{
  "dap/dap-3.10/examples/cda171.c": {
    "main": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void main()\n{\n  infile(\"cda171.dat\", \" \")\n    {\n      char defendant[6], victim[6], penalty[4];\n      double n;\n      input(\"defendant victim penalty n\");\n      outset(\"cda171\", \"\");\n      skip(2);\n      while (step())\n        output();\n    }\n\n  sort(\"cda171\", \"defendant victim penalty\", \"\");\n\n  title(\"(DV, P) vs (D, V, P)\");\n  loglin(\"cda171.srt\", \"n defendant victim penalty\",\n         \"victim penalty defendant\", \"defendant*victim penalty\", \"\");\n\n  sort(\"cda171.srt.llm\", \"defendant victim _type_ penalty\", \"\");\n  table(\"cda171.srt.llm.srt\", \"defendant victim\", \"_type_ penalty n\", \"s6.2 30\", \"\");\n    \n  title(\"(DV, VP) vs (DV, P)\");\n  loglin(\"cda171.srt\", \"n defendant victim penalty\",\n         \"defendant*victim penalty\", \"defendant*victim victim*penalty\", \"\");\n  sort(\"cda171.srt.llm\", \"defendant victim _type_ penalty\", \"\");\n  table(\"cda171.srt.llm.srt\", \"defendant victim\", \"_type_ penalty n\", \"s6.2 30\", \"\");\n  \n  title(\"(DV, DP, VP) vs (DV, VP)\");\n  loglin(\"cda171.srt\", \"n defendant victim penalty\",\n         \"defendant*victim victim*penalty\",\n         \"defendant*victim defendant*penalty victim*penalty\", \"\");\n  sort(\"cda171.srt.llm\", \"defendant victim _type_ penalty\", \"\");\n  table(\"cda171.srt.llm.srt\", \"defendant victim\", \"_type_ penalty n\", \"s6.2 30\", \"\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/examples/cda262.c": {
    "main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void main()\n{\n  infile(\"cda262.dat\", \" \")\n    {\n      char Income[6], JobSat[10];\n      double income, jobsat, count;\n      input(\"Income JobSat count\");\n      outset(\"cda262\", \"\");\n      skip(1);\n      while (step())\n\t{\n\t  /* we have to convert to double for categ */\n          if (!strcmp(Income, \"<6\"))\n\t    income = 0.0;\n          else if (!strcmp(Income, \"6-15\"))\n\t    income = 1.0;\n          else if (!strcmp(Income, \"15-25\"))\n\t    income = 2.0;\n          else if (!strcmp(Income, \">25\"))\n\t    income = 3.0;\n\t  if (!strcmp(JobSat, \"VeryDis\"))\n\t    jobsat = 0.0;\n\t  else if (!strcmp(JobSat, \"LittleDis\"))\n\t    jobsat = 1.0;\n\t  else if (!strcmp(JobSat, \"ModSat\"))\n\t    jobsat = 2.0;\n\t  else if (!strcmp(JobSat, \"VerySat\"))\n\t    jobsat = 3.0;\n\t  output();\n\t}\n    }\n\n  {\n    double param[8];\n    int p;\n\n    param[0] = 1.0;\n    for (p = 1; p < 8; p++)\n      param[p] = 0.0;\n    categ(\"cda262\", \"count income jobsat\", \"\", &expect, param,\n\t  \"mu <6 6-15 15-25 VeryDis LittleDis ModSat ?Inc*Sat\", \"\", \"\");\n    sort(\"cda262.cat\", \"income _type_ jobsat\", \"\");\n    table(\"cda262.cat.srt\", \"income\", \"_type_ jobsat count\", \"6.2\", \"\");\n  }\n}",
      "lines": 45,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "expect": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "double expect(double param[8], double class[2])\n{\n  double lx, ly;\n\n  if (class[0] < 3.0)\n    lx = param[1 + (int) class[0]];\n  else\n    lx = -(param[1] + param[2] + param[3]);\n  if (class[1] < 3.0)\n    ly = param[4 + (int) class[1]];\n  else\n    ly = -(param[4] + param[5] + param[6]);\n  return exp(param[0] + lx + ly + param[7] * class[0] * class[1]);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "double"
      ]
    }
  },
  "dap/dap-3.10/examples/custom.c": {
    "main": {
      "start_point": [
        11,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void main()\n{\n /* these variables are not in the datasets */\ndouble min, max;  /* extremes of both\n                   * distributions together\n                   */\ndouble width;     /* width of the bars */\n\ninfile(\"custom.dat\", \" \")\n  {\n    double x;\n    int part;\n\n    input(\"x part\");\n    outset(\"split\", \"\");\n    while (step())\n      output();\n  }\nmeans(\"split\", \"x\", \"MIN MAX\", \"\"); /* find min, max */\ninset(\"split.mns\")\n  {\n    double x;\n    int n;\n    char _type_[9];\n\n    for (n = 0; n < 2; n++)\n      {\n        step();             /* and store them */\n        if (!strcmp(_type_, \"MIN\"))\n          min = x;\n        else\n          max = x;\n      }\n  }\n\nwidth = (max - min) / ((double) NBARS);\n\ninset(\"split\")      /* compute class for each x */\n  {\n    double x;\n    int class;\n\n    outset(\"class\", \"x class part\");\n    while (step())\n      {\n        class = (int) floor((x - min) / width);\n        if (class < 0)\n          class = 0;\n        else if (class > NBARS - 1)\n          class = NBARS - 1;\n        output();\n      }\n  }\n\nsort(\"class\", \"part class\", \"\");\n/* compute counts in each class for each distribution */\nmeans(\"class.srt\", \"count\", \"N\", \"part class\");\n\n  {\n  pict p[21];  /* one pict for each class for each part\n                * plus one for the axes\n                */\n  int pn;\n\n  pict_initpict(NULL, p);  /* initialize the pict structs */\n  for (pn = 1; pn < 21; pn++)\n    pict_initpict(p + pn - 1, p + pn);\n\n  inset(\"class.srt.mns\")\n    {\n      int part, class;\n      double classmin, count;\n\n      while (step())\n        {\n          classmin = min + width * ((double) class);\n          /* make a rectangle */\n          pict_rectangle(p + NBARS * part + class,\n              0.0, classmin, (part ? count : -count), width);\n          /* shade the ones on the right */\n          if (part)\n            p[NBARS * part + class].pict_fgray = 0.8;\n        }\n    }\n  /* set up the axes */\n  pict_autoaxes(p, \"Count\", \"X\", \"==\", &fabs, NULL,\n                          \"Split histogram\", 1);\n  /* and make it all appear */\n  pict_port(1);\n  pict_page();\n  pict_show(p);\n  pict_end();\n  }\n}",
      "lines": 94,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/examples/standard.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "void main()\n{\ninfile(\"standard.dat\", \" \")\n  {\n    int part;\n    double x, y;\n\n    input(\"x y part\");\n    outset(\"mtest\", \"\");\n    while (step())\n      output();\n  }\n\ntitle(\"Means of y\\nError bars are 95% confidence for means\");\n  {\n    pict *p;\n\n    sort(\"mtest\", \"part x\", \"\");\n    p = plotmeans(\"mtest.srt\", \"y\", \"x\", \"SEM 1.96\", \"==\", \"part\", 2);\n/* p[0] and p[1] are error bars and means as points for group 1 */\n    strcpy(p[1].pict_type, \"TRIA\");\n/* p[2] and p[3] are error bars and means as points for group 2 */\n    strcpy(p[3].pict_type, \"SQUA\");\n\n    nport(p, 4, 4);\n  }\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dap.c": {
    "ecopy": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "char *ecopy(char *e)\n{\n  char *copy;\n\n  if (e)\n    {\n      if (!(copy = malloc(strlen(e) + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n      strcpy(copy, e);\n      return copy;\n    }\n  return NULL;\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "char",
        "*ecopy(char *e)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  int runstat;\t/* return status of execution of program */\n\n  fputs(\"\\nDap, Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\\n\",\n\tstderr);\n  fputs(\"Dap comes with ABSOLUTELY NO WARRANTY;\\n\", stderr);\n  fputs(\"for details see the GNU Public License.\\n\", stderr);\n  fputs(\"This is free software, and you are welcome to\\n\", stderr);\n  fputs(\"redistribute it under certain conditions; see\\n\", stderr);\n  fputs(\"the GNU Public License for details.\\n\\n\", stderr);\n\n  if (argc < 2)\n    {\n      fputs(\"dap: no files to process\\n\", stderr);\n      exit(1);\n    }\n  if (argc <= 1 || (!strcmp(argv[1], \"--help\") || !strcmp(argv[1], \"-h\")))\n    {\n      fputs(\"Usage:\\ndap [-k] [-d] FILE1.c [ FILE2.c ... ] [-a ARG1 ...]\\n\", stderr);\n      fputs(\"dap [--keep] [--debug] FILE1.c [ FILE2.c ... ] [--args] ARG1 ...]\\n\", stderr);\n      fputs(\"dap [-k] [-d] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n      fputs(\"dap [--keep] [--debug] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n      fputs(\"\\nReport bugs to <bug-dap@gnu.org>\\n\", stderr);\n      exit(1);\n    }\n  else if (argc == 2 && argv[1][0] == '-')\n    {\n      if (!strcmp(argv[1], \"--version\") || !strcmp(argv[1], \"-v\"))\n\t{\n\t  fputs(\"Dap 3.6\\n\", stderr);\n\t  exit(1);\n\t}\n      else\n\t{\n\t  fprintf(stderr, \"dap: bad option: %s\\n\", argv[0]);\n\t  exit(1);\n\t}\n    }\n  if (!(editor = ecopy(getenv(\"DAPEDITOR\"))))\n    editor = ED;\n  if (!(edopts = ecopy(getenv(\"DAPEDOPTS\"))))\n    edopts = NULL;\n  if (!(dappp = ecopy(getenv(\"DAPPP\"))))\n    dappp = DAPPP;\n  if (!(dapruns = ecopy(getenv(\"DAPRUNS\"))))\n    dapruns = DAPRUNS;\n  if (!(incdir = ecopy(getenv(\"INCDIR\"))))\n    incdir = INCDIR;\n  if (!(libdir = ecopy(getenv(\"LIBDIR\"))))\n    libdir = LIBDIR;\n  edrun(argc, argv);\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "srctype": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int srctype(char *name)\n{\n  int n;\n\n  n = strlen(name);\n  if (n > 2 && !strcmp(name + n - 2, \".c\"))\n    return C;\n  else if (n > 4 && !strcmp(name + n - 4, \".sbs\"))\n    return SBS;\n  else\n    {\n      fprintf(stderr, \"dap: name must end in .c or .sbs: %s\\n\", name);\n      exit(1);\n    }\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "edrun": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "void edrun(int argc, char **argv)\n{\n  char **arg;\t/* copy of arguments, modified */\n  int av;\t\t/* index to argv */\n  int a;\t\t/* index to arguments */\n  char *argstr;\t/* original argument list, as string */\n  int argstrlen;\t/* length of argument list, as string */\n  int argstart;      /* start of arguments following options */\n\n  if (!(arg = (char **) malloc(sizeof(char *) *\n\t\t\t       (argc + 5 + parseopts(edopts, NULL)))))\n    {\t/* + 5 for .log, .lst, .c, --eval, (shell-command \"dapruns ... &\") */\n      perror(\"dap\");\n      exit(1);\n    }\n  a = 0;\n  for (argstart = 1; argstart < argc && argv[argstart][0] == '-'; argstart++)\n    ;\n  arg[a++] = argcpy(argv[argstart], 0);\n  a += parseopts(edopts, arg + a);\n  arg[a] = argcpy(argv[argstart], 4);\n  suffix(arg[a++], \".log\");\n  arg[a] = argcpy(argv[argstart], 4);\n  suffix(arg[a++], \".lst\");\n  switch (srctype(argv[argstart]))\n    {\n    case C:\n      arg[a] = argcpy(argv[argstart], 2);\n      suffix(arg[a++], \".c\");\n      break;\n    case SBS:\n      arg[a] = argcpy(argv[argstart], 4);\n      suffix(arg[a++], \".sbs\");\n      break;\n    }\n  /* now put arguments back into a string\n   */\n  for (argstrlen = strlen(\"(shell-command \\\" &\\\")\") + strlen(dapruns) + 1, av = 1;\n       av < argc; av++)\n    argstrlen += strlen(argv[av] + 1);\n  argstr = malloc(argstrlen);\n  sprintf(argstr, \"(shell-command \\\"%s \", dapruns);\n  for (av = 1; av < argc; av++)\n    {\n      strcat(argstr, argv[av]);\n      strcat(argstr, \" \");\n    }\n  strcat(argstr, \"&\\\")\");\n  arg[a++] = \"--eval\";\n  arg[a++] = argstr;\n  /* Only use arguments preceding \"-a\"; arguments following \"-a\"\n   * are arguments to program  \n   */\n  for (av = argstart + 1;\n       av < argc && strcmp(argv[av], \"-a\") && strcmp(argv[av], \"--args\"); av++)\n    arg[a++] = argv[av];\n  arg[a] = NULL;\n  execv(editor, arg);\n  perror(editor);\n  exit(1);\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "suffix": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "void suffix(char name[], char suff[])\n{\n  int n;\n\n  n = strlen(name);\n  if (n > 2 && !strcmp(name + n - 2, \".c\"))\n    {\n      name[n - 2] = '\\0';\n      strcat(name, suff);\n    }\n  else if (n > 4 && !strcmp(name + n - 4, \".sbs\"))\n    {\n      name[n - 4] = '\\0';\n      strcat(name, suff);\n    }\n  else\n    {\n      fprintf(stderr, \"dap: name must end in .c or .sbs: %s\\n\", name);\n      exit(1);\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "argcpy": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "char *argcpy(char arg[], int extra)\n{\n  char *cpy;\n\n  if (!(cpy = malloc(strlen(arg) + extra + 1)))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  strcpy(cpy, arg);\n  return cpy;\n}",
      "lines": 12,
      "depth": 14,
      "decorators": [
        "char",
        "*argcpy(char arg[], int extra)",
        "*"
      ]
    },
    "parseopts": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "int parseopts(char *opts, char **arg)\n{\n  static char *optcpy = NULL;\t/* copy of opts */\n  static int optlen = 0;\n  int i;\t\t/* index to opts */\n  int a;\t\t/* arg count */\n\n  if (!opts)\n    return 0;\n  if (strlen(opts) > optlen)\n    {\n      if (optcpy)\n\tfree(optcpy);\n      optlen = strlen(opts);\n      if (!(optcpy = malloc(optlen + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n    }\n  strcpy(optcpy, opts);\n  for (i = 0; optcpy[i] == ' '; i++)\n    ;\n  for (a = 0; optcpy[i]; a++)\n    {\n      if (arg)\n\targ[a] = optcpy + i;\n      while (optcpy[i] && optcpy[i] != ' ')\n\ti++;\n      if (optcpy[i])\n\t{\n\t  if (arg)\n\t    optcpy[i] = '\\0';\n\t  for (i++; optcpy[i] == ' '; i++)\n\t    ;\n\t}\n    }\n  return a;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/dap.h": {},
  "dap/dap-3.10/src/dap0.c": {
    "dap_malloc": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "char *dap_malloc(int nbytes, char *mesg)\n{\n  char *m;\n\n  nmallocs++;\n  if (!(m = malloc(nbytes)))\n    {\n      perror(dap_dapname);\n      exit(1);\n    }\n  if (dap_memtrace)\n    {\n      fprintf(dap_log, \"malloc %x %s\\n\", (unsigned int) m, mesg);\n      fflush(dap_log);\n      if (dap_mabort && m == dap_memtrace)\n\tabort();\n    }\n  return m;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "char",
        "*dap_malloc(int nbytes, char *mesg)",
        "*"
      ]
    },
    "dap_free": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void dap_free(void *ptr, char *mesg)\n{\n  nfrees++;\n  if (dap_memtrace)\n    {\n      fprintf(dap_log, \"free %x %s\\n\", (unsigned int) ptr, mesg);\n      fflush(dap_log);\n      if (dap_fabort && ptr == dap_memtrace)\n\tabort();\n    }\n  free(ptr);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "initdo": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void initdo(dataobs *dato)\n{\n  int d;\n\n  dato->do_int = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"initdo: dato->do_int\");\n  dato->do_il = (int **) dap_malloc(sizeof(int *) * dap_maxvar, \"initdo: dato->do_il\");\n  dato->do_dbl = (double *) dap_malloc(sizeof(double) * dap_maxvar, \"initdo: dato->do_dbl\");\n  dato->do_dl = (double **) dap_malloc(sizeof(double *) * dap_maxvar, \"initdo: dato->do_dl\");\n  dato->do_str = (char **) dap_malloc(sizeof(char *) * dap_maxvar, \"initdo: dato->do_str\");\n  dato->do_sl = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"initdo: dato->do_sl\");\n  dato->do_nam = (char **) dap_malloc(sizeof(char *) * dap_maxvar, \"initdo: dato->do_nam\");\n  dato->do_len = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"initdo: dato->do_len\");\n  dato->do_in = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"initdo: dato->do_in\");\n  dato->do_out = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"initdo: dato->do_out\");\n  for (d = 0; d < dap_maxvar; d++)\n    {\n      dato->do_str[d] = NULL;\n      dato->do_nam[d] = NULL;\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  char *lstname;\t\t/* name of .lst file */\n  char *logname;\t\t/* name of .log file */\n  char *errname;\t\t/* name of .err file */\n  int len;\t\t/* length of lstname, logname, errname */\n  int v;\t\t\t/* index to variables */\n\n  dap_dapname = argv[0];\n  len = strlen(argv[0]);\n  lstname = malloc(len + 5);\t/* room for suffix */\n  strcpy(lstname, argv[0]);\n  if (len >= 4 && !strcmp(lstname + len - 4, \".dap\"))\n    strcpy(lstname + len - 3, \"lst\");\n  else\n    {\n      strcat(lstname, \".lst\");\n      len += 4;\n    }\n  if (!(dap_lst = fopen(lstname, \"a\")))\n    {\n      perror(dap_dapname);\n      exit(1);\n    }\n  logname = malloc(len + 1);\n  strcpy(logname, lstname);\n  strcpy(logname + len - 3, \"log\");\n  if (!(dap_log = fopen(logname, \"w\")))\n    {\n      perror(dap_dapname);\n      exit(1);\n    }\n  errname = malloc(len + 1);\n  strcpy(errname, lstname);\n  strcpy(errname + len - 3, \"err\");\n  if (!(dap_err = fopen(errname, \"w\")))\n    {\n      perror(dap_dapname);\n      exit(1);\n    }\n  initdo(dap_obs);\n  initdo(dap_obs + 1);\n  initdo(dap_obs + 2);\n  initdo(dap_prev);\n  initdo(dap_prev + 1);\n  initdo(&dosave);\n  rfile = (RFILE *) dap_malloc(sizeof(RFILE) * dap_nrfiles, \"main: rfile\");\n  dfile = (DFILE *) dap_malloc(sizeof(DFILE) * (dap_nrfiles + NDFILES), \"main: dfile\");\n  pageno = 1;\n  dap_psname = dap_malloc(len + 1, \"main: dap_psname\");\n  strcpy(dap_psname, lstname);\n  strcpy(dap_psname + len - 3, \"ps\");\n  dap_initpict();\n  for (v = 0; v < dap_maxvar; v++)\n    {\n      for (dap_ono = 0; dap_ono < 3; dap_ono++)\n\t{\n\t  dap_obs[dap_ono].do_nam[v] = NULL;\n\t  dap_obs[dap_ono].do_dl[v] = NULL;\n\t  dap_obs[dap_ono].do_il[v] = NULL;\n\t  dap_obs[dap_ono].do_str[v] = NULL;\n\t  dap_obs[dap_ono].do_sl[v] = 0;\n\t  if (dap_ono < 2)\n\t    dap_prev[dap_ono].do_str[v] = NULL;\n\t}\n      dosave.do_str[v] = NULL;\n    }\n  dap_ono = 0;\n  testd = -2.0; /* this should have the sign bit set and non-zero exponent, but\n\t\t   /* zero mantissa\n\t\t    */\n  ptesti = (int *) &testd; /* *ptesti is the low order word of testd */\n  if (!(*ptesti))\n    { /* if that's zero, then the sign and exponent are in the high-order word */\n      dap_dbllow = 0;\n      dap_dblhigh = 1;\n    }\n  else\n    { /* else they're in the low-order word */\n      dap_dbllow = 1;\n      dap_dblhigh = 0;\n    }\n  for (v = 0; v < 3; v++)\n    {\n      dap_in[v] = (DFILE *) NULL;\n      dap_out[v] = (DFILE *) NULL;\n    }\n  dap_main(argc, argv);\n  return 0;\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dopen": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static FILE *dopen(char fname[], char mode[])\n{\n  char *dname;\n  FILE *f;\n\n  dname = dap_malloc(strlen(fname) + strlen(dap_setdir) + 2, \"dopen: dname\");\n  dap_name(dname, fname);\n  f = fopen(dname, mode);\n  dap_free(dname, \"dopen: dname\");\n  return f;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*dopen(char fname[], char mode[])",
        "*"
      ]
    },
    "dfopen": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static DFILE *dfopen(char *fname, char *mode)\n{\n  static int rfileinit = 0;\t/* flag: has the ramfile array been initialized? */\n  int f;\n  char truemode[2];\n\n  if (!rfileinit)\n    {\n      rfileinit = 1;\n      for (f = 0; f < dap_nrfiles; f++)\n\t{\n\t  dfile[NDFILES + f].dfile_name = NULL;\n\t  dfile[NDFILES + f].dfile_ram = rfile + f;\n\t  dfile[NDFILES + f].dfile_disk = NULL;\n\t  rfile[f].rfile_str = NULL;\n\t}\n      for (f = 0; f < NDFILES; f++)\n\t{\n\t  dfile[f].dfile_disk = NULL;\n\t  dfile[f].dfile_ram = NULL;\n\t}\n    }\n  if (!fname)\n    {\n      fputs(\"(dfopen) no file name given\\n\", dap_err);\n      exit(1);\n    }\n  if (fname[0] == '<')\n    {\n      if (!strcmp(mode, \"r\"))\n\t{\n\t  for (f = 0; f < dap_nrfiles; f++)\n\t    {\n\t      if (dfile[NDFILES + f].dfile_name &&\n\t\t  !strcmp(dfile[NDFILES + f].dfile_name, fname + 1))\n\t\t{\n\t\t  rfile[f].rfile_pos = rfile[f].rfile_str;\n\t\t  return dfile + NDFILES + f;\n\t\t}\n\t    }\n\t  return NULL;\n\t}\n      else if (!strcmp(mode, \"w\"))\n\t{\n\t  for (f = 0; f < dap_nrfiles; f++)\n\t    {\n\t      if (dfile[NDFILES + f].dfile_name &&\n\t\t  !strcmp(dfile[NDFILES + f].dfile_name, fname + 1))\n\t\t{\n\t\t  rfile[f].rfile_end = rfile[f].rfile_str;\n\t\t  rfile[f].rfile_pos = rfile[f].rfile_str;\n\t\t  return dfile + NDFILES + f;\n\t\t}\n\t    }\n\t  for (f = 0; f < dap_nrfiles; f++)\n\t    {\n\t      if (!dfile[NDFILES + f].dfile_name)\n\t\t{\n\t\t  rfile[f].rfile_str = dap_malloc(dap_rfilesize,\n\t\t\t\t\t\t  \"dfopen: rfile[f].rfile_str\");\n\t\t  dfile[NDFILES + f].dfile_name =\n\t\t    dap_malloc(strlen(fname), \"dfopen: dfile[NDFILES + f].dfile_name\");\n\t\t  strcpy(dfile[NDFILES + f].dfile_name, fname + 1);\n\t\t  rfile[f].rfile_end = rfile[f].rfile_str;\n\t\t  rfile[f].rfile_pos = rfile[f].rfile_str;\n\t\t  return dfile + NDFILES + f;\n\t\t}\n\t    }\n\t  return NULL;\n\t}\n      else if (!strcmp(mode, \"a\"))\n\t{\n\t  for (f = 0; f < dap_nrfiles; f++)\n\t    {\n\t      if (!strcmp(dfile[NDFILES + f].dfile_name, fname + 1))\n\t\t{\n\t\t  rfile[f].rfile_pos = rfile[f].rfile_end;\n\t\t  return dfile + NDFILES + f;\n\t\t}\n\t    }\n\t  return NULL;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(dfopen) bad mode: %s\\n\", mode);\n\t  exit(1);\n\t}\n    }\n  for (f = 0; f < NDFILES; f++)\n    {\n      if (!dfile[f].dfile_disk)\n\t{\n\t  if (mode[1] == 'f')\n\t    {\n\t      truemode[0] = mode[0];\n\t      truemode[1] = '\\0';\n\t      dfile[f].dfile_disk = fopen(fname, truemode);\n\t    }\n\t  else\n\t    dfile[f].dfile_disk = dopen(fname, mode);\n\t  if (dfile[f].dfile_disk)\n\t    {\n\t      dfile[f].dfile_name =\n\t\tdap_malloc(strlen(fname) + 1, \"dfopen: dfile[f].dfile_name\");\n\t      strcpy(dfile[f].dfile_name, fname);\n\t      return dfile + f;\n\t    }\n\t  else\n\t    return NULL;\n\t}\n    }\n  return NULL;\n}",
      "lines": 113,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "DFILE",
        "*dfopen(char *fname, char *mode)",
        "*"
      ]
    },
    "dfclose": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static void dfclose(DFILE *fp)\n{\n  if (fp->dfile_disk)\n    {\n      fclose(fp->dfile_disk);\n      fp->dfile_disk = NULL;\n    }\n  else\n    fp->dfile_ram->rfile_pos = fp->dfile_ram->rfile_str;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dgetc": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static int dgetc(DFILE *fp)\n{\n  int c;\n\n  if (fp->dfile_disk)\n    c = getc(fp->dfile_disk);\n  else if (fp->dfile_ram->rfile_pos < fp->dfile_ram->rfile_end)\n    c = *fp->dfile_ram->rfile_pos++;\n  else\n    c = EOF;\n  return c;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "undgetc": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "static void undgetc(int c, DFILE *fp)\n{\n  if (fp->dfile_disk)\n    ungetc(c, fp->dfile_disk);\n  else if (fp->dfile_ram->rfile_pos > fp->dfile_ram->rfile_str)\n    {\n      --fp->dfile_ram->rfile_pos;\n      *fp->dfile_ram->rfile_pos = c;\n    }\n  else\n    {\n      fprintf(dap_err, \"(undgetc) can't unget past beginning of file %s\\n\",\n\t      fp->dfile_name);\n      exit(1);\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dap_putc": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void dap_putc(int c, DFILE *fp)\n{\n  if (fp->dfile_disk)\n    putc(c, fp->dfile_disk);\n  else if (fp->dfile_ram->rfile_pos < fp->dfile_ram->rfile_str + dap_rfilesize)\n    {\n      *fp->dfile_ram->rfile_pos++ = c;\n      fp->dfile_ram->rfile_end++;\n    }\n  else\n    {\n      fprintf(dap_err, \"(dap_putc) too many characters: %s\\n\",\n\t      fp->dfile_name);\n      exit(1);\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dputs": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static void dputs(char *s, char *suff, DFILE *fp)\n{\n  if (fp->dfile_disk)\n    {\n      fputs(s, fp->dfile_disk);\n      fputs(suff, fp->dfile_disk);\n    }\n  else\n    {\n      while (*s)\n\tdap_putc(*s++, fp);\n      while (*suff)\n\tdap_putc(*suff++, fp);\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dputi": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "static void dputi(int i, DFILE *fp)\n{\n  static char *istr = NULL;\n  int s;\n\n  if (!istr)\n    istr = dap_malloc(dap_intlen + 1, \"dputi: istr\");\n  if (fp->dfile_disk)\n    fprintf(fp->dfile_disk, \"%d\", i);\n  else\n    {\n      sprintf(istr, \"%d\", i);\n      for (s = 0; s < strlen(istr); s++)\n\tdap_putc(istr[s], fp);\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dflush": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static void dflush(DFILE *fp)\n{\n  fflush(fp->dfile_disk);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dap_suffix": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void dap_suffix(char dst[], char src[], char suff[])\n{\n  int n, s;\n\n  for (n = 0; src[n]; n++)\n    dst[n] = src[n];\n  if (suff[0] == '<')\n    {\n      while (--n >= 0)\n\t{\n\t  if (dst[n] == '.')\n\t    break;\n\t}\n      if (n < 0)\n\t{\n\t  fprintf(dap_err, \"(dap_suffix) source name has no '.': %s\\n\", src);\n\t  exit(1);\n\t}\n      n++;\n      s = 1;\n    }\n  else\n    s = 0;\n  for ( ; suff[s]; s++)\n    dst[n++] = suff[s];\n  dst[n] = '\\0';\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dap_varnum": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "int dap_varnum(char *vname)\n{\n  int v;\n  int nonblank; /* number of non-blank characters in vname */\n\n  while (*vname == ' ')\n    vname++;\n  for (nonblank = 0; vname[nonblank] && vname[nonblank] != ' '; nonblank++)\n    ;\n  if (vname)\n    {\n      for (v = 0; v < dap_obs[dap_ono].do_nvar; v++)\n\t{\n\t  if (!strncmp(vname, dap_obs[dap_ono].do_nam[v], nonblank) &&\n\t      !dap_obs[dap_ono].do_nam[v][nonblank])\n\t    return v;\n\t}\n    }\n  return -1;\n}",
      "lines": 20,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "dap_arrnum": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "int dap_arrnum(char vname[], int *dim)\n{\n  int v;\n  int n;\n  int d;\n\n  for (v = 0; v < dap_obs[dap_ono].do_nvar; v++)\n    {\n      for (n = 0; vname[n] && vname[n] == dap_obs[dap_ono].do_nam[v][n]; n++)\n\t;\n      if (!vname[n] && dap_obs[dap_ono].do_nam[v][n] == '[')\n\t{\n\t  for (d = 1; v + d < dap_obs[dap_ono].do_nvar; d++)\n\t    {\n\t      for (n = 0; vname[n] &&\n\t\t     vname[n] == dap_obs[dap_ono].do_nam[v + d][n]; n++)\n\t\t;\n\t      if (vname[n] || dap_obs[dap_ono].do_nam[v + d][n] != '[')\n\t\tbreak;\n\t    }\n\t  *dim = d;\n\t  return v;\n\t}\n    }\n  return -1;\n}",
      "lines": 26,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "dap_getline": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        601,
        1
      ],
      "content": "static int dap_getline(DFILE *fp, char *line)\n{\n  int l;\n  int c;\n  int cc;\n\n  c = EOF;\n  switch (intype)\n    {\n    case TEXT:\n    case DSET:\n      for (l = 0; (c = dgetc(fp)) != EOF; )\n\t{\n\t  if (c == '\\n')\n\t    break;\n\t  else if (c == '\\r')\n\t    {\n\t      if ((cc = dgetc(fp)) != '\\n')\n\t\tundgetc(cc, fp);\n\t      break;\n\t    }\n\t  if (l < dap_linelen)\n\t    line[l++] = c;\n\t  else\n\t    {\n\t      line[l] = '\\0';\n\t      fprintf(dap_err, \"(dap_getline) line too long:\\n%s\\n\", line);\n\t      exit(1);\n\t    }\n\t}\n      line[l] = '\\0';\n      break;\n    case DBASE:\n      dgetc(fp);      /* dump space */\n      for (l = 0; l < inlen; l++)\n\t{\n\t  if ((c = dgetc(fp)) == EOF)\n\t    break;\n\t  else\n\t    line[l] = c;\n\t}\n      if (l < inlen)\n\tl = 0;\n      line[l] = '\\0';\n      break;\n    default:\n      fprintf(dap_err, \"(dap_getline) bad infile type: %d\\n\", intype);\n      exit(1);\n    }\n  if (!l && c == EOF)\n    return -1;\n  return l;\n}",
      "lines": 53,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dap_swap": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "void dap_swap()\n{\n  int iv;\t\t/* index of input variable */\n  double dbltmp;\t/* temp for swapping doubles */\n  int inttmp;\t/* temp for swapping int */\n  char strtmp;\t/* temp char for swapping strings */\n  int s;\t\t/* index to strings */\n  char *so, *sp;\t/* pointers to strings for obs, prev */\n\n  for (iv = 0; iv < dap_obs[dap_ono].do_ivar; iv++)\n    {\n      switch (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]])\n\t{\n\tcase DBL:\n\t  dbltmp = dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_prev[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  dap_prev[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]] = dbltmp;\n\t  if (dap_obs[dap_ono].do_dl[dap_obs[dap_ono].do_in[iv]])\n\t    *dap_obs[dap_ono].do_dl[dap_obs[dap_ono].do_in[iv]] =\n\t      dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tcase INT:\n\t  inttmp = dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_prev[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  dap_prev[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]] = inttmp;\n\t  if (dap_obs[dap_ono].do_il[dap_obs[dap_ono].do_in[iv]])\n\t    *dap_obs[dap_ono].do_il[dap_obs[dap_ono].do_in[iv]] =\n\t      dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tdefault:\n\t  so = dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]];\n\t  sp = dap_prev[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]];\n\t  for (s = 0; s < dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]]; s++)\n\t    {\n\t      strtmp = so[s];\n\t      so[s] = sp[s];\n\t      sp[s] = strtmp;\n\t    }\n\t  break;\n\t}\n    }\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "dap_save": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "void dap_save()\n{\n  int iv;\n\n  for (iv = 0; iv < dap_obs[dap_ono].do_ivar; iv++)\n    {\n      switch (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]])\n\t{\n\tcase DBL:\n\t  dosave.do_dbl[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tcase INT:\n\t  dosave.do_int[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tdefault:\n\t  if (dosave.do_str[dap_obs[dap_ono].do_in[iv]])\n\t    dap_free(dosave.do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t     \"dap_save: dosave.do_str[dap_obs[dap_ono].do_in[iv]]\");\n\t  dosave.do_str[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_malloc(dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]] + 1,\n\t\t       \"dap_save: dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[iv]]\");\n\t  strncpy(dosave.do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]] + 1);\n\t  break;\n\t}\n    }\n}",
      "lines": 30,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "dap_rest": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "void dap_rest()\n{\n  int iv;\n\n  for (iv = 0; iv < dap_obs[dap_ono].do_ivar; iv++)\n    {\n      switch (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]])\n\t{\n\tcase DBL:\n\t  dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]] =\n\t    dosave.do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  if (dap_obs[dap_ono].do_dl[dap_obs[dap_ono].do_in[iv]])\n\t    *dap_obs[dap_ono].do_dl[dap_obs[dap_ono].do_in[iv]] =\n\t      dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tcase INT:\n\t  dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]] =\n\t    dosave.do_int[dap_obs[dap_ono].do_in[iv]];\n\t  if (dap_obs[dap_ono].do_il[dap_obs[dap_ono].do_in[iv]])\n\t    *dap_obs[dap_ono].do_il[dap_obs[dap_ono].do_in[iv]] =\n\t      dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tdefault:\n\t  strncpy(dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dosave.do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]] + 1);\n\t  break;\n\t}\n    }\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "dap_ftell": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "long dap_ftell(DFILE *fp)\n{\n  if (fp->dfile_disk)\n    return ftell(fp->dfile_disk);\n  return fp->dfile_ram->rfile_pos - fp->dfile_ram->rfile_str;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "long",
        "long"
      ]
    },
    "dap_mark": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "void dap_mark()\n{\n  filepos[dap_ono] = dap_ftell(dap_in[dap_ono]);\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dfseek": {
      "start_point": [
        722,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "static void dfseek(DFILE *fp, long pos, int mode)\n{\n  if (fp->dfile_disk)\n    fseek(fp->dfile_disk, pos, mode);\n  else\n    {\n      if (fp->dfile_ram->rfile_str + pos < fp->dfile_ram->rfile_end)\n\tfp->dfile_ram->rfile_pos = fp->dfile_ram->rfile_str + pos;\n      else\n\t{\n\t  fprintf(dap_err, \"(dfseek) seek past end of ramfile %s\\n\",\n\t\t  fp->dfile_name);\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dap_rewind": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "void dap_rewind()\n{\n  if (dap_in[dap_ono])\n    {\n      if (filepos[dap_ono] < dap_ftell(dap_in[dap_ono]))\n\teof[dap_ono] = 0;\n      dfseek(dap_in[dap_ono], filepos[dap_ono], SEEK_SET);\n      dap_obs[dap_ono].do_valid = 0;\n    }\n  else\n    {\n      fprintf(dap_err, \"(dap_rewind) file (%d) is closed.\\n\", dap_ono);\n      exit(1);\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dap_blank": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "int dap_blank(char str[])\n{\n  int b;\n\n  for (b = 0; str[b] == ' '; b++)\n    ;\n  if (str[b])\n    return 0;\n  return 1;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "skip": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "void skip(int nlines)\n{\n  char *line;\n\n  line = dap_malloc(dap_linelen + 1, \"skip: line\");\n  while (--nlines >= 0)\n    {\n      if (!dap_in[dap_ono] || eof[dap_ono])\n\t{\n\t  fprintf(dap_err, \"(skip) tried to read past end of file (%d).\\n\",\n\t\t  dap_ono);\n\t  exit(1);\n\t}\n      if (dap_getline(dap_in[dap_ono], line) < 0)\n\teof[dap_ono] = 1;\n      lineno[dap_ono]++;\n    }\n  dap_free(line, \"skip: line\");\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "step": {
      "start_point": [
        786,
        0
      ],
      "end_point": [
        969,
        1
      ],
      "content": "int step()\n{\n  static int stepinit = 0; /* need to initialize \"line\" and \"value\" */\n  static char *line = NULL; /* line read */\n  static char *value = NULL;\n  int v;\t\t\t\t/* index to variables */\n  int l;\n  int i;\n  int iv;\n  int nread;\t/* number of chars read by dap_getline */\n\n  if (!stepinit)\n    {\n      stepinit = 1;\n      line = dap_malloc(dap_linelen + 1, \"step: line\");\n      value = dap_malloc(dap_linelen + 1, \"step: value\");\n    }\n  if (!dap_in[dap_ono] || eof[dap_ono])\n    {\n      fprintf(dap_err, \"(step) ERROR: tried to read past end of file (%s).\\n\",\n\t      (dap_in[dap_ono] ? dap_in[dap_ono]->dfile_name : \"?\"));\n      exit(1);\n    }\n  /* copy most recently read line to prev */\n  for (iv = 0; iv < dap_obs[dap_ono].do_ivar; iv++)\n    {\n      switch (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]])\n\t{\n\tcase DBL:\n\t  dap_prev[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tcase INT:\n\t  dap_prev[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]] =\n\t    dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[iv]];\n\t  break;\n\tdefault:\n\t  strncpy(dap_prev[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[iv]],\n\t\t  dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[iv]] + 1);\n\t}\n    }\n  dap_prev[dap_ono].do_valid = dap_obs[dap_ono].do_valid;\n  if ((nread = dap_getline(dap_in[dap_ono], line)) <= 0)\n    {\n      eof[dap_ono] = 1;\n      dap_obs[dap_ono].do_valid = 0;\n      fprintf(stderr, \"(step) %d lines read from %s\\n\",\n\t      lineno[dap_ono] - 1, dap_in[dap_ono]->dfile_name);\n      if (!nread)\n\tfputs(\"(step) WARNING: terminated on null line\\n\", stderr);\n      fflush(stderr);\n      fprintf(dap_log, \"(step) %d lines read from  %s\\n\",\n\t      lineno[dap_ono] - 1, dap_in[dap_ono]->dfile_name);\n      if (!nread)\n\tfputs(\"(step) WARNING: terminated on null line\\n\", dap_log);\n      return 0;\n    }\n  if (nfields && dap_obs[dap_ono].do_ivar != nfields)\n    {\n      fprintf(dap_err,\n\t      \"(step) ERROR: number of input variables %d different from number of fields specified %d for %s.\\n\",\n\t      dap_obs[dap_ono].do_ivar, nfields, dap_in[dap_ono]->dfile_name);\n      exit(1);\n    }\n  /* convert input variables */\n  for (v = 0, l = 0; v < dap_obs[dap_ono].do_ivar; v++)\n    {\n      if (nfields)\n\t{\n\t  for (i = 0; line[l + i] && i < fieldwd[v]; i++)\n\t    value[i] = line[l + i];\n\t  value[i] = '\\0';\n\t  if (i < fieldwd[v])\n\t    {\n\t      fprintf(dap_log,\n\t\t      \"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\\n\",\n\t\t      dap_in[dap_ono]->dfile_name,\n\t\t      lineno[dap_ono], i, fieldwd[v],\n\t\t      dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[v]],\n\t\t      value);\n\t      fprintf(dap_err,\n\t\t      \"(step (%s:%d)) ERROR: got %d of %d characters for fixed length field for %s: %s\\n\",\n\t\t      dap_in[dap_ono]->dfile_name,\n\t\t      lineno[dap_ono], i, fieldwd[v],\n\t\t      dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[v]],\n\t\t      value);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  for (i = 0; line[l + i] && line[l + i] != dap_delim; i++)\n\t    value[i] = line[l + i];\n\t  value[i] = '\\0';\n\t}\n      if (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]] == INT)\n\t{\n\t  if (intype == DSET)\n\t    dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[v]] = dap_getint(value);\n\t  else if (sscanf(value, \" %d\",\n\t\t\t  dap_obs[dap_ono].do_int + dap_obs[dap_ono].do_in[v]) != 1)\n\t    {\n\t      if (dap_blank(value))\n\t\tdap_obs[dap_ono].do_int[dap_obs[dap_ono].do_in[v]] = 0;\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(step (%s:%d)) ERROR: invalid integer data for %s: %s\\n\",\n\t\t\t  dap_in[dap_ono]->dfile_name,\n\t\t\t  lineno[dap_ono],\n\t\t\t  dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[v]],\n\t\t\t  value);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  /* if we're in an infile statement, may need to update the value\n\t   * from the value in the user's program\n\t   */\n\t  if (!dap_ono && dap_obs[dap_ono].do_il[dap_obs[0].do_in[v]])\n\t    *dap_obs[dap_ono].do_il[dap_obs[0].do_in[v]] =\n\t      dap_obs[0].do_int[dap_obs[0].do_in[v]];\n\t}\n      else if (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]] == DBL)\n\t{\n\t  if (intype == DSET)\n\t    {\n\t      dap_getdouble(value);\n\t      dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[v]] = dap_double;\n\t    }\n\t  else\n\t    {\n\t      if (!i || (nfields && dap_blank(value)) || !strcmp(value, \".\"))\n\t\tdap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_in[v]] = 0.0 / 0.0;\n\t      else if (sscanf(value, \" %lf\",\n\t\t\t      dap_obs[dap_ono].do_dbl + dap_obs[dap_ono].do_in[v]) != 1)\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(step (%s:%d)) ERROR: invalid double data for %s: %s\\n\",\n\t\t\t  dap_in[dap_ono]->dfile_name,\n\t\t\t  lineno[dap_ono],\n\t\t\t  dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[v]],\n\t\t\t  value);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  /* if we're in an infile statement, may need to update the value\n\t   * from the value in the user's program\n\t   */\n\t  if (!dap_ono && dap_obs[dap_ono].do_dl[dap_obs[0].do_in[v]])\n\t    *dap_obs[dap_ono].do_dl[dap_obs[0].do_in[v]] =\n\t      dap_obs[0].do_dbl[dap_obs[0].do_in[v]];\n\t}\n      else\n\t{\n\t  if (i <= dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]])\n\t    strcpy(dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[v]], value);\n\t  else\n\t    {\n\t      strncpy(dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[v]],\n\t\t      value, dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]]);\n\t      dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_in[v]]\n\t\t[dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]]] = '\\0';\n\t      if (toolong < dap_toolong)\n\t\t{\n\t\t  fprintf(dap_log,\n\t\t\t  \"(step (%s:%d)) WARNING: string data too long (%d) for %s (%d): %s\\n\",\n\t\t\t  dap_in[dap_ono]->dfile_name,\n\t\t\t  lineno[dap_ono], i,\n\t\t\t  dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_in[v]],\n\t\t\t  dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_in[v]],\n\t\t\t  value);\n\t\t  toolong++;\n\t\t}\n\t    }\n\t}\n      l += i;\n      if (!nfields && line[l] == dap_delim)\n\tl++;\n    }\n  dap_obs[dap_ono].do_valid = 1;\n  lineno[dap_ono]++;\n  return 1;\n}",
      "lines": 184,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "dap_vd": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        1114,
        1
      ],
      "content": "int dap_vd(char *varspec, int invar)\n{\n  int s;\t\t/* base index to varspec */\n  int i;\t\t/* supplemental index to varspec */\n  char *varnam;\t/* name of variable, extracted from varspec */\n  int sign;\t/* for getting negative number */\n  int v;\t\t/* index of variable */\n  int vlen;\t/* length parameter for variable */\n  int redeclare;\t/* is variable being redeclared? */\n\n  v = -1;\t\t/* non-existent until proven otherwise */\n  varnam = dap_malloc(strlen(varspec), \"dap_vd: varnam\");\t/* allocate string for names */\n  for (s = 0; varspec[s] == ' '; )\t/* skip leading spaces */\n    s++;\n  while (varspec[s])\t/* while more specs to process */\n    {\n      if (dap_obs[dap_ono].do_nvar < dap_maxvar)\n\t{\t\t/* is there room for another variable? */\n\t  /***** seems as though a redeclare shouldn't have to check this, not really\n\t   ***** a problem, but could waste some space\n\t   *****/\n\t  for (i = 0; varspec[s + i] && varspec[s + i] != ' '; i++)\n\t    varnam[i] = varspec[s + i];\n\t  varnam[i] = '\\0';\t/* name copied, i = length */\n\t  if ((v = dap_varnum(varnam)) < 0)\n\t    {\t/* if it doesn't already exist */\n\t      redeclare = 0;\t/* not being redeclared */\n\t      v = dap_obs[dap_ono].do_nvar;\t/* its index is current nvar */\n\t      /* variable with that index is not being used, but entry may\n\t       * still have a name from before, so clear it\n\t       */\n\t      if (dap_obs[dap_ono].do_nam[v])\n\t\tdap_free(dap_obs[dap_ono].do_nam[v],\n\t\t\t \"dap_vd: dap_obs[dap_ono].do_nam[v]\");\n\t      /* allocate space for new name */\n\t      dap_obs[dap_ono].do_nam[v] =\n\t\tdap_malloc(i + 1,\n\t\t\t   \"dap_vd: dap_obs[dap_ono].do_nam[v]\");\n\t      /* and enter the name */\n\t      strcpy(dap_obs[dap_ono].do_nam[v], varnam);\n\t      /* if it's going to be read from file, indicate in the\n\t       * do_in array and count\n\t       */\n\t      if (invar)\n\t\tdap_obs[dap_ono].do_in[dap_obs[dap_ono].do_ivar++] = v;\n\t    }\n\t  else\n\t    redeclare = 1;\t/* variable already exists */\n\t  /* now get the length specification; first skip spaces, if any */\n\t  while (varspec[s + i] && varspec[s + i] == ' ')\n\t    i++;\n\t  if (!varspec[s + i])\n\t    {\t/* ooops, nothing there */\n\t      fprintf(dap_err, \"(dap_vd) missing variable length: %s\\n\",\n\t\t      varspec + s);\n\t      exit(1);\n\t    }\n\t  s += i;\n\t  if (varspec[s] == '-')\n\t    {\t/* negative value */\n\t      sign = -1;\n\t      for (s++; varspec[s] == ' '; s++)\n\t\t;\t/* skip spaces, if any */\n\t    }\n\t  else\n\t    sign = 1;\t/* positive value */\n\t  /* now convert character string to integer */\n\t  for (i = 0, vlen = 0; '0' <= varspec[s + i] && varspec[s + i] <= '9'; i++)\n\t    vlen = 10 * vlen + varspec[s + i] - '0';\n\t  vlen *= sign;\t/* and incorporate sign */\n\t  if (redeclare)\n\t    {\t/* check that redeclaration doesn't change length */\n\t      if (dap_obs[dap_ono].do_len[v] != vlen)\n\t\t{\n\t\t  if (vlen > 0 && dap_obs[dap_ono].do_len[v] > 0)\n\t\t    fprintf(dap_err,\n\t\t\t    \"(dap_vd) respecification of length of %s from %d to %d\\n\",\n\t\t\t    varnam, dap_obs[dap_ono].do_len[v] + 1, vlen + 1);\n\t\t  else\n\t\t    fprintf(dap_err,\n\t\t\t    \"(dap_vd) respecification of type of %s\\n\",\n\t\t\t    varnam);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\t/* for new declaration, use specified length */\n\t    dap_obs[dap_ono].do_len[v] = vlen;\n\t  if (varspec[s + i] && varspec[s + i] != ' ')\n\t    {\t/* nothing should follow length but a space */\n\t      fprintf(dap_err,\n\t\t      \"(dap_vd) invalid variable length for %s: %s\\n\",\n\t\t      varnam, varspec + s);\n\t      exit(1);\n\t    }\n\t  if (!redeclare && vlen > 0)\n\t    {\t/* bookkeeping for setting up new string variable */\n\t      /* if it's not linked to \"user\" program name and there's\n\t       * a left-over string from previous use, free it\n\t       */\n\t      if (!dap_obs[dap_ono].do_sl[v] && dap_obs[dap_ono].do_str[v])\n\t\tdap_free(dap_obs[dap_ono].do_str[v],\n\t\t\t \"dap_vd: dap_obs[dap_ono].do_str[v]\");\n\t      /* if need to free string from previous line dataobs, do it */\n\t      if (dap_ono < 2 && dap_prev[dap_ono].do_str[v])\n\t\tdap_free(dap_prev[dap_ono].do_str[v],\n\t\t\t \"dap_vd: dap_prev[dap_ono].do_str[v]\");\n\t      /* allocate space for new string variable */\n\t      dap_obs[dap_ono].do_str[v] =\n\t\tdap_malloc(vlen + 1,\n\t\t\t   \"dap_vd: dap_obs[dap_ono].do_str[v]\");\n\t      /* indicate not linked to \"user\" program variable */\n\t      dap_obs[dap_ono].do_sl[v] = 0;\n\t      /* allocate space in previous line dataobs */\n\t      if (dap_ono < 2)\n\t\tdap_prev[dap_ono].do_str[v] =\n\t\t  dap_malloc(vlen + 1,\n\t\t\t     \"dap_vd: dap_prev[dap_ono].do_str[v]\");\n\t    }\n\t  if (vlen == DBL)\t/* initialize doubles to NaN */\n\t    dap_obs[dap_ono].do_dbl[v] = 0.0 / 0.0;\n\t  else if (vlen == INT)\t/* initialize ints to 0 */\n\t    dap_obs[dap_ono].do_int[v] = 0;\n\t  else\t\t\t/* initialize strings to null */\n\t    dap_obs[dap_ono].do_str[v][0] = '\\0';\n\t  s += i;\t\t/* advance to next spec, if any */\n\t  while (varspec[s] == ' ')\t/* and skip spaces */\n\t    s++;\n\t}\n      else\t\t/* no room for another variable */\n\t{\n\t  fprintf(dap_err, \"(dap_vd) too many variables: %s\\n\", varspec + s);\n\t  exit(1);\n\t}\n      if (!redeclare)\t\t/* if not just redeclaration of one already there */\n\tdap_obs[dap_ono].do_nvar++;\t/* update number of variables */\n    }\n  dap_free(varnam, \"dap_vd: varnam\");\t/* free memory allocation */\n  return v;\t\t/* and return index of last (or only) variable */\n}",
      "lines": 139,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "dap_dl": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1144,
        1
      ],
      "content": "void dap_dl(char varname[], double *dbl)\n{\n  int v;\n  int dim;\n  int d;\n\n  if ((v = dap_varnum(varname)) >= 0)\n    {\n      dap_obs[dap_ono].do_dl[v] = dbl;\n      *dbl = 0.0 / 0.0;\n    }\n  else\n    {\n      if ((v = dap_arrnum(varname, &dim)) > 0)\n\t{\n\t  for (d = 0; d < dim; d++)\n\t    {\n\t      dap_obs[dap_ono].do_dl[v + d] = dbl + d;\n\t      dbl[d] = 0.0 / 0.0;\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(dap_dl) unknown variable %s\\n\", varname);\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "dap_il": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "void dap_il(char varname[], int *i)\n{\n  int v;\n  int dim;\n  int d;\n\n  if ((v = dap_varnum(varname)) > 0)\n    {\n      dap_obs[dap_ono].do_il[v] = i;\n      *i = 0;\n    }\n  else\n    {\n      if ((v = dap_arrnum(varname, &dim)) > 0)\n\t{\n\t  for (d = 0; d < dim; d++)\n\t    {\n\t      dap_obs[dap_ono].do_il[v + d] = i + d;\n\t      i[d] = 0;\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(dap_il) unknown variable %s\\n\", varname);\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "dap_sl": {
      "start_point": [
        1177,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "void dap_sl(char varname[], char *s)\n{\n  int v;\n\n  if ((v = dap_varnum(varname)) >= 0)\n    {\n      dap_free(dap_obs[dap_ono].do_str[v], \"dap_sl: dap_obs[dap_ono].do_str[v]\");\n      dap_obs[dap_ono].do_str[v] = s;\n      dap_obs[dap_ono].do_sl[v] = 1;\n      s[0] = '\\0';\n    }\n  else\n    {\n      fprintf(dap_err, \"(dap_sl) unknown variable %s\\n\", varname);\n      exit(1);\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dap_name": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1220,
        1
      ],
      "content": "void dap_name(char dname[], char *fname)\n{\n  struct stat statbuf;\n\n  if (!fname || !fname[0])\n    {\n      strcpy(dname, \"/dev/null\");\n      return;\n    }\n  strcpy(dname, dap_setdir);\n  if (stat(dname, &statbuf) < 0)\n    {\n      if (mkdir(dname, (mode_t) 0700) < 0)\n\t{\n\t  perror(dap_dapname);\n\t  exit(1);\n\t}\n    }\n  else if (!(statbuf.st_mode & S_IFDIR))\n    {\n      fprintf(dap_err, \"%s: non-directory file exists: %s\\n\", dap_dapname, dname);\n      exit(1);\n    }\n  strcat(dname, \"/\");\n  strcat(dname, fname);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dblcmp": {
      "start_point": [
        1222,
        0
      ],
      "end_point": [
        1229,
        1
      ],
      "content": "static int dblcmp(double *d1, double *d2)\n{\n  if (*d1 < *d2)\n    return -1;\n  else if (*d1 > *d2)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "intcmp": {
      "start_point": [
        1231,
        0
      ],
      "end_point": [
        1238,
        1
      ],
      "content": "static int intcmp(int *i1, int *i2)\n{\n  if (*i1 < *i2)\n    return -1;\n  else if (*i1 > *i2)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "stcmp": {
      "start_point": [
        1240,
        0
      ],
      "end_point": [
        1243,
        1
      ],
      "content": "static int stcmp(char **s1, char **s2)\n{\n  return strcmp(*s1, *s2);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "findlev": {
      "start_point": [
        1245,
        0
      ],
      "end_point": [
        1279,
        1
      ],
      "content": "static int findlev(int class, double dlevel[], int ilevel[], char *slevel[], int nlevels)\n{\n  int v;\n\n  if (dap_obs[dap_ono].do_len[class] == DBL)\n    {\n      for (v = 0; v < nlevels; v++)\n\t{\t/* search for level */\n\t  if (dap_obs[dap_ono].do_dbl[class] ==\n\t      dlevel[v])\n\t    break;\n\t}\n    }\n  else if (dap_obs[dap_ono].do_len[class] == INT)\n    {\n      for (v = 0; v < nlevels; v++)\n\t{\t/* search for level */\n\t  if (dap_obs[dap_ono].do_int[class] ==\n\t      ilevel[v])\n\t    break;\n\t}\n    }\n  else\n    {\n      for (v = 0; v < nlevels; v++)\n\t{\t/* search for level */\n\t  if (!strcmp(dap_obs[dap_ono].do_str[class],\n\t\t      slevel[v]))\n\t    break;\n\t}\n    }\n  if (v < nlevels)\n    return v;\n  return -1;\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "inclev": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "int inclev(int lev[], int nlevels[], int nclass)\n{\n  int c;\n\n  for (c = nclass - 1; c >= 0; --c)\n    {\n      if (lev[c] < nlevels[c] - 1)\t/* not maxed out */\n\tbreak;\n    }\n  if (c < 0)\t/* all maxed out */\n    return 0;\n  lev[c]++;\n  while (++c < nclass)\n    lev[c] = 0;\n  return 1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dataset": {
      "start_point": [
        1301,
        0
      ],
      "end_point": [
        1852,
        1
      ],
      "content": "void dataset(char oldname[], char newname[], char action[])\n{\n  static int datsetinit = 0;\t/* need to initialize 'baseobs' on first call */\n  char *dold, *dnew;\t\t/* oldname, newname with directory prepended */\n  int fold, fnew;\t\t\t/* file numbers for memory files */\n  DFILE *doldf, *dnewf;\n  int c;\t\t\t\t/* index for various purposes (ouch!) */\n  int v;\t\t\t\t/* index for various purposes (ouch!) */\n  int onum;\n  int maxnamlen;\t\t\t/* max length of variable name in dataset */\n  static dataobs baseobs;\t\t/* dataobs for append */\n  char *varspec;\n  char *oldvmem;\n  char *newvmem;\n  char **oldvar;\n  char **newvar;\n  int nvar;\t\t/* number of variables in action for COPY */\n  int ncell, nclass;\t/* number of cell, class variables for FILL */\n  char *celllist;\t\t/* list of cell, class variables for FILL */\n  int *cellv, *classv;\t/* indices of variables for FILL */\n  char **slevelmem;\t/* for storing ptrs to names of the levels of the string class vars */\n  char ***slevel;\t\t/* pointers to the level names */\n  double *dlevelmem;\t/* for storing values of the levels of the double class vars */\n  double **dlevel;\t/* pointers to the double level values */\n  int *ilevelmem;\t\t/* for storing values of the levels of the int class vars */\n  int **ilevel;\t\t/* pointers to the int level values */\n  int *inlev;\t\t/* current level read in for each class var */\n  int *outlev;\t\t/* current level written out for each class var */\n  int *nlevels;\t\t/* number of levels for each class var */\n  int (*dcmp)() = &dblcmp;\t/* to trick the compiler? */\n  int (*icmp)() = &intcmp;\t/* to trick the compiler? */\n  int (*scmp)() = &stcmp;\t\t/* to trick the compiler? */\n  int vn, nv;\n  int dim, ndim;\n  char *outlist;\n  static char dimstr[7];\t/* depends on dap_maxvar <= 10,000 */\n  int *clearvar;\t\t/* indices of variables to clear in APPEND */\n  int nclear;\t\t/* number of variables to clear */\n\n  if (!datsetinit)\t/* need to allocate and initiate baseobs? */\n    {\n      datsetinit = 1;\n      initdo(&baseobs);\n    }\n  if (dap_in[0])\t\t/* if input file left hanging... */\n    {\t\t/* ... finish it up */\n      dfclose(dap_in[0]);\n      dap_in[0] = (DFILE *) NULL;\n    }\n  if (dap_out[0])\t\t/* if output file left hanging... */\n    {\t\t/* ... finish it up */\n      dfclose(dap_out[0]);\n      dap_out[0] = (DFILE *) NULL;\n    }\n  celllist = (char *) NULL;\t/* to prevent freeing if not assigned */\n  slevelmem = (char **) NULL;\t/* to prevent freeing if not assigned */\n  cellv = (int *) NULL;\t\t/* to prevent freeing if not assigned */\n  classv = (int *) NULL;\t\t/* to prevent freeing if not assigned */\n  outlist = dap_malloc(dap_listlen, \"dataset: outlist\");\n  oldvmem = dap_malloc(dap_maxvar * (dap_namelen + 1), \"dataset: oldvmem\");\n  oldvar = (char **) dap_malloc(sizeof(char *) * dap_maxvar, \"dataset: oldvar\");\n  for (v = 0; v < dap_maxvar; v++)\n    oldvar[v] = oldvmem + v * (dap_namelen + 1);\n  newvmem = dap_malloc(dap_maxvar * (dap_namelen + 1), \"dataset: newvmem\");\n  newvar = (char **) dap_malloc(sizeof(char *) * dap_maxvar, \"dataset: newvar\");\n  for (v = 0; v < dap_maxvar; v++)\n    newvar[v] = newvmem + v * (dap_namelen + 1);\n  dold = dap_malloc(strlen(oldname) + strlen(dap_setdir) + 2, \"dataset: dold\");\n  dnew = dap_malloc(strlen(newname) + strlen(dap_setdir) + 2, \"dataset: dnew\");\n  dap_name(dold, oldname);\t/* set up dataset names */\n  dap_name(dnew, newname);\n  clearvar = NULL;\n  if (!strcmp(action, \"RENAME\"))\n    {\n      if (oldname[0] == '<')\n\t{\n\t  if (newname[0] == '<')\n\t    {\n\t      for (fold = 0; fold < dap_nrfiles; fold++)\n\t\t{\n\t\t  if (!strcmp(dfile[NDFILES + fold].dfile_name, oldname + 1))\n\t\t    break;\n\t\t}\n\t      if (fold < dap_nrfiles)\n\t\t{\n\t\t  for (fnew = 0; fnew < dap_nrfiles; fnew++)\n\t\t    {\n\t\t      if (!strcmp(dfile[NDFILES + fnew].dfile_name,\n\t\t\t\t  newname + 1))\n\t\t\tbreak;\n\t\t    }\n\t\t  if (fnew < dap_nrfiles)\n\t\t    dfile[NDFILES + fnew].dfile_name[0] = '\\0';\n\t\t  strcpy(dfile[NDFILES + fold].dfile_name, newname + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(dataset) can't find ramfile %s\\n\", oldname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(dataset) can't rename ramfile %s to disk file %s\\n\",\n\t\t      oldname, newname);\n\t      exit(1);\n\t    }\n\t}\n      else if (newname[0] == '<')\n\t{\n\t  fprintf(dap_err, \"(dataset) can't rename disk file %s to ramfile %s\\n\",\n\t\t  oldname, newname);\n\t  exit(1);\n\t}\n      else\n\trename(dold, dnew);\n    }\n  else if (!strncmp(action, \"COPY\", 4))\n    {\n      for (v = 4; action[v] == ' '; v++)\t/* get past COPY */\n\t;\n      for (nvar = 0; action[v]; nvar++)\n\t{\n\t  for (c = 0; action[v] && action[v] != ' ' && action[v] != '>'; )\n\t    {\n\t      if (c < dap_namelen)\n\t\toldvar[nvar][c++] = action[v++];\n\t      else\n\t\t{\n\t\t  fprintf(dap_err, \"(dataset) variable name too long: %s\\n\",\n\t\t\t  action);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  oldvar[nvar][c] = '\\0';\t\t/* now oldvar[nvar] is named variable */\n\t  while (action[v] == ' ')\n\t    v++;\n\t  if (action[v] == '>')\t\t/* if changing name */\n\t    {\n\t      for (v++; action[v] == ' '; v++)\n\t\t;\n\t      for (c = 0; action[v] && action[v] != ' '; )\n\t\t{\n\t\t  if (c < dap_namelen)\n\t\t    newvar[nvar][c++] = action[v++];\n\t\t  else\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(dataset) new variable name too long: %s\\n\",\n\t\t\t      action);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t      newvar[nvar][c] = '\\0';\t/* now newvar[nvar] is new name */\n\t      while (action[v] == ' ')\n\t\tv++;\n\t    }\n\t  else\n\t    strcpy(newvar[nvar], oldvar[nvar]);\n\t}\n      if (nvar)\t\t/* if there are variables to copy */\n\t{\n\t  inset(oldname);\n\t  for (v = 0, outlist[0] = '\\0'; v < nvar; v++)\n\t    {\n\t      if (v)\n\t\tstrcat(outlist, \" \");\n\t      strcat(outlist, newvar[v]);\t/* output list has newvars */\n\t      if (strcmp(oldvar[v], newvar[v]))\t/* if changing name */\n\t\t{\n\t\t  if ((vn = dap_varnum(oldvar[v])) >= 0)\n\t\t    {\n\t\t\t\t/* if newvar exists in oldname, zap its first char to '0' */\n\t\t      if ((nv = dap_varnum(newvar[v])) >= 0)\n\t\t\tdap_obs[0].do_nam[nv][0] = '0';\n\t\t\t\t/* and change the name of oldvar to newvar */\n\t\t      dap_free(dap_obs[0].do_nam[vn],\n\t\t\t       \"dataset: dap_obs[0].do_nam[vn]\");\n\t\t      dap_obs[0].do_nam[vn] =\n\t\t\tdap_malloc(strlen(newvar[v]) + 1,\n\t\t\t\t   \"dataset: dap_obs[0].do_nam[vn]\");\n\t\t      strcpy(dap_obs[0].do_nam[vn], newvar[v]);\n\t\t    }\n\t\t  else if ((vn = dap_arrnum(oldvar[v], &dim)) >= 0)\n\t\t    {\n\t\t\t\t/* do the same for arrays */\n\t\t      if ((nv = dap_arrnum(newvar[v], &ndim)) >= 0)\n\t\t\t{\n\t\t\t  for (c = 0; c < ndim; c++)\n\t\t\t    {\n\t\t\t      dap_obs[0].do_nam[nv + c][0] = '0';\n\t\t\t      sprintf(dimstr, \"[%d]\", c);\n\t\t\t      strcat(dap_obs[0].do_nam[vn + c], dimstr);\n\t\t\t    }\n\t\t\t}\n\t\t      for (c = 0; c < dim; c++)\n\t\t\t{\n\t\t\t  sprintf(dimstr, \"[%d]\", c);\n\t\t\t  dap_free(dap_obs[0].do_nam[vn + c],\n\t\t\t\t   \"dataset: dap_obs[0].do_nam[vn + c]\");\n\t\t\t  dap_obs[0].do_nam[vn + c] =\n\t\t\t    dap_malloc(strlen(newvar[v]) +\n\t\t\t\t       strlen(dimstr) + 1,\n\t\t\t\t       \"dataset: dap_obs[0].do_nam[vn + c]\");\n\t\t\t  strcpy(dap_obs[0].do_nam[vn + c], newvar[v]);\n\t\t\t  strcat(dap_obs[0].do_nam[vn + c], dimstr);\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      fprintf(dap_err, \"(dataset) unknown variable %s\\n\",\n\t\t\t      oldvar[v]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t  outset(newname, outlist);\n\t  while (step())\n\t    output();\n\t}\n      else\n\t{\n\t  if (!(doldf = dfopen(oldname, \"r\")))\n\t    {\n\t      fprintf(dap_err, \"(dataset) can't read %s for copy.\\n\",\n\t\t      oldname);\n\t      exit(1);\n\t    }\n\t  if (!(dnewf = dfopen(newname, \"w\")))\n\t    {\n\t      fprintf(dap_err, \"(dataset) can't write %s for copy.\\n\",\n\t\t      newname);\n\t      exit(1);\n\t    }\n\t  while ((c = dgetc(doldf)) != EOF)\n\t    dap_putc(c, dnewf);\n\t  dfclose(dnewf);\n\t  dfclose(doldf);\n\t}\n    }\n  else if (!strncmp(action, \"FILL\", 4))\n    {\n      inset(oldname);\n      /* make copy of cell variable names for dap_list */\n      celllist = dap_malloc(strlen(action), \"dataset: celllist\");\n      for (v = 4, c = 0; action[v] && action[v] != ':'; )\t/* get to : */\n\tcelllist[c++] = action[v++];\n      celllist[c] = '\\0';\n      if (!action[v])\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(dataset) missing ':' between variable lists in %s\\n\", action);\n\t  exit(1);\n\t}\n      ncell = c / 2;\t/* tentative, overestimate */\n      cellv = (int *) dap_malloc(sizeof(int) * ncell, \"dataset: cellv\");\n      ncell = dap_list(celllist, cellv, ncell);\n      nclass = (strlen(action) - v) / 2;\t/* tentative, overestimate */\n      classv = (int *) dap_malloc(sizeof(int) * nclass, \"dataset: classv\");\n      nclass = dap_list(action + v + 1, classv, nclass);\n      inlev = (int *) dap_malloc(sizeof(int) * nclass, \"dataset: inlev\");\n      outlev = (int *) dap_malloc(sizeof(int) * nclass, \"dataset: outlev\");\n      slevelmem = (char **) dap_malloc(sizeof(char *) * nclass * dap_maxlev,\n\t\t\t\t       \"dataset: slevelmem\");\n      slevel = (char ***) dap_malloc(sizeof(char **) * nclass, \"dataset: slevel\");\n      dlevelmem = (double *) dap_malloc(sizeof(double) * nclass * dap_maxlev,\n\t\t\t\t\t\"dataset: dlevelmem\");\n      dlevel = (double **) dap_malloc(sizeof(double *) * nclass,\n\t\t\t\t      \"dataset: dlevel\");\n      ilevelmem = (int *) dap_malloc(sizeof(int) * nclass * dap_maxlev,\n\t\t\t\t     \"dataset: ilevelmem\");\n      ilevel = (int **) dap_malloc(sizeof(int *) * nclass, \"dataset: ilevel\");\n      nlevels = (int *) dap_malloc(sizeof(int) * nclass, \"dataset: nlevels\");\n      for (c = 0; c < nclass; c++)\n\t{\n\t  slevel[c] = slevelmem + c * dap_maxlev;\n\t  dlevel[c] = dlevelmem + c * dap_maxlev;\n\t  ilevel[c] = ilevelmem + c * dap_maxlev;\n\t}\n      outset(newname, \"\");\n      for (c = 0; c < nclass; c++)\t/* start with empty level lists */\n\tnlevels[c] = 0;\n      for (dap_mark(); step(); )\n\t{\n\t  for (c = 0; c < nclass; c++)\n\t    {\n\t      if ((v = findlev(classv[c],\n\t\t\t       dlevel[c], ilevel[c], slevel[c], nlevels[c])) < 0)\n\t\t{\t/* if not found */\n\t\t  if (nlevels[c] < dap_maxlev)\n\t\t    {\n\t\t      if (dap_obs[dap_ono].do_len[classv[c]] == DBL)\n\t\t\t{\n\t\t\t  dlevel[c][nlevels[c]++] =\n\t\t\t    dap_obs[dap_ono].do_dbl[classv[c]];\n\t\t\t}\n\t\t      else if (dap_obs[dap_ono].do_len[classv[c]] == INT)\n\t\t\t{\n\t\t\t  ilevel[c][nlevels[c]++] =\n\t\t\t    dap_obs[dap_ono].do_int[classv[c]];\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  slevel[c][nlevels[c]] =\n\t\t\t    dap_malloc(strlen(dap_obs[dap_ono].do_str[classv[c]]) + 1,\n\t\t\t\t       \"dataset: slevel[c][nlevels[c]]\");\n\t\t\t  strcpy(slevel[c][nlevels[c]++],\n\t\t\t\t dap_obs[dap_ono].do_str[classv[c]]);\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(dataset) too many levels for \\%s\\n\",\n\t\t\t      dap_obs[dap_ono].do_nam[classv[c]]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t}\n      for (c = 0; c < nclass; c++)\n\t{\n\t  if (dap_obs[dap_ono].do_len[classv[c]] == DBL)\n\t    qsort(dlevel[c], nlevels[c], sizeof(double), dcmp);\n\t  else if (dap_obs[dap_ono].do_len[classv[c]] == INT)\n\t    qsort(ilevel[c], nlevels[c], sizeof(int), icmp);\n\t  else\n\t    qsort(slevel[c], nlevels[c], sizeof(char *), scmp);\n\t  outlev[c] = 0;\n\t}\n      dap_rewind();\t/* go back to beginning of part */\n      while (step())\n\t{\n\t  for (c = 0; c < nclass; c++)\n\t    {\n\t      inlev[c] = findlev(classv[c], dlevel[c], ilevel[c], slevel[c],\n\t\t\t\t nlevels[c]);\n\t    }\n\t  for (c = 0; c < nclass; c++)\n\t    {\n\t      if (outlev[c] < inlev[c])\n\t\tbreak;\n\t    }\n\t  if (c < nclass)\t/* skipped values for class c */\n\t    {\n\t      dap_save();\n\t      for (v = 0; v < ncell; v++)\t/* set cell vals */\n\t\t{\t/* set values to 0.0, 0, or \"\" */\n\t\t  if (dap_obs[dap_ono].do_len[cellv[v]] == DBL)\n\t\t    dap_obs[dap_ono].do_dbl[cellv[v]] = 0.0;\n\t\t  else if (dap_obs[dap_ono].do_len[cellv[v]] == INT)\n\t\t    dap_obs[dap_ono].do_int[cellv[v]] = 0;\n\t\t  else\n\t\t    dap_obs[dap_ono].do_str[cellv[v]][0] = '\\0';\n\t\t}\n\t      do\t{\n\t\tfor (c = 0; c < nclass; c++)\n\t\t  {\n\t\t    if (outlev[c] < inlev[c])\n\t\t      break;\n\t\t  }\n\t\tif (c == nclass)\t/* caught up */\n\t\t  break;\n\t\tfor (v = c; v < nclass; v++)\n\t\t  {\n\t\t    if (dap_obs[dap_ono].do_len[classv[v]] == DBL)\n\t\t      dap_obs[dap_ono].do_dbl[classv[v]] =\n\t\t\tdlevel[v][outlev[v]];\n\t\t    else if (dap_obs[dap_ono].do_len[classv[v]] == INT)\n\t\t      dap_obs[dap_ono].do_int[classv[v]] =\n\t\t\tilevel[v][outlev[v]];\n\t\t    else\n\t\t      strcpy(dap_obs[dap_ono].do_str[classv[v]],\n\t\t\t     slevel[v][outlev[v]]);\n\t\t  }\n\t\toutput();\n\t      } while (inclev(outlev, nlevels, nclass));\n\t      dap_rest();\n\t    }\n\t  output();\n\t  inclev(outlev, nlevels, nclass);\n\t}\n      for (c = 0; c < nclass; c++)\t/* empty the level lists */\n\t{\n\t  for (v = 0; v < nlevels[c]; v++)\n\t    {\n\t      if (dap_obs[dap_ono].do_len[classv[c]] > 0)\n\t\tdap_free(slevel[c][v], \"dataset: slevel[c][v]\");\n\t    }\n\t  nlevels[c] = 0;\n\t}\n    }\n  else if (!strcmp(action, \"REMOVE\"))\n    {\n      if (oldname[0] == '<')\n\t{\n\t  for (fold = 0; fold < dap_nrfiles; fold++)\n\t    {\n\t      if (!strcmp(dfile[NDFILES + fold].dfile_name, oldname + 1))\n\t\t{\n\t\t  dap_free(dfile[NDFILES + fold].dfile_name,\n\t\t\t   \"dataset: dfile[NDFILES + fold].dfile_name\");\n\t\t  dfile[NDFILES + fold].dfile_name = NULL;\n\t\t  dap_free(rfile[fold].rfile_str,\n\t\t\t   \"dataset: rfile[fold].rfile_str\");\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      else\n\tunlink(dold);\n    }\n  else if (!strcmp(action, \"APPEND\"))\n    {\n      if (!(dap_out[0] = dfopen(newname, \"r\")))\t/* no dataset to append to... */\n\t{\t\t\t\t/* ...so just copy. */\n\t  if (!(dap_out[0] = dfopen(newname, \"w\")))\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(dataset) Can't create new data set for append: %s\\n\",\n\t\t      newname);\n\t      exit(1);\n\t    }\n\t  if (!(dap_in[0] = dfopen(oldname, \"r\")))\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(dataset) can't read old data set for append: %s\\n\",\n\t\t      oldname);\n\t      exit(1);\n\t    }\n\t  while ((c = dgetc(dap_in[0])) != EOF)\n\t    dap_putc(c, dap_out[0]);\n\t  dfclose(dap_in[0]);\n\t  dap_in[0] = (DFILE *) NULL;\n\t  dfclose(dap_out[0]);\n\t  dap_out[0] = (DFILE *) NULL;\n\t  return;\n\t}\n      else\t\t\t\t/* really append */\n\t{\n\t  inset(newname);\t\t\t/* to get variable list */\n\t  outset(\"dap_null\", \"\");\t\t/* so don't output anywhere */\n\t  baseobs.do_nvar = dap_obs[0].do_nvar;\t/* save newname's nvar */\n\t  for (v = 0; v < baseobs.do_nvar; v++)\n\t    {\t\t\t/* copy names, lens from newname */\n\t      baseobs.do_len[v] = dap_obs[0].do_len[v];\n\t      baseobs.do_nam[v] = dap_malloc(strlen(dap_obs[0].do_nam[v]) + 1,\n\t\t\t\t\t     \"dataset: baseobs.do_nam[v]\");\n\t      strcpy(baseobs.do_nam[v], dap_obs[0].do_nam[v]);\n\t    }\n\t  dfclose(dap_out[0]);\n\t  dap_out[0] = (DFILE *) NULL;\n\t  inset(oldname);\t\t/* open \"old\" dataset to append to newname */\n\t  dap_obs[0].do_ovar = 0;\n\t  for (v = 0, maxnamlen = 0; v < baseobs.do_nvar; v++)\n\t    {\t\t/* find longest name length in newname */\n\t      if (maxnamlen < strlen(baseobs.do_nam[v]))\n\t\tmaxnamlen = strlen(baseobs.do_nam[v]);\n\t    }\n\t  /* set up for specification for declaration of those variables in\n\t   * newname that are not in oldname\n\t   */\n\t  varspec = dap_malloc(maxnamlen + dap_intlen + 2,\n\t\t\t       \"dataset: varspec\");\n\t  clearvar = (int *) dap_malloc(sizeof(int) * baseobs.do_nvar,\n\t\t\t\t\t\"dataset: clearvar\");\n\t  for (v = 0, nclear = 0; v < baseobs.do_nvar; v++)\n\t    {\n\t      if ((onum = dap_varnum(baseobs.do_nam[v])) < 0)\n\t\t{\t/* get index in oldname */\n\t\t\t\t/* if none give it newname's specs for it */\n\t\t  sprintf(varspec, \"%s %d\", baseobs.do_nam[v],\n\t\t\t  baseobs.do_len[v]);\n\t\t  onum = dap_vd(varspec, 0);\n\t\t\t\t/* mark for setting to \"\", 0, and 0.0 */\n\t\t  clearvar[nclear++] = onum;\n\t\t}\n\t      else\t\t/* if it's there, check type, len */\n\t\t{\n\t\t  if (dap_obs[0].do_len[onum] != baseobs.do_len[v])\n\t\t    {\n\t\t      fprintf(stderr,\n\t\t\t      \"(dataset) variable %s has different lengths (%d appended to %d) in datasets\\n\",\n\t\t\t      baseobs.do_nam[v], dap_obs[0].do_len[onum],\n\t\t\t      baseobs.do_len[v]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t      dap_obs[0].do_out[dap_obs[0].do_ovar++] = onum;\n\t    }\n\t  if (!(dap_out[0] = dfopen(newname, \"a\")))\n\t    {\n\t      fprintf(dap_err, \"(dataset) can't append to new data set: %s\\n\",\n\t\t      newname);\n\t      exit(1);\n\t    }\n\t  while (step())\n\t    {\n\t      /* and set to \"\", 0, and 0.0 */\n\t      for (v = 0; v < nclear; v++)\n\t\t{\n\t\t  if (dap_obs[0].do_str[clearvar[v]])\n\t\t    dap_obs[0].do_str[clearvar[v]][0] = '\\0';\n\t\t  dap_obs[0].do_sl[clearvar[v]] = 0;\n\t\t  dap_obs[0].do_int[clearvar[v]] = 0;\n\t\t  dap_obs[0].do_dbl[clearvar[v]] = 0.0;\n\t\t}\n\t      output();\n\t    }\n\t  for (v = 0; v < baseobs.do_nvar; v++)\n\t    {\n\t      dap_free(baseobs.do_nam[v], \"dataset: baseobs.do_nam[v]\");\n\t      baseobs.do_nam[v] = NULL;\n\t    }\n\t  dap_free(varspec, \"dataset: varspec\");\n\t}\n    }\n  else\n    {\n      fprintf(dap_err, \"(dataset) unknown action: %s\\n\", action);\n      exit(1);\n    }\n  dap_free(dold, \"dataset: dold\");\n  dap_free(dnew, \"dataset: dnew\");\n  dap_free(oldvmem, \"dataset: oldvmem\");\n  dap_free(oldvar, \"dataset: oldvar\");\n  dap_free(newvmem, \"dataset: newvmem\");\n  dap_free(newvar, \"dataset: newvar\");\n  dap_free(outlist, \"dataset: outlist\");\n  if (clearvar)\n    dap_free(clearvar, \"dataset: clearvar\");\n  if (celllist)\n    dap_free(celllist, \"dataset: celllist\");\n  if (cellv)\n    dap_free(cellv, \"dataset: cellv\");\n  if (classv)\n    dap_free(classv, \"dataset: classv\");\n  if (slevelmem)\t/* all of these allocated for FILL */\n    {\n      dap_free(slevelmem, \"dataset: slevelmem\");\n      dap_free(slevel, \"dataset: slevel\");\n      dap_free(dlevelmem, \"dataset: dlevelmem\");\n      dap_free(dlevel, \"dataset: dlevel\");\n      dap_free(ilevelmem, \"dataset: ilevelmem\");\n      dap_free(ilevel, \"dataset: ilevel\");\n      dap_free(inlev, \"dataset: inlev\");\n      dap_free(outlev, \"dataset: outlev\");\n      dap_free(nlevels, \"dataset: nlevels\");\n    }\n}",
      "lines": 552,
      "depth": 28,
      "decorators": [
        "void"
      ]
    },
    "getblock": {
      "start_point": [
        1856,
        0
      ],
      "end_point": [
        1866,
        1
      ],
      "content": "static int getblock(DFILE *fp)\n{\n  char block[BLOCKLEN];\n  int b;\n\n  if ((block[0] = dgetc(fp)) == '\\r')\n    return 0;\n  for (b = 1; b < BLOCKLEN; b++)\n    block[b] = dgetc(fp);\n  return (block[16] & 0xff);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dap_clearobs": {
      "start_point": [
        1868,
        0
      ],
      "end_point": [
        1913,
        1
      ],
      "content": "int dap_clearobs(char *varspec)\n{\n  int v;\n\n  if (dap_ono < 2)\n    {\n      dap_prev[dap_ono].do_ivar = 0;\n      eof[dap_ono] = 0;\n      for (v = 0; v < dap_maxvar; v++)\n\t{\n\t  if (dap_prev[dap_ono].do_str[v])\n\t    dap_free(dap_prev[dap_ono].do_str[v],\n\t\t     \"clearobs: dap_prev[dap_ono].do_str[v]\");\n\t  dap_prev[dap_ono].do_str[v] = NULL;\n\t}\n    }\n  dap_obs[dap_ono].do_ivar = 0;\n  dap_obs[dap_ono].do_ovar = 0;\n  dap_obs[dap_ono].do_nvar = 0;\n  dap_obs[dap_ono].do_valid = 0;\n  for (v = 0; v < dap_maxvar; v++)\n    {\n      if (dap_obs[dap_ono].do_nam[v])\n\tdap_free(dap_obs[dap_ono].do_nam[v],\n\t\t \"clearobs: dap_obs[dap_ono].do_nam[v]\");\n      dap_obs[dap_ono].do_nam[v] = NULL;\n      dap_obs[dap_ono].do_dl[v] = NULL;\n      dap_obs[dap_ono].do_il[v] = NULL;\n      if (!dap_obs[dap_ono].do_sl[v] && dap_obs[dap_ono].do_str[v])\n\tdap_free(dap_obs[dap_ono].do_str[v],\n\t\t \"clearobs: dap_obs[dap_ono].do_str[v]\");\n      dap_obs[dap_ono].do_str[v] = NULL;\n      dap_obs[dap_ono].do_sl[v] = 0;\n    }\n  if (varspec)\n    dap_vd(varspec, 1);\n  else\n    dap_vd(\"_type_ 8\", 0);\n  if ((v = dap_varnum(\"_type_\")) < 0)\n    {\n      fputs(\"(clearobs) missing _type_ variable\\n\", dap_err);\n      exit(1);\n    }\n  dap_obs[dap_ono].do_out[dap_obs[dap_ono].do_ovar++] = v;\n  return v;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "infile": {
      "start_point": [
        1915,
        0
      ],
      "end_point": [
        2008,
        1
      ],
      "content": "void infile(char *ifname, char *idelim)\n{\n  static int infinit = 0;\n  int v;\n  int d;\n  int infldlen;\n  char *fname;\n  static char *delim;\n  static int delimlen;\n  \n  if (!infinit)\n    {\n      infinit = 1;\n      delimlen = (dap_linelen + 1) / 8 - 1;\n      delim = dap_malloc(delimlen + 1, \"infile: delim\");\n      fieldwd = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"infile: fieldwd\");\n    }\n    \n  if (dap_in[dap_ono])\n    {\n      dfclose(dap_in[dap_ono]);\n      dap_in[dap_ono] = (DFILE *) NULL;\n    }\n  if (dap_out[dap_ono])\n    {\n      dfclose(dap_out[dap_ono]);\n      dap_out[dap_ono] = (DFILE *) NULL;\n    }\n  if (!ifname || !ifname[0])\n    {\n      fname = \"/dev/null\";\n      strcpy(delim, \"|\");\n    }\n  else\n    {\n      fname = ifname;\n      if (!idelim || !idelim[0])\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(infile) Delimiter string must be at least one character: %s\\n\",\n\t\t  delim);\n\t  exit(1);\n\t}\n      else if (strlen(idelim) <= delimlen)\n\tstrcpy(delim, idelim);\n      else\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(infile) Delimiter string too long: %s\\n\", idelim);\n\t  exit(1);\n\t}\n    }\n    \n  /* the 'f' says that it's not a dataset, so don't need to prepend directory */\n  if (!(dap_in[dap_ono] = dfopen(fname, \"rf\")))\n    {\n      fprintf(dap_err, \"(infile) can't read data file: %s\\n\", fname);\n      exit(1);\n    }\n  intype = TEXT;\n  if (!strcmp(fname + strlen(fname) - 4, \".dbf\"))\n    {\n      intype = DBASE;\n      getblock(dap_in[dap_ono]);     /* dump header */\n      for (inlen = 0; (infldlen = getblock(dap_in[dap_ono])); inlen += infldlen)\n\t;\n    }\n  dap_delim = delim[0];\n    \n  for (nfields = 0, d = 1; delim[d]; nfields++)\n    {\n\t    \n      if (nfields < dap_maxvar)\n\t{\n\t  for (fieldwd[nfields] = 0; delim[d] && delim[d] != dap_delim; )\n\t  {\n\t    fieldwd[nfields] = 10 * fieldwd[nfields] + delim[d++] - '0';\n\t  }\n\t  if (delim[d])\n\t    d++;\n\t}\n      else\n\t{\n\t  fputs(\"(infile) too many field width specifiers.\\n\", dap_err);\n\t  exit(1);\n\t}\n    }\n    \n  v = dap_clearobs((char *) NULL);\n  strcpy(dap_obs[dap_ono].do_str[v], \"OBS\");\n  lineno[dap_ono] = 1;\n  toolong = 0;\n    \n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "input": {
      "start_point": [
        2010,
        0
      ],
      "end_point": [
        2053,
        1
      ],
      "content": "void input(char varlist[])\n{\n  int v;\n  int l;\n  int i;\n  static char *vname = NULL;\n  int dim;\n  int d;\n\n  if (!vname)\n    vname = dap_malloc(dap_namelen + 1, \"input: vname\");\n  for (l = 0; varlist[l] == ' '; l++)\n    ;\n  while (varlist[l])\n    {\n      for (i = 0; varlist[l + i] && varlist[l + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    vname[i] = varlist[l + i];\n\t  else\n\t    {\n\t      vname[i] = '\\0';\n\t      fprintf(dap_err, \"(input) variable name too long: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t}\n      vname[i] = '\\0';\n      if ((v = dap_varnum(vname)) >= 0)\n\tdap_obs[dap_ono].do_in[dap_obs[dap_ono].do_ivar++] = v;\n      else if ((v = dap_arrnum(vname, &dim)) >= 0)\n\t{\n\t  for (d = 0; d < dim; d++)\n\t    dap_obs[dap_ono].do_in[dap_obs[dap_ono].do_ivar++] = v + d;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(input) unknown variable: %s\\n\", vname);\n\t  exit(1);\n\t}\n      l += i;\n      while (varlist[l] == ' ')\n\tl++;\n    }\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "inset": {
      "start_point": [
        2056,
        0
      ],
      "end_point": [
        2092,
        1
      ],
      "content": "void inset(char *fname)\n{\n  int v;\n  static char *varspec = NULL;\n  double testd;\n\n  if (!varspec)\n    varspec = dap_malloc(dap_linelen + 1, \"inset: varspec\");\n  if (dap_in[dap_ono])\n    {\n      dfclose(dap_in[dap_ono]);\n      dap_in[dap_ono] = (DFILE *) NULL;\n    }\n  if (dap_out[dap_ono])\n    {\n      dfclose(dap_out[dap_ono]);\n      dap_out[dap_ono] = (DFILE *) NULL;\n    }\n  if (!fname)\n    return;\n  if (!(dap_in[dap_ono] = dfopen(fname, \"r\")))\n    {\n      fprintf(dap_err, \"(inset) can't read data set: %s\\n\", fname);\n      exit(1);\n    }\n  intype = DSET;\n  dap_delim = '\\0';\n  if (dap_getline(dap_in[dap_ono], varspec) < 0)\n    {\n      fprintf(dap_err, \"(inset) data set empty: %s\\n\", fname);\n      exit(1);\n    }\n  nfields = 0;\n  dap_clearobs(varspec);\n  dap_delim = SETDELIM;\n  lineno[dap_ono] = 1;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fixlist": {
      "start_point": [
        2097,
        0
      ],
      "end_point": [
        2190,
        1
      ],
      "content": "static void fixlist(char *varl, char *varlist)\n{\n  static int fixinit = 0;\n  int l;\t\t\t/* index to var lists */\n  int f;\n  int inbrack;\n  static char *vname;\n  int dim;\n  static int *outv;\n  int l0;\n  int l1;\n  int f1;\n  int nv;\n  int v;\n  int vn;\n\n  if (!fixinit)\n    {\n      fixinit = 1;\n      vname = dap_malloc(dap_namelen + 1, \"fixlist: vname\");\n      outv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"fixlist: outv\");\n    }\n  if (!varl)\n    {\n      fputs(\"(fixlist) missing variable list.\\n\", dap_err);\n      exit(1);\n    }\n  if (!varlist)\n    {\n      fputs(\"(fixlist) missing string for fixed variable list.\\n\", dap_err);\n      exit(1);\n    }\n  /* First copy varl to varlist, eliminating bracketed indices */\n  for (inbrack = 0, l = 0, f = 0; varl[l]; l++)\n    {\n      if (inbrack)\n\t{\n\t  if (varl[l] == ']')\n\t    inbrack = 0;\n\t}\n      else if (varl[l] == '[')\n\tinbrack = 1;\n      else\n\tvarlist[f++] = varl[l];\n    }\n  varlist[f] = '\\0';\n  for (l = 0; varlist[l] == ' '; l++)\n    ;\n  l0 = 0;\n  if (varlist[l] == '!')\n    {\n      for (l++; varlist[l] == ' '; l++)\n\t;\n      varlist[l0++] = '!';\n    }\n  for (nv = 0, l1 = l0; varlist[l]; )\n    {\n      for (f = 0; varlist[l + f] && varlist[l + f] != ' '; f++)\n\t{\n\t  if (f < dap_namelen)\n\t    vname[f] = varlist[l + f];\n\t  else\n\t    {\n\t      vname[f] = '\\0';\n\t      fprintf(dap_err, \"(fixlist) variable name too long: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t}\n      vname[f] = '\\0';\n      if (((v = dap_varnum(vname)) < 0) && ((v = dap_arrnum(vname, &dim)) < 0))\n\t{\n\t  fprintf(dap_err, \"(fixlist) unknown variable: %s\\n\", vname);\n\t  exit(1);\n\t}\n      for (vn = 0; vn < nv; vn++)\t/* see if variable already appeared */\n\t{\n\t  if (outv[vn] == v)\n\t    break;\n\t}\n      if (vn == nv)\t\t\t\t/* if not */\n\t{\n\t  outv[nv++] = v;\t\t\t/* enter it in list of indices */\n\t  if (l1 > l0)\n\t    varlist[l1++] = ' ';\n\t  for (f1 = 0; f1 < f; f1++)\t/* copy name from varlist to varlist */\n\t    varlist[l1++] = varlist[l++];\n\t}\n      else\n\tl += f;\n      while (varlist[l] == ' ')\n\tl++;\n    }\n  varlist[l1] = '\\0';\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "outset": {
      "start_point": [
        2196,
        0
      ],
      "end_point": [
        2362,
        1
      ],
      "content": "void outset(char *fname, char *varl)\n{\n  static int outinit = 0;\t/* initialized data for outset? */\n  int l;\n  int i;\n  static char *varlist;\n  static char *vname;\n  int v;\n  int w;\n  int first;\n  int dim;\n  int d;\n  double testd;\n\n  if (dap_out[dap_ono])\n    {\n      dfclose(dap_out[dap_ono]);\n      dap_out[dap_ono] = (DFILE *) NULL;\n    }\n  if (!fname)\n    {\n      fputs(\"(outset) no dataset name.\\n\", dap_err);\n      exit(1);\n    }\n  if (!outinit)\n    {\n      outinit = 1;\n      varlist = dap_malloc(dap_listlen, \"outset: varlist\");\n      vname = dap_malloc(dap_listlen, \"outset: vname\");\n    }\n  if (!(dap_out[dap_ono] = dfopen(fname, \"w\")))\n    {\n      fprintf(dap_err, \"(outset) Can't write data set: %s\\n\", fname);\n      exit(1);\n    }\n  if (!varl)\n    {\n      fprintf(dap_err, \"(outset (%s)) Missing variable list.\\n\", fname);\n      exit(1);\n    }\n  fixlist(varl, varlist);\n  if (varlist[0])\n    {\n      for (l = 0; varlist[l] == ' '; l++)\n\t;\n      if (varlist[l] == '!')\t/* listing variables NOT to include */\n\t{\t\t/* first put them all in */\n\t  for (l++; varlist[l] == ' '; l++)\n\t    ;\n\t  dap_obs[dap_ono].do_ovar = dap_obs[dap_ono].do_nvar;\n\t  for (v = 0; v < dap_obs[dap_ono].do_nvar; v++)\n\t    dap_obs[dap_ono].do_out[v] = v;\n\t  while (varlist[l])\t/* then take them out */\n\t    {\n\t      for (i = 0; varlist[l + i] && varlist[l + i] != ' '; i++)\n\t\tvname[i] = varlist[l + i];\n\t      vname[i] = '\\0';\n\t      if ((w = dap_varnum(vname)) >= 0)\n\t\t{\n\t\t  for (v = 0; v < dap_obs[dap_ono].do_ovar; v++)\n\t\t    {\n\t\t      if (dap_obs[dap_ono].do_out[v] == w)\n\t\t\tbreak;\n\t\t    }\n\t\t  if (v == dap_obs[dap_ono].do_ovar)\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(outset (%s)) variable not in list of variables to exclude: %s\\n\",\n\t\t\t      fname, vname);\n\t\t      exit(1);\n\t\t    }\n\t\t  while (v < dap_obs[dap_ono].do_ovar - 1)\n\t\t    {\n\t\t      dap_obs[dap_ono].do_out[v] =\n\t\t\tdap_obs[dap_ono].do_out[v + 1];\n\t\t      v++;\n\t\t    }\n\t\t  dap_obs[dap_ono].do_ovar--;\n\t\t}\n\t      else if ((w = dap_arrnum(vname, &dim)) >= 0)\n\t\t{\n\t\t  for (v = 0; v < dap_obs[dap_ono].do_ovar; v++)\n\t\t    {\n\t\t      if (dap_obs[dap_ono].do_out[v] == w)\n\t\t\tbreak;\n\t\t    }\n\t\t  while (v < dap_obs[dap_ono].do_ovar - dim)\n\t\t    {\n\t\t      dap_obs[dap_ono].do_out[v] =\n\t\t\tdap_obs[dap_ono].do_out[v + dim];\n\t\t      v++;\n\t\t    }\n\t\t  dap_obs[dap_ono].do_ovar -= dim;\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(dap_err, \"(outset(%s)) unknown variable: %s\\n\",\n\t\t\t  fname, vname);\n\t\t  exit(1);\n\t\t}\n\t      l += i;\n\t      while (varlist[l] == ' ')\n\t\tl++;\n\t    }\n\t}\n      else\n\t{\n\t  while (varlist[l])\n\t    {\n\t      for (i = 0; varlist[l + i] && varlist[l + i] != ' '; i++)\n\t\tvname[i] = varlist[l + i];\n\t      vname[i] = '\\0';\n\t      if ((v = dap_varnum(vname)) >= 0)\n\t\tdap_obs[dap_ono].do_out[dap_obs[dap_ono].do_ovar++] = v;\n\t      else if ((v = dap_arrnum(vname, &dim)) >= 0)\n\t\t{\n\t\t  for (d = 0; d < dim; d++)\n\t\t    dap_obs[dap_ono].do_out[dap_obs[dap_ono].do_ovar++] = v + d;\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(dap_err, \"(outset(%s)) unknown variable: %s\\n\",\n\t\t\t  fname, vname);\n\t\t  exit(1);\n\t\t}\n\t      l += i;\n\t      while (varlist[l] == ' ')\n\t\tl++;\n\t    }\n\t}\n    }\n  else\n    {\n      dap_obs[dap_ono].do_ovar = dap_obs[dap_ono].do_nvar;\n      for (v = 0; v < dap_obs[dap_ono].do_nvar; v++)\n\tdap_obs[dap_ono].do_out[v] = v;\n    }\n  if (dap_varnum(\"_type_\") < 0)\n    {\n      fprintf(dap_err, \"(outset (%s)) missing _type_ variable\\n\", fname);\n      exit(1);\n    }\n  for (v = 0; v < dap_obs[dap_ono].do_ovar; v++)\n    {\n      for (w = v + 1; w < dap_obs[dap_ono].do_ovar; w++)\n\t{\n\t  if (dap_obs[dap_ono].do_out[v] == dap_obs[dap_ono].do_out[w])\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(outset (%s)) duplicate variable in output list: %s\\n\",\n\t\t      fname, dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_out[w]]);\n\t      exit(1);\n\t    }\n\t}\n    }\n  for (v = 0, first = 1; v < dap_obs[dap_ono].do_ovar; v++)\n    {\n      if (!first)\n\tdap_putc(' ', dap_out[dap_ono]);\n      dputs(dap_obs[dap_ono].do_nam[dap_obs[dap_ono].do_out[v]], \" \", dap_out[dap_ono]);\n      dputi(dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_out[v]], dap_out[dap_ono]);\n      first = 0;\n    }\n  dap_putc('\\n', dap_out[dap_ono]);\n  dflush(dap_out[dap_ono]);\n  outline = 0;\n}",
      "lines": 167,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "output": {
      "start_point": [
        2365,
        0
      ],
      "end_point": [
        2416,
        1
      ],
      "content": "void output()\n{\n  int v;\n  int first;\n\n  if ((v = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(output) missing _type_ variable\\n\");\n      exit(1);\n    }\n  for (v = 0, first = 1; v < dap_obs[dap_ono].do_ovar; v++)\n    {\n      if (!first)\n\tdap_putc(SETDELIM, dap_out[dap_ono]);\n      if (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_out[v]] == INT)\n\t{\n\t  /* if we're in an infile statement, may need to update the value\n\t   * from the value in the user's program\n\t   */\n\t  if (!dap_ono && dap_obs[dap_ono].do_il[dap_obs[0].do_out[v]])\n\t    dap_obs[0].do_int[dap_obs[0].do_out[v]] =\n\t      *dap_obs[dap_ono].do_il[dap_obs[0].do_out[v]];\n\t  dap_putint(dap_obs[dap_ono].do_int[dap_obs[dap_ono].do_out[v]],\n\t\t     dap_out[dap_ono]);\n\t}\n      else if (dap_obs[dap_ono].do_len[dap_obs[dap_ono].do_out[v]] == DBL)\n\t{\n\t  /* if we're in an infile statement, may need to update the value\n\t   * from the value in the user's program\n\t   */\n\t  if (!dap_ono && dap_obs[dap_ono].do_dl[dap_obs[0].do_out[v]])\n\t    dap_obs[0].do_dbl[dap_obs[0].do_out[v]] =\n\t      *dap_obs[dap_ono].do_dl[dap_obs[0].do_out[v]];\n\t  dap_double = dap_obs[dap_ono].do_dbl[dap_obs[dap_ono].do_out[v]];\n\t  dap_putdouble(dap_out[dap_ono]);\n\t}\n      else\n\t{\n\t  dputs(dap_obs[dap_ono].do_str[dap_obs[dap_ono].do_out[v]], \"\",\n\t\tdap_out[dap_ono]);\n\t}\n      first = 0;\n    }\n  dap_putc('\\n', dap_out[dap_ono]);\n  dflush(dap_out[dap_ono]);\n  if (dap_outreport && !(++outline % dap_outreport))\n    {\n      fprintf(stderr, \"(output) %d lines written to %s...\\n\",\n\t      outline, dap_out[dap_ono]->dfile_name);\n      fflush(stderr);\n    }\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "expand": {
      "start_point": [
        2422,
        0
      ],
      "end_point": [
        2522,
        1
      ],
      "content": "static int expand(char *varlist, int *varv, int maxvars)\n{\n  int nvars;\n  int m;\n  int i;\n  char *mname;\n  char *newname;\n  int arrn;\t\t/* var index of array's first element */\n  int dim;\t\t/* array dimension */\n  int d;\t\t\t/* index to array */\n  int include;\t\t/* variables to be included? (rather than excluded) */\n\n  if (!varlist)\n    return 0;\n  if (!varv)\n    {\n      fputs(\"(expand) Missing variable index list.\\n\", dap_err);\n      exit(1);\n    }\n  mname = dap_malloc(strlen(varlist) + 1, \"expand: mname\");\n  newname = dap_malloc(strlen(varlist) + 1, \"expand: newname\");\n  include = 1;\n  for (m = 0; varlist[m] == ' '; m++)\n    ;\n  if (varlist[m] == '!')\t/* indicates variables to exclude, not include */\n    {\n      for (m++; varlist[m] == ' '; m++)\n\t;\n      include = -1;\n    }\n  for (nvars = 0; varlist[m]; )\n    {\n      for (i = 0; varlist[m + i] && varlist[m + i] != ' ' && varlist[m + i] != '>'; i++)\n\tmname[i] = varlist[m + i];\n      mname[i] = '\\0';\n      m += i;\n      while (varlist[m] == ' ')\n\tm++;\n      newname[0] = '\\0';\n      if (varlist[m] == '>')\n\t{\n\t  if (include < 0)\n\t    {\n\t      fputs(\"(expand) Can't rename variables being excluded\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  for (m++; varlist[m] == ' '; m++)\n\t    ;\n\t  for (i = 0; varlist[m + i] && varlist[m + i] != ' ' && varlist[m + i] != '>';\n\t       i++)\n\t    newname[i] = varlist[m + i];\n\t  newname[i] = '\\0';\n\t  m += i;\n\t  while (varlist[m] == ' ')\n\t    m++;\n\t}\n      if (nvars >= maxvars)\n\t{\n\t  fprintf(dap_err, \"(expand) More than %d variables: %s\\n\", maxvars, varlist);\n\t  exit(1);\n\t}\n      if ((arrn = dap_arrnum(mname, &dim)) >= 0)\n\t{\n\t  for (d = 0; d < dim; d++)\n\t    {\n\t      if (newname[0])\n\t\t{\n\t\t  dap_free(dap_obs[dap_ono].do_nam[arrn],\n\t\t\t   \"expand: dap_obs[dap_ono].do_nam[arrn]\");\n\t\t  dap_obs[dap_ono].do_nam[arrn] =\n\t\t    dap_malloc(strlen(newname) + 6,\n\t\t\t       \"expand: dap_obs[dap_ono].do_nam[arrn]\");\n\t\t  sprintf(dap_obs[dap_ono].do_nam[arrn],\n\t\t\t  \"%s[%d]\", newname, d);\n\t\t}\n\t      varv[nvars++] = arrn++;\n\t    }\n\t}\n      else if ((varv[nvars] = dap_varnum(mname)) > 0)\n\t{\n\t  if (newname[0])\n\t    {\n\t      dap_free(dap_obs[dap_ono].do_nam[varv[nvars]],\n\t\t       \"expand: dap_obs[dap_ono].do_nam[varv[nvars]]\");\n\t      dap_obs[dap_ono].do_nam[varv[nvars]] =\n\t\tdap_malloc(strlen(newname) + 1,\n\t\t\t   \"expand: dap_obs[dap_ono].do_nam[varv[nvars]]\");\n\t      strcpy(dap_obs[dap_ono].do_nam[varv[nvars]], newname);\n\t    }\n\t  nvars++;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(expand) Variable unknown: %s\\n\", mname);\n\t  exit(1);\n\t}\n    }\n  dap_free(mname, \"expand: mname\");\n  dap_free(newname, \"expand: newname\");\n  return include * nvars;\n}",
      "lines": 101,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "varcat": {
      "start_point": [
        2524,
        0
      ],
      "end_point": [
        2550,
        1
      ],
      "content": "static void varcat(char *to, char *from)\n{\n  int t, f, ff;\n\n  for (f = 0; from[f] == ' '; f++)\n    ;\n  for (t = 0; to[t]; t++)\n    ;\n  while (from[f])\n    {\n      for (ff = f; from[ff] && from[ff] != ' ' && from[ff] != '>'; ff++)\n\t;\n      while (from[ff] == ' ')\n\tff++;\n      if (from[ff] == '>')\n\t{\n\t  for (f = ff + 1; from[f] == ' '; f++)\n\t    ;\n\t}\n      while (from[f] && from[f] != ' ')\n\tto[t++] = from[f++];\n      to[t++] = ' ';\n      while (from[f] == ' ')\n\tf++;\n    }\n  to[t] = '\\0';\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "merge": {
      "start_point": [
        2558,
        0
      ],
      "end_point": [
        2934,
        1
      ],
      "content": "void merge(char *fname1, char *vars1, char *fname2, char *vars2,\n\t   char *marks, char *outname)\n{\n  int *varv1, *varv2;\t/* indexes of variables listed in vars1, vars2 */\n  int *ovarv1, *ovarv2;\t/* indexes of variables to use from fname1, fname2 */\n  int nvar1, nvar2;\t/* number of vars in vars1, vars2 except if excluding,\n\t\t\t * it's the negative\n\t\t\t */\n  int *markv1;\t\t/* indexes of partitioning variables in fname1 */\n  int *markv2;\t\t/* indexes of partitioning variables in fname2 */\n  int nmark;\t\t/* number of partitioning variables */\n  int v1, v2;\t\t/* indexes to variable index lists */\n  int vv1, vv2;\t\t/* more indexes to variable index lists */\n  char *outlist;\t\t/* list of variables to appear in final output */\n  char *outlist1;\t\t/* list of variables to use from fname1 */\n  char *outlist2;\t\t/* list of variables to use from fname2 */\n  int goon1;\n  double ddiff;\n  int isdiff;\n  int vars1null, vars2null;\t/* vars1, vars2 = NULL? */\n  char *vars1a, *vars2a;\t/* OK, awful patch: if vars1 and/or vars2 are exclusions\n\t\t\t\t * with '!', then have to create lists artificially of\n\t\t\t\t * variables that are not to be excluded.\n\t\t\t\t */\n  int exclude1, exclude2;\t/* vars1, vars2 exclusion lists? */\n  int nvar1a, nvar2a;\t/* variable counts in case of exclusion */\n  int *varv1a, *varv2a;\t/* index lists for variables to include */\n\n  if (!fname1 || !fname2 || !outname)\n    {\n      fputs(\"(merge) Missing dataset name.\\n\", dap_err);\n      exit(1);\n    }\n  if (vars1 && index(vars1, '['))\n    {\n      fprintf(dap_err,\n\t      \"(merge) Variable lists may not contain individual array elements: %s\\n\",\n\t      vars1);\n      exit(1);\n    }\n  if (vars2 && index(vars2, '['))\n    {\n      fprintf(dap_err,\n\t      \"(merge) Variable lists may not contain individual array elements: %s\\n\",\n\t      vars2);\n      exit(1);\n    }\n  vars1null = 0;\t/* non-NULL until proven NULL */\n  vars2null = 0;\n  outlist = dap_malloc(dap_listlen, \"merge: outlist\");\n  outlist1 = dap_malloc(dap_listlen, \"merge: outlist1\");\n  outlist2 = dap_malloc(dap_listlen, \"merge:outlist2\");\n  varv1 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: varv1\");\n  varv2 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: varv2\");\n  ovarv1 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: ovarv1\");\n  ovarv2 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: ovarv2\");\n  markv1 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: markv1\");\n  markv2 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"merge: markv2\");\n  dap_ono = 0;\t/* take no chances! */\n  inset(fname1);\t/* set up input from dataset 1 */\n  if (vars1 && !vars1[0])\t\t/* vars1 null string: use all variables */\n    {\n      vars1null = 1;\n      /* in this case, need to make our own vars1 list */\n      vars1 = dap_malloc(dap_listlen, \"merge: vars1\");\n      vars1[0] = '\\0';\n      for (v1 = 0; v1 < dap_obs[dap_ono].do_nvar; v1++)\n\t{\t\t/* copy all vars except _type_ */\n\t  if (strcmp(dap_obs[dap_ono].do_nam[v1], \"_type_\"))\n\t    {\n\t      strcat(vars1, \" \");\n\t      strcat(vars1, dap_obs[dap_ono].do_nam[v1]);\n\t    }\n\t}\n    }\n  nvar1 = expand(vars1, varv1, dap_maxvar);\n  exclude1 = 0;\n  if (nvar1 < 0)\t/* OK, here we go: variables listed for exclusion */\n    {\n      exclude1 = 1;\n      nvar1 = -nvar1;\n      vars1a = dap_malloc(dap_listlen, \"merge: vars1a\");\n      vars1a[0] = '\\0';\n      varv1a = (int *) dap_malloc(dap_maxvar, \"merge: varv1a\");\n      for (v1 = 0, nvar1a = 0; v1 < dap_obs[dap_ono].do_nvar; v1++)\n\t{\t/* copy all vars except _type_ and excluded vars */\n\t  if (!strcmp(dap_obs[dap_ono].do_nam[v1], \"_type_\"))\n\t    continue;\n\t  for (vv1 = 0; vv1 < nvar1; vv1++)\n\t    {\t/* look to see if excluded */\n\t      if (varv1[vv1] == v1)\n\t\tbreak;\n\t    }\n\t  if (vv1 == nvar1)\t/* not found, include it */\n\t    {\n\t      strcat(vars1a, \" \");\n\t      strcat(vars1a, dap_obs[dap_ono].do_nam[v1]);\n\t      varv1a[nvar1a++] = v1;\n\t    }\n\t}\n      if (vars1null)\n\tdap_free(vars1, \"merge: vars1\");\n      vars1 = vars1a;\t/* reassign list; this won't happen if vars1 was NULL */\n      nvar1 = nvar1a;\n      dap_free(varv1, \"merge: varv1\");\n      varv1 = varv1a;\n    }\n  if (marks)\n    nmark = dap_list(marks, markv1, dap_maxvar);\n  else\n    nmark = 0;\n  dap_ono = 1;\n  inset(fname2);\t/* set up input from dataset 2 */\n  if (vars2 && !vars2[0])\t\t/* vars2 null string: use all variables */\n    {\n      vars2null = 1;\n      /* in this case, need to make our own vars2 list */\n      vars2 = dap_malloc(dap_listlen, \"merge: vars2\");\n      vars2[0] = '\\0';\n      for (v2 = 0; v2 < dap_obs[dap_ono].do_nvar; v2++)\n\t{\n\t  if (strcmp(dap_obs[dap_ono].do_nam[v2], \"_type_\"))\n\t    {\t/* copy all vars except _type_ */\n\t      strcat(vars2, \" \");\n\t      strcat(vars2, dap_obs[dap_ono].do_nam[v2]);\n\t    }\n\t}\n    }\n  nvar2 = expand(vars2, varv2, dap_maxvar);\n  exclude2 = 0;\n  if (nvar2 < 0)\t/* OK, here we go: variables listed for exclusion */\n    {\n      exclude2 = 1;\n      nvar2 = -nvar2;\n      vars2a = dap_malloc(dap_listlen, \"merge: vars2a\");\n      vars2a[0] = '\\0';\n      varv2a = (int *) dap_malloc(dap_maxvar, \"merge: varv2a\");\n      for (v2 = 0, nvar2a = 0; v2 < dap_obs[dap_ono].do_nvar; v2++)\n\t{\t/* copy all vars except _type_ and excluded vars */\n\t  if (!strcmp(dap_obs[dap_ono].do_nam[v2], \"_type_\"))\n\t    continue;\n\t  for (vv2 = 0; vv2 < nvar2; vv2++)\n\t    {\t/* look to see if excluded */\n\t      if (varv2[vv2] == v2)\n\t\tbreak;\n\t    }\n\t  if (vv2 == nvar2)\t/* not found, include it */\n\t    {\n\t      strcat(vars2a, \" \");\n\t      strcat(vars2a, dap_obs[dap_ono].do_nam[v2]);\n\t      varv2a[nvar2a++] = v2;\n\t    }\n\t}\n      if (vars2null)\n\tdap_free(vars2, \"merge: vars2\");\n      vars2 = vars2a;\t/* reassign list; this won't happen if vars2 was NULL */\n      nvar2 = nvar2a;\n      dap_free(varv2, \"merge: varv2\");\n      varv2 = varv2a;\n    }\n  dap_list(marks, markv2, dap_maxvar);\n  for (v1 = 0; v1 < nmark; v1++)\t/* check types of part vars across datasets */\n    {\n      if (dap_obs[0].do_len[markv1[v1]] != dap_obs[1].do_len[markv2[v1]])\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(merge) Part variables of different types: %s (%d) and %s (%d)\\n\",\n\t\t  dap_obs[0].do_nam[markv1[v1]], dap_obs[0].do_len[markv1[v1]],\n\t\t  dap_obs[1].do_nam[markv2[v1]], dap_obs[1].do_len[markv2[v1]]);\n\t  exit(1);\n\t}\n    }\n  /* Start assembling list of output variables. */\n  outlist[0] = '\\0';\n  if (vars2 && nvar2 > 0)\n    varcat(outlist, vars2);\n  outlist2[0] = '\\0';\n  if (vars2 && nvar2 > 0)\n    varcat(outlist2, vars2);\n  dap_ono = 2;\t\t/* the output dataset */\n  dap_obs[2].do_nvar = 0;\t/* start with nothing */\n  dap_obs[2].do_ovar = 0;\t/* except _type_ */\n  dap_obs[2].do_out[dap_obs[2].do_ovar++] = dap_vd(\"_type_ 8\", 0);\n  for (v2 = 0; v2 < nvar2; v2++)\n    {\n      if (dap_obs[2].do_nam[dap_obs[2].do_nvar])\n\tdap_free(dap_obs[2].do_nam[dap_obs[2].do_nvar],\n\t\t \"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]\");\n      dap_obs[2].do_nam[dap_obs[2].do_nvar] =\n\tdap_malloc(strlen(dap_obs[1].do_nam[varv2[v2]]) + 1,\n\t\t   \"merge: dap_obs[1].do_nam[varv2[v2]]\");\n      strcpy(dap_obs[2].do_nam[dap_obs[2].do_nvar],\n\t     dap_obs[1].do_nam[varv2[v2]]);\n      dap_obs[2].do_len[dap_obs[2].do_nvar] = dap_obs[1].do_len[varv2[v2]];\n      dap_obs[2].do_nvar++;\n    }\n  outlist1[0] = '\\0';\n  if (vars1 && nvar1 > 0)\n    {\n      strcat(outlist, \" \");\n      varcat(outlist, vars1);\n      varcat(outlist1, vars1);\n    }\n  for (v1 = 0; v1 < nvar1; v1++)\n    {\n      for (v2 = 0; v2 < nvar2; v2++)\n\t{\n\t  if (!strcmp(dap_obs[0].do_nam[varv1[v1]], dap_obs[1].do_nam[varv2[v2]]))\n\t    break;\n\t}\n      if (v2 < nvar2)\n\t{\n\t  fprintf(dap_err, \"(merge) variable appears in lists for both %s and %s: %s\\n\",\n\t\t  fname1, fname2, dap_obs[0].do_nam[varv1[v1]]);\n\t  exit(1);\n\t}\n      else\n\t{\n\t  if (dap_obs[2].do_nam[dap_obs[2].do_nvar])\n\t    dap_free(dap_obs[2].do_nam[dap_obs[2].do_nvar],\n\t\t     \"merge: dap_obs[2].do_nam[dap_obs[2].do_nvar]\");\n\t  dap_obs[2].do_nam[dap_obs[2].do_nvar] =\n\t    dap_malloc(strlen(dap_obs[0].do_nam[varv1[v1]]) + 1,\n\t\t       \"merge: dap_obs[0].do_nam[varv1[v1]]\");\n\t  strcpy(dap_obs[2].do_nam[dap_obs[2].do_nvar],\n\t\t dap_obs[0].do_nam[varv1[v1]]);\n\t  dap_obs[2].do_len[dap_obs[2].do_nvar] = dap_obs[0].do_len[varv1[v1]];\n\t  dap_obs[2].do_nvar++;\n\t}\n    }\n  outset(outname, outlist);\n  strcpy(dap_obs[2].do_str[dap_varnum(\"_type_\")], \"OBS\");\n  expand(outlist1, ovarv1, dap_maxvar);\n  expand(outlist2, ovarv2, dap_maxvar);\n  dap_ono = 0; /* for reading first dataset */\n  goon1 = step(); /* try to read one line */\n  for ( ; ; )\n    {\n      dap_ono = 1; /* prepare to read second dataset */\n      if (step()) /* if there's anything left of second dataset */\n\t{\n\t  while (goon1) /* while there's anything left of first dataset */\n\t    {\n\t      /* see if mark values variables currently match for both datasets */\n\t      isdiff = 0;\n\t      if (nmark) /* only check if there are mark variables */\n\t\t{\n\t\t  for (v1 = 0; v1 < nmark; v1++)\n\t\t    {\n\t\t      if (dap_obs[0].do_len[markv1[v1]] == DBL)\n\t\t\t{\n\t\t\t  ddiff = dap_obs[0].do_dbl[markv1[v1]] -\n\t\t\t    dap_obs[1].do_dbl[markv2[v1]];\n\t\t\t  if (ddiff < 0.0)\n\t\t\t    isdiff = -1;\n\t\t\t  else if (ddiff > 0.0)\n\t\t\t    isdiff = 1;\n\t\t\t  else\n\t\t\t    isdiff = 0;\n\t\t\t  if (isdiff)\n\t\t\t    break;\n\t\t\t}\n\t\t      else if (dap_obs[0].do_len[markv1[v1]] == INT)\n\t\t\t{\n\t\t\t  isdiff = dap_obs[0].do_int[markv1[v1]] -\n\t\t\t    dap_obs[1].do_int[markv2[v1]];\n\t\t\t  if (isdiff)\n\t\t\t    break;\n\t\t\t}\n\t\t      else if ((isdiff = strcmp(dap_obs[0].do_str[markv1[v1]],\n\t\t\t\t\t\tdap_obs[1].do_str[markv2[v1]])))\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t      if (isdiff < 0) /* dataset1 not up to where dataset2 is */\n\t\t{\n\t\t  dap_ono = 0; /* read another line of dataset1 */\n\t\t  goon1 = step();\n\t\t}\n\t      else if (isdiff > 0) /* dataset1 passed where dataset2 is */\n\t\tbreak;\n\t      else /* or else we're on the same page: merge */\n\t\t{\n\t\t  for (v1 = 0; v1 < nvar1; v1++)\n\t\t    {\n\t\t      if (dap_obs[0].do_len[varv1[v1]] == DBL)\n\t\t\tdap_obs[2].do_dbl[ovarv1[v1]] =\n\t\t\t  dap_obs[0].do_dbl[varv1[v1]];\n\t\t      else if (dap_obs[0].do_len[varv1[v1]] == INT)\n\t\t\tdap_obs[2].do_int[ovarv1[v1]] =\n\t\t\t  dap_obs[0].do_int[varv1[v1]];\n\t\t      else\n\t\t\t{\n\t\t\t  if (dap_obs[2].do_str[ovarv1[v1]])\n\t\t\t    dap_free(dap_obs[2].do_str[ovarv1[v1]],\n\t\t\t\t     \"merge: dap_obs[2].do_str[ovarv1[v1]]\");\n\t\t\t  dap_obs[2].do_str[ovarv1[v1]] =\n\t\t\t    dap_malloc(strlen(dap_obs[0].do_str[varv1[v1]]) + 1,\n\t\t\t\t       \"merge: dap_obs[0].do_str[ovarv1[v1]]\");\n\t\t\t  strcpy(dap_obs[2].do_str[ovarv1[v1]],\n\t\t\t\t dap_obs[0].do_str[varv1[v1]]);\n\t\t\t}\n\t\t    }\n\t\t  for (v2 = 0; v2 < nvar2; v2++)\n\t\t    {\n\t\t      if (dap_obs[1].do_len[varv2[v2]] == DBL)\n\t\t\tdap_obs[2].do_dbl[ovarv2[v2]] =\n\t\t\t  dap_obs[1].do_dbl[varv2[v2]];\n\t\t      else if (dap_obs[1].do_len[varv2[v2]] == INT)\n\t\t\tdap_obs[2].do_int[ovarv2[v2]] =\n\t\t\t  dap_obs[1].do_int[varv2[v2]];\n\t\t      else\n\t\t\t{\n\t\t\t  if (dap_obs[2].do_str[ovarv2[v2]])\n\t\t\t    dap_free(dap_obs[2].do_str[ovarv2[v2]],\n\t\t\t\t     \"merge: dap_obs[2].do_str[ovarv2[v2]]\");\n\t\t\t  dap_obs[2].do_str[ovarv2[v2]] =\n\t\t\t    dap_malloc(strlen(dap_obs[1].do_str[varv2[v2]]) + 1,\n\t\t\t\t       \"merge: dap_obs[1].do_str[ovarv2[v2]]\");\n\t\t\t  strcpy(dap_obs[2].do_str[ovarv2[v2]],\n\t\t\t\t dap_obs[1].do_str[varv2[v2]]);\n\t\t\t}\n\t\t    }\n\t\t  dap_ono = 2; /* prepare to output to merged file */\n\t\t  output();\n\t\t  dap_ono = 0;\n\t\t  goon1 = step();\n\t\t}\n\t      if (!nmark)\n\t\tbreak;\n\t    }\n\t}\n      else\n\tbreak;\n    }\n  dap_ono = 0;\n  if (dap_in[0])\n    {\n      dfclose(dap_in[0]);\n      dap_in[0] = (DFILE *) NULL;\n    }\n  if (dap_in[1])\n    {\n      dfclose(dap_in[1]);\n      dap_in[1] = (DFILE *) NULL;\n    }\n  if (dap_out[dap_ono])\n    {\n      dfclose(dap_out[dap_ono]);\n      dap_out[dap_ono] = (DFILE *) NULL;\n    }\n  dap_free(outlist, \"merge: outlist\");\n  dap_free(outlist1, \"merge: outlist1\");\n  dap_free(outlist2, \"merge: outlist2\");\n  dap_free(ovarv1, \"merge: ovarv1\");\n  dap_free(ovarv2, \"merge: ovarv2\");\n  dap_free(markv1, \"merge: markv1\");\n  dap_free(markv2, \"merge: markv2\");\n  if (vars1null)\n    dap_free(vars1, \"merge: vars1\");\n  if (vars2null)\n    dap_free(vars2, \"merge: vars2\");\n  if (exclude1 < 0)\n    {\n      dap_free(vars1a, \"merge: vars1a\");\n      dap_free(varv1a, \"merge: varv1a\");\n    }\n  else\n    dap_free(varv1, \"merge: varv1\");\n  if (exclude2 < 0)\n    {\n      dap_free(vars2a, \"merge: vars2a\");\n      dap_free(varv2a, \"merge: varv2a\");\n    }\n  else\n    dap_free(varv2, \"merge: varv2\");\n}",
      "lines": 377,
      "depth": 27,
      "decorators": [
        "void"
      ]
    },
    "title": {
      "start_point": [
        2936,
        0
      ],
      "end_point": [
        2939,
        1
      ],
      "content": "void title(char *text)\n{\n  dap_title = text;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "dap_head": {
      "start_point": [
        2941,
        0
      ],
      "end_point": [
        2985,
        1
      ],
      "content": "void dap_head(int markv[], int nmark)\n{\n  time_t t;\n  int m;\n\n  fputs(\"\\n=================================\", dap_lst);\n  fprintf(dap_lst, \"\\nDap %3d. \", pageno++);\n  time(&t);\n  fputs(ctime(&t), dap_lst);\n  putc('\\n', dap_lst);\n  if (dap_title)\n    {\n      fputs(dap_title, dap_lst);\n      putc('\\n', dap_lst);\n    }\n  if (nmark)\n    {\n      fprintf(dap_lst, \"\\nFor: \");\n      for (m = 0; m < nmark; m++)\n\t{\n\t  switch(dap_obs[dap_ono].do_len[markv[m]])\n\t    {\n\t    case DBL:\n\t      fprintf(dap_lst, \"%s = %g\",\n\t\t      dap_obs[dap_ono].do_nam[markv[m]],\n\t\t      dap_obs[dap_ono].do_dbl[markv[m]]);\n\t      break;\n\t    case INT:\n\t      fprintf(dap_lst, \"%s = %d\",\n\t\t      dap_obs[dap_ono].do_nam[markv[m]],\n\t\t      dap_obs[dap_ono].do_int[markv[m]]);\n\t      break;\n\t    default:\n\t      fprintf(dap_lst, \"%s = %s\",\n\t\t      dap_obs[dap_ono].do_nam[markv[m]],\n\t\t      dap_obs[dap_ono].do_str[markv[m]]);\n\t      break;\n\t    }\n\t  if (m < nmark - 1)\n\t    fputs(\", \", dap_lst);\n\t}\n      putc('\\n', dap_lst);\n    }\n  putc('\\n', dap_lst);\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "extractWords": {
      "start_point": [
        3010,
        0
      ],
      "end_point": [
        3051,
        1
      ],
      "content": "CharList extractWords(char * buffer, long size,char  *delimiter)\n{\n\tchar * bufferWord= (char*) malloc (sizeof(char)*size+1);\n\tmemset (bufferWord,'\\0',size+1);\n\tCharList list;\n\tlist.word=NULL;\n\tlist.next=NULL;\n\tCharList *current=&list;\n\tlong i=0l;\n\tlong sSize=0l;\n\tlong sIndex=0l;\n\tfor(i=0l;i<size;i++)\n\t{\n\t\tif (buffer[i]=='\\r' || buffer[i]=='\\t')\n\t\t\tcontinue;\n\t\tif (buffer[i]==delimiter[0])\n\t\t{\n\t\t\tcurrent->word= (char*) malloc (sizeof(char)*sIndex+5);\n\t\t\tstrcpy(current->word,bufferWord);\n\t\t\tcurrent->next= (char*) malloc (sizeof(CharList));\n\t\t\tcurrent=current->next;\n\t\t\tsSize=sIndex;\n\t\t\tsIndex=0;\n\t\t\tmemset (bufferWord,'\\0',size+1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbufferWord[sIndex]=buffer[i];\n\t\t\tsIndex++;\n\t\t}\n\t\t\n\t}\n\tif (sIndex>0)\n\t{\n\t\tcurrent->word= (char*) malloc ((sizeof(char)*strlen(bufferWord))+1);\n\t\tstrcpy(current->word,bufferWord);\n\t\tcurrent->next= NULL;\n\t}\n\tfree(bufferWord);\n\t\t\n\treturn list;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "CharList"
      ]
    },
    "cleanAttributeList": {
      "start_point": [
        3053,
        0
      ],
      "end_point": [
        3071,
        1
      ],
      "content": "void cleanAttributeList( AttributeList *list)\n{\n\tAttributeList *actualatt=list;\n\tdo{\n\t\tactualatt=list;\n\t\tAttributeList *prev=list;\n\t\tAttributeList *prev2=list;\n\t\tdo{\n\t\t\tprev2=prev;\n\t\t\tprev=actualatt;\n\t\t\tactualatt=actualatt->next;\n\t\t}while(actualatt!=NULL);\n\t\tif (prev!=list){\n\t\t\tfree(prev->word);\n\t\t\tfree(prev);\n\t\t}\n\t\tprev2->next=NULL;\n\t}while(list->next!=NULL);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "cleanCharList": {
      "start_point": [
        3073,
        0
      ],
      "end_point": [
        3092,
        1
      ],
      "content": "void cleanCharList( CharList *list)\n{\n\tCharList *actualatt=list;\n\tdo{\n\t\tactualatt=list;\n\t\tCharList *prev=list;\n\t\tCharList *prev2=list;\n\t\tdo{\n\t\t\tprev2=prev;\n\t\t\tprev=actualatt;\n\t\t\tactualatt=actualatt->next;\n\t\t}while(actualatt!=NULL);\n\t\tif (prev!=list)\n\t\t{\n\t\t\tfree(prev->word);\n\t\t\tfree(prev);\n\t\t}\n\t\tprev2->next=NULL;\n\t}while(list->next!=NULL);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "import": {
      "start_point": [
        3096,
        0
      ],
      "end_point": [
        3294,
        1
      ],
      "content": "int import(char* fname,  char* fileToLoad, char * format, char  *delimiter,int replace,int getnames){\n\t\n\tinfile(fileToLoad,delimiter);\n\tFILE * pFile;\n\tlong lSize;\n\tchar * buffer;\n\tchar * bufferline;\n\tsize_t result;\n\tif (strcmp(format,\"CSV\")&&strcmp(format,\"DLM\")&&strcmp(format,\"csv\")&&strcmp(format,\"dlm\")\n\t\t&&strcmp(format,\"TAB\")&&strcmp(format,\"tab\"))\n\t{\n\t\tprintf (\"Format not supported :%s\\n\",format); exit (1);\n\t}\n\tif (strlen(delimiter)==0)\n\t{\n\t\tif(strcmp(format,\"CSV\")||strcmp(format,\"csv\"))\n\t\t\tdelimiter=\",\";\n\t\tif(strcmp(format,\"DLM\")||strcmp(format,\"dlm\"))\n\t\t\tdelimiter=\" \";\n\t\tif(strcmp(format,\"TAB\")||strcmp(format,\"tab\"))\n\t\t\tdelimiter=\"\\t\";\n\t}\n\tpFile = fopen (fileToLoad , \"rb\" );\n\tif (pFile==NULL) {\n\t\tprintf (\"File loading error :%s\\n\",fileToLoad); exit (1);\n\t}\n\t// obtain file size:\n\tfseek (pFile , 0 , SEEK_END);\n\tlSize = ftell (pFile);\n\trewind (pFile);\n\t// allocate memory to contain the whole file:\n\tbuffer = (char*) malloc (sizeof(char)*lSize);\n\tif (buffer == NULL) {printf (\"Memory error \\n\"); exit (2);}\n\tbufferline = (char*) malloc (sizeof(char)*lSize);\n\tif (bufferline == NULL) {printf (\"2nd Memory error \\n\"); exit (2);}\n\n\t// copy the file into the buffer:\n\tresult = fread (buffer,1,lSize,pFile);\n\tif (result != lSize) {printf (\"Reading error \\n\"); exit (3);}\n\n\tlong sIndex=0l;\n\tlong sSize=0l;\n\tlong i=0l;\n\t\n\tAttributeList listatt;\n\tlistatt.word=NULL;\n\tlistatt.next=NULL;\n\t //the whole file is now loaded in the memory buffer. \n\tint lineCnt=0;\n\tfor(i=0l;i<lSize;i++)\n\t{\n\t\t\n\t\tif (buffer[i] == '\\n')\n\t\t{\n\t\t\tCharList list=extractWords(bufferline,sIndex,  delimiter);\n\t\t\tCharList *actual=&list;\n\t\t\tint counter=0;\n\t\t\tdo{\n\t\t\t\tchar *word=actual->word;\n\t\t\t\tint sizeStr=strlen(word);\n\t\t\t\tAttributeList *actualatt=&listatt;\n\t\t\t\tAttributeList *prev=actualatt;\n\t\t\t\t\n\t\t\t\tif(lineCnt==0)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif (actualatt->word==NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(getnames)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tactualatt->word= (char*) malloc (sizeof(char)*strlen(word)+5);\n\t\t\t\t\t\t\tstrcpy(actualatt->word,word);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tactualatt->word= (char*) malloc (sizeof(char)*10);\n\t\t\t\t\t\t\tsprintf(actualatt->word,\"X%d\",counter);\n\t\t\t\t\t\t}\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdo{\n\t\t\t\t\t\t\tchar *wordatt=actualatt->word;\n\t\t\t\t\t\t\tif (strcmp(wordatt,word)==0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprev=actualatt;\n\t\t\t\t\t\t\tactualatt=actualatt->next;\n\t\t\t\t\t\t}while(actualatt!=NULL);\n\t\t\t\t\t\tif (actualatt==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprev->next=(AttributeList*) malloc (sizeof(AttributeList));\n\t\t\t\t\t\t\tprev->next->word=NULL;\n\t\t\t\t\t\t\tprev=prev->next;\n\t\t\t\t\t\t\tif(getnames)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprev->word= (char*) malloc (sizeof(char)*strlen(word)+5);\n\t\t\t\t\t\t\t\tstrcpy(prev->word,word);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprev->word= (char*) malloc (sizeof(char)*10);\n\t\t\t\t\t\t\t\tsprintf(prev->word,\"X%d\",counter);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprev->next=NULL;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tactualatt=&listatt;\n\t\t\t\tprev=actualatt;\n\t\t\t\tif((getnames&&lineCnt>0)||!getnames)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tint counterbis=0;\n\t\t\t\t\tdo{\n\t\t\t\t\t\tif (counter==counterbis)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tactualatt=actualatt->next;\n\t\t\t\t\t\tcounterbis++;\n\t\t\t\t\t}while(actualatt!=NULL);\n\t\t\t\t\tif (actualatt!=NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t//measure column size\n\t\t\t\t\t\tif (sizeStr>actualatt->size)\n\t\t\t\t\t\t\tactualatt->size=sizeStr;\n\t\t\t\t\t\tif (actualatt->size>1000)\n\t\t\t\t\t\t\tactualatt->size=1000;\n\t\t\t\t\t\tfloat f;\n\t\t\t\t\t\tif(sscanf(word, \"%f\", &f) != 0)\n\t\t\t\t\t\t\tactualatt->type=DOUBLER;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tactualatt->type=STRINGER;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tactual=actual->next;\n\t\t\t\tcounter++;\n\t\t\t}while(actual!=NULL);\n\t\t\tsSize=sIndex;\n\t\t\tsIndex=0;\n\t\t\tlineCnt++;\n\t\t\tcleanCharList(&list);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbufferline[sIndex]=buffer[i];\n\t\t\tsIndex++;\n\t\t}\n\t\t\n\t}\n\t// terminate\n\tfclose (pFile);\n\tfree (buffer);\n\tfree (bufferline);\n\tAttributeList *actualatt=&listatt;\n\tint countcol=0;\n\t\n\tdo{\n\t\tchar *wordatt=actualatt->word;\n\t\tif(wordatt!=NULL)\n\t\t{\n\n\t\t\tint sierr=strlen(wordatt)+6;\n\t\t\tchar *bufferer= (char*) malloc (sizeof(char)*sierr);\n\t\t\t\n\t\t\t\n\t\t\tif(actualatt->type==DOUBLER)\n\t\t\t{\n\t\t\t\tsprintf(bufferer,\"%s -1\",wordatt);\n\t\t\t\tdap_vd(bufferer, -1);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint size=1000;\n\t\t\t\tif (actualatt->size<1000)\n\t\t\t\t\tsize=actualatt->size;\n\t\t\t\tsprintf(bufferer,\"%s %d\",wordatt,actualatt->size);\n\t\t\t\tdap_vd(bufferer,size);\n\t\t\t\t\n\t\t\t\n\t\t\t}\n\t\t}\n\t\tcountcol++;\n\t\tactualatt=actualatt->next;\n\t}while(actualatt!=NULL);\n\t\n\toutset(fname, \"\");\n\tskip(2);\n        while (step())\n          output();\n\n\tcleanAttributeList(&listatt);\n\t\n\treturn 0;\n}",
      "lines": 199,
      "depth": 28,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/dap1.c": {
    "sortparse": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void sortparse(char line[], int which)\n{\n  int v;\n  int l;\n  int newfield;\n\n  for (v = 0, l = 0, newfield = 1; line[l] && line[l] != '\\n'; l++)\n    {\n      if (newfield)\n\tstart[which][v++] = l;\n      newfield = (line[l] == SETDELIM);\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fieldcmp": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static int fieldcmp(char f1[], char f2[])\n{\n  int f;\n\n  for (f = 0; f1[f] && f1[f] != SETDELIM && f1[f] != '\\n' && f1[f] == f2[f]; f++)\n    ;\n  if (f1[f] == f2[f])\n    return 0;\n  if (!f1[f] || f1[f] == SETDELIM || f1[f] == '\\n')\n    return -1;\n  if (!f2[f] || f2[f] == SETDELIM || f2[f] == '\\n')\n    return 1;\n  return f1[f] - f2[f];\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sortcmp": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int sortcmp(char **e0, char **e1)\n{\n  int v;\n  int cmp;\n\n  cmp = 0;\n  sortparse(*e0, 0);\n  sortparse(*e1, 1);\n  for (v = 0; v < nvar; v++)\n    {\n      cmp = fieldcmp(*e0 + start[0][varv[v]], *e1 + start[1][varv[v]]);\n      if (cmp)\n\tbreak;\n    }\n  if (nmods && mod[v] == 'd')\n    cmp = -cmp;\n  return cmp;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "linediff": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int linediff(char l1[], char l2[])\n{\n  int l;\n\n  for (l = 0; l1[l] && l1[l] != '\\n' && l1[l] == l2[l]; l++)\n    ;\n  return l1[l] != l2[l];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void sort(char *fname, char *varlist, char *modifiers)\n{\n  static int sortinit = 0;\t/* memory allocated? */\n  int unique; /* in sorted dataset, include only one of a group of lines with matching keys? */\n  int lastun;\n  int l;\n  int i;\n  int v;\n  int vn;\n  char *dsrt0;\n  char *dsrt;\n  char *dfile;\n  static char **line;\n  int newline;\n  int nlines;\n  char *c;\n  int flen;\n  int (*scmp)();\n\n  if (!sortinit)\n    {\n      sortinit = 1;\n      line = (char **) dap_malloc(sizeof(char *) * dap_maxlines, \"\");\n      startmem = (int *) dap_malloc(sizeof(int) * 2 * dap_maxvar, \"\");\n      start[0] = startmem;\n      start[1] = startmem + dap_maxvar;\n      mod = dap_malloc(dap_maxvar, \"\");\n      varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n    }\n  if (!fname)\n    {\n      fprintf(dap_err, \"%s:sort: no dataset name given\\n\", dap_dapname);\n      exit(1);\n    }\n  scmp = &sortcmp;\n  unique = 0;\n  if (modifiers)\n    {\n      for (l = 0; modifiers[l] == ' '; l++)\n\t;\n      for (nmods = 0, unique = 0; modifiers[l]; )\n\t{\n\t  if (modifiers[l] == 'u')\n\t    {\n\t      unique = 1;\n\t      l++;\n\t    }\n\t  else if (modifiers[l] == 'i' || modifiers[l] == 'd')\n\t    {\n\t      while (modifiers[l] == 'i' || modifiers[l] == 'd')\n\t\tmod[nmods++] = modifiers[l++];\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(sort) Bad modifier(s): %s\\n\", modifiers);\n\t      exit(1);\n\t    }\n\t  while (modifiers[l] == ' ')\n\t    l++;\n\t}\n    }\n  else\n    nmods = 0;\n  dsrt0 = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(dsrt0, fname, \".srt\");\n  inset(fname);\n  outset(dsrt0, \"\");\n  nvar = dap_list(varlist, varv, dap_maxvar);\n  if (nmods && (nvar != nmods))\n    {\n      fprintf(dap_err,\n\t      \"(sort) Number of modifiers %d does not equal number of sort variables %d.\\n\",\n\t      nmods, nvar);\n      exit(1);\n    }\n  if (fname[0] == '<')\n    {\n      for (nlines = 0, i = dap_ftell(dap_in[0]), newline = 1;\n\t   i < dap_in[0]->dfile_ram->rfile_end -\n\t     dap_in[0]->dfile_ram->rfile_str; i++)\n\t{\n\t  if (newline)\n\t    {\n\t      if (nlines < dap_maxlines)\n\t\tline[nlines++] = dap_in[0]->dfile_ram->rfile_str + i;\n\t      else\n\t\t{\n\t\t  fprintf(dap_err, \"(sort) Too many lines in ramfile %s\\n\",\n\t\t\t  fname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  newline = (dap_in[0]->dfile_ram->rfile_str[i] == '\\n');\n\t}\n      qsort(line, nlines, sizeof(char *), scmp);\n      for (l = 0, lastun = -1; l < nlines; l++)\n\t{\n\t  if (!unique || lastun < 0 || linediff(line[lastun], line[l]))\n\t    {\n\t      for (c = line[l]; c < dap_in[0]->dfile_ram->rfile_end && *c != '\\n';\n\t\t   c++)\n\t\tdap_putc(*c, dap_out[0]);\n\t      dap_putc('\\n', dap_out[0]);\n\t      lastun = l;\n\t    }\n\t  else\n\t    {\n\t      for (c = line[l]; c < dap_in[0]->dfile_ram->rfile_end && *c != '\\n';\n\t\t   c++)\n\t\t;\n\t    }\n\t}\n      flen = dap_out[0]->dfile_ram->rfile_end - dap_out[0]->dfile_ram->rfile_str;\n      memcpy(dap_in[0]->dfile_ram->rfile_str, dap_out[0]->dfile_ram->rfile_str, flen);\n      dap_in[0]->dfile_ram->rfile_end = dap_in[0]->dfile_ram->rfile_str + flen;\n    }\n  else\n    {\n      inset(NULL); /* because we had to call inset before and now we don't want it */\n      dfile = dap_malloc(strlen(fname) + strlen(dap_setdir) + 2, \"\");\n      dap_name(dfile, fname);\n      dsrt = dap_malloc(strlen(dsrt0) + strlen(dap_setdir) + 2, \"\");\n      dap_name(dsrt, dsrt0);\n      dsort(dfile, dsrt, varv, nvar, unique, mod, nmods);\n      dap_free(dsrt, \"\");\n      dap_free(dfile, \"\");\n    }\n  dap_free(dsrt0, \"\");\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "printhead": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static void printhead(char **formstr, int space, char *fname, int *varv, int nvar)\n{\n  int v;\n  int d;\n  char *ttext;\n  int wastitle;\t/* flag: was there a title? */\n\n  ttext = dap_malloc(strlen(fname) + 11, \"\");\n  if (dap_title)\n    wastitle = 1;\n  else\n    {\n      wastitle = 0;\n      strcpy(ttext, \"Printing: \");\n      strcat(ttext, fname);\n      title(ttext);\n    }\n  dap_head((int *) NULL, 0);\n  if (space == ' ')\n    fprintf(dap_lst, \"  Obs \");\n  for (v = 0; v < nvar; v++)\n    {\n      if (space != ' ' && !strcmp(dap_obs[0].do_nam[varv[v]], \"_type_\"))\n\tcontinue;\n      if (dap_obs[0].do_len[varv[v]] <= 0)\n\t{\n\t  if (space == ' ')\n\t    fprintf(dap_lst, \"%12s\", dap_obs[0].do_nam[varv[v]]);\n\t  else\n\t    fprintf(dap_lst, \"%s\", dap_obs[0].do_nam[varv[v]]);\n\t}\n      else\n\tfprintf(dap_lst, formstr[v], dap_obs[0].do_nam[varv[v]]);\n      if (v < nvar - 1)\n\tputc(space, dap_lst);\n    }\n  putc('\\n', dap_lst);\n  if (space == ' ')\n    {\n      fprintf(dap_lst, \"----- \");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  for (d = 0; dap_obs[0].do_nam[varv[v]][d]; d++)\n\t    putc('-', dap_lst);\n\t  if (dap_obs[0].do_len[varv[v]] <= 0)\t/* DBL or INT */\n\t    {\n\t      while (d < 12)\n\t\t{\n\t\t  putc('-', dap_lst);\n\t\t  d++;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      while (d < dap_obs[0].do_len[varv[v]])\n\t\t{\n\t\t  putc('-', dap_lst);\n\t\t  d++;\n\t\t}\n\t    }\n\t  putc(' ', dap_lst);\n\t}\n      putc('\\n', dap_lst);\n    }\n  if (!wastitle)\n    title(NULL);\n  dap_free(ttext, \"\");\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "void print(char fname[], char *varlist)\n{\n  char *varlist1; /* copy of varlist, changing tabs to spaces if necessary */\n  int space; /* space character for output: space, tab, or comma */\n  int *varv; /* vector of indices for variables */\n  int nvar; /* number of variables to print */\n  int typen; /* index of type variable in varv */\n  char *formmem; /* memory for formats */\n  char **formstr; /* format string */\n  int v; /* index to varlist and to varv */\n  int lenstr; /* length of string variable */\n  int obn;\n\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  inset(fname);\n  space = ' ';\n  if (varlist && varlist[0])\n    {\n      varlist1 = (char *) dap_malloc(strlen(varlist) + 1, \"\");\n      for (v = 0; varlist[v]; v++)\n\t{\n\t  if (varlist[v] == '\\t' || varlist[v] == ',')\n\t    {\n\t      varlist1[v] = ' ';\n\t      if (space == ' ')\n\t\tspace = varlist[v];\n\t      else if (space != varlist[v])\n\t\t{\n\t\t  fputs(\"(print) variable list contains more than one type of separator\\n\",\n\t\t\tdap_err);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\n\t    varlist1[v] = varlist[v];\n\t}\n      varlist1[v] = '\\0';\n      if ((varv[0] = dap_varnum(\"_type_\")) < 0)\n\t{\n\t  fputs(\"(print) Missing _type_ variable.\\n\", dap_err);\n\t  exit(1);\n\t}\n      typen = varv[0];\n      nvar = 1 + dap_list(varlist1, varv + 1, dap_maxvar - 1);\n      if (nvar == 1) /* there were no variables, just the separator */\n\t{\n\t  nvar = dap_obs[0].do_nvar;\n\t  for (v = 0; v < nvar; v++)\n\t    varv[v] = v;\n\t}\n      dap_free(varlist1, \"\");\n    }\n  else\n    {\n      nvar = dap_obs[0].do_nvar;\n      for (v = 0; v < nvar; v++)\n\tvarv[v] = v;\n    }\n  formmem = dap_malloc(nvar * 10, \"\");\n  formstr = (char **) dap_malloc(sizeof(char *) * nvar, \"\");\n  for (v = 0; v < nvar; v++)\n    formstr[v] = formmem + 10 * v;\n  for (v = 0; v < nvar; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] == INT)\n\t{\n\t  lenstr = strlen(dap_obs[0].do_nam[varv[v]]);\n\t  if (lenstr < 12)\n\t    lenstr = 12;\n\t  if (space != ' ')\n\t    lenstr = 0;\n\t  sprintf(formstr[v], \"%%%dd\", lenstr);\n\t}\n      else if (dap_obs[0].do_len[varv[v]] == DBL)\n\t{\n\t  lenstr = strlen(dap_obs[0].do_nam[varv[v]]);\n\t  if (lenstr < 12)\n\t    lenstr = 12;\n\t  if (space != ' ')\n\t    lenstr = 0;\n\t  sprintf(formstr[v], \"%%%dg\", lenstr);\n\t}\n      else\n\t{\n\t  lenstr = strlen(dap_obs[0].do_nam[varv[v]]);\n\t  if (lenstr < dap_obs[0].do_len[varv[v]])\n\t    lenstr = dap_obs[0].do_len[varv[v]];\n\t  if (space != ' ')\n\t    lenstr = 0;\n\t  sprintf(formstr[v], \"%%-%ds\", lenstr);\n\t}\n    }\n  printhead(formstr, space, fname, varv, nvar);\n  for (obn = 1; step(); )\n    {\n      if (space == ' ')\n\tfprintf(dap_lst, \"%5d \", obn);\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (space != ' ' && varv[v] == typen)\n\t    continue;\n\t  if (dap_obs[0].do_len[varv[v]] == INT)\n\t    fprintf(dap_lst, formstr[v], dap_obs[0].do_int[varv[v]]);\n\t  else if (dap_obs[0].do_len[varv[v]] == DBL)\n\t    fprintf(dap_lst, formstr[v], dap_obs[0].do_dbl[varv[v]]);\n\t  else\n\t    fprintf(dap_lst, formstr[v], dap_obs[0].do_str[varv[v]]);\n\t  if (v < nvar - 1)\n\t    putc(space, dap_lst);\n\t}\n      putc('\\n', dap_lst);\n      obn++;\n    }\n  fflush(dap_lst);\n  dap_free(varv, \"\");\n  dap_free(formmem, \"\");\n  dap_free(formstr, \"\");\n}",
      "lines": 118,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "dap_mnsparse": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "int dap_mnsparse(char *varlist, char *outlist, int *varv, int *wtvar, int stats[])\n{\n  int v;\n  int i;\n  int j;\n  int k;\n  char *vname;\n  char *tmplist;\n  int vn;\n  int wn;\n  int nvar;\n  int s;\n  int nonly;\t/* only requested N, for var that didn't exist */\n\n  if (!varlist)\n    {\n      fputs(\"(meansparse) Missing variable list.\\n\", dap_err);\n      exit(1);\n    }\n  vname = dap_malloc(dap_namelen + 6, \"\");\n  for (v = 0; varlist[v]; v++)\n    ;\n  for (--v; v >= 0 && varlist[v] == ' '; --v)\n    ;\n  nvar = 0;\n  tmplist = dap_malloc(dap_listlen + 1, \"\");\n  tmplist[0] = '\\0';\n  wn = -1;\n  for (nonly = 0; v >= 0; )\n    {\n      for (i = v; i >= 0 && varlist[i] != ' ' && varlist[i] != '*'; --i)\n\t;\n      for (j = 0; j < v - i; j++)\n\t{\n\t  if (j < dap_namelen)\n\t    vname[j] = varlist[i + j + 1];\n\t  else\n\t    {\n\t      vname[j] = '\\0';\n\t      fprintf(dap_err, \"(meansparse) Variable name too long: %s\\n\",\n\t\t      vname);\n\t    }\n\t}\n      vname[j] = '\\0';\n      while (i >= 0 && varlist[i] == ' ')\n\t--i;\n      if ((vn = dap_varnum(vname)) >= 0)\n\t{\n\t  if (dap_obs[0].do_len[vn] == DBL)\n\t    {\n\t      if (tmplist[0])\n\t\tstrcat(tmplist, \" \");\n\t      strcat(tmplist, vname);\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(meansparse) Variable must be double: %s\\n\",\n\t\t      vname);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  for (s = 0; s < NSTATS; s++)\n\t    {\n\t      if (s != N && stats[s])\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(meansparse) Statistics other than N requested for unknown variable %s\\n\",\n\t\t\t  vname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  strcpy(tmplist, vname);\n\t  strcat(vname, \" -1\");\n\t  vn = dap_vd(vname, 0);\n\t  nonly = 1;\n\t}\n      v = i;\n      if (v >= 0 && varlist[v] == '*')\n\t{\n\t  wn = vn;\n\t  for (--v; v >= 0 && varlist[v] == ' '; --v)\n\t    ;\n\t}\n      else\n\t{\n\t  wtvar[nvar] = wn;\n\t  varv[nvar++] = vn;\n\t}\n    }\n  for (i = 0; tmplist[i]; i++)\n    ;\n  for (--i; i >= 0 && tmplist[i] == ' '; --i)\n    ;\n  for (outlist[0] = '\\0'; i >= 0; )\n    {\n      for (j = i; j > 0 && tmplist[j - 1] != ' '; --j)\n\t;\n      for (k = 0; k <= i - j; k++)\n\tvname[k] = tmplist[j + k];\n      vname[k] = '\\0';\n      if (outlist[0])\n\tstrcat(outlist, \" \");\n      strcat(outlist, vname);\n      for (i = j - 1; i >= 0 && tmplist[i] == ' '; --i)\n\t;\n    }\n  dap_free(vname, \"\");\n  dap_free(tmplist, \"\");\n  if (nonly)\n    return -nvar;\n  return nvar;\n}",
      "lines": 114,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "dap_stats": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "void dap_stats(char *statlist, int *stats)\n{\n  int s;\n  int i;\n  char *stat;\n  int sn;\n  double pctpt;\n  int pctptn;\n\n  for (s = 0; s < NSTATS; s++)\n    stats[s] = 0;\n  if (!statlist)\n    return;\n  if (!stats)\n    {\n      fputs(\"(dap_stats) Missing statistics index list.\\n\", dap_err);\n      exit(1);\n    }\n  for (s = 0; statlist[s] == ' '; s++)\n    ;\n  stat = dap_malloc(dap_namelen + 1, \"\");\n  for (pctptn = 0; statlist[s]; )\n    {\n      for (i = 0; statlist[s + i] && statlist[s + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    stat[i] = statlist[s + i];\n\t  else\n\t    {\n\t      stat[i] = '\\0';\n\t      fprintf(dap_err, \"(dap_stats) Statistic name too long: %s\\n\", stat);\n\t      exit(1);\n\t    }\n\t}\n      stat[i] = '\\0';\n      if (!strcmp(stat, \"STD\")) /* kluge to allow variants for SD, SEM, TPROB */\n\tstrcpy(stat, \"SD\");\n      else if (!strcmp(stat, \"STDERR\"))\n\tstrcpy(stat, \"SEM\");\n      else if (!strcmp(stat, \"PRT\"))\n\tstrcpy(stat, \"TPROB\");\n      else if (!strcmp(stat, \"MEDIAN\"))\n\tstrcpy(stat, \"MED\");\n      for (sn = 0; sn < NSTATS - MAXPCTPT + pctptn; sn++)\n\t{\n\t  if (!strcmp(stat, dap_sttnm[sn]))\n\t    {\n\t      stats[sn] = 1;\n\t      break;\n\t    }\n\t}\n      if (sn == NSTATS - MAXPCTPT + pctptn)\n\t{\n\t  if (!strncmp(stat, \"STEP\", 4))\n\t    {\n\t      stat[8] = '\\0';\n\t      strcpy(dap_sttnm[STEP], stat);\n\t      stats[STEP] = 1;\n\t    }\n\t  else if (stat[0] == 'P' && sscanf(stat + 1, \"%lf\", &pctpt) == 1)\n\t    {\n\t      if (pctptn++ < MAXPCTPT)\n\t\t{\n\t\t  stats[sn] = 1;\n\t\t  strcpy(dap_sttnm[sn++], stat);\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(dap_stats) Too many user-defined statistics: %s\\n\",\n\t\t\t  stat);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(dap_stats) Invalid statistic name: %s\\n\", stat);\n\t      exit(1);\n\t    }\n\t}\n      s += i;\n      while (statlist[s] == ' ')\n\ts++;\n    }\n  dap_free(stat, \"\");\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "meansout": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "static void meansout(int varv[], int nvar, int nobs[], double sum[], double sumwt[],\n\t\t     double min[], double max[], double ss[], int stats[])\n{\n  double *dn;\n  int typevar;\n  int v;\n  int nsteps;\n  int step;\n  double *range;\n  double fract;\n\n  dap_swap();\n  dn = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  for (v = 0; v < nvar; v++)\n    dn[v] = (double) nobs[v];\n  if ((typevar = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(meansout) Missing _type_ variable\\n\");\n      exit(1);\n    }\n  if (stats[N])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"N\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = dn[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SUM])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SUM\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = sum[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SUMWT])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SUMWT\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = sumwt[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[MEAN])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"MEAN\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = sum[v] / sumwt[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[MIN])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"MIN\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = min[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[MAX])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"MAX\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = max[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[RANGE])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"RANGE\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (nobs[v] >= 1)\n\t    dap_obs[0].do_dbl[varv[v]] = max[v] - min[v];\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[VAR])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"VAR\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (dn[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] = ss[v] / (dn[v] - 1.0);\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SD])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SD\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (dn[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      sqrt(ss[v] / (dn[v] - 1.0));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SEM])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SEM\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (dn[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      sqrt(ss[v] / (dn[v] * (dn[v] - 1.0)));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[VARM])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"VARM\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (dn[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      ss[v] / (dn[v] * (dn[v] - 1.0));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[VARFREQ])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"VARFREQ\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      ss[v] / (sumwt[v] - 1.0);\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SDFREQ])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SDFREQ\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      sqrt(ss[v] / (sumwt[v] - 1.0));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[SEMFREQ])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SEMFREQ\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      sqrt(ss[v] / (sumwt[v] * (sumwt[v] - 1.0)));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[VARMFREQ])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"SEMFREQ\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 1.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      ss[v] / (sumwt[v] * (sumwt[v] - 1.0));\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[STEP])\n    {\n      if (sscanf(dap_sttnm[STEP] + 4, \"%d\", &nsteps) == 1)\n\t{\n\t  range = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n\t  strcpy(dap_obs[0].do_str[typevar], \"STEP\");\n\t  for (v = 0; v < nvar; v++) \n\t    {\n\t      if (nobs[v] >= 1)\n\t\trange[v] = max[v] - min[v];\n\t      else\n\t\trange[v] = 0.0 / 0.0;\n\t    }\n\t  for (step = 0; step <= nsteps; step++)\n\t    {\n\t      fract = ((double) step) / ((double) nsteps);\n\t      for (v = 0; v < nvar; v++)\n\t\tdap_obs[0].do_dbl[varv[v]] =\n\t\t  min[v] + range[v] * fract;\n\t      output();\n\t    }\n\t  dap_free(range, \"\");\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(meansout) Bad number of steps: %s\\n\",\n\t\t  dap_sttnm[STEP] + 4);\n\t  exit(1);\n\t}\n    }\n  if (stats[T])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"T\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 0.0 && ss[v] > 0.0)\n\t    dap_obs[0].do_dbl[varv[v]] = (sum[v] /\n\t\t\t\t\t  sumwt[v]) * sqrt(sumwt[v] *\n\t\t\t\t\t\t\t   (dn[v] - 1.0) / ss[v]);\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  if (stats[TPROB])\n    {\n      strcpy(dap_obs[0].do_str[typevar], \"TPROB\");\n      for (v = 0; v < nvar; v++)\n\t{\n\t  if (sumwt[v] > 0.0 && ss[v] > 0.0)\n\t    dap_obs[0].do_dbl[varv[v]] =\n\t      2.0 * probt(fabs((sum[v] /\n\t\t\t\tsumwt[v]) * sqrt(sumwt[v] *\n\t\t\t\t\t\t (dn[v] - 1.0) / ss[v])), nobs[v] - 1);\n\t  else\n\t    dap_obs[0].do_dbl[varv[v]] = 0.0 / 0.0;\n\t}\n      output();\n    }\n  dap_swap();\n  dap_free(dn, \"\");\n}",
      "lines": 269,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dap_list": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "int dap_list(char *varlist, int *varv, int maxvars)\n{\n  int nvars;\n  int m;\n  int i;\n  char *mname;\n\n  if (!varlist)\n    return 0;\n  if (!varv)\n    {\n      fputs(\"(dap_list) Missing variable index list.\\n\", dap_err);\n      exit(1);\n    }\n  for (m = 0; varlist[m] == ' '; m++)\n    ;\n  mname = dap_malloc(dap_namelen + 1, \"\");\n  for (nvars = 0; varlist[m]; )\n    {\n      for (i = 0; varlist[m + i] && varlist[m + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    mname[i] = varlist[m + i];\n\t  else\n\t    {\n\t      mname[i] = '\\0';\n\t      fprintf(dap_err, \"(dap_list) variable name too long: %s\\n\",\n\t\t      mname);\n\t      exit(1);\n\t    }\n\t}\n      mname[i] = '\\0';\n      if (nvars >= maxvars)\n\t{\n\t  fprintf(dap_err, \"(dap_list) More than %d variables: %s\\n\", maxvars, varlist);\n\t  exit(1);\n\t}\n      if ((varv[nvars++] = dap_varnum(mname)) < 0)\n\t{\n\t  fprintf(dap_err, \"(dap_list) variable unknown: %s\\n\", mname);\n\t  exit(1);\n\t}\n      m += i;\n      while (varlist[m] == ' ')\n\tm++;\n    }\n  dap_free(mname, \"\");\n  return nvars;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dap_newpart": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "int dap_newpart(int markv[], int nmark)\n{\n  int marked;\n  int m;\n\n  marked = 0;\n  if (dap_prev[0].do_valid)\n    {\n      if (dap_obs[0].do_valid)\n\t{\n\t  for (m = 0; m < nmark; m++)\n\t    {\n\t      if (dap_obs[0].do_len[markv[m]] > 0)\n\t\t{\n\t\t  if (strcmp(dap_prev[0].do_str[markv[m]],\n\t\t\t     dap_obs[0].do_str[markv[m]]))\n\t\t    marked = 1;\n\t\t}\n\t      else if (dap_obs[0].do_len[markv[m]] == INT)\n\t\t{\n\t\t  if (dap_prev[0].do_int[markv[m]] !=\n\t\t      dap_obs[0].do_int[markv[m]])\n\t\t    marked = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (dap_prev[0].do_dbl[markv[m]] !=\n\t\t      dap_obs[0].do_dbl[markv[m]])\n\t\t    marked = 1;\n\t\t}\n\t    }\n\t}\n      else\n\tmarked = 1;\n    }\n  return marked;\n}",
      "lines": 37,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "means": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1166,
        1
      ],
      "content": "void means(char *fname, char *varlist, char *statlist, char *marks)\n{\n  char *outname;\n  int stats[NSTATS];\n  int nonly;\n  int *varv;\n  int *markv;\n  int nvar;\n  int nmark;\n  int *nobs;\n  char *outlist;\n  int *wtvar;\n  double *sum;\n  double *sumwt;\n  double *ss;\n  double *min;\n  double *max;\n  int v;\n  double wt;\n  double vtmp;\n  double tmp;\n  int *nnan;\t\t/* number of NaN's for each variable */\n  int more;\n\n  if (!fname)\n    {\n      fputs(\"(means) Missing input dataset name.\\n\", dap_err);\n      exit(1);\n    }\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".mns\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  wtvar = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  outlist = dap_malloc(dap_listlen + 1, \"\");\n  inset(fname);\n  dap_stats(statlist, stats);\n  nvar = dap_mnsparse(varlist, outlist, varv, wtvar, stats);\n  if ((nonly = (nvar < 0)))\n    nvar = -nvar;\n  nobs = (int *) dap_malloc(sizeof(int) * nvar, \"\");\n  nnan = (int *) dap_malloc(sizeof(int) * nvar, \"\");\n  if (marks && marks[0])\n    {\n      strcat(outlist, \" \");\n      strcat(outlist, marks);\n    }\n  outset(outname, outlist);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  sum = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  sumwt = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  ss = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  min = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  max = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  for (v = 0; v < nvar; v++)\n    {\n      sum[v] = 0.0;\n      sumwt[v] = 0.0;\n      ss[v] = 0.0;\n      nobs[v] = 0;\n      nnan[v] = 0;\n    }\n  for (more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  meansout(varv, nvar, nobs, sum, sumwt, min, max, ss, stats);\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      if (nnan[v])\n\t\t{\n\t\t  dap_swap();\n\t\t  fprintf(dap_log, \"(means) %d NaNs for %s\\n\",\n\t\t\t  nnan[v], dap_obs[0].do_nam[varv[v]]);\n\t\t  dap_swap();\n\t\t}\n\t      sum[v] = 0.0;\n\t      sumwt[v] = 0.0;\n\t      ss[v] = 0.0;\n\t      nobs[v] = 0;\n\t      nnan[v] = 0;\n\t    }\n\t}\n      for (v = 0; v < nvar; v++)\n\t{\n\t  vtmp = dap_obs[0].do_dbl[varv[v]];\n\t  if (wtvar[v] >= 0)\n\t    wt = dap_obs[0].do_dbl[wtvar[v]];\n\t  else\n\t    wt = 1.0;\n\t  if (finite(vtmp) && finite(wt))\n\t    {\n\t      if (!nobs[v])\n\t\t{\n\t\t  min[v] = vtmp;\n\t\t  max[v] = vtmp;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (vtmp < min[v])\n\t\t    min[v] = vtmp;\n\t\t  if (vtmp > max[v])\n\t\t    max[v] = vtmp;\n\t\t  tmp = sum[v] - sumwt[v] * vtmp;\n\t\t  ss[v] += tmp * tmp * wt / (sumwt[v] * (sumwt[v] + wt));\n\t\t}\n\t      sumwt[v] += wt;\n\t      sum[v] += vtmp * wt;\n\t      nobs[v]++;\n\t    }\n\t  else if (nonly)\n\t    nobs[v]++;\n\t  else\n\t    nnan[v]++;\n\t}\n    }\n  dap_free(outname, \"\");\n  dap_free(varv, \"\");\n  dap_free(markv, \"\");\n  dap_free(nobs, \"\");\n  dap_free(outlist, \"\");\n  dap_free(wtvar, \"\");\n  dap_free(sum, \"\");\n  dap_free(sumwt, \"\");\n  dap_free(ss, \"\");\n  dap_free(min, \"\");\n  dap_free(max, \"\");\n  dap_free(nnan, \"\");\n}",
      "lines": 130,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "newlab": {
      "start_point": [
        1197,
        0
      ],
      "end_point": [
        1209,
        1
      ],
      "content": "static int newlab(char lname[])\n{\n  if (nextclab == dap_maxclab)\n    {\n      fprintf(dap_err, \"(newlab) too many column labels: %s\\n\", lname);\n      exit(1);\n    }\n  strcpy(collabel[nextclab].lab, lname);\n  collabel[nextclab].labd = -1;\n  collabel[nextclab].laba = -1;\n  collabel[nextclab].labc = -1;\n  return nextclab++;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nodecnt": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "static int nodecnt(int clab)\n{\n  int across;\n  int totalcnt;\n\n  if (collabel[clab].labd < 0)\n    return 1;\n  for (across = collabel[clab].labd, totalcnt = 0;\n       across >= 0; across = collabel[across].laba)\n    totalcnt += nodecnt(across);\n  return totalcnt;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "labelprint": {
      "start_point": [
        1224,
        0
      ],
      "end_point": [
        1238,
        1
      ],
      "content": "static void labelprint(char name[], int width)\n{\n  static char *label = NULL;\n  int c;\n\n  if (!label)\n    label = dap_malloc(dap_strlen + 1, \"\");\n  strcpy(label, name);\n  for (c = 0; label[c] && c < width; c++)\n    ;\n  while (c < width)\n    label[c++] = ' ';\n  label[c] = '\\0';\n  fprintf(dap_lst, \"%s\", label);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "divider": {
      "start_point": [
        1240,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "static void divider(int left, int conn, int sep, int right, int nblank)\n{\n  int col;\n  int c;\n  int connect;\n\n  putc(left, dap_lst);\n  for (col = 0; col < nrowvar; col++)\n    {\n      if (col < nblank)\n\tconnect = ' ';\n      else\n\tconnect = conn;\n      for (c = 0; c < rtitlesp; c++)\n\tputc(connect, dap_lst);\n      if (col < nrowvar - 1)\n\t{\n\t  if (col < nblank)\n\t    putc(left, dap_lst);\n\t  else\n\t    putc(sep, dap_lst);\n\t}\n      else\n\tputc(right, dap_lst);\n    }\n  for (col = 0; col < ncols; col++)\n    {\n      for (c = 0; c < cellwidth; c++)\n\tputc(conn, dap_lst);\n      if (col < ncols - 1)\n\tputc(sep, dap_lst);\n      else\n\tputc(right, dap_lst);\n    }\n  putc('\\n', dap_lst);\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tableline": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "static void tableline(int start, int depth)\n{\n  int across;\n  int cnt;\n  int c;\n\n  for (across = start; across >= 0; across = collabel[across].laba)\n    {\n      if (!depth)\n\t{\n\t  labelprint(collabel[across].lab, cellwidth);\n\t  cnt = nodecnt(across);\n\t  for (c = 0; c < (cnt - 1) * (cellwidth + 1); c++)\n\t    putc(' ', dap_lst);\n\t  putc('|', dap_lst);\n\t}\n      else\n\ttableline(collabel[across].labd, depth - 1);\n    }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tablehead": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1352,
        1
      ],
      "content": "static void tablehead()\n{\n  int row, col;\n  int c;\n\n  putc(' ', dap_lst);\n  for (col = 0; col < nrowvar; col++)\n    {\n      for (c = 0; c < rtitlesp + 1; c++)\n\tputc(' ', dap_lst);\n    }\n  fputs(dap_obs[0].do_nam[colvar[ncolvar - 1]], dap_lst);\n  if (colvar[0] >= 0)\n    {\n      fputs(\" for \", dap_lst);\n      for (col = 0; col < ncolvar - 1; col++)\n\t{\n\t  fprintf(dap_lst, dap_obs[0].do_nam[colvar[col]]);\n\t  if (col < ncolvar - 2)\n\t    fprintf(dap_lst, \" / \");\n\t}\n    }\n  putc('\\n', dap_lst);\n  divider('=', '=', '=', '=', 0);\n  for (row = 0; row < ncolvar - 1; row++)\n    {\n      if (row < ncolvar - 2)\n\t{\n\t  putc('|', dap_lst);\n\t  for (col = 0; col < nrowvar; col++)\n\t    {\n\t      for (c = 0; c < rtitlesp; c++)\n\t\tputc(' ', dap_lst);\n\t      if (col < nrowvar - 1)\n\t\tputc(' ', dap_lst);\n\t      else\n\t\tputc('|', dap_lst);\n\t    }\n\t}\n      else\n\t{\n\t  putc('|', dap_lst);\n\t  for (col = 0; col < nrowvar; col++)\n\t    {\n\t      labelprint(dap_obs[0].do_nam[rowvar[col]], rtitlesp);\n\t      putc('|', dap_lst);\n\t    }\n\t}\n      tableline(labroot, row);\n      putc('\\n', dap_lst);\n      if (row < ncolvar - 2)\n\tdivider('|', '-', '+', '|', 0);\n    }\n  divider('|', '=', '|', '|', 0);\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "valprint": {
      "start_point": [
        1354,
        0
      ],
      "end_point": [
        1370,
        1
      ],
      "content": "static void valprint(int row, int node)\n{\n  while (node >= 0)\n    {\n      if (collabel[node].labd >= 0)\n\tvalprint(row, collabel[node].labd);\n      else\n\t{\n\t  if (valset[row][collabel[node].labc])\n\t    fprintf(dap_lst, tabform, tableval[row][collabel[node].labc]);\n\t  else\n\t    fprintf(dap_lst, emptyform, \"\");\n\t  putc('|', dap_lst);\n\t}\n      node = collabel[node].laba;\n    }\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tableprint": {
      "start_point": [
        1372,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "static void tableprint()\n{\n  int row, col;\n  int isblank;\n  int nextblank;\n  int nblank;\n  int nextnblank;\n\n  for (row = 0; row <= nrows; row++)\n    {\n      putc('|', dap_lst);\n      nblank = 0;\n      nextnblank = 0;\n      for (col = 0, isblank = 1, nextblank = 1;\n\t   col < nrowvar; col++)\n\t{\n\t  if (isblank && rowlabel[row][col][0])\n\t    {\n\t      nblank = col;\n\t      isblank = 0;\n\t    }\n\t  if (nextblank && row <= nrows - 1 && rowlabel[row + 1][col][0])\n\t    {\n\t      nextnblank = col;\n\t      nextblank = 0;\n\t    }\n\t  labelprint(rowlabel[row][col], rtitlesp);\n\t  putc('|', dap_lst);\n\t}\n      valprint(row, labroot);\n      putc('\\n', dap_lst);\n      if (nextnblank != nblank)\n\tnblank = nextnblank;\n      if (row <= nrows - 1)\n\tdivider('|', '-', '+', '|', nblank);\n      else\n\tdivider('-', '-', '-', '-', 0);\n    }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "findcol": {
      "start_point": [
        1412,
        0
      ],
      "end_point": [
        1503,
        1
      ],
      "content": "static int findcol()\n{\n  int varn;\n  int node, prevnode, nextnode;\n  int upnode;\n  int cmp;\n  char *label;\n\n  nextnode = -1;\n  if (colsort && colvar[0] >= 0)\n    {\n      for (node = labroot, varn = 0, upnode = -1; varn < ncolvar - 1; varn++)\n\t{\n\t  if (node >= 0)\n\t    {\n\t      for (nextnode = collabel[node].laba;\n\t\t   nextnode >= 0 &&\n\t\t     strcmp(dap_obs[0].do_str[colvar[varn]],\n\t\t\t    collabel[nextnode].lab) >= 0; )\n\t\t{\n\t\t  node = nextnode;\n\t\t  nextnode = collabel[nextnode].laba;\n\t\t}\n\t      cmp = strcmp(dap_obs[0].do_str[colvar[varn]], collabel[node].lab);\n\t    }\n\t  else\n\t    cmp = -1;\n\t  if (cmp < 0)\t/* only if no node or node is first in horizontal string */\n\t    {\n\t      if (upnode >= 0)\n\t\t{\n\t\t  nextnode = node;\n\t\t  node = newlab(dap_obs[0].do_str[colvar[varn]]);\n\t\t  collabel[upnode].labd = node;\n\t\t  collabel[node].laba = nextnode;\n\t\t}\n\t      else\n\t\t{\n\t\t  labroot = newlab(dap_obs[0].do_str[colvar[varn]]);\n\t\t  collabel[labroot].laba = node;\n\t\t  node = labroot;\n\t\t}\n\t    }\n\t  else if (cmp > 0)\n\t    {\n\t      collabel[node].laba = newlab(dap_obs[0].do_str[colvar[varn]]);\n\t      node = collabel[node].laba;\n\t      collabel[node].laba = nextnode;\n\t    }\n\t  upnode = node;\n\t  node = collabel[node].labd;\n\t}\n    }\n  else\n    {\n      for (node = labroot, varn = 0, upnode = -1; varn < ncolvar - 1; varn++)\n\t{\n\t  if (colvar[0] >= 0)\n\t    label = dap_obs[0].do_str[colvar[varn]];\n\t  else\n\t    label = \"\";\n\t  for (prevnode = -1; node >= 0 &&\n\t\t strcmp(label, collabel[node].lab); )\n\t    {\n\t      prevnode = node;\n\t      node = collabel[node].laba;\n\t    }\n\t  if (node < 0)\n\t    {\n\t      node = newlab(label);\n\t      if (prevnode >= 0)\n\t\tcollabel[prevnode].laba = node;\n\t      else if (upnode >= 0)\n\t\tcollabel[upnode].labd = node;\n\t      else\n\t\tlabroot = node;\n\t    }\n\t  upnode = node;\n\t  node = collabel[node].labd;\n\t}\n    }\n  if (collabel[upnode].labc < 0)\n    {\n      if (ncols >= dap_maxcols)\n\t{\n\t  fputs(\"(findcol) too many columns in table\\n\", dap_err);\n\t  exit(1);\n\t}\n      collabel[upnode].labc = ncols++;\n    }\n  return collabel[upnode].labc;\n}",
      "lines": 92,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tableform": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "static void tableform(char tform[])\n{\n  char width[7];\n  int w;\n  int forg; /* use \"f\" or \"g\" format */\n\n  strcpy(width, tform);\n  for (w = 0; width[w] && width[w] != '.'; w++)\n    ;\n  if (width[w] == '.')\n    forg = 'f';\n  else\n    forg = 'g';\n  width[w] = '\\0';\n  cellwidth = atoi(width);\n  strcpy(tabform, \"%\");\n  if (forg == 'f')\n    {\n      strcat(tabform, tform);\n      strcat(tabform, \"f\");\n    }\n  else\n    {\n      strcat(tabform, width);\n      strcat(tabform, \"g\");\n    }\n  sprintf(emptyform, \"%%%ds\", cellwidth);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "specparse": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1686,
        1
      ],
      "content": "static void specparse(char rowvars[], char colvars[], char format[])\n{\n  int t;\n  int i;\n  int sp;\n  char *vname;\n  int v;\n\n  vname = dap_malloc(dap_namelen + 1, \"\");\n  nrowvar = 0;\n  ncolvar = 0;\n  for (t = 0; rowvars[t] == ' '; t++)\n    ;\n  while (rowvars[t])\n    {\n      while (rowvars[t] == ' ')\n\tt++;\n      for (i = 0; rowvars[t + i] && rowvars[t + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    vname[i] = rowvars[t + i];\n\t  else\t\n\t    {\n\t      vname[i] = '\\0';\n\t      fprintf(dap_err,\n\t\t      \"(specparse) Row variable name too long: %s\\n\",\n\t\t      vname);\n\t      exit(1);\n\t    }\n\t}\n      vname[i] = '\\0';\n      if ((v = dap_varnum(vname)) >= 0)\n\t{\n\t  if (nrowvar < dap_maxrowv)\n\t    rowvar[nrowvar++] = v;\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(specparse) Too many row variables: %s\\n\",\n\t\t      vname);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(specparse) Unknown row variable: %s\\n\",\n\t\t  vname);\n\t  exit(1);\n\t}\n      t += i;\n      while (rowvars[t] == ' ')\n\tt++;\n    }\n  for (t = 0; colvars[t] == ' '; t++)\n    ;\n  while (colvars[t])\n    {\n      for (i = 0; colvars[t + i] && colvars[t + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    vname[i] = colvars[t + i];\n\t  else\n\t    {\n\t      vname[i] = '\\0';\n\t      fprintf(dap_err,\n\t\t      \"(specparse) Column variable name too long: %s\\n\",\n\t\t      vname);\n\t      exit(1);\n\t    }\n\t}\n      vname[i] = '\\0';\n      if ((v = dap_varnum(vname)) >= 0)\n\t{\n\t  if (ncolvar < dap_maxcolv)\n\t    colvar[ncolvar++] = v;\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(specparse) Too many column variables: %s\\n\",\n\t\t      vname);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(specparse) Unknown column variable: %s\\n\",\n\t\t  vname);\n\t  exit(1);\n\t}\n      t += i;\n      while (colvars[t] == ' ')\n\tt++;\n    }\n  for (t = 0; format[t] == ' '; t++)\n    ;\n  if (format[t] == 's')\n    {\n      colsort = 1;\n      for (t++; format[t] == ' '; t++)\n\t;\n    }\n  else\n    colsort = 0;\n  /* misuse of vname: initial part of format spec */\n  for (i = 0; format[t + i] && format[t + i] != ' '; i++)\n    {\n      if (i < dap_namelen)\n\tvname[i] = format[t + i];\n      else\n\t{\n\t  vname[i] = '\\0';\n\t  fprintf(dap_err,\n\t\t  \"(specparse) Format too long %s\\n\", vname);\n\t  exit(1);\n\t}\n    }\n  vname[i] = '\\0';\n  tableform(vname);\n  for (t += i; format[t] == ' '; t++)\n    ;\n  if (format[t])\n    {\n      for (sp = 0; '0' <= format[t] && format[t] <= '9'; t++)\n\tsp = 10 * sp + format[t] - '0';\n      if (format[t])\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(specparse) Extra character(s) at end of format: %s\\n\",\n\t\t  format);\n\t  exit(1);\n\t}\n      rtitlesp = (sp - 1) / nrowvar;\n    }\n  if (!tabform[0])\n    {\n      fprintf(dap_err, \"(specparse) No format\\n\");\n      exit(1);\n    }\n  if (!ncolvar)\n    {\n      fputs(\"(specparse) No column or analysis variable(s) specified.\\n\", dap_err);\n      exit(1);\n    }\n  if (ncolvar < 2)\n    {\n      colvar[1] = colvar[0];\n      colvar[0] = -1;\n      ncolvar = 2;\n    }\n  dap_free(vname, \"\");\n}",
      "lines": 153,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "table": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "void table(char *fname, char *rowvars, char *colvars, char *format, char *marks)\n{\n  static int tabinit = 0;\t\t\t/* has memory been allocated? */\n  static char *prevmem;\n  static char **prev;\t\t\t/* previous value of row variable */\n  int r;\t\t\t\t\t/* row number */\n  int s;\n  int c;\t\t\t\t\t/* column number */\n  int v;\n  static int *markv;\t\t\t/* mark vector for grouping */\n  int nmark;\t\t\t\t/* number of variables for marking groups */\n  int more;\t\t\t\t/* flag: another line of input read? */\n  static char *nstring;\t\t\t/* temp string for converting numbers to char */\n\n  if (!tabinit)\n    {\n      tabinit = 1;\n      valsetmem = (int *) dap_malloc(dap_maxrows * dap_maxcols * sizeof(int), \"\");\n      valset = (int **) dap_malloc(dap_maxrows * sizeof(int *), \"\");\n      for (r = 0; r < dap_maxrows; r++)\n\tvalset[r] = valsetmem + dap_maxcols * r;\n      tabvalmem = (double *) dap_malloc(dap_maxrows * dap_maxcols * sizeof(double), \"\");\n      tableval = (double **) dap_malloc(dap_maxrows * sizeof(double *), \"\");\n      for (r = 0; r < dap_maxrows; r++)\n\ttableval[r] = tabvalmem + dap_maxcols * r;\n      collabel = (labnode *) dap_malloc(dap_maxclab * sizeof(labnode), \"\");\n      for (c = 0; c < dap_maxclab; c++)\n\tcollabel[c].lab = dap_malloc(dap_lablen + 1, \"\");\n      rowvar = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n      colvar = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n      rlabmem = dap_malloc(dap_maxrows * dap_maxrowv * (dap_lablen + 1), \"\");\n      rlptrmem = (char **) dap_malloc(sizeof(char *) * dap_maxrows * dap_maxrowv, \"\");\n      rowlabel = (char ***) dap_malloc(sizeof(char **) * dap_maxrows, \"\");\n      for (r = 0; r < dap_maxrows; r++)\n\t{\n\t  rowlabel[r] = rlptrmem + r * dap_maxrowv;\n\t  for (v = 0; v < dap_maxrowv; v++)\n\t    rowlabel[r][v] = rlabmem +\n\t      r * (dap_maxrowv * (dap_lablen + 1)) +\n\t      v * (dap_lablen + 1);\n\t}\n      prevmem = dap_malloc(dap_maxrowv * (dap_lablen + 1), \"\");\n      prev = (char **) dap_malloc(sizeof(char *) * dap_maxrowv, \"\");\n      for (v = 0; v < dap_maxrowv; v++)\n\tprev[v] = prevmem + v * (dap_lablen + 1);\n      markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n      nstring = dap_malloc(dap_strlen + 1, \"dap_strlen\");\n    }\n  if (!fname)\n    {\n      fputs(\"(table) no dataset name given\\n\", dap_err);\n      exit(1);\n    }\n  inset(fname);\n  tabform[0] = '\\0';\n  rtitlesp = 8;\n  if (!rowvars || !colvars)\n    {\n      fputs(\"(table) no row and/or column variables specified\\n\", dap_err);\n      exit(1);\n    }\n  if (!format)\n    {\n      fputs(\"(table) no format given\\n\", dap_err);\n      exit(1);\n    }\n  /* NOTE: the following has a side-effect to change rtitlesp */\n  specparse(rowvars, colvars, format);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  nextclab = 0;\n  labroot = -1;\n  ncols = 0;\n  for (r = 0; r < nrowvar; r++)\n    {\n      prev[r][0] = '\\0';\n      if (dap_obs[0].do_len[rowvar[r]] <= 0)\n\t{\n\t  if (dap_obs[0].do_str[rowvar[r]])\n\t    dap_free(dap_obs[0].do_str[rowvar[r]], \"\");\n\t  dap_obs[0].do_str[rowvar[r]] = dap_malloc(rtitlesp + 1, \"\");\n\t}\n    }\n  for (c = 0; c < ncolvar - 1; c++)\n    {\n      if (dap_obs[0].do_len[colvar[c]] <= 0)\n\t{\n\t  if (dap_obs[0].do_str[colvar[c]])\n\t    dap_free(dap_obs[0].do_str[colvar[c]], \"\");\n\t  dap_obs[0].do_str[colvar[c]] = dap_malloc(rtitlesp + 1, \"\");\n\t}\n    }\n  for (r = 0; r < dap_maxrows; r++)\n    for (c = 0; c < dap_maxcols; c++)\n      valset[r][c] = 0;\n  for (nrows = -1, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  tablehead();\n\t  tableprint();\n\t  dap_swap();\n\t  nextclab = 0;\n\t  labroot = -1;\n\t  ncols = 0;\n\t  for (r = 0; r < nrowvar; r++)\n\t    prev[r][0] = '\\0';\n\t  for (r = 0; r < dap_maxrows; r++)\n\t    for (c = 0; c < dap_maxcols; c++)\n\t      valset[r][c] = 0;\n\t  nrows = -1;\n\t}\n      for (r = 0; r < nrowvar; r++)\n\t{\n\t  if (dap_obs[0].do_len[rowvar[r]] == INT)\n\t    {\n\t      sprintf(nstring, \"%d\", dap_obs[0].do_int[rowvar[r]]);\n\t      strncpy(dap_obs[0].do_str[rowvar[r]], nstring, rtitlesp);\n\t      dap_obs[0].do_str[rowvar[r]][rtitlesp] = '\\0';\n\t    }\n\t  else if (dap_obs[0].do_len[rowvar[r]] == DBL)\n\t    {\n\t      sprintf(nstring, \"%g\", dap_obs[0].do_dbl[rowvar[r]]);\n\t      strncpy(dap_obs[0].do_str[rowvar[r]], nstring, rtitlesp);\n\t      dap_obs[0].do_str[rowvar[r]][rtitlesp] = '\\0';\n\t    }\n\t}\n      for (r = 0; r < nrowvar; r++)\n\t{\n\t  if (strcmp(dap_obs[0].do_str[rowvar[r]], prev[r]))\n\t    break;\n\t}\n      if (r < nrowvar)\n\t{\n\t  nrows++;\n\t  for (s = 0; s < r; s++)\n\t    rowlabel[nrows][s][0] = '\\0';\n\t  for ( ; r < nrowvar; r++)\n\t    {\n\t      strcpy(prev[r], dap_obs[0].do_str[rowvar[r]]);\n\t      strcpy(rowlabel[nrows][r],\n\t\t     dap_obs[0].do_str[rowvar[r]]);\n\t    }\n\t}\n      if (nrows < 0)\n\t{\n\t  fputs(\"(table) No rows.\\n\", dap_err);\n\t  exit(1);\n\t}\n      for (c = 0; c < ncolvar - 1; c++)\n\t{\n\t  if (dap_obs[0].do_len[colvar[c]] == INT)\n\t    {\n\t      sprintf(nstring, \"%d\", dap_obs[0].do_int[colvar[c]]);\n\t      strncpy(dap_obs[0].do_str[colvar[c]], nstring, rtitlesp);\n\t      dap_obs[0].do_str[colvar[c]][rtitlesp] = '\\0';\n\t    }\n\t  else if (dap_obs[0].do_len[colvar[c]] == DBL)\n\t    {\n\t      sprintf(nstring, \"%g\", dap_obs[0].do_dbl[colvar[c]]);\n\t      strncpy(dap_obs[0].do_str[colvar[c]], nstring, rtitlesp);\n\t      dap_obs[0].do_str[colvar[c]][rtitlesp] = '\\0';\n\t    }\n\t}\n      c = findcol();\n      tableval[nrows][c] = dap_obs[0].do_dbl[colvar[ncolvar - 1]];\n      valset[nrows][c] = 1;\n    }\n}",
      "lines": 171,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "split": {
      "start_point": [
        1866,
        0
      ],
      "end_point": [
        1975,
        1
      ],
      "content": "void split(char *fname, char *varlist, char *classvalvars)\n{\n  char *skiplist;\t/* names of variables not to put in output dataset */\n  char *outname;\t/* name of output dataset */\n  char *classvar;\t/* name of classification variable */\n  char *valuevar;\t/* name of value variable */\n  int s, t;\t/* indexes to strings */\n  char *varname;\t/* name of variable in varlist */\n  int maxname;\t/* maximum length of variable name in varlist */\n  int *var;\t/* array of indexes to vars in varlist */\n  int nv;\t\t/* number of variables in varlist */\n  int vv;\t\t/* index to var */\n  int vlen;\t/* length (type) of variables in varlist */\n  int prevlen;\t/* for checking constancy of vlen */\n  int classv, valuev;\t/* indexes of class and value vars */\n\n  /* need space for length specification */\n  classvar = dap_malloc(strlen(varlist) + 6, \"\");\t/* should be longer than needed */\n  valuevar = dap_malloc(strlen(varlist) + 6, \"\");\t/* should be longer than needed */\n  for (s = 0; classvalvars[s] == ' '; s++)\t/* skip spaces */\n    ;\n  /* copy classification variable name */\n  for (t = 0; classvalvars[s] && classvalvars[s] != ' '; )\n    classvar[t++] = classvalvars[s++];\n  classvar[t] = '\\0';\n  if (!t)\n    {\n      fputs(\"(split) No classification variable specified.\\n\", dap_err);\n      exit(1);\n    }\n  while (classvalvars[s] == ' ')\n    s++;\t/* skip spaces */\n  /* copy value variable name */\n  for (t = 0; classvalvars[s] && classvalvars[s] != ' '; )\n    valuevar[t++] = classvalvars[s++];\n  valuevar[t] = '\\0';\n  if (!t)\n    {\n      fprintf(dap_err, \"(split) No value variable specified: %s\\n\", classvalvars);\n      exit(1);\n    }\n  var = (int *) dap_malloc(sizeof(int) * ((strlen(varlist) + 1) / 2), \"\"); /* more than necessary */\n  varname = dap_malloc(strlen(varlist) + 1, \"\");\t/* longest possible name */\n  skiplist = dap_malloc(strlen(varlist) + 2, \"\");\t/* prepare to eliminate variables */\n  strcpy(skiplist, \"!\");\t\t/* if outset second parameter starts with '!'... */\n  strcat(skiplist, varlist);\t/* those variables are dropped */\n  outname = dap_malloc(strlen(fname) + 5, \"\"); /* outname will have \".spl\" appended */\n  strcpy(outname, fname);\n  strcat(outname, \".spl\");\n  inset(fname);\t/* set up input dataset */\n  /* now set up variables to split */\n  for (s = 0; varlist[s] == ' '; s++)\n    ;\n  for (nv = 0, prevlen = DBL - 1, maxname = 0; varlist[s]; nv++)\n    {\n      for (t = 0; varlist[s] && varlist[s] != ' '; )\n\tvarname[t++] = varlist[s++];\n      varname[t] = '\\0';\n      if (t > maxname)\n\tmaxname = t;\n      if ((var[nv] = dap_varnum(varname)) < 0)\n\t{\n\t  fprintf(dap_err, \"(split) Unknown variable: %s\\n\", varname);\n\t  exit(1);\n\t}\n      vlen = dap_obs[dap_ono].do_len[var[nv]];\n      if (prevlen < DBL)\n\tprevlen = vlen;\n      else if (prevlen != vlen)\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(split) Length of %s (%d) differs from that of previous variables (%d)\\n\",\n\t\t  varname, vlen, prevlen);\n\t  exit(1);\n\t}\n      while (varlist[s] == ' ')\t/* skip to next or end */\n\ts++;\n    }\n  sprintf(classvar + strlen(classvar), \" %d\", maxname);\n  classv = dap_vd(classvar, 0);\t/* set up variable, 0 = not input from dataset */\n  sprintf(valuevar + strlen(valuevar), \" %d\", vlen);\n  valuev = dap_vd(valuevar, 0);\t/* set up variable, 0 = not input from dataset */\n  outset(outname, skiplist);\n  while (step())\n    {\n      for (vv = 0; vv < nv; vv++)\n\t{\t/* for each variable in varlist */\n\t  /* copy name to classification variable */\n\t  strcpy(dap_obs[dap_ono].do_str[classv],\n\t\t dap_obs[dap_ono].do_nam[var[vv]]);\n\t  /* and value to valuevar */\n\t  if (vlen == DBL)\n\t    dap_obs[dap_ono].do_dbl[valuev] =\n\t      dap_obs[dap_ono].do_dbl[var[vv]];\n\t  else if (vlen == INT)\n\t    dap_obs[dap_ono].do_int[valuev] =\n\t      dap_obs[dap_ono].do_int[var[vv]];\n\t  else\n\t    strcpy(dap_obs[dap_ono].do_str[valuev],\n\t\t   dap_obs[dap_ono].do_str[var[vv]]);\n\t  output();\t/* and write line to output dataset */\n\t}\n    }\n  dap_free(classvar, \"\");\n  dap_free(valuevar, \"\");\n  dap_free(var, \"\");\n  dap_free(skiplist, \"\");\n  dap_free(outname, \"\");\n  dap_free(varname, \"\");\n}",
      "lines": 110,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "join": {
      "start_point": [
        1980,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "void join(char *fname, char *partvars, char *valuevar)\n{\n  char *partvars1;\t/* all of partvars except last variable */\n  int npart;\t\t/* number of these partvars */\n  char *classvar;\t\t/* last variable of partvars */\n  int s, t;\t\t/* indexes for strings for copying */\n  char *outname;\t\t/* name of output dataset */\n  char *skiplist;\t\t/* list of variables to exclude from output dataset */\n  int cv;\t\t\t/* index of classvar */\n  int vv;\t\t\t/* index of valuevar */\n  int nnew;\t\t/* number of new variables */\n  int nv;\t\t\t/* index to new variable names */\n  int vlen;\t\t/* max length needed for new variable name */\n  int *partv;\t\t/* index array for partitioning */\n  int *newv;\t\t/* array of indexes of new variables */\n  int valv;\t\t/* index of valuevar */\n  int vallen;\t\t/* length of valuevar, and therefore of new variables */\n  char *varspec;\t\t/* for call to dap_vd to allocate new variables */\n  int more;\t\t/* for processing dataset: more lines? */\n  int np;\t\t\t/* index to partv */\n\n  outname = dap_malloc(strlen(fname) + 5, \"\");\t/* room for \".joi\" */\n  strcpy(outname, fname);\n  strcat(outname, \".joi\");\n  newv = (int *) dap_malloc(sizeof(int *) * dap_maxvar, \"dap_maxvar\");\n  partvars1 = dap_malloc(strlen(partvars) + 1, \"\");\t/* partvars1 shorter than partvars */\n  /* need to find last variable in partvars */\n  for (s = 0; partvars[s] == ' '; s++)\n    ;\t/* s marks beginning of first variable */\n  for (npart = 0; partvars[s]; )\t/* while there is a next variable */\n    {\n      /* skip through variable */\n      for (t = s; partvars[t] && partvars[t] != ' '; t++)\n\t;\n      /* continue past spaces following it */\n      while (partvars[t] == ' ')\n\tt++;\n      if (partvars[t])\t/* found another variable */\n\t{\n\t  s = t;\t\t/* mark start */\n\t  npart++;\n\t}\n      else\t\t\t/* s marks start of final variable */\n\tbreak;\n    }\n  strncpy(partvars1, partvars, s);\n  partvars1[s] = '\\0';\t/* now we have all but the final variable */\n  classvar = dap_malloc(strlen(partvars) - s + 2, \"\");\t/* need extra for null */\n  for (t = 0; partvars[s] && partvars[s] != ' '; )\n    classvar[t++] = partvars[s++];\n  classvar[t] = '\\0';\t/* get that final variable */\n  /* construct list for outset to exclude */\n  skiplist = dap_malloc(strlen(classvar) + strlen(valuevar) + 3, \"\");\n  if (strcmp(classvar, \"_type_\"))\t/* always need _type_ */\n    sprintf(skiplist, \"!%s %s\", classvar, valuevar);\n  else\n    sprintf(skiplist, \"!%s\", valuevar);\n  /* now get new variable names from actual values in the dataset */\n  inset(fname);\n  if ((cv = dap_varnum(classvar)) < 0)\n    {\n      fprintf(dap_err, \"(join) Unknown variable: %s\\n\", classvar);\n      exit(1);\n    }\n  if ((valv = dap_varnum(valuevar)) < 0)\n    {\n      fprintf(dap_err, \"(join) Unknown variable: %s\\n\", valuevar);\n      exit(1);\n    }\n  /* length of valuevar give length of new variables */\n  vallen = dap_obs[dap_ono].do_len[valv];\n  /* length of string gives length of variable name */\n  vlen = dap_obs[dap_ono].do_len[cv];\n  varspec = dap_malloc(vlen + 5, \"\");\t/* should be long enough */\n  if (vlen <= 0)\n    {\n      fprintf(dap_err, \"(join) Variable %s not string variable (%d)\\n\", classvar, vlen);\n      exit(1);\n    }\n  dap_mark();\t/* after setting all this up, will need to start over */\n  partv = (int *) dap_malloc(sizeof(int *) * npart, \"\");\t/* allocate */\n  dap_list(partvars1, partv, npart);\t/* set up partv index array */\n  /* now get new variable names and set them up */\n  for (nnew = 0; step(); nnew++)\n    {\n      if (dap_newpart(partv, npart))\t/* complete list must be in first part */\n\tbreak;\n      /* name of new variable is string value of classvar */\n      strcpy(varspec, dap_obs[dap_ono].do_str[cv]);\n      /* length (type) comes from valuevar */\n      sprintf(varspec + strlen(varspec), \" %d\", vallen);\n      /* set up new variable */\n      newv[nnew] = dap_vd(varspec, 0);\t/* 0 = not input var */\n    }\n  dap_rewind();\t/* now process the dataset */\n  outset(outname, skiplist);\n  for (more = 1, nv = 0; more; nv++)\n    {\n      more = step();\n      if (dap_newpart(partv, npart))\n\t{\n\t  if (nv < nnew)\n\t    {\n\t      fprintf(dap_err, \"(join) Too few lines in part:\");\n\t      for (np = 0; np < npart; np++)\n\t\t{\n\t\t  putc(' ', dap_err);\n\t\t  fputs(dap_obs[dap_ono].do_str[partv[np]], dap_err);\n\t\t}\n\t      putc('\\n', dap_err);\n\t      exit(1);\n\t    }\n\t  dap_swap();\n\t  output();\n\t  dap_swap();\n\t  nv = 0;\n\t}\n      if (more)\n\t{\n\t  if (nv >= nnew)\n\t    {\n\t      fprintf(dap_err, \"(join) Too many lines at %s\\n\",\n\t\t      dap_obs[dap_ono].do_str[cv]);\n\t      exit(1);\n\t    }\n\t  if (strcmp(dap_obs[dap_ono].do_nam[newv[nv]],\n\t\t     dap_obs[dap_ono].do_str[cv]))\n\t    {\n\t      fprintf(dap_err, \"(join) Missing or extra lines at %s\\n\",\n\t\t      dap_obs[dap_ono].do_str[cv]);\n\t      exit(1);\n\t    }\n\t  if (vallen == DBL)\n\t    dap_obs[dap_ono].do_dbl[newv[nv]] =\n\t      dap_obs[dap_ono].do_dbl[valv];\n\t  else if (vallen == INT)\n\t    dap_obs[dap_ono].do_int[newv[nv]] =\n\t      dap_obs[dap_ono].do_int[valv];\n\t  else\n\t    strcpy(dap_obs[dap_ono].do_str[newv[nv]],\n\t\t   dap_obs[dap_ono].do_str[valv]);\n\t}\n    }\n  dap_free(outname, \"\");\n  dap_free(newv, \"\");\n  dap_free(partvars1, \"\");\n  dap_free(classvar, \"\");\n  dap_free(skiplist, \"\");\n  dap_free(varspec, \"\");\n  dap_free(partv, \"\");\n}",
      "lines": 151,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "strtoi": {
      "start_point": [
        2171,
        0
      ],
      "end_point": [
        2186,
        1
      ],
      "content": "static int strtoi(char *s, int *pi, int *ps)\n{\n  int i;\n\n  for (i = 0; '0' <= *s && *s <= '9'; s++)\n    i = 10 * i + *s - '0';\n  *pi = i;\n  if (*s == 'd')\n    {\n      *ps = 0;\n      s++;\n    }\n  else\n    *ps = 1;\n  return !*s;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup": {
      "start_point": [
        2188,
        0
      ],
      "end_point": [
        2199,
        1
      ],
      "content": "static void cleanup(int nseg)\n{\n  int s; /* segment number */\n  char segname[] = TMPLATE;\n\n  for (s = 0; s < nseg; s++)\n    {\n      strcpy(segname, tmplate);\n      sprintf(segname + 18, \"%06d\", s);\n      unlink(segname);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "linecmp": {
      "start_point": [
        2201,
        0
      ],
      "end_point": [
        2210,
        1
      ],
      "content": "static int linecmp(char **s1, char **s2)\n{\n  char *t1, *t2;\n  char *e1;\n\n  /* run through keys until chars differ or at -- not beyond -- end of keys */\n  for (e1 = *s1 + keylen - 1, t1 = *s1, t2 = *s2; t1 < e1 && *t1 == *t2; t1++, t2++)\n    ;\n  return (keymap[t1 - *s1] ? *t1 - *t2 : *t2 - *t1);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sortseg": {
      "start_point": [
        2213,
        0
      ],
      "end_point": [
        2278,
        1
      ],
      "content": "static int sortseg(int orig, int s)\n{\n  char segname[] = TMPLATE;\n  ssize_t nread; /* number of bytes read so far */\n  int seg; /* file descriptor of segment to write */\n  char *m1, *m2; /* for stepping through mem1 and mem2 */\n  int nlines; /* the actual number of lines read */\n  char *lstart1, *lstart2; /* start of line to be read and written */\n  int f; /* index to fields */\n  int last; /* last char gotten from line */\n  int l; /* for stepping through line */\n  char *lp; /* for stepping through fields */\n  char *mp; /* for putting characters back into m */\n  int newfield; /* starting new field in line? */\n  int (*cmp)();\n\n  cmp = &linecmp;\n  nread = read(orig, mem1, dap_maxmem); /* read into mem1, reorder fields into mem2 */\n  if (!nread) /* nothing to read */\n    return 0;\n  strcpy(segname, tmplate);\n  sprintf(segname + 18, \"%06d\", s);\n  if ((seg = open(segname, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)) < 0)\n    {\n      fprintf(dap_err, \"(dsort) can't write %s\\n\", segname);\n      exit(1);\n    }\n  /* lstart1 is start of line we're getting, but may not get all of */\n  /* need to reorder fields in accordance with fieldstart */\n  for (lstart1 = mem1, lstart2 = mem2, nlines = 0;\n       lstart1 < mem1 + nread && lstart2 + linelen < mem2 + dap_maxmem;\n       lstart1 = m1, lstart2 += linelen)\n    {\n      /* do one line */\n      if (nlines < maxlines)\n\tline[nlines++] = lstart2;\n      else\n\tbreak;\n      for (f = 0, m1 = lstart1, last = '\\0'; f < nvars; f++) /* for each field */\n\t{\n\t  for (m2 = lstart2 + fieldstart[unfield[f]];\n\t       m1 < mem1 + nread && *m1 != '|' && *m1 != '\\n'; )\n\t    *m2++ = *m1++;\n\t  last = *m1++;\n\t  while (m2 < lstart2 + fieldstart[unfield[f] + 1])\n\t    *m2++ = '\\0';\n\t}\n      if (last != '\\n') /* didn't finish line */\n\tbreak;\n    }\n  if (last != '\\n')\n    --nlines;\n  nread = lstart1 - mem1; /* last line started but not completed */\n  if (!nread)\n    {\n      fputs(\"(dsort) line longer than buffer\\n\", dap_err);\n      exit(1);\n    }\n  fpos += nread;\n  qsort(line, nlines, sizeof(char *), cmp);\n  for (l = 0; l < nlines; l++)\n    memcpy(mem1 + l * linelen, line[l], linelen);\n  write(seg, mem1, nlines * linelen);\n  close(seg);\n  return nread;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nextlinecmp": {
      "start_point": [
        2283,
        0
      ],
      "end_point": [
        2286,
        1
      ],
      "content": "static int nextlinecmp(int *s1, int *s2)\n{\n  return linecmp(nextline + *s1, nextline + *s2);\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "merge": {
      "start_point": [
        2289,
        0
      ],
      "end_point": [
        2450,
        1
      ],
      "content": "static void merge(int nseg, int out)\n{\n  int s, s1, s2; /* segment number */\n  int c;\n  int l; /* index to line */\n  int f; /* index to fields */\n  char *segnamemem;\n  char **segname; /* segment names */\n  int segfile;\n  int chunksize; /* chunk of seg file to read at once */\n  int *chunkread; /* amount actually read from segment */\n  char *prevline; /* most recent line produced, for checking uniqueness */\n  unsigned long int *spos; /* position in segment file */\n  int nmore; /* number of segments with more */\n  unsigned int outpos; /* position in mem2 */\n  int *segord; /* order of next lines in segments */\n  int (*scmp)();\n\n  scmp = &nextlinecmp;\n  nextline = (char **) dap_malloc(nseg * sizeof(char *), \"nextline\");\n  prevline = NULL; /* mark as not yet set */\n  segnamemem = (char *) dap_malloc(nseg * (strlen(TMPLATE) + 1), \"segnamemem\");\n  segname = (char **) dap_malloc(nseg * sizeof(char *), \"segname\");\n  spos = (unsigned long int *) dap_malloc(nseg * sizeof(unsigned long int), \"spos\");\n  segord = (int *) dap_malloc(nseg * sizeof(int), \"segord\");\n  if (!(chunksize = dap_maxmem / (nseg * linelen) * linelen)) /* read in complete lines */\n    {\n      fputs(\"(dsort) insufficient memory\\n\", dap_err);\n      exit(1);\n    }\n  chunkread = (int *) dap_malloc(nseg * sizeof(int), \"chunkread\");\n  /* set up segnames, nextline, spos */\n  for (s = 0; s < nseg; s++)\n    {\n      segname[s] = segnamemem + s * (strlen(TMPLATE) + 1);\n      strcpy(segname[s], tmplate);\n      sprintf(segname[s] + 18, \"%06d\", s);\n      nextline[s] = mem1 + s * chunksize;\n      spos[s] = 0; /* at beginning of segment */\n      chunkread[s] = 0; /* nothing yet */\n      segord[s] = s;\n    }\n  /* get initial chunks */\n  for (s = 0; s < nseg; s++)\n    {\n      if ((segfile = open(segname[s], O_RDONLY)) < 0)\n\t{\n\t  fprintf(dap_err, \"(dsort) can't read %s\\n\", segname[s]);\n\t  exit(1);\n\t}\n      if ((chunkread[s] = read(segfile, mem1 + s * chunksize, chunksize)) > 0)\n\tspos[s] += chunkread[s];\n      else\n\t{\n\t  fprintf(dap_err, \"(dsort) bad initial read of %s\\n\", segname[s]);\n\t  exit(1);\n\t}\n      close(segfile);\n    }\n  /* initial sort of next lines to put out: segord[0] is index of that segment */\n  qsort(segord, nseg, sizeof(int), scmp);\n  /* now look for first line to copy to mem2 and move on to next line from that file,\n   * getting new chunk if necessary\n   */\n  for (nmore = nseg, outpos = 0; nmore; )\n    {\n      /* check uniqueness if requested */\n      if (unique)\n\t{\n\t  if (!prevline)\n\t    prevline = (char *) dap_malloc(linelen, \"prevline\");\n\t}\n      /* now need to reformat line */\n      if (!unique || (prevline && linecmp(nextline + segord[0], &prevline)))\n\t{\n\t  for (f = 0; f < nvars; f++)\n\t    {\n\t      for (l = fieldstart[unfield[f]]; l < fieldstart[unfield[f] + 1]; l++)\n\t\t{\n\t\t  if (outpos == dap_maxmem) /* if there's no room */\n\t\t    {\n\t\t      write(out, mem2, outpos); /* write it out */\n\t\t      outpos = 0; /* ready for more */\n\t\t    }\n\t\t  if (!(mem2[outpos] = nextline[segord[0]][l]))\n\t\t    break;\n\t\t  outpos++;\n\t\t}\n\t      if (outpos == dap_maxmem) /* if there's no room */\n\t\t{\n\t\t  write(out, mem2, outpos); /* write it out */\n\t\t  outpos = 0; /* ready for more */\n\t\t}\n\t      if (f < nvars - 1)\n\t\tmem2[outpos++] = '|';\n\t      else\n\t\tmem2[outpos++] = '\\n';\n\t    }\n\t}\n      if (unique)\n\t{\n\t  if (!prevline)\n\t    prevline = (char *) dap_malloc(linelen, \"prevline\");\n\t  memcpy(prevline, nextline[segord[0]], linelen);\n\t}\n      if ((nextline[segord[0]] += linelen) >=\n\t  mem1 + segord[0] * chunksize + chunkread[segord[0]])\n\t{ /* if ran out of data in chunk, read the next chunk */\n\t  if ((segfile = open(segname[segord[0]], O_RDONLY)) < 0)\n\t    {\n\t      fprintf(dap_err, \"(dsort) can't read %s\\n\", segname[segord[0]]);\n\t      exit(1);\n\t    }\n\t  if (lseek(segfile, spos[segord[0]], SEEK_CUR) > 0) /* can get to position */\n\t    {\n\t      if ((chunkread[segord[0]] =\n\t\t   read(segfile, mem1 + segord[0] * chunksize, chunksize)) > 0)\n\t\t{\n\t\t  spos[segord[0]] += chunkread[segord[0]];\n\t\t  nextline[segord[0]] = mem1 + segord[0] * chunksize;\n\t\t}\n\t      else\n\t\t--nmore;\n\t    }\n\t  else\n\t    {\n\t      chunkread[segord[0]] = 0;\n\t      --nmore;\n\t    }\n\t  close(segfile);\n\t}\n      /* now find next line to output: only segment segord[0] has changed, so we just\n       * need to bubble it up as necessary. Number of segments remaining is nmore.\n       */\n      if (chunkread[segord[0]] <= 0) /* seg gone, just have to shift down the others */\n\t{\n\t  for (s = 0; s < nmore; s++)\n\t    segord[s] = segord[s + 1];\n\t}\n      else /* bubble up as necessary */\n\t{\n\t  for (s1 = 1; s1 < nmore; s1++)\n\t    {\n\t      if (linecmp(nextline + segord[0], nextline + segord[s1]) <= 0)\n\t\tbreak;\n\t    }\n\t  s2 = segord[0];\n\t  for (s = 0; s < s1 - 1; s++)\n\t    segord[s] = segord[s + 1];\n\t  segord[s] = s2;\n\t}\n    }\n  if (outpos)\n    write(out, mem2, outpos);\n  dap_free(nextline, \"\");\n  dap_free(prevline, \"\");\n  dap_free(segnamemem, \"\");\n  dap_free(segname, \"\");\n  dap_free(spos, \"\");\n  dap_free(chunkread, \"\");\n  dap_free(segord, \"\");\n}",
      "lines": 162,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fieldfix": {
      "start_point": [
        2453,
        0
      ],
      "end_point": [
        2464,
        1
      ],
      "content": "static int fieldfix(int code)\n{\n  switch (code)\n    {\n    case DBL:\n      return 12; /* length of coded double */\n    case INT:\n      return 6; /* maximum length of coded int */\n    default: /* length of string */\n      return code;\n    }\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fixheader": {
      "start_point": [
        2470,
        0
      ],
      "end_point": [
        2574,
        1
      ],
      "content": "static int fixheader(char *header, int srt)\n{\n  int headerlen; /* index to header and length of header */\n  int nspaces; /* group variables in header with one internal space */\n  int v; /* index to variables */\n  int gotsign; /* got sign of field spec */\n  int sign; /* sign of field spec */\n  int h; /* index to header */\n  char *h1; /* pointer to header char */\n  int newfield; /* reached end of field, ready for next */\n  int fieldlen1; /* length of one field */\n  int f, f1, f2; /* indexes to fields */\n  int k, k1; /* indexes to keys */\n  char **headerfield; /* pointers to start of field names and specs */\n\n  headerfield = (char **) dap_malloc(dap_maxvar * sizeof(char *), \"headerfield\");\n  fieldstart = (int *) dap_malloc((dap_maxvar + 1) * sizeof(int), \"fieldstart\");\n  fieldstart[0] = 0;\n  fieldlen = (int *) dap_malloc((dap_maxvar + 1) * sizeof(int), \"fieldlen\");\n  for (headerlen = 0, nspaces = 0, nvars = 0, newfield = 1, linelen = 0;\n       headerlen < dap_linelen && header[headerlen] != '\\n';\n       headerlen++)\n    {\n      if (newfield) /* get pointer to start of each field */\n\t{\n\t  if (nvars)\n\t    linelen +=\n\t      (fieldlen[nvars - 1] = fieldfix(sign * fieldlen1));  /* no delimiter */\n\t  headerfield[nvars++] = header + headerlen;\n\t  newfield = 0;\n\t}\n      if (header[headerlen] == ' ')\n\t{\n\t  if (++nspaces == 1)\n\t    {\n\t      fieldlen1 = 0;\n\t      gotsign = 0; /* not set yet */\n\t    }\n\t  else\n\t    {\n\t      nspaces = 0;\n\t      newfield = 1;\n\t    }\n\t}\n      else if (nspaces == 1 && header[headerlen] != ' ') /* into length spec */\n\t{\n\t  if (!gotsign) /* not set yet */\n\t    {\n\t      if (header[headerlen] == '-')\n\t\tsign = -1;\n\t      else\n\t\t{\n\t\t  sign = 1;\n\t\t  gotsign = 1;\n\t\t}\n\t    }\n\t  if (gotsign)\n\t    fieldlen1 = 10 * fieldlen1 + header[headerlen] - '0';\n\t  gotsign = 1;\n\t}\n    }\n  linelen += (fieldlen[nvars - 1] = fieldfix(sign * fieldlen1)); /* no delimiter */\n  /* make map for sort orders */\n  maxlines = dap_maxmem / linelen;\n  line = (char **) dap_malloc(maxlines * sizeof(char *), \"line\");\n  if (headerlen == dap_linelen)\n    {\n      header[dap_linelen - 1] = '\\0';\n      fprintf(dap_err, \"(dsort) header line too long %s\\n\", header);\n      exit(1);\n    }\n  /* now fill in remainder of field array */\n  for (f = 0, f2 = nfields; f < nvars; f++)\n    {\n      for (f1 = 0; f1 < nfields; f1++)\n\t{\n\t  if (field[f1] == f)\n\t    break;\n\t}\n      if (f1 == nfields) /* wasn't there */\n\tfield[f2++] = f;\n    }\n  /* now invert to create unfield */\n  for (f = 0; f < nvars; f++)\n    unfield[field[f]] = f;\n  /* now set up fieldstarts */\n  for (fieldstart[0] = 0, f = 1; f <= nvars; f++)\n    fieldstart[f] = fieldstart[f - 1] + fieldlen[field[f - 1]];\n  /* now calculate keylen and keyends */\n  keyend = (int *) dap_malloc(nfields * sizeof(int), \"keyend\");\n  for (f = 0, keylen = 0; f < nfields; f++)\n    {\n      keylen += fieldlen[field[f]];\n      keyend[f] = keylen;\n    }\n  keymap = (int *) dap_malloc(keylen * sizeof(int), \"keymap\");\n  for (f = 0, k = 0; f < nfields; f++)\n    {\n      for (k1 = 0; k1 < fieldlen[field[f]]; k1++)\n\tkeymap[k++] = sortord[f];\n    }\n  write(srt, header, headerlen + 1);\n  dap_free(headerfield, \"\");\n  return headerlen + 1;\n}",
      "lines": 105,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dsort": {
      "start_point": [
        2576,
        0
      ],
      "end_point": [
        2664,
        1
      ],
      "content": "static void dsort(char *origset, char *sortset, int sortvar[], int nsort,\n\t\t  int uniq, char *mod, int nmods)\n{\n  int f; /* index to field */\n  int orig; /* orginal file */\n  int nseg; /* number of segments */\n  int srt; /* output file */\n  char *header; /* dap dataset header */\n  int c; /* for skipping and then copying header line */\n  struct stat statbuf; /* for seeing if directory exists */\n\n  header = (char *) dap_malloc(dap_linelen, \"header\");\n  field = (int *) dap_malloc(dap_maxvar * sizeof(int), \"field\");\n  unfield = (int *) dap_malloc(dap_maxvar * sizeof(int), \"unfield\");\n  sortord = (int *) dap_malloc(dap_maxvar * sizeof(int), \"dsortord\");\n  nfields = nsort;\n  if (!nmods)\n    {\n      for (f = 0; f < nfields; f++)\n\tmod[f] = 'i';\n    }\n  else if (nmods != nfields)\n    {\n      fprintf(dap_err, \"(dsort) nmods (%d) != nfields (%d)\\n\", nmods, nfields);\n      exit(1);\n    }\n  unique = uniq;\n  for (f = 0; f < nfields; f++)\n    {\n      sortord[f] = (mod[f] == 'i' ? 1 : 0);\n      field[f] = sortvar[f];\n    }\n  if (stat(dap_tmpdir, &statbuf) < 0)\n    {\n      if (mkdir(dap_tmpdir, (mode_t) 0700) < 0)\n\t{\n\t  perror(dap_dapname);\n\t  exit(1);\n\t}\n    }\n  else if (!(statbuf.st_mode & S_IFDIR))\n    {\n      fprintf(dap_err, \"%s: non-directory file exists: %s\\n\", dap_dapname, dap_tmpdir);\n      exit(1);\n    }\n  /* the memories for reordering, sorting, and writing */\n  mem1 = (char *) dap_malloc(2 * dap_maxmem, \"mem1\");\n  mem2 = mem1 + dap_maxmem;\n  if (!nfields)\n    {\n      fputs(\"(dsort) no fields specified for sorting\\n\", dap_err);\n      exit(1);\n    }\n  if ((orig = open(origset, O_RDONLY)) < 0)\n    {\n      fprintf(dap_err, \"(dsort) can't read %s\\n\", origset);\n      exit(1);\n    }\n  if ((srt = open(sortset, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)) < 0)\n    {\n      fprintf(dap_err, \"(dsort) can't write %s\\n\", sortset);\n      exit(1);\n    }\n  /* copy header and reorganize for field comparisons */\n  if (read(orig, header, dap_linelen) < 0)\n    {\n      fputs(\"(dsort) can't read header\\n\", dap_err);\n      exit(1);\n    }\n  fpos = fixheader(header, srt);\n  lseek(orig, fpos, SEEK_SET);\n  /* first sort segments of file */\n  sprintf(tmplate + 12, \"%06d\", getpid() % 1000000); /* for creating segment files */\n  for (nseg = 0; sortseg(orig, nseg); nseg++)\n    lseek(orig, fpos, SEEK_SET);\n  /* then merge */\n  merge(nseg, srt);\n  cleanup(nseg);\n  dap_free(header, \"\");\n  dap_free(mem1, \"\");\n  dap_free(fieldstart, \"\");\n  dap_free(line, \"\");\n  dap_free(field, \"\");\n  dap_free(unfield, \"\");\n  dap_free(fieldlen, \"\");\n  dap_free(sortord, \"\");\n  dap_free(keyend, \"\");\n  dap_free(keymap, \"\");\n}",
      "lines": 89,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bubblesort": {
      "start_point": [
        2666,
        0
      ],
      "end_point": [
        2708,
        1
      ],
      "content": "int* bubblesort(int * list,int n, int order){    \n  int *returndata=(int *) dap_malloc(n * sizeof(int), \"return\");\n    //copy table\n    int i = 0;\n    for (i = 0 ;i<n;i++)\n    {\n      returndata[i]=list[i];\n    }\n    int swappedcount=0;\n    int swapped = 0;\n    do {\n      swapped = 0;\n     \n     i = 1;\n     for (i = 1 ;i<n;i++)\n     {\n       if (order>0)\n       {\n\tif (returndata[i-1]>returndata[i])\n\t{\n\t  int act=returndata[i];\n\t  returndata[i]=returndata[i-1];\n\t  returndata[i-1]=act;\n\t  swapped = 1;\n\t  swappedcount++;\n\t}\n       }\n       else\n       {\n\tif (returndata[i-1]<returndata[i])\n\t{\n\t  int act=returndata[i];\n\t  returndata[i]=returndata[i-1];\n\t  returndata[i-1]=act;\n\t  swapped = 1;\n\t  swappedcount++;\n\t}\n       }\n     }\n     }while(swapped);\n     printf(\"nb swapped =%d\\n\",swappedcount);\n     return returndata;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "int",
        "* bubblesort(int * list,int n, int order)",
        "*"
      ]
    },
    "surveyselect": {
      "start_point": [
        2710,
        0
      ],
      "end_point": [
        2786,
        1
      ],
      "content": "void surveyselect(char *fname,char *outname,char *method,int tirage)\n{\n  inset(fname);\t/* set up input dataset */\n  //counting nb line\n  int nbLines=0;\n  while (step())\n  {\n    nbLines++;\n  }\n  printf(\"nblines to read = %d, nb selected = %d\\n\",nbLines,tirage);\n  \n  int *list=(int *) dap_malloc(tirage * sizeof(int), \"list\");\n  \n  int i=0;\n  \n  int sysrand=rand()%(nbLines/tirage);\n  printf(\"reload data\\n\");\n  \n  printf(\"create index list based on method\\n\");\n  for (i=0;i<tirage;i++)\n  {\n    if (strcmp(method,\"SRS\")==0)\n    {\n      int notalone=0;\n      int choice=0;\n      do{\n\tchoice=rand()%nbLines;\n\tint j=0;\n\tnotalone=0;\n\tfor(j=0;j<i;j++)\n\t  if(list[j]==choice)\n\t    notalone=1;\n      }while(notalone==1);\n      list[i]=choice;\n    }else\n    if (strcmp(method,\"SYS\")==0)\n    {\n      if (i==0)\n      {\n\tlist[i]=sysrand;\n      }\n      else\n      {\n\tlist[i]=list[i-1]+nbLines/tirage;\n\t\n      }\n      \n    }\n    \n  }\n  printf(\"sort values\\n\");\n  int *listsorted=bubblesort(list,tirage,1);\n  int counter=0;\n  int index=0;\n  printf(\"set output\\n\");\n  inset(fname);\t/* set up input dataset */\n  outset(outname, \"\"); /* set up output dataset */\n  while (step())\n  {\n      int founded=0;\n      for(i=0;i<tirage;i++)\n      {\n\t  if(listsorted[i]==counter)\n\t    founded=1;\n      }\n      if (founded)\n      {\n\n\toutput();\t/* and write line to output dataset */\n\tindex++;\n      }\n      counter++;\n  }\n  dap_free(list, \"\");\n  dap_free(listsorted, \"\");\n\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dap1.h": {},
  "dap/dap-3.10/src/dap2.c": {
    "dblcmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int dblcmp(double *x, double *y)\n{\n  if (*x < *y)\n    return -1;\n  if (*x > *y)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ddblcmp": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static int ddblcmp(double **x, double **y)\n{\n  if (**x < **y)\n    return -1;\n  if (**x > **y)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pctpttest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void pctpttest(double wtpt, double cumwt, double nextcum,\n\t\t      int *pctpt, int n, int *excess)\n{\n  if (cumwt <= wtpt && wtpt < nextcum)\n    {\n      *pctpt = n;\n      if (wtpt > cumwt)\n\t*excess = 1;\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pctile2": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static void pctile2(double ***val, int nobs,\n\t\t    int nvar, int *varv, int *wtvar, int *stats)\n{\n  int v;\n  int *pctptmem;\n  int **pctpt;\n  int *excessmem;\n  int **excess;\n  int pn;\t\t\t\t/* number of user-specified percentiles */\n  int pi;\t\t\t\t/* index to user-specified percentiles */\n  double pct;\n  static double sumwt;\t\t/* total sum of weights for specified variable */\n  static double cumwt;\t\t/* cumulative sum of wts for specified var */\n  static double nextcum;\t\t/* cumwt + next wt to be added in */\n  static double wtpt;\t\t/* fraction of sumwt for specified percentile */\n  double upct[MAXPCTPT];\t\t/* percent values for user-specified percentiles */\n  int n;\n  int ptindex;\n  int s;\n  double q1, q3;\n  int typen;\n\n  dap_swap();\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(pctile2) missing _type_ variable\\n\");\n      exit(1);\n    }\n  pctptmem = (int *) dap_malloc(sizeof(int) * nvar * (9 + MAXPCTPT), \"\");\n  pctpt = (int **) dap_malloc(sizeof(int *) * nvar, \"\");\n  excessmem = (int *) dap_malloc(sizeof(int) * nvar * (9 + MAXPCTPT), \"\");\n  excess = (int **) dap_malloc(sizeof(int *) * nvar, \"\");\n  for (pn = 0; pn < MAXPCTPT && stats[NSTATS - MAXPCTPT + pn]; pn++)\n    {\n      if (sscanf(dap_sttnm[NSTATS - MAXPCTPT + pn] + 1,\n\t\t \"%lf\", &upct[pn]) != 1)\n\t{\n\t  fprintf(dap_err, \"(pctile2) invalid percentile: %s\\n\",\n\t\t  dap_sttnm[NSTATS - MAXPCTPT + pn]);\n\t  exit(1);\n\t}\n    }\n  for (v = 0; v < nvar; v++)\n    {\n      pctpt[v] = pctptmem + v * (9 + MAXPCTPT);\n      excess[v] = excessmem + v * (9 + MAXPCTPT);\n      qsort((void *) val[v], (size_t) nobs, (size_t) (sizeof(double *)), dcmp);\n      for (n = 0, sumwt = 0.0; n < nobs; n++)\n\tsumwt += val[v][n][1];\n      for (s = 0; s < 9 + pn; s++)\n\t{\n\t  excess[v][s] = 0;\n\t  pctpt[v][s] = nobs - 1;\n\t}\n      for (n = 0, cumwt = 0.0; n < nobs; n++, cumwt = nextcum)\n\t{\n\t  nextcum = cumwt + val[v][n][1];\n\t  pctpttest(sumwt / 100.0, cumwt, nextcum, pctpt[v], n, excess[v]);\n\t  pctpttest(sumwt / 20.0, cumwt, nextcum, pctpt[v] + 1, n, excess[v] + 1);\n\t  pctpttest(sumwt / 10.0, cumwt, nextcum, pctpt[v] + 2, n, excess[v] + 2);\n\t  pctpttest(sumwt / 4.0, cumwt, nextcum, pctpt[v] + 3, n, excess[v] + 3);\n\t  pctpttest(sumwt / 2.0, cumwt, nextcum, pctpt[v] + 4, n, excess[v] + 4);\n\t  pctpttest(3.0 * sumwt / 4.0, cumwt, nextcum, pctpt[v] + 5, n, excess[v] + 5);\n\t  pctpttest(9.0 * sumwt / 10.0, cumwt, nextcum, pctpt[v] + 6, n, excess[v] + 6);\n\t  pctpttest(95.0 * sumwt / 100.0, cumwt, nextcum, pctpt[v] + 7, n, excess[v] + 7);\n\t  pctpttest(99.0 * sumwt / 100.0, cumwt, nextcum, pctpt[v] + 8, n, excess[v] + 8);\n\t  for (pi = 0; pi < pn; pi++)\n\t    {\n\t      pctpttest(upct[pi] * sumwt / 100.0,\n\t\t\tcumwt, nextcum, pctpt[v] + 9 + pi,\n\t\t\tn, excess[v] + 9 + pi);\n\t    }\n\t}\n    }\n  for (s = 0; s < 9 + pn; s++)\n    {\n      if (stats[P1 + s])\n\t{\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      ptindex = pctpt[v][s] - 1;\n\t      if (ptindex < 0)\n\t\tptindex = 0;\n\t      if (excess[v][s])\n\t\tdap_obs[0].do_dbl[varv[v]] = val[v][pctpt[v][s]][0];\n\t      else\n\t\tdap_obs[0].do_dbl[varv[v]] =\n\t\t  0.5 * (val[v][pctpt[v][s]][0] + val[v][ptindex][0]);\n\t    }\n\t  strcpy(dap_obs[0].do_str[typen], dap_sttnm[P1 + s]);\n\t  output();\n\t}\n    }\n  if (stats[N])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = (double) nobs;\n      strcpy(dap_obs[0].do_str[typen], \"N\");\n      output();\n    }\n  if (stats[MIN])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = val[v][0][0];\n      strcpy(dap_obs[0].do_str[typen], \"MIN\");\n      output();\n    }\n  if (stats[MAX])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = val[v][nobs - 1][0];\n      strcpy(dap_obs[0].do_str[typen], \"MAX\");\n      output();\n    }\n  if (stats[QRANGE])\n    {\n      for (v = 0; v < nvar; v++)\n\t{\n\t  ptindex = pctpt[v][3] - 1;\n\t  if (ptindex < 0)\n\t    ptindex = 0;\n\t  if (excess[v][3])\n\t    q1 = val[v][pctpt[v][3]][0];\n\t  else\n\t    q1 = 0.5 * (val[v][pctpt[v][3]][0] + val[v][ptindex][0]);\n\t  ptindex = pctpt[v][5] - 1;\n\t  if (ptindex < 0)\n\t    ptindex = 0;\n\t  if (excess[v][5])\n\t    q3 = val[v][pctpt[v][5]][0];\n\t  else\n\t    q3 = 0.5 * (val[v][pctpt[v][5]][0] + val[v][ptindex][0]);\n\t  dap_obs[0].do_dbl[varv[v]] = q3 - q1;\n\t}\n      strcpy(dap_obs[0].do_str[typen], \"QRANGE\");\n      output();\n    }\n  dap_swap();\n  dap_free(pctptmem, \"\");\n  dap_free(pctpt, \"\");\n  dap_free(excessmem, \"\");\n  dap_free(excess, \"\");\n}",
      "lines": 143,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pctile1": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void pctile1(double ***val, int nobs, int nvar, int *varv, int *stats)\n{\n  int v;\n  double dnobs;\n  static int pctpt[9 + MAXPCTPT];\n  int pn;\n  double pct;\n  static int excess[9 + MAXPCTPT];\n  int ptindex;\n  int s;\n  double q1, q3;\n  int typen;\n\n  dap_swap();\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(pctile1) missing _type_ variable\\n\");\n      exit(1);\n    }\n  dnobs = (double) nobs;\n  pctpt[0] = (int) floor(dnobs / 100.0);\n  excess[0] = ((dnobs / 100.0) > floor(dnobs / 100.0));\n  pctpt[1] = (int) floor(dnobs / 20.0);\n  excess[1] = ((dnobs / 20.0) > floor(dnobs / 20.0));\n  pctpt[2] = (int) floor(dnobs / 10.0);\n  excess[2] = ((dnobs / 10.0) > floor(dnobs / 10.0));\n  pctpt[3] = (int) floor(dnobs / 4.0);\n  excess[3] = ((dnobs / 4.0) > floor(dnobs / 4.0));\n  pctpt[4] = (int) floor(dnobs / 2.0);\n  excess[4] = ((dnobs / 2.0) > floor(dnobs / 2.0));\n  pctpt[5] = (int) floor(3.0 * dnobs / 4.0);\n  excess[5] = ((3.0 * dnobs / 4.0) > floor(3.0 * dnobs / 4.0));\n  pctpt[6] = (int) floor(9.0 * dnobs / 10.0);\n  excess[6] = ((9.0 * dnobs / 10.0) > floor(9.0 * dnobs / 10.0));\n  pctpt[7] = (int) floor(95.0 * dnobs / 100.0);\n  excess[7] = ((95.0 * dnobs / 100.0) > floor(95.0 * dnobs / 100.0));\n  pctpt[8] = (int) floor(99.0 * dnobs / 100.0);\n  excess[8] = ((99.0 * dnobs / 100.0) > floor(99.0 * dnobs / 100.0));\n  for (pn = 0; pn < MAXPCTPT && stats[NSTATS - MAXPCTPT + pn]; pn++)\n    {\n      sscanf(dap_sttnm[NSTATS - MAXPCTPT + pn] + 1, \"%lf\", &pct);\n      pctpt[9 + pn] = (int) floor(pct * dnobs / 100.0);\n      excess[9 + pn] = ((pct * dnobs / 100.0) > floor(pct * dnobs / 100.0));\n    }\n  for (v = 0; v < nvar; v++)\n    qsort((void *) val[v], (size_t) nobs, (size_t) sizeof(double *), dcmp);\n  for (s = 0; s < 9 + pn; s++)\n    {\n      if (stats[P1 + s])\n\t{\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      ptindex = pctpt[s] - 1;\n\t      if (ptindex < 0)\n\t\tptindex = 0;\n\t      if (excess[s])\n\t\tdap_obs[0].do_dbl[varv[v]] = val[v][pctpt[s]][0];\n\t      else\n\t\tdap_obs[0].do_dbl[varv[v]] =\n\t\t  0.5 * (val[v][pctpt[s]][0] + val[v][ptindex][0]);\n\t    }\n\t  strcpy(dap_obs[0].do_str[typen], dap_sttnm[P1 + s]);\n\t  output();\n\t}\n    }\n  if (stats[N])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = dnobs;\n      strcpy(dap_obs[0].do_str[typen], \"N\");\n      output();\n    }\n  if (stats[MIN])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = val[v][0][0];\n      strcpy(dap_obs[0].do_str[typen], \"MIN\");\n      output();\n    }\n  if (stats[MAX])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = val[v][nobs - 1][0];\n      strcpy(dap_obs[0].do_str[typen], \"MAX\");\n      output();\n    }\n  if (stats[RANGE])\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = val[v][nobs - 1][0] - val[v][0][0];\n      strcpy(dap_obs[0].do_str[typen], \"RANGE\");\n      output();\n    }\n  if (stats[QRANGE])\n    {\n      for (v = 0; v < nvar; v++)\n\t{\n\t  ptindex = pctpt[3] - 1;\n\t  if (ptindex < 0)\n\t    ptindex = 0;\n\t  if (excess[3])\n\t    q1 = val[v][pctpt[3]][0];\n\t  else\n\t    q1 = 0.5 * (val[v][pctpt[3]][0] + val[v][ptindex][0]);\n\t  ptindex = pctpt[5] - 1;\n\t  if (ptindex < 0)\n\t    ptindex = 0;\n\t  if (excess[5])\n\t    q3 = val[v][pctpt[5]][0];\n\t  else\n\t    q3 = 0.5 * (val[v][pctpt[5]][0] + val[v][ptindex][0]);\n\t  dap_obs[0].do_dbl[varv[v]] = q3 - q1;\n\t}\n      strcpy(dap_obs[0].do_str[typen], \"QRANGE\");\n      output();\n    }\n  dap_swap();\n}",
      "lines": 118,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pctiles": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "void pctiles(char *fname, char *varlist, char *statlist, char *marks)\n{\n  char *outname;\n  int stats[NSTATS];\n  int *varv;\n  int *markv;\n  int nvar;\n  int nmark;\n  int nobs;\n  char *outlist;\n  int *wtvar;\n  int v;\n  double *valmem;\n  double **valpair;\n  double ***val;\n  int weighted;\n  int more;\n\n  if (!fname)\n    {\n      fputs(\"(pctiles) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".pct\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  wtvar = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  /* outlist = dap_malloc(strlen(varlist) + strlen(marks) + 2, \"\"); ?? */\n  outlist = dap_malloc(dap_listlen + 1, \"\");\n  inset(fname);\n  dap_stats(statlist, stats);\n  nvar = dap_mnsparse(varlist, outlist, varv, wtvar, stats);\n  if (marks && marks[0])\n    {\n      strcat(outlist, \" \");\n      strcat(outlist, marks);\n    }\n  outset(outname, outlist);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  valmem = (double *) dap_malloc(sizeof(double) * nvar * 2 * dap_maxval, \"\");\n  valpair = (double **) dap_malloc(sizeof(double *) * nvar * dap_maxval, \"\");\n  val = (double ***) dap_malloc(sizeof(double *) * nvar, \"\");\n  for (v = 0, weighted = 0; v < nvar; v++)\n    {\n      if (wtvar[v] >= 0)\n\tweighted = 1;\n    }\n  for (nobs = 0, more = 1; more; nobs++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  if (weighted)\n\t    pctile2(val, nobs, nvar, varv,  wtvar, stats);\n\t  else\n\t    pctile1(val, nobs, nvar, varv, stats);\n\t  nobs = 0;\n\t}\n      if (more)\n\t{\n\t  if (nobs < dap_maxval)\n\t    {\n\t      for (v = 0; v < nvar; v++)\n\t\t{\n\t\t  valpair[dap_maxval * v + nobs] =\n\t\t    valmem + 2 * (dap_maxval * v + nobs);\n\t\t  val[v] = valpair + v * dap_maxval;\n\t\t  val[v][nobs][0] = dap_obs[0].do_dbl[varv[v]];\n\t\t  if (wtvar[v] >= 0)\n\t\t    val[v][nobs][1] = dap_obs[0].do_dbl[wtvar[v]];\n\t\t  else\n\t\t    val[v][nobs][1] = 1.0;\n\t\t  if (!finite(val[v][nobs][0]) || !finite(val[v][nobs][1]))\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(pctiles) NaN value %d for %s\\n\",\n\t\t\t      nobs, dap_obs[0].do_nam[varv[v]]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      fputs(\"(pctiles) Too many data.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t}\n    }\n  dap_free(outname, \"\");\n  dap_free(varv, \"\");\n  dap_free(markv, \"\");\n  dap_free(wtvar, \"\");\n  dap_free(outlist, \"\");\n  dap_free(valmem, \"\");\n  dap_free(valpair, \"\");\n  dap_free(val, \"\");\n}",
      "lines": 98,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "corr1": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void corr1(int *varv, int nvar, double **cormat, double ss[], int nobs)\n{\n  int varn[3];\n  int typen;\n  double nf;\n  int v, w;\n  double r;\n\n  if (nobs < 2)\n    return;\n  dap_swap();\n  nf = sqrt((double) (nobs - 2));\n  varn[0] = dap_varnum(\"_var1_\");\n  varn[1] = dap_varnum(\"_var2_\");\n  varn[2] = dap_varnum(\"_corr_\");\n  typen = dap_varnum(\"_type_\");\n  for (v = 0; v < nvar; v++)\n    for (w = 0; w < v; w++)\n      cormat[v][w] = cormat[w][v];\n  strcpy(dap_obs[0].do_str[typen], \"N\");\n  for (v = 0; v < nvar; v++)\n    {\n      strcpy(dap_obs[0].do_str[varn[0]], dap_obs[0].do_nam[varv[v]]);\n      for (w = 0; w < nvar; w++)\n\t{\n\t  strcpy(dap_obs[0].do_str[varn[1]],\n\t\t dap_obs[0].do_nam[varv[w]]);\n\t  dap_obs[0].do_dbl[varn[2]] = (double) nobs;\n\t  output();\n\t}\n    }\n  strcpy(dap_obs[0].do_str[typen], \"CORR\");\n  for (v = 0; v < nvar; v++)\n    {\n      strcpy(dap_obs[0].do_str[varn[0]], dap_obs[0].do_nam[varv[v]]);\n      for (w = 0; w < nvar; w++)\n\t{\n\t  strcpy(dap_obs[0].do_str[varn[1]],\n\t\t dap_obs[0].do_nam[varv[w]]);\n\t  if (w == v)\n\t    cormat[v][w] = 1.0;\n\t  else\n\t    cormat[v][w] /= sqrt(ss[v] * ss[w]);\n\t  dap_obs[0].do_dbl[varn[2]] = cormat[v][w];\n\t  output();\n\t}\n    }\n  strcpy(dap_obs[0].do_str[typen], \"PCORR\");\n  for (v = 0; v < nvar; v++)\n    {\n      strcpy(dap_obs[0].do_str[varn[0]], dap_obs[0].do_nam[varv[v]]);\n      for (w = 0; w < nvar; w++)\n\t{\n\t  strcpy(dap_obs[0].do_str[varn[1]],\n\t\t dap_obs[0].do_nam[varv[w]]);\n\t  r = fabs(cormat[v][w]);\n\t  if (r == 1.0)\n\t    dap_obs[0].do_dbl[varn[2]] = 0.0;\n\t  else\n\t    dap_obs[0].do_dbl[varn[2]] =\n\t      2.0 * probt(nf * r / sqrt(1.0 - r * r),\n\t\t\t  nobs - 2);\n\t  output();\n\t}\n    }\n  dap_swap();\n}",
      "lines": 67,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "corr": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "void corr(char *fname, char *varlist, char *marks)\n{\n  char *outname;\n  char varstr[11];\n  char *outlist;\n  int *markv;\n  int nmark;\n  int *varv;\n  int nvar;\n  int nobs;\n  double *cormem;\n  double **cormat;\n  int v, w;\n  double *sum;\n  double *ss;\n  double vtmp;\n  double tmp;\n  double dn;\n  int more;\n\n  if (!fname)\n    {\n      fputs(\"(corr) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".cor\");\n  outlist = dap_malloc(strlen(marks) + 22, \"\");\n  inset(fname);\n  nvar = dap_list(varlist, varv, dap_maxvar);\n  cormem = (double *) dap_malloc(sizeof(double) * nvar * nvar, \"\");\n  cormat = (double **) dap_malloc(sizeof(double *) * nvar, \"\");\n  for (v = 0; v < nvar; v++)\n    cormat[v] = cormem + v * nvar;\n  sum = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  ss = (double *) dap_malloc(sizeof(double) * nvar, \"\");\n  strcpy(outlist, marks);\n  for (v = 0; v < nvar; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] >= 0)\n\t{\n\t  fprintf(dap_err, \"(corr) Variable not of type dap_double: %s\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n    }\n  sprintf(varstr, \"_var1_ %d\", dap_namelen);\n  dap_vd(varstr, 0);\n  sprintf(varstr, \"_var2_ %d\", dap_namelen);\n  dap_vd(varstr, 0);\n  sprintf(varstr, \"_corr_ %d\", DBL);\n  dap_vd(varstr, 0);\n  strcat(outlist, \" _var1_ _var2_ _corr_\");\n  outset(outname, outlist);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  for (v = 0; v < nvar; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] != DBL)\n\t{\n\t  fprintf(dap_err, \"(corr) variables must be of type double: %s\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n      for (w = v + 1; w < nvar; w++)\n\tcormat[v][w] = 0.0;\n      sum[v] = 0.0;\n      ss[v] = 0.0;\n    }\n  for (nobs = 0, more = 1; more; nobs++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  corr1(varv, nvar, cormat, ss, nobs);\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      for (w = v + 1; w < nvar; w++)\n\t\tcormat[v][w] = 0.0;\n\t      sum[v] = 0.0;\n\t      ss[v] = 0.0;\n\t    }\n\t  nobs = 0;\n\t}\n      if (more)\n\t{\n\t  dn = (double) nobs;\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      vtmp = dap_obs[0].do_dbl[varv[v]];\n\t      if (!finite(vtmp))\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(corr) NaN value %d for %s\\n\",\n\t\t\t  nobs, dap_obs[0].do_nam[varv[v]]);\n\t\t  exit(1);\n\t\t}\n\t      if (nobs)\n\t\t{\n\t\t  tmp = sum[v] - dn * vtmp;\n\t\t  for (w = v + 1; w < nvar; w++)\n\t\t    {\n\t\t      cormat[v][w] += tmp * (sum[w] - dn *\n\t\t\t\t\t     dap_obs[0].do_dbl[varv[w]]) /\n\t\t\t(dn * (dn + 1.0));\n\t\t    }\n\t\t  ss[v] += tmp * tmp / (dn * (dn + 1.0));\n\t\t}\n\t      sum[v] += vtmp;\n\t    }\n\t}\n    }\n  dap_free(markv, \"\");\n  dap_free(varv, \"\");\n  dap_free(outname, \"\");\n  dap_free(outlist, \"\");\n  dap_free(cormem, \"\");\n  dap_free(cormat, \"\");\n  dap_free(sum, \"\");\n  dap_free(ss, \"\");\n}",
      "lines": 122,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "groupparse": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "static int groupparse(char *varspec, int varv[], int classtype[])\n{\n  int s;\n  int i;\n  int v;\n  char *varname; /* variable name or other token from varspec */\n  int n;\n  int nvar;\n  int number; /* Are we going to simply get observation number, fraction, or percent,\n\t       * (indicated by number == 0) or do grouping (indicated by number == 1?)?\n\t       * This is specified by first character in varspec.\n\t       */\n\n  if (!varspec)\n    return 0;\n  varname = dap_malloc(dap_namelen + 1, \"\");\n  for (s = 0; varspec[s] == ' '; s++) /* skip leading blanks */\n    ;\n  for (nvar = 0, number = 0; varspec[s]; )\n    {\n      classtype[nvar] = 0; /* initialize to innocent */\n      for (i = 0; varspec[s + i] && varspec[s + i] != ' '; i++)\n\t{ /* copy variable name or leading character in varspec only */\n\t  if (i < dap_namelen)\n\t    varname[i] = varspec[s + i];\n\t  else\n\t    {\n\t      varname[i] = '\\0';\n\t      fprintf(dap_err, \"(groupparse) variable name too long: %s\\n\",\n\t\t      varname);\n\t      exit(1);\n\t    }\n\t}\n      varname[i] = '\\0';\n      s += i; /* get past variable name or leading character */\n      /* if it's a variable, get its id */\n      if ((v = dap_varnum(varname)) >= 0)\n\t{ /* OK, it's a variable */\n\t  varv[nvar] = v; /* and place in vector */\n\t  while (varspec[s] == ' ') /* skip blanks to get to grouping type or next variable */\n\t    s++;\n\t  if (number) /* if we got leading character in varspec to specifying grouping */\n\t    {\n\t      if (dap_obs[0].do_len[v] != DBL)\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(groupparse) grouping variable must be of type double: %s\\n\",\n\t\t\t  varname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else /* else we have to get the grouping type */\n\t    {\n\t      if ('0' <= varspec[s] && varspec[s] <= '9')\n\t\t{ /* first there has to be a number */\n\t\t  if (dap_obs[0].do_len[v] == DBL)\n\t\t    { /* we're only going to group numbers of type double */\n\t\t      for (n = 0, i = 0;\n\t\t\t   '0' <= varspec[s + i] && varspec[s + i] <= '9';\n\t\t\t   i++)\n\t\t\tn = 10 * n + varspec[s + i] - '0';\n\t\t      if (!n || (varspec[s + i] != '#' &&\n\t\t\t\t varspec[s + i] != '^'))\n\t\t\t{ /* OK, we either didn't get a number or it wasn't followed\n\t\t\t   * by either # (equal count groups) or ^ (equal width groups)\n\t\t\t   */\n\t\t\t  fprintf(dap_err,\n\t\t\t\t  \"(groupparse) invalid number of groups: %s\\n\",\n\t\t\t\t  varspec + s);\n\t\t\t  exit(1);\n\t\t\t}\n\t\t      switch (varspec[s + i])\n\t\t\t{\n\t\t\tcase '^':\n\t\t\t  classtype[nvar] = -n; /* < 0 indicates equal width */\n\t\t\t  break;\n\t\t\tcase '#':\n\t\t\t  classtype[nvar] = n; /* > 0 indicates equal count */\n\t\t\t  break;\n\t\t\tdefault:\n\t\t\t  fprintf(dap_err,\n\t\t\t\t  \"(groupparse) invalid class type: %s\\n\",\n\t\t\t\t  varspec + s + i);\n\t\t\t  exit(1);\n\t\t\t}\n\t\t      s += i + 1;\n\t\t      while (varspec[s] == ' ') /* on to next variable */\n\t\t\ts++;\n\t\t      if (n > dap_maxbars)\n\t\t\t{\n\t\t\t  fprintf(dap_err,\n\t\t\t\t  \"(groupparse) too many classes: %d\\n\", n);\n\t\t\t  exit(1);\n\t\t\t}\n\t\t    }\n\t\t  else /* guess it wasn't a double... */\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(groupparse) grouping variable must be of type double: %s\\n\",\n\t\t\t      varname);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t      else /* guess there wasn't a number... */\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(groupparse) missing number of groups for %s\\n\",\n\t\t\t  varname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  nvar++;\n\t}\n      else if (number < 0)\n\t{ /* then varname was really a variable name, because we already found\n\t   * a #, /, or % at the beginning of varspec\n\t   */\n\t  if (varname[0] == '-') /* descending */\n\t    classtype[0] |= GRPDESC;\n\t  if (varname[1] == '0') /* lowest group is numbered 0 */\n\t    classtype[0] |= GRP0;\n\t}\n      else if (!nvar)\n\t{ /* at the beginning of varspec: want count, fraction, or percent? */\n\t  if (!strcmp(varname, \"#\"))\n\t    number = GRPNUMBER;\n\t  else if (!strcmp(varname, \"/\"))\n\t    number = GRPFRACTION;\n\t  else if (!strcmp(varname, \"%\"))\n\t    number = GRPPERCENT;\n\t  classtype[0] = 0;\n\t  nvar++;\n\t}\n      else /* OK, look: we're not at the beginning and it's not a variable. What gives? */\n\t{\n\t  fprintf(dap_err, \"(groupparse) unknown variable: %s\\n\", varname);\n\t  exit(1);\n\t}\n      while (varspec[s] == ' ') /* on to next */\n\ts++;\n    }\n  dap_free(varname, \"\");\n  if (number < 0) /* if were just finding count, fraction, or percent */\n    return -4 * nvar + number;\n  return nvar;\n}",
      "lines": 146,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getpoints": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "static void getpoints(double **numval, int nonum,\n\t\t      int *ctype, int nobs, double **point)\n{\n  int v;\n  double width;\n  int p;\n  int index;\n  double excess;\n\n  for (v = 0; v < nonum; v++)\n    {\n      qsort((void *) numval[v], (size_t) nobs, /* sort values for each variable separately */\n\t    (size_t) sizeof(double), cmp);\n      if (ctype[v] < 0)\n\t{\n\t  width = (numval[v][nobs - 1] - numval[v][0]) /\n\t    ((double) -ctype[v]);\n\t  for (p = 0; p < -ctype[v]; p++)\n\t    point[v][p] = numval[v][0] +\n\t      ((double) p) * width;\n\t  point[v][p] = numval[v][nobs - 1];\n\t}\n      else if (ctype[v] > 0)\n\t{\n\t  for (p = 0; p < ctype[v]; p++)\n\t    {\n\t      index = (int) floor(((double) (p * nobs)) /\n\t\t\t\t  ((double) ctype[v]));\n\t      excess = ((double) (p * nobs)) / ((double) ctype[v]) -\n\t\t(double) index;\n\t      if (excess > 0.0 && index < nobs - 1)\n\t\tpoint[v][p] = 0.5 *\n\t\t  (numval[v][index] + numval[v][index + 1]);\n\t      else\n\t\tpoint[v][p] =\n\t\t  numval[v][(int) rint(((double) (p * nobs)) /\n\t\t\t\t       ((double) ctype[v]))];\n\t    }\n\t  point[v][p] = numval[v][nobs - 1];\n\t}\n    }\n}",
      "lines": 42,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "group": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        1042,
        1
      ],
      "content": "void group(char *fname, char *varspec, char *marks)\n{\n  char *outname;\n  int *markv; /* vector of ids of partitioning variables */\n  int nmark; /* and number of those */\n  int *varv; /* vector of ids of variables */\n  int *ctype; /* grouping type; see groupparse above for details */\n  double *nummem;\n  double **numval;\n  int nvar;\n  int number;\n  int v;\n  char *grpname; /* to hold name of group variables */\n  int *grpv; /* vector of ids of grouping variables */\n  int nobs;\n  int nnan;\n  int allgood;\t\t/* all vars selected are finite */\n  double *ptmem;\n  double **point;\n  double dnobs;\n  double count;\n  double countinc;\n  int p;\n  int more; /* to see if another dataset line was read */\n\n  if (!fname)\n    {\n      fputs(\"(group) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".grp\");\n  grpname = dap_malloc(dap_namelen + 3, \"\"); /* +3 for two '_' and null */\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  ctype = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  inset(fname);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  /* construct vector of variable ids (varv) and grouping types (ctype) */\n  nvar = groupparse(varspec, varv, ctype);\n  if (nvar < 0) /* means we're simply getting count, fraction, or percent */\n    {\n      number = -((-nvar) % 4); /* recover codes for descending or not, start from 0 or not */\n      nvar = -(nvar - number) / 4; /* and get true number of variables */\n    }\n  else\n    number = 0; /* indicates true grouping */\n  grpv = (int *) dap_malloc(sizeof(int) * (number ? 1 : nvar), \"\");\n  if (!number) /* true grouping requires: */\n    {\n      strcpy(grpname, \"_\"); /* variable names for group variables */\n      for (v = 0; v < nvar; v++)\n\t{\n\t  strcpy(grpname + 1, dap_obs[0].do_nam[varv[v]]);\n\t  grpname[dap_namelen] = '\\0';\n\t  strcat(grpname, \" -1\");\n\t  grpv[v] = dap_vd(grpname, 0);\n\t}\n    }\n  else /* counting, etc., simply requires one new variable */\n    {\n      grpv[0] = dap_vd(\"_N_ -1\", 0);\n      varv[0] = grpv[0];\n    }\n  outset(outname, \"\");\n  nummem = NULL;\n  numval = NULL;\n  if (!number) /* if true grouping, need some memory to sort and manipulate the numbers */\n    {\n      nummem = (double *) dap_malloc(sizeof(double) * nvar * dap_maxval, \"dap_maxval\");\n      numval = (double **) dap_malloc(nvar * dap_maxval * sizeof(double *), \"dap_maxval\");\n      ptmem = (double *) dap_malloc(sizeof(double) * nvar * (dap_maxbars + 1), \"dap_maxbars\");\n      point = (double **) dap_malloc(sizeof(double *) * nvar, \"\");\n      for (v = 0; v < nvar; v++) /* set up pointers for array referencing */\n\t{\n\t  numval[v] = nummem + v * dap_maxval;\n\t  point[v] = ptmem + v * (dap_maxbars + 1);\n\t}\n    }\n  for (dap_mark(), nobs = 0, nnan = 0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark)) /* reached a new part of dataset, time to do stuff */\n\t{\n\t  if (!number) /* if true grouping, need... */\n\t    getpoints(numval, nvar, ctype, nobs, point); /* to get grouping points */\n\t  dnobs = (double) nobs;\n\t  dap_rewind(); /* have to pass through this part again */\n\t  count = 1.0;\n\t  countinc = 1.0;\n\t  if (nnan > 0)\n\t    fprintf(dap_log, \"(group) %d NaNs\\n\", nnan);\n\t  if (number)\n\t    {\n\t      if (ctype[0] & GRP0)\n\t\tcount = 0.0;\n\t      if (ctype[0] & GRPDESC)\n\t\t{\n\t\t  countinc = -1.0;\n\t\t  count = dnobs - 1.0 + count;\n\t\t}\n\t    }\n\t  for ( ; step() && !dap_newpart(markv, nmark); )\n\t    {\n\t      if (number)\n\t\t{\n\t\t  for (v = 1, allgood = 1; v < nvar; v++)\n\t\t    {\n\t\t      if (!finite(dap_obs[0].do_dbl[varv[v]]))\n\t\t\t{\n\t\t\t  allgood = 0;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if (allgood)\n\t\t    {\n\t\t      switch (number)\n\t\t\t{\n\t\t\tcase GRPNUMBER:\n\t\t\t  dap_obs[0].do_dbl[grpv[0]] = count;\n\t\t\t  break;\n\t\t\tcase GRPFRACTION:\n\t\t\t  dap_obs[0].do_dbl[grpv[0]] = count / dnobs;\n\t\t\t  break;\n\t\t\tcase GRPPERCENT:\n\t\t\t  dap_obs[0].do_dbl[grpv[0]] = 100.0 * count / dnobs;\n\t\t\t  break;\n\t\t\t}\n\t\t      count += countinc;\n\t\t    }\n\t\t  else\n\t\t    dap_obs[0].do_dbl[grpv[0]] = 0.0 / 0.0;\n\t\t}\n\t      else\n\t\t{\n\t\t  for (v = 0, allgood = 1; v < nvar; v++)\n\t\t    {\n\t\t      if (!finite(dap_obs[0].do_dbl[varv[v]]))\n\t\t\t{\n\t\t\t  allgood = 0;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if (allgood)\n\t\t    {\n\t\t      for (v = 0; v < nvar; v++)\n\t\t\t{\n\t\t\t  for (p = 1;\n\t\t\t       dap_obs[0].do_dbl[varv[v]] >\n\t\t\t\t point[v][p]; p++)\n\t\t\t    ;\n\t\t\t  dap_obs[0].do_dbl[grpv[v]] = (double) p;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    for (v = 0; v < nvar; v++)\n\t\t      dap_obs[0].do_dbl[grpv[v]] = 0.0 / 0.0;\n\t\t}\n\t      output();\n\t      dap_mark();\n\t    }\n\t  nobs = 0;\n\t  nnan = 0;\n\t}\n      if (number)\n\t{\n\t  for (v = 1, allgood = 1; v < nvar; v++)\n\t    {\n\t      if (!finite(dap_obs[0].do_dbl[varv[v]]))\n\t\t{\n\t\t  allgood = 0;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (allgood)\n\t    nobs++;\n\t  else\n\t    nnan++;\n\t}\n      else\n\t{\n\t  if (nobs < dap_maxval)\n\t    {\n\t      for (v = 0, allgood = 1; v < nvar; v++)\n\t\t{\n\t\t  if (!finite(dap_obs[0].do_dbl[varv[v]]))\n\t\t    {\n\t\t      allgood = 0;\n\t\t      break;\n\t\t    }\n\t\t  numval[v][nobs] = dap_obs[0].do_dbl[varv[v]];\n\t\t}\n\t      if (allgood)\n\t\tnobs++;\n\t      else\n\t\tnnan++;\n\t    }\n\t  else\n\t    {\n\t      fputs(\"(group) too many data.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t}\n    }\n  if (!number)\n    {\n      dap_free(nummem, \"\");\n      dap_free(numval, \"\");\n      dap_free(ptmem, \"\");\n      dap_free(point, \"\");\n    }\n  dap_free(outname, \"\");\n  dap_free(grpname, \"\");\n  dap_free(grpv, \"\");\n  dap_free(markv, \"\");\n  dap_free(varv, \"\");\n  dap_free(ctype, \"\");\n}",
      "lines": 218,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "freq1": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "static void freq1(int *varv, int nvar, double count, double sumcount, int *statv,\n\t\t  int typen, int celln)\n{\n  dap_swap();\n  if (statv[FREQCNT])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"COUNT\");\n      dap_obs[0].do_dbl[celln] = count;\n      output();\n    }\n  if (statv[FREQPCT])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"PERCENT\");\n      dap_obs[0].do_dbl[celln] = 100.0 * count / sumcount;\n      output();\n    }\n  if (statv[FREQFRA])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"FRACTION\");\n      dap_obs[0].do_dbl[celln] = count / sumcount;\n      output();\n    }\n  dap_swap();\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "statparse": {
      "start_point": [
        1084,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "static void statparse(char *stats, int *statv)\n{\n  int s;\n  int i;\n  char *stat;\n\n  stat = dap_malloc(dap_namelen + 1, \"\");\n  for (s = 0; s < NFREQSTAT; s++)\n    statv[s] = 0;\n  for (s = 0; stats[s] == ' '; s++)\n    ;\n  while (stats[s])\n    {\n      for (i = 0; stats[s + i] && stats[s + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    stat[i] = stats[s + i];\n\t  else\n\t    {\n\t      stat[i] = '\\0';\n\t      fprintf(dap_err, \"(statparse) Statistic name too long: %s\\n\", stat);\n\t      exit(1);\n\t    }\n\t}\n      stat[i] = '\\0';\n      s += i;\n      if (!strcmp(stat, \"COUNT\"))\n\tstatv[FREQCNT] = 1;\n      else if (!strcmp(stat, \"PERCENT\"))\n\tstatv[FREQPCT] = 1;\n      else if (!strcmp(stat, \"ROWPERC\"))\n\tstatv[FREQROW] = 1;\n      else if (!strcmp(stat, \"COLPERC\"))\n\tstatv[FREQCOL] = 1;\n      else if (!strcmp(stat, \"FRACTION\"))\n\tstatv[FREQFRA] = 1;\n      else if (!strcmp(stat, \"EXPECTED\"))\n\tstatv[FREQEXP] = 1;\n      else if (!strcmp(stat, \"CHISQ\"))\n\tstatv[FREQCHISQ] = 1;\n      else if (!strcmp(stat, \"ODDSRAT\"))\n\tstatv[FREQODDRAT] = 1;\n      else if (!strcmp(stat, \"ORDINAL\"))\n\tstatv[FREQORD] = 1;\n      else if (!strcmp(stat, \"FISHER\"))\n\tstatv[FREQFISHER] = 1;\n      else if (!strcmp(stat, \"CMH\"))\n\tstatv[FREQCMH] = 1;\n      else if (!strcmp(stat, \"PAIR\"))\n\tstatv[FREQPAIR] = 1;\n      else if (!strcmp(stat, \"NOMINAL\"))\n\tstatv[FREQNOM] = 1;\n      else\n\t{\n\t  fprintf(dap_err, \"(statparse) Invalid statistic name: %s\\n\", stat);\n\t  exit(1);\n\t}\n      while (stats[s] == ' ')\n\ts++;\n    }\n  dap_free(stat, \"\");\n}",
      "lines": 62,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "findlev": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1181,
        1
      ],
      "content": "static int findlev(int v, char **level, int *nlevels)\n{\n  int l;\n  static char *str = NULL;\n  char *s;\n\n  if (!str)\n    str = dap_malloc(21, \"\");\n  if (dap_obs[0].do_len[v] > 0)\n    s = dap_obs[0].do_str[v];\n  else\n    {\n      s = str;\n      if (dap_obs[0].do_len[v] == INT)\n\tsprintf(str, \"%d\", dap_obs[0].do_int[v]);\n      else\n\tsprintf(str, \"%g\", dap_obs[0].do_dbl[v]);\n    }\n  for (l = 0; l < *nlevels; l++)\n    {\n      if (!strcmp(s, level[l]))\n\treturn l;\n    }\n  if (*nlevels < dap_maxlev)\n    {\n      strcpy(level[l], s);\n      (*nlevels)++;\n      return l;\n    }\n  else\n    {\n      fprintf(dap_err, \"(findlev) Too many levels at: %s\\n\", s);\n      exit(1);\n    }\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tabentry": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1189,
        1
      ],
      "content": "static void tabentry(int *varv, double **tab,\n\t\t     char **level[2], int nlevels[2], double count)\n{\n  dap_swap();\n  tab[findlev(varv[0], level[0], nlevels)][findlev(varv[1], level[1], nlevels + 1)] = count;\n  dap_swap();\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "valcpy": {
      "start_point": [
        1191,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "static void valcpy(int v, char *val)\n{\n  if (dap_obs[0].do_len[v] > 0)\n    strcpy(dap_obs[0].do_str[v], val);\n  else if (dap_obs[0].do_len[v] == INT)\n    dap_obs[0].do_int[v] = atoi(val);\n  else\n    dap_obs[0].do_dbl[v] = atof(val);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "freq2": {
      "start_point": [
        1201,
        0
      ],
      "end_point": [
        1586,
        1
      ],
      "content": "static void freq2(double **tab, char **level[2],\n\t\t  int nlevels[2], int *statv, int *markv, int nmark, int *varv,\n\t\t  int typen, int celln)\n{\n  int v;\n  int l;\n  double *expmem;\n  double **expect;\n  double *rowsum;\n  double *colsum;\n  double sum;\n  double *amem;\n  double **a;\n  double *dmem;\n  double **d;\n  double p, q;\n  double tmp1, tmp2, tmp3, tmp4;\n  double w;\n  double t;\n  double var;\n  int r, c;\n  double diff;\n  double chisq;\n  int rr, cc;\n  double upleft, dnleft;\n  double denom, prob, oneprob, othprob;\n  double hx, hy, hxy;\n  double uv;\n\n  sum = 0.0;\n  oneprob = 0.0;\n  expmem = (double *) dap_malloc(sizeof(double) * dap_maxlev * dap_maxlev, \"\");\n  expect = (double **) dap_malloc(sizeof(double *) * dap_maxlev, \"\");\n  for (l = 0; l < dap_maxlev; l++)\n    expect[l] = expmem + l * dap_maxlev;\n  rowsum = (double *) dap_malloc(sizeof(double) * dap_maxlev, \"\");\n  colsum = (double *) dap_malloc(sizeof(double) * dap_maxlev, \"\");\n  amem = (double *) dap_malloc(sizeof(double) * dap_maxlev * dap_maxlev, \"\");\n  dmem = (double *) dap_malloc(sizeof(double) * dap_maxlev * dap_maxlev, \"\");\n  a = (double **) dap_malloc(sizeof(double *) * dap_maxlev, \"\");\n  d = (double **) dap_malloc(sizeof(double *) * dap_maxlev, \"\");\n  for (l = 0; l < dap_maxlev; l++)\n    {\n      a[l] = amem + l * dap_maxlev;\n      d[l] = dmem + l * dap_maxlev;\n    }\n  dap_swap();\n  if (statv[FREQCHISQ] || statv[FREQODDRAT] || statv[FREQORD] ||\n      statv[FREQFISHER] || statv[FREQPAIR] || statv[FREQNOM])\n    {\n      dap_head(markv, nmark);\n      fputs(\"Variable: Levels\\n\", dap_lst);\n      fputs(\"----------------\\n\", dap_lst);\n      for (v = 0; v < 2; v++)\n\t{\n\t  fprintf(dap_lst, \"%s:\", dap_obs[0].do_nam[varv[v]]);\n\t  for (l = 0; l < nlevels[v]; l++)\n\t    fprintf(dap_lst, \" %s\", level[v][l]);\n\t  putc('\\n', dap_lst);\n\t}\n      putc('\\n', dap_lst);\n    }\n  if (statv[FREQEXP] || statv[FREQCHISQ] || statv[FREQORD] || statv[FREQFISHER] ||\n      statv[FREQROW] || statv[FREQCOL] || statv[FREQPAIR] || statv[FREQNOM])\n    {\n      for (r = 0, sum = 0.0; r < nlevels[0]; r++)\n\t{\n\t  rowsum[r] = 0.0;\n\t  for (c = 0; c < nlevels[1]; c++)\n\t    rowsum[r] += tab[r][c];\n\t  sum += rowsum[r];\n\t}\n      for (c = 0; c < nlevels[1]; c++)\n\t{\n\t  colsum[c] = 0.0;\n\t  for (r = 0; r < nlevels[0]; r++)\n\t    colsum[c] += tab[r][c];\n\t}\n      for (r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  expect[r][c] = rowsum[r] * colsum[c] / sum;\n    }\n  if (statv[FREQEXP])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"EXPECTED\");\n      for (r = 0; r < nlevels[0]; r++)\n\t{\n\t  valcpy(varv[0], level[0][r]);\n\t  for (c = 0; c < nlevels[1]; c++)\n\t    {\n\t      valcpy(varv[1], level[1][c]);\n\t      dap_obs[0].do_dbl[celln] = expect[r][c];\n\t      output();\n\t    }\n\t}\n    }\n  if (statv[FREQROW])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"ROWPERC\");\n      for (r = 0; r < nlevels[0]; r++)\n\t{\n\t  valcpy(varv[0], level[0][r]);\n\t  for (c = 0; c < nlevels[1]; c++)\n\t    {\n\t      valcpy(varv[1], level[1][c]);\n\t      dap_obs[0].do_dbl[celln] = 100.0 * tab[r][c] / rowsum[r];\n\t      output();\n\t    }\n\t}\n    }\n  if (statv[FREQCOL])\n    {\n      strcpy(dap_obs[0].do_str[typen], \"COLPERC\");\n      for (r = 0; r < nlevels[0]; r++)\n\t{\n\t  valcpy(varv[0], level[0][r]);\n\t  for (c = 0; c < nlevels[1]; c++)\n\t    {\n\t      valcpy(varv[1], level[1][c]);\n\t      dap_obs[0].do_dbl[celln] = 100.0 * tab[r][c] / colsum[c];\n\t      output();\n\t    }\n\t}\n    }\n  if (statv[FREQCHISQ])\n    {\n      for (r = 0, chisq = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    diff = tab[r][c] - expect[r][c];\n\t    chisq += diff * diff / expect[r][c];\n\t  }\n      fprintf(dap_lst, \"Chisq0[%d] = %g, Prob[Chisq > Chisq0] = %.5f\\n\",\n\t      (nlevels[0] - 1) * (nlevels[1] - 1), chisq,\n\t      ceil(100000.0 *\n\t\t   probchisq(chisq, (nlevels[0] - 1) * (nlevels[1] - 1))) /\n\t      100000.0);\n    }\n  if (statv[FREQODDRAT])\n    {\n      if (nlevels[0] == 2 && nlevels[1] == 2)\n\t{\n\t  tmp1 = (tab[0][0] + 0.5) * (tab[1][1] + 0.5) /\n\t    ((tab[0][1] + 0.5) * (tab[1][0] + 0.5));\n\t  fprintf(dap_lst,\n\t\t  \"Odds ratio = %g\\nlog(Odds ratio) = %g, ASE = %g\\n\",\n\t\t  tmp1, log(tmp1),\n\t\t  sqrt(1.0 / (tab[0][0] + 0.5) + 1.0 / (tab[1][0] + 0.5) +\n\t\t       1.0 / (tab[0][1] + 0.5) + 1.0 / (tab[1][1] + 0.5)));\n\t}\n      else\n\tfputs(\"(freq2) Odds ratio computed for 2 x 2 tables only.\\n\", dap_log);\n    }\n  if (statv[FREQFISHER])\n    {\n      if (nlevels[0] == 2 && nlevels[1] == 2) /* only do for 2x2 tables */\n\t{\n\t  if (tab[0][0] >= expect[0][0]) /* right-tail test: assoc stronger than expected */\n\t    {\n\t      denom = dap_bincoeff(sum, colsum[0]); /* number of tables given column sums */\n\t      for (upleft = tab[0][0], dnleft = tab[1][0], prob = 0.0;\n\t\t   upleft <= rowsum[0] && upleft <= colsum[0];\n\t\t   upleft += 1.0, dnleft -= 1.0)\n\t\t{\n\t\t  if (prob == 0.0)\n\t\t    {\n\t\t      oneprob = dap_bincoeff(rowsum[0], upleft) *\n\t\t\tdap_bincoeff(rowsum[1], dnleft);\n\t\t      prob = oneprob;\n\t\t    }\n\t\t  else\n\t\t    prob += dap_bincoeff(rowsum[0], upleft) *\n\t\t      dap_bincoeff(rowsum[1], dnleft);\n\t\t}\n\t      fprintf(dap_lst, \"Fisher's exact test: right     %g\\n\",\n\t\t      prob / denom);\n\t      for (upleft = ceil(expect[1][0]), dnleft = colsum[0] - upleft;\n\t\t   upleft <= rowsum[1] && upleft <= colsum[0];\n\t\t   upleft += 1.0, dnleft -= 1.0)\n\t\t{\n\t\t  othprob = dap_bincoeff(rowsum[1], upleft) *\n\t\t    dap_bincoeff(rowsum[0], dnleft);\n\t\t  if (othprob <= oneprob)\n\t\t    prob += othprob;\n\t\t}\n\t      if (tab[0][0] == expect[0][0])\n\t\t/* this is a kluge for tables satisfying independence */\n\t\tprob = 1.0;\n\t      fprintf(dap_lst, \"                     2-tailed  %g\\n\",\n\t\t      prob / denom);\n\t    }\n\t  if (tab[0][0] <= expect[0][0])\n\t    {\n\t      denom = dap_bincoeff(sum, colsum[1]);\n\t      for (upleft = tab[1][0], dnleft = tab[0][0], prob = 0.0;\n\t\t   upleft <= rowsum[1] && upleft <= colsum[0];\n\t\t   upleft += 1.0, dnleft -= 1.0)\n\t\t{\n\t\t  if (prob == 0.0)\n\t\t    {\n\t\t      oneprob = dap_bincoeff(rowsum[1], upleft) *\n\t\t\tdap_bincoeff(rowsum[0], dnleft);\n\t\t      prob = oneprob;\n\t\t    }\n\t\t  else\n\t\t    prob += dap_bincoeff(rowsum[1], upleft) *\n\t\t      dap_bincoeff(rowsum[0], dnleft);\n\t\t}\n\t      fprintf(dap_lst, \"Fisher's exact test: left      %g\\n\",\n\t\t      prob / denom);\n\t      for (upleft = ceil(expect[0][0]), dnleft = colsum[0] - upleft;\n\t\t   upleft <= rowsum[0] && upleft <= colsum[0];\n\t\t   upleft += 1.0, dnleft -= 1.0)\n\t\t{\n\t\t  othprob = dap_bincoeff(rowsum[0], upleft) *\n\t\t    dap_bincoeff(rowsum[1], dnleft);\n\t\t  if (othprob <= oneprob)\n\t\t    prob += othprob;\n\t\t}\n\t      if (tab[0][0] == expect[0][0])\n\t\t/* this is a kluge for tables satisfying independence */\n\t\tprob = 1.0;\n\t      fprintf(dap_lst, \"                     2-tailed  %g\\n\",\n\t\t      prob / denom);\n\t    }\n\t}\n      else\n\tfputs(\"(freq2) Fisher's exact test computed for 2 x 2 tables only.\\n\", dap_log);\n    }\n  if (statv[FREQORD])\n    {\n      for (r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    a[r][c] = 0.0;\n\t    d[r][c] = 0.0;\n\t    for (rr = 0; rr < nlevels[0]; rr++)\n\t      for (cc = 0; cc < nlevels[1]; cc++)\n\t\t{\n\t\t  if ((rr < r && cc < c) || (rr > r && cc > c))\n\t\t    a[r][c] += tab[rr][cc];\n\t\t  else if ((rr < r && cc > c) || (rr > r && cc < c))\n\t\t    d[r][c] += tab[rr][cc];\n\t\t}\n\t  }\n      for (r = 0, p = 0.0, q = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    p += tab[r][c] * a[r][c];\n\t    q += tab[r][c] * d[r][c];\n\t  }\n      fprintf(dap_lst, \"Statistic          Value   ASE\\n\");\n      for (r = 0, var = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp1 = q * a[r][c] - p * d[r][c];\n\t    var += tab[r][c] * tmp1 * tmp1;\n\t  }\n      tmp2 = p + q;\n      tmp2 *= tmp2;\n      tmp2 *= tmp2;\n      var *= 16.0 / tmp2;\n      fprintf(dap_lst, \"Gamma             %6.3f  %5.3f\\n\",\n\t      (p - q) / (p + q), sqrt(var));\n      for (r = 0, tmp1 = sum * sum; r < nlevels[0]; r++)\n\ttmp1 -= rowsum[r] * rowsum[r];\n      for (c = 0, tmp2 = sum * sum; c < nlevels[1]; c++)\n\ttmp2 -= colsum[c] * colsum[c];\n      w = sqrt(tmp1 * tmp2);\n      t = (p - q) / w;\n      for (r = 0, var = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp3 = 2.0 * w * (a[r][c] - d[r][c]) +\n\t      t * (rowsum[r] * tmp2 + colsum[c] * tmp1);\n\t    var += tab[r][c] * tmp3 * tmp3;\n\t  }\n      tmp4 = tmp1 + tmp2;\n      var = (var - sum * sum * sum * t * t * tmp4 * tmp4) / (w * w * w * w);\n      fprintf(dap_lst, \"Kendall's Tau-b   %6.3f  %5.3f\\n\", t, sqrt(var));\n      for (r = 0, var = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp3 = tmp1 * (a[r][c] - d[r][c]) - (p - q) * (sum - rowsum[r]);\n\t    var += tab[r][c] * tmp3 * tmp3;\n\t  }\n      var *= 4.0 / (tmp1 * tmp1 * tmp1 * tmp1);\n      fprintf(dap_lst, \"Somers' D C|R     %6.3f  %5.3f\\n\", (p - q) / tmp1, sqrt(var));\n      for (r = 0, var = 0.0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp3 = tmp2 * (a[r][c] - d[r][c]) - (p - q) * (sum - colsum[c]);\n\t    var += tab[r][c] * tmp3 * tmp3;\n\t  }\n      var *= 4.0 / (tmp2 * tmp2 * tmp2 * tmp2);\n      fprintf(dap_lst, \"Somers' D R|C     %6.3f  %5.3f\\n\", (p - q) / tmp2, sqrt(var));\n    }\n  if (statv[FREQPAIR])\n    {\n      if (nlevels[0] != nlevels[1])\n\t{\n\t  fprintf(dap_err, \"(freq2) PAIR requires square table, table is %d x %d.\\n\",\n\t\t  nlevels[0], nlevels[1]);\n\t  exit(1);\n\t}\n      for (r = 0, p = 0.0, q = 0.0, tmp1 = 0.0, tmp2 = 0.0; r < nlevels[0]; r++)\n\t{\n\t  p += tab[r][r];\t\t\t/* Po */\n\t  q += expect[r][r];\t\t/* Pe */\n\t  tmp1 += tab[r][r] * (rowsum[r] + colsum[r]);\n\t  for (c = 0; c < nlevels[0]; c++)\n\t    {\n\t      tmp3 = (rowsum[c] + colsum[r]);\n\t      tmp2 += tab[r][c] * tmp3 * tmp3;\n\t    }\n\t}\n      p /= sum;\n      q /= sum;\n      tmp1 /= sum * sum;\n      tmp2 /= sum * sum * sum;\n      tmp3 = 1.0 - p;\n      tmp4 = 1.0 - q;\n      fprintf(dap_lst, \"Statistic          Value   ASE\\n\");\n      fprintf(dap_lst, \"Kappa             %6.3f  %5.3f\\n\",\n\t      (p - q) / tmp4,\n\t      sqrt((p * tmp3 / (tmp4 * tmp4) +\n\t\t    2.0 * tmp3 * (2.0 * p * q - tmp1) / (tmp4 * tmp4 * tmp4) +\n\t\t    tmp3 * tmp3 * (tmp2 - 4.0 * q * q) / (tmp4 * tmp4 * tmp4 * tmp4)) /\n\t\t   sum));\n    }\n  if (statv[FREQNOM])\n    {\n      for (hx = 0.0, r = 0; r < nlevels[0]; r++)\n\thx -= rowsum[r] * log(rowsum[r] / sum);\n      hx /= sum;\n      for (hy = 0.0, c = 0; c < nlevels[1]; c++)\n\thy -= colsum[c] * log(colsum[c] / sum);\n      hy /= sum;\n      for (hxy = 0.0, r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  hxy -= tab[r][c] * log(tab[r][c] / sum);\n      hxy /= sum;\n      uv = hx + hy - hxy;\n      fprintf(dap_lst, \"Statistic              Value   ASE\\n\");\n      for (var = 0.0, r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp1 = hy * log(tab[r][c] / rowsum[r]) +\n\t      (hx - hxy) * log(colsum[c] / sum);\n\t    var += tab[r][c] * tmp1 * tmp1;\n\t  }\n      var = sqrt(var) / (sum * hy * hy);\n      fprintf(dap_lst, \"Uncertainty C|R       %6.3f  %5.3f\\n\",\n\t      uv / hy, var);\n      for (var = 0.0, r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp1 = hx * log(tab[r][c] / colsum[c]) +\n\t      (hy - hxy) * log(rowsum[r] / sum);\n\t    var += tab[r][c] * tmp1 * tmp1;\n\t  }\n      var = sqrt(var) / (sum * hx * hx);\n      fprintf(dap_lst, \"Uncertainty R|C       %6.3f  %5.3f\\n\",\n\t      uv / hx, var);\n      for (var = 0.0, r = 0; r < nlevels[0]; r++)\n\tfor (c = 0; c < nlevels[1]; c++)\n\t  {\n\t    tmp1 = hxy * log(rowsum[r] * colsum[c] / (sum * sum)) -\n\t      (hx + hy) * log(tab[r][c] / sum);\n\t    var += tab[r][c] * tmp1 * tmp1;\n\t  }\n      tmp2 = hx + hy;\n      var = 2.0 * sqrt(var) / (sum * tmp2 * tmp2);\n      fprintf(dap_lst, \"Uncertainty Symmetric %6.3f  %5.3f\\n\",\n\t      2.0 * uv / (hx + hy), var);\n    }\n  dap_swap();\n  dap_free(expmem, \"\");\n  dap_free(expect, \"\");\n  dap_free(rowsum, \"\");\n  dap_free(colsum, \"\");\n  dap_free(amem, \"\");\n  dap_free(a, \"\");\n  dap_free(dmem, \"\");\n  dap_free(d, \"\");\n}",
      "lines": 386,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "freqparse": {
      "start_point": [
        1588,
        0
      ],
      "end_point": [
        1649,
        1
      ],
      "content": "static int freqparse(char *varlist, int *varv, int *wt)\n{\n  int nvars;\n  int m;\n  int i;\n  char *mname;\n  int wtvar;\n\n  wt[0] = -1;\n  if (!varlist)\n    return 0;\n  mname = dap_malloc(dap_namelen + 1, \"\");\n  for (m = 0; varlist[m] == ' '; m++)\n    ;\n  for (nvars = 0, wtvar = 0; varlist[m]; )\n    {\n      if (varlist[m] == '*')\n\t{\n\t  if (wtvar)\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(freqparse) Only one weight variable allowed: %s\\n\",\n\t\t      varlist);\n\t      exit(1);\n\t    }\n\t  wtvar = 1;\n\t  for (m++; varlist[m] == ' '; m++)\n\t    ;\n\t}\n      for (i = 0; varlist[m + i] && varlist[m + i] != ' ' && varlist[m + i] != '*'; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    mname[i] = varlist[m + i];\n\t  else\n\t    {\n\t      mname[i] = '\\0';\n\t      fprintf(dap_err, \"(dap_list) Variable name too long: %s\\n\",\n\t\t      mname);\n\t      exit(1);\n\t    }\n\t}\n      mname[i] = '\\0';\n      if (wtvar)\n\t{\n\t  if ((wt[0] = dap_varnum(mname)) < 0)\n\t    {\n\t      fprintf(dap_err, \"(dap_list) Weight variable unknown: %s\\n\", mname);\n\t      exit(1);\n\t    }\n\t}\n      else if ((varv[nvars++] = dap_varnum(mname)) < 0)\n\t{\n\t  fprintf(dap_err, \"(dap_list) Variable unknown: %s\\n\", mname);\n\t  exit(1);\n\t}\n      m += i;\n      while (varlist[m] == ' ')\n\tm++;\n    }\n  dap_free(mname, \"\");\n  return nvars;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmh1": {
      "start_point": [
        1651,
        0
      ],
      "end_point": [
        1666,
        1
      ],
      "content": "static void cmh1(double **tab, double *cmh, double *cmhvar)\n{\n  double rowsum[2];\n  double colsum[2];\n  double tabsum;\n\n  rowsum[0] = tab[0][0] + tab[0][1];\n  rowsum[1] = tab[1][0] + tab[1][1];\n  colsum[0] = tab[0][0] + tab[1][0];\n  colsum[1] = tab[0][1] + tab[1][1];\n  tabsum = rowsum[0] + rowsum[1];\n  *cmh += tab[0][0] -\n    rowsum[0] * colsum[0] / tabsum;\n  *cmhvar += rowsum[0] * rowsum[1] * colsum[0] * colsum[1] /\n    (tabsum * tabsum * (tabsum - 1.0));\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printcmh": {
      "start_point": [
        1668,
        0
      ],
      "end_point": [
        1686,
        1
      ],
      "content": "static void printcmh(double cmh, double cmhvar,\n\t\t     int *varv, int nvar, int *markv, int nmark)\n{\n  int v;\n\n  dap_swap();\n  dap_head(markv, nmark);\n  cmh = fabs(cmh) - 0.5;\n  cmh *= cmh / cmhvar;\n  fprintf(dap_lst,\n\t  \"Cochran-Mantel-Haenszel test for %s x %s, stratified by\",\n\t  dap_obs[0].do_nam[varv[1]], dap_obs[0].do_nam[varv[2]]); \n  for (v = 0; v < nvar - 2; v++)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[v]]);\n  putc('\\n', dap_lst);\n  fprintf(dap_lst, \"M0-squared = %g, Prob[M-squared > M0-squared] = %g\\n\",\n\t  cmh, rint(10000.0 * probchisq(cmh, 1)) / 10000.0);\n  dap_swap();\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "freq": {
      "start_point": [
        1688,
        0
      ],
      "end_point": [
        1834,
        1
      ],
      "content": "void freq(char *fname, char *varlist, char *stats, char *marks)\n{\n  char *outname;\n  int statv[NFREQSTAT];\n  int typen;\n  int celln;\n  int *markv;\n  int nmark;\n  int *varv;\n  int nvar;\n  int v;\n  int wt;\n  char *outlist;\n  double count;\n  double sumcount;\n  double *tabmem;\n  double **tab;\n  char *levmem;\n  char **level[2];\n  int nlevels[2];\n  int l1, l2;\n  double cmh, cmhvar;\n  int more, moremore;\n  int (*strc)();\n\n  strc = &strcmp;\n  if (!fname)\n    {\n      fputs(\"(freq) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".frq\");\n  outlist = dap_malloc(dap_listlen + 1, \"\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  tabmem = (double *) dap_malloc(sizeof(double) * dap_maxlev * dap_maxlev, \"\");\n  tab = (double **) dap_malloc(sizeof(double *) * dap_maxlev, \"\");\n  for (l1 = 0; l1 < dap_maxlev; l1++)\n    tab[l1] = tabmem + l1 * dap_maxlev;\n  levmem = dap_malloc(2 * dap_maxlev * (dap_strlen + 1), \"\");\n  level[0] = (char **) dap_malloc(sizeof(char *) * dap_maxlev, \"\");\n  level[1] = (char **) dap_malloc(sizeof(char *) * dap_maxlev, \"\");\n  for (l1 = 0; l1 < dap_maxlev; l1++)\n    {\n      level[0][l1] = levmem + l1 * (dap_strlen + 1);\n      level[1][l1] = level[0][l1] + dap_maxlev * (dap_strlen + 1);\n    }\n  statparse(stats, statv);\n  inset(fname);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fputs(\"(freq) Missing _type_ variable.\\n\", dap_err);\n      exit(1);\n    }\n  nmark = dap_list(marks, markv, dap_maxvar);\n  nvar = freqparse(varlist, varv, &wt);\n  if (statv[FREQCMH] && nvar < 3)\n    {\n      fputs(\n\t    \"(freq) Cochran-Mantel-Haenszel test performed only for tables with dimension >= 3.\\n\",\n\t    dap_err);\n      exit(1);\n    }\n  celln = dap_vd(\"_cell_ -1\", 0);\n  for (v = 0; v < nvar; v++)\n    {\n      if (!v)\n\tstrcpy(outlist, dap_obs[0].do_nam[varv[v]]);\n      else\n\t{\n\t  strcat(outlist, \" \");\n\t  strcat(outlist, dap_obs[0].do_nam[varv[v]]);\n\t}\n    }\n  strcat(outlist, \" _cell_ \");\n  strcat(outlist, marks);\n  outset(outname, outlist);\n  nlevels[0] = 0;\n  nlevels[1] = 0;\n  for (l1 = 0; l1 < dap_maxlev; l1++)\n    for (l2 = 0; l2 < dap_maxlev; l2++)\n      tab[l1][l2] = 0.0;\n  for (dap_mark(), sumcount = 0.0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_rewind();\n\t  if (nvar == 2)\n\t    {\n\t      qsort(level[0][0], nlevels[0], dap_strlen + 1, strc);\n\t      qsort(level[1][0], nlevels[1], dap_strlen + 1, strc);\n\t    }\n\t  for (count = 0.0, cmh = 0.0, cmhvar = 0.0, moremore = 1; moremore; )\n\t    {\n\t      dap_mark();\n\t      moremore = (step() && !dap_newpart(markv, nmark));\n\t      if (dap_newpart(varv, nvar) || dap_newpart(markv, nmark))\n\t\t{\n\t\t  freq1(varv, nvar, count, sumcount, statv, typen, celln);\n\t\t  if (nvar == 2)\n\t\t    tabentry(varv, tab, level, nlevels, count); \n\t\t  else if (statv[FREQCMH])\n\t\t    {\n\t\t      tabentry(varv + nvar - 2, tab, level, nlevels, count); \n\t\t      if (dap_newpart(varv, nvar - 2))\n\t\t\tcmh1(tab, &cmh, &cmhvar);\n\t\t    }\n\t\t  count = 0.0;\n\t\t}\n\t      if (wt >= 0)\n\t\tcount += dap_obs[0].do_dbl[wt];\n\t      else\n\t\tcount += 1.0;\n\t    }\n\t  if (nvar == 2)\n\t    freq2(tab, level, nlevels, statv, markv, nmark, varv, typen, celln);\n\t  else if (statv[FREQCMH])\n\t    printcmh(cmh, cmhvar, varv, nvar, markv, nmark);\n\t  for (l1 = 0; l1 < dap_maxlev; l1++)\n\t    for (l2 = 0; l2 < dap_maxlev; l2++)\n\t      tab[l1][l2] = 0.0;\n\t  sumcount = 0.0;\n\t  nlevels[0] = 0;\n\t  nlevels[1] = 0;\n\t}\n      if (nvar == 2)\n\t{\n\t  findlev(varv[0], level[0], nlevels);\n\t  findlev(varv[1], level[1], nlevels + 1);\n\t}\n      if (wt >= 0)\n\tsumcount += dap_obs[0].do_dbl[wt];\n      else\n\tsumcount += 1.0;\n    }\n  dap_free(outname, \"\");\n  dap_free(outlist, \"\");\n  dap_free(markv, \"\");\n  dap_free(varv, \"\");\n  dap_free(tabmem, \"\");\n  dap_free(tab, \"\");\n  dap_free(levmem, \"\");\n  dap_free(level[0], \"\");\n  dap_free(level[1], \"\");\n}",
      "lines": 147,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "trim1": {
      "start_point": [
        1836,
        0
      ],
      "end_point": [
        1849,
        1
      ],
      "content": "static void trim1(double *vpct, int nvar, double **val,\n\t\t  int nobs, double *vmin, double *vmax)\n{\n  int v;\n  int trimcnt;\n\n  for (v = 0; v < nvar; v++)\n    {\n      trimcnt = (int) rint(vpct[v] / 100.0 * ((double) nobs));\n      qsort((void *) val[v], (size_t) nobs, (size_t) sizeof(double), cmp);\n      vmin[v] = val[v][trimcnt];\n      vmax[v] = val[v][nobs - trimcnt - 1];\n    }\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "trimparse": {
      "start_point": [
        1851,
        0
      ],
      "end_point": [
        1942,
        1
      ],
      "content": "static int trimparse(char *trimspec, int *varv, double *vpct)\n{\n  int n;\n  int i;\n  char *varname;\n  int v;\n  double div;\n  int digits;\n  int nvar;\n\n  if (!trimspec)\n    return 0;\n  varname = dap_malloc(dap_namelen + 1, \"\");\n  for (n = 0; trimspec[n] == ' '; n++)\n    ;\n  for (nvar = 0; trimspec[n]; )\n    {\n      for (i = 0; trimspec[n + i] && trimspec[n + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    varname[i] = trimspec[n + i];\n\t  else\n\t    {\n\t      varname[i] = '\\0';\n\t      fprintf(dap_err, \"(trimparse) trim variable name too long: %s\\n\",\n\t\t      varname);\n\t      exit(1);\n\t    }\n\t}\n      varname[i] = '\\0';\n      n += i;\n      if ((v = dap_varnum(varname)) >= 0)\n\t{\n\t  varv[nvar] = v;\n\t  while (trimspec[n] == ' ')\n\t    n++;\n\t  for (digits = 0, div = 0.0;\n\t       ('0' <= trimspec[n] && trimspec[n] <= '9') || trimspec[n] == '.';\n\t       n++)\n\t    {\n\t      if (trimspec[n] == '.')\n\t\t{\n\t\t  if (div >= 1.0)\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(trimparse) multiple decimal points in percent for %s\\n\",\n\t\t\t      varname);\n\t\t      exit(1);\n\t\t    }\n\t\t  div = 1.0;\n\t\t}\n\t      else\n\t\t{\n\t\t  digits = 10 * digits + trimspec[n] - '0';\n\t\t  if (div >= 1.0)\n\t\t    div *= 10.0;\n\t\t}\n\t    }\n\t  vpct[nvar] = (double) digits;\n\t  if (div >= 1.0)\n\t    vpct[nvar] /= div;\n\t  if (vpct[nvar] > 0.0)\n\t    {\n\t      if (dap_obs[0].do_len[v] == DBL)\n\t\tnvar++;\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(trimparse) trim variable not double: %s\\n\",\n\t\t\t  varname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(trimparse) no percent for trim variable: %s\\n\",\n\t\t      varname);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(trimparse) unknown trim variable: %s\\n\", varname);\n\t  exit(1);\n\t}\n      while (trimspec[n] == ' ')\n\tn++;\n    }\n  dap_free(varname, \"\");\n  return nvar;\n}",
      "lines": 92,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "trim": {
      "start_point": [
        1944,
        0
      ],
      "end_point": [
        2030,
        1
      ],
      "content": "void trim(char *fname, char *trimspec, char *marks)\n{\n  char *outname;\n  int *markv;\n  int nmark;\n  int *varv;\n  double *vpct;\n  int nvar;\n  double *valmem;\n  double **val;\n  int v;\n  int nobs;\n  double *vmin;\n  double *vmax;\n  int more;\n\n  if (!fname)\n    {\n      fputs(\"(trim) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  outname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(outname, fname, \".trm\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  vpct = (double *) dap_malloc(sizeof(double) * dap_maxvar, \"\");\n  vmin = (double *) dap_malloc(sizeof(double) * dap_maxvar, \"\");\n  vmax = (double *) dap_malloc(sizeof(double) * dap_maxvar, \"\");\n  inset(fname);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  nvar = trimparse(trimspec, varv, vpct);\n  outset(outname, \"\");\n  valmem = (double *) dap_malloc(sizeof(double) * nvar * dap_maxval, \"\");\n  val = (double **) dap_malloc(sizeof(double *) * nvar, \"\");\n  for (v = 0; v <= nvar; v++)\n    val[v] = valmem + v * dap_maxval;\n  for (dap_mark(), nobs = 0, more = 1; more; nobs++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  trim1(vpct, nvar, val, nobs, vmin, vmax);\n\t  dap_rewind();\n\t  while (step() && !dap_newpart(markv, nmark))\n\t    {\n\t      for (v = 0; v < nvar; v++)\n\t\t{\n\t\t  if (dap_obs[0].do_dbl[varv[v]] < vmin[v] ||\n\t\t      dap_obs[0].do_dbl[varv[v]] > vmax[v])\n\t\t    break;\n\t\t}\n\t      if (v == nvar)\n\t\toutput();\n\t      dap_mark();\n\t    }\n\t  nobs = 0;\n\t}\n      if (nobs < dap_maxval)\n\t{\n\t  for (v = 0; v < nvar; v++)\n\t    {\n\t      if (finite(dap_obs[0].do_dbl[varv[v]]))\n\t\tval[v][nobs] = dap_obs[0].do_dbl[varv[v]];\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(trim) NaN value %d for %s\\n\",\n\t\t\t  nobs, dap_obs[0].do_nam[varv[v]]);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  fputs(\"(group) Too many data.\\n\", dap_err);\n\t  exit(1);\n\t}\n    }\n  dap_free(outname, \"\");\n  dap_free(markv, \"\");\n  dap_free(varv, \"\");\n  dap_free(vpct, \"\");\n  dap_free(valmem, \"\");\n  dap_free(val, \"\");\n  dap_free(vmin, \"\");\n  dap_free(vmax, \"\");\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dap3.c": {
    "plot1": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static void plot1(double x[], double y[], int nobs,\n\t\t  char xvar[], char yvar[], int markv[], int nmark,\n\t\t  pict p[], pict a[], int pn, char style[],\n\t\t  double (*xfunct)(), double (*yfunct)(), int doaxes)\n{\n  int titlelen;\n  static char *title0 = NULL;\n  char *title1;\n  int overlay;\n  int n;\n  int v;\n  int s;\n  char *axspec;\n  int t;\n  double pictr;\n\n  dap_swap();\n  if (dap_title)\n    titlelen = strlen(dap_title) + 1;\n  else\n    titlelen = 0;\n  if (!title0)\n    {\n      title0 = dap_malloc(dap_linelen + titlelen + 1, \"dap_linelen\");\n      if (dap_title)\n\tstrcpy(title0, dap_title);\n    }\n  title1 = dap_malloc(dap_linelen + titlelen + 1, \"dap_linelen\");\n  for (s = 0; style[s] == ' '; s++)\n    ;\n  overlay = 0;\n  if (style[s] == 'o')\n    {\n      for (s++; style[s] == ' '; s++)\n\t;\n      for ( ; '0' <= style[s] && style[s] <= '9'; s++)\n\toverlay = 10 * overlay + style[s] - '0';\n      if (!overlay)\n\toverlay = -1;\n    }\n  while (style[s] == ' ')\n    s++;\n  axspec = dap_malloc(3 + strlen(style), \"\");\n  strcpy(axspec, style + s);\n  if (overlay == -1)\n    {\n      if (pn)\n\tpict_initpict(p + pn - 1, p + pn);\n      else\n\tpict_initpict(NULL, p + pn);\n      pict_initpict(p + pn, a);\n    }\n  else if (overlay)\n    {\n      if (pn % overlay)\n\tpict_initpict(p + pn - 1, p + pn);\n      else\n\tpict_initpict(NULL, p + pn);\n      pict_initpict(p + pn, a + (pn / overlay));\n    }\n  else\n    {\n      pict_initpict(NULL, p + pn);\n      pict_initpict(p + pn, a + pn);\n    }\n  for (n = 0; n < nobs; n++)\n    pict_point(p + pn, x[n], y[n]);\n  strcpy(p[pn].pict_type, \"CIRC\");\n  title1[0] = '\\0';\n  if (dap_title)\n    strcpy(title1, dap_title);\n  if (overlay >= 0 && nmark)\n    {\n      if (dap_title)\n\tstrcat(title1, \"\\n\");\n      for (v = 0; v < nmark; v++)\n\t{\n\t  if (v)\n\t    strcat(title1, \" \");\n\t  if (dap_obs[0].do_len[markv[v]] == DBL)\n\t    sprintf(title1 + strlen(title1), \"%g\",\n\t\t    dap_obs[0].do_dbl[markv[v]]);\n\t  else if (dap_obs[0].do_len[markv[v]] == INT)\n\t    sprintf(title1 + strlen(title1), \"%d\",\n\t\t    dap_obs[0].do_int[markv[v]]);\n\t  else\n\t    strcat(title1, dap_obs[0].do_str[markv[v]]);\n\t}\n      if (overlay > 0)\n\t{\n\t  if (!(pn % overlay))\n\t    strcpy(title0, title1);\n\t  else\n\t    {\n\t      for (t = 0; title0[t] && title0[t] == title1[t]; t++)\n\t\t;\n\t      title1[t] = '\\0';\n\t    }\n\t}\n    }\n  if (doaxes)\n    {\n      if (overlay == -1)\n\t{\n\t  pictr =\n\t    0.05 * pict_autoaxes(p, xvar, yvar, axspec, xfunct, yfunct, title1, PORTRAIT);\n\t  while (pn >= 0)\n\t    p[pn--].pict_r = pictr;\n\t}\n      else if (overlay)\n\t{\n\t  pictr = 0.05 * pict_autoaxes(p + (pn / overlay) * overlay,\n\t\t\t\t       xvar, yvar, axspec, xfunct, yfunct, title1, PORTRAIT);\n\t  while (pn >= (pn / overlay) * overlay)\n\t    p[pn--].pict_r = pictr;\n\t}\n      else\n\tp[pn].pict_r = 0.05 * pict_autoaxes(p + pn, xvar, yvar,\n\t\t\t\t\t    axspec, xfunct, yfunct, title1, PORTRAIT);\n    }\n  dap_swap();\n  if (doaxes)\n    {\n      dap_free(title0, \"\");\n      title0 = NULL;\n    }\n  dap_free(title1, \"\");\n  dap_free(axspec, \"\");\n}",
      "lines": 129,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "plotparse": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static void plotparse(char *xyvar, char *xyname, char *xname, char *yname)\n{\n  int n;\t\t/* index to xyvar */\n  int xyn;\t/* index to xyname */\n  int xn, yn;\t/* indexes to xname, yname */\n  int ystart;\t/* starting position of y variable name in xyvar */\n\n  for (n = 0; xyvar[n] == ' '; n++)\t/* skip spaces */\n    ;\n  /* first copy actual x variable name to xyname */\n  for (xyn = 0; xyvar[n] && xyvar[n] != ' ' && xyvar[n] != '`'; n++)\n    {\n      if (xyn < dap_namelen)\n\txyname[xyn++] = xyvar[n];\n      else\n\t{\n\t  fprintf(dap_err, \"(plotparse) X-variable name too long: %s\\n\", xyvar);\n\t  exit(1);\n\t}\n    }\n  strncpy(xname, xyvar, n);\t/* and copy that to xname */\n  xname[n] = '\\0';\n  xyname[xyn++] = ' ';\t\t/* leave a space before y variable name */\n  while (xyvar[n] == ' ')\t\t/* skip unnecessary spaces */\n    n++;\n  if (xyvar[n] == '`')\t\t/* if axis renaming specified */\n    {\n      for (n++; xyvar[n] == ' '; n++)\n\t;\n      /* replace xname with that */\n      for (xn = 0; xyvar[n] && xyvar[n] != '`'; n++)\n\t{\n\t  if (xn < dap_linelen)\n\t    xname[xn++] = xyvar[n];\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(plotparse) X-axis label too long: %s\\n\", xyvar);\n\t      exit(1);\n\t    }\n\t}\n      while (xyvar[n] == ' ')\n\tn++;\n      if (xyvar[n] == '`')\n\t{\n\t  for (n++; xyvar[n] == ' '; n++)\n\t    ;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(plotparse) Expected ` after x-axis label: %s\\n\", xyvar);\n\t  exit(1);\n\t}\n      xname[xn] = '\\0';\n    }\n  ystart = n;\t/* mark start of y variable name */\n  /* and copy y variable name to xyname */\n  for ( ; xyvar[n] && xyvar[n] != ' ' && xyvar[n] != '`'; n++)\n    {\n      if (xyn < 2 * (dap_namelen + 1))\n\txyname[xyn++] = xyvar[n];\n      else\n\t{\n\t  fprintf(dap_err, \"(plotparse) Y-variable name too long: %s\\n\", xyvar);\n\t  exit(1);\n\t}\n    }\n  xyname[xyn] = '\\0';\n  if (yname)\t\t/* if y variable name requested, too */\n    {\n      strncpy(yname, xyvar + ystart, n);\t/* start with variable name */\n      yname[n - ystart] = '\\0';\n      xyname[xyn++] = ' ';\n      while (xyvar[n] == ' ')\n\tn++;\n      if (xyvar[n] == '`')\t/* but if renaming, rename */\n\t{\n\t  for (n++; xyvar[n] == ' '; n++)\n\t    ;\n\t  for (yn = 0; xyvar[n] && xyvar[n] != '`'; n++)\n\t    {\n\t      if (yn < dap_linelen)\n\t\tyname[yn++] = xyvar[n];\n\t      else\n\t\t{\n\t\t  fprintf(dap_err, \"(plotparse) Y-axis label too long: %s\\n\", xyvar);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  yname[yn] = '\\0';\n\t}\n    }\n  xyname[xyn] = '\\0';\n}",
      "lines": 93,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "plot": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "pict *plot(char *fname, char *xyvar, char *marks,\n\t   char *style, double (*xfunct)(), double (*yfunct)(), int nplots)\n{\n  pict *p;\n  pict *a;\n  int *markv;\n  int nmark;\n  int nobs;\n  int nnan;\n  static double *x, *y;\n  int pn;\n  int xyv[2];\n  char *xyname;\n  char *xname;\n  char *yname;\n  int s;\n  int overlay;\n  int more;\n\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  p = (pict *) dap_malloc(2 * nplots * sizeof(pict), \"\");\n  a = p + nplots;\n  x = (double *) dap_malloc(dap_maxval * sizeof(double), \"\");\n  y = (double *) dap_malloc(dap_maxval * sizeof(double), \"\");\n  if (!fname)\n    {\n      fputs(\"(plot) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  inset(fname);\n  if (!xyvar)\n    {\n      fputs(\"(plot) No x and y variable list given.\\n\", dap_err);\n      exit(1);\n    }\n  xyname = dap_malloc(2 * (dap_namelen + 1), \"\");\n  xname = dap_malloc(dap_linelen + 1, \"\");\n  yname = dap_malloc(dap_linelen + 1, \"\");\n  plotparse(xyvar, xyname, xname, yname);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  if (dap_list(xyname, xyv, dap_maxvar) != 2)\n    {\n      fprintf(dap_err, \"(plot) Invalid x and y variable list: %s\\n\", xyvar);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[xyv[0]] != DBL)\n    {\n      fprintf(dap_err, \"(plot) x-variable is not double variable: %s\\n\",\n\t      dap_obs[0].do_nam[xyv[0]]);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[xyv[1]] != DBL)\n    {\n      fprintf(dap_err, \"(plot) y-variable is not double variable: %s\\n\",\n\t      dap_obs[0].do_nam[xyv[1]]);\n      exit(1);\n    }\n  for (s = 0; style[s] == ' '; s++)\n    ;\n  overlay = 0;\n  if (style && style[s] == 'o')\n    {\n      for (s++; style[s] == ' '; s++)\n\t;\n      for ( ; '0' <= style[s] && style[s] <= '9'; s++)\n\toverlay = 10 * overlay + style[s] - '0';\n      if (!overlay)\n\toverlay = -1;\n    }\n  for (nobs = 0, nnan = 0, pn = 0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  if (pn < nplots)\n\t    {\n\t      plot1(x, y, nobs, xname, yname,\n\t\t    markv, nmark, p, a, pn, style, xfunct, yfunct,\n\t\t    (!more || !overlay || (overlay > 0 && !((pn + 1) % overlay))));\n\t      pn++;\n\t      if (nnan > 0)\n\t\tfprintf(dap_log, \"(plot) %d NaNs\\n\", nnan);\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(plot) More plots than specified by nplots (%d)\\n\",\n\t\t      nplots);\n\t      exit(1);\n\t    }\n\t  nobs = 0;\n\t  nnan = 0;\n\t}\n      if (nobs < dap_maxval)\n\t{\n\t  x[nobs] = dap_obs[0].do_dbl[xyv[0]];\n\t  y[nobs] = dap_obs[0].do_dbl[xyv[1]];\n\t  if (finite(x[nobs]) && finite(y[nobs]))\n\t    nobs++;\n\t  else\n\t    nnan++;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(plot) Too many points\\n\");\n\t  exit(1);\n\t}\n    }\n  dap_free(x, \"\");\n  dap_free(y, \"\");\n  dap_free(markv, \"\");\n  dap_free(xyname, \"\");\n  dap_free(xname, \"\");\n  dap_free(yname, \"\");\n  return p;\n}",
      "lines": 116,
      "depth": 21,
      "decorators": [
        "pict",
        "*plot(char *fname, char *xyvar, char *marks,\n\t   char *style, double (*xfunct)(), double (*yfunct)(), int nplots)",
        "*"
      ]
    },
    "dblcmp": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static int dblcmp(double *x, double *y)\n{\n  if (*x < *y)\n    return -1;\n  if (*x > *y)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "comb": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static double comb(int n, int k) /* n combination k */\n{\n  double dn, dk;\n  double c;\n\n  for (c = 1.0, dn = (double) n, dk = (double) k; dk >= 1.0;\n       dn -= 1.0, dk -= 1.0)\n    c *= dn / dk;\n  return c;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "orderf": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "static double orderf(double t)\n{\n  double x;\n  double tmp1, tmp2;\n\n  if (t == -1.0 || t == 1.0)\n    return 0.0;\n  tmp1 = 1.0 - t * t;\n  x = t / sqrt(tmp1);\n  tmp2 = dkm1 * log(probz(x)) + dnmk * log(probz(-x)) - 0.5 * x * x;\n  if (finite(tmp2))\n    return exp(tmp2) * t / (tmp1 * tmp1);\n  return 0.0;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "geta": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static void geta(double a[], int n) /* get (negative of) Shaprio-Wilk \"a\" array */\n{\n  int k; /* index to \"a\" array */\n  double dn; /* number of points, as double */\n  double c;\n\n  if (n < 7) /* get \"exact\" values for \"a\" array */\n    {\n      switch (n)\n\t{\n\tcase 3:\n\t  a[0] = 0.707107;\n\t  break;\n\tcase 4:\n\t  a[0] = 0.687155;\n\t  a[1] = 0.166787;\n\t  break;\n\tcase 5:\n\t  a[0] = 0.664647;\n\t  a[1] = 0.241337;\n\t  break;\n\tcase 6:\n\t  a[0] = 0.643105;\n\t  a[1] = 0.280635;\n\t  a[2] = 0.0875196;\n\t  break;\n\t}\n      return;\n    }\n  /* Here we use the approximations on page 117 of\n   * Royston, Appl. Statist. (1982), 31, No. 2, pp. 115-124\n   */\n  for (k = 0; k < n / 2; k++)\n    { /* first get the expected values of the order statistics of n normal variates */\n      dnmk = (double) (n - k - 1);\n      dkm1 = (double) k;\n      a[k] = ((double) k + 1) * comb(n, k + 1) * INVSQ2PI *\n\tdap_simp(&orderf, -1.0, 1.0, NSTEPS);\n    }\n  dn = (double) n;\n  if (n <= 20)\n    {\n      for (a[0] = SQRTHALF; dn > 2.0; dn -= 2.0)\n\ta[0] *= (dn - 2.0) / (dn - 1.0);\n      if (dn == 2.0)\n\ta[0] *= TWOOSQRTPI;\n      else\n\ta[0] *= SQRTPI;\n    }\n  else\n    {\n      for (a[0] = SQRTHALF; dn > 1.0; dn -= 2.0)\n\ta[0] *= (dn - 1.0) / dn;\n      if (dn == 1.0)\n\ta[0] *= TWOOSQRTPI;\n      else\n\ta[0] *= SQRTPI;\n    }\n  for (c = 0.0, k = 1; k < n / 2; k++)\n    c += a[k] * a[k];\n  c = sqrt((1.0 - 2.0 * a[0]) / (2.0 * c));\n  a[0] = -sqrt(a[0]);\n  for (k = 1; k < n / 2; k++)\n    a[k] *= c;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "poly": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static double poly(double c[], double x, int n)\n{\n  double p;\n\n  for (p = c[n]; --n >= 0; )\n    p = p * x + c[n];\n  return p;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "probw": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "static double probw(int n, double w0, double a1)\n{\n  double u; /* transformed from w0 */\n  double d, lambda, logmu, logsigma;\n  double y;\n  double eps;\n  int r; /* range index */\n\n  if (n == 3)\n    return SIXOVERPI * (asin(sqrt(w0)) - asin(sqrt(0.75)));\n  if (n >= 7)\n    {\n      if (n <= 20)\n\td = 3.0;\n      else\n\td = 5.0;\n      d = log((double) n) - d;\n      if (n <= 20)\n\t{\n\t  lambda = poly(clambda1, d, 2);\n\t  logmu = poly(clogmu1, d, 3);\n\t  logsigma = poly(clogsigma1, d, 3);\n\t}\n      else\n\t{\n\t  lambda = poly(clambda2, d, 5);\n\t  logmu = poly(clogmu2, d, 5);\n\t  logsigma = poly(clogsigma2, d, 6);\n\t}\n      y = pow(1.0 - w0, lambda);\n      return probz(-(y - exp(logmu)) / exp(logsigma));\n    }\n  else\n    {\n      if (w0 >= 1.0)\n\treturn 1.0;\n      eps = a1 * a1 * (1.0 + 1.0 / ((double) (n - 1)));\n      if (w0 <= eps)\n\treturn 0.0;\n      u = log((w0 - eps) / (1.0 - w0));\n      if (w0 < lowhigh[n - 4][0] || w0 > lowhigh[n - 4][1])\n\treturn 0.0 / 0.0;\n      if (u < 1.4)\n\tr = 0;\n      else\n\t{\n\t  r = 1;\n\t  u = log(u);\n\t  if (!finite(u))\n\t    return 0.0 / 0.0;\n\t}\n      u = poly(au[n - 4][r], u, 4);\n      if (r)\n\tu = exp(u);\n      u = exp(u);\n      return SIXOVERPI * (asin(sqrt((u + 0.75) / (1.0 + u))) - asin(sqrt(0.75)));\n    }\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "normal1": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static void normal1(double x[], double y[], int nobs,\n\t\t    char varname[], char varlabel[], int markv[], int nmark,\n\t\t    pict *p, pict *l, pict *a, int pn)\n{\n  int titlelen; /* length of title string, +1, for caption */\n  int r; /* index to sorted values (of y), i.e., rank */\n  double dr; /* r converted to double */\n  double dnobsp25; /* number of obs + 1/4, as double, for denom for computing x */\n  double sum; /* for incremental computation of corrected sum of squares */\n  double ss; /* corrected sum of squares */\n  double vtmp; /* temp for incremental computation of corrected sum of squares */\n  double tmp; /* temp for incremental computation of corrected sum of squares */\n  double sd; /* standard deviation: needed for slope of line in q-q plot */\n  double minx, maxx; /* min and max values of x, for q-q plot */\n  double *swa; /* array of Shapiro-Wilk \"a\" coefficients */\n  int k; /* index of \"a\" array */\n  double w; /* Shapiro-Wilk statistic */\n  double prob; /* probability that W <= computed Shapiro-Wilk statistic */\n  int v;\n  char *caption;\n  int (*cmp)(); /* address of function for comparing doubles through pointers */\n\n  dap_swap(); /* get back to part of file we want to work on */\n  cmp = &dblcmp;\n  if (dap_title)\n    titlelen = strlen(dap_title) + 1;\n  else\n    titlelen = 0;\n  if (p) /* if q-q plot requested, we have pointer to linked list of picts\n\t  * and we need to allocate caption string: 47??\n          */\n    caption = dap_malloc(dap_linelen + titlelen + 47, \"dap_linelen\");\n  qsort((void *) y, (size_t) nobs, (size_t) sizeof(double), cmp);\n  /* q-q plot has denominator n + 1/4, numerator rank - 3/8 */\n  dnobsp25 = ((double) nobs) + 0.25;\n  for (r = 0, sum = 0.0, ss = 0.0, minx = 0.0, maxx = 0.0; r < nobs; r++)\n    { /* for each y, compute an x for plotting: inv std norm(numerator/denominator) */\n      dr = (double) r;\n      x[r] = -zpoint((dr + 0.625) / dnobsp25);\n      if (x[r] < minx)\n\tminx = x[r];\n      if (x[r] > maxx)\n\tmaxx = x[r];\n      vtmp = y[r];\n      if (r)\n\t{ /* incremental method for computing corrected sum of squares */\n\t  tmp = sum - dr * vtmp;\n\t  ss += tmp * tmp / (dr * (dr + 1.0));\n\t}\n      sum += vtmp;\n    }\n  sd = sqrt(ss / ((double) (nobs - 1))); /* need sd to plot line for q-q plot */\n  if (sd == 0.0)\n    {\n      fprintf(dap_err, \"(normal1) Zero standard deviation for %s\\n\", varname);\n      exit(1);\n    }\n  if (3 <= nobs && nobs <= 2000)\n    {\n      swa = (double *) dap_malloc(nobs / 2 * sizeof(double), \"\");\n      geta(swa, nobs); /* compute Shapiro-Wilk \"a\" coefficients */\n      for (w = 0.0, k = 0; k < nobs / 2; k++) /* compute W */\n\tw += swa[k] * (y[k] - y[nobs - 1 - k]);\n      w *= w / ss;\n      if ((prob = probw(nobs, w, swa[0])) < 0.001)\n\tprob = 0.001;\n      dap_free(swa, \"\");\n      if (p)\t/* if q-q plot requested */\n\tsprintf(caption, \"q-q plot: W|0| = %.4f, P[W < W|0|] = %.3f\", w, prob);\n      dap_head(markv, nmark);\n      fprintf(dap_lst,\n\t      \"Shapiro-Wilk test for %s:\\nW0 = %.4f, P[W < W0] = %.3f\\n\",\n\t      varname, w, prob);\n    }\n  else if (p)\t/* if q-q plot requested */\n    strcpy(caption, \"q-q plot\");\n  if (p && dap_title)\t/* if q-q plot requested and title given */\n    {\n      strcat(caption, \"\\n\");\n      strcat(caption, dap_title);\n    }\n  if (p && nmark)\t/* if q-q plot requested and dataset is partitioned */\n    {\n      for (v = 0; v < nmark; v++)\n\t{\n\t  strcat(caption, \"\\n\");\n\t  if (dap_obs[0].do_len[markv[v]] == DBL)\n\t    sprintf(caption + strlen(caption), \"%g\",\n\t\t    dap_obs[0].do_dbl[markv[v]]);\n\t  else if (dap_obs[0].do_len[markv[v]] == INT)\n\t    sprintf(caption + strlen(caption), \"%d\",\n\t\t    dap_obs[0].do_int[markv[v]]);\n\t  else\n\t    strcat(caption, dap_obs[0].do_str[markv[v]]);\n\t}\n    }\n  if (p)\t/* if q-q plot requested */\n    {\n      pict_initpict(NULL, p + pn);\n      pict_initpict(p + pn, l + pn);\n      pict_initpict(l + pn, a + pn);\n      for (r = 0; r < nobs; r++)\n\tpict_point(p + pn, x[r], y[r]);\n      strcpy(p[pn].pict_type, \"CIRC\");\n      sum /= (double) nobs;\n      strcpy(l[pn].pict_type, \"LINE\");\n      pict_line(l + pn, minx, sd * minx + sum, maxx, sd * maxx + sum);\n      p[pn].pict_r = 0.05 *\n\tpict_autoaxes(p + pn, \"z\", varlabel, \"-0 NXDIGITS3\", NULL, NULL, caption, PORTRAIT);\n      free(caption);\n    }\n  dap_swap();\n}",
      "lines": 113,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "normal": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "pict *normal(char *fname, char *variable, char *marks, int nplots)\n{\n  char *varname;\n  char *varlabel;\n  int s, t;\n  pict *p;\t/* the picts for the q-q plots */\n  pict *l;\t/* the picts for the straight lines in the q-q plots */\n  pict *a;\t/* the picts for the axes for the q-q plots */\n  int *markv;\n  int nmark;\n  int nobs;\n  int nnan;\n  double *x, *y;\n  int pn;\n  int vy;\n  int more;\n\n  varname = dap_malloc(dap_namelen + 1, \"\");\n  varlabel = dap_malloc(dap_linelen + 1, \"\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  if (nplots)\n    {\n      p = (pict *) dap_malloc(3 * nplots * sizeof(pict), \"\");\n      l = p + nplots;\n      a = p + 2 * nplots;\n    }\n  else\n    p = (pict *) NULL;\n  x = (double *) dap_malloc(dap_maxval * sizeof(double), \"\");\n  y = (double *) dap_malloc(dap_maxval * sizeof(double), \"\");\n  if (!variable)\n    {\n      fputs(\"(normal) No variable specified.\\n\", dap_err);\n      exit(1);\n    }\n  for (t = 0; variable[t] == ' '; t++)\n    ;\n  for (s = 0; variable[t] && variable[t] != ' ' && variable[t] != '`'; t++)\n    {\n      if (s < dap_namelen)\n\tvarname[s++] = variable[t];\n      else\n\t{\n\t  fprintf(dap_err, \"(normal) Variable name too long: %s\\n\", variable);\n\t  exit(1);\n\t}\n    }\n  varname[s] = '\\0';\n  while (variable[t] == ' ')\n    t++;\n  s = 0;\n  if (variable[t] == '`')\n    {\n      for (t++ ; variable[t] && variable[t] != ' ' && variable[t] != '`'; t++)\n\t{\n\t  if (s < dap_linelen)\n\t    varlabel[s++] = variable[t];\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(normal) Variable label too long: %s\\n\", variable);\n\t      exit(1);\n\t    }\n\t}\n      varlabel[s] = '\\0';\n    }\n  else\n    strcpy(varlabel, varname);\n  if (!fname)\n    {\n      fputs(\"(normal) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  inset(fname);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  if ((vy = dap_varnum(varname)) < 0)\n    {\n      fprintf(dap_err, \"(normal) Variable unknown: %s\\n\", varname);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[vy] != DBL)\n    {\n      fprintf(dap_err, \"(normal) Variable is not double variable: %s\\n\", varname);\n      exit(1);\n    }\n  for (nobs = 0, nnan = 0, pn = 0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  if (!nplots || pn < nplots)\n\t    {\n\t      normal1(x, y, nobs, varname, varlabel, markv, nmark,\n\t\t      p, l, a, pn++);\n\t      if (nnan > 0)\n\t\tfprintf(dap_log, \"(normal) %d NaNs\\n\", nnan);\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(normal) More plots than specified by nplots (%d)\\n\",\n\t\t      nplots);\n\t      exit(1);\n\t    }\n\t  nobs = 0;\n\t  nnan = 0;\n\t}\n      if (nobs < dap_maxval)\n\t{\n\t  y[nobs] = dap_obs[0].do_dbl[vy];\n\t  if (finite(y[nobs]))\n\t    nobs++;\n\t  else\n\t    nnan++;\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(normal) Too many points\\n\");\n\t  exit(1);\n\t}\n    }\n  dap_free(x, \"\");\n  dap_free(y, \"\");\n  dap_free(varname, \"\");\n  dap_free(varlabel, \"\");\n  dap_free(markv, \"\");\n  return p;\n}",
      "lines": 127,
      "depth": 14,
      "decorators": [
        "pict",
        "*normal(char *fname, char *variable, char *marks, int nplots)",
        "*"
      ]
    },
    "arint": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "static double arint(double x)\n{\n  double i;\n        \n  if (fabs(i = rint(x)) == 0.0)\n    return 0.0; \n  else    \n    return i;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "histo1": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        1119,
        1
      ],
      "content": "static void histo1(double x[], double xw[][2], int nobs, int varv[], int nbars,\n\t\t   char xname[], char *style, double (*xfunct)(),\n\t\t   int markv[], int nmark, pict *p, pict *a, int pn)\n{\n  int titlelen;\n  char *caption;\n  int s;\n  int w; /* index to word */\n  char *word;\n  char *axspec; /* specification for axes for pict_autoaxes, inherited from style */\n  double *h;\n  double *part;\n  int equal;\n  int height;\n  int whole;\n  double min, max;\n  double xlen, xspace;\n  static char htitle[19];\n  double width;\n  double dnobs;\n  double dnbars;\n  int b; /* index for bars */\n  int xn;\n  int xnm1;\n  int v;\n  double maxy;\n  int (*cmp)();\n\n  cmp = &dblcmp;\n  if (dap_title)\n    titlelen = strlen(dap_title) + 1;\n  else\n    titlelen = 0;\n  /* this could bomb, but probably won't */\n  caption = dap_malloc(titlelen + dap_linelen + 1, \"\");\n  axspec = dap_malloc(strlen(style) + 1, \"\");\n  word = dap_malloc(dap_namelen + 1, \"\");\n  h = (double *) dap_malloc(sizeof(double) * dap_maxbars, \"\");\n  part = (double *) dap_malloc(sizeof(double) * (dap_maxbars + 1), \"\");\n  if (!nbars)\n    {\n      fputs(\"(histo1) Number of bars is zero.\\n\", dap_err);\n      exit(1);\n    }\n  equal = 1;\n  height = UNSPEC;\n  whole = 0;\n  htitle[0] = '\\0';\n  if (x)\n    {\n      qsort((void *) x, (size_t) nobs, (size_t) sizeof(double), cmp);\n      part[0] = x[0];\n      part[nbars] = x[nobs - 1];\n    }\n  else\n    {\n      qsort((void *) xw, (size_t) nobs, (size_t) (2 * sizeof(double)), cmp);\n      part[0] = xw[0][0];\n      part[nbars] = xw[nobs - 1][0];\n    }\n  maxy = 0.0;\t/* mark as not used */\n  axspec[0] = '\\0';\n  if (style)\n    {\n      for (s = 0; style[s] == ' '; s++)\n\t;\n      while (style[s])\n\t{\n\t  for (w = 0; style[s] && style[s] != ' '; )\n\t    {\n\t      if (w < dap_namelen)\n\t\tword[w++] = style[s++];\n\t      else\n\t\t{\n\t\t  word[w] = '\\0';\n\t\t  fprintf(dap_err, \"(histo1) Style word too long: %s\\n\", word);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  word[w] = '\\0';\n\t  if (!strcmp(word, \"EQUAL\"))\n\t    equal = 1;\n\t  else if (!strcmp(word, \"VARIABLE\"))\n\t    equal = 0;\n\t  else if (!strcmp(word, \"COUNT\"))\n\t    height = COUNT;\n\t  else if (!strcmp(word, \"PERCENT\"))\n\t    height = PERCENT;\n\t  else if (!strcmp(word, \"FRACTION\"))\n\t    height = FRACTION;\n\t  else if (!strcmp(word, \"ROUND\"))\n\t    whole = 1;\n\t  else /* info for histo1, but also passed as part of axspec */\n\t    {\n\t      strcat(axspec, word);\n\t      strcat(axspec, \" \");\n\t      if (!strncmp(word, \"MINX\", 4))\n\t\t{\n\t\t  if (sscanf(word + 4, \"%lf\", &part[0]) != 1)\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(histo1) bad MINX specification: %s\\n\",\n\t\t\t      word);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t      else if (!strncmp(word, \"MAXX\", 4))\n\t\t{\n\t\t  if (sscanf(word + 4, \"%lf\", &part[nbars]) != 1)\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(histo1) bad MAXX specification: %s\\n\",\n\t\t\t      word);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t  while (style[s] == ' ')\n\t    s++;\n\t}\n    }\n  if (equal)\n    {\n      switch (height)\n\t{\n\tcase UNSPEC:\n\tcase COUNT:\n\t  strcpy(htitle, \"Count\");\n\t  break;\n\tcase PERCENT:\n\t  strcpy(htitle, \"Percent\");\n\t  break;\n\tcase FRACTION:\n\t  strcpy(htitle, \"Fraction\");\n\t  break;\n\t}\n    }\n  else\n    {\n      switch (height)\n\t{\n\tcase COUNT:\n\t  fputs(\"(histo1) Can't use count with variable width bars.\\n\",\n\t\tdap_err);\n\t  exit(1);\n\tcase PERCENT:\n\t  strcpy(htitle, \"Density (Percent)\");\n\t  break;\n\tcase UNSPEC:\n\tcase FRACTION:\n\t  strcpy(htitle, \"Density (Fraction)\");\n\t  break;\n\t}\n    }\n  dnobs = (double) nobs;\n  dnbars = (double) nbars;\n  if (whole)\n    {\n      xlen = 1e5 / (part[nbars] - part[0]);\n      xlen = (arint(xlen * part[nbars]) - arint(xlen * part[0])) / xlen;\n      if (xlen >= 1.0)\n\t{\n\t  for (xspace = 1.0; dnbars * xspace < xlen; xspace *= dnbars)\n\t    ;\n\t  xspace *= ceil(xlen / xspace) / dnbars;\n\t}\n      else\n\t{\n\t  for (xspace = 0.1; xspace / nbars > xlen; xspace /= nbars)\n\t    ;\n\t  xspace *= ceil(xlen / xspace) / dnbars;\n\t}\n      part[0] = floor(part[0] / xspace) * xspace;\n      part[nbars] = ceil(part[nbars] / xspace) * xspace;\n    }\n  if (equal)\n    {\n      width = (part[nbars] - part[0]) / dnbars;\n      for (b = 1; b < nbars; b++)\n\tpart[b] = part[0] + width * ((double) b);\n      for (b = 0; b < nbars; b++)\n\th[b] = 0.0;\n      for (xn = 0, b = 0; xn < nobs; xn++)\n\t{\n\t  if (x)\n\t    {\n\t      while (b < nbars && x[xn] > part[b + 1])\n\t\tb++;\n\t      h[b] += 1.0;\n\t    }\n\t  else\n\t    {\n\t      while (b < nbars && xw[xn][0] > part[b + 1])\n\t\tb++;\n\t      h[b] += xw[xn][1];\n\t    }\n\t}\n      for (b = 0; b < nbars; b++)\n\t{\n\t  switch (height)\n\t    {\n\t    case PERCENT:\n\t      h[b] *= 100.0;\n\t    case FRACTION:\n\t      h[b] /= dnobs;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  else\n    {\n      for (b = 1, xnm1 = 0; b < nbars; b++)\n\t{\n\t  xn = (int) rint(dnobs * ((double) b) / dnbars);\n\t  if (x)\n\t    part[b] = x[xn];\n\t  else\n\t    part[b] = xw[xn][0];\n\t  if (part[b] > part[b - 1])\n\t    h[b] = ((double) (xn - xnm1)) / ((part[b] - part[b - 1]) * dnobs);\n\t  else\n\t    h[b] = 0.0;\n\t  if (height == PERCENT)\n\t    h[b] *= 100.0;\n\t  xnm1 = xn;\n\t}\n    }\n  pict_initpict(NULL, p + pn);\n  pict_initpict(p + pn, a + pn);\n  for (b = 0; b < nbars; b++)\n    pict_rectangle(p + pn, part[b], 0.0, part[b + 1] - part[b], h[b]);\n  caption[0] = '\\0';\n  if (dap_title)\n    strcpy(caption, dap_title);\n  if (nmark)\n    {\n      if (dap_title)\n\tstrcat(caption, \"\\n\");\n      for (v = 0; v < nmark; v++)\n\t{\n\t  if (v)\n\t    strcat(caption, \" \");\n\t  if (dap_obs[0].do_len[markv[v]] == DBL)\n\t    sprintf(caption + strlen(caption), \"%g\",\n\t\t    dap_obs[0].do_dbl[markv[v]]);\n\t  else if (dap_obs[0].do_len[markv[v]] == INT)\n\t    sprintf(caption + strlen(caption), \"%d\",\n\t\t    dap_obs[0].do_int[markv[v]]);\n\t  else\n\t    strcat(caption, dap_obs[0].do_str[markv[v]]);\n\t}\n    }\n  pict_autoaxes(p + pn, xname, htitle, axspec, xfunct, NULL, caption, PORTRAIT);\n  dap_free(caption, \"\");\n  dap_free(axspec, \"\");\n  dap_free(word, \"\");\n  dap_free(h, \"\");\n  dap_free(part, \"\");\n}",
      "lines": 261,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "histogram": {
      "start_point": [
        1122,
        0
      ],
      "end_point": [
        1260,
        1
      ],
      "content": "pict *histogram(char *fname, char *vars, char *marks, int nbars,\n\t\tchar *style, double (*xfunct)(), int nplots)\n{\n  pict *p;\n  pict *a;\n  int *markv;\n  int nmark;\n  int varv[2];\n  int nvar;\n  int nobs;\n  double *x;\n  double (*xw)[2];\n  char *xwname;\n  char *xname;\n  int pn;\n  int v;\n  int mv;\n  int nnan;\n  int more;\n\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  xwname = dap_malloc(2 * (dap_namelen + 1), \"\");\n  xname = dap_malloc(dap_linelen + 1, \"\");\n  p = (pict *) dap_malloc(2 * nplots * sizeof(pict), \"\");\n  a = p + nplots;\n  if (!fname)\n    {\n      fputs(\"(histogram) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  inset(fname);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  if (!vars)\n    {\n      fputs(\"(histogram) No variable given.\\n\", dap_err);\n      exit(1);\n    }\n  plotparse(vars, xwname, xname, NULL);\n  nvar = dap_list(xwname, varv, dap_maxvar);\n  for (v = 0; v < nvar; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] != DBL)\n\t{\n\t  fprintf(dap_err, \"(histogram) Variable is not double variable: %s\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n    }\n  if (nvar == 1)\n    {\n      x = (double *) dap_malloc(dap_maxval * sizeof(double), \"\");\n      xw = (double (*)[2]) NULL;\n    }\n  else if (nvar == 2)\n    {\n      xw = (double (*)[2]) dap_malloc(dap_maxval * 2 * sizeof(double), \"\");\n      x = (double *) NULL;\n    }\n  else\n    {\n      fprintf(dap_err,\n\t      \"(histogram) Variable list contains more than two variables: %s\\n\", vars);\n      exit(1);\n    }\n  for (nobs = 0, nnan = 0, pn = 0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  if (nnan)\n\t    {\n\t      fprintf(dap_log, \"(histogram) %d missing values for:\", nnan);\n\t      for (mv = 0; mv < nmark; mv++)\n\t\t{\n\t\t  putc(' ', dap_log);\n\t\t  if (dap_obs[0].do_len[markv[mv]] == DBL)\n\t\t    fprintf(dap_log, \"%g\",\n\t\t\t    dap_obs[0].do_dbl[markv[mv]]);\n\t\t  else if (dap_obs[0].do_len[markv[mv]] == INT)\n\t\t    fprintf(dap_log, \"%d\",\n\t\t\t    dap_obs[0].do_int[markv[mv]]);\n\t\t  else\n\t\t    fputs(dap_obs[0].do_str[markv[mv]], dap_log);\n\t\t}\n\t      putc('\\n', dap_log);\n\t    }\n\t  if (nobs)\n\t    {\n\t      if (pn < nplots)\n\t\thisto1(x, xw, nobs, varv, nbars, xname,\n\t\t       style, xfunct, markv, nmark, p, a, pn++);\n\t      else\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(histogram) More plots than specified by nplots (%d)\\n\",\n\t\t\t  nplots);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  dap_swap();\n\t  nobs = 0;\n\t  nnan = 0;\n\t}\n      if (nobs < dap_maxval)\n\t{\n\t  if (nvar == 1)\n\t    {\n\t      x[nobs] = dap_obs[0].do_dbl[varv[0]];\n\t      if (finite(x[nobs]))\n\t\tnobs++;\n\t      else\n\t\tnnan++;\n\t    }\n\t  else\n\t    {\n\t      xw[nobs][0] = dap_obs[0].do_dbl[varv[0]];\n\t      xw[nobs][1] = dap_obs[0].do_dbl[varv[1]];\n\t      if (finite(xw[nobs][0]) && finite(xw[nobs][1]))\n\t\tnobs++;\n\t      else\n\t\tnnan++;\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(histogram) Too many points\\n\");\n\t  exit(1);\n\t}\n    }\n  if (nvar == 1)\n    dap_free(x, \"\");\n  else\n    dap_free(xw, \"\");\n  dap_free(markv, \"\");\n  dap_free(xwname, \"\");\n  dap_free(xname, \"\");\n  return p;\n}",
      "lines": 139,
      "depth": 19,
      "decorators": [
        "pict",
        "*histogram(char *fname, char *vars, char *marks, int nbars,\n\t\tchar *style, double (*xfunct)(), int nplots)",
        "*"
      ]
    },
    "plotlinreg": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "pict *plotlinreg(char *fname, char *ylist0, char *x1list0, char *style,\n\t\t char *marks, int nmarks, double level)\n{\n  char *ylist;\t/* copy of ylist0 without axis renaming, if any */\n  char *x1list;\t/* copy of x1list0 without axis renaming, if any */\n  int l;\t\t/* index to strings */\n  int varv[1];\n  int typen;\t/* index of type variable */\n  int sortord[4];\t/* sort order for types for plot: 0 = LOWER, 1 = OBS,\n\t\t\t * 2 = PRED, 3 = UPPER\n\t\t\t */\n  int s;\t\t/* index to sortord */\n  char *mnsname;\t/* name of dataset for output of means() */\n  char *regname;\t/* name of dataset for output of linreg() */\n  char *srtarg;\t/* arguments to sort() */\n  char *srtname;\t/* name of dataset for output of sort() */\n  char *plotvars;\t/* variable names to pass to plot */\n  char *plotmarks;\n  pict *p;\n  int pn;\n  char *plotstyle;\n\n  ylist = dap_malloc(strlen(ylist0) + 1, \"\");\n  x1list = dap_malloc(strlen(x1list0) + 1, \"\");\n  for (l = 0; ylist0[l] && ylist0[l] != '`'; l++)\n    ylist[l] = ylist0[l];\n  ylist[l] = '\\0';\n  for (l = 0; x1list0[l] && x1list0[l] != '`'; l++)\n    x1list[l] = x1list0[l];\n  x1list[l] = '\\0';\n  inset(fname);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(plotlinreg) missing type variable in %s\\n\", fname);\n      exit(1);\n    }\n  step();\n  for (s = 0; s < 4; s++)\n    sortord[s] = s;\n  if (strcmp(dap_obs[0].do_str[typen], \"LOWER\") < 0)\n    {\t/* the 'OBS' value will appear first */\n      sortord[0] = 1;\n      sortord[1] = 0;\n    }\n  else if (strcmp(dap_obs[0].do_str[typen], \"PRED\") < 0)\n    ;\n  else if (strcmp(dap_obs[0].do_str[typen], \"UPPER\") < 0)\n    {\t/* the 'OBS' value will appear between 'PRED' and 'UPPER' */\n      sortord[1] = 2;\n      sortord[2] = 1;\n    }\n  else\n    {\n      sortord[1] = 3;\n      sortord[2] = 1;\n      sortord[3] = 2;\n    }\n  dap_list(ylist, varv, 1);\t/* check that it's only 1 variable */\n  dap_list(x1list, varv, 1);\t/* check that it's only 1 variable */\n  mnsname = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(mnsname, fname);\n  strcat(mnsname, \".mns\");\n  regname = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(regname, fname);\n  strcat(regname, \".reg\");\n  srtname = dap_malloc(strlen(regname) + 5, \"\");\n  strcpy(srtname, regname);\n  strcat(srtname, \".srt\");\n  means(fname, x1list, \"STEP100\", marks);\n  linreg(fname, ylist, \"\", x1list, marks, mnsname, level);\n  dataset(fname, regname, \"APPEND\");\n  srtarg = dap_malloc(strlen(marks) + strlen(x1list) + 9, \"\");\n  strcpy(srtarg, marks);\n  strcat(srtarg, \" _type_ \");\n  strcat(srtarg, x1list);\n  sort(regname, srtarg, \"\");\n  plotvars = dap_malloc(strlen(x1list0) + strlen(ylist0) + 2, \"\");\n  strcpy(plotvars, x1list0);\n  strcat(plotvars, \" \");\n  strcat(plotvars, ylist0);\n  plotmarks = dap_malloc(strlen(marks) + strlen(\"_type_\") + 2, \"\");\n  strcpy(plotmarks, marks);\n  strcat(plotmarks, \" _type_\");\n  plotstyle = dap_malloc(strlen(style) + 4, \"\");\n  strcpy(plotstyle, \"o4 \");\n  strcat(plotstyle, style);\n  p = plot(srtname, plotvars, plotmarks, plotstyle, NULL, NULL, 4 * nmarks);\n  for (pn = 0; pn < nmarks; pn++)\n    {\n      strcpy(p[4 * pn + sortord[0]].pict_type, \"LINE\");\n      strcpy(p[4 * pn + sortord[2]].pict_type, \"LINE\");\n      strcpy(p[4 * pn + sortord[3]].pict_type, \"LINE\");\n      p[4 * pn + sortord[0]].pict_dash = 4.0;\n      p[4 * pn + sortord[3]].pict_dash = 4.0;\n    }\n  dap_free(ylist, \"\");\n  dap_free(x1list, \"\");\n  dap_free(mnsname, \"\");\n  dap_free(regname, \"\");\n  dap_free(srtarg, \"\");\n  dap_free(srtname, \"\");\n  dap_free(plotvars, \"\");\n  dap_free(plotmarks, \"\");\n  dap_free(plotstyle, \"\");\n  return p;\n}",
      "lines": 106,
      "depth": 13,
      "decorators": [
        "pict",
        "*plotlinreg(char *fname, char *ylist0, char *x1list0, char *style,\n\t\t char *marks, int nmarks, double level)",
        "*"
      ]
    },
    "plotlogreg": {
      "start_point": [
        1375,
        0
      ],
      "end_point": [
        1550,
        1
      ],
      "content": "pict *plotlogreg(char *fname, char *yspec0, char *x1list0, char *style,\n\t\t int ngroups, char *marks, int nmarks,  double level)\n{\n  char *yspec;\t/* yspec0 with axis labeling removed */\n  char *x1list;\t/* x1list0 with axis labeling removed */\n  int varv[3];\n  char *trlname;\n  int trialsn;\n  char varspec[12];\n  char *grpname;\n  char *grparg;\n  char *grpvar;\n  char *mnsarg;\n  char *mnsname;\n  char *lgrname;\n  char *srtarg;\n  char *srtname;\n  char *plotvars;\n  char *plotmarks;\n  char *casevar;\t\t/* the number of cases */\n  char *casevar0;\t\t/* the number of cases, with option axis label */\n  int c;\n  int cs;\n  pict *p;\n  int pn;\n  char *plotstyle;\n  int l0, l;\t\t/* index to variable name strings */\n\n  yspec = dap_malloc(strlen(yspec0) + 1, \"\");\n  x1list = dap_malloc(strlen(x1list0) + 1, \"\");\n  for (l0 = 0, l = 0; yspec0[l0] && yspec0[l0] != '`'; )\n    yspec[l++] = yspec0[l0++];\n  if (yspec0[l0] == '`')\n    {\n      for (l0++; yspec0[l0] && yspec0[l0] != '`'; l0++)\n\t;\n      for (l0++; yspec0[l0]; )\n\tyspec[l++] = yspec0[l0++];\n    }\n  yspec[l] = '\\0';\n  for (l = 0; x1list0[l] && x1list0[l] != '`'; l++)\n    x1list[l] = x1list0[l];\n  x1list[l] = '\\0';\n  trlname = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(trlname, fname);\n  strcat(trlname, \".trl\");\n  grpname = dap_malloc(strlen(trlname) + 5, \"\");\n  strcpy(grpname, trlname);\n  strcat(grpname, \".grp\");\n  srtname = dap_malloc(strlen(grpname) + 5, \"\");\n  strcpy(srtname, grpname);\n  strcat(srtname, \".srt\");\n  mnsname = dap_malloc(strlen(srtname) + 5, \"\");\n  strcpy(mnsname, srtname);\n  strcat(mnsname, \".mns\");\n  lgrname = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(lgrname, fname);\n  strcat(lgrname, \".lgr\");\n  grparg = dap_malloc(strlen(x1list) + 14, \"\");\n  grpvar = dap_malloc(strlen(marks) + strlen(x1list) + 3, \"\");\n  casevar = dap_malloc(strlen(yspec) + 1, \"\");\n  casevar0 = dap_malloc(strlen(yspec0) + 1, \"\");\n  mnsarg = dap_malloc(strlen(yspec) + 12 + strlen(x1list), \"\");\n  srtarg = dap_malloc(strlen(marks) + strlen(x1list) + 9, \"\");\n  plotvars = dap_malloc(strlen(x1list0) + strlen(yspec0) + 2, \"\");\n  plotmarks = dap_malloc(strlen(marks) + strlen(\"_type_\") + 2, \"\");\n  inset(fname);\n  dap_list(x1list, varv, 1);\t/* check that it's only 1 variable */\n  strcpy(grpvar, marks);\n  strcat(grpvar, \" _\");\n  strcat(grpvar, x1list);\n  strcpy(casevar, yspec);\n  for (cs = 0; casevar[cs] == ' '; cs++)\n    ;\n  for (c = 0; casevar[cs] && casevar[cs] != ' ' && casevar[cs] != '/'; )\n    casevar[c++] = casevar[cs++];\n  casevar[c] = '\\0';\n  strcpy(casevar0, yspec0);\n  for (cs = 0; casevar0[cs] == ' '; cs++)\n    ;\n  for (c = 0; casevar0[cs] && casevar0[cs] != '/'; )\n    casevar0[c++] = casevar0[cs++];\n  casevar0[c] = '\\0';\n\n  inset(fname);\n  sprintf(varspec, \"_ntrials %d\", DBL);\n  trialsn = dap_vd(varspec, 0);\n  outset(trlname, \"\");\n  dap_parsey(yspec, varv);\n  while (step())\n    {\n      if (varv[1] >= 0)\t/* number of trials variable */\n\tdap_obs[0].do_dbl[trialsn] = dap_obs[0].do_dbl[varv[1]];\n      else\n\tdap_obs[0].do_dbl[trialsn] = -varv[1];\n      output();\n    }\n\n  strcpy(grparg, x1list);\n  sprintf(grparg + strlen(grparg), \" %d#\", ngroups);\n\n  group(trlname, grparg, marks);\n\n  sort(grpname, grpvar, \"\");\n\n  strcpy(mnsarg, casevar);\n  strcat(mnsarg, \" _ntrials \");\n  strcat(mnsarg, x1list);\n  means(srtname, mnsarg, \"MEAN\", grpvar);\n\n  inset(mnsname);\n  outset(grpname, \"\");\n  trialsn = dap_varnum(\"_ntrials\");\n  dap_list(casevar, varv, 1);\n  while (step())\n    {\n      dap_obs[0].do_dbl[varv[0]] /= dap_obs[0].do_dbl[trialsn];\n      output();\n    }\n\n  means(fname, x1list, \"STEP100\", marks);\n\n  strcpy(mnsname, fname);\n  strcat(mnsname, \".mns\");\n\n  logreg(fname, yspec, \"\", x1list, marks, mnsname, level);\n\n  dataset(grpname, lgrname, \"APPEND\");\n\n  strcpy(srtarg, marks);\n  strcat(srtarg, \" _type_ \");\n  strcat(srtarg, x1list);\n\n  sort(lgrname, srtarg, \"\");\n\n  strcpy(srtname, lgrname);\n  strcat(srtname, \".srt\");\n\n  strcpy(plotvars, x1list0);\n  strcat(plotvars, \" \");\n  strcat(plotvars, casevar0);\n\n  strcpy(plotmarks, marks);\n  strcat(plotmarks, \" _type_\");\n\n  plotstyle = dap_malloc(strlen(style) + 4, \"\");\n  strcpy(plotstyle, \"o4 \");\n  strcat(plotstyle, style);\n\n  p = plot(srtname, plotvars, plotmarks, plotstyle, NULL, NULL, 4 * nmarks);\n  for (pn = 0; pn < nmarks; pn ++)\n    {\n      strcpy(p[4 * pn + 0].pict_type, \"LINE\");\n      strcpy(p[4 * pn + 2].pict_type, \"LINE\");\n      strcpy(p[4 * pn + 3].pict_type, \"LINE\");\n      p[4 * pn + 0].pict_dash = 4.0;\n      p[4 * pn + 3].pict_dash = 4.0;\n    }\n  dap_free(yspec, \"\");\n  dap_free(x1list, \"\");\n  dap_free(trlname, \"\");\n  dap_free(grpname, \"\");\n  dap_free(grparg, \"\");\n  dap_free(grpvar, \"\");\n  dap_free(mnsarg, \"\");\n  dap_free(mnsname, \"\");\n  dap_free(lgrname, \"\");\n  dap_free(srtarg, \"\");\n  dap_free(srtname, \"\");\n  dap_free(plotvars, \"\");\n  dap_free(plotmarks, \"\");\n  dap_free(casevar, \"\");\n  dap_free(casevar0, \"\");\n  dap_free(plotstyle, \"\");\n  return p;\n}",
      "lines": 176,
      "depth": 12,
      "decorators": [
        "pict",
        "*plotlogreg(char *fname, char *yspec0, char *x1list0, char *style,\n\t\t int ngroups, char *marks, int nmarks,  double level)",
        "*"
      ]
    },
    "plotmeans": {
      "start_point": [
        1560,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "pict *plotmeans(char *dataset, char *meanvar0, char *varlist0, char *errbar,\n\t\tchar *style, char *partvars, int noverlay)\n{\n  int meanv[1];\n  int *partv;\n  int npartv;\n  char *meanvar;\t/* user's meanvar0, truncating any `name spec` */\n  char *varlist;\t/* user's varlist0, truncating any `name spec` */\n  int l;\n  char *mnslist;\n  char *mnsname;\n  char *errname;\n  char *srtname;\n  char *ebar;\n  char *overstr;\n  int e;\t\t\t/* index to ebar */\n  double scale;\n  int typen;\n  double mean;\n  double err;\n  int n;\n  char *srtarg;\n  char *plotvars;\n  char *plotparts;\n  pict *p;\n  int more;\n  int nparts;\n  int pn;\n\n  partv = NULL;\n  mean = 0.0;\n  err = 0.0;\n  meanvar = dap_malloc(strlen(meanvar0) + 1, \"\");\t/* copy meanvar0, truncate `name-spec` */\n  strcpy(meanvar, meanvar0);\n  for (l = 0; meanvar[l] && meanvar[l] != '`'; l++)\n    ;\n  meanvar[l] = '\\0';\n  varlist = dap_malloc(strlen(varlist0) + 1, \"\");\t/* copy varlist0, truncate `name-spec` */\n  strcpy(varlist, varlist0);\n  for (l = 0; varlist[l] && varlist[l] != '`'; l++)\n    ;\n  varlist[l] = '\\0';\n  if (partvars && partvars[0])\n    {\n      partv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n      mnslist = dap_malloc(strlen(varlist) + strlen(partvars) + 2, \"\");\n      strcpy(mnslist, partvars);\n      strcat(mnslist, \" \");\n      strcat(mnslist, varlist);\n      plotparts = dap_malloc(strlen(partvars) + 8, \"\");\n      strcpy(plotparts, partvars);\n      strcat(plotparts, \" _type_\");\n    }\n  else\n    {\n      mnslist = varlist;\n      plotparts = \"_type_\";\n    }\n  mnsname = dap_malloc(strlen(dataset) + 5, \"\");\n  strcpy(mnsname, dataset);\n  strcat(mnsname, \".mns\");\n  errname = dap_malloc(strlen(dataset) + 5, \"\");\n  strcpy(errname, dataset);\n  strcat(errname, \".err\");\n  srtname = dap_malloc(strlen(errname) + 5, \"\");\n  strcpy(srtname, errname);\n  strcat(srtname, \".srt\");\n  ebar = dap_malloc(strlen(errbar) + 6, \"\");\n  strcpy(ebar, \"MEAN \");\n  strcat(ebar, errbar);\n  overstr = dap_malloc(8 + strlen(style), \"\");\n  if (noverlay < 1)\n    noverlay = 1;\n  sprintf(overstr, \"o%d %s\", 2 * noverlay, style);\n  srtarg = dap_malloc(strlen(mnslist) + 8, \"\");\n  if (partvars && partvars[0])\n    {\n      strcpy(srtarg, partvars);\n      strcat(srtarg, \" \");\n    }\n  else\n    srtarg[0] = '\\0';\n  strcat(srtarg, \"_type_ \");\n  strcat(srtarg, varlist);\n  plotvars = dap_malloc(strlen(meanvar0) + strlen(varlist0) + 2, \"\");\n  strcpy(plotvars, varlist0);\n  strcat(plotvars, \" \");\n  strcat(plotvars, meanvar0);\n  for (e = 0; errbar[e] == ' '; e++)\n    ;\n  while (errbar[e] && errbar[e] != ' ')\n    e++;\n  ebar[e + 5] = '\\0';\n  while (errbar[e] == ' ')\n    e++;\n  if (errbar[e])\n    {\n      if (sscanf(errbar + e, \"%lf\", &scale) != 1)\n\t{\n\t  fprintf(stderr, \"%s: bad scale in call to plotmeans: %s\\n\",\n\t\t  dap_dapname, errbar + e);\n\t  exit(1);\n\t}\n    }\n  else\n    scale = 1.0;\n  means(dataset, meanvar, ebar, mnslist);\n  inset(mnsname);\n  outset(errname, \"\");\n  dap_list(varlist, meanv, 1);\t/* check that there's only one */\n  dap_list(meanvar, meanv, 1);\n  if (partvars && partvars[0])\n    npartv = dap_list(partvars, partv, dap_maxvar);\n  else\n    npartv = 0;\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(stderr, \"%s: missing _type_ variable for plotmeans\\n\", dap_dapname);\n      exit(1);\n    }\n  for (n = 0, nparts = 0, more = 1; more; )\n    {\n      more = step();\n      if (more)\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"MEAN\"))\n\t    mean = dap_obs[0].do_dbl[meanv[0]];\n\t  else\n\t    err = dap_obs[0].do_dbl[meanv[0]];\n\t  if (++n == 2)\n\t    {\n\t      strcpy(dap_obs[0].do_str[typen], \"MEAN\");\n\t      dap_obs[0].do_dbl[meanv[0]] = mean;\n\t      output();\n\t      strcpy(dap_obs[0].do_str[typen], \"BAR\");\n\t      dap_obs[0].do_dbl[meanv[0]] = mean - err * scale;\n\t      output();\n\t      dap_obs[0].do_dbl[meanv[0]] = mean + err * scale;\n\t      output();\n\t      n = 0;\n\t    }\n\t}\n      if (dap_newpart(partv, npartv))\n\tnparts++;\n    }\n  sort(errname, srtarg, \"\");\n  p = plot(srtname, plotvars, plotparts, overstr, NULL, NULL, 2 * nparts);\n  for (pn = 0; pn < nparts; pn++)\n    strcpy(p[2 * pn].pict_type, \"IBEA\");\n  if (partvars && partvars[0])\n    {\n      dap_free(partv, \"\");\n      dap_free(mnslist, \"\");\n      dap_free(plotparts, \"\");\n    }\n  dap_free(mnsname, \"\");\n  dap_free(errname, \"\");\n  dap_free(srtname, \"\");\n  dap_free(ebar, \"\");\n  dap_free(overstr, \"\");\n  dap_free(srtarg, \"\");\n  dap_free(plotvars, \"\");\n  return p;\n}",
      "lines": 164,
      "depth": 15,
      "decorators": [
        "pict",
        "*plotmeans(char *dataset, char *meanvar0, char *varlist0, char *errbar,\n\t\tchar *style, char *partvars, int noverlay)",
        "*"
      ]
    }
  },
  "dap/dap-3.10/src/dap4.c": {
    "gettwo": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static double gettwo(double x)\n{\n  double t;\n\n  for (t = 1.0, x = fabs(x); t > x; t /= 2.0)\n    ;\n  while (t < x)\n    t *= 2.0;\n  return t;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "rowred": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static int rowred(double **coeff, int rterm[], int byterm,\n\t\t  int ncells, double nobs[], int row1, int row2, int *nonz)\n{\n  int *misscol;\n  int celln;\n  int ncols;\n  int col, subcol;\n  int row, subrow;\n  int maxrow;\n  double colmax;\n  double rowmax;\n  double tmp, tmp1, tmp2;\n  int itmp;\n  double mult1, mult2;\n  int nterms;\n  int *term;\n  int t;\n  int elimrow;\n\n  nterms = 0;\n  elimrow = 0;\n  misscol = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  term = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  if (byterm)\n    {\n      nterms = 0;\n      term[nterms++] = 0;\n      for (row = row1 + 1; row <= row2; row++)\n\t{\n\t  for (t = 1; t < nterms; t++)\n\t    {\n\t      if (rterm[row] == term[t])\n\t\tbreak;\n\t    }\n\t  if (t == nterms)\n\t    term[nterms++] = rterm[row];\n\t}\n    }\n  for (celln = 0, ncols = 0; celln < ncells; celln++)\n    {\n      if (nobs[celln] == 0.0)\n\tmisscol[ncols++] = celln;\n    }\n  for (t = 0; (byterm && t < nterms) || t < 1; t++)\n    {\n      for (row = (t ? row1 + 1 : 0); row <= (t ? row2 : row1); row++)\n\t{\n\t  if (!byterm || row <= row1 || rterm[row] == term[t])\n\t    break;\n\t}\n      for (col = 0; col < ncols; col++)\n\t{\n\t  while (byterm && row > row1 && rterm[row] != term[t] &&\n\t\t row < (t ? row2 : row1))\n\t    row++;\n\t  for (colmax = 0.0, maxrow = row, subrow = row;\n\t       subrow <= (t ? row2 : row1); subrow++)\n\t    {\n\t      if (byterm && subrow > row1 && rterm[subrow] != term[t])\n\t\tcontinue;\n\t      if ((tmp = fabs(coeff[subrow][misscol[col]])) > colmax)\n\t\t{\n\t\t  colmax = tmp;\n\t\t  maxrow = subrow;\n\t\t}\n\t    }\n\t  if (colmax > dap_redtol)\n\t    {\n\t      if (maxrow != row)\n\t\t{\n\t\t  for (subcol = 0; subcol < ncells; subcol++)\n\t\t    {\n\t\t      tmp = coeff[row][subcol];\n\t\t      coeff[row][subcol] = coeff[maxrow][subcol];\n\t\t      coeff[maxrow][subcol] = tmp;\n\t\t      itmp = rterm[row];\n\t\t      rterm[row] = rterm[maxrow];\n\t\t      rterm[maxrow] = itmp;\n\t\t    }\n\t\t}\n\t      for (subrow = row + 1; subrow <= row2; subrow++)\n\t\t{\n\t\t  if (byterm && subrow > row1 && rterm[subrow] != term[t])\n\t\t    continue;\n\t\t  mult1 = coeff[subrow][misscol[col]];\n\t\t  mult2 = coeff[row][misscol[col]];\n\t\t  if (fabs(mult1) > dap_redtol * fabs(mult2))\n\t\t    {\n\t\t      for (subcol = 0, rowmax = 0.0; subcol < ncells; subcol++)\n\t\t\t{\n\t\t\t  tmp = mult2 * coeff[subrow][subcol];\n\t\t\t  tmp1 = mult1 * coeff[row][subcol];\n\t\t\t  coeff[subrow][subcol] = tmp - tmp1;\n\t\t\t  tmp2 = fabs(coeff[subrow][subcol]);\n\t\t\t  if (tmp2 < dap_redtol * (fabs(tmp) + fabs(tmp1)))\n\t\t\t    coeff[subrow][subcol] = 0.0;\n\t\t\t  else if (tmp2 > rowmax)\n\t\t\t    rowmax = tmp2;\n\t\t\t}\n\t\t      tmp = gettwo(rowmax);\n\t\t      for (subcol = 0; subcol < ncells; subcol++)\n\t\t\t{\n\t\t\t  coeff[subrow][subcol] /= tmp;\n\t\t\t  if (fabs(coeff[subrow][subcol]) < dap_redtol)\n\t\t\t    coeff[subrow][subcol] = 0.0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      row++;\n\t    }\n\t}\n      if (!t)\n\telimrow = row;\n    }\n  if (byterm)\n    {\n      for (t = 0; t < nterms; t++)\n\t{\n\t  for (row = (t ? row2 : row1); row > (t ? row1 + 1 : 0); --row)\n\t    {\n\t      if (row <= row1 || rterm[row] == term[t])\n\t\tbreak;\n\t    }\n\t  for ( ; row > (t ? row1 + 1 : 0); --row)\n\t    {\n\t      if (row > row1 && rterm[row] != term[t])\n\t\tcontinue;\n\t      for (col = 0; col < ncols; col++)\n\t\t{\n\t\t  if (fabs(coeff[row][misscol[col]]) > dap_redtol)\n\t\t    break;\n\t\t}\n\t      if (col < ncols)\n\t\t{\n\t\t  for (subrow = row - 1; subrow >= (t ? row1 + 1: 0); --subrow)\n\t\t    {\n\t\t      if (subrow > row1 && rterm[subrow] != term[t])\n\t\t\tcontinue;\n\t\t      mult1 = coeff[subrow][misscol[col]];\n\t\t      mult2 = coeff[row][misscol[col]];\n\t\t      if (fabs(mult1) > dap_redtol * fabs(mult2))\n\t\t\t{\n\t\t\t  for (col = 0, rowmax = 0.0; col < ncells; col++)\n\t\t\t    {\n\t\t\t      tmp = mult2 * coeff[subrow][col];\n\t\t\t      tmp1 = mult1 * coeff[row][col];\n\t\t\t      coeff[subrow][col] = tmp - tmp1;\n\t\t\t      if (fabs(coeff[subrow][col]) <\n\t\t\t\t  dap_redtol * (fabs(tmp) + fabs(tmp1)))\n\t\t\t\tcoeff[subrow][col] = 0.0;\n\t\t\t      else if (fabs(coeff[subrow][col]) > rowmax)\n\t\t\t\trowmax = fabs(coeff[subrow][col]);\n\t\t\t    }\n\t\t\t  tmp = gettwo(rowmax);\n\t\t\t  for (col = 0; col < ncells; col++)\n\t\t\t    {\n\t\t\t      coeff[subrow][col] /= tmp;\n\t\t\t      if (fabs(coeff[subrow][col]) < dap_redtol)\n\t\t\t\tcoeff[subrow][col] = 0.0;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  if (nonz)\n    {\n      for (row = 0; row <= row2; row++)\n\t{\n\t  nonz[row] = 0;\n\t  for (col = 0; col < ncells; col++)\n\t    {\n\t      if (fabs(coeff[row][col]) > dap_zerotol)\n\t\t{\n\t\t  if (nobs[col] > 0.0)\n\t\t    {\n\t\t      nonz[row] = 1;\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  dap_free(misscol, \"\");\n  dap_free(term, \"\");\n  if (elimrow == ncols)\n    return elimrow;\n  fputs(\"error terms insufficient to impute missing cells\\n\", dap_err);\n  exit(1);\n}",
      "lines": 191,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lcm": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static double lcm(double x, double y)\n{\n  int ix, iy;\n  int q, r;\n  int lcmxy;\n\n  ix = (int) x;\n  iy = (int) y;\n  lcmxy = ix * iy;\n  for ( ; ; )\n    {\n      q = iy / ix;\n      r = iy - q * ix;\n      if (r)\n\t{\n\t  iy = ix;\n\t  ix = r;\n\t}\n      else\n\tbreak;\n    }\n  return (double) (lcmxy / ix);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "orthog": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "static int orthog(double **coeff, int row0, int row1, int row2,\n\t\t  int ncells, double *nobs, int *indep, int *rterm)\n{\n  double lcmnobs;\n  int updown;\n  int *term;\n  int nterms;\n  int t;\n  int cr;\n  int cc;\n  int crr;\n  double lensq;\n  double dot;\n  double tmp, tmp1;\n  double mult1, mult2;\n  double rowmax;\n  int df;\n\n  nterms = 0;\n  term = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  if (row2 >= row0)\n    updown = 1;\n  else\n    updown = -1;\n  df = 0;\n  if (rterm)\n    {\n      for (cr = row0, nterms = 0; cr != row2 + updown; cr += updown)\n\t{\n\t  for (t = 0; t < nterms; t++)\n\t    {\n\t      if (rterm[cr] == term[t])\n\t\tbreak;\n\t    }\n\t  if (t == nterms)\n\t    term[nterms++] = rterm[cr];\n\t}\n    }\n  for (cc = 0, lcmnobs = 1.0; cc < ncells; cc++)\n    {\n      if (nobs[cc] != 0.0)\n\tlcmnobs = lcm(lcmnobs, nobs[cc]);\n    }\n  lcmnobs /= gettwo(lcmnobs);\n  for (t = 0; (rterm && t < nterms) || t < 1; t++)\n    {\n      for (cr = row0; cr != row1 + updown; cr += updown)\n\t{\n\t  if (rterm && rterm[cr] != term[t])\n\t    continue;\n\t  for (cc = 0; cc < ncells; cc++)\n\t    {\n\t      if (fabs(coeff[cr][cc]) > dap_orthtol)\n\t\tbreak;\n\t    }\n\t  if (cc < ncells)\n\t    break;\n\t}\n      for ( ; cr != row1 + updown; cr += updown)\n\t{\n\t  if (rterm && rterm[cr] != term[t])\n\t    continue;\n\t  for (lensq = 0.0, cc = 0; cc < ncells; cc++)\n\t    {\n\t      if (nobs[cc] > 0.0)\n\t\t{\n\t\t  tmp = coeff[cr][cc];\n\t\t  lensq += tmp * tmp * (lcmnobs / nobs[cc]);\n\t\t}\n\t    }\n\t  if (lensq > dap_orthtol)\n\t    {\n\t      indep[cr] = 1;\n\t      df++;\n\t      for (crr = cr + updown; crr != row2 + updown; crr += updown)\n\t\t{\n\t\t  if (rterm && rterm[crr] != term[t])\n\t\t    continue;\n\t\t  for (dot = 0.0, cc = 0; cc < ncells; cc++)\n\t\t    {\n\t\t      if (nobs[cc] > 0.0)\n\t\t\tdot += coeff[cr][cc] * coeff[crr][cc] *\n\t\t\t  (lcmnobs / nobs[cc]);\n\t\t    }\n\t\t  if (fabs(dot) > dap_orthtol * lensq)\n\t\t    {\n\t\t      mult1 = dot;\n\t\t      mult2 = lensq;\n\t\t      for (cc = 0, rowmax = 0.0; cc < ncells; cc++)\n\t\t\t{\n\t\t\t  tmp = mult2 * coeff[crr][cc];\n\t\t\t  tmp1 = mult1 * coeff[cr][cc];\n\t\t\t  coeff[crr][cc] = tmp - tmp1;\n\t\t\t  if (fabs(coeff[crr][cc]) <\n\t\t\t      dap_orthtol *\n\t\t\t      (fabs(tmp) + fabs(tmp1)))\n\t\t\t    coeff[crr][cc] = 0.0;\n\t\t\t  else if (fabs(coeff[crr][cc]) > rowmax)\n\t\t\t    rowmax = fabs(coeff[crr][cc]);\n\t\t\t}\n\t\t      tmp = gettwo(rowmax);\n\t\t      for (cc = 0; cc < ncells; cc++)\n\t\t\t{\n\t\t\t  coeff[crr][cc] /= tmp;\n\t\t\t  if (fabs(coeff[crr][cc]) < dap_orthtol)\n\t\t\t    coeff[crr][cc] = 0.0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      for (cc = 0; cc < ncells; cc++)\n\t\tcoeff[cr][cc] = 0.0;\n\t    }\n\t}\n      while (cr != row2 + updown)\n\t{\n\t  if (!rterm || rterm[cr] == term[t])\n\t    {\n\t      for (lensq = 0.0, cc = 0; cc < ncells; cc++)\n\t\t{\n\t\t  if (nobs[cc] > 0.0)\n\t\t    {\n\t\t      tmp = coeff[cr][cc];\n\t\t      lensq += tmp * tmp * (lcmnobs / nobs[cc]);\n\t\t    }\n\t\t}\n\t      if (lensq > dap_orthtol)\n\t\t{\n\t\t  indep[cr] = 1;\n\t\t  df++;\n\t\t}\n\t    }\n\t  cr += updown;\n\t}\n    }\n  dap_free(term, \"\");\n  return df;\n}",
      "lines": 140,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sumcheck": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "static void sumcheck(char caller[], double **coeff,\n\t\t     int ncells, int nerrors, int ncontrasts, int *rterm)\n{\n  int r, c;\n  double elt;\n  double rowsum;\n  double rowmax;\n\n  for (r = 0; r < nerrors + ncontrasts; r++)\n    {\n      for (c = 0, rowsum = 0.0, rowmax = 0.0; c < ncells; c++)\n\t{\n\t  elt = coeff[r][c];\n\t  rowsum += elt;\n\t  elt = fabs(elt);\n\t  if (elt > rowmax)\n\t    rowmax = elt;\n\t}\n      if (fabs(rowsum) > dap_zerotol * rowmax)\n\t{\n\t  fprintf(dap_err, \"(sumcheck:%s) Unable to fit model:\\n\", caller);\n\t  if (r < nerrors)\n\t    fprintf(dap_err, \"Error %d sums to %g:\\n\", r, rowsum);\n\t  else\n\t    fprintf(dap_err, \"Contrast %d sums to %g:\\n\", r - nerrors, rowsum);\n\t  fprintf(dap_err, \"%s%d (%x) \",\n\t\t  ((r < nerrors) ? \"E\" : \"C\"),\n\t\t  ((r < nerrors) ? r : r - nerrors),\n\t\t  (rterm ? rterm[r] : 0));\n\t  for (c = 0; c < ncells; c++)\n\t    fprintf(dap_err, \" %g\", coeff[r][c]);\n\t  putc('\\n', dap_err);\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "testparse": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "static int testparse(char *test, char *termv, int *varv, int nvars)\n{\n  int nterms;\t/* total number of terms in model and residual */\n  int tv;\t/* index to termv: bits of tv indicate variables in the term */\n  char *vname;  /* variable name */\n  int t;      \t/* index to char *test */\n  int n;\t/* index to vname[] */\n  int bit;\t/* bit to set for presence of variable in term */\n  int term;\t/* bits for entire term */\n  int vv;\t/* index to varv */\n  int v;\t/* index of variable dap_obs */\n  int firstv;\t/* first variable in term */\n\n  term = 0;\n  vname = dap_malloc(dap_namelen + 1, \"\");\n  if (!test || !test[0])\n    return 0;\n  /* compute the maximum possible number of terms for nvars variables with crossing */\n  for (nterms = 1, tv = 1; tv < nvars; tv++)\n    nterms *= 2;\n  nterms--; /* but the empty term isn't interesting */\n  for (tv = 1; tv <= nterms; tv++) /* all terms are error terms until proved to be contrasts */\n    termv[tv] = 'e';\n  for (t = 0; test[t] == ' '; t++) /* skip leading blanks of test string */\n    ;\n  for (firstv = 1; test[t]; )\n    {\n      if (firstv)\n\tterm = 0;\n      firstv = 0;\n      for (n = 0; test[t] && test[t] != ' ' && test[t] != '*'; )\n\t{ /* copy variable name from test string */\n\t  if (n < dap_namelen)\n\t    vname[n++] = test[t++];\n\t  else\n\t    {\n\t      vname[n] = '\\0';\n\t      fprintf(dap_err, \"(testparse) name too long: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t}\n      vname[n] = '\\0';\n      if ((v = dap_varnum(vname)) < 0)\n\t{\n\t  fprintf(dap_err, \"(testparse) unknown variable: %s\\n\", vname);\n\t  exit(1);\n\t}\n      for (bit = 0x1, vv = 1; vv < nvars; vv++, bit = (bit << 1))\n\t{\n\t  if (varv[vv] == v)\n\t    break;\n\t}\n      if (vv == nvars)\n\t{\n\t  fprintf(dap_err, \"(testparse) variable in test not in model: %s\\n\", vname);\n\t  exit(1);\n\t}\n      term |= bit;\n      while (test[t] == ' ')\n\tt++;\n      if (test[t] == '*')\n\t{\n\t  for (t++; test[t] == ' '; t++)\n\t    ;\n\t}\n      else\n\t{\n\t  termv[term] = 'c';\n\t  firstv = 1;\n\t}\n    }\n  dap_free(vname, \"\");\n  return nterms;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "levn": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "static int levn(char *levstr, char **levval, int *nlevels)\n{\n  int l;\n\n  for (l = 0; l < *nlevels && levval[l][0]; l++)\n    {\n      if (!strcmp(levstr, levval[l]))\n\treturn l;\n    }\n  if (l < dap_maxlev - 1)\n    {\n      strcpy(levval[l], levstr);\n      if (l < *nlevels)\n\treturn *nlevels;\n      else\n\treturn (*nlevels)++;\n    }\n  else\n    {\n      fprintf(dap_err, \"(levn) too many levels: %s\\n\", levstr);\n      exit(1);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putrand": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "static void putrand(int bits, double coeff, int varv[])\n{\n  int v;\n  int termn;\n\n  if (coeff != 0.0)\n    fprintf(dap_lst, \"\\n    %g Var(\", coeff);\n  for (v = 1, termn = 1; bits; bits = (bits >> 1), v++)\n    {\n      if (bits & 0x1)\n\t{\n\t  if (termn > 1)\n\t    putc('*', dap_lst);\n\t  fputs(dap_obs[0].do_nam[varv[v]], dap_lst);\n\t  termn++;\n\t}\n    }\n  if (coeff != 0.0)\n    putc(')', dap_lst);\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ems": {
      "start_point": [
        583,
        0
      ],
      "end_point": [
        739,
        1
      ],
      "content": "static int ems(double **coeff, int **level, int ncells,\n\t       int *rterm, int *indep, int nrows, double *nobs,\n\t       int *varv, char *termv, int nterm, double **emscoeff)\n{\n  int r;\t\t/* row in coefficient matrix */\n  int t;\t\t/* term bits for effect to be decomposed */\n  int u;\t\t/* term bits for factors */\n  int c;\t\t/* column in coefficient matrix */\n  double *cum;\n  double df;\t/* denominator degrees of freedom */\n  int *effrow;\n  int neffrows;\n  int *factlev;\n  int nfactlevs;\n  int bits;\n  double *emsc;\n  double *lensq;\t/* squared length of coeff matrix row */\n  int basecell;\n  int nextcell;\n  int *used;\n  int s;\n  int same;\n  double tmp;\n  int factor; /* ?? */\n\n  cum = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  emsc = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  lensq = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  effrow = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  factlev = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  used = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  for (r = 0; r < nrows; r++)\n    emsc[r] = 0.0;\n  emscoeff++;\t\t/* room for error */\n  for (t = 1, factor = 0; t <= nterm; t++)\n    {\n      if (termv[t] == 'c' || termv[t] == 'n')\n\t{\n\t  if (varv)\n\t    {\n\t      fputs(\"EMS(\", dap_lst);\n\t      putrand(t, 0.0, varv);\n\t      fputs(\") =\", dap_lst);\n\t    }\n\t  emscoeff[factor][0] = 1.0;\t/* space for EMS(Error) */\n\t  for (r = 0, neffrows = 0; r < nrows; r++)\n\t    {\n\t      if (indep[r] && rterm[r] == t)\n\t\teffrow[neffrows++] = r;\n\t    }\n\t  for (u = 1; u <= nterm; u++)\n\t    {\n\t      for (r = 0; r < nrows; r++)\n\t\t{\n\t\t  if (indep[r] && rterm[r] == u)\n\t\t    break;\n\t\t}\n\t      if ((u & t) == t && r < nrows)\n\t\t{\n\t\t  for (bits = u, nfactlevs = 0, r = 1; bits; bits = (bits >> 1), r++)\n\t\t    {\n\t\t      if (bits & 0x1)\n\t\t\tfactlev[nfactlevs++] = r;\n\t\t    }\n\t\t  for (r = 0; r < neffrows; r++)\n\t\t    {\n\t\t      if (indep[r])\n\t\t\t{\n\t\t\t  lensq[r] = 0.0;\n\t\t\t  emsc[r] = 0.0;\n\t\t\t}\n\t\t    }\n\t\t  for (c = 0; c < ncells; c++)\n\t\t    used[c] = 0;\n\t\t  for (basecell = 0, nextcell = 0; basecell < ncells; basecell = nextcell)\n\t\t    {\n\t\t      for (r = 0; r < neffrows; r++)\n\t\t\tcum[r] = 0.0;\n\t\t      for (c = basecell; c < ncells; )\n\t\t\t{\n\t\t\t  for (r = 0; r < neffrows; r++)\n\t\t\t    {\n\t\t\t      if (indep[r])\n\t\t\t\t{\n\t\t\t\t  tmp = coeff[effrow[r]][c];\n\t\t\t\t  cum[r] += tmp;\n\t\t\t\t  lensq[r] += tmp * tmp / nobs[c];\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  used[c] = 1;\n\t\t\t  for (c++; c < ncells; c++)\n\t\t\t    {\n\t\t\t      for (s = 0, same = 1; s < nfactlevs; s++)\n\t\t\t\t{\n\t\t\t\t  if (level[factlev[s]][basecell] !=\n\t\t\t\t      level[factlev[s]][c])\n\t\t\t\t    {\n\t\t\t\t      if (nextcell == basecell &&\n\t\t\t\t\t  !used[c])\n\t\t\t\t\tnextcell = c;\n\t\t\t\t      same = 0;\n\t\t\t\t      break;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t      if (same)\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t      for (r = 0; r < neffrows; r++)\n\t\t\t{\n\t\t\t  if (indep[r])\n\t\t\t    {\n\t\t\t      cum[r] *= cum[r];\n\t\t\t      emsc[r] += cum[r];\n\t\t\t    }\n\t\t\t}\n\t\t      if (nextcell == basecell)\n\t\t\tbreak;\n\t\t    }\n\t\t  for (r = 0; r < neffrows; r++)\n\t\t    {\n\t\t      if (indep[r])\n\t\t\temsc[r] /= lensq[r];\n\t\t    }\n\t\t  for (r = 0, emscoeff[factor][u] = 0.0, df = 0.0; r < neffrows; r++)\n\t\t    {\n\t\t      if (indep[r])\n\t\t\t{\n\t\t\t  emscoeff[factor][u] += emsc[r];\n\t\t\t  df += 1.0;\n\t\t\t}\n\t\t    }\n\t\t  if (df > 0.0)\n\t\t    {\n\t\t      emscoeff[factor][u] /= df;\n\t\t      if (varv)\n\t\t\tputrand(u, emscoeff[factor][u], varv);\n\t\t    }\n\t\t  else\n\t\t    emscoeff[factor][u] = 0.0;\n\t\t}\n\t      else\n\t\temscoeff[factor][u] = 0.0;\n\t    }\n\t  if (varv)\n\t    fputs(\"\\n    1 Var(Error)\\n\", dap_lst);\n\t  factor++;\n\t}\n    }\n  dap_free(cum, \"\");\n  dap_free(effrow, \"\");\n  dap_free(factlev, \"\");\n  dap_free(emsc, \"\");\n  dap_free(lensq, \"\");\n  dap_free(used, \"\");\n  return factor;\n}",
      "lines": 157,
      "depth": 26,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "putms": {
      "start_point": [
        741,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "static void putms(int bits, double coeff, int *varv)\n{\n  int v;\n  int termn;\n\n  if (coeff != 0.0)\n    fprintf(dap_lst, \"\\n    %g MS(\", coeff);\n  if (bits)\n    {\n      for (v = 1, termn = 1; bits; bits = (bits >> 1), v++)\n\t{\n\t  if (bits & 0x1)\n\t    {\n\t      if (termn > 1)\n\t\tputc('*', dap_lst);\n\t      fputs(dap_obs[0].do_nam[varv[v]], dap_lst);\n\t      termn++;\n\t    }\n\t}\n    }\n  else if (coeff != 0.0)\n    fputs(\"Error\", dap_lst);\n  if (coeff != 0.0)\n    putc(')', dap_lst);\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emssolve": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        845,
        1
      ],
      "content": "static int emssolve(double **emscoeff, int nterms, int nfactors,\n\t\t    int *varv, int *termv)\n{\n  int r, c;\n  int maxr;\n  int subr;\n  int subc;\n  double rowmax;\n  double colmax;\n  double maxmax;\n  double tmp;\n  int itmp;\n  double mult;\n\n  emscoeff[0][0] = 1.0;\t/* for error */\n  termv[0] = 0;\n  for (r = 1; r <= nterms; r++)\n    {\n      emscoeff[0][r] = 0.0;\n      termv[r] = r;\n    }\n  for (c = 1, r = 1; c <= nfactors; c++)\n    {\n      for (colmax = 0.0, maxmax = 0.0, maxr = r, subr = r; subr <= nterms; subr++)\n\t{\n\t  for (subc = c, rowmax = 0.0; subc <= nfactors; subc++)\n\t    {\n\t      if ((tmp = fabs(emscoeff[subc][subr])) > rowmax)\n\t\trowmax = tmp;\n\t    }\n\t  if ((tmp = fabs(emscoeff[c][subr] / rowmax)) > colmax)\n\t    {\n\t      maxmax = rowmax;\n\t      colmax = tmp;\n\t      maxr = subr;\n\t    }\n\t}\n      if (colmax > dap_redtol * maxmax)\n\t{\n\t  if (maxr != r)\n\t    {\n\t      for (subc = 0; subc <= nfactors + 1; subc++)\n\t\t{\n\t\t  tmp = emscoeff[subc][r];\n\t\t  emscoeff[subc][r] = emscoeff[subc][maxr];\n\t\t  emscoeff[subc][maxr] = tmp;\n\t\t}\n\t      itmp = termv[r];\n\t      termv[r] = termv[maxr];\n\t      termv[maxr] = itmp;\n\t    }\n\t  for (subr = 0; subr <= nterms; subr++)\n\t    {\n\t      if (subr == r)\n\t\t{\n\t\t  mult = emscoeff[c][subr];\n\t\t  for (subc = c; subc <= nfactors + 1; subc++)\n\t\t    emscoeff[subc][subr] /= mult;\n\t\t}\n\t      else\n\t\t{\n\t\t  mult = emscoeff[c][subr] / emscoeff[c][r];\n\t\t  if (fabs(mult) > dap_redtol * maxmax)\n\t\t    {\n\t\t      for (subc = c; subc <= nfactors + 1; subc++)\n\t\t\t{\n\t\t\t  tmp = fabs(emscoeff[subc][subr]);\n\t\t\t  emscoeff[subc][subr] -= mult * emscoeff[subc][r];\n\t\t\t  if (fabs(emscoeff[subc][subr]) < dap_redtol * tmp)\n\t\t\t    emscoeff[subc][subr] = 0.0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  r++;\n\t}\n    }\n  return r;\n}",
      "lines": 79,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ftest1": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        1069,
        1
      ],
      "content": "static void ftest1(double **coeff, int **level, int ncells,\n\t\t   int *rterm, int ncontrasts, int nerrors,\n\t\t   double *mean, double *vari, double *nobs, int *varv,\n\t\t   char *numv, int nnum, char *denv, int nden, int typen)\n{\n  int corow;\n  int cc;\n  int cr;\n  double numer;\n  double sq;\n  double varnce;\n  double tmp;\n  double denom;\n  double modelss;\n  double n;\n  int cdfi;\n  int edfi;\n  double dedfi;\n  int *indep;\n  double sse;\n  int dfe;\n  double *emsmem;\n  double **emscoeff;\n  int nfactors;\n  int *termv;\n  int ndenterm;\n  int t;\n  double ss, ms;\n  double df;\n  double dfdown, dfup;\n  double fdown, fup;\n\n  dedfi = 0.0;\n  emsmem = NULL;\n  emscoeff = NULL;\n  ndenterm = 0;\n  ss = 0.0;\n  df = 0.0;\n  sumcheck(\"ftest1\", coeff, ncells, nerrors, ncontrasts, rterm);\n  indep = (int *) dap_malloc(sizeof(int) * (nerrors + ncontrasts), \"\");\n  if (nden)\n    {\n      emsmem = (double *) dap_malloc(sizeof(double) * 2 * ncells * ncells, \"\");\n      emscoeff = (double **) dap_malloc(sizeof(double *) * 2 * ncells, \"\");\n      for (cr = 0; cr < 2 * ncells; cr++)\n\temscoeff[cr] = emsmem + cr * ncells;\n    }\n  termv = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  denom = 0.0;\n  for (cr = 0; cr < nerrors + ncontrasts; cr++)\n    indep[cr] = 0;\n  nfactors = 0;\n  if (nerrors)\n    {\n      if (nden)\n\t{\n\t  edfi = orthog(coeff, 0, nerrors - 1, nerrors - 1,\n\t\t\tncells, nobs, indep, rterm);\n\t  nfactors = ems(coeff, level, ncells, rterm, indep,\n\t\t\t nerrors + ncontrasts,\n\t\t\t nobs, varv, denv, nden, emscoeff);\n\t}\n      else\n\t{\n\t  edfi = nerrors;\n\t  for (cr = 0; cr < nerrors; cr++)\n\t    {\n\t      for (cc = 0, sq = 0.0, varnce = 0.0; cc < ncells; cc++)\n\t\t{\n\t\t  tmp = coeff[cr][cc];\n\t\t  sq += tmp * mean[cc];\n\t\t  varnce += tmp * tmp / nobs[cc];\n\t\t}\n\t      denom += sq * sq / varnce;\n\t    }\n\t}\n    }\n  else\n    edfi = 0;\n  corow = nerrors + ncontrasts - 1;\n  for (cc = 0, n = 0.0, sse = 0.0; cc < ncells; cc++)\n    {\n      if (nobs[cc] > 0.0)\n\t{\n\t  sse += (nobs[cc] - 1.0) * vari[cc];\n\t  n += nobs[cc];\n\t}\n    }\n  dfe = ((int) n) - ncells;\n  if (nden)\n    {\n      orthog(coeff, nerrors, nerrors, corow, ncells, nobs, indep, NULL);\n      cdfi = orthog(coeff, nerrors, corow, corow, ncells, nobs, indep, rterm);\n      if (ems(coeff, level, ncells, rterm, indep, nerrors + ncontrasts,\n\t      nobs, varv, numv, nnum, emscoeff + nfactors) != 1)\n\t{\n\t  fputs(\"(ftest1) Only one one term allowed in numerator of F-test with denominator\\n\",\n\t\tdap_lst);\n\t  exit(1);\n\t}\n      ndenterm = emssolve(emscoeff, nden, nfactors, varv, termv);\n      fputs(\"Error for \", dap_lst);\n      putms(rterm[nerrors], 0.0, varv);\n      fputs(\" =\", dap_lst);\n      for (t = 0, denom = 0.0, dedfi = 0.0; t < ndenterm; t++)\n\t{\n\t  if (termv[t] != rterm[nerrors] && emscoeff[nfactors + 1][t])\n\t    {\n\t      putms(termv[t], emscoeff[nfactors + 1][t], varv);\n\t      if (termv[t])\n\t\t{\n\t\t  for (cr = 0, ss = 0.0, df = 0.0;\n\t\t       cr < nerrors + ncontrasts; cr++)\n\t\t    {\n\t\t      if (rterm[cr] == termv[t] && indep[cr])\n\t\t\t{\n\t\t\t  for (cc = 0, sq = 0.0, varnce = 0.0;\n\t\t\t       cc < ncells; cc++)\n\t\t\t    {\n\t\t\t      tmp = coeff[cr][cc];\n\t\t\t      sq += tmp * mean[cc];\n\t\t\t      varnce += tmp * tmp / nobs[cc];\n\t\t\t    }\n\t\t\t  ss += sq * sq / varnce;\n\t\t\t  df += 1.0;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  ss = sse;\n\t\t  df = (double) dfe;\n\t\t}\n\t      if (ndenterm > 1)\n\t\t{\n\t\t  ms = ss / df;\n\t\t  tmp = emscoeff[nfactors + 1][t] * ms;\n\t\t  denom += tmp;\n\t\t  dedfi += tmp * tmp / df;\n\t\t}\n\t    }\n\t}\n      putc('\\n', dap_lst);\n      if (ndenterm > 1)\n\tdedfi = denom * denom / dedfi;\n      else\n\t{\n\t  denom = emscoeff[nfactors][t] * ss;\n\t  edfi = (int) df;\n\t}\n    }\n  else\n    {\n      denom += sse;\n      cdfi = orthog(coeff, 0, corow, corow, ncells, nobs, indep, NULL) - edfi;\n      edfi += dfe;\n    }\n  for (cr = nerrors, numer = 0.0; cr <= corow; cr++)\n    {\n      if (indep[cr])\n\t{\n\t  for (cc = 0, sq = 0.0, varnce = 0.0; cc < ncells; cc++)\n\t    {\n\t      tmp = coeff[cr][cc];\n\t      sq += tmp * mean[cc];\n\t      varnce += tmp * tmp / nobs[cc];\n\t    }\n\t  numer += sq * sq / varnce;\n\t}\n    }\n  fprintf(dap_lst, \"Number of observations = %d\\n\", (int) n);\n  fprintf(dap_lst, \"H0 SS = %g, df = %d, MS = %g\\n\", numer, cdfi, numer / ((double) cdfi));\n  modelss = numer;\n  numer /= (double) cdfi;\n  if (nerrors)\n    fputs(\"Residual \", dap_lst);\n  else\n    fputs(\"Error \", dap_lst);\n  if (nden && ndenterm > 1)\n    {\n      fprintf(dap_lst, \"df = %g, MS = %g\\n\", dedfi, denom);\n      numer /= denom;\n      fprintf(dap_lst, \"F0 = %g\\n\", numer);\n      dfdown = floor(dedfi);\n      dfup = ceil(dedfi);\n      if (dfup == dfdown)\n\tfprintf(dap_lst, \"Prob[F > F0] = %.5f\\n\",\n\t\t0.00001 * (ceil(100000.0 * probf(numer, cdfi, (int) dedfi))));\n      else\n\t{\n\t  fdown = probf(numer, cdfi, (int) dfdown);\n\t  fup = probf(numer, cdfi, (int) dfup);\n\t  fprintf(dap_lst, \"Prob[F > F0] = %.5f\\n\",\n\t\t  0.00001 * (ceil(100000.0 *\n\t\t\t\t  (fdown + (dedfi - dfdown) / (dfup - dfdown) *\n\t\t\t\t   (fup - fdown)))));\n\t}\n    }\n  else\n    {\n      dedfi = (double) edfi;\n      fprintf(dap_lst, \"SS = %g, df = %d, MS = %g\\n\", denom, edfi, denom / dedfi);\n      if (ncontrasts + nerrors == ncells - 1)\n\tfprintf(dap_lst, \"R-sq = %g\\n\", modelss / (modelss + denom));\n      denom /= dedfi;\n      numer /= denom;\n      fprintf(dap_lst, \"F0 = %g\\nProb[F > F0] = %.5f\\n\",\n\t      numer, 0.00001 * (ceil(100000.0 * probf(numer, cdfi, edfi))));\n    }\n  strcpy(dap_obs[0].do_str[typen], \"MSERROR\");\n  dap_obs[0].do_dbl[varv[0]] = denom;\n  output();\n  strcpy(dap_obs[0].do_str[typen], \"ERRORDF\");\n  dap_obs[0].do_dbl[varv[0]] = dedfi;\n  output();\n  if (nden)\n    {\n      dap_free(emsmem, \"\");\n      dap_free(emscoeff, \"\");\n    }\n  dap_free(indep, \"\");\n  dap_free(termv, \"\");\n}",
      "lines": 223,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "puttest": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "static void puttest(char *testv, int ntest, int *varv, int nvars)\n{\n  int t;\n  int v;\n  int bits;\n  int first;\n\n  for (t = 1; t <= ntest; t++)\n    {\n      if (testv[t] == 'c' || testv[t] == 'n')\n\t{\n\t  for (bits = t, v = 1, first = 1; v < nvars; bits = (bits >> 1), v++)\n\t    {\n\t      if (bits & 0x1)\n\t\t{\n\t\t  if (first)\n\t\t    {\n\t\t      putc(' ', dap_lst);\n\t\t      first = 0;\n\t\t    }\n\t\t  else\n\t\t    putc('*', dap_lst);\n\t\t  fprintf(dap_lst, \"%s\", dap_obs[0].do_nam[varv[v]]);\n\t\t}\n\t    }\n\t}\n    }\n  putc('\\n', dap_lst);\n}",
      "lines": 29,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ftest": {
      "start_point": [
        1101,
        0
      ],
      "end_point": [
        1438,
        1
      ],
      "content": "void ftest(char *fname, char *variables, char *numerator, char *denominator, char *marks)\n{\n  char *tstname; /* fname with .tst appended */\n  int typen; /* index of _type_ variable */\n  int termn; /* index of _term_ variable */\n  int *varv; /* vector of indices of variables */\n  int nvars; /* number of variables */\n  int *markv; /* vector of indices of partitioning variables */\n  int nmark; /* number of partitioning variables */\n  int *rterm;\n  int nnum;\n  int nden;\n  char *numv; /* numerator term vector */\n  char *denv; /* denominator term vector */\n  int num;\n  int den;\n  int t;\n  int morecells;\n  int more; /* for stepping through dataset: got one more line? */\n  int statn;\n  int gotm, gotn, gotv; /* got mean? got n? got variance? */\n  char *levmem; /* memory for level names */\n  char **levptr; /* pointers for setting up array */\n  char ***levval; /* array of level values */\n  int *nlevels;\n  int *levelmem; /* memory for storing treatment level numbers */\n  int **level; /* array of treatment level numbers */\n  int v;\n  int l;\n  double *comem;\n  double **coeff;\n  double *mean;\n  double *nobs;\n  double *vari;\n  int ncells;\n  int ncontrasts;\n  int nerrors;\n  int err;\n  int con;\n\n  varv = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  rterm = (int *) dap_malloc(sizeof(int) * (dap_maxcell - 1), \"\");\n  numv = dap_malloc(dap_maxcell, \"\");\n  denv = dap_malloc(dap_maxcell, \"\");\n  levmem = dap_malloc((dap_maxtreat + 1) * dap_maxlev * (dap_strlen + 1), \"\");\n  levptr = (char **) dap_malloc(sizeof(char *) * (dap_maxtreat + 1) * dap_maxlev, \"\");\n  levval = (char ***) dap_malloc(sizeof(char **) * (dap_maxtreat + 1), \"\");\n  for (v = 0; v < dap_maxtreat + 1; v++)\n    {\n      levval[v] = levptr + v * dap_maxlev;\n      for (l = 0; l < dap_maxlev; l++)\n\tlevval[v][l] = levmem + v * dap_maxlev * (dap_strlen + 1) +\n\t  l * (dap_strlen + 1);\n    }\n  nlevels = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"\");\n  levelmem = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1) * dap_maxcell, \"\");\n  level = (int **) dap_malloc(sizeof(int *) * (dap_maxtreat + 1), \"\");\n  for (v = 0; v < dap_maxtreat + 1; v++)\n    level[v] = levelmem + v * dap_maxcell;\n  comem = (double *) dap_malloc(sizeof(double) * dap_maxcell * dap_maxcell, \"dap_maxcell\");\n  coeff = (double **) dap_malloc(sizeof(double *) * dap_maxcell, \"dap_maxcell\");\n  for (ncells = 0; ncells < dap_maxcell; ncells++)\n    coeff[ncells] = comem + ncells * dap_maxcell;\n  mean = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  nobs = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  vari = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  if (!fname)\n    {\n      fputs(\"(ftest) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  tstname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(tstname, fname, \"<tst\");\n  inset(fname);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(ftest) no _type_ variable\\n\");\n      exit(1);\n    }\n  if ((termn = dap_varnum(\"_term_\")) < 0)\n    {\n      fprintf(dap_err, \"(ftest) no _term_ variable\\n\");\n      exit(1);\n    }\n  if (!variables || !variables[0])\n    {\n      fputs(\"(ftest) No variables given.\\n\", dap_err);\n      exit(1);\n    }\n  nvars = dap_list(variables, varv, dap_maxtreat + 1);\n  if (dap_obs[0].do_len[varv[0]] != DBL)\n    {\n      fprintf(dap_err, \"(ftest) response variable %s must be of type double\\n\",\n\t      dap_obs[0].do_nam[varv[0]]);\n      exit(1);\n    }\n  for (v = 1; v < nvars; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] <= 0)\n\t{\n\t  fprintf(dap_err, \"(ftest) classification variable %s must be string\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n    }\n  outset(tstname, \"\");\n  if (numerator && numerator[0])\n    {\n      nnum = testparse(numerator, numv, varv, nvars);\n      num = 1;\n    }\n  else\n    {\n      num = 0;\n      nnum = 0;\n      for (t = 1; t < dap_maxcell; t++)\n\tnumv[t] = 'e';\n    }\n  if (denominator && denominator[0])\n    {\n      nden = testparse(denominator, denv, varv, nvars);\n      /* take numerator terms out of denominator */\n      for (t = 1; t <= nnum; t++)\n\t{\n\t  if (numv[t] == 'c')\n\t    denv[t] = 'e';\n\t}\n      for (t = 1; t <= nden; t++)\n\t{\n\t  if (denv[t] != 'e')\n\t    {\n\t      den = 1;\n\t      break;\n\t    }\n\t}\n      if (t > nden)\n\t{\n\t  den = 0;\n\t  nden = 0;\n\t  while (t < dap_maxcell)\n\t    denv[t++] = 'e';\n\t}\n    }\n  else\n    {\n      den = 0;\n      nden = 0;\n      for (t = 1; t < dap_maxcell; t++)\n\tdenv[t] = 'e';\n    }\n  for (v = 1; v < nvars; v++)\n    {\n      nlevels[v] = 0;\n      for (l = 0; l < dap_maxlev; l++)\n\tlevval[v][l][0] = '\\0';\n    }\n  nmark = dap_list(marks, markv, dap_maxvar);\n  for (ncells = 0, ncontrasts = 0, nerrors = 0,\n\t more = step(), morecells = 1; morecells; ncells++)\n    {\n      gotn = 0;\n      gotm = 0;\n      gotv = 0;\n      morecells = more;\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  if (num)\n\t    fprintf(dap_lst, \"Testing Ho: %s\\n\", numerator);\n\t  else if (nnum > 0)\n\t    {\n\t      fputs(\"Testing Ho:\", dap_lst);\n\t      puttest(numv, nnum, varv, nvars);\n\t    }\n\t  if (den)\n\t    fprintf(dap_lst, \"Denominator: %s\\n\", denominator);\n\t  else if (nden > 0)\n\t    {\n\t      fputs(\"Denominator:\", dap_lst);\n\t      puttest(denv, nden, varv, nvars);\n\t    }\n\t  ftest1(coeff, level, ncells, rterm, ncontrasts, nerrors,\n\t\t mean, vari, nobs, varv, numv, num * nnum, denv, den * nden, typen);\n\t  dap_swap();\n\t  for (v = 1; v < nvars; v++)\n\t    {\n\t      nlevels[v] = 0;\n\t      for (l = 0; l < dap_maxlev; l++)\n\t\tlevval[v][l][0] = '\\0';\n\t    }\n\t  ncells = 0;\n\t  ncontrasts = 0;\n\t  nerrors = 0;\n\t}\n      for (statn = 0; more; )\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"N\"))\n\t    {\n\t      nobs[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotn = 1;\n\t      output();\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"MEAN\"))\n\t    {\n\t      mean[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotm = 1;\n\t      output();\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"VAR\"))\n\t    {\n\t      vari[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotv = 1;\n\t      output();\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(ftest) Bad cell statistic: %s\\n\",\n\t\t      dap_obs[0].do_str[typen]);\n\t      exit(1);\n\t    }\n\t  if (++statn < 3)\n\t    more = step();\n\t  else\n\t    {\n\t      if (nobs[ncells] == 1.0)\n\t\tvari[ncells] = 0.0;\n\t      break;\n\t    }\n\t}\n      if (more)\n\t{\n\t  if (!gotm)\n\t    {\n\t      fputs(\"(ftest) Missing MEAN.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  if (!gotn)\n\t    {\n\t      fputs(\"(ftest) Missing N.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  if (!gotv)\n\t    {\n\t      fputs(\"(ftest) Missing VAR.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  for (v = 1; v < nvars; v++)\n\t    level[v][ncells] = levn(dap_obs[0].do_str[varv[v]], levval[v], &nlevels[v]);\n\t}\n      for (dap_mark(), nerrors = 0; more; )\n\t{\n\t  more = step();\n\t  err = !strcmp(dap_obs[0].do_str[typen], \"ERROR\");\n\t  con = !strcmp(dap_obs[0].do_str[typen], \"CONTR\");\n\t  if (den && err)\n\t    dap_mark();\n\t  if (err || (den && con))\n\t    {\n\t      t = dap_obs[0].do_int[termn];\n\t      rterm[nerrors] = t;\n\t      if (!den)\n\t\t{\n\t\t  denv[t] = 'c';\n\t\t  if (nden < t)\n\t\t    nden = t;\n\t\t}\n\t      if (denv[t] == 'c' || denv[t] == 'n')\n\t\t{\n\t\t  coeff[nerrors][ncells] = dap_obs[0].do_dbl[varv[0]];\n\t\t  nerrors++;\n\t\t  output();\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (den)\n\t\t{\n\t\t  dap_rewind();\n\t\t  more = step();\n\t\t}\n\t      break;\n\t    }\n\t}\n      for (ncontrasts = 0; more; more = step())\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"CONTR\"))\n\t    {\n\t      t = dap_obs[0].do_int[termn];\n\t      rterm[nerrors + ncontrasts] = t;\n\t      if (!num)\n\t\t{\n\t\t  numv[t] = 'c';\n\t\t  if (nnum < t)\n\t\t    nnum = t;\n\t\t}\n\t      if (numv[t] == 'c' || numv[t] == 'n')\n\t\t{\n\t\t  coeff[nerrors + ncontrasts][ncells] =\n\t\t    dap_obs[0].do_dbl[varv[0]];\n\t\t  ncontrasts++;\n\t\t}\n\t    }\n\t  else\n\t    break;\n\t}\n      while (more)\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"LSMEAN\"))\n\t    {\n\t      t = dap_obs[0].do_int[termn];\n\t      if (t <= nnum && (numv[t] == 'c' || numv[t] == 'n'))\n\t\toutput();\n\t    }\n\t  else\n\t    break;\n\t  more = step();\n\t}\n    }\n  dap_free(comem, \"\");\n  dap_free(coeff, \"\");\n  dap_free(tstname, \"\");\n  dap_free(varv, \"\");\n  dap_free(markv, \"\");\n  dap_free(rterm, \"\");\n  dap_free(numv, \"\");\n  dap_free(denv, \"\");\n  dap_free(levmem, \"\");\n  dap_free(levptr, \"\");\n  dap_free(levval, \"\");\n  dap_free(nlevels, \"\");\n  dap_free(levelmem, \"\");\n  dap_free(level, \"\");\n  dap_free(mean, \"\");\n  dap_free(nobs, \"\");\n  dap_free(vari, \"\");\n}",
      "lines": 338,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "putlev": {
      "start_point": [
        1440,
        0
      ],
      "end_point": [
        1456,
        1
      ],
      "content": "static void putlev(int *nlevels, int *varv, int nvars, char ***levval)\n{\n  int v;\n  int l;\n\n  fprintf(dap_lst, \"Response variable: %s\\n\\n\", dap_obs[0].do_nam[varv[0]]);\n  fprintf(dap_lst, \"%-15s Levels\\n\", \"Treatment\");\n  fprintf(dap_lst, \"%-15s ------\\n\", \"--------\");\n  for (v = 1; v < nvars; v++)\n    {\n      fprintf(dap_lst, \"%-15s\", dap_obs[0].do_nam[varv[v]]);\n      for (l = 0; l < nlevels[v]; l++)\n\tfprintf(dap_lst, \" %s\", levval[v][l]);\n      putc('\\n', dap_lst);\n    }\n  putc('\\n', dap_lst);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "maketerm": {
      "start_point": [
        1458,
        0
      ],
      "end_point": [
        1600,
        1
      ],
      "content": "static void maketerm(int nterm, char *termv, int nvars, int *varv,\n\t\t     int *nlevels, double **coeff, int ncells, double *nobs,\n\t\t     int *rterm, int *nrows, int **clevel)\n{\n  char termtype[4] = \"ecc\";\n  int tt;\n  int tn;\n  int *nest;\n  int reset;\t/* = 1 for error and contrasts, 0 for lsmeans */\n  int r, c;\n  int row;\n  int *iv;\n  int ivn;\n  int ntreat;\n  int *rlevel;\n  int bits;\n  double prod;\n  int vn;\n  int nextr;\n  int *change;\n  int nbits;\n\n  row = 0;\n  nest = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  iv = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  rlevel = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  change = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  for (tn = 1; tn <= nterm; tn++)\n    nest[tn] = tn;\n  for (tn = 0x1; tn <= nterm; tn = (tn << 1))\n    {\n      if (termv[tn] == 'e')\n\t{\n\t  for (tt = 1, bits = 0; tt <= nterm; tt++)\n\t    {\n\t      if (tt != tn && (tt & tn) == tn && termv[tt] == 'c')\n\t\t{\n\t\t  if (bits)\n\t\t    bits &= tt;\n\t\t  else\n\t\t    bits = tt;\n\t\t}\n\t    }\n\t  if (bits && bits != tn)\n\t    {\n\t      for (tt = 1; tt <= nterm; tt++)\n\t\t{\n\t\t  if ((tt & tn) == tn)\n\t\t    {\n\t\t      if (termv[tt] == 'e')\n\t\t\t{\n\t\t\t  nbits = (tt | bits);\n\t\t\t  termv[tt] = 'n';\n\t\t\t  nest[tt] = nbits;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n  for (vn = 1, c = 0; vn < nvars; vn++)\n    clevel[vn][c] = 0;\n  for (c++; c < ncells; c++)\n    {\n      for (vn = 1; vn < nvars; vn++)\n\tclevel[vn][c] = clevel[vn][c - 1];\n      for (vn = nvars - 1; vn >= 0; --vn)\n\t{\n\t  if (++clevel[vn][c] == nlevels[vn])\n\t    clevel[vn][c] = 0;\n\t  else\n\t    break;\n\t}\n    }\n  for (tt = 0, r = 0; tt < 3; tt++)\n    {\n      reset = (tt < 2);\n      for (tn = 1, nrows[tt] = 0; tn <= nterm; tn++)\n\t{\n\t  if (termv[tn] == termtype[tt] ||\n\t      (termv[tn] == 'n' && termtype[tt] == 'c'))\n\t    {\n\t      bits = tn;\n\t      for (ntreat = 0, vn = 1; vn < nvars; vn++, bits = (bits >> 1))\n\t\t{\n\t\t  if (bits & 0x1)\n\t\t    iv[ntreat++] = vn;\n\t\t}\n\t      for (c = 0, vn = nvars - 1; vn > 0; )\n\t\t{\n\t\t  for (ivn = 0; ivn < ntreat; ivn++)\n\t\t    rlevel[ivn] = reset;\n\t\t  for (row = 0, ivn = 0; ivn < ntreat; )\n\t\t    {\n\t\t      if (tt < 2)\n\t\t\t{\n\t\t\t  for (ivn = 0, prod = 1.0; ivn < ntreat;\n\t\t\t       ivn++)\n\t\t\t    {\n\t\t\t      if (clevel[iv[ivn]][c] == 0)\n\t\t\t\t;\n\t\t\t      else if (clevel[iv[ivn]][c] ==\n\t\t\t\t       rlevel[ivn])\n\t\t\t\tprod = -prod;\n\t\t\t      else\n\t\t\t\t{\n\t\t\t\t  prod = 0.0;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t  coeff[r + row][c] = prod;\n\t\t\t  row++;\n\t\t\t}\n\t\t      else if (ntreat == 1)\n\t\t\t{\n\t\t\t  if (clevel[iv[ivn]][c] ==\n\t\t\t      rlevel[ivn])\n\t\t\t    coeff[r + row][c] = 1.0;\n\t\t\t  else\n\t\t\t    coeff[r + row][c] = 0.0;\n\t\t\t  row++;\n\t\t\t}\n\t\t      for (ivn = 0; ivn < ntreat; ivn++)\n\t\t\t{\n\t\t\t  if (++rlevel[ivn] == nlevels[iv[ivn]])\n\t\t\t    rlevel[ivn] = reset;\n\t\t\t  else\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t  if (++c == ncells)\n\t\t    break;\n\t\t}\n\t      for (nextr = r + row; r < nextr; r++, nrows[tt]++)\n\t\trterm[r] = nest[tn];\n\t    }\n\t}\n    }\n  dap_free(nest, \"\");\n  dap_free(iv, \"\");\n  dap_free(rlevel, \"\");\n  dap_free(change, \"\");\n}",
      "lines": 143,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmpstr": {
      "start_point": [
        1602,
        0
      ],
      "end_point": [
        1605,
        1
      ],
      "content": "static int cmpstr(char **s1, char **s2)\n{\n  return strcmp(*s1, *s2);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eff1": {
      "start_point": [
        1607,
        0
      ],
      "end_point": [
        1856,
        1
      ],
      "content": "static void eff1(int incells, char ***levval, int *nlevels,\n\t\t int *varv, int nvars, char *termv, int nterm, int typen, int termn)\n{\n  double *comem;\n  double **coeff;\n  int v;\n  int ncells;\n  int celli;\n  int *level;\n  int *clevmem;\n  int **clevel;\n  int statn;\n  double nobs1;\n  double mean1;\n  double vari1;\n  int gotn, gotm, gotv;\n  double *nobs;\n  double *mean;\n  double *vari;\n  int celln;\n  int sumlev;\n  int miss;\n  int *rterm;\n  int *indep;\n  int *nonz;\n  int nrows[3];\t/* nrows[0] = nerrors, nrows[1] = ncontrasts, nrows[2] = lsmeans */\n  int r;\n  int errow;\n  int corow;\n  int cr;\n  double max;\n  double tmp;\n  int (*scmp)();\n\n  nobs1 = 0.0;\n  mean1 = 0.0;\n  vari1 = 0.0;\n  scmp = &cmpstr;\n  level = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  for (v = 1; v < nvars; v++)\n    qsort(levval[v], nlevels[v], sizeof(char *), scmp);\n  for (v = 1, ncells = 1, sumlev = 0; v < nvars; v++)\n    {\n      ncells *= nlevels[v];\n      sumlev += nlevels[v];\n      level[v] = 0;\n    }\n  clevmem = (int *) dap_malloc(sizeof(int) * nvars * ncells, \"\");\n  clevel = (int **) dap_malloc(sizeof(int *) * nvars, \"\");\n  for (v = 0; v < nvars; v++)\n    clevel[v] = clevmem + v * ncells;\n  nobs = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  mean = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  vari = (double *) dap_malloc(sizeof(double) * ncells, \"\");\n  rterm = (int *) dap_malloc(sizeof(int) * (ncells + sumlev - 1), \"\");\n  indep = (int *) dap_malloc(sizeof(int) * (ncells + sumlev - 1), \"\");\n  nonz = (int *) dap_malloc(sizeof(int) * (ncells + sumlev - 1), \"\");\n  comem = (double *) dap_malloc(sizeof(double) * (ncells + sumlev) * ncells, \"\");\n  coeff = (double **) dap_malloc(sizeof(double *) * (ncells + sumlev), \"\");\n  for (r = 0; r < ncells + sumlev; r++)\n    coeff[r] = comem + r * ncells;\n  for (celli = 0, celln = 0; celli < incells; celli++, celln++)\n    {\n      gotn = 0;\n      gotm = 0;\n      gotv = 0;\n      for (statn = 0; statn < 3; statn++)\n\t{\n\t  step();\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"N\"))\n\t    {\n\t      nobs1 = dap_obs[0].do_dbl[varv[0]];\n\t      gotn = 1;\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"MEAN\"))\n\t    {\n\t      mean1 = dap_obs[0].do_dbl[varv[0]];\n\t      gotm = 1;\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"VAR\"))\n\t    {\n\t      vari1 = dap_obs[0].do_dbl[varv[0]];\n\t      gotv = 1;\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(eff1) Bad cell statistic: %s\\n\",\n\t\t      dap_obs[0].do_str[typen]);\n\t      exit(1);\n\t    }\n\t}\n      if (!gotn)\n\t{\n\t  fputs(\"(eff1) Missing N.\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (!gotm)\n\t{\n\t  fputs(\"(eff1) Missing MEAN.\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (!gotv)\n\t{\n\t  fputs(\"(eff1) Missing VAR.\\n\", dap_err);\n\t  exit(1);\n\t}\n      do\t{\n\tfor (v = 1, miss = 0; v < nvars; v++)\n\t  {\n\t    if (strcmp(dap_obs[0].do_str[varv[v]],\n\t\t       levval[v][level[v]]))\n\t      {\n\t\tmiss = 1;\n\t\tbreak;\n\t      }\n\t  }\n\tif (miss)\n\t  {\n\t    nobs[celln] = 0.0;\n\t    mean[celln] = 0.0;\n\t    vari[celln] = 0.0;\n\t    celln++;\n\t    for (v = nvars - 1; v > 0; --v)\n\t      {\n\t\tif (++level[v] == nlevels[v])\n\t\t  level[v] = 0;\n\t\telse\n\t\t  break;\n\t      }\n\t  }\n      } while (miss);\n      nobs[celln] = nobs1;\n      mean[celln] = mean1;\n      if (nobs1 > 1.0)\n\tvari[celln] = vari1;\n      else\n\tvari[celln] = 0.0;\n      for (v = nvars - 1; v > 0; --v)\n\t{\n\t  if (++level[v] == nlevels[v])\n\t    level[v] = 0;\n\t  else\n\t    break;\n\t}\n    }\n  while (celln < ncells)\n    {\n      nobs[celln] = 0.0;\n      mean[celln] = 0.0;\n      vari[celln] = 0.0;\n      celln++;\n    }\n  maketerm(nterm, termv, nvars, varv, nlevels, coeff, ncells, nobs, rterm, nrows, clevel);\n  for (cr = 0; cr < nrows[0] + nrows[1] + nrows[2]; cr++)\n    indep[cr] = 0;\n  if (nrows[0])\n    {\n      errow = rowred(coeff, rterm, 0, ncells, nobs,\n\t\t     nrows[0] - 1, nrows[0] - 1, NULL);\n      if (errow < nrows[0])\n\torthog(coeff, nrows[0] - 1, errow, 0, ncells, nobs, indep, NULL);\n      corow = rowred(coeff, rterm, 0, ncells, nobs,\n\t\t     nrows[0] - 1, nrows[0] + nrows[1] + nrows[2] - 1, nonz);\n      if (corow < nrows[0])\n\tcorow = nrows[0];\n    }\n  else\n    {\n      errow = 0;\n      corow = nrows[0];\n    }\n  for (v = 1; v < nvars; v++)\n    level[v] = 0;\n  for (r = 0, max = 0.0; r < nrows[0] + nrows[1] + nrows[2]; r++)\n    for (celln = 0; celln < ncells; celln++)\n      {\n\tif ((tmp = fabs(coeff[r][celln])) > max)\n\t  max = tmp;\n      }\n  for (r = 0; r < nrows[0] + nrows[1] + nrows[2]; r++)\n    for (celln = 0; celln < ncells; celln++)\n      {\n\tif (fabs(coeff[r][celln]) < dap_zerotol * max)\n\t  coeff[r][celln] = 0.0;\n      }\n  for (celln = 0; celln < ncells; celln++)\n    {\n      if (nobs[celln])\n\t{\n\t  dap_obs[0].do_int[termn] = 0;\n\t  for (v = 1; v < nvars; v++)\n\t    strcpy(dap_obs[0].do_str[varv[v]], levval[v][level[v]]);\n\t  strcpy(dap_obs[0].do_str[typen], \"N\");\n\t  dap_obs[0].do_dbl[varv[0]] = nobs[celln];\n\t  output();\n\t  strcpy(dap_obs[0].do_str[typen], \"MEAN\");\n\t  dap_obs[0].do_dbl[varv[0]] = mean[celln];\n\t  output();\n\t  strcpy(dap_obs[0].do_str[typen], \"VAR\");\n\t  dap_obs[0].do_dbl[varv[0]] = vari[celln];\n\t  output();\n\t  for (r = errow; r < nrows[0]; r++)\n\t    {\n\t      if (indep[r])\n\t\t{\n\t\t  dap_obs[0].do_dbl[varv[0]] = coeff[r][celln];\n\t\t  strcpy(dap_obs[0].do_str[typen], \"ERROR\");\n\t\t  dap_obs[0].do_int[termn] = rterm[r];\n\t\t  output();\n\t\t}\n\t    }\n\t  for (r = corow; r < nrows[0] + nrows[1]; r++)\n\t    {\n\t      if (!nrows[0] || nonz[r])\n\t\t{\n\t\t  dap_obs[0].do_dbl[varv[0]] = coeff[r][celln];\n\t\t  strcpy(dap_obs[0].do_str[typen], \"CONTR\");\n\t\t  dap_obs[0].do_int[termn] = rterm[r];\n\t\t  output();\n\t\t}\n\t    }\n\t  strcpy(dap_obs[0].do_str[typen], \"LSMEAN\");\n\t  while (r < nrows[0] + nrows[1] + nrows[2])\n\t    {\n\t      dap_obs[0].do_int[termn] = rterm[r];\n\t      dap_obs[0].do_dbl[varv[0]] = coeff[r][celln];\n\t      output();\n\t      r++;\n\t    }\n\t}\n      for (v = nvars - 1; v > 0; --v)\n\t{\n\t  if (++level[v] == nlevels[v])\n\t    level[v] = 0;\n\t  else\n\t    break;\n\t}\n    }\n  dap_free(comem, \"\");\n  dap_free(coeff, \"\");\n  dap_free(level, \"\");\n  dap_free(clevmem, \"\");\n  dap_free(clevel, \"\");\n  dap_free(nobs, \"\");\n  dap_free(mean, \"\");\n  dap_free(vari, \"\");\n  dap_free(rterm, \"\");\n  dap_free(indep, \"\");\n  dap_free(nonz, \"\");\n}",
      "lines": 250,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "effects": {
      "start_point": [
        1858,
        0
      ],
      "end_point": [
        1998,
        1
      ],
      "content": "void effects(char *fname, char *varlist, char *model, char *marks)\n{\n  char *conname;\n  char *outlist;\n  int *varv;\n  int nvars;\n  int *markv;\n  int nmark;\n  int typen;\n  int termn;\n  char *termv;\n  int nterm;\n  char *levmem;\n  char **levptr;\n  char ***levval;\n  int *nlevels;\n  int incells;\n  int v;\n  int l;\n  int more;\n\n  conname = dap_malloc(strlen(fname) + 5, fname);\n  outlist = dap_malloc(strlen(varlist) + strlen(marks) + 9, \"\");\n  varv = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  termv = dap_malloc(dap_maxcell, \"dap_maxcell\");\n  levmem = dap_malloc((dap_maxtreat + 1) * dap_maxlev * (dap_strlen + 1),\n\t\t      \"dap_maxtreat, dap_maxlev, dap_strlen\");\n  levptr = (char **) dap_malloc(sizeof(char *) * (dap_maxtreat + 1) * dap_maxlev,\n\t\t\t\t\"dap_maxtreat, dap_maxlev\");\n  levval = (char ***) dap_malloc(sizeof(char **) * (dap_maxtreat + 1),\n\t\t\t\t \"dap_maxtreat\");\n  for (v = 0; v < dap_maxtreat + 1; v++)\n    {\n      levval[v] = levptr + v * dap_maxlev;\n      for (l = 0; l < dap_maxlev; l++)\n\tlevval[v][l] = levmem + v * dap_maxlev * (dap_strlen + 1) +\n\t  l * (dap_strlen + 1);\n    }\n  nlevels = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  if (!fname)\n    {\n      fputs(\"(effects) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  dap_suffix(conname, fname, \".con\");\n  inset(fname);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fputs(\"(effects) no _type_ variable\\n\", dap_err);\n      exit(1);\n    }\n  termn = dap_vd(\"_term_ 0\", 0);\n  nvars = dap_list(varlist, varv, dap_maxtreat + 1);\n  if (nvars > dap_maxtreat + 1)\n    {\n      fprintf(dap_err, \"(effects) too many variables in model: %s\\n\", model);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[varv[0]] != DBL)\n    {\n      fprintf(dap_err, \"(effects) response variable %s must be of type double\\n\",\n\t      dap_obs[0].do_nam[varv[0]]);\n      exit(1);\n    }\n  for (v = 1; v < nvars; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] <= 0)\n\t{\n\t  fprintf(dap_err, \"(effects) classification variable %s must be string\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n    }\n  nterm = testparse(model, termv, varv, nvars);\n  nmark = dap_list(marks, markv, dap_maxvar);\n  strcpy(outlist, varlist);\n  strcat(outlist, \" _term_\");\n  if (nmark)\n    {\n      strcat(outlist, \" \");\n      strcat(outlist, marks);\n    }\n  outset(conname, outlist);\n  for (v = 1; v < nvars; v++)\n    {\n      nlevels[v] = 0;\n      for (l = 0; l < dap_maxlev; l++)\n\tlevval[v][l][0] = '\\0';\n    }\n  dap_mark();\n  for (more = 1, incells = 0; more; incells++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  dap_swap();\n\t  dap_rewind();\n\t  putlev(nlevels, varv, nvars, levval);\n\t  eff1(incells, levval, nlevels, varv, nvars, termv, nterm, typen, termn);\n\t  for (v = 1; v < nvars; v++)\n\t    {\n\t      nlevels[v] = 0;\n\t      for (l = 0; l < dap_maxlev; l++)\n\t\tlevval[v][l][0] = '\\0';\n\t    }\n\t  incells = 0;\n\t  dap_mark();\n\t  more = step();\n\t}\n      if (more)\n\t{\n\t  for (v = 1; v < nvars; v++)\n\t    levn(dap_obs[0].do_str[varv[v]], levval[v], &nlevels[v]);\n\t  if (!step() || !step())\n\t    {\n\t      fprintf(dap_err, \"(effects) Incomplete cell statistics for: \");\n\t      for (v = 1; v < nvars; v++)\n\t\t{\n\t\t  fprintf(dap_err, \"%s (%s) \",\n\t\t\t  dap_obs[0].do_nam[varv[v]], dap_obs[0].do_str[varv[v]]);\n\t\t}\n\t      putc('\\n', dap_err);\n\t      exit(1);\n\t    }\n\t}\n    }\n  if (model && model[0])\n    ftest(conname, varlist, \"\", \"\", marks);\n  dap_free(conname, \"\");\n  dap_free(outlist, \"\");\n  dap_free(varv, \"\");\n  dap_free(markv, \"\");\n  dap_free(termv, \"\");\n  dap_free(levval, \"\");\n  dap_free(nlevels, \"\");\n  dap_free(levmem, \"\");\n  dap_free(levptr, \"\");\n}",
      "lines": 141,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "lsmeans1": {
      "start_point": [
        2002,
        0
      ],
      "end_point": [
        2310,
        1
      ],
      "content": "static void lsmeans1(\n\t\t     int methn,\t/* method: TUKEY=0, LSD=1, DUNNETT=2 */\n\t\t     double alpha,\t/* p-value at which to compare LS means */\n\t\t     double **coeff,\t/* matrix of coefficients (?) */\n\t\t     int ncells,\t/* number of cells = number of columns of coeff matrix */\n\t\t     double err,\t/* ms error (?) */\n\t\t     double dedfi,\t/* error degrees of freedom (?), as double */\n\t\t     int nerrors,\t/* number of error lines (?) in coeff matrix */\n\t\t     int nlsmeans,\t/* number of LS means lines (?) in coeff matrix */\n\t\t     double *mean,\t/* array of means for cells */\n\t\t     double *vari,\t/* array of variances for cells */\n\t\t     double *nobs,\t/* array of numbers of observations for cells */\n\t\t     int nlevels,\t/* number of levels of treatment */\n\t\t     char **levval,\t/* strings for levels of treatment */\n\t\t     int respn,\t/* index of response variable in dataobs array */\n\t\t     int treatn,\t/* index of treatment variable in dataobs array */\n\t\t     int resp2n,\t/* index of copy of response variable in dataobs array */\n\t\t     int treat2n,\t/* index of copy of treatment variable in dataobs array */\n\t\t     int typen,\t/* index of _type_ variable in dataobs array */\n\t\t     int statn,\t/* index of statistic in dataobs array */\n\t\t     int lsm1,\t/* index of LS means row variable in dataobs array */\n\t\t     int lsm2\t/* index of LS means col variable in dataobs array */\n\t\t     )\n{\n  int l1, l2;\t/* indices to arrays for levels */\n  int lsrow;\n  double tmp;\n  double n;\n  int cr, cc;\t/* row and column of coeff matrix */\n  int *indep;\t/* flags for linearly independent rows */\n  double sumwt;\n  double *lsmean;\t/* array of LS means */\n  double *effinvn;\n  double effin;\n  double *diffmem;\t/* memory allocation for diff array */\n  double **diff;\t/* array of differences between LS means for levels */\n  double *probmem;\t/* memory allocation for prob array */\n  double **prob;\t/* array of probability values for LS means comparisons */\n  double pt, pr;\t/* for computing probability points: pt = point, pr = probability */\n  int edfi;\t/* error degrees of freedom, as integer */\n  double dfdown, dfup;\t/* round down (resp. up) of degrees of freedom */\n  double pdown, pup;\t/* round down (resp. up) of probability values */\n\n  pt = 0.0;\n  dap_swap();\t/* get back to part just ended */\n  /* array allocations and pointer setup */\n  indep = (int *) dap_malloc(sizeof(int) * ncells, \"\");\n  lsmean = (double *) dap_malloc(sizeof(double) * nlevels, \"\");\n  effinvn = (double *) dap_malloc(sizeof(double) * nlevels, \"\");\n  diffmem = (double *) dap_malloc(sizeof(double) * nlevels * nlevels, \"\");\n  probmem = (double *) dap_malloc(sizeof(double) * nlevels * nlevels, \"\");\n  diff = (double **) dap_malloc(sizeof(double *) * nlevels, \"\");\n  prob = (double **) dap_malloc(sizeof(double *) * nlevels, \"\");\n  for (l1 = 0; l1 < nlevels; l1++)\n    {\n      diff[l1] = diffmem + l1 * nlevels;\n      prob[l1] = probmem + l1 * nlevels;\n    }\n  /* end array allocations and pointer setup */\n\n  /* check that row sums for error terms in coeff array are zero */\n  sumcheck(\"lsmeans1\", coeff, ncells, nerrors, 0, NULL);\n  for (cr = 0; cr < nerrors + nlsmeans; cr++)\n    indep[cr] = 0;\n\n  /* orthogonalize the coefficient matrix, return number of independent rows */\n  lsrow = orthog(coeff, 0, nerrors + nlevels - 1, nerrors + nlevels - 1,\n\t\t ncells, nobs, indep, NULL);\n  if (lsrow - nerrors != nlevels)\n    {\n      fprintf(dap_err,\n\t      \"(lsmeans1) Number of independent LS means %d differs from number of levels %d\\n\",\n\t      lsrow - nerrors, nlevels);\n      exit(1);\n    }\n\n  /* compute total number of observations */\n  for (cc = 0, n = 0.0; cc < ncells; cc++)\n    n += nobs[cc];\n\n  /* compute LS means and effective reciprocal of number of observations for each level */\n  for (l1 = 0, effin = 0.0; l1 < nlevels; l1++)\n    {\n      for (cc = 0, lsmean[l1] = 0.0, effinvn[l1] = 0.0, sumwt = 0.0; cc < ncells; cc++)\n\t{\n\t  tmp = coeff[nerrors + l1][cc];\n\t  lsmean[l1] += tmp * mean[cc];\n\t  sumwt += tmp;\n\t  effinvn[l1] += tmp * tmp / nobs[cc];\n\t}\n      lsmean[l1] /= sumwt;\n      effinvn[l1] /= (sumwt * sumwt);\n      effin += effinvn[l1];\n    }\n  effin /= (double) nlevels;\n  /* end compute LS means and effective reciprocal of number of observations */\n\n  /* output LS means to file */\n  putc('\\n', dap_lst);\n  /* shouldn't need this now\n   * strcpy(dap_obs[0].do_str[typen], \"LSMEAN\");\n   * for (l1 = 0; l1 < nlevels; l1++)\n   * \t{\n   * \tstrcpy(dap_obs[0].do_str[treatn], levval[l1]);\n   * \tdap_obs[0].do_str[treat2n][0] = '\\0';\n   * \tdap_obs[0].do_dbl[respn] = lsmean[l1];\n   * \tdap_obs[0].do_dbl[resp2n] = lsmean[l1];\n   * \tdap_obs[0].do_dbl[statn] = lsmean[l1];\n   * \tdap_obs[0].do_dbl[lsm1] = lsmean[l1];\n   * \tdap_obs[0].do_dbl[lsm2] = 0.0;\n   * \toutput();\n   * \t}\n   */\n\n  /* output effective numbers of observations to file */\n  strcpy(dap_obs[0].do_str[typen], \"EFFN\");\n  for (l1 = 0; l1 < nlevels; l1++)\n    {\n      strcpy(dap_obs[0].do_str[treatn], levval[l1]);\n      dap_obs[0].do_dbl[respn] = 1.0 / effinvn[l1];\n      dap_obs[0].do_dbl[resp2n] = 1.0 / effinvn[l1];\n      dap_obs[0].do_dbl[statn] = 1.0 / effinvn[l1];\n      dap_obs[0].do_dbl[lsm1] = lsmean[l1];\n      dap_obs[0].do_dbl[lsm2] = 0.0;\n      output();\n    }\n\n  dfdown = floor(dedfi);\n  dfup = ceil(dedfi);\n  edfi = (int) dfdown;\n  if (methn == TUKEY || methn == LSD)\n    {\n      pr = -1.0;\n      for (l1 = 0; l1 < nlevels; l1++)\n\t{\n\t  for (l2 = 0; l2 < nlevels; l2++)\n\t    {\n\t      if (l2 == l1)\n\t\t{\n\t\t  diff[l1][l2] = 0.0;\n\t\t  prob[l1][l2] = 1.0;\n\t\t}\n\t      else if (methn == TUKEY)\n\t\t{\n\t\t  diff[l1][l2] = (lsmean[l1] - lsmean[l2]) /\n\t\t    sqrt(err * 0.5 * (effinvn[l1] + effinvn[l2]));\n\t\t  diff[l2][l1] = -diff[l1][l2];\n\t\t  if (dfdown == dfup)\n\t\t    prob[l1][l2] =\n\t\t      dap_sr(nlevels, edfi, fabs(diff[l1][l2]));\n\t\t  else\n\t\t    {\n\t\t      pdown = dap_sr(nlevels, edfi, fabs(diff[l1][l2]));\n\t\t      pup = dap_sr(nlevels, (int) dfup, fabs(diff[l1][l2]));\n\t\t      prob[l1][l2] = pdown +\n\t\t\t(dedfi - dfdown) / (dfup - dfdown) *\n\t\t\t(pup - pdown);\n\t\t    }\n\t\t  prob[l2][l1] = prob[l1][l2];\n\t\t}\n\t      else\n\t\t{\n\t\t  diff[l1][l2] = (lsmean[l1] - lsmean[l2]) /\n\t\t    sqrt(err * (effinvn[l1] + effinvn[l2]));\n\t\t  diff[l2][l1] = -diff[l1][l2];\n\t\t  if (dfdown == dfup)\n\t\t    prob[l1][l2] = 2.0 * probt(fabs(diff[l1][l2]), edfi);\n\t\t  else\n\t\t    {\n\t\t      pdown = probt(fabs(diff[l1][l2]), edfi);\n\t\t      pup = probt(fabs(diff[l1][l2]), (int) dfup);\n\t\t      prob[l1][l2] = 2.0 * (pdown +\n\t\t\t\t\t    (dedfi - dfdown) / (dfup - dfdown) *\n\t\t\t\t\t    (pup - pdown));\n\t\t    }\n\t\t  prob[l2][l1] = prob[l1][l2];\n\t\t}\n\t      if (pr < 0.0 || fabs(prob[l1][l2] - alpha) < fabs(pr - alpha))\n\t\t{\n\t\t  pt = fabs(diff[l1][l2]);\n\t\t  pr = prob[l1][l2];\n\t\t}\n\t    }\n\t}\n      for (l1 = 0; l1 < nlevels; l1++)\n\t{\n\t  strcpy(dap_obs[0].do_str[treatn], levval[l1]);\n\t  dap_obs[0].do_dbl[respn] = lsmean[l1];\n\t  for (l2 = 0; l2 < nlevels; l2++)\n\t    {\n\t      if (l2 == l1)\n\t\tcontinue;\n\t      strcpy(dap_obs[0].do_str[treat2n], levval[l2]);\n\t      dap_obs[0].do_dbl[resp2n] = lsmean[l2];\n\t      strcpy(dap_obs[0].do_str[typen], \"LSMDIFF\");\n\t      dap_obs[0].do_dbl[statn] = lsmean[l1] - lsmean[l2];\n\t      dap_obs[0].do_dbl[lsm1] = lsmean[l1];\n\t      dap_obs[0].do_dbl[lsm2] = lsmean[l2];\n\t      output();\n\t      if (methn == TUKEY)\n\t\t{\n\t\t  dap_obs[0].do_dbl[resp2n] = lsmean[l2];\n\t\t  strcpy(dap_obs[0].do_str[typen], \"MINDIFF\");\n\t\t  if (dfdown == dfup)\n\t\t    dap_obs[0].do_dbl[statn] =\n\t\t      dap_srpt(nlevels, edfi, pt, pr, alpha) *\n\t\t      sqrt(err * 0.5 * (effinvn[l1] + effinvn[l2]));\n\t\t  else\n\t\t    {\n\t\t      pdown = dap_srpt(nlevels, edfi, pt, pr, alpha);\n\t\t      pup = dap_srpt(nlevels, (int) dfup, pt, pr, alpha);\n\t\t      dap_obs[0].do_dbl[statn] =\n\t\t\t(pdown +\n\t\t\t (dedfi - dfdown) / (dfup - dfdown) *\n\t\t\t (pup - pdown)) *\n\t\t\tsqrt(err * 0.5 * (effinvn[l1] + effinvn[l2]));\n\t\t    }\n\t\t  output();\n\t\t}\n\t      else\n\t\t{\n\t\t  dap_obs[0].do_dbl[resp2n] = lsmean[l2];\n\t\t  strcpy(dap_obs[0].do_str[typen], \"MINDIFF\");\n\t\t  if (dfdown == dfup)\n\t\t    dap_obs[0].do_dbl[statn] =\n\t\t      tpoint(alpha / 2.0, edfi) *\n\t\t      sqrt(err * (effinvn[l1] + effinvn[l2]));\n\t\t  else\n\t\t    {\n\t\t      pdown = tpoint(alpha / 2.0, edfi);\n\t\t      pup = tpoint(alpha / 2.0, (int) dfup);\n\t\t      dap_obs[0].do_dbl[statn] =\n\t\t\t(pdown +\n\t\t\t (dedfi - dfdown) / (dfup - dfdown) *\n\t\t\t (pup - pdown)) *\n\t\t\tsqrt(err * (effinvn[l1] + effinvn[l2]));\n\t\t    }\n\t\t  output();\n\t\t}\n\t      strcpy(dap_obs[0].do_str[typen], \"PROB\");\n\t      dap_obs[0].do_dbl[statn] = prob[l1][l2];\n\t      output();\n\t    }\n\t}\n    }\n  else\t\t/* DUNNETT */\n    {\n      pr = -1.0;\n      for (l2 = 1; l2 < nlevels; l2++)\n\t{\n\t  diff[0][l2] = (lsmean[l2] - lsmean[0]) /\n\t    sqrt(err * effin);\n\t  if (dfdown == dfup)\n\t    prob[0][l2] = dap_md(nlevels - 1, edfi, fabs(diff[0][l2]));\n\t  else\n\t    {\n\t      pdown = dap_md(nlevels - 1, edfi, fabs(diff[0][l2]));\n\t      pup = dap_md(nlevels - 1, (int) dfup, fabs(diff[0][l2]));\n\t      prob[l1][l2] = pdown +\n\t\t(dedfi - dfdown) / (dfup - dfdown) *\n\t\t(pup - pdown);\n\t    }\n\t  if (pr < 0.0 || fabs(prob[0][l2] - alpha) < fabs(pr - alpha))\n\t    {\n\t      pt = fabs(diff[0][l2]);\n\t      pr = prob[0][l2];\n\t    }\n\t  strcpy(dap_obs[0].do_str[treat2n], levval[0]);\n\t  strcpy(dap_obs[0].do_str[treatn], levval[l2]);\n\t  dap_obs[0].do_dbl[respn] = lsmean[l2];\n\t  strcpy(dap_obs[0].do_str[typen], \"LSMDIFF\");\n\t  dap_obs[0].do_dbl[statn] = lsmean[l2] - lsmean[0];\n\t  dap_obs[0].do_dbl[lsm1] = lsmean[l2];\n\t  dap_obs[0].do_dbl[lsm2] = lsmean[0];\n\t  output();\n\t  strcpy(dap_obs[0].do_str[typen], \"PROB\");\n\t  dap_obs[0].do_dbl[statn] = prob[0][l2];\n\t  output();\n\t}\n    }\n  switch (methn)\n    {\n    case TUKEY:\n      fputs(\"Tukey method\\n\\n\", dap_lst);\n      fprintf(dap_lst, \"Minimum significant differences are for level %.5f\\n\",\n\t      alpha);\n      break;\n    case LSD:\n      fputs(\"LSD  method\\n\", dap_lst);\n      fprintf(dap_lst, \"Minimum significant differences are for level %.5f\\n\",\n\t      alpha);\n      break;\n    case DUNNETT:\n      pt = dap_mdpt(nlevels, edfi, pt, pr, alpha) * sqrt(err * effin);\n      fputs(\"Dunnett method\\n\", dap_lst);\n      fprintf(dap_lst,\n\t      \"At level %.5f, minimum significant difference = %.6g\\n\",\n\t      alpha, pt);\n      break;\n    }\n  dap_free(indep, \"\");\n  dap_free(lsmean, \"\");\n  dap_free(effinvn, \"\");\n  dap_free(diffmem, \"\");\n  dap_free(diff, \"\");\n  dap_free(probmem, \"\");\n  dap_free(prob, \"\");\n  dap_swap();\n}",
      "lines": 309,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lsmeans": {
      "start_point": [
        2312,
        0
      ],
      "end_point": [
        2585,
        1
      ],
      "content": "void lsmeans(char *fname, char *method, double alpha, char *varlist, char *treat,\n\t     char *marks, char *format)\n{\n  int typen;\n  int *varv;\n  int *markv;\n  int nmark;\n  int r;\n  char *lsmname;\n  char *lsmsrt;\n  char *varstr;\n  char *treat2;\t/* rename of treatment variable for columns */\n  char *args1;\n  char *args2;\n  int treatn;\n  int treat2n;\n  int resp2n;\n  int statn;\t/* index of _stat_ variable */\n  int methn;\t/* code for method: TUKEY=0, LSD=1, DUNNETT=2 */\n  char *levmem;\n  char **levval;\n  int l;\n  static int nlevels;\n  double *comem;\n  double **coeff;\n  int gotm, gotn, gotv;\n  double *mean;\n  double *nobs;\n  double *vari;\n  int s;\n  int ncells;\n  int nerrors;\n  int nlsmeans;\n  int morecells;\n  int more;\n  int err;\n  int con;\n  double mse;\n  double edf;\n  int lsm1, lsm2;\t/* index to LS mean row and col variables for sorting table */\n\n  mse = 0.0;\n  edf = 0.0;\n  if (!fname || !fname[0])\n    {\n      fputs(\"(lsmeans) no dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  lsmname = dap_malloc(strlen(fname) + 5, fname);\n  dap_suffix(lsmname, fname, \".lsm\");\n  lsmsrt = dap_malloc(strlen(lsmname) + 5, lsmname);\n  dap_suffix(lsmsrt, lsmname, \".srt\");\n  varv = (int *) dap_malloc(sizeof(int) * (dap_maxtreat + 1), \"dap_maxtreat\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  levmem = dap_malloc(dap_maxlev * (dap_strlen + 1), \"dap_maxlev, dap_strlen\");\n  levval = (char **) dap_malloc(sizeof(char *) * dap_maxlev, \"dap_maxlev\");\n  for (l = 0; l < dap_maxlev; l++)\n    levval[l] = levmem + l * (dap_strlen + 1);\n  comem = (double *) dap_malloc(sizeof(double) * dap_maxcell * dap_maxcell, \"dap_maxcell\");\n  coeff = (double **) dap_malloc(sizeof(double *) * dap_maxcell, \"dap_maxcell\");\n  for (ncells = 0; ncells < dap_maxcell; ncells++)\n    coeff[ncells] = comem + ncells * dap_maxcell;\n  mean = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  nobs = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  vari = (double *) dap_malloc(sizeof(double) * dap_maxcell, \"dap_maxcell\");\n  inset(fname);\n  if (!varlist || !varlist[0])\n    {\n      fputs(\"(lsmeans) no variable list given.\\n\", dap_err);\n      exit(1);\n    }\n  dap_list(varlist, varv, dap_maxtreat + 1);\n  if (!treat || !treat[0])\n    {\n      fputs(\"(lsmeans) no treatments specified.\\n\", dap_err);\n      exit(1);\n    }\n  if ((treatn = dap_varnum(treat)) < 0)\n    {\n      fprintf(dap_err, \"(lsmeans) Treatment variable unknown: %s\\n\", treat);\n      exit(1);\n    }\n  treat2 = dap_malloc(strlen(treat) + 2, treat); /* +2 for '_' and '\\0' */\n  strcpy(treat2, \"_\");\n  strcat(treat2, treat);\n  /* + 10 is to make sure that later use for dap_vd is OK */\n  varstr = dap_malloc(strlen(treat2) + strlen(dap_obs[0].do_nam[varv[0]]) + 10, \"\");\n  sprintf(varstr, \"%s %d\", treat2, dap_obs[0].do_len[treatn]);\n  treat2n = dap_vd(varstr, 0);\n  lsm1 = dap_vd(\"_lsm_ -1\", 0);\n  lsm2 = dap_vd(\"_LSMEAN_ -1\", 0);\n  for(r = 0, varstr[0] = '_'; dap_obs[0].do_nam[varv[0]][r]; r++)\n    {\n      if (r < dap_namelen - 1)\n\tvarstr[r + 1] = dap_obs[0].do_nam[varv[0]][r];\n    }\n  sprintf(varstr + r + 1, \" %d\", DBL);\n  resp2n = dap_vd(varstr, 0);\n  sprintf(varstr, \"_stat_ %d\", DBL);\n  statn = dap_vd(varstr, 0);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(lsmeans) no _type_ variable\\n\");\n      exit(1);\n    }\n  if (dap_varnum(\"_term_\") < 0)\n    {\n      fprintf(dap_err, \"(lsmeans) no _term_ variable\\n\");\n      exit(1);\n    }\n  outset(lsmname, \"\");\n  if (!method || !method[0])\n    {\n      fputs(\"(lsmeans) no method specified.\\n\", dap_err);\n      exit(1);\n    }\n  if (!strcmp(method, \"TUKEY\"))\n    methn = TUKEY;\n  else if (!strcmp(method, \"LSD\"))\n    methn = LSD;\n  else if (!strcmp(method, \"DUNNETT\"))\n    methn = DUNNETT;\n  else\n    {\n      fprintf(dap_err, \"(lsmeans) unknown method: %s\\n\", method);\n      exit(1);\n    }\n  nmark = dap_list(marks, markv, dap_maxvar);\n  for (l = 0; l < dap_maxlev; l++)\n    levval[l][0] = '\\0';\n  for (ncells = 0, nlevels = 0, nlsmeans = 0, nerrors = 0, more = step(), morecells = 1;\n       morecells; ncells++)\n    {\n      gotn = 0;\n      gotm = 0;\n      gotv = 0;\n      morecells = more;\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  dap_swap();\n\t  fprintf(dap_lst, \"Least-squares means for: %s\\n\", treat);\n\t  lsmeans1(methn, alpha, coeff, ncells, mse, edf,\n\t\t   nerrors, nlsmeans, mean, vari, nobs, nlevels, levval,\n\t\t   varv[0], treatn,  resp2n, treat2n, typen, statn, lsm1, lsm2);\n\t  ncells = 0;\n\t  nlsmeans = 0;\n\t  nerrors = 0;\n\t  nlevels = 0;\n\t  for (l = 0; l < dap_maxlev; l++)\n\t    levval[l][0] = '\\0';\n\t}\n      for (s = 0; more; )\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"N\"))\n\t    {\n\t      nobs[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotn = 1;\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"MEAN\"))\n\t    {\n\t      mean[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotm = 1;\n\t    }\n\t  else if (!strcmp(dap_obs[0].do_str[typen], \"VAR\"))\n\t    {\n\t      vari[ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      gotv = 1;\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(lsmeans) Bad cell statistic: %s\\n\",\n\t\t      dap_obs[0].do_str[typen]);\n\t      exit(1);\n\t    }\n\t  if (++s < 3)\n\t    more = step();\n\t  else\n\t    {\n\t      if (nobs[ncells] == 1.0)\n\t\tvari[ncells] = 0.0;\n\t      break;\n\t    }\n\t}\n      if (more)\n\t{\n\t  if (!gotm)\n\t    {\n\t      fputs(\"(lsmeans) Missing MEAN.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  if (!gotn)\n\t    {\n\t      fputs(\"(lsmeans) Missing N.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  if (!gotv)\n\t    {\n\t      fputs(\"(lsmeans) Missing VAR.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t  levn(dap_obs[0].do_str[treatn], levval, &nlevels);\n\t}\n      for (nerrors = 0; more; )\n\t{\n\t  more = step();\n\t  err = !strcmp(dap_obs[0].do_str[typen], \"ERROR\");\n\t  con = !strcmp(dap_obs[0].do_str[typen], \"CONTR\");\n\t  if (err || con)\n\t    {\n\t      coeff[nerrors][ncells] = dap_obs[0].do_dbl[varv[0]];\n\t      nerrors++;\n\t    }\n\t  else\n\t    break;\n\t}\n      for (nlsmeans = 0; more; )\n\t{\n\t  if (!strcmp(dap_obs[0].do_str[typen], \"LSMEAN\"))\n\t    {\n\t      coeff[nerrors + nlsmeans][ncells] =\n\t\tdap_obs[0].do_dbl[varv[0]];\n\t      nlsmeans++;\n\t    }\n\t  else\n\t    break;\n\t  more = step();\n\t}\n      if (!strcmp(dap_obs[0].do_str[typen], \"MSERROR\"))\n\t{\n\t  mse = dap_obs[0].do_dbl[varv[0]];\n\t  if (more && (more = step()) &&\n\t      !strcmp(dap_obs[0].do_str[typen], \"ERRORDF\"))\n\t    {\n\t      edf = dap_obs[0].do_dbl[varv[0]];\n\t      if (more)\n\t\tmore = step();\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(lsmeans1) Expected ERRORDF: %s\\n\",\n\t\t      dap_obs[0].do_str[typen]);\n\t      exit(1);\n\t    }\n\t}\n    }\n  args1 = dap_malloc(strlen(marks) + strlen(treat2) + strlen(treat) + 10 + 15, \"\");\n  sprintf(args1, \"%s _type_ _LSMEAN_ %s _lsm_ %s\", marks, treat2, treat);\n  sort(lsmname, args1, \"\");\n  sprintf(args1, \"_type_ _LSMEAN_ %s\", treat2);\n  args2 = dap_malloc(strlen(treat) + 8 + 6, treat);\n  sprintf(args2, \"_lsm_ %s _stat_\", treat);\n  while (*format == ' ')\t/* here we want to deny user sorting */\n    format++;\n  if (*format == 's')\n    format++;\n  table(lsmsrt, args1, args2, format, marks);\n  dap_free(varv, \"\");\n  dap_free(markv, \"\");\n  dap_free(lsmname, \"\");\n  dap_free(lsmsrt, \"\");\n  dap_free(varstr, \"\");\n  dap_free(treat2, \"\");\n  dap_free(args1, \"\");\n  dap_free(args2, \"\");\n  dap_free(levmem, \"\");\n  dap_free(levval, \"\");\n  dap_free(comem, \"\");\n  dap_free(coeff, \"\");\n  dap_free(mean, \"\");\n  dap_free(nobs, \"\");\n  dap_free(vari, \"\");\n}",
      "lines": 274,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dap5.c": {
    "matchmark": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int matchmark(int *markv, int *xmarkv, int nmark, double level)\n{\n  int i;\n  int diff;\n\n  if (xmarkv[0] < 0)\n    return !dap_newpart(markv, nmark);\n  for (diff = 0, i = 0; !diff && i < nmark; i++)\n    {\n      if (dap_obs[0].do_len[markv[i]] > 0)\n\tdiff = strcmp(dap_obs[0].do_str[markv[i]], dap_obs[1].do_str[xmarkv[i]]);\n      else if (dap_obs[0].do_len[markv[i]] == INT)\n\tdiff = (dap_obs[0].do_int[markv[i]] != dap_obs[1].do_int[xmarkv[i]]);\n      else\n\tdiff = (dap_obs[0].do_dbl[markv[i]] != dap_obs[1].do_dbl[xmarkv[i]]);\n    }\n  return !diff;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "linreg1": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "void linreg1(double **xymat, int *varv,\n\t     int nx0, int nx, int ny, int nobs, int *xvarv,\n\t     int *markv, int *xmarkv, int nmark, double level,\n\t     int respn, int param1n, int param2n, int covn, int partv[])\n{\n  double *invmem;\t\t\t/* memory allocated for inverse of SS matrix */\n  double **inv;\t\t\t/* pointers for inverse matrix */\n  int r, c;\t\t\t/* row and column */\n  int rr, cc;\t\t\t/* row and column */\n  double pivot;\t\t\t/* numerical value of pivot element */\n  double tmp, tmp2;\n  int typen;\t\t\t/* index of _type_ variable */\n  double dnobs;\t\t\t/* number of observations, as double */\n  double *rss0, *rss1, *rss;\t/* reduced sums of squares for y vs x0s, y vs x1s, y vs y */\n  double *f, *fch;\t\t/* F and F change values */\n  int df;\t\t\t\t/* degrees of freedom */\n  double ddf;\t\t\t/* degrees of freedom, as double */\n  double xi, xj;\t\t\t/* indexes to x-variables */\n  static double tpt;\t\t/* point in t-distribution */\n  int yn;\t\t\t\t/* index to y variables */\n  int i, j;\n  double *pred;\t\t\t/* array of predicted values */\n  double *sepred;\t\t\t/* array of SEs for predictions */\n  int v;\t\t\t\t/* index to variables */\n\n  dap_swap();\t/* it's cleaner to have linreg1 get the previous part's mark variables */\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(linreg1) Missing _type_ variable.\\n\");\n      exit(1);\n    }\n  invmem = (double *) dap_malloc(sizeof(double) * nx * nx, \"\");\n  inv = (double **) dap_malloc(sizeof(double *) * nx, \"\");\n  for (r = 0; r < nx; r++)\n    inv[r] = invmem + r * nx;\n  rss0 = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  rss1 = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  rss = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  f = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  fch = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  pred = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  sepred = (double *) dap_malloc(sizeof(double) * ny, \"\");\n  dnobs = (double) nobs;\n  /* row 0 of xymat will now be the means of the observations */\n  for (c = 1; c < nx + ny; c++)\n    xymat[0][c] /= dnobs;\n  /* initialize the inverse to the identity before performing row ops */\n  for (r = 1; r < nx; r++)\n    for (c = 1; c < nx; c++)\n      {\n\tif (r == c)\n\t  inv[r][c] = 1.0;\n\telse\n\t  inv[r][c] = 0.0;\n      }\n  /* now perform row ops for the x-variables, from row 1 to nx-1 */\n  for (c = 1; c < nx; c++)\n    {\n      /* these could have been done before, but can be done here, too */\n      if (c == 1)\t/* initialize RSS for x0 vars to SSs of the y's */\n\t{\n\t  for (cc = 0; cc < ny; cc++)\n\t    rss0[cc] = xymat[nx + cc][nx + cc];\n\t}\n      if (c == nx0)\t/* init RSS for x1 vars to SSs of the y's after reduction of x0 rows */\n\t{\n\t  for (cc = 0; cc < ny; cc++)\n\t    rss1[cc] = xymat[nx + cc][nx + cc];\n\t}\n      pivot = xymat[c][c];\t/* default pivot */\n      if (pivot != 0.0)\t/* OK, trusting the SS matrix not to be weird */\n\t{\t\t/* should not require pivoting */\n\t  for (rr = c + 1; rr < nx + ny; rr++)\n\t    {\n\t      tmp = xymat[rr][c] / pivot;\t/* mult factor for row op */\n\t      xymat[rr][c] = 0.0;\t\t/* eliminate below (c,c) elt */\n\t      for (cc = c + 1; cc < nx + ny; cc++)\n\t\t{\n\t\t  if (rr < nx || cc < nx || rr == cc)\n\t\t    {\n\t\t      xymat[rr][cc] -= tmp * xymat[c][cc];\n\t\t      /* zero out entries below tolerance */\n\t\t      if (fabs(xymat[rr][cc]) < dap_tol * pivot)\n\t\t\txymat[rr][cc] = 0.0;\n\t\t    }\n\t\t}\n\t      if (rr < nx)\n\t\t{\t/* repeat row reduction to get inverse */\n\t\t  for (cc = 1; cc < nx; cc++)\n\t\t    {\n\t\t      inv[rr][cc] -= tmp * inv[c][cc];\n\t\t      if (fabs(inv[rr][cc]) < dap_tol * pivot)\n\t\t\tinv[rr][cc] = 0.0;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(linreg1) X'X matrix is singular.\\n\");\n\t  exit(1);\n\t}\n    }\n  /* now need to do upward row ops to get inverse */\n  for (c = nx - 1; c > 0; --c)\n    {\n      for (r = c - 1; r > 0; --r)\n\t{\n\t  tmp = xymat[r][c] / xymat[c][c];\n\t  for (cc = c + 1; cc < nx + ny; cc++)\n\t    xymat[r][cc] -= tmp * xymat[c][cc];\n\t  for (cc = 0; cc < nx; cc++)\n\t    inv[r][cc] -= tmp * inv[c][cc];\n\t}\n      for (cc = c + 1; cc < nx + ny; cc++)\n\txymat[c][cc] /= xymat[c][c];\n      for (cc = 0; cc < nx; cc++)\n\tinv[c][cc] /= xymat[c][c];\n    }\n  df = nobs - nx;\n  ddf = (double) df;\n  /* RSS for y-vars are the diagonal entries of xymat\n   * and F stats are ratios of differences of SSs to RSS for the y-vars\n   */\n  for (c = 0; c < ny; c++)\n    {\n      rss[c] = xymat[nx + c][nx + c];\t\t/* SSs of the y-vars after reduction */\n      f[c] = (rss0[c] - rss[c]) / rss[c] * ddf / ((double) nx - 1);\n      fch[c] = (rss1[c] - rss[c]) / rss[c] * ddf / ((double) nx - nx0);\n    }\n  /* now copy inverse of SS of the x-vars back to xymat */\n  for (r = 1; r < nx; r++)\n    for (c = 1; c < nx; c++)\n      xymat[r][c] = inv[r][c];\n  /* column 0 will be the minus cross-product of inv SS with the means */\n  for (r = 1; r < nx; r++)\n    for (c = 1; c < nx; c++)\n      xymat[r][0] -= xymat[r][c] * xymat[0][c];\n  xymat[0][0] = 1.0 / dnobs;\n  for (c = 1; c < nx; c++)\n    xymat[0][0] -= xymat[0][c] * xymat[c][0];\n  for (c = 0; c < ny; c++)\n    for (cc = 1; cc < nx; cc++)\n      xymat[0][nx + c] -= xymat[0][cc] * xymat[cc][nx + c];\n  for (c = 1; c < nx; c++)\n    xymat[0][c] = xymat[c][0];\n  /* now print and output estimates and SEs, later output the covariance matrix */\n  dap_ono = 2;\n  /* set up partvars for covariance matrix dataset */\n  for (v = 0; v < nmark; v++)\n    {\n      if (dap_obs[0].do_len[markv[v]] == DBL)\n\tdap_obs[dap_ono].do_dbl[partv[v]] = dap_obs[0].do_dbl[markv[v]];\n      else if (dap_obs[0].do_len[markv[v]] == INT)\n\tdap_obs[dap_ono].do_int[partv[v]] = dap_obs[0].do_int[markv[v]];\n      else\n\tstrcpy(dap_obs[dap_ono].do_str[partv[v]],\n\t       dap_obs[0].do_str[markv[v]]);\n    }\n  fprintf(dap_lst, \"Reduced | full model regressors:\");\n  for (r = 0; r < nx0; r++)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[r]]);\n  fprintf(dap_lst, \" |\");\n  while (r < nx)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[r++]]);\n  putc('\\n', dap_lst);\n  fprintf(dap_lst, \"Number of observations = %d\\n\", nobs);\n  for (c = 0; c < ny; c++)\n    {\n      fprintf(dap_lst, \"\\nResponse: %s\\n\", dap_obs[0].do_nam[varv[nx + c]]);\n      fprintf(dap_lst,\n\t      \"   F0(%d, %d) = %.6g, Prob[F > F0] = %.5f\\n   R-sq = %.6g, Adj R-sq = %.6g\\n\",\n\t      nx - 1, nobs - nx, f[c],\n\t      0.00001 * ceil(100000.0 * probf(f[c], nx - 1, nobs - nx)),\n\t      1.0 - rss[c] / rss0[c],\n\t      1.0 - rss[c] * ((double) (nobs - 1)) / (rss0[c] * ddf));\n      if (nx0 > 1)\n\tfprintf(dap_lst, \"   F-change(%d, %d) = %.6g, Prob[F > F-change] = %.5f\\n\",\n\t\tnx - nx0, nobs - nx, fch[c],\n\t\t0.00001 * ceil(100000.0 * probf(fch[c], nx - nx0, nobs - nx)));\n      fprintf(dap_lst,\n\t      \"\\n   Parameter           Estimate    Std Error   T0[%6d]  Prob[|T|>|T0|]\\n\",\n\t      nobs - nx);\n      for (r = 0; r < nx; r++)\n\t{\n\t  /* tmp = sqrt(RSS for y with itself after reduction / deg freedom * inv SS for x-var)\n\t   * this is the standard error, the denominator for the t-value\n\t   */\n\t  tmp = sqrt(rss[c] / ddf * xymat[r][r]);\n\t  /* tmp2 is the t-value because xymat[r][nx + c] is the estimate */\n\t  tmp2 = xymat[r][nx + c] / tmp;\n\t  fprintf(dap_lst, \"   %-15s %12.6g %12.6g %12.6g  %14.5f\\n\",\n\t\t  dap_obs[0].do_nam[varv[r]],\n\t\t  xymat[r][nx + c], tmp,\n\t\t  tmp2,\n\t\t  0.00001 * ceil(200000.0 * probt(fabs(tmp2), nobs - nx)));\n\t  strcpy(dap_obs[dap_ono].do_str[typen], \"ESTIMATE\");\n\t  strcpy(dap_obs[dap_ono].do_str[respn], dap_obs[0].do_nam[varv[nx + c]]);\n\t  strcpy(dap_obs[dap_ono].do_str[param2n], dap_obs[0].do_nam[varv[r]]);\n\t  strcpy(dap_obs[dap_ono].do_str[param1n], \"\");\n\t  dap_obs[dap_ono].do_dbl[covn] = xymat[r][nx + c];\n\t  output();\n\t}\n    }\n  /* now we write out the covariance matrix */\n  strcpy(dap_obs[dap_ono].do_str[typen], \"COVAR\");\n  for (yn = 0; yn < ny; yn++)\n    {\n      strcpy(dap_obs[dap_ono].do_str[respn], dap_obs[0].do_nam[varv[nx + yn]]);\n      tmp = rss[yn] / ddf;\n      /* \"rows\" are indexed by r */\n      for (r = 0; r < nx; r++)\n\t{\n\t  strcpy(dap_obs[dap_ono].do_str[param1n], dap_obs[0].do_nam[varv[r]]);\n\t  /* \"columns\" are indexed by c */\n\t  for (c = 0; c < nx; c++)\n\t    {\n\t      strcpy(dap_obs[dap_ono].do_str[param2n], dap_obs[0].do_nam[varv[c]]);\n\t      dap_obs[dap_ono].do_dbl[covn] = tmp * xymat[r][c];\n\t      output();\n\t    }\n\t}\n    }\n  /* now back to .reg output */\n  dap_ono = 0;\n  /* now we write out the OBS, PRED, LOWER, and UPPER values for the xname values */\n  if (level < 1.0)\n    tpt = tpoint(0.5 * (1.0 - level), nobs - nx);\n  else\n    tpt = 0.0;\n  dap_obs[0].do_dbl[varv[0]] = 1.0;\n  if (xvarv[0] < 0)\n    {\n      dap_rewind();\n      step();\n    }\n  while (matchmark(markv, xmarkv, nmark, level))\n    {\n      dap_ono = 0;\n      if (xvarv[0] >= 0)\t/* if dataset for x-values specified */\n\t{\t\t/* there are no observed values */\n\t  for (i = 1; i < nx; i++)\n\t    dap_obs[0].do_dbl[varv[i]] = dap_obs[1].do_dbl[xvarv[i - 1]];\n\t}\n      else\n\t{\n\t  strcpy(dap_obs[0].do_str[typen], \"OBS\");\n\t  output();\n\t}\n      for (yn = 0; yn < ny; yn++)\n\t{\n\t  for (pred[yn] = 0.0, i = 0; i < nx; i++)\n\t    pred[yn] += xymat[i][nx + yn] * dap_obs[0].do_dbl[varv[i]];\n\t  for (sepred[yn] = 0.0, i = 0; i < nx; i++)\n\t    {\n\t      xi = dap_obs[0].do_dbl[varv[i]];\n\t      for (j = 0; j < nx; j++)\n\t\t{\n\t\t  xj = dap_obs[0].do_dbl[varv[j]];\n\t\t  sepred[yn] += xi * rss[yn] / ddf * xymat[i][j] * xj;\n\t\t}\n\t    }\n\t}\n      strcpy(dap_obs[0].do_str[typen], \"PRED\");\n      for (yn = 0; yn < ny; yn++)\n\tdap_obs[0].do_dbl[varv[nx + yn]] = pred[yn];\n      output();\n      if (tpt != 0.0)\n\t{\n\t  strcpy(dap_obs[0].do_str[typen], \"LOWER\");\n\t  for (yn = 0; yn < ny; yn++)\n\t    dap_obs[0].do_dbl[varv[nx + yn]] = pred[yn] - tpt * sqrt(sepred[yn]);\n\t  output();\n\t  strcpy(dap_obs[0].do_str[typen], \"UPPER\");\n\t  for (yn = 0; yn < ny; yn++)\n\t    dap_obs[0].do_dbl[varv[nx + yn]] = pred[yn] + tpt * sqrt(sepred[yn]);\n\t  output();\n\t}\n      if (xvarv[0] >= 0)\n\tdap_ono = 1;\n      dap_mark();\n      if (!step())\n\tbreak;\n    }\n  dap_ono = 0;\n  if (xvarv[0] >= 0)\n    dap_swap();\n  dap_free(invmem, \"\");\n  dap_free(inv, \"\");\n  dap_free(rss0, \"\");\n  dap_free(rss1, \"\");\n  dap_free(rss, \"\");\n  dap_free(f, \"\");\n  dap_free(fch, \"\");\n  dap_free(pred, \"\");\n  dap_free(sepred, \"\");\n}",
      "lines": 297,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "linreg": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "void linreg(char *fname, char *ylist, char *x0list, char *x1list,\n\t    char *marks, char *xname, double level)\n{\n  char *regname;\t/* name of .reg dataset for writing out OBS,PRED,LOWER, and UPPER values */\n  int *varv;\t/* indexes of all variables */\n  int *xvarv;\t/* indexes of x-variables in dataset xname */\n  int ny;\t\t/* number of y-variables */\n  int nx0, nx1;\t/* num of x-vars in reduced (includes _intercept_), full-reduced models */\n  int nx;\t\t/* number of x-variables: nx0 + nx1 */\n  int nvar;\t/* number of x- and y-variables: nx + ny */\n  int nxx;\t/* number of x-variables not including _intercept_ */\n  int *markv;\t/* indexes of mark variables for partitioning the dataset */\n  int *xmarkv;\t/* if xname is given, indexes of mark variables in dataset xname */\n  int nmark;\t/* number of mark variables (must be equal for fname and xname datasets) */\n  int v, w;\t/* indexes to index vectors */\n  double tmp;\n  int nobs;\t/* number of observations in the dataset fname */\n  double dnobs;\t/* nobs converted to double */\n  double *xymem;\t/* memory allocated for SS matrix */\n  double **xymat;\t/* SS matrix for the nvar = nx + ny x- and y-variables */\n  int more;\t/* for stepping through parts of the dataset */\n  char *covset;   /* name of dataset for covariance matrix */\n  int param1n, param2n, respn, covn;     /* indices to covset variables */\n  int paramlen1, paramlen;        /* length and maximum length of parameter name */\n  char paramstr[14];      /* string for declaring variable name variables */\n  char *partstr;  /* for declaring part variables in covset */\n  int *partv;    /* indexes of part variables for covset */\n\n  if (!fname)\n    {\n      fputs(\"(linreg) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  xvarv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  xmarkv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  partv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  regname = dap_malloc(strlen(fname) + 5, \"\");\n  dap_suffix(regname, fname, \".reg\");\n  inset(fname);\n  dap_vd(\"_intercept_ -1\", 0);\t/* allocate _intercept_ variable */\n  nx0 = dap_list(\"_intercept_\", varv, dap_maxvar);\t/* and put in varv */\n  nx0 += dap_list(x0list, varv + 1, dap_maxvar);\t/* now put in x0 vars */\n  nx1 = dap_list(x1list, varv + nx0, dap_maxvar);\t/* now put in x1 vars */\n  nx = nx0 + nx1;\n  ny = dap_list(ylist, varv + nx, dap_maxvar);\t/* now put in y vars */\n  nvar = nx + ny;\n  nmark = dap_list(marks, markv, dap_maxvar);\t/* get mark variable indexes */\n  /* do some bookkeeping for covariance dataset */\n  covset = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(covset, fname);\n  strcat(covset, \".cov\");\n  /* find maximum length of variable names */\n  for (v = 1, paramlen = strlen(\"_intercept_\"); v < nvar; v++)\n    {\n      paramlen1 = strlen(dap_obs[dap_ono].do_nam[varv[v]]);\n      if (paramlen1 > paramlen)\n\tparamlen = paramlen1;\n    }\n  /* now set up variables for covariance dataset */\n  dap_ono = 2;\n  dap_clearobs((char *) NULL);    /* set up dap_obs, make _type_ variable */\n  /* this will bomb if a variable name is more than 99 characters long */\n  sprintf(paramstr, \"_response_ %d\", paramlen);\n  respn = dap_vd(paramstr, 0);\n  sprintf(paramstr, \"_param1_ %d\", paramlen);\n  param1n = dap_vd(paramstr, 0);\n  sprintf(paramstr, \"_param2_ %d\", paramlen);\n  param2n = dap_vd(paramstr, 0);\n  covn = dap_vd(\"_cov_ -1\", 0);\n  partstr = dap_malloc(strlen(marks) + 1, \"\");\n  for (v = 0; v < nmark; v++)\n    {\n      strcpy(partstr, dap_obs[0].do_nam[markv[v]]);\n      sprintf(partstr + strlen(partstr), \" %d\", dap_obs[0].do_len[markv[v]]);\n      partv[v] = dap_vd(partstr, 1);\n    }\n  outset(covset, \"\");\n  /* now back to fname */\n  dap_ono = 0;\n  /* allocate memory for SS matrix and set up pointers for matrix entries */\n  xymem = (double *) dap_malloc(sizeof(double) * nvar * nvar, \"\");\n  xymat = (double **) dap_malloc(sizeof(double *) * nvar, \"\");\n  for (v = 0; v < nvar; v++)\n    xymat[v] = xymem + v * nvar;\n  dap_ono = 1;\t\t/* now going to work with dataset xname of x-values */\n  if (xname && xname[0])\t/* if xname is specified */\n    {\n      inset(xname);\n      nxx = dap_list(x0list, xvarv, dap_maxvar);\t/* get indexes of x-vars in xname */\n      nxx += dap_list(x1list, xvarv + nxx, dap_maxvar);\n      if (nxx != nx - 1)\t/* this had better match, except for _intercept_ */\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(linreg) %s and %s have different numbers (%d and %d) of x-variables.\\n\",\n\t\t  fname, xname, nx - 1, nxx);\n\t  exit(1);\n\t}\n      if (nmark)\t/* if the datasets are partitioned */\n\t{\t/* check that fname and xname have same mark vars */\n\t  for (v = 0; v < nmark; v++)\n\t    {\n\t      if ((xmarkv[v] = dap_varnum(dap_obs[0].do_nam[markv[v]])) < 0)\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(linreg) Mark variable %s in %s not in %s.\\n\",\n\t\t\t  dap_obs[0].do_nam[markv[v]], fname, xname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      if (!step())\n\t{\n\t  fprintf(dap_err, \"(linreg) No data in %s.\\n\", xname);\n\t  exit(1);\n\t}\n    }\n  else\t\t/* indicate lack of xname dataset */\n    {\n      xvarv[0] = -1;\n      xmarkv[0] = -1;\n    }\n  dap_ono = 0;\t/* now back to dataset fname of observations */\n  for (w = 0; w < nvar; w++)\t/* check type of variables */\n    {\n      if (dap_obs[0].do_len[varv[w]] != DBL)\n\t{\n\t  fprintf(dap_err, \"(linreg) Variable %s not double.\\n\",\n\t\t  dap_obs[0].do_nam[varv[w]]);\n\t  exit(1);\n\t}\n      for (v = 0; v < nvar; v++)\t/* and zero out entire xymat */\n\txymat[v][w] = 0.0;\n    }\n  outset(regname, \"\");\t/* prepare writing of OBS,PRED,LOWER and UPPER values */\n  /* now we read in the data and create the SS matrix */\n  for (nobs = 0, dap_mark(), more = 1; more; nobs++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  dap_swap();\n\t  linreg1(xymat, varv, nx0, nx, ny, nobs, xvarv, markv, xmarkv, nmark, level,\n\t\t  respn, param1n, param2n, covn, partv);\n\t  for (w = 0; w < nvar; w++)\n\t    {\n\t      for (v = 0; v < nvar; v++)\n\t\txymat[v][w] = 0.0;\n\t    }\n\t  nobs = 0;\n\t}\n      /* use standard updating algorithm for computing the SS's on the run for accuracy */\n      /* xymat: 0 row contains sum of values for x and y vars except for _intercept_\n       * (1 to nx-1) x (1 to nx-1) contains SS for x-variables;\n       * (1 to nx-1) x (nx to nvar) contains SS for x-vars with each y-var\n       * (nx to nvar-1) x (1 to nx-1) contains SS for x-vars with each y-var\n       * (nx, nx) to (nvar-1,nvar-1) diagonal contains SS for each y-var\n       */\n      if (nobs)\n\t{\t/* we do this starting on the second observation */\n\t  dnobs = (double) nobs;\n\t  for (v = 1; v < nvar; v++)\n\t    {\n\t      tmp = xymat[0][v] -\n\t\tdnobs * dap_obs[0].do_dbl[varv[v]];\n\t      for (w = 1; w < nvar; w++)\n\t\t{\n\t\t  if (v < nx || w < nx || v == w)\n\t\t    xymat[v][w] += tmp *\n\t\t      (xymat[0][w] - dnobs *\n\t\t       dap_obs[0].do_dbl[varv[w]]) /\n\t\t      (dnobs * (dnobs + 1.0));\n\t\t}\n\t    }\n\t}\n      for (w = 1; w < nvar; w++)\t/* zero row is sum of values except for _intercept_ */\n\txymat[0][w] += dap_obs[0].do_dbl[varv[w]];\n    }\n  dap_free(regname, \"\");\n  dap_free(varv, \"\");\n  dap_free(xvarv, \"\");\n  dap_free(markv, \"\");\n  dap_free(xmarkv, \"\");\n  dap_free(xymem, \"\");\n  dap_free(xymat, \"\");\n  dap_free(covset, \"\");\n  dap_free(partstr, \"\");\n  dap_free(partv, \"\");\n}",
      "lines": 192,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "dap_parsey": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "void dap_parsey(char *yspec, int *varv)\n{\n  int l;\n  int i;\n  char *vname;\n  int vn;\n  int ntrials;\n\n  vname = dap_malloc(dap_namelen + 1, \"dap_namelen\");\n  for (l = 0; yspec[l] == ' '; l++) /* skip leading blanks */\n    ;\n  for (i = 0; yspec[l + i] && yspec[l + i] != ' ' && yspec[l + i] != '/'; i++)\n    {\n      if (i < dap_namelen)\n\tvname[i] = yspec[l + i];\n      else\n\t{\n\t  fprintf(dap_err, \"(parsey) Variable name too long: %s\\n\", yspec + l);\n\t  exit(1);\n\t}\n    }\n  vname[i] = '\\0'; /* response variable */\n  l += i; /* now at space or / */\n  if ((vn = dap_varnum(vname)) < 0)\n    {\n      fprintf(dap_err, \"(parsey) Unknown variable: %s\\n\", vname);\n      exit(1);\n    }\n  if (dap_obs[dap_ono].do_len[vn] != DBL)\n    {\n      fprintf(dap_err, \"(parsey) Events variable not double: %s\\n\", vname);\n      exit(1);\n    }\n  varv[0] = vn;\n  while (yspec[l] == ' ')\n    l++;\n  if (yspec[l] == '/')\n    {\n      for (l++; yspec[l] == ' '; l++) /* skip spaces */\n\t;\n      for (i = 0; yspec[l + i] && yspec[l + i] != ' '; i++)\n\t{\n\t  if (i < dap_namelen)\n\t    vname[i] = yspec[l + i];\n\t  else\n\t    {\n\t      fprintf(dap_err, \"(parsey) Variable name too long: %s\\n\", yspec + l);\n\t      exit(1);\n\t    }\n\t}\n      vname[i] = '\\0';\n      for (i = 0, ntrials = 0; '0' <= vname[i] && vname[i] <= '9'; i++)\n\tntrials = 10 * ntrials + vname[i] - '0';\n      if (i)\n\t{\n\t  if (vname[i])\n\t    {\n\t      fprintf(dap_err, \"(parsey) Invalid number of trials: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t  varv[1] = -ntrials;\n\t}\n      else\n\t{\n\t  if ((vn = dap_varnum(vname)) < 0)\n\t    {\n\t      fprintf(dap_err, \"(parsey) Unknown variable: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t  if (dap_obs[dap_ono].do_len[vn] != DBL)\n\t    {\n\t      fprintf(dap_err, \"(parsey) Trials variable not double: %s\\n\", vname);\n\t      exit(1);\n\t    }\n\t  varv[1] = vn;\n\t}\n    }\n  else\n    {\n      fprintf(dap_err, \"(parsey) Expected / in yspec at: %s\\n\", yspec + l);\n      exit(1);\n    }\n  dap_free(vname, \"\");\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "vlen": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "static double vlen(double *v, int nv)\n{\n  int i;\n  double len;\n\n  for (len = 0.0, i = 0; i < nv; i++)\n    len += v[i] * v[i];\n  return sqrt(len);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "vdiff": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static double vdiff(double *v0, double *v1, int nv)\n{\n  int i;\n  double tmp;\n  double diff;\n\n  for (diff = 0.0, i = 0; i < nv; i++)\n    {\n      tmp = v0[i] - v1[i];\n      diff += tmp * tmp;\n    }\n  return sqrt(diff);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "dap_invert": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        726,
        1
      ],
      "content": "int dap_invert(double **a, int nrc)\n{\n  double *invmem;\n  double **inv;\n  int r, c;\n  int cc;\n  double tmp;\n  double mult;\n\n  invmem = (double *) dap_malloc(sizeof(double) * nrc * nrc, \"\");\n  inv = (double **) dap_malloc(sizeof(double *) * nrc, \"\");\n  for (r = 0; r < nrc; r++)\n    {\n      inv[r] = invmem + r * nrc;\n      for (c = 0; c < nrc; c++)\n\t{\n\t  if (r == c)\n\t    inv[r][c] = 1.0;\n\t  else\n\t    inv[r][c] = 0.0;\n\t}\n    }\n  for (c = 0; c < nrc; c++)\n    {\n      if (a[c][c] != 0.0)\n\t{\n\t  tmp = a[c][c];\n\t  for (r = c + 1; r < nrc; r++)\n\t    {\n\t      mult = a[r][c] / tmp;\n\t      a[r][c] = 0.0;\n\t      for (cc = c + 1; cc < nrc; cc++)\n\t\t{\n\t\t  a[r][cc] -= mult * a[c][cc];\n\t\t  if (fabs(a[r][cc]) < dap_tol * tmp)\n\t\t    a[r][cc] = 0.0;\n\t\t}\n\t      for (cc = 0; cc < nrc; cc++)\n\t\t{\n\t\t  inv[r][cc] -= mult * inv[c][cc];\n\t\t  if (fabs(inv[r][cc]) < dap_tol * tmp)\n\t\t    inv[r][cc] = 0.0;\n\t\t}\n\t    }\n\t}\n      else\n\treturn 0;\n    }\n  for (c = nrc - 1; c >= 0; --c)\n    {\n      tmp = a[c][c];\n      for (cc = c + 1; cc < nrc; cc++)\n\ta[c][cc] /= tmp;\n      for (cc = 0; cc < nrc; cc++)\n\tinv[c][cc] /= tmp;\n      for (r = c - 1; r >= 0; --r)\n\t{\n\t  tmp = a[r][c];\n\t  for (cc = c; cc < nrc; cc++)\n\t    a[r][cc] -= tmp * a[c][cc];\n\t  for (cc = 0; cc < nrc; cc++)\n\t    inv[r][cc] -= tmp * inv[c][cc];\n\t}\n    }\n  for (r = 0; r < nrc; r++)\n    for (c = 0; c < nrc; c++)\n      a[r][c] = inv[r][c];\n  dap_free(invmem, \"\");\n  dap_free(inv, \"\");\n  return 1;\n}",
      "lines": 71,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "irls": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static double irls(\n\t\t   double **x,\t/* array of explanatory x-variable values */\n\t\t   double **y,\t/* array of response y-variable, number-of-cases variable values */\n\t\t   double *pr,\t/* array of predicted probability values for x-variable values */\n\t\t   double *beta0,\t/* parameter vector, allocated by and returned to caller */\n\t\t   double **cov,\t/* covariance matrix, allocated by caller */\n\t\t   int nx,\t\t/* number of explanatory x-variable values */\n\t\t   int nobs\t/* number of observations */\n\t\t   )\n{\n  int i, j;\n  int n;\n  double *beta1;\t\t\t/* next value of parameter vector */\n  double *v;\t\t\t/* the X'(y - m(i)) term of equation (4.32) on p. 116 */\n  double *step;\t\t\t/* amount to change beta parameter vector by */\n  double loglike0, loglike1;\t/* current and next log likelihood values */\n  int niter;\t\t\t/* number of iterations completed */\n  double maxv;\t\t\t/* max entry in X'(y - m(i)) */\n  double maxcov;\n  double tmp;\n\n  /* allocate array for next value of parameter vector */\n  beta1 = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  /* what's this? */\n  v = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  /* allocate array for beta change vector */\n  step = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  /* initialize parameter values all to zero: null model */\n  for (i = 0; i < nx; i++)\n    beta1[i] = 0.0;\n  /* initialize all probability values to 0.5 (null model) and\n   * compute corresponding log likelihood\n   */\n  for (loglike1 = 0.0, n = 0; n < nobs; n++)\n    {\n      pr[n] = 0.5;\n      loglike1 += y[1][n];\n    }\n  loglike1 *= log(0.5);\n  /* starting iterations */\n  niter = 0;\n  do\t{\n    /* copy new parameter vector, log likelihood into old for next iteration */\n    for (i = 0; i < nx; i++)\n      beta0[i] = beta1[i];\n    loglike0 = loglike1;\n    /* compute terms of equation (4.32) on page 116 */\n    for (i = 0, maxv = 0.0, maxcov = 0.0; i < nx; i++)\n      {\n\t/* compute the X'(y - m(i)) term */\n\tfor (v[i] = 0.0, n = 0; n < nobs; n++)\n\t  v[i] += x[i][n] * (y[0][n] - y[1][n] * pr[n]);\n\t/* and the maximum entry in that vector */\n\tif ((tmp = fabs(v[i])) > maxv)\n\t  maxv = tmp;\n\t/* now compute X'Diag[ni pi(i)(1 - pi(i)]X; temporarily put in cov */\n\tfor (j = 0; j < nx; j++)\n\t  {\n\t    cov[i][j] = 0.0;\n\t    for (n = 0; n < nobs; n++)\n\t      cov[i][j] += y[1][n] * pr[n] * (1.0 - pr[n]) *\n\t\tx[i][n] * x[j][n];\n\t    /* and get the maximum entry in that matrix */\n\t    if ((tmp = fabs(cov[i][j])) > maxcov)\n\t      maxcov = tmp;\n\t  }\n      }\n    /* to deal with near-zero results from rounding */\n    for (i = 0; i < nx; i++)\n      {\n\tif (fabs(v[i]) < dap_ctol * maxv)\n\t  v[i] = 0.0;\n\tfor (j = 0; j < nx; j++)\n\t  {\n\t    if (fabs(cov[i][j]) < dap_ctol * maxcov)\n\t      cov[i][j] = 0.0;\n\t  }\n      }\n    if (!dap_invert(cov, nx))\n      {\n\tfputs(\"(irls) X'DX matrix is singular\\n\", dap_err);\n\texit(1);\n      }\n    /* compute change in the beta parameter array */\n    for (i = 0; i < nx; i++)\n      {\n\tstep[i] = 0.0;\n\tfor (j = 0; j < nx; j++)\n\t  step[i] += cov[i][j] * v[j];\n      }\n    for ( ; niter <= dap_maxiter; niter++)\n      {\n\t/* get tentative new beta parameter array */\n\tfor (i = 0; i < nx; i++)\n\t  beta1[i] = beta0[i] + step[i];\n\t/* compute corresponding new log likelihood */\n\tfor (n = 0, loglike1 = 0.0; n < nobs; n++)\n\t  {\n\t    for (pr[n] = 0.0, i = 0; i < nx; i++)\n\t      pr[n] += x[i][n] * beta1[i];\n\t    pr[n] = 1.0 / (1.0 + exp(-pr[n]));\n\t    loglike1 += y[0][n] * log(pr[n]) +\n\t      (y[1][n] - y[0][n]) * log(1.0 - pr[n]);\n\t  }\n\tif (loglike1 >= loglike0)\t/* if it's at least as good, quit */\n\t  break;\n\telse\t\t/* else halve the step size and try again */\n\t  {\n\t    for (i = 0; i < nx; i++)\n\t      step[i] *= 0.5;\n\t  }\n      }\n  } while (++niter <= dap_maxiter && vdiff(beta1, beta0, nx) > dap_ctol * vlen(beta0, nx));\n  if (niter > dap_maxiter)\n    fprintf(dap_lst, \"Failed to converge after %d iterations.\\n\", dap_maxiter);\n  dap_free(beta1, \"\");\n  dap_free(v, \"\");\n  dap_free(step, \"\");\n  return loglike0;\n}",
      "lines": 120,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "logreg1": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "void logreg1(\n\t     double **y,\t/* the response and number-of-cases variables */\n\t     double **x,\t/* array of x-vectors of data */\n\t     int nx0,\t/* number of explanatory x-variables in reduced model */\n\t     int nx,\t\t/* number of explanatory x-variables in full model */\n\t     int nobs,\t/* number of observations */\n\t     int *varv,\t/* array of variable indices for main dataset */\n\t     int *xvarv,\t/* array of variable indices for xname dataset */\n\t     int *markv,\t/* array of indices of partitioning variables in main dataset */\n\t     int *xmarkv,\t/* array of indices of partitioning variables in xname dataset */\n\t     int nmark,\t/* number of partitioning variables */\n\t     double level,\t/* confidence level for probabilities */\n\t     int param1n,\t/* for covariance dataset, index of parameter for \"row\" label */\n\t     int param2n,\t/* for covariance dataset, index of parameter for \"column\" label */\n\t     int covn,\t/* for covariance dataset, index of parameter for numerical value */\n\t     int partv[]\t/* array of indexes of partioning variables in covset */\n\t     )\n{\n  int typen;\t\t\t/* index of _type_ variable */\n  double *covmem;\t\t\t/* memory for covariance matrix */\n  double **cov;\t\t\t/* covariance matrix */\n  double *pr;\t\t\t/* array of estimated probabilities for data points */\n  double *beta;\t\t\t/* parameter vector */\n  int i, j;\n  double tmp, tmp2;\n  double loglike0, loglike1;\t/* current and next log likelihood values */\n  static double npt;\n  double xi, xj;\n  double logit;\n  double selogit;\n  int ntrials;\n  int v;\n\n  /* allocate memory for covariance matrix */\n  covmem = (double *) dap_malloc(sizeof(double) * dap_maxvar * dap_maxvar, \"\");\n  /* allocate and assign pointers for covariance matrix */\n  cov = (double **) dap_malloc(sizeof(double *) * dap_maxvar, \"\");\n  for (i = 0; i < dap_maxvar; i++)\n    cov[i] = covmem + i * dap_maxvar;\n  /* allocate parameter vector */\n  beta = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  /* get back to the part of the dataset we're working on */\n  dap_swap();\n  /* get index of _type_ variable */\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(logreg1) Missing _type_ variable.\\n\");\n      exit(1);\n    }\n  /* allocate probability array */\n  pr = (double *) dap_malloc(nobs * sizeof(double), \"\");\n  /* print out information on model */\n  fprintf(dap_lst, \"Reduced | full model regressors:\");\n  for (i = 0; i < nx0; i++)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[i]]);\n  fprintf(dap_lst, \" |\");\n  while (i < nx)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[i++]]);\n  putc('\\n', dap_lst);\n  fprintf(dap_lst, \"Number of observations = %d\\n\", nobs);\n  for (i =  0, ntrials = 0; i < nobs; i++)\n    ntrials += (int) rint(y[1][i]);\n  fprintf(dap_lst, \"Number of trials = %d\\n\", ntrials);\n  if (varv[nx + 1] >= 0)\n    fprintf(dap_lst, \"Events / Trials: %s / %s\\n\",\n\t    dap_obs[0].do_nam[varv[nx]],\n\t    dap_obs[0].do_nam[varv[nx + 1]]);\n  else\n    fprintf(dap_lst, \"Events / Trials: %s / %d\\n\",\n\t    dap_obs[0].do_nam[varv[nx]], -varv[nx + 1]);\n  /* run iterative reweighted least squares on reduced model */\n  loglike0 = irls(x, y, pr, beta, cov, nx0, nobs);\n  /* run iterative reweighted least squares on full model */\n  loglike1 = irls(x, y, pr, beta, cov, nx, nobs);\n  /* don't need probability array any more */\n  dap_free(pr, \"\");\n  /* now print results and output estimates and SEs, later output the covariance matrix */\n  dap_ono = 2;\n  /* set up partvars for covariance matrix dataset */\n  for (v = 0; v < nmark; v++)\n    {\n      if (dap_obs[0].do_len[markv[v]] == DBL)\n\tdap_obs[dap_ono].do_dbl[partv[v]] = dap_obs[0].do_dbl[markv[v]];\n      else if (dap_obs[0].do_len[markv[v]] == INT)\n\tdap_obs[dap_ono].do_int[partv[v]] = dap_obs[0].do_int[markv[v]];\n      else\n\tstrcpy(dap_obs[dap_ono].do_str[partv[v]],\n\t       dap_obs[0].do_str[markv[v]]);\n    }\n  fprintf(dap_lst, \"-2 (Lred - Lfull) = %.6g = ChiSq0[%d]\\n\",\n\t  tmp = -2.0 * (loglike0 - loglike1), nx - nx0);\n  fprintf(dap_lst, \"Prob[ChiSq > ChiSq0] = %.5f\\n\\n\",\n\t  0.00001 * ceil(100000.0 * probchisq(fabs(tmp), nx - nx0)));\n  fputs(\n\t\"  Parameter           Estimate    Std Error   Wald ChiSq  Prob[ChiSq>Wald ChiSq]\\n\",\n\tdap_lst);\n  for (i = 0; i < nx; i++)\n    {\n      tmp = sqrt(cov[i][i]);\n      tmp2 = beta[i] * beta[i] / cov[i][i];\n      fprintf(dap_lst, \"  %-15s %12.6g %12.6g %12.6g  %14.5f\\n\",\n\t      dap_obs[0].do_nam[varv[i]],\n\t      beta[i], tmp, tmp2,\n\t      0.00001 * ceil(100000.0 * probchisq(fabs(tmp2), 1)));\n      strcpy(dap_obs[dap_ono].do_str[typen], \"ESTIMATE\");\n      strcpy(dap_obs[dap_ono].do_str[param2n], dap_obs[0].do_nam[varv[i]]);\n      strcpy(dap_obs[dap_ono].do_str[param1n], \"\");\n      dap_obs[dap_ono].do_dbl[covn] = beta[i];\n      output();\n    }\n  /* now we write out the covariance matrix */\n  strcpy(dap_obs[dap_ono].do_str[typen], \"COVAR\");\n  /* \"rows\" are indexed by i */\n  for (i = 0; i < nx; i++)\n    {\n      strcpy(dap_obs[dap_ono].do_str[param1n], dap_obs[0].do_nam[varv[i]]);\n      /* \"columns\" are indexed by j */\n      for (j = 0; j < nx; j++)\n\t{\n\t  strcpy(dap_obs[dap_ono].do_str[param2n], dap_obs[0].do_nam[varv[j]]);\n\t  dap_obs[dap_ono].do_dbl[covn] = cov[i][j];\n\t  output();\n\t}\n    }\n  /* now back to .lgr output */\n  dap_ono = 0;\n  if (fabs(level) < 1.0)\n    npt = -zpoint(0.5 * (1.0 - level));\n  else\n    npt = 0.0;\n  dap_obs[0].do_dbl[varv[0]] = 1.0;\n  /* now compute predicted values */\n  if (xvarv[0] < 0)\n    {\n      dap_rewind();\n      step();\n    }\n  while (matchmark(markv, xmarkv, nmark, level))\n    {\n      dap_ono = 0;\n      if (xvarv[0] >= 0)\n\t{\n\t  for (i = 1; i < nx; i++)\n\t    dap_obs[0].do_dbl[varv[i]] = dap_obs[1].do_dbl[xvarv[i - 1]];\n\t}\n      for (logit = 0.0, i = 0; i < nx; i++)\n\tlogit += beta[i] * dap_obs[0].do_dbl[varv[i]];\n      for (selogit = 0.0, i = 0; i < nx; i++)\n\t{\n\t  xi = dap_obs[0].do_dbl[varv[i]];\n\t  for (j = 0; j < nx; j++)\n\t    {\n\t      xj = dap_obs[0].do_dbl[varv[j]];\n\t      selogit += xi * cov[i][j] * xj;\n\t    }\n\t}\n      selogit = sqrt(selogit);\n      strcpy(dap_obs[0].do_str[typen], \"PRED\");\n      dap_obs[0].do_dbl[varv[nx]] = 1.0 / (1.0 + exp(-logit));\n      output();\n      if (npt != 0.0)\n\t{\n\t  strcpy(dap_obs[0].do_str[typen], \"LOWER\");\n\t  dap_obs[0].do_dbl[varv[nx]] =\n\t    1.0 / (1.0 + exp(-logit + npt * selogit));\n\t  output();\n\t  strcpy(dap_obs[0].do_str[typen], \"UPPER\");\n\t  dap_obs[0].do_dbl[varv[nx]] =\n\t    1.0 / (1.0 + exp(-logit - npt * selogit));\n\t  output();\n\t}\n      if (xvarv[0] >= 0)\n\tdap_ono = 1;\n      dap_mark();\n      if (!step())\n\tbreak;\n    }\n  dap_ono = 0;\n  if (xvarv[0] >= 0)\n    dap_swap();\n  /* free allocated memory */\n  dap_free(covmem, \"\");\n  dap_free(cov, \"\");\n  dap_free(beta, \"\");\n}",
      "lines": 185,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "logreg": {
      "start_point": [
        1040,
        0
      ],
      "end_point": [
        1230,
        1
      ],
      "content": "void logreg(\n\t    char *fname,\t/* name of dataset */\n\t    char *yspec,\t/* specification of response */\n\t    char *x0list,\t/* list of explanatory x-variables in reduced model */\n\t    char *x1list,\t/* list of explanatory x-variables in rest of model */\n\t    char *marks,\t/* variables for partitioning the dataset */\n\t    char *xname,\t/* name of dataset containing x-values for reporting results */\n\t    double level\t/* level for confidence region */\n\t    )\n{\n  char *regname;\n  int *varv;\t\t/* array of variable indices */\n  int *xvarv;\t\t/* array of x-variable indices */\n  int nx0, nx1;\t\t/* number of explanatory x-variables in reduced, rest of model;\n\t\t\t * note that x0 always contains intercept\n\t\t\t */\n  int nx;\t\t\t/* number of all x-variables, including intercept */\n  int nxx;\t\t/* number of all x-variables in xname dataset */\n  int *markv;\t\t/* partitioning array for dataset */\n  int *xmarkv;\t\t/* partitioning array for xname dataset */\n  int nmark;\t\t/* number of partitioning variables */\n  double *xmem;\t\t/* memory for x-matrix */\n  double **x;\t\t/* the array of x-vectors */\n  double *ymem;\t\t/* memory for the array of corresponding y-values */\n  double *y[2];\t\t/* the array of corresponding y-values */\n  int v;\t\t\t/* index to array of variable indices */\n  int nobs;\t\t/* number of observations */\n  int more;\t\t/* more data to be read from dataset? (for partitioning) */\n  char *covset;\t\t/* name of dataset for covariance matrix */\n  int param1n, param2n, covn;\t/* indices to covset variables */\n  int paramlen1, paramlen;\t/* length and maximum length of parameter name */\n  char paramstr[14];\t/* string for declaring variable name variables */\n  char *partstr;\t\t/* for declaring part variables in covset */\n  int *partv;\t\t/* indexes of part variables for covset */\n\n  if (!fname)\n    {\n      fputs(\"(logreg) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  /* allocate arrays */\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  xvarv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  xmarkv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  partv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  /* allocate string for name of output dataset, 5 for \".reg\" with null */\n  regname = dap_malloc(strlen(fname) + 5, \"\");\n  /* and assign name */\n  dap_suffix(regname, fname, \".lgr\");\n  /* set of arrays of variables indices */\n  inset(fname);\n  /* allocate intercept variable */\n  dap_vd(\"_intercept_ -1\", 0);\n  /* find numbers of variables and assign indices to arrays */\n  nx0 = dap_list(\"_intercept_\", varv, dap_maxvar);\n  nx0 += dap_list(x0list, varv + 1, dap_maxvar);\n  nx1 = dap_list(x1list, varv + nx0, dap_maxvar);\n  /* total number of x-variables, including intercept */\n  nx = nx0 + nx1;\n  /* parse the y-specifications and assign their variable indices */\n  dap_parsey(yspec, varv + nx);\n  /* allocate memory of array of explanatory x-vectors */\n  xmem = (double *) dap_malloc(sizeof(double) * nx * dap_maxval, \"dap_maxval\");\n  /* and allocate and assign pointers */\n  x = (double **) dap_malloc(sizeof(double *) * nx, \"\");\n  for (v = 0; v < nx; v++)\n    x[v] = xmem + v * dap_maxval;\n  /* allocate array for response variable values */\n  ymem = (double *) dap_malloc(sizeof(double) * 2 * dap_maxval, \"dap_maxval\");\n  /* and assign pointers: y[0] for response variable, y[1] for number of cases */\n  y[0] = ymem;\n  y[1] = ymem + dap_maxval;\n  /* set up partitioning for main dataset */\n  nmark = dap_list(marks, markv, dap_maxvar);\n  /* do some bookkeeping for covariance dataset */\n  covset = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(covset, fname);\n  strcat(covset, \".cov\");\n  /* find maximum length of variable names */\n  for (v = 1, paramlen = strlen(\"_intercept_\"); v < nx; v++)\n    {\n      paramlen1 = strlen(dap_obs[dap_ono].do_nam[varv[v]]);\n      if (paramlen1 > paramlen)\n\tparamlen = paramlen1;\n    }\n  /* now set up variables for covariance dataset */\n  dap_ono = 2;\n  dap_clearobs((char *) NULL);    /* set up dap_obs, make _type_ variable */\n  /* this will bomb if a variable name is more than 99 characters long */\n  sprintf(paramstr, \"_param1_ %d\", paramlen);\n  param1n = dap_vd(paramstr, 0);\n  sprintf(paramstr, \"_param2_ %d\", paramlen);\n  param2n = dap_vd(paramstr, 0);\n  covn = dap_vd(\"_cov_ -1\", 0);\n  partstr = dap_malloc(strlen(marks) + 1, \"\");\n  for (v = 0; v < nmark; v++)\n    {\n      strcpy(partstr, dap_obs[0].do_nam[markv[v]]);\n      sprintf(partstr + strlen(partstr), \" %d\", dap_obs[0].do_len[markv[v]]);\n      partv[v] = dap_vd(partstr, 1);\n    }\n  outset(covset, \"\");\n  /* now switch to xname dataset */\n  dap_ono = 1;\n  if (xname && xname[0])\t/* if caller wants predicted values */\n    {\n      inset(xname);\n      /* find numbers of explanatory x-variables */\n      nxx = dap_list(x0list, xvarv, dap_maxvar);\n      nxx += dap_list(x1list, xvarv + nxx, dap_maxvar);\n      /* which had better match those of the main dataset */\n      if (nxx != nx - 1)\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(logreg) %s and %s have different numbers (%d and %d) of x-variables.\\n\",\n\t\t  fname, xname, nx - 1, nxx);\n\t  exit(1);\n\t}\n      if (nmark)\t/* cross-check partitioning of main and xname datasets */\n\t{\n\t  for (v = 0; v < nmark; v++)\n\t    {\n\t      if ((xmarkv[v] = dap_varnum(dap_obs[0].do_nam[markv[v]])) < 0)\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(logreg) Mark variable %s in %s not in %s.\\n\",\n\t\t\t  dap_obs[0].do_nam[markv[v]], fname, xname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      if (!step())\n\t{\n\t  fprintf(dap_err, \"(logreg) No data in %s.\\n\",\n\t\t  (xname[0] ? xname : fname));\n\t  exit(1);\n\t}\n    }\n  else\t\t/* caller doesn't want predicted values */\n    {\n      xvarv[0] = -1;\n      xmarkv[0] = -1;\n    }\n  /* back to main dataset */\n  dap_ono = 0;\n  outset(regname, \"\");\n  /* for each observation; use dap_mark for backing up in dataset */\n  for (nobs = 0, dap_mark(), more = 1; more; nobs++)\n    {\n      more = step();\t/* read line, if any */\n      if (dap_newpart(markv, nmark))\t/* if new part or end reached */\n\t{\n\t  dap_swap();\t/* print head for this part */\n\t  dap_head(markv, nmark);\n\t  dap_swap();\n\t  /* and run logistic regression on it */\n\t  logreg1(y, x, nx0, nx, nobs, varv, xvarv, markv, xmarkv, nmark, level,\n\t\t  param1n, param2n, covn, partv);\n\t  nobs = 0;\t/* clean slate for next part */\n\t}\n      if (nobs < dap_maxval)\t/* if room for more data... */\n\t{\n\t  x[0][nobs] = 1.0;\t/* this is the intercept, gets 1 in X matrix */\n\t  for (v = 1; v < nx; v++)\t/* read in x-values */\n\t    x[v][nobs] = dap_obs[dap_ono].do_dbl[varv[v]];\n\t  y[0][nobs] = dap_obs[dap_ono].do_dbl[varv[nx]];\t/* and y-values */\n\t  if (varv[nx + 1] >= 0)\t/* if number-of-cases variable exists, read it */\n\t    y[1][nobs] = dap_obs[dap_ono].do_dbl[varv[nx + 1]];\n\t  else\t\t\t/* else assign from constant give by parsey */\n\t    y[1][nobs] = -(double) varv[nx + 1];\n\t}\n      else\t\t/* ... or not */\n\t{\n\t  fputs(\"(logreg) Too many data.\\n\", dap_err);\n\t  exit(1);\n\t}\n    }\n  /* release all allocated memory */\n  dap_free(regname, \"\");\n  dap_free(varv, \"\");\n  dap_free(xvarv, \"\");\n  dap_free(markv, \"\");\n  dap_free(xmarkv, \"\");\n  dap_free(xmem, \"\");\n  dap_free(x, \"\");\n  dap_free(ymem, \"\");\n  dap_free(covset, \"\");\n  dap_free(partstr, \"\");\n  dap_free(partv, \"\");\n}",
      "lines": 191,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "valcmp1": {
      "start_point": [
        1237,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "static int valcmp1(value *v1, value *v2)\n{\n  if (v1->val_val < v2->val_val)\n    return -1;\n  if (v1->val_val > v2->val_val)\n    return 1;\n  return 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "probkol": {
      "start_point": [
        1246,
        0
      ],
      "end_point": [
        1262,
        1
      ],
      "content": "static double probkol(double d, double n)\n{\n  double lambda;\n  double l;\n  double k;\n  double term;\n  int sign;\n\n  if (d == 0.0)\n    return 0.0;\n  lambda = d * sqrt(n);\n  lambda *= -2.0 * lambda;\n  for (k = 1.0, l = 0.0, sign = 1;\n       (term = exp(k * k * lambda)) > dap_ktol; k += 1.0, sign = -sign)\n    l += (sign > 0 ? term : -term);\n  return 2.0 * l;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "nonpar1": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1533,
        1
      ],
      "content": "static void nonpar1(value *val, int nval, char **level,\n\t\t    int nlevels, int *varv, int nvar)\n{\n  int rank, ntied, tied;\n  int tottied;\n  double tiecorr;\n  double drank;\n  double dn;\n  double stat0, stat;\n  double prob;\n  int *levnobs;\n  int minnobs;\n  int *rank1;\n  int r;\n  int levn;\n  double *sumr;\n  double tmp, tmp1;\n  double kold;\n  int kolr;\n  double kolval;\n  double f[2];\n\n  tmp = 0.0;\n  tmp1 = 0.0;\n  kolr = 0;\n  kolval = 0.0;\n  dap_swap();\n  levnobs = (int *) dap_malloc(sizeof(int) * nlevels, \"\");\n  sumr = (double *) dap_malloc(sizeof(double) * nlevels, \"\");\n  rank1 = (int *) dap_malloc(sizeof(int) * dap_maxex2, \"dap_maxex2\");\n  dn = (double) nval;\n  if (nvar == 2)\n    {\n      qsort(val, nval, sizeof(value), pvalcmp1);\n      for (levn = 0; levn < nlevels; levn++)\n\tlevnobs[levn] = 0;\n      for (rank = 0; rank < nval; rank++)\n\tlevnobs[val[rank].val_class]++;\n      if (nlevels == 2)\n\t{\n\t  for (rank = 0, stat0 = 0.0, stat = 0.0, tottied = 0,\n\t\t tiecorr = 0.0, f[0] = 0.0, f[1] = 0.0,\n\t\t kold = 0.0; rank < nval; )\n\t    {\n\t      for (ntied = 1; rank + ntied < nval &&\n\t\t     fabs(val[rank + ntied].val_val - val[rank].val_val) <\n\t\t     dap_tol * (fabs(val[rank + ntied].val_val) + fabs(val[rank].val_val));\n\t\t   ntied++)\n\t\t;\n\t      drank = ((double) (2 * rank + ntied + 1)) / 2.0; \n\t      if (ntied > 1)\n\t\t{\n\t\t  tottied += ntied;\n\t\t  tiecorr += (double) (ntied * (ntied + 1) * (ntied - 1));\n\t\t}\n\t      for (tied = 0; tied < ntied; tied++, rank++)\n\t\t{\n\t\t  if (val[rank].val_class)\n\t\t    {\n\t\t      stat0 += drank;\n\t\t      f[1] += 1.0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      stat += drank;\n\t\t      f[0] += 1.0;\n\t\t    }\n\t\t  tmp1 = val[rank].val_val;\n\t\t  val[rank].val_val = drank;\n\t\t}\n\t      tmp = fabs(f[1] / ((double) levnobs[1]) - f[0] / ((double) levnobs[0]));\n\t      if (tmp > kold)\n\t\t{\n\t\t  kold = tmp;\n\t\t  kolr = rank;\n\t\t  kolval = tmp1;\n\t\t}\n\t    }\n\t  fprintf(dap_lst, \"\\nResponse: %s\\n\", dap_obs[0].do_nam[varv[0]]);\n\t  fprintf(dap_lst, \"Classified by %s:\", dap_obs[0].do_nam[varv[1]]);\n\t  for (r = 0; r < nlevels; r++)\n\t    fprintf(dap_lst, \" %s (%d)\", level[r], levnobs[r]);\n\t  putc('\\n', dap_lst);\n\t  fprintf(dap_lst, \"Number of tied observations = %d\\n\", tottied);\n\t  if (levnobs[0] < levnobs[1])\n\t    {\n\t      levn = 0;\n\t      stat0 = stat;\n\t    }\n\t  else\n\t    levn = 1;\n\t  fprintf(dap_lst, \"\\nWilcoxon rank sum statistic S0 (%s) = %g\\n\",\n\t\t  level[0], stat0);\n\t  fprintf(dap_lst, \"Expected under H0 = %g\\n\",\n\t\t  ((double) levnobs[levn]) * (dn + 1.0) / 2.0);\n\t  stat0 = fabs(stat0 - ((double) levnobs[levn]) * (dn + 1.0) / 2.0);\n\t  if (nval < dap_maxex2)\n\t    {\n\t      for (r = 0; r < levnobs[levn]; r++)\n\t\trank1[r] = r;\n\t      rank1[r] = nval;\n\t      for (prob = 0.0; ; )\n\t\t{\n\t\t  for (r = 0, stat = -((double) levnobs[levn]) * (dn + 1.0) / 2.0;\n\t\t       r < levnobs[levn]; r++)\n\t\t    stat += val[rank1[r]].val_val;\n\t\t  if (fabs(stat) >= stat0)\n\t\t    prob += 1.0;\n\t\t  for (r = levnobs[levn] - 1;\n\t\t       r >= 0 && rank1[r] + 1 == rank1[r + 1]; --r)\n\t\t    ;\n\t\t  if (r >= 0)\n\t\t    {\n\t\t      rank1[r]++;\n\t\t      for (r++; r < levnobs[levn]; r++)\n\t\t\trank1[r] = rank1[r - 1] + 1;\n\t\t    }\n\t\t  else\n\t\t    break;\n\t\t}\n\t      fprintf(dap_lst, \"Prob[|S - E(S)| >= |S0 - E(S)|] = %.4g (exact)\\n\",\n\t\t      prob / dap_bincoeff(dn, (double) levnobs[levn]));\n\t    }\n\t  else\n\t    {\n\t      if (stat0 >= 0.5)\n\t\tstat0 -= 0.5;\n\t      prob = 2.0 * (1.0 - probz(stat0 /\n\t\t\t\t\tsqrt(((double) (levnobs[0] * levnobs[1])) *\n\t\t\t\t\t     ((dn + 1.0) - tiecorr /\n\t\t\t\t\t      (dn * (dn - 1.0))) / 12.0)));\n\t      fprintf(dap_lst, \"Prob[|S - E(S)| >= |S0 - E(S)|] = %.4g\\n\", prob);\n\t      fputs(\"(normal approximation, with continuity correction)\\n\", dap_lst);\n\t    }\n\t  fprintf(dap_lst, \"\\nKolmogorov statistic D0 = %g\\n\", kold);\n\t  fprintf(dap_lst, \"Maximum deviation at %g for level %s\\n\",\n\t\t  kolval, level[val[kolr].val_class]);\n\t  fprintf(dap_lst, \"Prob[D >= D0] = %.4g\\n\",\n\t\t  probkol(kold, ((double) (levnobs[0] * levnobs[1])) / dn));\n\t}\n      else if (nlevels > 2)\n\t{\n\t  for (levn = 0; levn < nlevels; levn++)\n\t    sumr[levn] = 0.0;\n\t  for (rank = 0, tottied = 0, tiecorr = 0.0; rank < nval; )\n\t    {\n\t      for (ntied = 1; rank + ntied < nval &&\n\t\t     fabs(val[rank + ntied].val_val - val[rank].val_val) <\n\t\t     dap_tol * (fabs(val[rank + ntied].val_val) + fabs(val[rank].val_val));\n\t\t   ntied++)\n\t\t;\n\t      drank = ((double) (2 * rank + ntied + 1)) / 2.0; \n\t      if (ntied > 1)\n\t\t{\n\t\t  tottied += ntied;\n\t\t  tiecorr += (double) (ntied * (ntied + 1) * (ntied - 1));\n\t\t}\n\t      for (tied = 0; tied < ntied; tied++, rank++)\n\t\t{\n\t\t  sumr[val[rank].val_class] += drank;\n\t\t  val[rank].val_val = drank;\n\t\t}\n\t    }\n\t  for (stat0 = 0.0, levn = 0; levn < nlevels; levn++)\n\t    {\n\t      tmp = sumr[levn] / ((double) levnobs[levn]) - 0.5 * (dn + 1.0);\n\t      stat0 += tmp * tmp * (double) levnobs[levn];\n\t    }\n\t  stat0 *= 12.0 / (dn * (dn + 1.0) - tiecorr / (dn - 1.0));\n\t  fprintf(dap_lst, \"\\nResponse: %s\\n\", dap_obs[0].do_nam[varv[0]]);\n\t  fprintf(dap_lst, \"Classified by %s:\", dap_obs[0].do_nam[varv[1]]);\n\t  for (levn = 0, minnobs = levnobs[0]; levn < nlevels; levn++)\n\t    {\n\t      fprintf(dap_lst, \" %s (%d)\", level[levn], levnobs[levn]);\n\t      if (levnobs[levn] < minnobs)\n\t\tminnobs = levnobs[levn];\n\t    }\n\t  putc('\\n', dap_lst);\n\t  fprintf(dap_lst, \"Number of tied observations = %d\\n\", tottied);\n\t  fprintf(dap_lst, \"Kruskal-Wallis statistic T0 = %g\\n\", stat0);\n\t  prob = probchisq(stat0, nlevels - 1);\n\t  fprintf(dap_lst,\n\t\t  \"Prob[T >= T0] = %g (chi-squared approximation, df = %d)\\n\",\n\t\t  prob, nlevels - 1);\n\t  if ((nlevels == 3 && minnobs < 6) || minnobs < 5)\n\t    fputs(\n\t\t  \"Warning: sample may be too small for this approximation.\\n\",\n\t\t  dap_lst);\n\t}\n    }\n  else\n    {\n      fprintf(dap_lst, \"\\nResponse: %s\\n\", dap_obs[0].do_nam[varv[0]]);\n      fprintf(dap_lst, \"Number of non-zero observations = %d\\n\", nval);\n      qsort(val, nval, sizeof(value), pvalcmp1);\n      for (rank = 0, stat0 = 0.0, tottied = 0, tiecorr = 0, levnobs[0] = 0; rank < nval; )\n\t{\n\t  for (ntied = 1; rank + ntied < nval &&\n\t\t fabs(val[rank + ntied].val_val - val[rank].val_val) <\n\t\t dap_tol * (fabs(val[rank + ntied].val_val) + fabs(val[rank].val_val));\n\t       ntied++)\n\t    ;\n\t  drank = ((double) (2 * rank + ntied + 1)) / 2.0; \n\t  if (ntied > 1)\n\t    {\n\t      tottied += ntied;\n\t      tiecorr += ((double) (ntied * (ntied + 1) * (ntied - 1))) / 2.0;\n\t    }\n\t  for (tied = 0; tied < ntied; tied++, rank++)\n\t    {\n\t      if (val[rank].val_class)\n\t\t{\n\t\t  stat0 += drank;\n\t\t  levnobs[0]++;\n\t\t}\n\t      val[rank].val_val = drank;\n\t    }\n\t}\n      fprintf(dap_lst, \"Number of tied observations = %d\\n\", tottied);\n      fprintf(dap_lst, \"Number of positive observations = %d\\n\", levnobs[0]);\n      fprintf(dap_lst, \"\\nWilcoxon signed rank statistic W0 = %g\\n\", stat0);\n      fprintf(dap_lst, \"Expected under H0 = %g\\n\", (dn * (dn + 1.0)) / 4.0);\n      stat0 = fabs(stat0 - (dn * (dn + 1.0)) / 4.0);\n      if (nval <= dap_maxex1)\n\t{\n\t  for (rank = 0; rank < nval; rank++)\n\t    val[rank].val_class = 0;\n\t  prob = 0.0;\n\t  do\t{\n\t    for (rank = 0, stat = -(dn * (dn + 1.0)) / 4.0;\n\t\t rank < nval; rank++)\n\t      {\n\t\tif (val[rank].val_class)\n\t\t  stat += val[rank].val_val;\n\t      }\n\t    if (fabs(stat) >= stat0)\n\t      prob += 1.0;\n\t    for (rank = 0; rank < nval; rank++)\n\t      {\n\t\tif (!val[rank].val_class)\n\t\t  {\n\t\t    val[rank].val_class = 1;\n\t\t    break;\n\t\t  }\n\t\telse\n\t\t  val[rank].val_class = 0;\n\t      }\n\t  } while (rank < nval);\n\t  for (rank = 0; rank < nval; rank++)\n\t    prob /= 2.0;\n\t  fprintf(dap_lst, \"Prob[|W - E(W)| >= |W0 - E(W)|] = %.4g (exact)\\n\", prob);\n\t}\n      else\n\t{\n\t  prob = 2.0 *\n\t    probt(stat0 * sqrt((dn - 1.0) /\n\t\t\t       (dn * (dn * (dn + 1.0) * (2.0 * dn + 1.0) - tiecorr) /\n\t\t\t\t24.0 - stat0 * stat0)), nval - 1);\n\t  fprintf(dap_lst, \"Prob[|W - E(W)| >= |W0 - E(W)|] = %.4g\\n\", prob);\n\t  fprintf(dap_lst, \"(t-approximation, df = %d, with continuity correction)\\n\",\n\t\t  nval - 1);\n\t}\n    }\n  dap_free(levnobs, \"\");\n  dap_free(rank1, \"\");\n  dap_free(sumr, \"\");\n  dap_swap();\n}",
      "lines": 268,
      "depth": 28,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "findlev": {
      "start_point": [
        1535,
        0
      ],
      "end_point": [
        1554,
        1
      ],
      "content": "static int findlev(char *levname, char **level, int *nlevels)\n{\n  int l;\n\n  for (l = 0; l < *nlevels; l++)\n    {\n      if (!strcmp(levname, level[l]))\n\treturn l;\n    }\n  if (*nlevels < dap_maxlev)\n    {\n      strcpy(level[*nlevels], levname);\n      return (*nlevels)++;\n    }\n  else\n    {\n      fprintf(dap_err, \"(findlev) Too many levels (%s)\\n\", levname);\n      exit(1);\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nonparam": {
      "start_point": [
        1556,
        0
      ],
      "end_point": [
        1648,
        1
      ],
      "content": "void nonparam(char *fname, char *variables, char *marks)\n{\n  int varv[2];\n  int nvar;\n  int *markv;\n  int nmark;\n  value *val;\n  int nval;\n  int nobs;\n  char *levmem;\n  char **level;\n  int nlevels;\n  int more;\n\n  if (!fname)\n    {\n      fputs(\"(nonparam) No dataset name given.\\n\", dap_err);\n      exit(1);\n    }\n  markv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  levmem = dap_malloc(dap_maxlev * (dap_strlen + 1), \"dap_maxlev, dap_strlen\");\n  level = (char **) dap_malloc(sizeof(char *) * dap_maxlev, \"dap_maxlev\");\n  for (nlevels = 0; nlevels < dap_maxlev; nlevels++)\n    level[nlevels] = levmem + nlevels * (dap_strlen + 1);\n  inset(fname);\n  nvar = dap_list(variables, varv, dap_maxvar);\n  if (!nvar)\n    {\n      fputs(\"(nonparam) No variables specified.\\n\", dap_err);\n      exit(1);\n    }\n  if (nvar > 2)\n    {\n      fputs(\"(nonparam) At most one response and one class variable allowed\\n\", dap_err);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[varv[0]] != DBL)\n    {\n      fprintf(dap_err, \"(nonparam) Variable must be dap_double: %s\\n\",\n\t      dap_obs[0].do_nam[varv[0]]);\n      exit(1);\n    }\n  if (nvar == 2 && dap_obs[0].do_len[varv[1]] <= 0)\n    {\n      fprintf(dap_err, \"(nonparam) Classification variable must be dap_char: %s\\n\",\n\t      dap_obs[0].do_nam[varv[1]]);\n      exit(1);\n    }\n  nmark = dap_list(marks, markv, dap_maxvar);\n  val = (value *) dap_malloc(sizeof(value) * dap_maxval, \"dap_maxval\");\n  for (more = 1, nlevels = 0, nval = 0, nobs = 0; more; nobs++)\n    {\n      more = step();\n      if (dap_newpart(markv, nmark))\n\t{\n\t  dap_swap();\n\t  dap_head(markv, nmark);\n\t  dap_swap();\n\t  fprintf(dap_lst, \"Number of observations = %d\\n\", nobs);\n\t  nonpar1(val, nval, level, nlevels, varv, nvar);\n\t  if (!more)\n\t    break;\n\t  nval = 0;\n\t  nobs = 0;\n\t  nlevels = 0;\n\t}\n      if (nval >= dap_maxval)\n\t{\n\t  fputs(\"(nonparam) Too many values.\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (nvar == 2)\n\t{\n\t  val[nval].val_class =\n\t    findlev(dap_obs[0].do_str[varv[1]], level, &nlevels);\n\t  val[nval].val_val = dap_obs[0].do_dbl[varv[0]];\n\t  nval++;\n\t}\n      else\n\t{\n\t  if (dap_obs[0].do_dbl[varv[0]] != 0.0)\n\t    {\n\t      val[nval].val_class = (dap_obs[0].do_dbl[varv[0]] > 0.0);\n\t      val[nval].val_val = fabs(dap_obs[0].do_dbl[varv[0]]);\n\t      nval++;\n\t    }\n\t}\n    }\n  dap_free(val, \"\");\n  dap_free(markv, \"\");\n  dap_free(levmem, \"\");\n  dap_free(level, \"\");\n}",
      "lines": 93,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dap6.c": {
    "loglike": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static double loglike(double *selparam)\n{\n  int s;\n  int p;\n  double expected;\n  double ll;\n  int c;\n\n  for (s = 0, p = 0; sel[s]; s++)\n    {\n      if (sel[s] != '!')\n\tallparam[s] = selparam[p++];\n      else\n\tallparam[s] = 0.0;\n    }\n  for (ll = 0.0, c = 0; c < nc; c++)\n    {\n      expected = ex(allparam, tab[c] + 1);\t/* skip cell count */\n      ll += tab[c][0] * log(expected) - expected;\n    }\n  return ll;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "selparse": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int selparse(char *names, char *codes)\n{\n  int n;\t/* index to names */\n  int c;\t/* index to codes */\n\n  for (n = 0; names[n] == ' '; n++)\n    ;\n  for (c = 0; names[n]; c++)\n    {\n      if (names[n] == '!' || names[n] == '?')\n\t{\n\t  codes[c] = names[n];\n\t  for (++n; names[n] == ' '; n++)\n\t    ;\n\t}\n      else\n\tcodes[c] = '1';\n      while (names[n] && names[n] != ' ')\n\tn++;\n      while (names[n] == ' ')\n\tn++;\n    }\n  codes[c] = '\\0';\n  return c;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "categ1": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static void categ1(double **tab, int ncell, int *varv, int nvar,\n\t\t   double (*expect)(), double *param,\n\t\t   char *select, char *selcodes,\n\t\t   int param1n, int param2n, int covn,\n\t\t   int partv[], int partv2[], int npart, char *trace)\n{\n  int typen;\t/* index of _type_ variable */\n  int sparam;\t/* number of selected parameters */\n  int sparamr;\t/* number of selected parameters in reduced model */\n  int nparam;\t/* number of parameters */\n  int c, c1, c0;\t/* indexes to selection string */\n  double *x;\n  double *xch;\n  int p;\n  double step, tol;\n  double tmp;\n  int v;\n  double likerat;\n  double likered;\n  double pearson;\n  double *infomem;\t/* memory for information matrix */\n  double **info;\t\t/* information matrix */\n  int p1, p2;\n  double lpp, lpm, lmp, lmm;\n  double h, halfh;\n  int s, s1;\t/* indexes to info and covariance matrices */\n  int nonsing;\t/* info matrix non-singular? */\n\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fputs(\"(categ1) missing _type_ variable\\n\", dap_err);\n      exit(1);\n    }\n  sparamr = 0;\n  likered = 0.0;\n  nc = ncell;\n  ex = expect;\n  x = (double *) dap_malloc(sizeof(double) * strlen(sel), \"\");\n  xch = (double *) dap_malloc(sizeof(double) * strlen(sel), \"\");\n  if (selred)\n    {\n      sel = selred;\n      for (nparam = 0, sparamr = 0; sel[nparam]; nparam++)\n\t{\n\t  if (sel[nparam] != '!')\n\t    {\n\t      allparam[nparam] = param[nparam];\n\t      sparamr++;\n\t    }\n\t  else\n\t    allparam[nparam] = 0.0;\n\t}\n      for (p = 0, nparam = 0; sel[nparam]; nparam++)\n\t{\n\t  if (sel[nparam] != '!')\n\t    x[p++] = param[nparam];\n\t}\n      for (step = 0.0, p = 0; p < sparamr; p++)\n\t{\n\t  tmp = x[p];\n\t  step += tmp * tmp;\n\t}\n      if (step > 0.0)\n\tstep = 0.1 * sqrt(step);\n      else\n\tstep = 0.01;\n      tol = dap_cattol * step;\n      dap_maximize(&loglike, sparamr, x, step, tol, trace);\n      for (c = 0, likerat = 0.0; c < ncell; c++)\n\tlikered += (tab[c][0] + dap_addtozero) *\n\t  log((tab[c][0] + dap_addtozero) / expect(allparam, tab[c] + 1));\n      likered *= 2.0;\n    }\n  sel = selcodes;\n  for (nparam = 0, sparam = 0; sel[nparam]; nparam++)\n    {\n      if (sel[nparam] != '!')\n\t{\n\t  allparam[nparam] = param[nparam];\n\t  sparam++;\n\t}\n      else\n\tallparam[nparam] = 0.0;\n    }\n  for (p = 0, nparam = 0; sel[nparam]; nparam++)\n    {\n      if (sel[nparam] != '!')\n\tx[p++] = param[nparam];\n    }\n  for (step = 0.0, p = 0; p < sparam; p++)\n    {\n      tmp = x[p];\n      step += tmp * tmp;\n    }\n  if (step > 0.0)\n    step = 0.1 * sqrt(step);\n  else\n    step = 0.01;\n  tol = dap_cattol * step;\n  dap_maximize(&loglike, sparam, x, step, tol, trace);\n  for (c = 0, likerat = 0.0, pearson = 0.0; c < ncell; c++)\n    {\n      for (v = 0; v < nvar; v++)\n\tdap_obs[0].do_dbl[varv[v]] = tab[c][v];\n      strcpy(dap_obs[0].do_str[typen], \"OBS\");\n      output();\n      strcpy(dap_obs[0].do_str[typen], \"FIT\");\n      dap_obs[0].do_dbl[varv[0]] = expect(allparam, tab[c] + 1);\n      likerat += (tab[c][0] + dap_addtozero) *\n\tlog((tab[c][0] + dap_addtozero) / dap_obs[0].do_dbl[varv[0]]);\n      tmp = dap_obs[0].do_dbl[varv[0]] - tab[c][0];\n      pearson += tmp * tmp / dap_obs[0].do_dbl[varv[0]];\n      output();\n    }\n  likerat *= 2.0;\n  infomem = (double *) dap_malloc(sizeof(double) * sparam * sparam, \"\");\n  info = (double **) dap_malloc(sizeof(double *) * sparam, \"\");\n  for (p = 0; p < sparam; p++)\n    info[p] = infomem + p * sparam;\n  h = 0.0001;\n  halfh = h / 2.0;\n  for (p1 = 0; p1 < sparam; p1++)\n    {\n      for (p = 0; p < sparam; p++)\n\txch[p] = x[p];\n      lpm = loglike(xch);\n      xch[p1] += h;\n      lpp = loglike(xch);\n      xch[p1] = x[p1] - h;\n      lmm = loglike(xch);\n      info[p1][p1] = -(lpp - 2.0 * lpm + lmm) / (h * h);\n    }\n  for (p1 = 0; p1 < sparam; p1++)\n    for (p2 = 0; p2 < p1; p2++)\n      {\n\tfor (p = 0; p < sparam; p++)\n\t  xch[p] = x[p];\n\txch[p1] += halfh;\n\txch[p2] += halfh;\n\tlpp = loglike(xch);\n\txch[p1] = x[p1] - halfh;\n\tlmp = loglike(xch);\n\txch[p2] = x[p2] - halfh;\n\tlmm = loglike(xch);\n\txch[p1] = x[p1] + halfh;\n\tlpm = loglike(xch);\n\tinfo[p1][p2] = -(lpp - lpm - lmp + lmm) / (h * h);\n\tinfo[p2][p1] = info[p1][p2];\n      }\n  if (!(nonsing = dap_invert(info, sparam)))\n    fputs(\"(categ1) covariance matrix is singular\\n\", dap_err);\n  /* now print and output estimates and SEs, later output the covariance matrix */\n  dap_ono = 1;\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(categ1) output dataset has no _type_ variable\\n\");\n      exit(1);\n    }\n  for (v = 0; v < npart; v++)\n    {\n      if (dap_obs[0].do_len[partv[v]] == DBL)\n\tdap_obs[dap_ono].do_dbl[partv2[v]] = dap_obs[0].do_dbl[partv[v]];\n      else if (dap_obs[0].do_len[partv[v]] == INT)\n\tdap_obs[dap_ono].do_int[partv2[v]] = dap_obs[0].do_int[partv[v]];\n      else\n\tstrcpy(dap_obs[dap_ono].do_str[partv2[v]],\n\t       dap_obs[0].do_str[partv[v]]);\n    }\n  fputs(\"Maximum likelihood estimation\\n\\n\", dap_lst);\n  fprintf(dap_lst, \"Cell count: %s\\n\", dap_obs[0].do_nam[varv[0]]);\n  fputs(\"Class and aux variables:\", dap_lst);\n  for (v = 1; v < nvar; v++)\n    fprintf(dap_lst, \" %s\", dap_obs[0].do_nam[varv[v]]);\n  putc('\\n', dap_lst);\n  fputs(\"\\nStatistic              df      Prob\\n\", dap_lst);\n  fprintf(dap_lst, \"G2[Model]   = %6.2f  %3d    %.4f\\n\",\n\t  likerat, ncell - sparam,\n\t  ((ncell > sparam) ?\n\t   (ceil(10000.0 * probchisq(likerat, ncell - sparam)) / 10000.0) :\n\t   1.0));\n  if (selred)\n    {\n      fprintf(dap_lst, \"G2[Reduced] = %6.2f  %3d    %.4f\\n\",\n\t      likered, ncell - sparamr,\n\t      ceil(10000.0 * probchisq(likered, ncell - sparamr)) / 10000.0);\n      fprintf(dap_lst, \"G2[Diff]    = %6.2f  %3d    %.4f\\n\",\n\t      likered - likerat, sparam - sparamr,\n\t      ceil(10000.0 * probchisq(likered - likerat, sparam - sparamr)) / 10000.0);\n    }\n  fprintf(dap_lst, \"X2[Model]   = %6.2f  %3d    %.4f\\n\",\n\t  pearson, ncell - sparam,\n\t  ((ncell > sparam) ?\n\t   (ceil(10000.0 * probchisq(pearson, ncell - sparam)) / 10000.0) :\n\t   1.0));\n  putc('\\n', dap_lst);\n  fputs(\"    Estimate          ASE  Model  Parameter\\n\", dap_lst);\n  for (c = 0; select[c] == ' '; c++)\n    ;\n  for (p = 0, s = 0; p < nparam; p++)\n    {\n      fprintf(dap_lst, \"%12g \", allparam[p]);\n      if (sel[p] == '!')\n\tfputs(\"              \", dap_lst);\n      else\n\t{\n\t  if (nonsing)\n\t    fprintf(dap_lst, \"%12g  \", sqrt(info[s][s]));\n\t  else\n\t    fputs(\"           ?  \", dap_lst);\n\t}\n      switch (selcodes[p])\n\t{\n\tcase '1':\n\t  fprintf(dap_lst, \"  *    \");\n\t  break;\n\tcase '?':\n\t  fprintf(dap_lst, \"  ?    \");\n\t  for (++c; select[c] == ' '; c++)\n\t    ;\n\t  break;\n\tdefault:\n\t  fprintf(dap_lst, \"       \");\n\t  for (++c; select[c] == ' '; c++)\n\t    ;\n\t  break;\n\t}\n      for (p2 = 0; select[c] && select[c] != ' '; c++, p2++)\n\t{\n\t  putc(select[c], dap_lst);\n\t  dap_obs[dap_ono].do_str[param2n][p2] = select[c];\n\t}\n      dap_obs[dap_ono].do_str[param2n][p2] = '\\0';\n      while (select[c] == ' ')\n\tc++;\n      if (sel[p] != '!')\n\t{\n\t  strcpy(dap_obs[dap_ono].do_str[typen], \"ESTIMATE\");\n\t  strcpy(dap_obs[dap_ono].do_str[param1n], \"\");\n\t  dap_obs[dap_ono].do_dbl[covn] = allparam[p];\n\t  output();\n\t  s++;\n\t}\n      putc('\\n', dap_lst);\n    }\n  putc('\\n', dap_lst);\n  /* now output covariance matrix into dataset */\n  strcpy(dap_obs[dap_ono].do_str[typen], \"COVAR\");\n  for (c = 0; select[c] == ' '; c++)\n    ;\n  for (p = 0, s = 0; p < nparam; p++)\n    {\n      if (selcodes[p] != '1')\n\t{\n\t  for (++c; select[c] == ' '; c++)\n\t    ;\n\t}\n      while (select[c] == ' ')\n\tc++;\n      for (c1 = 0; select[c1] == ' '; c1++)\n\t;\n      for (p1 = 0, s1 = 0; p1 < nparam; p1++)\n\t{\n\t  if (sel[p] != '!' && sel[p1] != '!')\n\t    dap_obs[dap_ono].do_dbl[covn] = info[s][s1];\n\t  if (sel[p1] != '!')\n\t    s1++;\n\t  if (selcodes[p1] != '1')\n\t    {\n\t      for (++c1; select[c1] == ' '; c1++)\n\t\t;\n\t    }\n\t  if (sel[p] != '!' && sel[p1] != '!')\n\t    {\n\t      for (p2 = 0; select[c1] && select[c1] != ' '; c1++, p2++)\n\t\tdap_obs[dap_ono].do_str[param2n][p2] = select[c1];\n\t      dap_obs[dap_ono].do_str[param2n][p2] = '\\0';\n\t      c0 = c;\n\t      if (select[c0] == '?')\n\t\t{\n\t\t  for (c0++; select[c0] == ' '; c0++)\n\t\t    ;\n\t\t}\n\t      for (p2 = 0; select[c0] && select[c0] != ' '; c0++, p2++)\n\t\tdap_obs[dap_ono].do_str[param1n][p2] = select[c0];\n\t      dap_obs[dap_ono].do_str[param1n][p2] = '\\0';\n\t      output();\n\t    }\n\t  while (select[c1] == ' ')\n\t    c1++;\n\t}\n      while (select[c] && select[c] != ' ')\n\tc++;\n      if (sel[p] != '!')\n\ts++;\n    }\n  dap_ono = 0;\n  dap_free(x, \"\");\n  dap_free(xch, \"\");\n  dap_free(infomem, \"\");\n  dap_free(info, \"\");\n}",
      "lines": 301,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "categ": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "void categ(char *dname, char *varlist, char *auxvarlist, double (*expect)(),\n\t   double *param, char *select, char *part, char *trace)\n{\n  int p;\n  char *filset;\t/* name of dataset with no missing cells */\n  char *filarg;\t/* argument for dataset for FILL */\n  char *catset;\t/* name of dataset for tables of observed and fitted values */\n  char *covset;\t/* name of dataset for covariance matrix */\n  int param1n, param2n, covn;\t/* indices to covset variables */\n  int paramlen1, paramlen;\t/* length and maximum length of parameter name */\n  char paramstr[12];\t/* string for declaring parameter name variables */\n  char *partstr;\t/* for declaring part variables in covset */\n  int *varv;\n  int *partv, *partv2;\t/* indexes of part variables for catset and covset */\n  int ncvar; /* number of classification variables */\n  int navar; /* number of auxiliary variables */\n  int nvar; /* ncvar + navar */\n  int npart;\n  int more;\n  int nparam;\t/* number of parameters identified in select */\n  char *selcodes;\t/* string to hold '1', '!', '?' codes */\n  double *tabmem;\n  int v;\n  int ncell;\n  int s;\n\n  varv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  partv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  partv2 = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  filarg = dap_malloc(strlen(varlist) + strlen(part) + 8, \"\");\n  strcpy(filarg, \"FILL \");\n  for (s = 0; varlist[s] == ' '; s++)\n    ;\t/* skip leading blanks before count arg */\n  for (v = 5; varlist[s] && varlist[s] != ' '; )\n    filarg[v++] = varlist[s++];\t/* copy in count arg */\n  filarg[v++] = ':';\n  strcpy(filarg + v, part);\t/* part vars need to come first */\n  strcat(filarg, \" \");\n  strcat(filarg, varlist + s);\n  filset = dap_malloc(strlen(dname) + 5, \"\");\n  strcpy(filset, dname);\n  strcat(filset, \".fil\");\n  dataset(dname, filset, filarg);\n  catset = dap_malloc(strlen(dname) + 5, \"\");\n  strcpy(catset, dname);\n  strcat(catset, \".cat\");\n  covset = dap_malloc(strlen(dname) + 5, \"\");\n  strcpy(covset, dname);\n  strcat(covset, \".cov\");\n  /* find maximum length of parameter names */\n  for (s = 0, paramlen = 0; select[s]; )\n    {\n      while (select[s] == ' ' || select[s] == '?' || select[s] == '!')\n\ts++;\n      for (paramlen1 = 0; select[s] && select[s] != ' '; s++)\n\tparamlen1++;\n      if (paramlen1 > paramlen)\n\tparamlen = paramlen1;\n    }\n  dap_ono = 0;\n  inset(filset);\n  ncvar = dap_list(varlist, varv, dap_maxvar);\n  navar = dap_list(auxvarlist, varv + ncvar, dap_maxvar - ncvar);\n  nvar = ncvar + navar;\n  for (v = 1; v < nvar; v++)\n    {\n      if (dap_obs[0].do_len[varv[v]] != DBL)\n\t{\n\t  fprintf(dap_err, \"(categ) classification or auxiliary variable not of type double: %s\\n\",\n\t\t  dap_obs[0].do_nam[varv[v]]);\n\t  exit(1);\n\t}\n    }\n  npart = dap_list(part, partv, dap_maxvar);\n  /* now set up variables for covariance dataset */\n  dap_ono = 1;\n  dap_clearobs((char *) NULL);\t/* set up dap_obs, make _type_ variable */\n  /* this will bomb if a parameter name is more than 99 characters long */\n  sprintf(paramstr, \"_param1_ %d\", paramlen);\n  param1n = dap_vd(paramstr, 0);\n  sprintf(paramstr, \"_param2_ %d\", paramlen);\n  param2n = dap_vd(paramstr, 0);\n  covn = dap_vd(\"_cov_ -1\", 0);\n  partstr = dap_malloc(strlen(part) + 1, \"\");\n  for (v = 0; v < npart; v++)\n    {\n      strcpy(partstr, dap_obs[0].do_nam[partv[v]]);\n      sprintf(partstr + strlen(partstr), \" %d\", dap_obs[0].do_len[partv[v]]);\n      partv2[v] = dap_vd(partstr, 1);\n    }\n  outset(covset, \"\");\n  /* now back to catset */\n  dap_ono = 0;\n  outset(catset, \"\");\n  tabmem = (double *) dap_malloc(sizeof(double) * nvar * dap_maxcell, \"\");\n  tab = (double **) dap_malloc (sizeof(double *) * dap_maxcell, \"\");\n  for (ncell = 0; ncell < dap_maxcell; ncell++)\n    tab[ncell] = tabmem + ncell * nvar;\n  selcodes = dap_malloc(strlen(select) + 1, \"\");\n  nparam = selparse(select, selcodes);\n  allparam = (double *) dap_malloc(sizeof(double) * nparam, \"\");\n  sel = selcodes;\n  if (index(selcodes, '?'))\n    {\n      selred = dap_malloc(nparam + 1, \"\");\n      for (s = 0; selcodes[s]; s++)\n\t{\n\t  if (selcodes[s] == '?')\n\t    selred[s] = '!';\n\t  else\n\t    selred[s] = selcodes[s];\n\t}\n      selred[s] = '\\0';\n    }\n  else\n    selred = NULL;\n  for (p = 0; p < nparam; p++)\n    allparam[p] = param[p];\n  for (ncell = 0, more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(partv, npart))\n\t{\n\t  dap_swap();\n\t  dap_head(partv, npart);\n\t  categ1(tab, ncell, varv, nvar, expect, param, select, selcodes,\n\t\t param1n, param2n, covn, partv, partv2, npart, trace);\n\t  dap_swap();\n\t  ncell = 0;\n\t  for (p = 0; p < nparam; p++)\n\t    allparam[p] = param[p];\n\t}\n      if (more)\n\t{\n\t  if (ncell < dap_maxcell)\n\t    {\n\t      for (v = 0; v < nvar; v++)\n\t\ttab[ncell][v] = dap_obs[0].do_dbl[varv[v]];\n\t      ncell++;\n\t    }\n\t  else\n\t    {\n\t      fputs(\"(categ) too many cells\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t}\n    }\n  if (selred)\n    {\n      dap_free(selred, \"\");\n      selred = NULL;\n    }\n  dap_free(filarg, \"\");\n  dap_free(varv, \"\");\n  dap_free(partv, \"\");\n  dap_free(partv2, \"\");\n  dap_free(filset, \"\");\n  dap_free(catset, \"\");\n  dap_free(covset, \"\");\n  dap_free(partstr, \"\");\n  dap_free(tabmem, \"\");\n  dap_free(tab, \"\");\n  dap_free(allparam, \"\");\n  dap_free(selcodes, \"\");\n}",
      "lines": 165,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "llexpect": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        603,
        1
      ],
      "content": "static double llexpect(double *param, double *class)\n{\n  int p;\t\t/* parameter number for paramlist */\n  int c;\t\t/* class number for paramlist */\n  int neg[MAXCLASS];\t/* to take care of constraints/absence: neg[c] is 0 or 1\n\t\t\t * depending on whether class[c] == maxval[c], for constraints\n\t\t\t */\n  double sign;\t/* sign of term = 1.0 if even number of negs in term, -1.0 if odd */\n  int match;\t/* if class[c] not maxed out, did value of class[c] match term? */\n  double logc;\t/* log of expected count in cell */\n\n  /* incorporate constraints */\n  for (c = 0; c < nclass; c++)\n    neg[c] = (class[c] == maxval[c]);\n  /* param[0] is always mu */\n  for (logc = param[0], p = 1; p < numparam; p++)\n    {\n      for (sign = 1.0, match = 1, c = 0; c < nclass; c++)\n\t{\n\t  if (paramlist[p][c] >= 0)\t/* if class c in the term */\n\t    {\n\t      if (neg[c])\n\t\tsign *= -1.0;\n\t      else\n\t\tmatch &= (paramlist[p][c] == (int) class[c]);\n\t    }\n\t}\n      if (match)\n\tlogc += sign * param[p];\n    }\n  return exp(logc);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "findclass": {
      "start_point": [
        605,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int findclass(char *cname, char **class)\n{\n  int c;\t/* index to class */\n\n  for (c = 0; c < nclass; c++)\n    {\n      if (!strcmp(cname, class[c]))\n\treturn c;\n    }\n  return -1;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "llparse": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        751,
        1
      ],
      "content": "static int llparse(char **class, int nterm, unsigned int *pattern,\n\t\t   char *model0, char *model1, int *term)\n{\n  int classlen1;\t/* length of one class var name */\n  int classlen;\t/* max length of one class var name */\n  int nt;\t\t/* index to term */\n  int c;\t\t/* index to class */\n  int l;\t\t/* index to class list */\n  int cm;\t\t/* index to classmem */\n  char *oneclass;\t/* class var extracted from model */\n  int oneterm;\t/* bit pattern from term in model */\n  int m;\t\t/* index to model */\n  int t, t1;\t/* indexes to term */\n  int firstclass;\t/* for putting *'s in error message: first class found? */\n\n  for (c = 0, classlen = 0; c < nclass; c++)\n    {\n      if ((classlen1 = strlen(class[c])) > classlen)\n\tclasslen = classlen1;\n    }\n  oneclass = dap_malloc(classlen + 1, \"\");\n  /* now process terms in model1 */\n  for (t = 0; t < nterm; t++)\n    term[t] = 0;\n  nterm = 0;\t/* innocent until proven... */\n  for (m = 0; model1[m] == ' '; m++)\n    ;\n  for (oneterm = 0; model1[m]; )\n    {\n      for (c = 0; model1[m] && model1[m] != '*' && model1[m] != ' '; m++)\n\toneclass[c++] = model1[m];\n      oneclass[c] = '\\0';\n      while (model1[m] == ' ')\n\tm++;\n      c = findclass(oneclass, class);\n      if (c < 0)\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(llparse) Unknown class variable %s in model %s\\n\",\n\t\t  oneclass, model1);\n\t  exit(1);\n\t}\n      oneterm |= pattern[c];\n      if (model1[m] != '*')\t/* finished a term, record it */\n\t{\n\t  term[oneterm] = 1;\n\t  if (oneterm > nterm)\n\t    nterm = oneterm;\n\t  oneterm = 0;\n\t}\n      else\n\tm++;\n      while (model1[m] == ' ')\n\tm++;\n    }\n  /* now fill in the implicit terms for model1 */\n  /* now this could be seen as wasteful, but we are wasting so little... */\n  for (t1 = 0; t1 <= nterm; t1++)\n    {\n      if (term[t1])\n\t{\n\t  for (t = 0; t < nterm; t++)\n\t    {\n\t      if (!(t & ~t1))\n\t\tterm[t] = 1;\n\t    }\n\t}\n    }\n  /* now let's see who's in model0 also */\n  for (m = 0; model0[m] == ' '; m++)\n    ;\n  for (oneterm = 0; model0[m]; )\n    {\n      for (c = 0; model0[m] && model0[m] != '*' && model0[m] != ' '; m++)\n\toneclass[c++] = model0[m];\n      oneclass[c] = '\\0';\n      while (model0[m] == ' ')\n\tm++;\n      c = findclass(oneclass, class);\n      if (c < 0)\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(llparse) Unknown class variable %s in model %s\\n\",\n\t\t  oneclass, model0);\n\t  exit(1);\n\t}\n      oneterm |= pattern[c];\n      if (model0[m] != '*')\t/* finished a term, record it */\n\t{\n\t  if (!term[oneterm])\n\t    {\n\t      fputs(\"(llparse) Term in model0 (\", dap_err);\n\t      for (c = 0, firstclass = 1; c < nclass; c++)\n\t\t{\n\t\t  if (!(pattern[c] & ~oneterm))\n\t\t    {\n\t\t      if (firstclass)\n\t\t\tfirstclass = 0;\n\t\t      else\n\t\t\tfputs(\"*\", dap_err);\n\t\t      fprintf(dap_err, \"%s\", class[c]);\n\t\t    }\n\t\t}\n\t      fprintf(dap_err, \") not in in model1 (%s)\\n\", model1);\n\t      exit(1);\n\t    }\n\t  term[oneterm] = 2;\n\t  oneterm = 0;\n\t}\n      else\n\tm++;\n      while (model0[m] == ' ')\n\tm++;\n    }\n  /* now fill in the implicit terms for model0 */\n  /* now this could be seen as wasteful, but we are wasting so little... */\n  for (t1 = 0; t1 <= nterm; t1++)\n    {\n      if (term[t1] == 2)\n\t{\n\t  for (t = 0; t < nterm; t++)\n\t    {\n\t      if (!(t & ~t1))\n\t\tterm[t] = 2;\n\t    }\n\t}\n    }\n  dap_free(oneclass, \"\");\n  return nterm;\n}",
      "lines": 130,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "loglin": {
      "start_point": [
        764,
        0
      ],
      "end_point": [
        1293,
        1
      ],
      "content": "void loglin(char *fname, char *varlist, char *model0, char *model1, char *part)\n{\n  char *fnamefil;\t\t/* copy of fname with empty cells filled */\n  char *filarg;\t\t/* variable names for FILL */\n  char *fname1;\t\t/* copy of fname to use for categ, which requires doubles\n\t\t\t * instead of strings for classification variables\n\t\t\t */\n  char *catname;\t\t/* name of output file of categ, to copy back to fname1\n\t\t\t\t * to put strings back in for doubles\n\t\t\t\t */\n  char *varlist1;\t\t/* copy of varlist, with each name, except that of count var,\n\t\t\t\t * preceded by a '_'\n\t\t\t\t */\n  char *outlist;\t\t/* varlist for fname1 */\n  char *vardef;\t\t/* for calling dap_vd to declare varlist1 variables */\n  int nvar;\t\t/* number of vars in varlist */\n  int l, l1;\t\t/* indexes to varlist, varlist1 */\n  int vd;\t\t\t/* index to vardef */\n  int *classv;\t\t/* indexes of part and class vars in varlist and varlist1 */\n  int npart;\t\t/* number of part vars */\n  int c, cc;\t\t/* indexes to class arrays */\n  int nv;\t\t\t/* for stepping through class var list */\n  int coff;\t\t/* offset to class vars in varlist */\n  double *maxval1;\t/* to check that (external) maxval doesn't change between parts! */\n  int maxmaxval;\t\t/* max of maxvals */\n  int nvl;\t\t/* index to maxval1 and extern maxval */\n  int firstpart;\t\t/* flag: first part? */\n  int more;\t\t/* for stepping through dataset */\n  double oneval;\t\t/* temporary for convenience */\n  int *term;\t\t/* terms present in model0 and model1, either explicitly or\n\t\t\t * by default\n\t\t\t */\n  int nterm;\t\t/* number of terms in model1 */\n  double *param;\t\t/* parameters for model */\n  int termparam;\t\t/* number of params for one term */\n  int nparam0;\t\t/* tentative number of parameters, (external) numparam is actual */\n  char *classmem;\t\t/* memory for class array */\n  char **class;\t\t/* the names of the class variables */\n  int cm;\t\t\t/* index to classmem */\n  char *select;\t\t/* selection string for param */\n  int sellen;\t\t/* length of selection string */\n  int termlen;\t\t/* length of term in selection string */\n  char *selterm;\t\t/* one term of select */\n  int s;\t\t\t/* index to select */\n  int *sub;\t\t/* subscript */\n  unsigned int *pattern;\t/* list of bit patterns for class vars */\n  int t;\t\t\t/* index to terms */\n  int *paramlistmem;\t/* memory for (external) paramlist */\n  int p;\t\t\t/* index to (external) paramlist */\n  valnode **classval;\t/* linked lists of class values */\n  valnode **endcv;\t/* point to end of classval */\n  int *maxlen;\t\t/* max length of any class value */\n  int onelen;\t\t/* length of one class value */\n  char formstr[8];\t/* \"  %-xxs\" + '\\0' */\n  valnode *nodeptr;\t/* for stepping through node list */\n\n  fnamefil = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(fnamefil, fname);\n  strcat(fnamefil, \".fil\");\n  filarg = dap_malloc(strlen(varlist) + strlen(part) + 8, \"\");\n  strcpy(filarg, \"FILL \");\n  for (s = 0; varlist[s] == ' '; s++)\n    ;\t/* skip leading blanks before count arg */\n  for (l = 5; varlist[s] && varlist[s] != ' '; )\n    filarg[l++] = varlist[s++];\t/* copy in count arg */\n  filarg[l++] = ':';\n  strcpy(filarg + l, part);\t/* part vars need to come first */\n  strcat(filarg, \" \");\n  strcat(filarg, varlist + s);\n  dataset(fname, fnamefil, filarg);\n  fname1 = dap_malloc(strlen(fname) + 5, \"\");\n  strcpy(fname1, fname);\n  strcat(fname1, \".llm\");\n  catname = dap_malloc(strlen(fname1) + 5, \"\");\n  strcpy(catname, fname1);\n  strcat(catname, \".cat\");\n\n  /* count the vars so that we know how long to make varlist1 */\n  for (l = 0, nvar = 0; varlist[l]; )\n    {\n      while (varlist[l] == ' ')\n\tl++;\n      if (varlist[l])\n\t{\n\t  nvar++;\n\t  while (varlist[l] && varlist[l] != ' ')\n\t    l++;\n\t}\n    }\n  /* nclass is external */\n  nclass = nvar - 1;\n  /* don't need a +1 for varlist1 or outlist because first variable,\n   * the counts, doesn't need a '_'\n   */\n  varlist1 = dap_malloc(strlen(varlist) + nvar + 2, \"\");\n  outlist = dap_malloc(strlen(varlist) + nvar + strlen(part) + 2, \"\");\n  /* don't even need this much for vardef because we're going to\n   * declare one variable at a time with \" -1\", but definitely safe\n   */\n  vardef = dap_malloc(strlen(varlist) + 4, \"\");\n  classv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"dap_maxvar\");\n  /* classval[c] = pointer to first node in list of values for class var c */\n  classval = (valnode **) dap_malloc(sizeof(valnode *) * nclass, \"\");\n  endcv = (valnode **) dap_malloc(sizeof(valnode *) * nclass, \"\");\n  /* and maxlen[c] = max length of value for class var c */\n  maxlen = (int *) dap_malloc(sizeof(int) * nclass, \"\");\n\n  inset(fnamefil);\n\n  /* part vars go in outlist, not in varlist1 */\n  npart = dap_list(part, classv, dap_maxvar);\n  /* here comes the count variable */\n  for (l = 0; varlist[l] == ' '; l++)\n    ;\n  for (l1 = 0; varlist[l] && varlist[l] != ' '; )\n    {\n      varlist1[l1] = varlist[l];\n      outlist[l1++] = varlist[l++];\n    }\n  coff = l;\n  /* use varlist + coff to skip count var */\n  dap_list(varlist + coff, classv + npart, dap_maxvar - npart);\n  if (nclass > MAXCLASS)\n    {\n      fprintf(dap_err, \"(loglin) Number of classification variables (%d) exceeds %d.\\n\",\n\t      nclass, MAXCLASS);\n      exit(1);\n    }\n  /* check that count variable is of type double */\n  varlist1[l1] = '\\0';\t/* this is temporary */\n  if ((c = dap_varnum(varlist1)) < 0)\n    {\n      fprintf(dap_err, \"(loglin) Count variable %s unknown.\\n\", varlist1);\n      exit(1);\n    }\n  if (dap_obs[0].do_len[c] >= 0)\n    {\n      fprintf(dap_err, \"(loglin) Count variable %s not of type double.\\n\", varlist1);\n      exit(1);\n    }\n  /* check that class vars are all strings */\n  for (c = 0; c < nclass; c++)\n    {\n      if (dap_obs[0].do_len[classv[npart + c]] <= 0)\n\t{\n\t  fprintf(dap_err, \"(loglin) Classification variable %s not a string.\\n\",\n\t\t  dap_obs[0].do_nam[classv[npart + c]]);\n\t  exit(1);\n\t}\n    }\n  /* now the rest, leave space in classv for old class vars */\n\n  /* going to need class variable names as array */\n  classmem = dap_malloc(strlen(varlist + coff) + 1, \"\");\n  /* this is a bit wasteful of space, price for saving would be time */\n  class = (char **) dap_malloc(sizeof(char *) * nclass, \"\");\n\n  for (c = 0, cm = 0; varlist[l]; )\n    {\n      while (varlist[l] == ' ')\n\tl++;\n      if (varlist[l])\n\t{\n\t  varlist1[l1] = ' ';\n\t  outlist[l1++] = ' ';\n\t  varlist1[l1] = '_';\n\t  outlist[l1++] = '_';\n\t  vardef[0] = '_';\n\t  class[c] = classmem + cm;\n\t  for (vd = 1; varlist[l] && varlist[l] != ' '; l++)\n\t    {\n\t      classmem[cm++] = varlist[l];\n\t      vardef[vd++] = varlist[l];\n\t      varlist1[l1] = varlist[l];\n\t      outlist[l1++] = varlist[l];\n\t    }\n\t  vardef[vd] = '\\0';\n\t  classmem[cm++] = '\\0';\n\t  strcat(vardef, \" -1\");\n\t  classv[npart + nclass + c++] = dap_vd(vardef, 0);\n\t}\n    }\n  varlist1[l1] = '\\0';\n  outlist[l1] = '\\0';\n  strcat(outlist, \" \");\n  strcat(outlist, part);\n\n  outset(fname1, outlist);\n\n  maxval = (double *) dap_malloc(sizeof(double) * nclass, \"\");\n  maxval1 = (double *) dap_malloc(sizeof(double) * nclass, \"\");\n  for (nvl = 0; nvl < nclass; nvl++)\n    maxval1[nvl] = 0.0;\n  /* have to convert string classification into double for categ\n   * and later print out a translation table for the class var values, too.\n   */\n  for (c = 0; c < nclass; c++)\n    {\n      dap_obs[0].do_dbl[classv[npart + nclass + c]] = 0.0;\n      maxlen[c] = 0;\n      classval[c] = NULL;\n    }\n  for (firstpart = 1, more = 1; more; )\n    {\n      more = step();\n      /* first check if maxval changes between parts */\n      if (dap_newpart(classv, npart))\t/* new part */\n\t{\n\t  /* record maxval for first part */\n\t  if (firstpart)\n\t    {\n\t      for (nvl = 0; nvl < nclass; nvl++)\n\t\tmaxval[nvl] = maxval1[nvl];\n\t      firstpart = 0;\n\t    }\n\t  else\t/* else check for changes */\n\t    {\n\t      for (nvl = 0; nvl < nclass; nvl++)\n\t\t{\n\t\t  if (maxval[nvl] != maxval1[nvl])\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(loglin) Variable %s has different numbers of levels in different parts of dataset %s\\n\",\n\t\t\t      dap_obs[0].do_nam[classv[npart + nvl]],\n\t\t\t      fname);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t  for (nvl = 0; nvl < nclass; nvl++)\n\t    {\n\t      maxval1[nvl] = 0.0;\n\t      dap_obs[0].do_dbl[classv[npart + nclass + nvl]] = 0.0;\n\t    }\n\t}\n      /* now update number of values; nv is the number of variables, not the index */\n      if (more)\n\t{\n\t  if (dap_newpart(classv, npart))\t/* first record of new part */\n\t    nv = nclass + 1;\t/* fake it by setting nv */\n\t  else\n\t    {\n\t      for (nv = 1; nv <= nclass; nv++)\n\t\t{\n\t\t\t\t/* partition on part vars and old class vars */\n\t\t  if (dap_newpart(classv, npart + nv))\n\t\t    break;\n\t\t}\n\t    }\n\t  /* at this point, nv - 1 is the index of the one that has new value,\n\t   * except if nv - 1 == nclass, it's first record of dataset\n\t   */\n\t  if (nv <= nclass)\t/* not first record of dataset */\n\t    {\n\t      /* increment new class vars */\n\t      dap_obs[0].do_dbl[classv[npart + nclass + nv - 1]] += 1.0;\n\t      oneval = dap_obs[0].do_dbl[classv[npart + nclass + nv - 1]];\n\t      if (oneval > 99.0)\n\t\t{\n\t\t  fprintf(dap_err, \"(loglin) Number of levels (%g) for %s exceeds maximum (100)\\n\",\n\t\t\t  oneval + 1.0,\n\t\t\t  dap_obs[0].do_nam[classv[npart + nclass + nv - 1]]);\n\t\t  exit(1);\n\t\t}\n\t      if (oneval > maxval1[nv - 1])\t/* got a new one */\n\t\t{\n\t\t  maxval1[nv - 1] = oneval;\n\t\t  onelen = strlen(dap_obs[0].do_str[classv[npart + nv - 1]]);\n\t\t  if (onelen > maxlen[nv - 1])\n\t\t    maxlen[nv - 1] = onelen;\n\t\t  if (firstpart)\n\t\t    {\t/* already got first nodes */\n\t\t      endcv[nv - 1]->next = (valnode *)\n\t\t\tdap_malloc(sizeof(valnode), \"\");\n\t\t      endcv[nv - 1] = endcv[nv - 1]->next;\n\t\t      endcv[nv - 1]->value = dap_malloc(onelen + 1, \"\");\n\t\t      endcv[nv - 1]->next = NULL;\n\t\t      strcpy(endcv[nv - 1]->value,\n\t\t\t     dap_obs[0].do_str[classv[npart + nv - 1]]);\n\t\t    }\n\t\t}\n\t    }\n\t  else if (firstpart)\t\t/* is first record */\n\t    {\n\t      for (nvl = 0; nvl < nclass; nvl++)\n\t\t{\n\t\t  classval[nvl] = (valnode *) dap_malloc(sizeof(valnode), \"\");\n\t\t  endcv[nvl] = classval[nvl];\n\t\t  onelen = strlen(dap_obs[0].do_str[classv[npart + nvl]]);\n\t\t  if (onelen > maxlen[nvl])\n\t\t    maxlen[nvl] = onelen;\n\t\t  endcv[nvl]->value = dap_malloc(onelen + 1, \"\");\n\t\t  endcv[nvl]->next = NULL;\n\t\t  strcpy(endcv[nvl]->value,\n\t\t\t dap_obs[0].do_str[classv[npart + nvl]]);\n\t\t}\n\t    }\n\t  for (c = nv; c < nclass; c++)\n\t    {\n\t      if (dap_obs[0].do_dbl[classv[npart + nclass + c]] !=\n\t\t  maxval1[c])\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(loglin) Variable %s has different numbers of levels\\n\",\n\t\t\t  dap_obs[0].do_nam[classv[npart + c]]);\n\t\t  exit(1);\n\t\t}\n\t      dap_obs[0].do_dbl[classv[npart + nclass + c]] = 0.0;\n\t    }\n\t  output();\n\t}\n    }\n\n  /* now show numerical values of class var values */\n  dap_head(NULL, 0);\n  fputs(\"Loglinear model:\\nnumerical indexes of classification variables\\n\\n\", dap_lst);\n  fputs(\"Number\", dap_lst);\n  for (maxmaxval = 0, c = 0; c < nclass; c++)\n    {\n      onelen = strlen(class[c]);\n      if (maxlen[c] < onelen)\n\tmaxlen[c] = onelen;\n      sprintf(formstr, \"  %%-%ds\", maxlen[c]);\n      fprintf(dap_lst, formstr, class[c]);\n      if (((int) maxval[c]) > maxmaxval)\n\tmaxmaxval = ((int) maxval[c]);\n    }\n  putc('\\n', dap_lst);\n  fputs(\"------\", dap_lst);\n  for (c = 0; c < nclass; c++)\n    {\n      putc(' ', dap_lst);\n      putc(' ', dap_lst);\n      for (cc = 0; cc < maxlen[c]; cc++)\n\tputc('-', dap_lst);\n      /* this is so we can preserve classval for later */\n      endcv[c] = classval[c];\n    }\n  putc('\\n', dap_lst);\n  for (cc = 0; cc <= maxmaxval; cc++)\n    {\n      fprintf(dap_lst, \"%6d\", cc + 1);\n      for (c = 0; c < nclass; c++)\n\t{\n\t  if (endcv[c])\n\t    {\n\t      sprintf(formstr, \"  %%-%ds\", maxlen[c]);\n\t      fprintf(dap_lst, formstr, endcv[c]->value);\n\t      endcv[c] = endcv[c]->next;\n\t    }\n\t  else\n\t    {\n\t      sprintf(formstr, \"  %%%ds\", maxlen[c]);\n\t      fprintf(dap_lst, formstr, \"\");\n\t    }\n\t}\n      putc('\\n', dap_lst);\n    }\n  putc('\\n', dap_lst);\n\n  for (nterm = 1, nv = 0; nv < nclass; nv++)\n    nterm *= 2;\n  term = (int *) dap_malloc(sizeof(int) * nterm, \"\");\n  pattern = (int *) dap_malloc(sizeof(int) * nclass, \"\");\n  for (c = 1, pattern[0] = 1; c < nclass; c++)\n    pattern[c] = 2 * pattern[c - 1];\n  nterm = llparse(class, nterm, pattern, model0, model1, term);\n  /* Start with _mu, which is why sellen starts at 5: \"_mu \" and for final '\\0'. */\n  for (nparam0 = 1, sellen = 5, t = 1; t <= nterm; t++)\n    {\n      if (term[t])\n\t{\n\t  for (termparam = 1, c = 0, termlen = 0; c < nclass; c++)\n\t    {\n\t      if (!(pattern[c] & ~t))\n\t\t{\n\t\t  termparam *= (int) maxval[c];\n\t\t\t\t/* + 4 for ':' and '*' and 2 digits */\n\t\t  termlen += strlen(class[c]) + 4;\n\t\t}\n\t    }\n\t  nparam0 += termparam;\n\t  /* + 2 allows for space, and possible '?'\n\t   */\n\t  sellen += termparam * (termlen + 2);\n\t}\n    }\n  param = (double *) dap_malloc(sizeof(double) * nparam0, \"\");\n  paramlistmem = (int *) dap_malloc(sizeof(int) * nparam0 * nclass, \"\");\n  /* paramlist is external */\n  paramlist = (int **) dap_malloc(sizeof(int *) * nparam0, \"\");\n  for (p = 0; p < nparam0; p++)\n    paramlist[p] = paramlistmem + p * nclass;\n  select = dap_malloc(sellen, \"\");\n  selterm = dap_malloc(sellen, \"\");\t/* overkill, but so what? */\n  /* now go back and create select string */\n  sub = (int *) dap_malloc(sizeof(int) * nclass, \"\");\n  /* param[0] is always mu; start numparam at 0 because we increment when\n   * we find a term, not afterward\n   */\n  for (t = 1, strcpy(select, \"_mu\"), numparam = 0; t <= nterm; t++)\n    {\n      selterm[0] = ' ';\n      selterm[1] = ' ';\n      if (term[t])\n\t{\n\t  if (term[t] == 2 || !model0[0])\n\t    selterm[1] = ' ';\n\t  else\n\t    selterm[1] = '?';\n\t  selterm[2] = '\\0';\n\t  for (c = 0; c < nclass; c++)\n\t    {\n\t      if (!(pattern[c] & ~t))\n\t\t{\n\t\t  if (!selterm[2])\n\t\t    strcat(selterm, class[c]);\n\t\t  else\n\t\t    {\n\t\t      strcat(selterm, \"*\");\n\t\t      strcat(selterm, class[c]);\n\t\t    }\n\t\t}\n\t    }\n\t  /* now we got the term, need subscripts */\n\t  for (c = 0; c < nclass; c++)\n\t    sub[c] = 1;\n\t  do\t{\n\t    numparam++;\n\t    strcat(select, selterm);\n\t    for (cc = 0; cc < nclass; cc++)\n\t      {\n\t\tif (!(pattern[cc] & ~t))\n\t\t  {\n\t\t    strcat(select, \":\");\n\t\t    sprintf(select + strlen(select), \"%d\", sub[cc]);\n\t\t    paramlist[numparam][cc] = sub[cc] - 1;\n\t\t  }\n\t\telse\n\t\t  paramlist[numparam][cc] = -1;\n\t      }\n\t    for (c = nclass - 1; c >= 0; c--)\n\t      {\n\t\tif (!(pattern[c] & ~t) && sub[c] < (int) maxval[c])\n\t\t  {\n\t\t    sub[c]++;\n\t\t    for (cc = c + 1; cc < nclass; cc++)\n\t\t      sub[cc] = 1;\n\t\t    break;\n\t\t  }\n\t      }\n\t  } while (c >= 0);\n\t}\n    }\n  numparam++;\t/* to give count instead of highest number */\n  param[0] = 1.0;\n  for (p = 1; p < numparam; p++)\n    param[p] = 0.0;\n\n  categ(fname1, varlist1, \"\", &llexpect, param, select, part, \"\");\n\n  /* tables are now in catname, going to copy back to fname1 and\n   * translate the numerical values back to strings.\n   */\n\n  inset(catname);\n  /* first need to declare the class vars without the leading '_' */\n  /* OK, so maxlen may be larger than necessary at this point because\n   * it was possibly increased to accomodate class var name for table.\n   */\n  for (c = 0; c < nclass; c++)\n    {\n      strcpy(vardef, class[c]);\n      sprintf(vardef + strlen(vardef), \" %d\", maxlen[c]);\n      classv[c] = dap_vd(vardef, 0);\n    }\n\n  outset(fname1, \"\");\n\n  /* need to get indices of numerical class vars; classv has dap_maxvar slots */\n  /* +1 because I'm too lazy to skip the count variable */\n  dap_list(varlist1, classv + nclass, nclass + 1);\n\n  while (step())\n    {\n      for (c = 0; c < nclass; c++)\n\t{\n\t  for (nodeptr = classval[c], nvl = 0;\n\t       nvl < (int) dap_obs[0].do_dbl[classv[nclass + 1 + c]];\n\t       nvl++)\n\t    nodeptr = nodeptr->next;\n\t  strcpy(dap_obs[0].do_str[classv[c]], nodeptr->value);\n\t}\n      output();\n    }\n\n  dap_free(fnamefil, \"\");\n  dap_free(filarg, \"\");\n  dap_free(fname1, \"\");\n  dap_free(catname, \"\");\n  dap_free(varlist1, \"\");\n  dap_free(outlist, \"\");\n  dap_free(vardef, \"\");\n  dap_free(classv, \"\");\n  dap_free(maxval, \"\");\n  dap_free(maxval1, \"\");\n  dap_free(term, \"\");\n  dap_free(param, \"\");\n  dap_free(select, \"\");\n  dap_free(selterm, \"\");\n  dap_free(sub, \"\");\n  dap_free(classmem, \"\");\n  dap_free(class, \"\");\n  dap_free(pattern, \"\");\n  dap_free(paramlistmem, \"\");\n  dap_free(paramlist, \"\");\n  for (c = 0; c < nclass; c++)\n    {\n      while (classval[c])\n\t{\n\t  dap_free(classval[c]->value, \"\");\n\t  endcv[c] = classval[c]->next;\n\t  dap_free(classval[c], \"\");\n\t  classval[c] = endcv[c];\n\t}\n    }\n  dap_free(classval, \"\");\n  dap_free(endcv, \"\");\n  dap_free(maxlen, \"\");\n}",
      "lines": 530,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "findparam": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "static int findparam(char *pname, char *param[], int nparam)\n{\n  int p;\n\n  for (p = 0; p < nparam; p++)\n    {\n      if (!strcmp(pname, param[p]))\n\treturn p;\n    }\n  return -1;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "estimate": {
      "start_point": [
        1311,
        0
      ],
      "end_point": [
        1601,
        1
      ],
      "content": "void estimate(char *fname, char *parameters, char *definitions, char *part)\n{\n  char *parammem;       /* memory to hold parameter names */\n  char **param;\t\t/* pointers to parameter names */\n  int start, end;\t/* for stepping through 'definitions' */\n  int nparam;\t\t/* number of parameters */\n  int p, p1;\t\t/* index to parameter arrays */\n  int defstate;\t\t/* 0 = new def, 1 = got '=' */\n  double *defmem;\t/* memory for def */\n  double **def;\t\t/* definition for each parameter: each entry contains the\n                         * coefficient for the parameter in the def or 0 if not in the def\n\t\t\t */\n  double coeff;\t\t/* coefficient of def entry */\n  double sign;\t\t/* sign of the coefficient */\n  double place;\t\t/* for conversion from string to double */\n  int pnum1, pnum2, pnum3;\t/* parameter numbers */\n  int defnum;\t\t/* number of parameter being defined */\n  int ninput;\t\t/* number of parameters to read in */\n  double *estimate;\t/* vector of estimates */\n  double *covmem;\t/* memory for covariance matrix */\n  double **cov;\t\t/* covariance matrix */\n  int typen, param1n, param2n, covn;\t/* indices of input variables */\n  int more;\t\t/* for checking if there are more data lines to read in */\n  int *partv;\t\t/* indices of the partitioning variables */\n  int npart;\t\t/* number of partitioning variables */\n\n  parammem = dap_malloc(strlen(parameters) + strlen(definitions) + 1, \"\");\n  /* divide by 2 because params are separated; almost always still too many */\n  /* this is just (an overestimate of) the max, not the real nparam */\n  nparam = (strlen(parameters) + strlen(definitions)) / 2;\n  param = (char **) dap_malloc(sizeof(char *) * nparam, \"\");\n  defmem = (double *) dap_malloc(sizeof(double) * nparam * nparam, \"\");\n  def = (double **) dap_malloc(sizeof(double *) * nparam, \"\");\n  for (p = 0; p < nparam; p++)\n    {\n      def[p] = defmem + p * nparam;\n      for (p1 = 0; p1 < nparam; p1++)\n\tdef[p][p1] = 0.0;\t/* clear them all to start */\n    }\n  /* get parameter names from 'parameters' */\n  for (start = 0; parameters[start] == ' '; start++)\n    ;\n  for (nparam = 0, p = 0; parameters[start]; start = end)\n    {\n      /* tentatively copy param from 'parameters' to param list */\n      param[nparam++] = parammem + p;\n      for (end = start; parameters[end] && parameters[end] != ' '; )\n\tparammem[p++] = parameters[end++];\n      parammem[p++] = '\\0';\n      while (parameters[end] == ' ')\n\tend++;\n    }\n  ninput = nparam;\n  /* now get parameter names from 'definitions' */\n  for (start = 0; definitions[start] == ' '; start++)\n    ;\t/* get to first parameter */\n  for (defstate = 0; definitions[start]; start = end)\n    {\n      /* tentatively copy param from definition to param list */\n      param[nparam] = parammem + p;\n      if (definitions[start] == '+' || definitions[start] == '-')\n\t{\n\t  sign = 2.0 * ((double) (definitions[start] == '+')) - 1.0;\n\t  for (start++; definitions[start] == ' '; start++)\n\t    ;\n\t}\n      if (definitions[start] == '.' ||\n\t  ('0' <= definitions[start] && definitions[start] <= '9'))\n\t{\n\t  for (coeff = 0.0, place = 0.0;\n\t       definitions[start] == '.' ||\n\t\t ('0' <= definitions[start] && definitions[start] <= '9');\n\t       start++)\n\t    {\n\t      if (definitions[start] == '.')\n\t\t{\n\t\t  if (place > 0.0)\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(estimate) bad coefficient in definition: %s\\n\",\n\t\t\t      definitions + start);\n\t\t      exit(1);\n\t\t    }\n\t\t  else\n\t\t    place = 1.0;\n\t\t}\n\t      else\n\t\t{\n\t\t  coeff = 10.0 * coeff + (double) (definitions[start] - '0');\n\t\t  if (place > 0.0)\n\t\t    place *= 10.0;\n\t\t}\n\t    }\n\t  coeff *= sign;\n\t  if (place > 0.0)\n\t    coeff /= place;\n\t  while (definitions[start] == ' ')\n\t    start++;\n\t}\n      else\n\tcoeff = sign;\n      for (end = start;\n\t   definitions[end] && definitions[end] != ' ' &&\n\t     definitions[end] != '=' && definitions[end] != '+' &&\n\t     definitions[end] != '-'; )\n\tparammem[p++] = definitions[end++];\n      parammem[p++] = '\\0';\n      if ((pnum1 = findparam(param[nparam], param, nparam)) < 0)\t/* it's new */\n\tnparam++;\t/* count it */\n      else\n\tp = param[nparam] - parammem;\t/* reset p */\n      while (definitions[end] == ' ')\n\tend++;\n      switch (defstate)\n\t{\n\tcase 0:\t\t/* new definition */\n\t  if (definitions[end] == '=')\n\t    {\n\t      defstate = 1;\n\t      for (end++; definitions[end] == ' '; end++)\n\t\t;\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(estimate) definition starting at %s missing an =\\n\",\n\t\t      definitions + start);\n\t      exit(1);\n\t    }\n\t  defnum = nparam - 1;\n\t  sign = 1.0;\t/* default for first parameter in definition */\n\t  break;\n\tcase 1:\n\t  if (pnum1 < 0)\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(estimate) undefined parameter %s in definition\\n\",\n\t\t      param[nparam - 1]);\n\t      exit(1);\n\t    }\n\t  if (sign == 0.0)\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(estimate) missing sign or coefficient for parameter %s in definition\\n\",\n\t\t      param[nparam - 1]);\n\t      exit(1);\n\t    }\n\t  def[defnum][pnum1] = coeff;\n\t  if (definitions[end] != '+' && definitions[end] != '-')\n\t    /* end of definition */\n\t    defstate = 0;\n\t  sign = 0.0;\n\t  break;\n\t}\n    }\n  estimate = (double *) dap_malloc(sizeof(double) * nparam, \"\");\n  covmem = (double *) dap_malloc(sizeof(double) * nparam * nparam, \"\");\n  cov = (double **) dap_malloc(sizeof(double *) * nparam, \"\");\n  for (p = 0; p < nparam; p++)\n    cov[p] = covmem + nparam * p;\n  inset(fname);\n  if ((typen = dap_varnum(\"_type_\")) < 0)\n    {\n      fprintf(dap_err, \"(estimate) missing _type_ variable in dataset %s\\n\", fname);\n      exit(1);\n    }\n  if ((param1n = dap_varnum(\"_param1_\")) < 0)\n    {\n      fprintf(dap_err, \"(estimate) missing _param1_ variable in dataset %s\\n\", fname);\n      exit(1);\n    }\n  if ((param2n = dap_varnum(\"_param2_\")) < 0)\n    {\n      fprintf(dap_err, \"(estimate) missing _param2_ variable in dataset %s\\n\", fname);\n      exit(1);\n    }\n  if ((covn = dap_varnum(\"_cov_\")) < 0)\n    {\n      fprintf(dap_err, \"(estimate) missing _cov_ variable in dataset %s\\n\", fname);\n      exit(1);\n    }\n  partv = (int *) dap_malloc(sizeof(int) * dap_maxvar, \"\");\n  npart = dap_list(part, partv, dap_maxvar);\n  for (pnum1 = 0; pnum1 < nparam; pnum1++)\n    {\n      estimate[pnum1] = 0.0 / 0.0;\n      for (pnum2 = 0; pnum2 < nparam; pnum2++)\n\tcov[pnum1][pnum2] = 0.0 / 0.0;\n    }\n  for (more = 1; more; )\n    {\n      more = step();\n      if (dap_newpart(partv, npart))\n\t{\n\t  dap_swap();\n\t  dap_head(partv, npart);\n\t  fputs(\"    Estimate           SE  Parameter\\n\", dap_lst);\n\t  for (pnum1 = ninput; pnum1 < nparam; pnum1++)\n\t    {\n\t      /* compute estimate of defined parameter */\n\t      estimate[pnum1] = 0.0;\n\t      for (pnum2 = 0; pnum2 < pnum1; pnum2++)\n\t\t{\n\t\t  if (def[pnum1][pnum2] && !finite(estimate[pnum2]))\n\t\t    {\n\t\t      fprintf(dap_err,\n\t\t\t      \"(estimate) estimate for parameter %s not in dataset %s\\n\",\n\t\t\t      param[pnum2], fname);\n\t\t      exit(1);\n\t\t    }\n\t\t  estimate[pnum1] += def[pnum1][pnum2] * estimate[pnum2];\n\t\t}\n\t      /* compute variance of defined parameter */\n\t      cov[pnum1][pnum1] = 0.0;\n\t      for (pnum2 = 0; pnum2 < pnum1; pnum2++)\n\t\t{\n\t\t  for (pnum3 = 0; pnum3 < pnum1; pnum3++)\n\t\t    {\n\t\t      coeff = def[pnum1][pnum2] * def[pnum1][pnum3];\n\t\t      cov[pnum1][pnum1] += coeff * cov[pnum2][pnum3];\n\t\t    }\n\t\t}\n\t      /* compute covariance of def. param. with others */\n\t      for (pnum2 = 0; pnum2 < pnum1; pnum2++)\n\t\t{\n\t\t  cov[pnum1][pnum2] = 0.0;\n\t\t  for (pnum3 = 0; pnum3 < pnum1; pnum3++)\n\t\t    {\n\t\t      coeff = def[pnum1][pnum2];\n\t\t      cov[pnum1][pnum2] += coeff * cov[pnum2][pnum3];\n\t\t    }\n\t\t  cov[pnum2][pnum1] = cov[pnum1][pnum2];\n\t\t}\n\t    }\n\t  for (pnum1 = ninput; pnum1 < nparam; pnum1++)\n\t    {\n\t      fprintf(dap_lst, \"%12g %12g  %s =\",\n\t\t      estimate[pnum1], sqrt(cov[pnum1][pnum1]), param[pnum1]);\n\t      for (pnum2 = 0; pnum2 < nparam; pnum2++)\n\t\t{\n\t\t  if (def[pnum1][pnum2] != 0.0)\n\t\t    {\n\t\t      putc(' ', dap_lst);\n\t\t      if (def[pnum1][pnum2] > 0.0)\n\t\t\tputc('+', dap_lst);\n\t\t      if (def[pnum1][pnum2] == 1.0)\n\t\t\tfprintf(dap_lst, \"%s\", param[pnum2]);\n\t\t      else if (def[pnum1][pnum2] == -1.0)\n\t\t\tfprintf(dap_lst, \" -%s\", param[pnum2]);\n\t\t      else\n\t\t\tfprintf(dap_lst, \"%g%s\",\n\t\t\t\tdef[pnum1][pnum2], param[pnum2]);\n\t\t    }\n\t\t}\n\t      putc('\\n', dap_lst);\n\t    }\n\t  dap_swap();\n\t  for (pnum1 = 0; pnum1 < nparam; pnum1++)\n\t    {\n\t      estimate[pnum1] = 0.0 / 0.0;\n\t      for (pnum2 = 0; pnum2 < nparam; pnum2++)\n\t\tcov[pnum1][pnum2] = 0.0 / 0.0;\n\t    }\n\t}\n      if (more)\n\t{\n\t  if (!strcmp(dap_obs[dap_ono].do_str[typen], \"ESTIMATE\"))\n\t    {\n\t      if ((pnum2 = findparam(dap_obs[dap_ono].do_str[param2n],\n\t\t\t\t     param, ninput)) >= 0)\n\t\testimate[pnum2] = dap_obs[dap_ono].do_dbl[covn];\n\t    }\n\t  else if (!strcmp(dap_obs[dap_ono].do_str[typen], \"COVAR\"))\n\t    {\n\t      if ((pnum1 = findparam(dap_obs[dap_ono].do_str[param1n],\n\t\t\t\t     param, ninput)) >= 0 &&\n\t\t  (pnum2 = findparam(dap_obs[dap_ono].do_str[param2n],\n\t\t\t\t     param, ninput)) >= 0)\n\t\tcov[pnum1][pnum2] = dap_obs[dap_ono].do_dbl[covn];\n\t    }\n\t}\n    }\n  dap_free(parammem, \"\");\n  dap_free(param, \"\");\n  dap_free(defmem, \"\");\n  dap_free(def, \"\");\n  dap_free(estimate, \"\");\n  dap_free(covmem, \"\");\n  dap_free(cov, \"\");\n  dap_free(partv, \"\");\n}",
      "lines": 291,
      "depth": 21,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/dappp.c": {
    "white": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int white(int c)\n{\n  return (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r');\n}",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "alpha": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int alpha(int c)\n{\n  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '_';\n}",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "num": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int num(int c)\n{\n  return '0' <= c && c <= '9';\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "alphanum": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int alphanum(int c)\n{\n  return alpha(c) || num(c);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "get1c": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int get1c(FILE *fp)\n{\n  int c;\n\n  c = getc(fp);\n  if (newline)\n    {\n      lineno++;\n      column = 0;\n    }\n  else\n    column++;\n  newline = (c == '\\n');\n  if (newline)\n    pound = 0;\n  return c;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "unget1c": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void unget1c(int c, FILE *dotc, FILE *dapc)\n{\n  if (newline)\n    newline = 0;\n  ungetc(c, dotc);\n  if (dapc)\n    fseek(dapc, ftell(dapc) - 1, SEEK_SET);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "dgetc": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "int dgetc(FILE *dotc, FILE *dapc, int out)\n{\n  int c;\t\t\t/* the character read from .c file */\n\n  switch (c = get1c(dotc))\n    {\n    case '#':\n      if (!incomment && !column)\n\tpound = 1;\n      escape = 0;\n      break;\n    case '\"':\n      if (inquote2 && !escape)\n\tinquote2 = 0;\n      else if (!inquote1 && !incomment)\n\tinquote2 = 1;\n      escape = 0;\n      break;\n    case '\\'':\n      if (inquote1 && !escape)\n\tinquote1 = 0;\n      else if (!inquote2 && !incomment)\n\tinquote1 = 1;\n      escape = 0;\n      break;\n    case '*':\n      if (incomment)\n\t{\n\t  if ((c = get1c(dotc)) == '/')\n\t    {\n\t      if (out)\n\t\tfputs(\"*/\", dapc);\n\t      c = get1c(dotc);\n\t      incomment = 0;\n\t    }\n\t  else\n\t    {\n\t      unget1c(c, dotc, NULL);\n\t      c = '*';\n\t    }\n\t}\n      escape = 0;\n      break;\n    case '/':\n      if (!incomment && !inquote1 && !inquote2)\n\t{\n\t  if ((c = get1c(dotc)) == '*')\n\t    {\n\t      if (out)\n\t\tfputs(\"/*\", dapc);\n\t      c = get1c(dotc);\n\t      incomment = 1;\n\t    }\n\t  else\n\t    {\n\t      unget1c(c, dotc, NULL);\n\t      c = '/';\n\t    }\n\t}\n      escape = 0;\n      break;\n    case '\\\\':\n      if (!incomment && (inquote1 || inquote2))\n\tescape = 1;\n      break;\n    case EOF:\n      if (inquote1)\n\t{\n\t  fprintf(stderr, \"dappp:%s:%d: unmatched '\\n\", dotname, lineno);\n\t  exit(1);\n\t}\n      if (inquote2)\n\t{\n\t  fprintf(stderr, \"dappp:%s:%d: unmatched \\\"\\n\", dotname, lineno);\n\t  exit(1);\n\t}\n      if (incomment)\n\t{\n\t  fprintf(stderr, \"dappp:%s:%d: non-terminated comment\\n\", dotname, lineno);\n\t  exit(1);\n\t}\n      if (escape)\n\t{\n\t  fprintf(stderr, \"dappp:%s:%d: incomplete escape\\n\", dotname, lineno);\n\t  exit(1);\n\t}\n      if (pound)\n\t{\n\t  fprintf(stderr, \"dappp:%s:%d: incomplete #\\n\", dotname, lineno);\n\t  exit(1);\n\t}\n      break;\n    default:\n      escape = 0;\n      break;\n    }\n  if (out && c != EOF)\n    putc(c, dapc);\n  return c;\n}",
      "lines": 100,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "gettoken": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "int gettoken(char token[], FILE *dotc, FILE *dapc, int out)\n{\n  int c;\t\t/* character read from .c file */\n  int t;\t\t/* index to token character array */\n\n  token[0] = '\\0';\n  while (white(c = dgetc(dotc, dapc, out)) || incomment || inquote1 || inquote2)\n    ;\n  t = 0;\n  if (alpha(c))\t\t/* name of function, variable, etc. */\n    {\n      for ( ; alphanum(c); c = dgetc(dotc, dapc, out))\n\t{\n\t  if (t < TOKLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"dappp:%s:%d: token too long: %s\\n\",\n\t\t      dotname, lineno, token);\n\t      exit(1);\n\t    }\n\t}\n      unget1c(c, dotc, (out ? dapc : NULL));\n    }\n  else if (num(c))\t/* look for positive integers in #defines */\n    {\n      for ( ; num(c); c = dgetc(dotc, dapc, out))\n\t{\n\t  if (t < TOKLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"dappp:%s:%d: token too long: %s\\n\",\n\t\t      dotname, lineno, token);\n\t      exit(1);\n\t    }\n\t}\n      unget1c(c, dotc, (out ? dapc : NULL));\n    }\n  else if (c != EOF)\n    token[t++] = c;\n  token[t] = '\\0';\n  return (t > 0);\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "newdef": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void newdef(FILE *dotc, FILE *dapc)\n{\n  static char defstr[TOKLEN + 1];\t/* string to be defined */\n  static char defval[TOKLEN + 1]; /* defined as */\n  int d;\t\t\t\t/* index to defval */\n  int c;\t\t\t\t/* defval[d] */\n  int v;\t\t\t\t/* numerical value of defval */\n\n  if (gettoken(defstr, dotc, dapc, 1))\n    {\n      if (gettoken(defval, dotc, dapc, 1))\n\t{\n\t  for (v = 0, d = 0; num(c = defval[d]); d++)\n\t    v = 10 * v + c - '0';\n\t  if (v > 0 && !c)\n\t    {\n\t      if (ndef < MAXDEF)\n\t\t{\n\t\t  strcpy(def[ndef].def_str, defstr);\n\t\t  def[ndef].def_val = v;\n\t\t  ndef++;\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: too many #defines\\n\",\n\t\t\t  dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "defval": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "int defval(char str[])\n{\n  int d;\n\n  for (d = 0; d < ndef; d++)\n    {\n      if (!strcmp(def[d].def_str, str))\n\treturn def[d].def_val;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "declare": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void declare(FILE *dotc, FILE *dapc, char decl[])\n{\n  static char token[TOKLEN + 1];\t/* the token read */\n  static char tokdel[TOKLEN + 1];\t/* the delimiter read */\n  static char tokdim[TOKLEN + 1];\t/* the array dimension read */\n  int c;\t\t\t\t/* character read from .c file */\n  int dim;\t\t\t/* dimension of array variable */\n  int dimd;\t\t\t/* index to tokdim */\n  int d;\t\t\t\t/* index for declaring array variable entries */\n  long delpos;\t\t\t/* file position of delimiter */\n\n  while (gettoken(token, dotc, dapc, 0))\n    {\n      if ((delpos = ftell(dotc)) < 0)\n\t{\n\t  perror(\"dappp\");\n\t  exit(1);\n\t}\n      if (gettoken(tokdel, dotc, dapc, 0))\n\t{\n\t  if (!strcmp(tokdel, \"[\"))\n\t    {\n\t      if (!gettoken(tokdim, dotc, dapc, 0))\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: missing array dimension\\n\",\n\t\t\t  dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t      if (!(dim = defval(tokdim)))\n\t\t{\n\t\t  for (dimd = 0, dim = 0; num(c = tokdim[dimd]); dimd++)\n\t\t    dim = 10 * dim + c - '0';\n\t\t}\n\t      if (!dim)\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: zero array dimension\\n\",\n\t\t\t  dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t      if (!gettoken(tokdel, dotc, dapc, 0))\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: missing ]\\n\", dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t      if (strcmp(tokdel, \"]\"))\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: expected ], got %s\\n\",\n\t\t\t  dotname, lineno, tokdel);\n\t\t  exit(1);\n\t\t}\n\t      if (!strcmp(decl, \"int\"))\n\t\t{\n\t\t  for (d = 0; d < dim; d++)\n\t\t    fprintf(dapc,\n\t\t\t    \"dap_vd(\\\"%s[%d] 0\\\", 0);\", token, d);\n\t\t  fprintf(dapc, \"dap_il(\\\"%s\\\", %s);\", token, token);\n\t\t}\n\t      else if (!strcmp(decl, \"double\"))\n\t\t{\n\t\t  for (d = 0; d < dim; d++)\n\t\t    fprintf(dapc,\n\t\t\t    \"dap_vd(\\\"%s[%d] -1\\\", 0);\", token, d);\n\t\t  fprintf(dapc, \"dap_dl(\\\"%s\\\", %s);\", token, token);\n\t\t}\n\t      else\n\t\t{\n\t\t  if (dim <= 1)\n\t\t    {\n\t\t      fprintf(stderr,\n\t\t\t      \"dappp:%s:%d: dimension of character array must be at least 2\\n\",\n\t\t\t      dotname, lineno);\n\t\t      exit(1);\n\t\t    }\n\t\t  fprintf(dapc, \"dap_vd(\\\"%s %d\\\", 0);\", token, dim - 1);\n\t\t  fprintf(dapc, \"dap_sl(\\\"%s\\\", %s);\", token, token);\n\t\t}\n\t      if (!gettoken(tokdel, dotc, dapc, 0))\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"dappp:%s:%d: missing delimiter after string declaration\\n\",\n\t\t\t  dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else if (!strcmp(tokdel, \",\") || !strcmp(tokdel, \";\"))\n\t    {\n\t      if (!strcmp(decl, \"int\"))\n\t\t{\n\t\t  fprintf(dapc, \"dap_vd(\\\"%s 0\\\", 0);\", token);\n\t\t  fprintf(dapc, \"dap_il(\\\"%s\\\", &%s);\", token, token);\n\t\t}\n\t      else if (!strcmp(decl, \"double\"))\n\t\t{\n\t\t  fprintf(dapc, \"dap_vd(\\\"%s -1\\\", 0);\", token);\n\t\t  fprintf(dapc, \"dap_dl(\\\"%s\\\", &%s);\", token, token);\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"dappp:%s:%d: string variables must be arrays with explicit dimension\\n\",\n\t\t\t  dotname, lineno);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      if (!strcmp(tokdel, \",\"))\n\t{\n\t  while (white(c = dgetc(dotc, dapc, 0)))\n\t    ;\n\t  unget1c(c, dotc, NULL);\n\t}\n      else if (!strcmp(tokdel, \";\"))\n\tbreak;\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"dappp:%s:%d: expected `;' or `,', got %s\\n\",\n\t\t  dotname, lineno, tokdel);\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 122,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "preproc": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "void preproc(FILE *dotc, FILE *dapc)\n{\n  int c;\t\t\t\t/* character read */\n  static char token[TOKLEN + 1];\t/* token read */\n  static char tokdel[TOKLEN + 1];\t/* delimiter read */\n  int isdecl;\t\t\t/* flag: is it a declaration? */\n  long decpos;\t\t\t/* file position at start of current declaration */\n  int decline;\t\t\t/* line number at start of current declaration */\n  long inpos;\t\t\t/* file position at start of first declaration */\n  int infline;\t\t\t/* line number at start of first declaration */\n  int indecl;\t\t\t/* in declaration area of dotc */\n  int brace;\t\t\t/* depth of brace nesting */\n\n  indecl = 0;\n  if ((inpos = ftell(dotc)) < 0)\n    {\n      perror(\"dappp\");\n      exit(1);\n    }\n  infline = lineno;\n  do\t{\n    if ((decpos = ftell(dotc)) < 0)\n      {\n\tperror(\"dappp\");\n\texit(1);\n      }\n    decline = lineno;\n    if (gettoken(token, dotc, dapc, 0) &&\n\t(!strcmp(token, \"double\") || !strcmp(token, \"int\") ||\n\t !strcmp(token, \"char\")))\n      {\n\tisdecl = 1;\n\tif (fseek(dotc, decpos, SEEK_SET) < 0)\n\t  {\n\t    perror(\"dappp\");\n\t    exit(1);\n\t  }\n\tlineno = decline;\n\twhile ((c = dgetc(dotc, dapc, 1)) != ';' && c != EOF)\n\t  ;\n      }\n    else\n      isdecl = 0;\n  } while (isdecl);\n  if (fseek(dotc, inpos, SEEK_SET) < 0)\n    {\n      perror(\"dappp\");\n      exit(1);\n    }\n  lineno = infline;\n  do\t{\n    if ((decpos = ftell(dotc)) < 0)\n      {\n\tperror(\"dappp\");\n\texit(1);\n      }\n    decline = lineno;\n    if (gettoken(token, dotc, dapc, 0) &&\n\t(!strcmp(token, \"double\") || !strcmp(token, \"int\") ||\n\t !strcmp(token, \"char\")))\n      {\n\tisdecl = 1;\n\tdeclare(dotc, dapc, token);\n      }\n    else\n      isdecl = 0;\n  } while (isdecl);\n  if (fseek(dotc, decpos, SEEK_SET) < 0)\n    {\n      perror(\"dappp\");\n      exit(1);\n    }\n  lineno = decline;\n  for (brace = 1; brace && gettoken(token, dotc, dapc, 1); )\n    {\n      if (!strcmp(token, \"infile\") || !strcmp(token, \"inset\") || !strcmp(token, \"main\"))\n\t{\n\t  if (gettoken(tokdel, dotc, dapc, 1))\n\t    {\n\t      if (!strcmp(tokdel, \"(\"))\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"dappp:%s:%d: call to %s in infile or inset body\\n\",\n\t\t\t  dotname, lineno, token);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      else if (!strcmp(token, \"{\"))\n\tbrace++;\n      else if (!strcmp(token, \"}\"))\n\t--brace;\n    }\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "infile": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int infile(FILE *dotc, FILE *dapc)\n{\n  char token[TOKLEN + 1];\t\t/* could be infile or inset or main or not */\n  char tokdel[TOKLEN + 1];\t/* delimiter after token */\n  int c;\t\t\t\t/* character read */\n  long dotcpos;\t\t\t/* file position at start of main in dotc */\n  long dapcpos;\t\t\t/* file position at start of main in dapc */\n  int paren;\t\t\t/* depth of nesting of parentheses */\n\n  while (gettoken(token, dotc, dapc, 1))\n    {\n      if (pound)\n\t{\n\t  if (column > 1)\n\t    {\n\t      if (!strcmp(token, \"define\"))\n\t\tnewdef(dotc, dapc);\n\t      pound = 0;\n\t    }\n\t}\n      else if (!strcmp(token, \"main\"))\n\t{\n\t  dotcpos = ftell(dotc) - 4;\n\t  dapcpos = ftell(dapc) - 4;\n\t  if (gettoken(tokdel, dotc, dapc, 1))\n\t    {\n\t      if (!strcmp(tokdel, \"(\"))\n\t\t{\n\t\t  if (fseek(dotc, dotcpos, SEEK_SET) < 0)\n\t\t    {\n\t\t      perror(\"dappp\");\n\t\t      exit(1);\n\t\t    }\n\t\t  if (fseek(dapc, dapcpos, SEEK_SET) < 0)\n\t\t    {\n\t\t      perror(\"dappp\");\n\t\t      exit(1);\n\t\t    }\n\t\t  fputs(\"dap_\", dapc);\n\t\t  gettoken(token, dotc, dapc, 1);\n\t\t  gettoken(tokdel, dotc, dapc, 1);\n\t\t}\n\t    }\n\t}\n      else if (!strcmp(token, \"infile\") || !strcmp(token, \"inset\"))\n\t{\n\t  if (gettoken(tokdel, dotc, dapc, 1) && !strcmp(tokdel, \"(\"))\n\t    {\n\t      for (paren = 1; paren && (c = dgetc(dotc, dapc, 1)) != EOF; )\n\t\t{\n\t\t  if (!incomment && !inquote1 && !inquote2)\n\t\t    {\n\t\t      if (c == '(')\n\t\t\tparen++;\n\t\t      else if (c == ')')\n\t\t\t--paren;\n\t\t    }\n\t\t}\n\t      putc(';', dapc);\n\t      while (white(c = dgetc(dotc, dapc, 1)) || incomment)\n\t\t;\n\t      if (c == '{')\n\t\t{\n\t\t  while (white(c = dgetc(dotc, dapc, 1)) || incomment)\n\t\t    ;\n\t\t  unget1c(c, dotc, dapc);\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(stderr, \"dappp:%s:%d: expected {, got %c\\n\",\n\t\t\t  dotname, lineno, c);\n\t\t  exit(1);\n\t\t}\n\t      return 1;\n\t    }\n\t  else\n\t    {\n\t      fprintf(stderr, \"dappp:%s:%d: expected (, got %s\\n\",\n\t\t      dotname, lineno, tokdel);\n\t      exit(1);\n\t    }\n\t}\n    }\n  return 0;\n}",
      "lines": 85,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  FILE *dotc, *dapc;\n  int namelen;\n  char *dapname;\n\n  while (--argc > 0)\n    {\n      argv++;\n      namelen = strlen(*argv);\n      if (namelen > 4 && !strcmp(*argv + namelen - 4, \".sbs\"))\n\t{\n\t  sbstrans(*argv);\n\t  namelen -= 2;\n\t}\n      if (namelen <= 2 || strcmp(*argv + namelen - 2, \".c\"))\n\t{\n\t  fprintf(stderr, \"dappp: file name does not end in .c: %s\\n\", *argv);\n\t  exit(1);\n\t}\n      if (!(dotname = malloc(namelen + 1)))\n\t{\n\t  perror(\"dappp\");\n\t  exit(1);\n\t}\n      if (!(dapname = malloc(namelen + 5)))\n\t{\n\t  perror(\"dappp\");\n\t  exit(1);\n\t}\n      strcpy(dotname, *argv);\n      strcpy(dapname, *argv);\n      strcpy(dapname + namelen - 1, \"dap.c\");\n      if (!(dotc = fopen(dotname, \"r\")))\n\t{\n\t  fputs(\"dappp:\", stderr);\n\t  perror(dotname);\n\t  exit(1);\n\t}\n      if (!(dapc = fopen(dapname, \"w\")))\n\t{\n\t  fputs(\"dappp:\", stderr);\n\t  perror(dapname);\n\t  exit(1);\n\t}\n      lineno = 0;\n      column = 0;\n      newline = 1;\n      incomment = 0;\n      inquote1 = 0;\n      inquote2 = 0;\n      escape = 0;\n      ndef = 0;\n      while (infile(dotc, dapc))\n\tpreproc(dotc, dapc);\n\t\t\n      fclose(dotc);\n      fclose(dapc);\n      free(dotname);\n      free(dapname);\n    }\n  return 0;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/daprun.c": {
    "ecopy": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "char *ecopy(char *e)\n{\n  char *copy;\n\n  if (e)\n    {\n      if (!(copy = malloc(strlen(e) + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n      strcpy(copy, e);\n      return copy;\n    }\n  return NULL;\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "char",
        "*ecopy(char *e)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  int keep;\t/* flag: keep .lst file and append to it each run? */\n  int debug;\t/* flag: save .dap.c for debugging? */\n  int runstat;\t/* return status of execution of program */\n\n  fputs(\"\\nDap, Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\\n\",\n\tstderr);\n  fputs(\"Dap comes with ABSOLUTELY NO WARRANTY;\\n\", stderr);\n  fputs(\"for details see the GNU Public License.\\n\", stderr);\n  fputs(\"This is free software, and you are welcome to\\n\", stderr);\n  fputs(\"redistribute it under certain conditions; see\\n\", stderr);\n  fputs(\"the GNU Public License for details.\\n\\n\", stderr);\n\n  if (argc < 2)\n    {\n      fputs(\"dap: no files to process\\n\", stderr);\n      exit(1);\n    }\n  keep = 0;\t/* FALSE value */\n  debug = 0;\t/* FALSE value */\n  while (argv[1][0] == '-')\n    {\n      --argc;\n      argv++;\n      if (!strcmp(argv[0], \"-k\") || !strcmp(argv[0], \"--keep\"))\n\tkeep = -1;\t/* initial TRUE value */\n      else if (!strcmp(argv[0], \"-d\") || !strcmp(argv[0], \"--debug\"))\n\tdebug = 1;\t/* initial TRUE value */\n      else if (!strcmp(argv[0], \"--help\"))\n\t{\n\t  fputs(\"Usage:\\ndap [-k] [-d] FILE1.c [ FILE2.c ... ] [-a ARG1 ...]\\n\", stderr);\n\t  fputs(\"dap [--keep] [--debug] FILE1.c [ FILE2.c ... ] [--args] ARG1 ...]\\n\", stderr);\n\t  fputs(\"dap [-k] [-d] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n\t  fputs(\"dap [--keep] [--debug] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n\t  fputs(\"\\nReport bugs to <bug-dap@gnu.org>\\n\", stderr);\n\t  exit(1);\n\t}\n      else if (!strcmp(argv[0], \"--version\") || !strcmp(argv[0], \"-v\"))\n\t{\n\t  fputs(\"Dap 3.6\\n\", stderr);\n\t  exit(1);\n\t}\n      else\n\t{\n\t  fprintf(stderr, \"dap: bad option: %s\\n\", argv[0]);\n\t  exit(1);\n\t}\n    }\n  if (!(pager = ecopy(getenv(\"DAPPAGER\"))))\n    pager = PAGE;\n  if (!(pageopts = ecopy(getenv(\"DAPPAGEOPTS\"))))\n    pageopts = NULL;\n  if (!(compiler = ecopy(getenv(\"DAPCOMPILER\"))))\n    compiler = GCC;\n  if (!(compopts = ecopy(getenv(\"DAPCOMPOPTS\"))))\n    compopts = NULL;\n  if (!(viewer = ecopy(getenv(\"DAPVIEWER\"))))\n    viewer = PS;\n  if (!(viewopts = ecopy(getenv(\"DAPVIEWOPTS\"))))\n    viewopts = NULL;\n  if (!(dappp = ecopy(getenv(\"DAPPP\"))))\n    dappp = DAPPP;\n  if (!(incdir = ecopy(getenv(\"INCDIR\"))))\n    incdir = INCDIR;\n  if (!(libdir = ecopy(getenv(\"LIBDIR\"))))\n    libdir = LIBDIR;\n  if (!dappprun(argc, argv))\n    {\n      if (!gccrun(argc, argv, debug))\n\t{\n\t  runstat = run(argc, argv, keep);\n\t  view(argv[1], \".err\");\n\t  if (!runstat)\n\t    {\n\t      if (keep == -1)\n\t\tkeep = 1;\t/* non-initial TRUE value */\n\t      showps(argv[1]);\n\t    }\n\t}\n    }\n  return 0;\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "dappprun": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int dappprun(int argc, char **argv)\n{\n  char **arg;\t/* copy of arguments, modified */\n  int a;\t\t/* index to arguments */\n  int status;\t/* return status of preprocessor */\n  pid_t pid;\t/* process id of preprocessor */\n\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  arg[0] = dappp;\n  /* Only use arguments preceding \"-a\"; arguments following \"-a\"\n   * are arguments to program  \n   */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++)\n    arg[a] = argv[a];\n  arg[a] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Preprocessing...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  return status;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "suffix": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void suffix(char name[], char suff[])\n{\n  int n;\n\n  n = strlen(name);\n  if (n > 2 && !strcmp(name + n - 2, \".c\"))\n    {\n      name[n - 2] = '\\0';\n      strcat(name, suff);\n    }\n  else if (n > 4 && !strcmp(name + n - 4, \".sbs\"))\n    {\n      name[n - 4] = '\\0';\n      strcat(name, suff);\n    }\n  else\n    {\n      fprintf(stderr, \"dap: name must end in .c or .sbs: %s\\n\", name);\n      exit(1);\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "argcpy": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "char *argcpy(char arg[], int extra)\n{\n  char *cpy;\n\n  if (!(cpy = malloc(strlen(arg) + extra + 1)))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  strcpy(cpy, arg);\n  return cpy;\n}",
      "lines": 12,
      "depth": 14,
      "decorators": [
        "char",
        "*argcpy(char arg[], int extra)",
        "*"
      ]
    },
    "gccrun": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int gccrun(int argc, char **argv, int debug)\n{\n  char **arg;\t/* copy of arguments, modified */\n  int ncompopts;\t/* number of compiler options */\n  int g, a;\t/* indices to arguments */\n  int argstart;\t/* index of first file name */\n  int argend;\t/* index of \"-a\", if any, otherwise 0 */\n  int status;\t/* return status of compiler */\n  pid_t pid;\t/* process id of compiler */\n\n  ncompopts = parseopts(compopts, NULL);\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 11 + ncompopts))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  g = 0;\n  arg[g++] = compiler;\t\t\t/* first arg is compiler name */\n  g += parseopts(compopts, arg + g);\t/* now get compiler opts, if any */\n  arg[g++] = \"-o\";\t\t\t/* always name output file */\n  arg[g] = argcpy(argv[1], 4);\t\t/* and this is its name */\n  suffix(arg[g], \".dap\");\t\t\t/* except have to attach suffix */\n  g++;\n  arg[g++] = \"-I\";\t\t\t/* need to make use of... */\n  arg[g++] = incdir;\t\t\t/* ... header files */\n  /* Only use arguments preceding \"-a\"; arguments following \"-a\"\n   * are arguments to program  \n   */\n  argstart = g;\t\t\t\t/* this is where file names start */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++, g++)\n    {\n      arg[g] = argcpy(argv[a], 6);\t/* file name + chars for \".dap.c\" */\n      suffix(arg[g], \".dap.c\");\n    }\n  argend = g;\t\t\t\t/* this is after then end */\n  arg[g++] = \"-L\";\n  arg[g++] = libdir;\n  arg[g++] = \"-ldap\";\n  arg[g++] = \"-lm\";\n  arg[g] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Compiling...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  if (!status && !debug)\n    {\n      for (g = argstart; g < argend; g++)\n\tunlink(arg[g]);\n    }\n  return status;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "run": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "int run(int argc, char **argv, int keep)\n{\n  char **arg;\t/* copy of arguments, modified */\n  char *lstname;\t/* name of .lst file */\n  char *psname;\t/* name of .ps file */\n  int g, a;\t/* indices to arguments */\n  int status;\t/* return status of executable program */\n  pid_t pid;\t/* process id of executable program */\n\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  arg[0] = argcpy(argv[1], 4);\t/* name of executable */\n  suffix(arg[0], \".dap\");\n  lstname = argcpy(argv[1], 4);\n  suffix(lstname, \".lst\");\n  if (keep != 1)\t\t/* remove .lst file if first run or !keep */\n    unlink(lstname);\n  psname = argcpy(argv[1], 3);\n  suffix(psname, \".ps\");\n  unlink(psname);\t\t/* always remove .ps file */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++)\n    ;\n  for (g = 1, a++; a < argc; a++, g++)\t/* copy runtime arguments */\n    arg[g] = argcpy(argv[a], 0);\n  arg[g] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Executing...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  return status;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "ask": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "int ask(char *question)\n{\n  int c;\n\n  do\t{\n    fprintf(stderr, \"%s? [y/q] \", question);\n    c = getchar();\n    while (getchar() != '\\n')\n      ;\n    if (c != 'y' && c != 'q')\n      fprintf(stderr, \"Invalid response. \");\n  } while (c != 'y' && c != 'q');\n  return (c == 'y');\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "view": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "void view(char name[], char suff[])\n{\n  char *lstname;\n  char **arg;\n  int a;\t\t\t/* index to arg */\n  int status;\n  struct stat buf;\n  pid_t pid;\n\n  if (!(arg = (char **) malloc(sizeof(char *) *\n\t\t\t       (3 + parseopts(pageopts, NULL)))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  lstname = argcpy(name, strlen(suff));\n  suffix(lstname, suff);\n  if (!stat(lstname, &buf) && buf.st_size)\n    {\n      a = 0;\n      arg[a++] = pager;\n      a += parseopts(pageopts, arg + a);\n      arg[a++] = lstname;\n      arg[a] = NULL;\n      if (!(pid = fork()))\n\t{\n\t  execv(arg[0], arg);\n\t  perror(arg[0]);\n\t  exit(1);\n\t}\n      else if (pid == -1)\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n      waitpid(pid, &status, 0);\n    }\n}",
      "lines": 38,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "showps": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "void showps(char name[])\n{\n  char *psname;\t\t/* name of graphics file */\n  char **arg;\t\t/* arguments for execution of graphics viewer */\n  int a;\t\t\t/* index to arg */\n  struct stat buf;\t/* for call to stat: unused */\n  static int gv = 0;\t/* flag: graphics viewer started? */\n  pid_t pid;\t\t/* process id of viewer */\n\n  if (!(arg = (char **) malloc(sizeof(char *) *\n\t\t\t       (3 + parseopts(viewopts, NULL)))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  psname = argcpy(name, 3);\n  suffix(psname, \".ps\");\n  if (!gv && !stat(psname, &buf))\n    {\n      gv = 1;\n      a = 0;\n      arg[a++] = viewer;\n      a += parseopts(viewopts, arg + a);\n      arg[a++] = psname;\n      arg[a++] = NULL;\n      if (!(pid = fork()))\n\t{\n\t  execv(arg[0], arg);\n\t  perror(arg[0]);\n\t  exit(1);\n\t}\n      else if (pid == -1)\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 38,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "parseopts": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "int parseopts(char *opts, char **arg)\n{\n  static char *optcpy = NULL;\t/* copy of opts */\n  static int optlen = 0;\n  int i;\t\t/* index to opts */\n  int a;\t\t/* arg count */\n\n  if (!opts)\n    return 0;\n  if (strlen(opts) > optlen)\n    {\n      if (optcpy)\n\tfree(optcpy);\n      optlen = strlen(opts);\n      if (!(optcpy = malloc(optlen + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n    }\n  strcpy(optcpy, opts);\n  for (i = 0; optcpy[i] == ' '; i++)\n    ;\n  for (a = 0; optcpy[i]; a++)\n    {\n      if (arg)\n\targ[a] = optcpy + i;\n      while (optcpy[i] && optcpy[i] != ' ')\n\ti++;\n      if (optcpy[i])\n\t{\n\t  if (arg)\n\t    optcpy[i] = '\\0';\n\t  for (i++; optcpy[i] == ' '; i++)\n\t    ;\n\t}\n    }\n  return a;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/dapruns.c": {
    "ecopy": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "char *ecopy(char *e)\n{\n  char *copy;\n\n  if (e)\n    {\n      if (!(copy = malloc(strlen(e) + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n      strcpy(copy, e);\n      return copy;\n    }\n  return NULL;\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "char",
        "*ecopy(char *e)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  int keep;\t/* flag: keep .lst file and append to it each run? */\n  int debug;\t/* flag: save .dap.c for debugging? */\n  int runstat;\t/* return status of execution of program */\n\n  fputs(\"\\nDap, Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\\n\",\n\tstderr);\n  fputs(\"Dap comes with ABSOLUTELY NO WARRANTY;\\n\", stderr);\n  fputs(\"for details see the GNU Public License.\\n\", stderr);\n  fputs(\"This is free software, and you are welcome to\\n\", stderr);\n  fputs(\"redistribute it under certain conditions; see\\n\", stderr);\n  fputs(\"the GNU Public License for details.\\n\\n\", stderr);\n\n  if (argc < 2)\n    {\n      fputs(\"dap: no files to process\\n\", stderr);\n      exit(1);\n    }\n  keep = 0;\t/* FALSE value */\n  debug = 0;\t/* FALSE value */\n  while (argv[1][0] == '-')\n    {\n      --argc;\n      argv++;\n      if (!strcmp(argv[0], \"-k\") || !strcmp(argv[0], \"--keep\"))\n\tkeep = -1;\t/* initial TRUE value */\n      else if (!strcmp(argv[0], \"-d\") || !strcmp(argv[0], \"--debug\"))\n\tdebug = 1;\t/* initial TRUE value */\n      else if (!strcmp(argv[0], \"--help\"))\n\t{\n\t  fputs(\"Usage:\\ndap [-k] [-d] FILE1.c [ FILE2.c ... ] [-a ARG1 ...]\\n\", stderr);\n\t  fputs(\"dap [--keep] [--debug] FILE1.c [ FILE2.c ... ] [--args] ARG1 ...]\\n\", stderr);\n\t  fputs(\"dap [-k] [-d] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n\t  fputs(\"dap [--keep] [--debug] FILE1.sbs [ FILE2.c ... ]\\n\", stderr);\n\t  fputs(\"\\nReport bugs to <bug-dap@gnu.org>\\n\", stderr);\n\t  exit(1);\n\t}\n      else if (!strcmp(argv[0], \"--version\") || !strcmp(argv[0], \"-v\"))\n\t{\n\t  fputs(\"Dap 3.6\\n\", stderr);\n\t  exit(1);\n\t}\n      else\n\t{\n\t  fprintf(stderr, \"dap: bad option: %s\\n\", argv[0]);\n\t  exit(1);\n\t}\n    }\n  if (!(pager = ecopy(getenv(\"DAPPAGER\"))))\n    pager = PAGE;\n  if (!(pageopts = ecopy(getenv(\"DAPPAGEOPTS\"))))\n    pageopts = NULL;\n  if (!(compiler = ecopy(getenv(\"DAPCOMPILER\"))))\n    compiler = GCC;\n  if (!(compopts = ecopy(getenv(\"DAPCOMPOPTS\"))))\n    compopts = NULL;\n  if (!(viewer = ecopy(getenv(\"DAPVIEWER\"))))\n    viewer = PS;\n  if (!(viewopts = ecopy(getenv(\"DAPVIEWOPTS\"))))\n    viewopts = NULL;\n  if (!(dappp = ecopy(getenv(\"DAPPP\"))))\n    dappp = DAPPP;\n  if (!(incdir = ecopy(getenv(\"INCDIR\"))))\n    incdir = INCDIR;\n  if (!(libdir = ecopy(getenv(\"LIBDIR\"))))\n    libdir = LIBDIR;\n  for ( ; ; )\n    {\n      if (!ask(\"Compile and run\"))\n\tbreak;\n      if (!dappprun(argc, argv))\n\t{\n\t  if (!gccrun(argc, argv, debug))\n\t    {\n\t      runstat = run(argc, argv, keep);\n\t      view(argv[1], \".err\");\n\t      if (!runstat)\n\t\t{\n\t\t  if (keep == -1)\n\t\t    keep = 1;\t/* non-initial TRUE value */\n\t\t  showps(argv[1]);\n\t\t}\n\t    }\n\t}\n    }\n  return 0;\n}",
      "lines": 88,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "dappprun": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "int dappprun(int argc, char **argv)\n{\n  char **arg;\t/* copy of arguments, modified */\n  int a;\t\t/* index to arguments */\n  int status;\t/* return status of preprocessor */\n  pid_t pid;\t/* process id of preprocessor */\n\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  arg[0] = dappp;\n  /* Only use arguments preceding \"-a\"; arguments following \"-a\"\n   * are arguments to program  \n   */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++)\n    arg[a] = argv[a];\n  arg[a] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Preprocessing...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  return status;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "suffix": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void suffix(char name[], char suff[])\n{\n  int n;\n\n  n = strlen(name);\n  if (n > 2 && !strcmp(name + n - 2, \".c\"))\n    {\n      name[n - 2] = '\\0';\n      strcat(name, suff);\n    }\n  else if (n > 4 && !strcmp(name + n - 4, \".sbs\"))\n    {\n      name[n - 4] = '\\0';\n      strcat(name, suff);\n    }\n  else\n    {\n      fprintf(stderr, \"dap: name must end in .c or .sbs: %s\\n\", name);\n      exit(1);\n    }\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "argcpy": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "char *argcpy(char arg[], int extra)\n{\n  char *cpy;\n\n  if (!(cpy = malloc(strlen(arg) + extra + 1)))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  strcpy(cpy, arg);\n  return cpy;\n}",
      "lines": 12,
      "depth": 14,
      "decorators": [
        "char",
        "*argcpy(char arg[], int extra)",
        "*"
      ]
    },
    "gccrun": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "int gccrun(int argc, char **argv, int debug)\n{\n  char **arg;\t/* copy of arguments, modified */\n  int ncompopts;\t/* number of compiler options */\n  int g, a;\t/* indices to arguments */\n  int argstart;\t/* index of first file name */\n  int argend;\t/* index of \"-a\", if any, otherwise 0 */\n  int status;\t/* return status of compiler */\n  pid_t pid;\t/* process id of compiler */\n\n  ncompopts = parseopts(compopts, NULL);\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 11 + ncompopts))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  g = 0;\n  arg[g++] = compiler;\t\t\t/* first arg is compiler name */\n  g += parseopts(compopts, arg + g);\t/* now get compiler opts, if any */\n  arg[g++] = \"-o\";\t\t\t/* always name output file */\n  arg[g] = argcpy(argv[1], 4);\t\t/* and this is its name */\n  suffix(arg[g], \".dap\");\t\t\t/* except have to attach suffix */\n  g++;\n  arg[g++] = \"-I\";\t\t\t/* need to make use of... */\n  arg[g++] = incdir;\t\t\t/* ... header files */\n  /* Only use arguments preceding \"-a\"; arguments following \"-a\"\n   * are arguments to program  \n   */\n  argstart = g;\t\t\t\t/* this is where file names start */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++, g++)\n    {\n      arg[g] = argcpy(argv[a], 6);\t/* file name + chars for \".dap.c\" */\n      suffix(arg[g], \".dap.c\");\n    }\n  argend = g;\t\t\t\t/* this is after then end */\n  arg[g++] = \"-L\";\n  arg[g++] = libdir;\n  arg[g++] = \"-ldap\";\n  arg[g++] = \"-lm\";\n  arg[g] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Compiling...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  if (!status && !debug)\n    {\n      for (g = argstart; g < argend; g++)\n\tunlink(arg[g]);\n    }\n  return status;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "run": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int run(int argc, char **argv, int keep)\n{\n  char **arg;\t/* copy of arguments, modified */\n  char *lstname;\t/* name of .lst file */\n  char *psname;\t/* name of .ps file */\n  int g, a;\t/* indices to arguments */\n  int status;\t/* return status of executable program */\n  pid_t pid;\t/* process id of executable program */\n\n  if (!(arg = (char **) malloc(sizeof(char *) * (argc + 1))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  arg[0] = argcpy(argv[1], 4);\t/* name of executable */\n  suffix(arg[0], \".dap\");\n  lstname = argcpy(argv[1], 4);\n  suffix(lstname, \".lst\");\n  if (keep != 1)\t\t/* remove .lst file if first run or !keep */\n    unlink(lstname);\n  psname = argcpy(argv[1], 3);\n  suffix(psname, \".ps\");\n  unlink(psname);\t\t/* always remove .ps file */\n  for (a = 1; a < argc && strcmp(argv[a], \"-a\") && strcmp(argv[a], \"--args\"); a++)\n    ;\n  for (g = 1, a++; a < argc; a++, g++)\t/* copy runtime arguments */\n    arg[g] = argcpy(argv[a], 0);\n  arg[g] = NULL;\n  if (!(pid = fork()))\n    {\n      fputs(\"Executing...\\n\", stderr);\n      execv(arg[0], arg);\n      perror(arg[0]);\n      exit(1);\n    }\n  else if (pid == -1)\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  waitpid(pid, &status, 0);\n  return status;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "ask": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "int ask(char *question)\n{\n  int c;\n\n  do\t{\n    fprintf(stderr, \"%s? [y/q] \", question);\n    c = getchar();\n    while (getchar() != '\\n')\n      ;\n    if (c != 'y' && c != 'q')\n      fprintf(stderr, \"Invalid response. \");\n  } while (c != 'y' && c != 'q');\n  return (c == 'y');\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "view": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "void view(char name[], char suff[])\n{\n  char *lstname;\n  char **arg;\n  int a;\t\t\t/* index to arg */\n  int status;\n  struct stat buf;\n  pid_t pid;\n\n  if (!(arg = (char **) malloc(sizeof(char *) *\n\t\t\t       (3 + parseopts(pageopts, NULL)))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  lstname = argcpy(name, strlen(suff));\n  suffix(lstname, suff);\n  if (!stat(lstname, &buf) && buf.st_size)\n    {\n      a = 0;\n      arg[a++] = pager;\n      a += parseopts(pageopts, arg + a);\n      arg[a++] = lstname;\n      arg[a] = NULL;\n      if (!(pid = fork()))\n\t{\n\t  execv(arg[0], arg);\n\t  perror(arg[0]);\n\t  exit(1);\n\t}\n      else if (pid == -1)\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n      waitpid(pid, &status, 0);\n    }\n}",
      "lines": 38,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "showps": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void showps(char name[])\n{\n  char *psname;\t\t/* name of graphics file */\n  char **arg;\t\t/* arguments for execution of graphics viewer */\n  int a;\t\t\t/* index to arg */\n  struct stat buf;\t/* for call to stat: unused */\n  static int gv = 0;\t/* flag: graphics viewer started? */\n  pid_t pid;\t\t/* process id of viewer */\n\n  if (!(arg = (char **) malloc(sizeof(char *) *\n\t\t\t       (3 + parseopts(viewopts, NULL)))))\n    {\n      perror(\"dap\");\n      exit(1);\n    }\n  psname = argcpy(name, 3);\n  suffix(psname, \".ps\");\n  if (!gv && !stat(psname, &buf))\n    {\n      gv = 1;\n      a = 0;\n      arg[a++] = viewer;\n      a += parseopts(viewopts, arg + a);\n      arg[a++] = psname;\n      arg[a++] = NULL;\n      if (!(pid = fork()))\n\t{\n\t  execv(arg[0], arg);\n\t  perror(arg[0]);\n\t  exit(1);\n\t}\n      else if (pid == -1)\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n    }\n}",
      "lines": 38,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "parseopts": {
      "start_point": [
        448,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "int parseopts(char *opts, char **arg)\n{\n  static char *optcpy = NULL;\t/* copy of opts */\n  static int optlen = 0;\n  int i;\t\t/* index to opts */\n  int a;\t\t/* arg count */\n\n  if (!opts)\n    return 0;\n  if (strlen(opts) > optlen)\n    {\n      if (optcpy)\n\tfree(optcpy);\n      optlen = strlen(opts);\n      if (!(optcpy = malloc(optlen + 1)))\n\t{\n\t  perror(\"dap\");\n\t  exit(1);\n\t}\n    }\n  strcpy(optcpy, opts);\n  for (i = 0; optcpy[i] == ' '; i++)\n    ;\n  for (a = 0; optcpy[i]; a++)\n    {\n      if (arg)\n\targ[a] = optcpy + i;\n      while (optcpy[i] && optcpy[i] != ' ')\n\ti++;\n      if (optcpy[i])\n\t{\n\t  if (arg)\n\t    optcpy[i] = '\\0';\n\t  for (i++; optcpy[i] == ' '; i++)\n\t    ;\n\t}\n    }\n  return a;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/dap_make.h": {},
  "dap/dap-3.10/src/externs.h": {},
  "dap/dap-3.10/src/machdep.c": {
    "putnd": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int putnd(unsigned int h, int n, char dstr[])\n{\nint d;\t/* this dstr stupidity is also to get around weird behavior on some machines */\n\nd = 0;\nwhile (--n >= 0)\n\tdstr[d++] = ((h >> (6 * n)) & 0x3f) + CHARBASE;\nreturn d;\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dap_putdouble": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void dap_putdouble(DFILE *dfp)\n{\nunsigned int ix[2];\nunsigned int sign;\nunsigned int e;\n/* more weird stuff to get around weird behavior */\nchar dstr[13];\t/* doubles are encoded to 12 bits */\nint d;\n\nd = 0;\nix[0] = *(((unsigned int *) &dap_double) + dap_dbllow);\nix[1] = *(((unsigned int *) &dap_double) + dap_dblhigh);\nif (!(ix[0] & 0x7fffffff) && !ix[1])\n\t{\n\tdstr[d++] = 'A';\n\tfor (e = 0; e < 11; e++)\n\t\tdstr[d++] = '!';\n\t}\nelse\n\t{\n\tsign = ((ix[1] >> 20) & 0x800);\n\te =((ix[1] >> 20) & 0x7ff);\n\tif (!e)\n\t\t{\n\t\tdstr[d++] = 'A';\n\t\tfor (e = 0; e < 11; e++)\n\t\t\tdstr[d++] = '!';\n\t\t}\n\telse if (e == 0x7ff)\n\t\t{\n\t\tfor (e = 0; e < 12; e++)\n\t\t\tdstr[d++] = 'a';\n\t\t}\n\telse\n\t\t{\n\t\tif (sign)\n\t\t\t{\n\t\t\te = 0x800 - e;\n\t\t\tix[1] = ((~ix[1]) & 0xfffff);\n\t\t\tix[0] = (~ix[0]);\n\t\t\t}\n\t\telse\n\t\t\te += 0x800;\n\t\td += putnd(e, 2, dstr + d);\n\t\td += putnd(ix[1], 4, dstr + d);\n\t\td += putnd(ix[0], 6, dstr + d);\n\t\t}\n\t}\ndstr[d] = '\\0';\nfor (d = 0; dstr[d]; d++)\n        dap_putc(dstr[d], dfp);\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "getnh": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static unsigned int getnh(char s[], int n)\n{\nunsigned int h;\nint i;\n\nfor (h = ((s[0] - CHARBASE) & 0x3f), i = 1; i < n; i++)\n\th = ((h << 6) | ((s[i] - CHARBASE) & 0x3f));\nreturn h;\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "dap_getdouble": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void dap_getdouble(char code[])\n{\nunsigned int ix[2];\nunsigned int sign;\nunsigned int e;\n\nif (!strncmp(code, \"A!!!!!!!!!!!\", 12))\n\t{\n\tdap_double = 0.0;\n\treturn;\n\t}\nelse if (!strncmp(code, \"aaaaaaaaaaaa\", 12))\n\t{\n\tdap_double = 0.0 / 0.0;\n\treturn;\n\t}\nsign = ('!' <= code[0] && code[0] <= '@');\ne = getnh(code, 2);\nif (sign)\n\te = ((0x800 - e) | 0x800);\nelse\n\te -= 0x800;\nix[1] = getnh(code + 2, 4);\nix[0] = getnh(code + 6, 6);\nif (sign)\n\t{\n\tix[1] = (((~ix[1]) & 0xfffff) | (e << 20));\n\tix[1] = (ix[1] | 0x80000000);\n\tix[0] = (~ix[0]);\n\t}\nelse\n\tix[1] = (ix[1] | (e << 20));\n*(((unsigned int *) &dap_double) + dap_dbllow) = ix[0];\n*(((unsigned int *) &dap_double) + dap_dblhigh) = ix[1];\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "dap_putint": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void dap_putint(int i, DFILE *dfp)\n{\nint j;\nint ndig;\nint sign;\n\nif (!i)\n\tdap_putc('0', dfp);\nsign = 1;\nif (i < 0)\n\t{\n\tsign = -1;\n\ti = -i;\n\t}\nfor (ndig = 0, j = i; j; ndig++)\n\tj = (j >> 6);\ndap_putc('0' + sign * ndig, dfp);\nif (sign > 0)\n\t{\n\twhile (--ndig >= 0)\n\t\tdap_putc(((i >> (6 * ndig)) & 0x3f) + CHARBASE, dfp);\n\t}\nelse\n\t{\n\twhile (--ndig >= 0)\n\t\tdap_putc(((0x40 - (i >> (6 * ndig))) & 0x3f) + CHARBASE, dfp);\n\t}\n}",
      "lines": 28,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "dap_getint": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int dap_getint(char code[])\n{\nint i, j;\nint ndig;\nint sign;\n\nif (!strncmp(code, \"0\", 1))\n\treturn 0;\nsign = (code[0] < '0');\nif (sign)\n\tndig = '0' - code[0];\nelse\n\tndig = code[0] - '0';\nif (sign)\n\t{\n\tfor (j = 1, i = 0; j <= ndig; j++)\n\t\ti = ((i << 6) | (0x40 + CHARBASE - code[j]));\n\t}\nelse\n\t{\n\tfor (j = 1, i = 0; j <= ndig; j++)\n\t\ti = ((i << 6) | (code[j] - CHARBASE));\n\t}\nreturn (sign ? -i : i);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "dap/dap-3.10/src/misc.c": {
    "dap_numdate": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int dap_numdate(char date[])        /* number of days since 12/31/1751 */\n{\n  int d; /* index to date */\n  int dday; /* start of day */\n  int dyr; /* start of year */\n  int mon;\n  int day;\n  int yr;\n  int m;\n  int y;\n  int ndays;\n\n  for (d = 0, mon = 0; d < 2 && '0' <= date[d] && date[d] <= '9'; d++)\n    mon = 10 * mon + date[d] - '0';\n  if (date[d] == '/')\n    d++;\n  for (dday = d, day = 0; d < dday + 2 && '0' <= date[d] && date[d] <= '9'; d++)\n    day = 10 * day + date[d] - '0';\n  if (date[d] == '/')\n    d++;\n  for (dyr = d, yr = 0; d < dyr + 4 && '0' <= date[d] && date[d] <= '9'; d++)\n    yr = 10 * yr + date[d] - '0';\n  if (d < dyr + 4)\n    return -1;\n  for (m = 1, ndays = day; m < mon; m++)\n    ndays += mdays[m];\n  if ((mon > 2) && !(yr % 4) && (yr % 100))\n    ndays++;\n  if (yr < 1752)\n    return -1;\n  for (y = 1752; y < yr; y++)\n    {\n      ndays += 365;\n      if (!(y % 4) && ((y % 100) || !(y % 400)))\n\tndays++;\n    }\n  return ndays;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dap_datenum": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void dap_datenum(int n, char *d)\n{\n  int mon;\n  int day;\n  int yr;\n  int ndays;\n\n  if (n <= 0)\n    {\n      strcpy(d, \"?\");\n      return;\n    }\n  yr = 1752;\n  sprintf(d, \"0101%4d\", yr);\n  ndays = dap_numdate(d);\n  while (ndays <= n)\n    {\n      if (yr < 10000)\n\t{\n\t  sprintf(d, \"0101%4d\", ++yr);\n\t  ndays = dap_numdate(d);\n\t}\n      else\n\t{\n\t  strcpy(d, \"?\");\n\t  return;\n\t}\n    }\n  --yr;\n  mon = 1;\n  sprintf(d, \"%02d01%4d\", mon, yr);\n  ndays = dap_numdate(d);\n  while (ndays <= n)\n    {\n      sprintf(d, \"%02d01%4d\", ++mon, yr);\n      if (mon <= 12)\n\tndays = dap_numdate(d);\n      else\n\tbreak;\n    }\n  --mon;\n  day = 1;\n  sprintf(d, \"%02d%02d%4d\", mon, day,  yr);\n  ndays = dap_numdate(d);\n  while (ndays < n)\n    {\n      sprintf(d, \"%02d%02d%4d\", mon, ++day, yr);\n      if (day <= mdays[mon])\n\tndays = dap_numdate(d);\n      else\n\texit(1);\n    }\n}",
      "lines": 53,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dap_bincoeff": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "double dap_bincoeff(double n, double r)\n{\n  double b;\n\n  for (b = 1.0; r > 0.0; r -= 1.0, n -= 1.0)\n    b *= n / r;\n  return rint(b);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "takestep": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void takestep(double *x, double *y, double *d, int n, double step)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    x[i] = y[i] + d[i] * step;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vcopy": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void vcopy(double *x, double *y, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    x[i] = y[i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vsub": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void vsub(double *x, double *y, int n)\n{\n  int i;\n\n  for (i = 0; i < n; i++)\n    x[i] -= y[i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vlen": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static double vlen(double *x, int nx)\n{\n  double len;\n  int n;\n\n  for (n = 0, len = 0.0; n < nx; n++)\n    len += x[n] * x[n];\n  return sqrt(len);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "dirstep": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static double dirstep(double (*f)(double xx[]), int nx,\n\t\t      double x[], double x1[], double f0, double step, double tol)\n{\n  int n;\n  static double f1, f2, f3;\n  double dstep;\n\n  for (n = 0; n < nx; n++)\n    x1[n] = x[n];\n  for (n = 0; n < nx; n++)\n    {\n      x1[n] = x[n] - step;\n      f1 = (*f)(x1);\n      x1[n] = x[n] + step;\n      f2 = (*f)(x1);\n      dstep = step * (f1 - f2) / (f1 - 2.0 * f0 + f2) / 2.0;\n      if (finite(dstep) && fabs(dstep) > tol && ((f1 < f0 && f0 < f2) ||\n\t\t\t\t\t\t (f1 > f0 && f0 > f2)))\n\t{\n\t  x1[n] = x[n] + dstep;\n\t  f3 = (*f)(x1);\n\t  if (finite(f3) && f3 > f1 && f3 > f2)\n\t    f0 = f3;\n\t  else if (f1 > f0)\n\t    {\n\t      f0 = f1;\n\t      x1[n] = x[n] - step;\n\t    }\n\t  else\n\t    {\n\t      f0 = f2;\n\t      x1[n] = x[n] + step;\n\t    }\n\t}\n      else\n\tx1[n] = x[n];\n    }\n  return f0;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "dap_maximize": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "double dap_maximize(double (*f)(double xx[]), int nx, double x[],\n\t\t    double step, double tol, char *trace)\n{\n  int tr;\n  int ntries;\n  double *x1, *x2;\n  static double f0;\n  static double f1, f2;\n  double *dir;\n  double dirlen;\n  double dstep;\n  int n;\n  int d;\n  int traceout;\t/* number of trace steps per output */\n  int t;\n  int nsteps;\n\n  x1 = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  x2 = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  dir = (double *) dap_malloc(sizeof(double) * nx, \"\");\n  tr = 0;\n  if (trace && trace[0])\n    {\n      if (!strncmp(trace, \"TRACE\", 5) || !strncmp(trace, \"PAUSE\", 5))\n\t{\n\t  if (trace[0] == 'T')\n\t    tr = 1;\n\t  else\n\t    tr = 2;\n\t  for (t = 5; trace[t] == ' '; t++)\n\t    ;\n\t  for (traceout = 0; '0' <= trace[t] && trace[t] <= '9'; t++)\n\t    traceout = 10 * traceout + trace[t] - '0';\n\t  while (trace[t] == ' ')\n\t    t++;\n\t  if (trace[t])\n\t    {\n\t      fprintf(dap_err, \"(dap_maximize) bad trace interval: %s\\n\",\n\t\t      trace);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(dap_maximize) bad tracing option: %s\\n\", trace);\n\t  exit(1);\n\t}\n    }\n  else\n    tr = 0;\n  for (f0 = (*f)(x), nsteps = 0; ; nsteps++)\n    {\n      if (nsteps > dap_maxiter)\n\t{\n\t  fprintf(dap_err,\n\t\t  \"(dap_maximize) stepsize = %g failed to reach tolerance = %g after %d iterations\\n\",\n\t\t  step, tol, nsteps);\n\t  break;\n\t}\n      f1 = dirstep(f, nx, x, x1, f0, step, tol);\n      if (f1 > f0)\n\t{\n\t  vcopy(dir, x1, nx);\n\t  vsub(dir, x, nx);\n\t  dirlen = vlen(dir, nx);\n\t  vcopy(x2, x, nx);\n\t  vsub(x2, dir, nx);\n\t  f2 = (*f)(x2);\n\t  dstep = (f2 - f1) / (f1 - 2.0 * f0 + f2) / 2.0;\n\t  if (finite(dstep) && dstep > tol / step)\n\t    {\n\t      takestep(x2, x, dir, nx, dstep);\n\t      f2 = (*f)(x2);\n\t      if (finite(f2) && f2 > f1)\n\t\t{\n\t\t  vcopy(x1, x2, nx);\n\t\t  f1 = f2;\n\t\t}\n\t    }\n\t}\n      if (tr && (!traceout || !(nsteps % traceout)))\n\t{\n\t  fprintf(dap_log,\n\t\t  \"(dap_maximize) nsteps = %d, f0 = %.16g, f1 = %.16g, step = %g\\ndir = \",\n\t\t  nsteps, f0, f1, step);\n\t  fprintf(stderr,\n\t\t  \"(dap_maximize) nsteps = %d, f0 = %.16g, f1 = %.16g, step = %g\\ndir = \",\n\t\t  nsteps, f0, f1, step);\n\t  for (n = 0; n < nx; n++)\n\t    {\n\t      fprintf(dap_log, \" %g\", dir[n]);\n\t      fprintf(stderr, \" %g\", dir[n]);\n\t    }\n\t  fputs(\"\\nx =\", dap_log);\n\t  fputs(\"\\nx =\", stderr);\n\t  for (n = 0; n < nx; n++)\n\t    {\n\t      fprintf(dap_log, \" %g\", x[n]);\n\t      fprintf(stderr, \" %g\", x[n]);\n\t    }\n\t  putc('\\n', dap_log);\n\t  putc('\\n', stderr);\n\t  fflush(stderr);\n\t  if (tr == 2)\n\t    getchar();\n\t}\n      if (f1 <= f0)\n\t{\n\t  step /= 2.0;\n\t  if (step < tol)\n\t    break;\n\t}\n      else\n\t{\n\t  f0 = f1;\n\t  vcopy(x, x1, nx);\n\t}\n    }\n  dap_free(x1, \"\");\n  dap_free(x2, \"\");\n  dap_free(dir, \"\");\n  return f0;\n}",
      "lines": 123,
      "depth": 15,
      "decorators": [
        "double"
      ]
    }
  },
  "dap/dap-3.10/src/prob.c": {
    "dap_simp": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "double dap_simp(double (*f)(), double a, double b, int n)\n{\n  double h;\n  double val;\n  int i;\n\n  h = (b - a) / ((double) n);\n  val = 0.0;\n  for (i = 1; i <= n - 1; i += 2)\n    val += 4.0 * (*f)(a + ((double) i) * h);\n  for (i = 2; i <= n - 2; i += 2)\n    val += 2.0 * (*f)(a + ((double) i) * h);\n  val += (*f)(a) + (*f)(b);\n  return val * h / 3.0;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "Tfun": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static double Tfun(double x)\n{\n  if (dddi == 0.0)\n    return 1.0;\n  return pow(cos(x), dddi - 1.0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "probt": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "double probt(double t1, int di)\n{\n  double c;\n  double ddi;\n\n  if (!finite(t1))\n    return 0.0 / 0.0;\n  ddi = (double) di;\n  dddi = ddi;\n  for (c = 1.0; ddi > 2.0; ddi -= 2.0)\n    c *= (ddi - 1.0) / (ddi - 2.0);\n  if (ddi == 2.0)\n    c *= 0.5;\n  else\n    c /= PI;\n  return c * dap_simp(&Tfun, atan(t1 / sqrt(dddi)), HALFPI, 1024);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "zpoint": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "double zpoint(double p)\n{\n  static double a[4] = { 2.5066282, -18.6150006, 41.3911977, -25.4410605 };\n  static double b[4] = { -8.4735109, 23.0833674, -21.0622410, 3.1308291 };\n  static double c[4] = { -2.7871893, -2.2979648, 4.8501413, 2.3212128 };\n  static double d[2] = { 3.5438892, 1.6370678 };\n  double q, r, x, x0;\n\n  q = p - 0.5;\n  if (fabs(q) > 0.42)\n    {\n      r = p;\n      if (q > 0.0)\n\tr = 1.0 - p;\n      if (r <= 0.0)\n\t{\n\t  fputs(\"(zpoint) input not between 0 and 1\\n\", dap_err);\n\t  exit(1);\n\t}\n      r = sqrt(-log(r));\n      x = ((c[3] * r + c[2]) * r + c[1]) * r + c[0];\n      x0 = x / ((d[1] * r + d[0]) * r + 1.0);\n      if (q < 0.0)\n\tx0 = -x0;\n    }\n  else\n    {\n      r = q * q;\n      x = q * (((a[3] * r + a[2]) * r + a[1]) * r + a[0]);\n      x0 = x / ((((b[3] * r + b[2]) * r + b[1]) * r + b[0]) * r + 1.0);\n    }\n  return -x0;\n}",
      "lines": 33,
      "depth": 21,
      "decorators": [
        "double"
      ]
    },
    "tpoint": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "double tpoint(double p, int df)\n{\n  double pt0, pr0;\n  double pt1, pr1;\n  double pt2, pr2;\n\n  pt2 = 0.0;\t/* make compiler happy */\n  pt0 = zpoint(p);\n  pr0 = probt(pt0, df);\n  pt1 = 2.0 * pt0;\n  pr2 = pr0;\n  while (fabs(pr2 - p) > dap_prtol)\n    {\n      pr1 = probt(pt1, df);\n      pt2 = pt0 + (pt1 - pt0) * (p - pr0) / (pr1 - pr0);\n      if (pt2 < 0.0)\n\t{\n\t  if (pt0 < pt1)\n\t    pt2 = 0.5 * pt0;\n\t  else\n\t    pt2 = 0.5 * pt1;\n\t}\n      pr2 = probt(pt2, df);\n      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))\n\t{\n\t  pr1 = pr2;\n\t  pt1 = pt2;\n\t}\n      else\n\t{\n\t  pr0 = pr2;\n\t  pt0 = pt2;\n\t}\n    }\n  return pt2;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "Ffun": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static double Ffun(double x)\n{\n  if (dnm1 > 0.0)\n    return pow(x, dnm1) / pow(1.0 + drat * x, dmpln);\n  else\n    return 1.0 / pow(1.0 + drat * x, dmpln);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "probf": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "double probf(double f0, int numdf, int dendf)\n{\n  double c;\n  double dm, dn, dmpn;\n  double ddn;\n  double b;\n  double s, s0, s1, s2;\n\n  if (!finite(f0))\n    return 0.0 / 0.0;\n  if (numdf == 1)\n    return 2.0 * probt(sqrt(f0), dendf);\n  dn = 0.5 * (double) numdf;\n  dm = 0.5 * (double) dendf;\n  dmpn = dn + dm;\n  dmpln = dm + dn;\n  dnm1 = dn - 1.0;\n  drat = dn / dm;\n  ddn = dn;\n  for (c = 1.0; dmpn >= 0.5; )\n    {\n      dm -= 1.0;\n      dn -= 1.0;\n      dmpn -= 1.0;\n      if (dm > 0.0)\n\tc /= dm;\n      else if (dm == -0.5)\n\tc /= SQRTPI;\n      if (dn > 0.0)\n\tc /= dn;\n      else if (dn == -0.5)\n\tc /= SQRTPI;\n      if (dmpn > 0.0)\n\tc *= dmpn;\n      else if (dmpn == -0.5)\n\tc *= SQRTPI;\n    }\n  c *= pow(drat, ddn);\n  for (b = 1.0; f0 >= b; b *= 2.0)\n    ;\n  s = dap_simp(&Ffun, f0, b, 1024);\n  s0 = dap_simp(&Ffun, b, 2.0 * b, 1024);\n  b *= 2.0;\n  s1 = dap_simp(&Ffun, b, 2.0 * b, 1024);\n  b *= 2.0;\n  s2 = dap_simp(&Ffun, b, 2.0 * b, 1024);\n  s += s0 + s1 + s2;\n  while (s2 < s1 && (s2 * s2 / (s1 - s2) > 5.0e-11 / c))\n    {\n      b *= 2.0;\n      s0 = s1;\n      s1 = s2;\n      s2 = dap_simp(&Ffun, b, 2.0 * b, 1024);\n      s += s2;\n    }\n  return c * s;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "fpoint": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "double fpoint(double p, int numdf, int dendf)\n{\n  double pt0, pr0;\n  double pt1, pr1;\n  double pt2, pr2;\n\n  pt2 = 0.0;\t/* make compiler happy */\n  pt0 = ((double) numdf) / ((double) dendf);\n  pr0 = probf(pt0, numdf, dendf);\n  pt1 = 2.0 * pt0;\n  pr2 = 1.0;\n  while (fabs(pr2 - p) > dap_prtol)\n    {\n      pr1 = probf(pt1, numdf, dendf);\n      pt2 = pt0 + (pt1 - pt0) * (p - pr0) / (pr1 - pr0);\n      if (pt2 < 0.0)\n\t{\n\t  if (pt0 < pt1)\n\t    pt2 = 0.5 * pt0;\n\t  else\n\t    pt2 = 0.5 * pt1;\n\t}\n      pr2 = probf(pt2, numdf, dendf);\n      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))\n\t{\n\t  pr1 = pr2;\n\t  pt1 = pt2;\n\t}\n      else\n\t{\n\t  pr0 = pr2;\n\t  pt0 = pt2;\n\t}\n    }\n  return pt2;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "varnorm": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "double varnorm()\n{\n  double u1, u2, v1, v2, w;\n\n  do      {\n    u1 = 2.0 * ((double) random()) / randmax - 1.0;\n    v1 = u1 * u1;\n    u2 = 2.0 * ((double) random()) / randmax - 1.0;\n    v2 = u2 * u2;\n  } while ((w = v1 + v2) > 1.0);\n  w = sqrt(-2.0 * log(w) / w);\n  return u1 * w;\n}",
      "lines": 13,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "varunif": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "double varunif()\n{\n  return ((double) random()) / randmax;\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "probz": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "double probz(double z)\n{\n  if (!finite(z))\n    return 0.0 / 0.0;\n  z *= SQRTHALF;\n  if (z < -0.58)\n    return 0.5 * erfc(-z);\n  if (z < 0.0)\n    return 0.5 * (1.0 - erf(-z));\n  if (z < 0.58)\n    return 0.5 * (1.0 + erf(z));\n  return 1.0 - 0.5 * erfc(z);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "probchisq": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "double probchisq(double c, int df)\n{\n  double ddf;\n  double tmp;\n\n  if (df < 0)\n    {\n      fprintf(dap_err, \"(probchisq) non-positive df = %d\\n\", df);\n      exit(1);\n    }\n  if (!finite(c))\n    return 0.0 / 0.0;\n  switch (df)\n    {\n    case 1:\n      return 2.0 * probz(-sqrt(c));\n    case 2:\n      return exp(-0.5 * c);\n    default:\n      ddf = (double) df;\n      tmp = (0.5 * ddf - 1.0) * log(0.5 * c) - 0.5 * c -\n\tlgamma(0.5 * ddf);\n      if (finite(tmp))\n\treturn exp(tmp) + probchisq(c, df - 2);\n      return 0.0;\n      /* Orginal code:\n\t return exp((0.5 * ddf - 1.0) * log(0.5 * c) - 0.5 * c -\n\t lgamma(0.5 * ddf)) + probchisq(c, df - 2);\n      */\n      break;\n    }\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "chisqpoint": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "double chisqpoint(double p, int df)\n{\n  double pt0, pr0;\n  double pt1, pr1;\n  double pt2, pr2;\n\n  pt2 = 0.0;\t/* make compiler happy */\n  pt0 = (double) df;\n  pr0 = probchisq(pt0, df);\n  pt1 = 2.0 * pt0;\n  pr2 = 1.0;\n  while (fabs(pr2 - p) > dap_prtol)\n    {\n      pr1 = probchisq(pt1, df);\n      pt2 = pt0 + (pt1 - pt0) * (p - pr0) / (pr1 - pr0);\n      if (pt2 < 0.0)\n\t{\n\t  if (pt0 < pt1)\n\t    pt2 = 0.5 * pt0;\n\t  else\n\t    pt2 = 0.5 * pt1;\n\t}\n      pr2 = probchisq(pt2, df);\n      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))\n\t{\n\t  pr1 = pr2;\n\t  pt1 = pt2;\n\t}\n      else\n\t{\n\t  pr0 = pr2;\n\t  pt0 = pt2;\n\t}\n    }\n  return pt2;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "rangef1": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "double rangef1(double x0)\n{\n  double diff;\n  double x, x1, x2;\n  double tmp;\n\n  if (x0 == -1.0)\n    return 0.0;\n  x1 = 1.0 + x0;\n  x = x0 / x1;\n  x2 = x1 * x1;\n  diff = probz(x + w) - probz(x);\n  if (diff / x2 < 1.0e-16)\n    return 0.0;\n  tmp = -0.5 * x * x + numdfm1 * log(diff);\n  if (finite(tmp))\n    return exp(tmp) / (x1 * x1);\n  return 0.0;\n  /* Original code:\n     return exp(-0.5 * x * x + numdfm1 * log(diff)) / (x1 * x1);\n  */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "rangef2": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "double rangef2(double x0)\n{\n  double diff;\n  double x, x1, x2;\n  double tmp;\n\n  if (x0 == 1.0)\n    return 0.0;\n  x1 = 1.0 - x0;\n  x = x0 / x1;\n  x2 = x1 * x1;\n  diff = probz(x + w) - probz(x);\n  if (diff / x2 < 1.0e-16)\n    return 0.0;\n  tmp = -0.5 * x * x + numdfm1 * log(diff);\n  if (finite(tmp))\n    return exp(tmp) / (x1 * x1);\n  return 0.0;\n  /* Original code:\n     return exp(-0.5 * x * x + numdfm1 * log(diff)) / (x1 * x1);\n  */\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "range": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "static double range(double w0)\n{\n  w = w0;\n  return 1.0 - dnumdf * INVSQ2PI *\n    (dap_simp(&rangef1, -1.0, 0.0, 32) + dap_simp(&rangef2, 0.0, 1.0, 32));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "sturf": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "static double sturf(double s0)\n{\n  double s;\n  double s1;\n  double tmp;\n\n  if (s0 == 1.0)\n    return 0.0;\n  s1 = 1.0 - s0;\n  s = s0 / s1;\n  if (dendfm1 == 0.0)\n    return exp(-0.5 * s * s / E) * range(pt * s * INVSQRTE) / (s1 * s1);\n  tmp = dendfm1 * log(s) - 0.5 * ddendf * s * s / E;\n  if (finite(tmp))\n    return exp(tmp) * range(pt * s * INVSQRTE) / (s1 * s1);\n  return 0.0;\n  /* Original code:\n     return exp(dendfm1 * log(s) - 0.5 * ddendf * s * s / E) *\n     range(pt * s * INVSQRTE) / (s1 * s1);\n  */\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "dap_sr": {
      "start_point": [
        445,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "double dap_sr(int numdf, int dendf, double pt0)\t/* studentized range */\n{\n  double c;\n  double dn, dn1;\n\n  pt = pt0;\n  dnumdf = (double) numdf;\n  numdfm1 = (double) (dnumdf - 1);\n  ddendf = (double) dendf;\n  dendfm1 = (double) (dendf - 1);\n  for (dn = 0.5 * ddendf, dn1 = dn * INVE, c = 2.0; dn > 1.0; dn -= 1.0)\n    c *= dn1 / (dn - 1.0);\n  if (dn == 0.5)\n    c *= sqrt(dn1) / SQRTPI;\n  else\n    c *= dn1;\n  return c * dap_simp(&sturf, 0.0, 1.0, 64);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "dap_srpt": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "double dap_srpt(int numdf, int dendf, double pt0, double pr0, double alpha)\n{\n  double pt1, pr1;\n  double pt2, pr2;\n\n  pt2 = 0.0;\t/* make compiler happy */\n  if (alpha < pr0)\n    pt1 = 2.0 * pt0;\n  else\n    pt1 = 0.5 * pt0;\n  pr2 = 1.0;\n  while (fabs(pr2 - alpha) > dap_prtol)\n    {\n      pr1 = dap_sr(numdf, dendf, pt1);\n      pt2 = pt0 + (pt1 - pt0) * (alpha - pr0) / (pr1 - pr0);\n      if (pt2 < 0.0)\n\t{\n\t  if (pt0 < pt1)\n\t    pt2 = 0.5 * pt0;\n\t  else\n\t    pt2 = 0.5 * pt1;\n\t}\n      pr2 = dap_sr(numdf, dendf, pt2);\n      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))\n\t{\n\t  pr1 = pr2;\n\t  pt1 = pt2;\n\t}\n      else\n\t{\n\t  pr0 = pr2;\n\t  pt0 = pt2;\n\t}\n    }\n  return pt2;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "maxdf1": {
      "start_point": [
        501,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "double maxdf1(double x0)\n{\n  double diff;\n  double x, x1, x2;\n\n  if (x0 == -1.0)\n    return 0.0;\n  x1 = 1.0 + x0;\n  x = x0 / x1;\n  x2 = x1 * x1;\n  diff = probz(x + w) - probz(x - w);\n  if (diff / x2 < 1.0e-16)\n    return 0.0;\n  return exp(-0.5 * x * x + dnumdf * log(diff)) / (x1 * x1);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "maxdf2": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "double maxdf2(double x0)\n{\n  double diff;\n  double x, x1, x2;\n\n  if (x0 == 1.0)\n    return 0.0;\n  x1 = 1.0 - x0;\n  x = x0 / x1;\n  x2 = x1 * x1;\n  diff = probz(x + w) - probz(x - w);\n  if (diff / x2 < 1.0e-16)\n    return 0.0;\n  return exp(-0.5 * x * x + dnumdf * log(diff)) / (x1 * x1);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "maxdf": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "static double maxdf(double w0)\n{\n  w = w0;\n  return 1.0 - INVSQ2PI *\n    (dap_simp(&maxdf1, -1.0, 0.0, 32) + dap_simp(&maxdf2, 0.0, 1.0, 32));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "maxdiff": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "static double maxdiff(double s0)\n{\n  double s;\n  double s1;\n\n  if (s0 == 1.0)\n    return 0.0;\n  s1 = 1.0 - s0;\n  s = s0 / s1;\n  if (dendfm1 == 0.0)\n    return exp(-0.5 * s * s / E) * maxdf(pt * s * INVSQRTE) / (s1 * s1);\n  return exp(dendfm1 * log(s) - 0.5 * ddendf * s * s / E) *\n    maxdf(pt * s * INVSQRTE) / (s1 * s1);\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "dap_md": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "double dap_md(int numdf, int dendf, double pt0)\t/* maximum difference */\n{\n  double c;\n  double dn, dn1;\n\n  pt = pt0;\n  dnumdf = (double) numdf;\n  numdfm1 = (double) (dnumdf - 1);\n  ddendf = (double) dendf;\n  dendfm1 = (double) (dendf - 1);\n  for (dn = 0.5 * ddendf, dn1 = dn * INVE, c = 2.0; dn > 1.0; dn -= 1.0)\n    c *= dn1 / (dn - 1.0);\n  if (dn == 0.5)\n    c *= sqrt(dn1) / SQRTPI;\n  else\n    c *= dn1;\n  return c * dap_simp(&maxdiff, 0.0, 1.0, 256);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "dap_mdpt": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "double dap_mdpt(int numdf, int dendf, double pt0, double pr0, double alpha)\n{\n  double pt1, pr1;\n  double pt2, pr2;\n\n  pt2 = 0.0;\t/* make compiler happy */\n  if (alpha < pr0)\n    pt1 = 2.0 * pt0;\n  else\n    pt1 = 0.5 * pt0;\n  pr2 = 1.0;\n  while (fabs(pr2 - alpha) > dap_prtol)\n    {\n      pr1 = dap_md(numdf, dendf, pt1);\n      pt2 = pt0 + (pt1 - pt0) * (alpha - pr0) / (pr1 - pr0);\n      if (pt2 < 0.0)\n\t{\n\t  if (pt0 < pt1)\n\t    pt2 = 0.5 * pt0;\n\t  else\n\t    pt2 = 0.5 * pt1;\n\t}\n\n      pr2 = dap_md(numdf, dendf, pt2);\n      if (fabs(pr2 - pr0) < fabs(pr2 - pr1))\n\t{\n\t  pr1 = pr2;\n\t  pt1 = pt2;\n\t}\n      else\n\t{\n\t  pr0 = pr2;\n\t  pt0 = pt2;\n\t}\n    }\n  return pt2;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "double"
      ]
    }
  },
  "dap/dap-3.10/src/ps.c": {
    "dap_initpict": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void dap_initpict()\n{\n  double *ptmem;\n  int p;\n\n  ptmem = (double *) dap_malloc(sizeof(double) * 2 * dap_maxpts, \"dap_maxpts\");\n  ptbuf = (double **) dap_malloc(sizeof(double *) * dap_maxpts, \"dap_maxpts\");\n  for (p = 0; p < dap_maxpts; p++)\n    ptbuf[p] = ptmem + p * 2;\n  charbuf = dap_malloc(dap_maxchar + 1, \"dap_maxchar\");\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pict_newpoint": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static double (*pict_newpoint(double x, double y))[2]\n{\n  double (*pt)[2];\n\n  if (ptnext < dap_maxpts)\n    {\n      ptbuf[ptnext][0] = x;\n      ptbuf[ptnext][1] = y;\n      pt = (double (*)[2]) ptbuf[ptnext];\n      ptnext++;\n    }\n  else\n    {\n      fputs(\"(pict_newpoint) Too many points.\\n\", dap_err);\n      exit(1);\n    }\n  return pt;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double",
        "(*pict_newpoint(double x, double y))[2]",
        "(*pict_newpoint(double x, double y))",
        "(",
        "*pict_newpoint(double x, double y)",
        "*"
      ]
    },
    "pict_newstr": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "char *pict_newstr(char *str)\n{\n  int s;\n  char *s0;\n\n  s0 = charbuf + charnext;\n  if (str)\n    {\n      for (s = 0; str[s]; s++)\n\t{\n\t  if (charnext < dap_maxchar)\n\t    charbuf[charnext++] = str[s];\n\t  else\n\t    {\n\t      fputs(\"(pict_newstr) Too many characters.\\n\", dap_err);\n\t      exit(1);\n\t    }\n\t}\n    }\n  charbuf[charnext++] = '\\0';\n  return s0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "char",
        "*pict_newstr(char *str)",
        "*"
      ]
    },
    "pict_init": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void pict_init(int or, int bbx0, int bby0, int bbx1, int bby1, int npages)\n{\n  time_t t;\n\n  if (!pict_out)\n    {\n      if (!(pict_out = fopen(dap_psname, \"w\")))\n\t{\n\t  fprintf(dap_err, \"(pict_init) Can't create .ps file: %s\\n\", dap_psname);\n\t  exit(1);\n\t}\n    }\n  orient = or;\n  bboxx0 = bbx0;\n  bboxy0 = bby0;\n  bboxx1 = bbx1;\n  bboxy1 = bby1;\n  fputs(\"%!PS-Adobe-2.0\\n\", pict_out);\n  fprintf(pict_out, \"%%Title: %s\\n\", dap_psname);\n  fputs(\"%%Creator: ps.c\\n\", pict_out);\n  fputs(\"%%CreationDate: \", pict_out);\n  time(&t);\n  fputs(ctime(&t), pict_out);\n  fputs(\"%%For: bassein@localhost.localdomain (,,,,)\\n\", pict_out);\n  fprintf(pict_out, \"%s %s\\n\", \"%%Orientation:\", ((orient == 'p') ? \"Portrait\" : \"Landscape\"));\n  fprintf(pict_out, \"%s %d %d %d %d\\n\", \"%%BoundingBox:\", bboxx0, bboxy0, bboxx1, bboxy1);\n  fprintf(pict_out, \"%s %d\\n\", \"%%Pages:\", npages);\n  fputs(\"%%BeginSetup\\n\", pict_out);\n  fputs(\"%%IncludeFeature: *PageSize Letter\\n\", pict_out);\n  fputs(\"%%EndSetup\\n\", pict_out);\n  fputs(\"%%Magnification: 1.0000\\n\", pict_out);\n  fputs(\"%%EndComments\\n\", pict_out);\n  fputs(\"/cp {closepath} bind def /gr {grestore} bind def /gs {gsave} bind def\\n\", pict_out);\n  fputs(\"/sa {save} bind def /rs {restore} bind def /l {lineto} bind def\\n\", pict_out);\n  fputs(\"/rl {rlineto} bind def /ar {arc} bind def\\n\", pict_out);\n  fputs(\"/m {moveto} bind def /rm {rmoveto} bind def /n {newpath} bind def\\n\", pict_out);\n  fputs(\"/f {fill} bind def /s {stroke} bind def /sh {show} bind def\\n\", pict_out);\n  fputs(\"/slw {setlinewidth} bind def /sg {setgray} bind def /rot {rotate} bind def\\n\", pict_out);\n  fputs(\"/sc {scale} bind def /sd {setdash} bind def /ff {findfont} bind def\\n\", pict_out);\n  fputs(\"/sf {setfont} bind def /scf {scalefont} bind def /sw {stringwidth} bind def\\n\", pict_out);\n  fputs(\"/tr {translate} bind def\\n\", pict_out);\n  fputs(\"%%EndProlog\\n\", pict_out);\n  pageno = 0;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pict_port": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void pict_port(int npages)\n{\n  pict_init('p', 0, 0, 612, 792, npages);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pict_land": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void pict_land(int npages)\n{\n  pict_init('l', 0, 0, 612, 792, npages);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pict_end": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void pict_end()\n{\n  fputs(\"gr\\n\", pict_out);\n  fputs(\"showpage\\n\", pict_out);\n  fputs(\"%%Trailer\\n\", pict_out);\n  fflush(pict_out);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pict_page": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void pict_page()\n{\n  if (pageno)\n    {\n      fputs(\"gr\\n\", pict_out);\n      fputs(\"showpage\\n\", pict_out);\n    }\n  pageno++;\n  fprintf(pict_out, \"%%%%Page: %d %d\\n\", pageno, pageno);\n  fputs(\"gs\\n\", pict_out);\n  if (orient == 'l')\n    fprintf(pict_out, \"%d %d tr 90 rot %d %d tr\\n\", bboxy0 + bboxx1, bboxy0, -bboxx0, -bboxy0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pict_clearpict": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "void pict_clearpict(pict *p)\n{\n  dap_free(p->pict_txt, \"\");\n  p->pict_txt = NULL;\n  dap_free(p->pict_font, \"\");\n  p->pict_font = NULL;\n  dap_free(p->pict_tpt[0], \"\");\n  dap_free(p->pict_tang, \"\");\n  p->pict_tang = NULL;\n  dap_free(p->pict_pos[0], \"\");\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pict_initpict": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void pict_initpict(pict *prev, pict *p)\n{\n  double *dblmem;\n  char *charmem;\n  int t;\n\n  p->pict_npts = 0;\n  p->pict_ntxt = 0;\n  p->pict_txt = (char **) dap_malloc(sizeof(char *) * dap_maxntxt, \"dap_maxntxt\");\n  strcpy(p->pict_type, \"LINE\");\n  p->pict_dash = 0.0;\n  p->pict_font = dap_malloc(dap_maxfont + 1, \"dap_maxfont\");\n  strcpy(p->pict_font, \"Helvetica-Bold\");\n  dblmem = (double *) dap_malloc(sizeof(double) * 2 * dap_maxntxt, \"dap_maxntxt\");\n  p->pict_tpt = (double **) dap_malloc(sizeof(double *) * dap_maxntxt, \"dap_maxntxt\");\n  for (t = 0; t < dap_maxntxt; t++)\n    p->pict_tpt[t] = dblmem + 2 * t;\n  p->pict_tang = (double *) dap_malloc(sizeof(double) * dap_maxntxt, \"dap_maxntxt\");\n  charmem = dap_malloc(3 * dap_maxntxt, \"dap_maxntxt\");\n  p->pict_pos = (char **) dap_malloc(sizeof(char *) * dap_maxntxt, \"dap_maxntxt\");\n  for (t = 0; t < dap_maxntxt; t++)\n    p->pict_pos[t] = charmem + 3 * t;\n  p->pict_fs = 12.0;\n  p->pict_lw = 0.4;\n  p->pict_lgray = 0.0;\n  p->pict_fgray = -1.0;\n  p->pict_patt = NULL;\n  p->pict_next = NULL;\n  if (prev)\n    prev->pict_next = p;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pict_text": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void pict_text(pict *p, char *str, double x, double y, double tang, char pos[])\n{\n  if (!str)\n    return;\n  if (p->pict_ntxt < dap_maxntxt - 1)\n    {\n      p->pict_txt[p->pict_ntxt] = pict_newstr(str);\n      p->pict_tpt[p->pict_ntxt][0] = x;\n      p->pict_tpt[p->pict_ntxt][1] = y;\n      if (strlen(pos) <= 3)\n\t{\n\t  strcpy(p->pict_pos[p->pict_ntxt], pos);\n\t  if ((pos[0] != 'l' && pos[0] != 'c' && pos[0] != 'r') ||\n\t      (pos[1] != 't' && pos[1] != 'm' && pos[1] != 'b'))\n\t    {\n\t      fprintf(dap_err, \"(pict_text) Invalid position string: %s\\n\", pos);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(dap_err, \"(pict_text) Position string too long: %s\\n\", pos);\n\t  exit(1);\n\t}\n      p->pict_tang[p->pict_ntxt] = tang;\n      p->pict_ntxt++;\n    }\n  else\n    {\n      fprintf(dap_err, \"(pict_text) Too many texts in pict\\n\");\n      exit(1);\n    }\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "pict_circle": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "void pict_circle(pict *p, double cx, double cy, double r)\n{\n  p->pict_npts = 1;\n  strcpy(p->pict_type, \"CIRC\");\n  p->pict_pt = pict_newpoint(cx, cy);\n  p->pict_r = r;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pict_rectangle": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void pict_rectangle(pict *p, double llx, double lly, double sx, double sy)\n{\n  strcpy(p->pict_type, \"LINE\");\n  pict_point(p, llx, lly);\n  pict_point(p, llx + sx, lly);\n  pict_point(p, llx + sx, lly + sy);\n  pict_point(p, llx, lly + sy);\n  pict_point(p, llx, lly);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pict_hrect": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "void pict_hrect(pict *p, double spacing, double x0, double y0, double xside, double yside)\n{\n  int vlines, hlines;\n  int linen;\n  int ptn;\n  double xl, xr, yb, yt;\n  int even;\n\n  vlines = (int) floor(yside / spacing);\n  hlines = (int) floor(xside / spacing);\n  pict_point(p, x0, y0 + yside);\n  pict_point(p, x0, y0);\n  pict_point(p, x0 + xside, y0);\n  pict_point(p, x0 + xside, y0 + yside);\n  pict_point(p, x0, y0 + yside);\n  for (linen = -vlines, ptn = 0, even = 0; linen <= hlines;\n       linen++, ptn += 2, even = 1 - even)\n    {\n      xl = x0 + ((double) linen) * spacing;\n      yb = y0;\n      xr = xl + yside;\n      yt = y0 + yside;\n      if (xl < x0)\n\t{\n\t  yb += x0 - xl;\n\t  xl = x0;\n\t}\n      if (xr > x0 + xside)\n\t{\n\t  if (!even && xr < x0 + xside + spacing)\n\t    pict_point(p, x0 + xside, y0 + yside);\n\t  yt -= xr - x0 - xside;\n\t  xr = x0 + xside;\n\t}\n      if (even)\n\t{\n\t  pict_point(p, xl, yb);\n\t  pict_point(p, xr, yt);\n\t}\n      else\n\t{\n\t  pict_point(p, xr, yt);\n\t  pict_point(p, xl, yb);\n\t}\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pict_bhrect": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "void pict_bhrect(pict *p, double spacing, double x0, double y0, double xside, double yside)\n{\n  int vlines, hlines;\n  int linen;\n  int ptn;\n  double xl, xr, yb, yt;\n  int even;\n\n  vlines = (int) floor(yside / spacing);\n  hlines = (int) floor(xside / spacing);\n  pict_point(p, x0, y0);\n  pict_point(p, x0 + xside, y0);\n  pict_point(p, x0 + xside, y0 + yside);\n  pict_point(p, x0, y0 + yside);\n  pict_point(p, x0, y0);\n  for (linen = -vlines, ptn = 0, even = 0; linen <= hlines;\n       linen++, ptn += 2, even = 1 - even)\n    {\n      xl = x0 + ((double) linen) * spacing;\n      yt = y0 + yside;\n      xr = xl + yside;\n      yb = y0;\n      if (xl < x0)\n\t{\n\t  yt -= x0 - xl;\n\t  xl = x0;\n\t}\n      if (xr > x0 + xside)\n\t{\n\t  if (!even && xr < x0 + xside + spacing)\n\t    pict_point(p, x0 + xside, y0);\n\t  yb += xr - x0 - xside;\n\t  xr = x0 + xside;\n\t}\n      if (even)\n\t{\n\t  pict_point(p, xl, yt);\n\t  pict_point(p, xr, yb);\n\t}\n      else\n\t{\n\t  pict_point(p, xr, yb);\n\t  pict_point(p, xl, yt);\n\t}\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "pict_point": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void pict_point(pict *p, double x, double y)\n{\n  if (!p->pict_npts)\n    {\n      p->pict_minx = x;\n      p->pict_maxx = x;\n      p->pict_miny = y;\n      p->pict_maxy = y;\n      p->pict_pt = pict_newpoint(x, y);\n    }\n  else\n    {\n      if (x < p->pict_minx)\n\tp->pict_minx = x;\n      if (x > p->pict_maxx)\n\tp->pict_maxx = x;\n      if (y < p->pict_miny)\n\tp->pict_miny = y;\n      if (y > p->pict_maxy)\n\tp->pict_maxy = y;\n      pict_newpoint(x, y);\n    }\n  p->pict_npts++;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pict_line": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "void pict_line(pict *p, double x0, double y0, double x1, double y1)\n{\n  pict_point(p, x0, y0);\n  pict_point(p, x1, y1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "pict_curve": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "void pict_curve(pict *p, double (*xf)(double t), double (*yf)(double t),\n\t\tdouble t0, double t1, int nsteps)\n{\n  int step;\n  double h;\n  double t;\n\n  h = (t1 - t0) / ((double) nsteps);\n  for (step = 0; step <= nsteps; step++)\n    {\n      t = t0 + ((double) step) * h;\n      if (xf)\n\tpict_point(p, (*xf)(t), (*yf)(t));\n      else\n\tpict_point(p, t, (*yf)(t));\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pict_scale": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "void pict_scale(pict *p, double cx, double cy, double sx, double sy)\n{\n  int ptn;\n  int t;\n\n  while (p)\n    {\n      if (sx >= sy)\n\tp->pict_r *= sy;\n      else\n\tp->pict_r *= sx;\n      for (t = 0; t < p->pict_ntxt; t++)\n\t{\n\t  p->pict_tpt[t][0] = cx + sx * (p->pict_tpt[t][0] - cx);\n\t  p->pict_tpt[t][1] = cy + sy * (p->pict_tpt[t][1] - cy);\n\t}\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\n\t  p->pict_pt[ptn][0] = cx + sx * (p->pict_pt[ptn][0] - cx);\n\t  p->pict_pt[ptn][1] = cy + sy * (p->pict_pt[ptn][1] - cy);\n\t}\n      p->pict_minx = cx + sx * (p->pict_minx - cx);\n      p->pict_maxx = cx + sx * (p->pict_maxx - cx);\n      p->pict_miny = cx + sx * (p->pict_miny - cx);\n      p->pict_maxy = cx + sx * (p->pict_maxy - cx);\n      p = p->pict_next;\n    }\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "pict_rotate": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void pict_rotate(pict *p, double cx, double cy, double deg, int texttoo)\n{\n  double c, s;\n  int ptn;\n  double tmpx, tmpy;\n  double angle;\n  int t;\n\n  angle = 3.14159265358979323846 / 180.0 * deg;\n  c = cos(angle);\n  s = sin(angle);\n  while (p)\n    {\n      for (t = 0; t < p->pict_ntxt; t++)\n\t{\n\t  tmpx = p->pict_tpt[t][0] - cx;\n\t  tmpy = p->pict_tpt[t][1] - cy;\n\t  p->pict_tpt[t][0] = cx + c * tmpx - s * tmpy;\n\t  p->pict_tpt[t][1] = cy + s * tmpx + c * tmpy;\n\t  p->pict_tang[t] += deg;\n\t}\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\n\t  tmpx = p->pict_pt[ptn][0] - cx;\n\t  tmpy = p->pict_pt[ptn][1] - cy;\n\t  p->pict_pt[ptn][0] = cx + c * tmpx - s * tmpy;\n\t  p->pict_pt[ptn][1] = cy + s * tmpx + c * tmpy;\n\t  if (!ptn)\n\t    {\n\t      p->pict_minx = p->pict_pt[ptn][0];\n\t      p->pict_maxx = p->pict_pt[ptn][0];\n\t      p->pict_miny = p->pict_pt[ptn][1];\n\t      p->pict_maxy = p->pict_pt[ptn][1];\n\t    }\n\t  else\n\t    {\n\t      if (p->pict_pt[ptn][0] < p->pict_minx)\n\t\tp->pict_minx = p->pict_pt[ptn][0];\n\t      if (p->pict_pt[ptn][0] > p->pict_maxx)\n\t\tp->pict_maxx = p->pict_pt[ptn][0];\n\t      if (p->pict_pt[ptn][1] < p->pict_miny)\n\t\tp->pict_miny = p->pict_pt[ptn][1];\n\t      if (p->pict_pt[ptn][1] > p->pict_maxy)\n\t\tp->pict_maxy = p->pict_pt[ptn][1];\n\t    }\n\t}\n      p = p->pict_next;\n    }\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "pict_translate": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "void pict_translate(pict *p, double tx, double ty)\n{\n  int ptn;\n  int t;\n\n  while (p)\n    {\n      for (t = 0; t < p->pict_ntxt; t++)\n\t{\n\t  p->pict_tpt[t][0] += tx;\n\t  p->pict_tpt[t][1] += ty;\n\t}\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\n\t  p->pict_pt[ptn][0] += tx;\n\t  p->pict_pt[ptn][1] += ty;\n\t}\n      p->pict_minx += tx;\n      p->pict_maxx += tx;\n      p->pict_miny += ty;\n      p->pict_maxy += ty;\n      p = p->pict_next;\n    }\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "putmode": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "static void putmode(int mode)\n{\n  switch (mode)\n    {\n    case 's':\t/* s = stroke */\n      fputs(\"s\\n\", pict_out);\n      break;\n    case 'f':\t/* f = fill */\n      fputs(\"f\\n\", pict_out);\n      break;\n    case 'p':\t/* p = clip */\n      fputs(\"clip\\n\", pict_out);\n      break;\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "picttype": {
      "start_point": [
        552,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "static int picttype(char type[])\n{\n  if (!strcmp(type, \"LINE\")) return LINE;\n  else if (!strcmp(type, \"SEGM\")) return SEGM;\n  else if (!strcmp(type, \"IBEA\")) return IBEA;\n  else if (!strcmp(type, \"CIRC\")) return CIRC;\n  else if (!strcmp(type, \"SQUA\")) return SQUA;\n  else if (!strcmp(type, \"TRIA\")) return TRIA;\n  else if (!strcmp(type, \"UTRI\")) return UTRI;\n  else if (!strcmp(type, \"DIAM\")) return DIAM;\n  else if (!strcmp(type, \"PATT\")) return PATT;\n  else\n    {\n      fprintf(dap_err, \"bad pict type: %s\\n\", type);\n      exit(1);\n    }\n}",
      "lines": 17,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "show0": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "static void show0(pict *p, int mode)\n{\n  int ptn;\t/* index to point array */\n\n  switch (picttype(p->pict_type))\n    {\n    case SEGM:\t/* show a segment, not connected to other lines */\n      if (p->pict_npts % 2)\t/* need pairs of points */\n\t{\n\t  fputs(\"(show0) Requested SEGM with odd number of points.\\n\", dap_err);\n\t  exit(1);\n\t}\n      for (ptn = 0; ptn < p->pict_npts; ptn += 2)\n\t{\t/* place lines in graphical output file */\n\t  fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t  p->pict_pt[ptn][0], p->pict_pt[ptn][1],\n\t\t  p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1]);\n\t  putmode(mode);\t/* and stroke or fill */\n\t}\n      break;\n    case IBEA:\t/* show I-beam, not connect to other lines */\n      if (p->pict_npts % 2)\t/* need pairs of points */\n\t{\n\t  fputs(\"(show0) Requested IBEA with odd number of points.\\n\", dap_err);\n\t  exit(1);\n\t}\n      for (ptn = 0; ptn < p->pict_npts; ptn += 2)\n\t{\n\t  if (p->pict_pt[ptn][0] == p->pict_pt[ptn + 1][0])\n\t    {\t/* if x-coordinates are equal */\n\t      /* first cross piece of I-beam */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn][0] - p->pict_r, p->pict_pt[ptn][1],\n\t\t      p->pict_pt[ptn][0] + p->pict_r, p->pict_pt[ptn][1]);\n\t      putmode(mode);\n\t      /* bar */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn][0], p->pict_pt[ptn][1],\n\t\t      p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1]);\n\t      putmode(mode);\n\t      /* other cross piece of I-beam */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn + 1][0] - p->pict_r, p->pict_pt[ptn + 1][1],\n\t\t      p->pict_pt[ptn + 1][0] + p->pict_r, p->pict_pt[ptn + 1][1]);\n\t      putmode(mode);\n\t    }\n\t  else if (p->pict_pt[ptn][1] == p->pict_pt[ptn + 1][1])\n\t    {\t/* y-coordinate equal */\n\t      /* first cross piece of I-beam */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn][0], p->pict_pt[ptn][1] - p->pict_r,\n\t\t      p->pict_pt[ptn][0], p->pict_pt[ptn][1] + p->pict_r);\n\t      putmode(mode);\n\t      /* bar */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn][0], p->pict_pt[ptn][1],\n\t\t      p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1]);\n\t      putmode(mode);\n\t      /* other cross piece of I-beam */\n\t      fprintf(pict_out, \"n %.6f %.6f m %.6f %.6f l\\n\",\n\t\t      p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1] - p->pict_r,\n\t\t      p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1] + p->pict_r);\n\t      putmode(mode);\n\t    }\n\t  else\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(show0) IBEA requested but neither x nor y coordinates match: (%g, %g), (%g, %g)\\n\",\n\t\t      p->pict_pt[ptn][0], p->pict_pt[ptn][1],\n\t\t      p->pict_pt[ptn + 1][0], p->pict_pt[ptn + 1][1]);\n\t      exit(1);\n\t    }\n\t}\n      break;\n    case UTRI:\t/* upside-down triangle */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\t/* run around the triangle */\n\t  fprintf(pict_out,\n\t\t  \"n %.6f %.6f m %.6f %.6f l %.6f %.6f l %.6f %.6f l\\n\",\n\t\t  p->pict_pt[ptn][0] - p->pict_r,\n\t\t  p->pict_pt[ptn][1] + ONEOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0] + p->pict_r,\n\t\t  p->pict_pt[ptn][1] + ONEOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0],\n\t\t  p->pict_pt[ptn][1] - TWOOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0] - p->pict_r,\n\t\t  p->pict_pt[ptn][1] + ONEOVERSQRT3 * p->pict_r);\n\t  putmode(mode);\n\t}\n      break;\n    case DIAM:\t/* diamond */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\t/* run around the diamond */\n\t  fprintf(pict_out,\n\t\t  \"n %.6f %.6f m %.6f %.6f l %.6f %.6f l %.6f %.6f l %.6f %.6f l\\n\",\n\t\t  p->pict_pt[ptn][0], p->pict_pt[ptn][1] - p->pict_r,\n\t\t  p->pict_pt[ptn][0] + p->pict_r, p->pict_pt[ptn][1],\n\t\t  p->pict_pt[ptn][0], p->pict_pt[ptn][1] + p->pict_r,\n\t\t  p->pict_pt[ptn][0] - p->pict_r, p->pict_pt[ptn][1],\n\t\t  p->pict_pt[ptn][0], p->pict_pt[ptn][1] - p->pict_r);\n\t  putmode(mode);\n\t}\n      break;\n    case LINE:\t/* connected lines */\n      fprintf(pict_out, \"n %.6f %.6f m\\n\", p->pict_pt[0][0], p->pict_pt[0][1]);\n      for (ptn = 1; ptn < p->pict_npts; ptn++)\n\tfprintf(pict_out, \"%.6f %.6f l\\n\", p->pict_pt[ptn][0], p->pict_pt[ptn][1]);\n      putmode(mode);\n      break;\n    case CIRC:\t/* circle */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\n\t  fprintf(pict_out, \"n %.6f %.6f %.3f 0 360 ar\\n\",\n\t\t  p->pict_pt[ptn][0], p->pict_pt[ptn][1], p->pict_r);\n\t  putmode(mode);\n\t}\n      break;\n    case SQUA:\t/* square */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\t/* run around the square */\n\t  fprintf(pict_out,\n\t\t  \"n %.6f %.6f m %.6f %.6f l %.6f %.6f l %.6f %.6f l %.6f %.6f l\\n\",\n\t\t  p->pict_pt[ptn][0] - p->pict_r, p->pict_pt[ptn][1] - p->pict_r,\n\t\t  p->pict_pt[ptn][0] + p->pict_r, p->pict_pt[ptn][1] - p->pict_r,\n\t\t  p->pict_pt[ptn][0] + p->pict_r, p->pict_pt[ptn][1] + p->pict_r,\n\t\t  p->pict_pt[ptn][0] - p->pict_r, p->pict_pt[ptn][1] + p->pict_r,\n\t\t  p->pict_pt[ptn][0] - p->pict_r, p->pict_pt[ptn][1] - p->pict_r);\n\t  putmode(mode);\n\t}\n      break;\n    case TRIA:\t/* triangle */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\t/* run around the triangle */\n\t  fprintf(pict_out,\n\t\t  \"n %.6f %.6f m %.6f %.6f l %.6f %.6f l %.6f %.6f l\\n\",\n\t\t  p->pict_pt[ptn][0] - p->pict_r,\n\t\t  p->pict_pt[ptn][1] - ONEOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0] + p->pict_r,\n\t\t  p->pict_pt[ptn][1] - ONEOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0],\n\t\t  p->pict_pt[ptn][1] + TWOOVERSQRT3 * p->pict_r,\n\t\t  p->pict_pt[ptn][0] - p->pict_r,\n\t\t  p->pict_pt[ptn][1] - ONEOVERSQRT3 * p->pict_r);\n\t  putmode(mode);\n\t}\n      break;\n    case PATT:\t/* display pict linked to this pict */\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\t/* first do a gsave */\n\t  /* need to translate linked pict to this point */\n\t  fprintf(pict_out,\n\t\t  \"gs n %.6f %.6f tr\\n\", p->pict_pt[ptn][0], p->pict_pt[ptn][1]);\n\t  pict_show(p->pict_patt);\t/* then display */\n\t  fputs(\"gr\\n\", pict_out);\t/* end with grestore */\n\t}\n      break;\n    }\n}",
      "lines": 158,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "show1": {
      "start_point": [
        731,
        0
      ],
      "end_point": [
        983,
        1
      ],
      "content": "static pict *show1(pict *p)\n{\n  static int show1init = 0;\t/* initial bookkeeping done? */\n  int t;\t\t/* index to text strings */\n  double yoff;\t/* offset for positioning text relative to point */\n  int tc;\t\t/* index to one text string */\n  double nfull;\t/* number of full-sized characters */\n  double nscript;\t/* number of super/sub-script-sized characters */\n  double nchange;\t/* number of super/sub-script sub-strings */\n  int inscript;\t/* stepping though text: in super/sub-script? */\n  double lfact;\t/* length factor: true length over character-counting length */\n  int i;\t\t/* index to baret */\n  static char *tpart;\t/* part of text between super/sub-script changes */\n  static char *baret;\t/* bare text, no super/sub-script escapes */\n  double hside;\t/* width of box for blanking around text: less than perfect */\n  double efffs;\t/* effective font-size for blanking to account for super/sub-scripts */\n  int nlines;\t/* number of lines specified by text string */\n  int toff;\t/* offset into text string */\n  double linespace;\t/* factor to multiply font size by to get line spacing */\n\n  linespace = 1.4;\n  yoff = 0.0;\t\t/* default is lower left of first character on the point */\n  if (!show1init)\t\t/* if initial bookkeeping not done yet */\n    {\n      show1init = 1;\n      tpart = dap_malloc(dap_maxtxt + 1, \"dap_maxtxt\");\n      baret = dap_malloc(dap_maxtxt + 1, \"dap_maxtxt\");\n    }\n  if (p->pict_npts > 0)\t/* if there are points, not just text, to display */\n    {\n      if (p->pict_fgray >= 0.0)\n\t{\t/* non-negative value requested by caller */\n\t  fprintf(pict_out, \"%.2f sg\\n\", p->pict_fgray);\n\t  show0(p, 'f');\t/* stroke with fill */\n\t}\n      if (p->pict_lw >= 0.0)\n\t{\t/* non-negative value requested by caller */\n\t  fprintf(pict_out, \"%.2f slw %.2f sg\\n\", p->pict_lw, p->pict_lgray);\n\t  if (p->pict_dash > 0.0)\t/* positive value requested by caller */\n\t    fprintf(pict_out, \"[%.3f] 0 sd\\n\", p->pict_dash);\n\t  show0(p, 's');\t/* stroke, no fill */\n\t  if (p->pict_dash > 0.0)\t/* reset dashing to null */\n\t    fputs(\"[] 0 sd\\n\", pict_out);\n\t}\n      if (p->pict_patt && strcmp(p->pict_type, \"PATT\"))\n\tshow0(p, 'p');\n    }\n  /* now on to text */\n  for (t = 0; t < p->pict_ntxt; t++)\t/* show one string and follow link */\n    {\n      /* tc = 0: start at beginning of string\n       * i = 0: index to baret, start at beginning\n       * inscript = 0: not in super/sub-scripts at start\n       * nfull = 0.0: number of full-sized characters\n       * nscript = 0.0: number of super/sub-script-sized characters\n       * nchange = 0.0: number of super/sub-script sub-strings\n       */\n      /* first get number of lines requested */\n      for (nlines = 1, tc = 0; p->pict_txt[t][tc]; tc++)\n\t{\n\t  if (p->pict_txt[t][tc] == '\\n')\n\t    nlines++;\n\t}\n      switch (p->pict_pos[t][1])\t/* position text relative to point */\n\t{\n\tcase 't':\t/* point is at top of text */\n\t  yoff = -p->pict_fs;\n\t  break;\n\tcase 'm':\t/* point is at middle (vertical) of text */\n\t  yoff = -0.2 * p->pict_fs + 0.5 * linespace * p->pict_fs * (double) (nlines - 1);\n\t  break;\n\tcase 'b':\t/* point is at bottom of text */\n\t  yoff = linespace * p->pict_fs * (double) (nlines - 1);\n\t  break;\n\t}\n      for (toff = 0; p->pict_txt[t][toff]; )\n\t{\n\t  for (tc = toff, i = 0, inscript = 0, nfull = 0.0, nscript = 0.0, nchange = 0.0;\n\t       p->pict_txt[t][tc] && p->pict_txt[t][tc] != '\\n'; tc++)\n\t    {\t/* step though one text string */\n\t      if (p->pict_txt[t][tc] == '^' || p->pict_txt[t][tc] == '|')\n\t\t{\t/* entering or leaving super/sub-script portion */\n\t\t  inscript = !inscript;\n\t\t  nchange += 1.0;\t/* record number of changes */\n\t\t}\n\t      else\t\t/* not entering or leaving */\n\t\t{\n\t\t  if (inscript)\t/* count super/sub-scripted character */\n\t\t    nscript += 1.0;\n\t\t  else\t\t/* count full-sized character */\n\t\t    nfull += 1.0;\n\t\t  /* copy bare text, no super/sub-script marks, into baret */\n\t\t  /* except if ( ), need to escape! */\n\t\t  if (i < dap_maxtxt)\n\t\t    {\n\t\t      if (p->pict_txt[t][tc] == '(' || p->pict_txt[t][tc] == ')')\n\t\t\t{ /* parens need escape */\n\t\t\t  baret[i++] = '\\\\';\n\t\t\t  if (i == dap_maxtxt)\n\t\t\t    {\n\t\t\t      fprintf(dap_err, \"(show1) Text too long: %s\\n\",\n\t\t\t\t      p->pict_txt[t]);\n\t\t\t      exit(1);\n\t\t\t    }\n\t\t\t}\n\t\t      baret[i++] = p->pict_txt[t][tc];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      fprintf(dap_err, \"(show1) Text too long: %s\\n\",\n\t\t\t      p->pict_txt[t]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t    }\n\t  baret[i] = '\\0';\n\t  if (!i)\t\t/* if nothing to show for all this */\n\t    continue;\t/* just skip it */\n\t  /* length factor: true length as fraction of character count */\n\t  lfact = (nfull + SCRIPTF * nscript) / (nfull + nscript + nchange);\n\t  if (p->pict_pos[t][2] == ' ')\t/* trailing space for blanking around text */\n\t    {\n\t      efffs = p->pict_fs;\n\t      if (nchange > 0.0)\n\t\tefffs *= 1.4;\n\t      /* This computation assumes with of character is 0.9 * height.\n\t       * That is simply untrue, but to do any better would require\n\t       * this program to read font tables... some other lifetime, folks.\n\t       */\n\t      hside = ((double) strlen(baret)) * lfact * p->pict_fs * 0.9;\n\t      /* gsave so we can translate to save trouble */\n\t      fputs(\"gs n 1 sg\\n\", pict_out);\n\t      fprintf(pict_out, \"%.6f %.6f tr %.3f rot\\n\",\n\t\t      p->pict_tpt[t][0], p->pict_tpt[t][1], p->pict_tang[t]);\n\t      switch (p->pict_pos[t][0])\n\t\t{\n\t\tcase 'l':\t/* string begins at point */\n\t\t  fprintf(pict_out, \"%.3f %.3f tr\\n\",\n\t\t\t  -(TBOXF - 1.0) * p->pict_fs, yoff - 0.5 * efffs);\n\t\t  break;\n\t\tcase 'c':\t/* center of string at point */\n\t\t  fprintf(pict_out, \"%.3f %.3f tr\\n\",\n\t\t\t  -0.5 * hside, yoff - 0.5 * efffs);\n\t\t  break;\n\t\tcase 'r':\t/* string ends at point */\n\t\t  fprintf(pict_out, \"%.3f %.3f tr\\n\",\n\t\t\t  -hside + (TBOXF - 1.0) * p->pict_fs, yoff - 0.5 * efffs);\n\t\t  break;\n\t\t}\n\t      fprintf(pict_out, \" 0 0 m %.3f 0 rl 0 %.3f rl %.3f 0 rl cp f\\n\",\n\t\t      hside, TBOXF * efffs, -hside);\n\t      fputs(\"gr\\n\", pict_out);\t/* grestore */\n\t    }\n\t  /* gsave for convenience */\n\t  fputs(\"gs\\n\", pict_out);\n\t  /* set gray level */\n\t  fprintf(pict_out, \"n %.2f sg\\n\", p->pict_lgray);\n\t  /* set and scale the font */\n\t  fprintf(pict_out, \"/%s ff %.3f scf sf\\n\", p->pict_font, p->pict_fs);\n\t  /* place text and rotate if necessary */\n\t  fprintf(pict_out, \"%.6f %.6f tr %.3f rot\\n\",\n\t\t  p->pict_tpt[t][0], p->pict_tpt[t][1], p->pict_tang[t]);\n\t  /* if left/right text position, not just show, requested */\n\t  if (p->pict_pos[t][0] == 'c' || p->pict_pos[t][0] == 'r')\n\t    {\n\t      /* first get string width: slightly wrong if it has super/sub-scripts */\n\t      fprintf(pict_out, \"0 %.3f m (%s) sw pop %.3f mul \", yoff, baret, lfact);\n\t      /* go half-way back */\n\t      if (p->pict_pos[t][0] == 'c')\n\t\tfputs(\"-2 div 0 rm\\n\", pict_out);\n\t      /* go all the way back */\n\t      else\n\t\tfputs(\"neg 0 rm\\n\", pict_out);\n\t    }\n\t  else\t/* or position is just fine */\n\t    fprintf(pict_out, \"0 %.3f m \", yoff);\n\t  /* show the string, with all its super/sub-scripts, if any */\n\t  for (tc = toff, inscript = 0;\n\t       p->pict_txt[t][tc] && p->pict_txt[t][tc] != '\\n'; )\n\t    {\n\t      /* copy part of string up to next super/sub-script mark */\n\t      for (i = 0; p->pict_txt[t][tc] && p->pict_txt[t][tc] != '^' &&\n\t\t     p->pict_txt[t][tc] != '|' && p->pict_txt[t][tc] != '\\n';\n\t\t   i++, tc++)\n\t\t{\n\t\t  if (i < dap_maxtxt)\n\t\t    {\n\t\t      if (p->pict_txt[t][tc] == '(' || p->pict_txt[t][tc] == ')')\n\t\t\t{ /* parens need escape */\n\t\t\t  tpart[i++] = '\\\\';\n\t\t\t  if (i == dap_maxtxt)\n\t\t\t    {\n\t\t\t      fprintf(dap_err, \"(show1) Text too long: %s\\n\",\n\t\t\t\t      p->pict_txt[t]);\n\t\t\t      exit(1);\n\t\t\t    }\n\t\t\t}\n\t\t      tpart[i] = p->pict_txt[t][tc];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      fprintf(dap_err, \"(show1) Text too long: %s\\n\",\n\t\t\t      p->pict_txt[t]);\n\t\t      exit(1);\n\t\t    }\n\t\t}\n\t      tpart[i] = '\\0';\n\t      fprintf(pict_out, \"(%s) sh \", tpart);\t/* and show it */\n\t      /* if we found a super/sub-script mark, need to prepare for next chars */\n\t      if (p->pict_txt[t][tc] == '^' || p->pict_txt[t][tc] == '|')\n\t\t{\n\t\t  if (inscript)\n\t\t    {\t/* leaving scripted part */\n\t\t      /* re-adjust font */\n\t\t      fprintf(pict_out, \"/%s ff %.3f scf sf\\n\",\n\t\t\t      p->pict_font, p->pict_fs);\n\t\t      /* re-adjust position */\n\t\t      if (p->pict_txt[t][tc] == '^')\n\t\t\tfprintf(pict_out, \"0 %.3f rm \",\n\t\t\t\t-SCRIPTH * p->pict_fs);\n\t\t      else\n\t\t\tfprintf(pict_out, \"0 %.3f rm \",\n\t\t\t\tSCRIPTH * p->pict_fs);\n\t\t      inscript = 0;\n\t\t    }\n\t\t  else\t/* entering scripted part */\n\t\t    {\n\t\t      /* adjust font */\n\t\t      fprintf(pict_out, \"/%s ff %.3f scf sf\\n\",\n\t\t\t      p->pict_font, SCRIPTF * p->pict_fs);\n\t\t      /* adjust position */\n\t\t      if (p->pict_txt[t][tc] == '^')\n\t\t\tfprintf(pict_out, \"0 %.3f rm \",\n\t\t\t\tSCRIPTH * p->pict_fs);\n\t\t      else\n\t\t\tfprintf(pict_out, \"0 %.3f rm \",\n\t\t\t\t-SCRIPTH * p->pict_fs);\n\t\t      inscript = 1;\n\t\t    }\n\t\t  tc++;\n\t\t}\n\t    }\n\t  fputs(\"\\ngr\\n\", pict_out);\t/* grestore */\n\t  toff = tc;\n\t  while (p->pict_txt[t][toff] == '\\n')\n\t    {\n\t      toff++;\n\t      yoff -= linespace * p->pict_fs;\n\t    }\n\t}\n    }\n  return p->pict_next;\t/* return link to next pict */\n}",
      "lines": 253,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "pict",
        "*show1(pict *p)",
        "*"
      ]
    },
    "pict_show": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        990,
        1
      ],
      "content": "void pict_show(pict *p)\n{\n  while (p)\t\t/* show each pict and follow the link */\n    p = show1(p);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "nport": {
      "start_point": [
        992,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "void nport(pict *p, int nplots, int nperpage)\n{\n  int pn;\n\n  if (nplots % nperpage)\n    {\n      fprintf(dap_err,\n\t      \"(nport) Number of plots %d not a multiple of number per page %d\\n\",\n\t      nplots, nperpage);\n      exit(1);\n    }\n  pict_port(nplots / nperpage);\n  for (pn = 0; pn < nplots; pn += nperpage)\n    {\n      pict_page();\n      pict_show(p + pn);\n    }\n  pict_end();\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "nland": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "void nland(pict *p, int nplots, int nperpage)\n{\n  int pn;\n\n  if (nplots % nperpage)\n    {\n      fprintf(dap_err,\n\t      \"(pict_nlandscape) Number of plots %d not a multiple of number per page %d\\n\",\n\t      nplots, nperpage);\n      exit(1);\n    }\n  pict_land(nplots / nperpage);\n  for (pn = 0; pn < nplots; pn += nperpage)\n    {\n      pict_page();\n      pict_show(p + pn);\n    }\n  pict_end();\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/ps.h": {},
  "dap/dap-3.10/src/ps1.c": {
    "pict_maketick": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void pict_maketick(tick *t, double num, char *label, double len)\n{\n  t->tick_num = num;\n  t->tick_lab = pict_newstr(label);\n  t->tick_len = len;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "yaxis": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void yaxis(pict *p, double miny, double maxy, tick ytick[], int nyticks,\n\t\t  double xpos, double ypos, double side, int marks)\n{\n  int ny;\t\t/* index to ytick[] */\n  char tpos[4];\t/* text positioning string for axis label */\n  char npos[3];\t/* text positioning string for numerical values */\n  double xlaboff;\t/* x offset for label */\n  double txtang;\t/* for rotating the label if it lies along the axis */\n  int lab1len;\t/* string length of one label */\n  int labslen;\t/* maximum string length of labels */\n\n  strcpy(tpos, \"cb \");\t/* coordinates give center, bottom point of axis label */\n  if (side > 0.0)\t\t/* if ticks extend to right */\n    strcpy(npos, \"rm\");\t/* coordinates give right, middle point of number */\n  else\t\t\t/* if ticks extend to left */\n    strcpy(npos, \"lm\");\t/* coordinates give left, middle point of number */\n  for (labslen = 0, ny = 0; ny < nyticks; ny++)\n    {\t\t/* find maximum string length of numerical labels */\n      lab1len = strlen(ytick[ny].tick_lab);\n      if (lab1len > labslen)\n\tlabslen = lab1len;\n    }\n  txtang = 0.0;\t/* used if label is at the top of the y-axis */\n  /* check to see if axes label \"tick\" is between bottom and top \"real\" ticks,\n   * so that axis label is along side the axis\n   */\n  if (miny <= ytick[nyticks].tick_num && ytick[nyticks].tick_num <= maxy)\n    {\n      /* have to increase distance for label to leave room for\n       * numerical labels\n       */\n      strcpy(tpos, \"cb \");\t/* coordinates give center, bottom point of axis label */\n      xlaboff = 0.25 * p->pict_fs * ((double) (labslen + 6)) * fabs(ytick[nyticks].tick_len);\n      txtang = side * 90.0;\n    }\n  else if (ytick[nyticks].tick_num < miny)\t/* label at bottom */\n    {\n      strcpy(tpos, \"ct \");\t/* coordinates give center, top point of axis label */\n      xlaboff = 0.0;\n    }\n  else\t\t\t\t\t\t\t/* label at top */\n    {\n      strcpy(tpos, \"cb \");\t/* coordinates give center, bottom point of axis label */\n      xlaboff = 0.0;\n    }\n  /* for ticks extending to right or if extending to left and using marks */\n  if (side > 0.0 || marks)\n    pict_text(p, ytick[nyticks].tick_lab, ypos - side * xlaboff,\n\t      ytick[nyticks].tick_num, txtang, tpos);\n  pict_point(p, ypos, maxy);\n  while (--nyticks >= 0)\n    {\n      pict_point(p, ypos, ytick[nyticks].tick_num);\n      pict_point(p, ypos + side * ytick[nyticks].tick_len, ytick[nyticks].tick_num);\n      pict_point(p, ypos, ytick[nyticks].tick_num);\n      if (side > 0.0 || marks)\n\tpict_text(p, ytick[nyticks].tick_lab,\n\t\t  ypos - (4.5 * side - 0.5) * fabs(ytick[nyticks].tick_len),\n\t\t  ytick[nyticks].tick_num, 0.0, npos);\n    }\n  pict_point(p, ypos, miny);\n  pict_point(p, ypos, xpos);\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xaxis": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static void xaxis(pict *p, double minx, double maxx, tick xtick[], int nxticks,\n\t\t  double xpos, double ypos, double side, int marks)\n{\n  int nx;\t\t/* index to xtick array */\n  char tpos[4];\t/* position string for axis label for pict_text */\n  char npos[3];\t/* position string for numerical labels for pict_text */\n  double ylaboff;\t/* y offset for label */\n  int lab1len;\t/* length of one numerical label */\n  int labslen;\t/* max length of numerical labels */\n\n  strcpy(tpos, \"lt \");\t/* default for axis label is left, top of label at tick */\n  strcpy(npos, \"ct\");\t/* default for tick label is centered, top of label at tick */\n  for (labslen = 0, nx = 0; nx < nxticks; nx++)\n    {\t\t/* find maximum string length of numerical labels */\n      lab1len = strlen(xtick[nx].tick_lab);\n      if (lab1len > labslen)\n\tlabslen = lab1len;\n    }\n  if (minx <= xtick[nxticks].tick_num && xtick[nxticks].tick_num <= maxx)\n    {\t/* if the axis label is going on the side, not the end */\n      tpos[0] = 'c';\t/* center the text */\n      if (side < 0.0)\n\t{\n\t  tpos[1] = 'b';\n\t  npos[1] = 'b';\n\t}\n      ylaboff = fabs(p->pict_fs * xtick[nxticks].tick_len); /* make room for label */\n    }\n  else if (xtick[nxticks].tick_num < minx)\t/* axis label at left end */\n    {\n      strcpy(tpos, \"rm \");\n      ylaboff = 0.0;\n    }\n  else\t\t\t\t\t\t\t/* axis label at right end */\n    {\n      strcpy(tpos, \"lm \");\n      ylaboff = 0.0;\n    }\n  if (side > 0.0 || marks)\t/* this is the axis label, but only label if ticking */\n    pict_text(p, xtick[nxticks].tick_lab, xtick[nxticks].tick_num,\n\t      xpos - side * ylaboff, 0.0, tpos);\n  pict_point(p, maxx, xpos);\n  while (--nxticks >= 0)\t/* for the real ticks */\n    {\n      pict_point(p, xtick[nxticks].tick_num, xpos);\n      if (side > 0.0 || marks)\n\tpict_point(p, xtick[nxticks].tick_num, xpos + side * xtick[nxticks].tick_len);\n      pict_point(p, xtick[nxticks].tick_num, xpos);\n      if (side > 0.0 || marks)\n\tpict_text(p, xtick[nxticks].tick_lab, xtick[nxticks].tick_num,\n\t\t  xpos - 2.0 * side * fabs(xtick[nxticks].tick_len), 0.0, npos);\n    }\n  pict_point(p, minx, xpos);\n  pict_point(p, ypos, xpos);\t/* end up at ypos, xpos */\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pict_axes": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "void pict_axes(pict *p, double minx, double maxx, tick xtick[], int nxticks,\n\t       double miny, double maxy, tick ytick[], int nyticks,\n\t       char style[], double bpos, double lpos, double tpos, double rpos)\n{\n  double xpos, ypos;\t/* y-coordinate of x-axis, x-coordinate of y-axis */\n  int rmarks, tmarks;\t/* put tick marks on right, top? */\n\n  xpos = 0.0;\t/* default is x-axis at 0 on y-axis */\n  ypos = 0.0;\t/* default is y-axis at 0 on x-axis */\n  rmarks = 0;\t/* default is no ticks on right axis */\n  tmarks = 0;\t/* default is no ticks on top axis */\n  if (style[0] == '+' || style[0] == '#')\t/* ticked axis at top */\n    tmarks = 1;\n  if (style[1] == '+' || style[1] == '#')\t/* ticked axis at right */\n    rmarks = 1;\n  if (style[0] != '=' && style[1] != '=' &&\n      style[0] != '#' && style[1] != '#')\n    {\t\t\t/* at most one of each axis */\n      switch (style[0])\n\t{\n\tcase '-':\n\t  xpos = bpos;\n\t  break;\n\tcase '+':\n\t  xpos = tpos;\n\t  break;\n\tcase '0':\n\tcase 'n':\n\t  xpos = 0.0;\n\t  break;\n\t}\n      switch (style[1])\n\t{\n\tcase '-':\n\t  ypos = lpos;\n\t  break;\n\tcase '+':\n\t  ypos = rpos;\n\t  break;\n\tcase '0':\n\tcase 'n':\n\t  ypos = 0.0;\n\t  break;\n\t}\n      switch (style[0])\n\t{\n\tcase '-':\n\tcase '0':\n\t  xaxis(p, minx, maxx, xtick, nxticks, xpos, ypos, 1.0, tmarks);\n\t  break;\n\tcase '+':\n\t  xaxis(p, minx, maxx, xtick, nxticks, xpos, ypos, -1.0, tmarks);\n\t  break;\n\tcase 'n':\n\t  break;\n\t}\n      switch (style[1])\n\t{\n\tcase '-':\n\tcase '0':\n\t  yaxis(p, miny, maxy, ytick, nyticks, xpos, ypos, 1.0, rmarks);\n\t  break;\n\tcase '+':\n\t  yaxis(p, miny, maxy, ytick, nyticks, xpos, ypos, -1.0, rmarks);\n\t  break;\n\tcase 'n':\n\t  break;\n\t}\n    }\n  else if (style[0] != '=' && style[0] != '#')\n    {\t/* y-axis on left and right, but only one x-axis */\n      switch (style[0])\n\t{\n\tcase '-':\n\t  xpos = bpos;\n\tcase '0':\n\t  yaxis(p, miny, maxy, ytick, nyticks, xpos, lpos, 1.0, rmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, xpos, lpos, 1.0, tmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, xpos, rpos, 1.0, tmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, xpos, rpos, -1.0, rmarks);\n\t  break;\n\tcase '+':\n\t  yaxis(p, miny, maxy, ytick, nyticks, tpos, lpos, 1.0, rmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, tpos, lpos, -1.0, tmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, tpos, rpos, -1.0, tmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, tpos, rpos, -1.0, rmarks);\n\t  break;\n\tcase 'n':\n\t  fputs(\"(axes) Can't have double y-axes and no x-axis.\\n\", dap_err);\n\t  exit(1);\n\t}\n    }\n  else if (style[1] != '=' && style[1] != '#')\n    {\t/* x-axis on top and bottom, but only one y-axis */\n      switch (style[1])\n\t{\n\tcase '-':\n\t  ypos = lpos;\n\tcase '0':\n\t  xaxis(p, minx, maxx, xtick, nxticks, bpos, ypos, 1.0, tmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, bpos, ypos, 1.0, rmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, tpos, ypos, 1.0, rmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, tpos, ypos, -1.0, tmarks);\n\t  break;\n\tcase '+':\n\t  xaxis(p, minx, maxx, xtick, nxticks, bpos, rpos, 1.0, tmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, bpos, rpos, -1.0, rmarks);\n\t  yaxis(p, miny, maxy, ytick, nyticks, tpos, rpos, -1.0, rmarks);\n\t  xaxis(p, minx, maxx, xtick, nxticks, tpos, rpos, -1.0, tmarks);\n\t  break;\n\tcase 'n':\n\t  fputs(\"(axes) Can't have double x-axes and no y-axis.\\n\", dap_err);\n\t  exit(1);\n\t}\n    }\n  else\n    {\t/* totally boxed */\n      yaxis(p, miny, maxy, ytick, nyticks, bpos, lpos, 1.0, rmarks);\n      xaxis(p, minx, maxx, xtick, nxticks, bpos, rpos, 1.0, tmarks);\n      yaxis(p, miny, maxy, ytick, nyticks, tpos, rpos, -1.0, rmarks);\n      xaxis(p, minx, maxx, xtick, nxticks, tpos, lpos, -1.0, tmarks);\n    }\n}",
      "lines": 123,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "makeform": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static void makeform(char form[], double max, int ndigs)\n{\n  int ndec;\t/* number of decimal places */\n  double scale;\t/* power of 10 to compare max to */\n\n  if (ndigs > 9)\n    ndigs = 9;\n  max = fabs(max);\n  strcpy(form, \"%.0f\");\n  if (max == 0.0)\t\t/* this really shouldn't happen */\n    sprintf(form, \"%%.%dg\", ndigs);\n  else\n    {\n      for (scale = 1.0; ndigs > 1; ndigs--)\n\tscale *= 10.0;\n      for (ndec = 0; max < scale; max *= 10.0)\n\tndec++;\n      if (ndec > 9)\n\tndec = 9;\n      form[2] += ndec;\n    }\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ticks": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "static void ticks(\n\t\t  tick ticks[],\t\t/* array of ticks to make, allocated by caller */\n\t\t  double min,\t\t/* coordinate of lowest valued tick */\n\t\t  double max,\t\t/* coordinate of highest valued tick */\n\t\t  int ndigs,\t\t/* number of digits for tick label */\n\t\t  double ticklen,\t/* length of tick line */\n\t\t  int nticks,\t\t/* number of ticks requested not including axis label */\n\t\t  double labpos,\t\t/* position of axis label */\n\t\t  char *alab,\t\t/* axis label */\n\t\t  double (*tfunct)()\t/* function for adjusting printed values at ticks */\n\t\t  )\n{\n  int n;\n  static char *lab;\n  double coord;\n  double space;\n  double tcoord;\t\t/* coord or transformed coord */\n  char form[5];\t\t/* format string */\n  double tmin, tmax;\t/* (possibly) transformed min, max */\n\n  if (!lab)\n    lab = dap_malloc(dap_maxtxt + 1, \"dap_maxtxt\");\n  if (nticks > 1)\n    space = (max - min) / (double) (nticks - 1);\n  else\n    space = 0;\n  if (tfunct)\n    tmin = tfunct(min);\n  else\n    tmin = min;\n  tmin = fabs(tmin);\n  if (tfunct)\n    tmax = tfunct(max);\n  else\n    tmax = max;\n  tmax = fabs(tmax);\n  if (tmin > tmax)\n    tmax = tmin;\n  makeform(form, tmax, ndigs);\n  for (n = 0; n < nticks; n++)\n    {\n      if (nticks > 1)\n\tcoord = min + space * (double) n;\n      else\n\tcoord = (min + max) / 2.0;\n      if (tfunct)\n\ttcoord = (*tfunct)(coord);\n      else\n\ttcoord = coord;\n      sprintf(lab, form, tcoord);\n      pict_maketick(ticks + n, coord, lab, ticklen);\n    }\n  pict_maketick(ticks + n, labpos, alab, ticklen);\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pict_autoaxes": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "double pict_autoaxes(pict *p, char *xlab, char *ylab, char *axspec,\n\t\t     double (*xfunct)(), double (*yfunct)(), char *caption, int autopos)\n{\n  pict *pp;\t\t\t\t/* for stepping through array of picts */\n  int totpts;\t\t\t\t/* total number of points */\n  double minx, maxx, miny, maxy;\t\t/* min, max values of x, y in picts */\n  double minxt, maxxt, minyt, maxyt;\t/* min, max tick values */\n  int nxticks, nyticks;\t\t\t/* number of ticks, for x, y */\n  tick *xticks;\t\t\t\t/* tick array for x */\n  tick *yticks;\t\t\t\t/* tick array for y */\n  double xticklen;\t\t\t/* length of tick mark for x */\n  double yticklen;\t\t\t/* length of tick mark for y */\n  char as[3];\t\t\t\t/* axis specifications, from axspec */\n  double lpos, rpos, bpos, tpos;\t\t/* axis positions: left, right ends of x-axis,\n\t\t\t\t\t\t * bottom, top ends of y-axis\n\t\t\t\t\t\t */\n  double xlabpos, ylabpos;\t/* coordinates of position of x, y axis labels */\n  double captoff;\t\t\t/* offset into caption */\n  double width, height;\t\t/* width, height of graph in points */\n  double specxmax, specxmin;\t/* specified min, max for x */\n  double specymax, specymin;\t/* specified min, max for y */\n  int specxticks, specyticks;\t/* specified number of ticks, for x, y */\n  int nxdigs, nydigs;\t\t/* number of digits for tick labels, for x, y */\n  int a, w;\t\t\t/* indexs to axspec, word */\n  char *word;\t\t\t/* word extracted from axspec */\n  double digs, places, sign;\t/* for computing max, min numbers */\n  int nt;\t\t\t\t/* number of ticks */\n  double xscale, yscale;\t\t/* to compensate for scaling in label positions */\n  int xlablines;\t\t\t/* number lines in xlabel */\n\n  /* start out with centered around 0.0 */\n  minx = 0.0;\n  maxx = 0.0;\n  miny = 0.0;\n  maxy = 0.0;\n  lpos = 0.0;\n  rpos = 0.0;\n  bpos = 0.0;\n  tpos = 0.0;\n  xlabpos = 0.0;\n  ylabpos = 0.0;\n  /* no scaling yet */\n  xscale = 1.0;\n  yscale = 1.0;\n  captoff = 0.0;\n  /* allocate tick arrays */\n  xticks = (tick *) dap_malloc(sizeof(tick) * dap_maxntxt, \"dap_maxntxt\");\n  yticks = (tick *) dap_malloc(sizeof(tick) * dap_maxntxt, \"dap_maxntxt\");\n  /* default is nothing specified: make NaNs, -1 */\n  specxmin = 0.0 / 0.0;\n  specxmax = 0.0 / 0.0;\n  specymin = 0.0 / 0.0;\n  specymax = 0.0 / 0.0;\n  specxticks = -1;\n  specyticks = -1;\n  nxdigs = 3;\n  nydigs = 3;\n  /* allocate word */\n  word = dap_malloc(dap_namelen + 1, \"\");\n  /* now parse the axis specifications, if present */\n  if (axspec && axspec[0])\n    {\n      /* first skip blanks */\n      for (a = 0; axspec[a] == ' '; a++)\n\t;\n      /* if there are axis formats */\n      if (axspec[a] == '-' || axspec[a] == '+' || axspec[a] == '0' ||\n\t  axspec[a] == 'n' || axspec[a] == '=' ||\n\t  axspec[a] == '#')\n\t{\n\t  /* copy to as */\n\t  as[0] = axspec[a++];\n\t  if (axspec[a] == '-' || axspec[a] == '+' || axspec[a] == '0' ||\n\t      axspec[a] == 'n' || axspec[a] == '=' ||\n\t      axspec[a] == '#')\n\t    as[1] = axspec[a++];\n\t  else\t/* no second char, make '0' as default */\n\t    as[1] = '0';\n\t}\n      else\t/* otherwise, use default */\n\tstrcpy(as, \"00\");\n      as[2] = '\\0';\n      /* now look for other words */\n      while (axspec[a] == ' ')\n\ta++;\n      while (axspec[a])\n\t{\n\t  /* extract one word */\n\t  for (w = 0; axspec[a] && axspec[a] != ' '; )\n\t    {\n\t      if (w < dap_namelen)\n\t\tword[w++] = axspec[a++];\n\t      else\n\t\t{\n\t\t  word[w] = '\\0';\n\t\t  fprintf(dap_err,\n\t\t\t  \"(pict_autoaxes) word in axspec too long: %s\\n\",\n\t\t\t  word);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  word[w] = '\\0';\n\t  if (!strncmp(word, \"MAXX\", 4) || !strncmp(word, \"MINX\", 4) ||\n\t      !strncmp(word, \"MAXY\", 4) || !strncmp(word, \"MINY\", 4))\n\t    {\n\t      /* for max, min spec, position at next char for number */\n\t      w = 4;\n\t      /* default is positive, see if negative */\n\t      sign = 1.0;\n\t      if (word[w] == '-')\n\t\t{\n\t\t  sign = -1.0;\n\t\t  w++;\n\t\t}\n\t      /* standard decimal conversion, allowing for dec pt */\n\t      for (digs = 0.0, places = 0.0;\n\t\t   ('0' <= word[w] && word[w] <= '9') ||\n\t\t     word[w] == '.'; w++)\n\t\t{\n\t\t  if (word[w] == '.')\n\t\t    {\n\t\t      if (places > 0.0)\n\t\t\t{\n\t\t\t  fprintf(dap_err,\n\t\t\t\t  \"(pict_autoaxes) bad number for MIN or MAX: %s\\n\",\n\t\t\t\t  word + 4);\n\t\t\t  exit(1);\n\t\t\t}\n\t\t      places = 1.0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (places > 0.0)\n\t\t\tplaces *= 10.0;\n\t\t      digs = 10.0 * digs +\n\t\t\t(double) (word[w] - '0');\n\t\t    }\n\t\t}\n\t      digs *= sign;\n\t      if (places > 0.0)\n\t\tdigs /= places;\n\t      /* should be space after number */\n\t      if (word[w] && word[w] != ' ')\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(pict_autoaxes) bad number for MIN or MAX: %s\\n\",\n\t\t\t  word + 3);\n\t\t  exit(1);\n\t\t}\n\t      /* mAx or mIn, m.X or m.Y */\n\t      if (word[1] == 'A')\n\t\t{\n\t\t  if (word[3] == 'X')\n\t\t    specxmax = digs;\n\t\t  else\n\t\t    specymax = digs;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (word[3] == 'X')\n\t\t    specxmin = digs;\n\t\t  else\n\t\t    specymin = digs;\n\t\t}\n\t    }\n\t  /* now if was tick spec instead */\n\t  else if (!strncmp(word, \"NXTICKS\", 7) ||\n\t\t   !strncmp(word, \"NYTICKS\", 7))\n\t    {\n\t      /* integer conversion */\n\t      for (nt = 0, w = 7; '0' <= word[w] && word[w] <= '9'; w++)\n\t\tnt = 10 * nt + word[w] - '0';\n\t      /* should have number, should end in space */\n\t      if (word[w] && word[w] != ' ')\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(pict_autoaxes) bad number of ticks: %s\\n\",\n\t\t\t  word + 7);\n\t\t  exit(1);\n\t\t}\n\t      /* nXticks or nYticks */\n\t      if (word[1] == 'X')\n\t\tspecxticks = nt;\n\t      else\n\t\tspecyticks = nt;\n\t    }\n\t  /* now if specifying label precision */\n\t  else if (!strncmp(word, \"NXDIGITS\", 8) ||\n\t\t   !strncmp(word, \"NYDIGITS\", 8))\n\t    {\n\t      /* integer conversion */\n\t      for (nt = 0, w = 8; '0' <= word[w] && word[w] <= '9'; w++)\n\t\tnt = 10 * nt + word[w] - '0';\n\t      /* should have number, should end in space */\n\t      if (word[w] && word[w] != ' ')\n\t\t{\n\t\t  fprintf(dap_err,\n\t\t\t  \"(pict_autoaxes) bad number of digits: %s\\n\",\n\t\t\t  word + 8);\n\t\t  exit(1);\n\t\t}\n\t      /* nXdigits or nYdigits */\n\t      if (word[1] == 'X')\n\t\tnxdigs = nt;\n\t      else\n\t\tnydigs = nt;\n\t    }\n\t  else\t/* tried to match and failed */\n\t    {\n\t      fprintf(dap_err,\n\t\t      \"(pict_autoaxes) bad axes specification: %s\\n\",\n\t\t      word);\n\t      exit(1);\n\t    }\n\t  /* and on to the next */\n\t  while (axspec[a] == ' ')\n\t    a++;\n\t}\n    }\n  else\t/* the default */\n    strcpy(as, \"00\");\n  /* now we find the min, max for x, y for all the points in the pict\n   * and check that there are indeed points\n   */\n  for (pp = p, totpts = 0; pp && pp->pict_next; pp = pp->pict_next)\n    {\t/* step through linked list of picts */\n      if (pp->pict_npts)\n\t{\n\t  if (pp == p || minx > pp->pict_minx)\n\t    minx = pp->pict_minx;\n\t  if (pp == p || miny > pp->pict_miny)\n\t    miny = pp->pict_miny;\n\t  if (pp == p || maxx < pp->pict_maxx)\n\t    maxx = pp->pict_maxx;\n\t  if (pp == p || maxy < pp->pict_maxy)\n\t    maxy = pp->pict_maxy;\n\t  totpts += pp->pict_npts;\n\t}\n    }\n  if (!totpts)\n    {\n      fputs(\"(pict_autoaxes) no points.\\n\", dap_err);\n      exit(1);\n    }\n  /* the specs were set to NaNs, so if finite, they were present */\n  if (finite(specxmin))\n    minx = specxmin;\n  else\t/* we like to make minx leave a little extra room and be a nice decimal;\n\t * note that we are not dealing with xfunct and yfunct, because we have\n\t * no inverse functions for them: the caller will just have to deal with those.\n\t */\n    {\n      /* first make sure it includes 0 */\n      if (minx > 0.0)\n\tminx = 0.0;\n    }\n  if (finite(specxmax))\n    maxx = specxmax;\n  else\n    {\n      if (maxx < 0.0)\n\tmaxx = 0.0;\n    }\n  minxt = minx;\n  minx -= AXISMARGIN * (maxx - minx);\n  maxxt = maxx;\n  maxx += AXISMARGIN * (maxx - minx);\n  if (finite(specymin))\n    miny = specymin;\n  else\n    {\n      if (miny > 0.0)\n\tminy = 0.0;\n    }\n  if (finite(specymax))\n    maxy = specymax;\n  else\n    {\n      if (maxy < 0.0)\n\tmaxy = 0.0;\n    }\n  minyt = miny;\n  if (miny != 0.0)\n    miny -= AXISMARGIN * (maxy - miny);\n  maxyt = maxy;\n  maxy += AXISMARGIN * (maxy - miny);\n  if (specxticks >= 0)\n    nxticks = specxticks;\n  else\n    nxticks = 11;\n  if (nxticks > dap_maxntxt)\n    {\n      fprintf(dap_err, \"(pict_autoaxes) Too many x-ticks (%d)\\n\", nxticks);\n      exit(1);\n    }\n  if (specyticks >= 0)\n    nyticks = specyticks;\n  else\n    nyticks = 11;\n  if (nyticks > dap_maxntxt)\n    {\n      fprintf(dap_err, \"(pict_autoaxes) Too many y-ticks (%d)\\n\", nyticks);\n      exit(1);\n    }\n  xticklen = -2.0;\n  yticklen = -2.0;\n  if (autopos)\n    {\n      if (autopos == PORTRAIT)\n\t{\n\t  width = PORTWIDTH;\n\t  height = PORTHEIGHT;\n\t}\n      else\n\t{\n\t  width = LANDWIDTH;\n\t  height = LANDHEIGHT;\n\t}\n      xscale = width / (maxx - minx);\n      yscale = height / (maxy - miny);\n    }\n  if (as[0] == '=' || as[0] == '#')\t/* if x-axis is bottom and top */\n    {\n      bpos = miny;\n      tpos = maxy;\n      xlabpos = 0.5 * (minx + maxx);\n      captoff = 4.0 * p->pict_fs / yscale;\n    }\n  else if (as[0] != 'n')\t\t/* else if there is to be an x-axis at all */\n    {\n      switch (as[0])\n\t{\n\tcase '-':\n\t  bpos = miny;\n\t  xlabpos = 0.5 * (minx + maxx);\n\t  captoff = 4.0 * p->pict_fs / yscale;\n\t  break;\n\tcase '+':\n\t  tpos = maxy;\n\t  xlabpos = 0.5 * (minx + maxx);\n\t  captoff = 4.0 * p->pict_fs / yscale;\n\t  break;\n\tcase '0':\n\t  bpos = 0.0;\n\t  if (as[1] == '+')\n\t    xlabpos = minx - 0.05 * (maxx - minx);\n\t  else\n\t    xlabpos = maxx + 0.05 * (maxx - minx);\n\t  captoff = 2.0 * p->pict_fs / yscale;\n\t  break;\n\tdefault:\n\t  fprintf(dap_err, \"(pict_autoaxes) Bad axis specification: %s\\n\", axspec);\n\t  exit(1);\n\t}\n    }\n  if (as[1] == '=' || as[1] == '#')\t/* if y-axis is bottom and top */\n    {\n      lpos = minx;\n      rpos = maxx;\n      ylabpos = 0.5 * (miny + maxy);\n    }\n  else if (as[1] != 'n')\n    {\n      switch (as[1])\n\t{\n\tcase '-':\n\t  lpos = minx;\n\t  ylabpos = 0.5 * (miny + maxy);\n\t  break;\n\tcase '+':\n\t  rpos = maxx;\n\t  ylabpos = 0.5 * (miny + maxy);\n\t  break;\n\tcase '0':\n\t  lpos = 0.0;\n\t  if (as[0] == '+')\n\t    ylabpos = miny - 0.05 * (maxy - miny);\n\t  else\n\t    ylabpos = maxy + 0.05 * (maxy - miny);\n\t  break;\n\tdefault:\n\t  fprintf(dap_err, \"(autoaxes) Bad axis specification: %s\\n\", axspec);\n\t  exit(1);\n\t}\n    }\n  for (w = 0, xlablines = 0; xlab[w]; w++)\n    {\n      if (xlab[w] == '\\n')\n\txlablines++;\n    }\n  captoff += 1.4 * xlablines * p->pict_fs / yscale;\n  ticks(xticks, minxt, maxxt, nxdigs, xticklen / yscale,\n\tnxticks, xlabpos, xlab, xfunct);\n  ticks(yticks, minyt, maxyt, nydigs, yticklen / xscale,\n\tnyticks, ylabpos, ylab, yfunct);\n  pict_axes(pp, minx, maxx, xticks, nxticks,\n\t    miny, maxy, yticks, nyticks, as, bpos, lpos, tpos, rpos);\n  pict_text(pp, caption, 0.5 * (minx + maxx), miny - captoff, 0.0, \"ct \");\n  if (autopos)\n    {\n      pict_scale(p, 0.5 * (minx + maxx), 0.5 * (miny + maxy), xscale, yscale);\n      pict_translate(p, LEFT + 0.5 * (width - (minx + maxx)),\n\t\t     BOTTOM + 0.5 * (height - (miny + maxy)));\n    }\n  dap_free(xticks, \"\");\n  dap_free(yticks, \"\");\n  dap_free(word, \"\");\n  return sqrt((width * width + height * height) / RADIUSFACTOR);\n}",
      "lines": 409,
      "depth": 20,
      "decorators": [
        "double"
      ]
    },
    "pict_save": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "void pict_save(pict *p, int npicts, char *dataset)\n{\n  pict *firstp;\t/* start of pict list */\n  int pn;\t\t/* picture number */\n  char strspec[15];\n  int len;\n  int maxlen;\n  int pict_npts;\t\t\t\t/* number of points in pict, if any */\n  char pict_type[5];\t\t\t/* \"LINE\" = connected lines */\n  double pict_dash;\t\t\t/* dash length for lines if > 0.0 */\n  double pict_minx, pict_maxx;\t\t/* bounds */\n  double pict_miny, pict_maxy;\t\t/* bounds */\n  int pict_ntxt;\t\t\t\t/* number of texts */\n  char *pict_font;\t\t\t/* font for displayed text, if any */\n  double pict_fs;\t\t\t\t/* font size */\n  double pict_lw;\t\t\t\t/* line width */\n  double pict_r;\t\t\t\t/* radius for circles */\n  double pict_lgray;              \t/* gray level for lines */ \n  double pict_fgray;              \t/* gray level for fill: if >= 0, fill then stroke */\n  int pict_next;\t\t\t\t/* next pict in list */\n  double pict_pt[2];\t\t\t/* the points */\n  int ptn;\n  char *pict_txt;\n  double pict_tpt[2];\t\t\t/* location of text */\n  double pict_tang;\t\t\t/* angle for text */\n  char pict_pos[4];\t\t\t/* text position */\n  char *outname;\n  int pict_patt;\t\t\t\t/* pattern number */\n\n  firstp = p;\n\n  for (p = firstp, maxlen = 0; p; )\n    {\n      len = strlen(p->pict_font);\n      if (len > maxlen)\n\tmaxlen = len;\n      for (ptn = 0; ptn < p->pict_ntxt; ptn++)\n\t{\n\t  len = strlen(p->pict_txt[ptn]);\n\t  if (len > maxlen)\n\t    maxlen = len;\n\t}\n      if (npicts)\n\t{\n\t  if (++p >= firstp + npicts)\n\t    break;\n\t}\n      else\n\tp = p->pict_next;\n    }\n  if (maxlen > 9998)\n    {\n      fprintf(dap_err, \"(pict_save) maximum string length too long: %d\\n\", maxlen);\n      exit(1);\n    }\n  pict_font = dap_malloc(maxlen + 1, \"\");\n  pict_txt = dap_malloc(maxlen + 1, \"\");\n\n  /* first write out basic structure */\n  infile(NULL, NULL);\n  dap_vd(\"pict_npts 0\", 0); dap_il(\"pict_npts\", &pict_npts);\n  dap_vd(\"pict_type 5\", 0); dap_sl(\"pict_type\", pict_type);\n  dap_vd(\"pict_dash -1\", 0); dap_dl(\"pict_dash\", &pict_dash);\n  dap_vd(\"pict_minx -1\", 0); dap_dl(\"pict_minx\", &pict_minx);\n  dap_vd(\"pict_maxx -1\", 0); dap_dl(\"pict_maxx\", &pict_maxx);\n  dap_vd(\"pict_miny -1\", 0); dap_dl(\"pict_miny\", &pict_miny);\n  dap_vd(\"pict_maxy -1\", 0); dap_dl(\"pict_maxy\", &pict_maxy);\n  dap_vd(\"pict_ntxt 0\", 0); dap_il(\"pict_ntxt\", &pict_ntxt);\n  sprintf(strspec, \"pict_font %d\", maxlen);\n  dap_vd(strspec, 0); dap_sl(\"pict_font\", pict_font);\n  dap_vd(\"pict_fs -1\", 0); dap_dl(\"pict_fs\", &pict_fs);\n  dap_vd(\"pict_lw -1\", 0); dap_dl(\"pict_lw\", &pict_lw);\n  dap_vd(\"pict_r -1\", 0); dap_dl(\"pict_r\", &pict_r);\n  dap_vd(\"pict_lgray -1\", 0); dap_dl(\"pict_lgray\", &pict_lgray);\n  dap_vd(\"pict_fgray -1\", 0); dap_dl(\"pict_fgray\", &pict_fgray);\n  dap_vd(\"pict_next 0\", 0); dap_il(\"pict_next\", &pict_next);\n  dap_vd(\"pict_patt 0\", 0); dap_il(\"pict_patt\", &pict_patt);\n  outname = dap_malloc(strlen(dataset) + 9, \"\"); /* max 10000 picts */\n  for (pn = 0, p = firstp; p; pn++)\n    {\n      if (pn < MAXPICTSAVE)\n\t{\n\t  sprintf(outname, \"%s.pic%04d\", dataset, pn);\n\t  outset(outname, \"\");\n\t  pict_npts = p->pict_npts;\n\t  strcpy(pict_type, p->pict_type);\n\t  pict_dash = p->pict_dash;\n\t  pict_minx = p->pict_minx;\n\t  pict_maxx = p->pict_maxx;\n\t  pict_miny = p->pict_miny;\n\t  pict_maxy = p->pict_maxy;\n\t  pict_ntxt = p->pict_ntxt;\n\t  strcpy(pict_font, p->pict_font);\n\t  pict_fs = p->pict_fs;\n\t  pict_lw = p->pict_lw;\n\t  pict_r = p->pict_r;\n\t  pict_lgray = p->pict_lgray;\n\t  pict_fgray = p->pict_fgray;\n\t  if (npicts)\n\t    {\n\t      if (pn < npicts - 1)\n\t\t{\n\t\t  if (p->pict_next)\n\t\t    pict_next = -(p->pict_next - firstp);\n\t\t  else\n\t\t    pict_next = -pn;\n\t\t}\n\t      else\n\t\tpict_next = 0;\n\t    }\n\t  else\n\t    {\n\t      if (p->pict_next)\n\t\tpict_next = pn + 1;\n\t      else\n\t\tpict_next = 0;\n\t    }\n\t  if (p->pict_patt)\n\t    pict_patt = 1;\n\t  else\n\t    pict_patt = 0;\n\t  output();\n\t}\n      else\n\t{\n\t  fputs(\"(pict_save) too many picts.\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (npicts)\n\t{\n\t  if (++p >= firstp + npicts)\n\t    break;\n\t}\n      else\n\tp = p->pict_next;\n    }\n  infile(NULL, NULL);\n  dap_vd(\"pict_pt[0] -1 pict_pt[1] - 1\", 0);\n  dap_dl(\"pict_pt\", pict_pt);\n  for (pn = 0, p = firstp; p; pn++)\n    {\n      sprintf(outname, \"%s.pts%04d\", dataset, pn);\n      outset(outname, \"\");\n      for (ptn = 0; ptn < p->pict_npts; ptn++)\n\t{\n\t  pict_pt[0] = p->pict_pt[ptn][0];\n\t  pict_pt[1] = p->pict_pt[ptn][1];\n\t  output();\n\t}\n      if (npicts)\n\t{\n\t  if (++p >= firstp + npicts)\n\t    break;\n\t}\n      else\n\tp = p->pict_next;\n    }\n  infile(NULL, NULL);\n  sprintf(strspec, \"pict_txt %d\", maxlen);\n  dap_vd(strspec, 0); dap_sl(\"pict_txt\", pict_txt);\n  dap_vd(\"pict_tpt[0] -1 pict_tpt[1] -1\", 0);\n  dap_dl(\"pict_tpt\", pict_tpt);\n  dap_vd(\"pict_tang -1\", 0); dap_dl(\"pict_tang\", &pict_tang);\n  dap_vd(\"pict_pos 3\", 0); dap_sl(\"pict_pos\", pict_pos);\n  for (pn = 0, p = firstp; p; pn++)\n    {\n      sprintf(outname, \"%s.txt%04d\", dataset, pn);\n      outset(outname, \"\");\n      for (ptn = 0; ptn < p->pict_ntxt; ptn++)\n\t{\n\t  strcpy(pict_txt, p->pict_txt[ptn]);\n\t  pict_tpt[0] = p->pict_tpt[ptn][0];\n\t  pict_tpt[1] = p->pict_tpt[ptn][1];\n\t  pict_tang = p->pict_tang[ptn];\n\t  strcpy(pict_pos, p->pict_pos[ptn]);\n\t  output();\n\t}\n      if (npicts)\n\t{\n\t  if (++p >= firstp + npicts)\n\t    break;\n\t}\n      else\n\tp = p->pict_next;\n    }\n  for (pn = 0, p = firstp; p; pn++)\n    {\n      if (p->pict_patt)\n\t{\n\t  sprintf(outname, \"%s.pat%04d\", dataset, pn++);\n\t  pict_save(p->pict_patt, 0, outname);\n\t}\n      if (npicts)\n\t{\n\t  if (++p >= firstp + npicts)\n\t    break;\n\t}\n      else\n\tp = p->pict_next;\n    }\n  dap_free(outname, \"\");\n  dap_free(pict_font, \"\");\n  dap_free(pict_txt, \"\");\n}",
      "lines": 204,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "pict_rest": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1300,
        1
      ],
      "content": "pict *pict_rest(char *dataset)\n{\n  int npict;\t/* total number of picts, including patterns */\n  pict *p;\n  char *inname;\n  int pn;\n  int ptn;\n  int pnext;\n  int npicts;\n  /* all these are indices to variables */\n  int pict_npts;\t\t\t\t/* number of points in pict, if any */\n  int pict_type;\t\t\t\t/* \"LINE\" = connected lines */\n  int pict_dash;\t\t\t\t/* dash length for lines if > 0.0 */\n  int pict_minx, pict_maxx;\t\t/* bounds */\n  int pict_miny, pict_maxy;\t\t/* bounds */\n  int pict_ntxt;\t\t\t\t/* number of texts */\n  int pict_font;\t\t\t\t/* font for displayed text, if any */\n  int pict_fs;\t\t\t\t/* font size */\n  int pict_lw;\t\t\t\t/* line width */\n  int pict_r;\t\t\t\t/* radius for circles */\n  int pict_lgray;              \t\t/* gray level for lines */ \n  int pict_fgray;              \t\t/* gray level for fill: if >= 0, fill then stroke */\n  int pict_pt;\t\t\t\t/* the points */\n  int pict_txt;\n  int pict_tpt;\t\t\t\t/* location of text */\n  int pict_tang;\t\t\t\t/* angle for text */\n  int pict_pos;\t\t\t\t/* text position */\n  int pict_next;\t\t\t\t/* link to next */\n  int pict_patt;\t\t\t\t/* pattern number */\n  int dim;\n  int npts;\n  double *dblmem;\n  char *charmem;\n\n  inname = dap_malloc(strlen(dataset) + 9, \"\");\n  for (pn = 0, npicts = 0; ; npicts++)\n    {\n      sprintf(inname, \"%s.pic%04d\", dataset, pn);\n      inset(inname);\n      step();\n      if ((pict_next = dap_varnum(\"pict_next\")) < 0)\n\t{\n\t  fprintf(dap_err, \"(pict_rest) no pict_next in %s\\n\", inname);\n\t  exit(1);\n\t}\n      pnext = dap_obs[0].do_int[pict_next];\n      if (!pnext)\n\tbreak;\n      if (pnext > 0)\n\tpn = pnext;\n      else if (pnext < 0)\n\t++pn;\n    }\n  npicts++;\n  p = (pict *) dap_malloc(sizeof(pict) * npicts, \"\");\n  for (pn = 0; pn < npicts; pn++)\n    {\n      sprintf(inname, \"%s.pic%04d\", dataset, pn);\n      inset(inname);\n      step();\n      if ((pict_npts = dap_varnum(\"pict_npts\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_npts\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_npts = dap_obs[0].do_int[pict_npts];\n      if ((pict_type = dap_varnum(\"pict_type\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_type\\n\", dap_err);\n\t  exit(1);\n\t}\n      strcpy(p[pn].pict_type, dap_obs[0].do_str[pict_type]);\n      if ((pict_dash = dap_varnum(\"pict_dash\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_dash\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_dash = dap_obs[0].do_dbl[pict_dash];\n      if ((pict_minx = dap_varnum(\"pict_minx\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_minx\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_minx = dap_obs[0].do_dbl[pict_minx];\n      if ((pict_maxx = dap_varnum(\"pict_maxx\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_maxx\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_maxx = dap_obs[0].do_dbl[pict_maxx];\n      if ((pict_miny = dap_varnum(\"pict_miny\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_miny\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_miny = dap_obs[0].do_dbl[pict_miny];\n      if ((pict_maxy = dap_varnum(\"pict_maxy\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_maxy\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_maxy = dap_obs[0].do_dbl[pict_maxy];\n      if ((pict_ntxt = dap_varnum(\"pict_ntxt\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_ntxt\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_ntxt = dap_obs[0].do_int[pict_ntxt];\n      if ((pict_font = dap_varnum(\"pict_font\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_font\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_font = dap_malloc(strlen(dap_obs[0].do_str[pict_font]) + 1, \"\");\n      strcpy(p[pn].pict_font, dap_obs[0].do_str[pict_font]);\n      if ((pict_fs = dap_varnum(\"pict_fs\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_fs\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_fs = dap_obs[0].do_dbl[pict_fs];\n      if ((pict_lw = dap_varnum(\"pict_lw\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_lw\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_lw = dap_obs[0].do_dbl[pict_lw];\n      if ((pict_r = dap_varnum(\"pict_r\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_r\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_r = dap_obs[0].do_dbl[pict_r];\n      if ((pict_lgray = dap_varnum(\"pict_lgray\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_lgray\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_lgray = dap_obs[0].do_dbl[pict_lgray];\n      if ((pict_fgray = dap_varnum(\"pict_fgray\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_fgray\\n\", dap_err);\n\t  exit(1);\n\t}\n      p[pn].pict_fgray = dap_obs[0].do_dbl[pict_fgray];\n      if ((pict_next = dap_varnum(\"pict_next\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_next\\n\", dap_err);\n\t  exit(1);\n\t}\n      pnext = dap_obs[0].do_int[pict_next];\n      if (pnext < 0)\n\t{\n\t  if (pnext == -pn)\n\t    p[pn].pict_next = NULL;\n\t  else\n\t    p[pn].pict_next = p - pnext;\n\t}\n      else if (pnext)\n\tp[pn].pict_next = p + pn + 1;\n      else\n\tp[pn].pict_next = NULL;\n      if ((pict_patt = dap_varnum(\"pict_patt\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_patt\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (dap_obs[0].do_int[pict_patt])\n\t{\n\t  sprintf(inname, \"%s.pat%04d\", dataset, pn);\n\t  p[pn].pict_patt = pict_rest(inname);\n\t}\n      else\n\tp[pn].pict_patt = NULL;\n    }\n  for (pn = 0; pn < npicts; pn++)\n    {\n      sprintf(inname, \"%s.pts%04d\", dataset, pn);\n      inset(inname);\n      if ((pict_pt = dap_arrnum(\"pict_pt\", &dim)) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_pt\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (dim != 2)\n\t{\n\t  fprintf(dap_err, \"(pict_rest) bad dimension for pict_pt: %d\\n\", dim);\n\t  exit(1);\n\t}\n      npts = p[pn].pict_npts;\n      for (ptn = 0, p[pn].pict_npts = 0; ptn < npts; ptn++)\n\t{\n\t  step();\n\t  pict_point(p + pn, dap_obs[0].do_dbl[pict_pt],\n\t\t     dap_obs[0].do_dbl[pict_pt + 1]);\n\t}\n    }\n  for (pn = 0; pn < npicts; pn++)\n    {\n      sprintf(inname, \"%s.txt%04d\", dataset, pn);\n      inset(inname);\n      npts = p[pn].pict_ntxt;\n      p[pn].pict_txt =\n\t(char **) dap_malloc(sizeof(char *) * dap_maxntxt, \"dap_maxntxt\");\n      dblmem =\n\t(double *) dap_malloc(sizeof(double) * 2 * dap_maxntxt, \"dap_maxntxt\");\n      p[pn].pict_tpt =\n\t(double **) dap_malloc(sizeof(double *) * dap_maxntxt, \"dap_maxntxt\");\n      for (ptn = 0; ptn < dap_maxntxt; ptn++)\n\tp[pn].pict_tpt[ptn] = dblmem + 2 * ptn;\n      p[pn].pict_tang =\n\t(double *) dap_malloc(sizeof(double) * dap_maxntxt, \"dap_maxntxt\");\n      charmem = dap_malloc(3 * dap_maxntxt, \"dap_maxntxt\"); \n      p[pn].pict_pos =\n\t(char **) dap_malloc(sizeof(char *) * dap_maxntxt, \"dap_maxntxt\");\n      for (ptn = 0; ptn < dap_maxntxt; ptn++)\n\tp[pn].pict_pos[ptn] = charmem + 3 * ptn;\n      if ((pict_txt = dap_varnum(\"pict_txt\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_txt\\n\", dap_err);\n\t  exit(1);\n\t}\n      if ((pict_tpt = dap_arrnum(\"pict_tpt\", &dim)) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_tpt\\n\", dap_err);\n\t  exit(1);\n\t}\n      if (dim != 2)\n\t{\n\t  fprintf(dap_err, \"(pict_rest) bad dimension for pict_tpt: %d\\n\", dim);\n\t  exit(1);\n\t}\n      if ((pict_tang = dap_varnum(\"pict_tang\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_tang\\n\", dap_err);\n\t  exit(1);\n\t}\n      if ((pict_pos = dap_varnum(\"pict_pos\")) < 0)\n\t{\n\t  fputs(\"(pict_rest) missing pict_pos\\n\", dap_err);\n\t  exit(1);\n\t}\n      for (ptn = 0, p[pn].pict_ntxt = 0; ptn < npts; ptn++)\n\t{\n\t  step();\n\t  pict_text(p + pn, dap_obs[0].do_str[pict_txt],\n\t\t    dap_obs[0].do_dbl[pict_tpt], dap_obs[0].do_dbl[pict_tpt + 1],\n\t\t    dap_obs[0].do_dbl[pict_tang], dap_obs[0].do_str[pict_pos]);\n\t}\n    }\n  dap_free(inname, \"\");\n  return p;\n}",
      "lines": 253,
      "depth": 15,
      "decorators": [
        "pict",
        "*pict_rest(char *dataset)",
        "*"
      ]
    }
  },
  "dap/dap-3.10/src/sbs.h": {},
  "dap/dap-3.10/src/sbstrans.c": {
    "iskeyword": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int iskeyword(char *str)\n{\n  int k;\n\n  for (k = 0; *keyword[k]; k++)\n    {\n      if (!linecmp(str, keyword[k]))\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "namecvt": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void namecvt(char *sbsname)\n{\n  int dot;\n\n  for (dot = 0; sbsname[dot]; dot++)\n    ;\n  while (--dot >= 0 && sbsname[dot] != '.')\n    ;\n  if (dot <= 0)\n    {\n      fprintf(stderr, \"sbs: %s not a .sbs file\\n\", sbsname);\n      exit(1);\n    }\n  strcpy(sbsname + dot, \".c\");\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "is_space": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int is_space(int c)\n{\n  return c == EOF || c == ' ' || c == '\\t' || c == '\\n';\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sbsgetc": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int sbsgetc(FILE *sbsfile)\n{\n  int c;\n\n  c = dgetc(sbsfile, NULL, 0); /* process comments */\n  if (c == '\\n')\n    sbslineno++;\n  return c;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "sbstoken": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int sbstoken(FILE *sbsfile, char *token)\n{\n  int t; /* index to token */\n  int c; /* input character */\n  int cprev; /* previous c for double character tokens */\n  int quote; /* to save quote character encountered (single or double) */\n\n  t = 0;\n  while ((c = sbsgetc(sbsfile)) == ' ' || c == '\\t' || c == '\\n' || incomment)\n    ;\n  if (c == EOF)\n    {\n      token[0] = '\\0';\n      return 0;\n    }\n  if ((('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) || c == '_') /* string */\n    {\n      for (t = 0;\n\t   ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') ||\n\t     ('0' <= c && c <= '9') || c == '_' || c == '.';\n\t   c = sbsgetc(sbsfile))\n\t{\n\t  if (t < TOKENLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"sbstrans: before %d: token too long: %s\\n\", sbslineno, token);\n\t      exit(1);\n\t    }\n\t}\n    }\n  else if (c == '.' || ('0' <= c && c <= '9')) /* number */\n    {\n      for (t = 0; c == '.' || ('0' <= c && c <= '9'); c = sbsgetc(sbsfile))\n\t{\n\t  if (t < TOKENLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"sbstrans: before %d: token too long: %s\\n\", sbslineno, token);\n\t      exit(1);\n\t    }\n\t}\n    }\n  else if (c == '=' || c == '+' || c == '-' || c == '*' || c == '/' || c == '>' ||\n\t   c == '<' || c == '^' || c == '~' || c == '!' || c == '&' || c == '|')\n    {\n      t = 0;\n      token[t++] = c;\n      cprev = c;\n      c = sbsgetc(sbsfile);\n      if (c == '=' || (cprev == c))\n\t{\n\t  if (t < TOKENLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"sbstrans: before %d: token too long: %s\\n\", sbslineno, token);\n\t      exit(1);\n\t    }\n\t  c = sbsgetc(sbsfile);\n\t}\n    }\n  else if (c == '\"' || c == '\\'')\n    {\n      quote = c;\n      t = 0;\n      token[t++] = c;\n      cprev = c;\n      c = sbsgetc(sbsfile);\n      for ( ; c != EOF && c != quote; cprev = c, c = sbsgetc(sbsfile))\n\t{\n\t  if (c == '\\n')\n\t    {\n\t      if (cprev == '\\\\')\n\t\t--t;\n\t      else\n\t\tbreak;\n\t    }\n\t  else if (t < TOKENLEN)\n\t    token[t++] = c;\n\t  else\n\t    {\n\t      token[t] = '\\0';\n\t      fprintf(stderr, \"sbstrans: before %d: token too long: %s\\n\", sbslineno, token);\n\t      exit(1);\n\t    }\n\t}\n      if (t < TOKENLEN)\n\ttoken[t++] = c;\n      else\n\t{\n\t  token[t] = '\\0';\n\t  fprintf(stderr, \"sbstrans: before %d: token too long: %s\\n\", sbslineno, token);\n\t  exit(1);\n\t}\n      c = sbsgetc(sbsfile);\n    }\n  else\n    {\n      t = 0;\n      token[t++] = c;\n      c = sbsgetc(sbsfile);\n    }\n  token[t] = '\\0';\n  while (c != EOF && c == ' ' || c == '\\t' || c == '\\n' || incomment)\n    c = sbsgetc(sbsfile);\n  if (c != EOF)\n    {\n      unget1c(c, sbsfile, NULL);\n      if (c == '\\'')\n\tinquote1 = !inquote1;\n      else if (c == '\"')\n\tinquote2 = !inquote2;\n      if (c == '\\n')\n\t--sbslineno;\n    }\n  return t;\n}",
      "lines": 122,
      "depth": 20,
      "decorators": [
        "int"
      ]
    },
    "lineput": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int lineput(char *line, FILE *dapfile)\n{\n  int l;\n\n  for (l = 0; line[l] && line[l] != '\\n'; l++)\n    putc(line[l], dapfile);\n  return l;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getstatement": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int getstatement(FILE *sbsfile, char *statement)\n{\n  int s; /* index to statement */\n  static char token[TOKENLEN + 1];\n  int toklen; /* length of token */\n\n  for (s = 0; (toklen = sbstoken(sbsfile, token)) && linecmp(token, \";\"); )\n    {\n      if (s + toklen + 1 < STATELEN)\n\t{\n\t  strcpy(statement + s, token);\n\t  s += toklen;\n\t  statement[s++] = '\\n';\n\t}\n    }\n  if (!linecmp(token, \";\")) /* if there was at least a ; */\n    {\n      statement[s++] = ';';\n      statement[s++] = '\\n';\n    }\n  statement[s] = '\\0';\n  return s;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "linecpy": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int linecpy(char *l1, char *l2)\n{\n  char *start;\n\n  start = l2;\n  while (*l2 && *l2 != '\\n')\n    {\n      if (l1)\n\t*l1++ = *l2++;\n      else\n\tl2++;\n    }\n  if (l1)\n    *l1 = '\\0';\n  return l2 - start;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "putlines": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "int putlines(char *line, FILE *file, int term)\n{\n  char *start;\n\n  for (start = line; *line && *line != term; line++)\n    {\n      if (*line == '\\n')\n\tputc(' ', file);\n      else\n\tputc(*line, file);\n    }\n  putc(' ', file);\n  return line - start;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lower": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "int lower(int c)\n{\n  if ('A' <= c && c <= 'Z')\n    return c + 'a' - 'A';\n  else\n    return c;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "linecmp": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int linecmp(char *l1, char *l2)\n{\n  while (lower(*l1) == lower(*l2) &&\n\t *l1 && *l2 && *l1 != '\\n' && *l2 != '\\n')\n    {\n      l1++;\n      l2++;\n    }\n  return (*l1 && *l1 != '\\n') || (*l2 && *l2 != '\\n');\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "getstep": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int getstep(FILE *sbsfile, char *step)\n{\n  static char statement[STATELEN + 1];\n  int steptype;\n  int s; /* index to step */\n  static int statelen = -1; /* length of token */\n\n  if (statelen < 0)\n    {\n      if (!(statelen = getstatement(sbsfile, statement)))\n\treturn 0;\n    }\n  if (!linecmp(statement, \"data\"))\n    steptype = DATA;\n  else if (!linecmp(statement, \"proc\"))\n    steptype = PROC;\n  else\n    return 0;\n  strcpy(step, statement);\n  s = statelen;\n  while ((statelen = getstatement(sbsfile, statement)))\n    {\n      if (!linecmp(statement, \"data\") &&\n\t  (alpha(statement[5]) || statement[5] == ';' || statement[5] == '('))\n\tbreak;\n      else if (!linecmp(statement, \"proc\") && alpha(statement[5]))\n\tbreak;\n      if (s + statelen + 1 < STEPLEN)\n\t{\n\t  strcpy(step + s, statement);\n\t  s += statelen;\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: %s step too long\\n\",\n\t\t  sbslineno, ((steptype == DATA) ? \"data\" : \"proc\"));\n\t  exit(1);\n\t}\n    }\n  step[s] = '\\0';\n  return steptype;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "findvar": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "int findvar(char *varname, char var[][TOKENLEN + 1], int nvars)\n{\n  int v;\n\n  for (v = 0; v < nvars; v++)\n    {\n      if (!linecmp(varname, var[v]))\n\tbreak;\n    }\n  if (v < MAXVARS - 1)\n    strcpy(var[v], varname);\n  return v;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "opfix": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "int opfix(char *token, FILE *dapfile)\n{\n  int t; /* index to token */\n\n  if (inquote1 || inquote2)\n    return lineput(token, dapfile) + 1;\n  else if (!linecmp(token, \"=\"))\n    {\n      fputs(\"==\", dapfile);\n      return 2;\n    }\n  else if (!linecmp(token, \"^=\") || !linecmp(token, \"~=\"))\n    {\n      fputs(\"!=\", dapfile);\n      return 3;\n    }\n  else if (!linecmp(token, \"&\"))\n    {\n      fputs(\"&&\", dapfile);\n      return 2;\n    }\n  else if (!linecmp(token, \"|\"))\n    {\n      fputs(\"||\", dapfile);\n      return 2;\n    }\n  else if (!linecmp(token, \"^\") || !linecmp(token, \"~\"))\n    {\n      fputs(\"!\", dapfile);\n      return 2;\n    }\n  else if (!strncmp(token, \"first.\", 6))\n    {\n      putc('_', dapfile);\n      for (t = 6; token[t] && token[t] != '\\n'; t++)\n\tputc(token[t], dapfile);\n      putc('_', dapfile);\n      return t + 1;\n    }\n  else if (!linecmp(token, \"[\"))\n    {\n      fputs(\"[(int)(\", dapfile); /* C-style array subscripting */\n      return 2;\n    }\n  else if (!linecmp(token, \"]\"))\n    {\n      fputs(\")-1]\", dapfile); /* C-style array subscripting */\n      return 2;\n    }\n  else\n    return lineput(token, dapfile) + 1;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "nonaction": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        446,
        1
      ],
      "content": "char *nonaction(char *step) /* is not an action statement? */\n{\n  static char type[TOKENLEN + 1];\n\n  if (!linecmp(step, \"set\") || !linecmp(step, \"infile\") ||\n      !linecmp(step, \"input\") || !linecmp(step, \"length\") ||\n      !linecmp(step, \"merge\") || !linecmp(step, \"by\") ||\n      !linecmp(step, \"drop\") || !linecmp(step, \"keep\") ||\n      !linecmp(step, \"title\"))\n    {\n      linecpy(type, step);\n      return type;\n    }\n  return NULL;\n}",
      "lines": 15,
      "depth": 17,
      "decorators": [
        "char",
        "*nonaction(char *step)",
        "*"
      ]
    },
    "statementtrans": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "int statementtrans(char *step, FILE *dapfile, int *isoutput)\n{\n  int s; /* index to step */\n  char *statementtype;\n\n  s = 0;\n  if ((statementtype = nonaction(step)))\n    {\n      while (step[s] && step[s] != ';')\n\ts++;\n      if (step[s] == ';')\n\treturn s + 2;\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; after %s statement in data step\\n\",\n\t\t  sbslineno, statementtype);\n\t  exit(1);\n\t}\n    }\n  else if (!linecmp(step, \"output\"))\n    {\n      fputs(\"output();\\n\", dapfile);\n      s += 7;\n      *isoutput = 1;\n      statementtype = \"output\";\n    }\n  else if (!linecmp(step, \"end\"))\n    {\n      fputs(\"}\\n\", dapfile);\n      s += 4;\n      statementtype = \"end\";\n    }\n  else if (!linecmp(step, \"if\"))\n    {\n      s += 3;\n      fputs(\"if (\", dapfile);\n      while (step[s] && linecmp(step + s, \"then\"))\n\ts += opfix(step + s, dapfile);\n      fputs(\")\\n\", dapfile);\n      s += 5; /* get past the then */\n      s += statementtrans(step + s, dapfile, isoutput) - 2;\n      /* need - 2 because recursive call picked up the ; */\n      statementtype = \"if\";\n    }\n  else if (!linecmp(step, \"else\"))\n    {\n      fputs(\"else\\n\", dapfile);\n      s += 5;\n      return s;\n    }\n  else if (!linecmp(step + s, \"do\")) /* for do or do while */\n    {\n      s += 3;\n      if (!linecmp(step + s, \"while\")) /* yes, it's a do while */\n\t{\n\t  s += 6;\n\t  if (linecmp(step + s, \"(\"))\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing ( after do while\\n\", sbslineno);\n\t      exit(1);\n\t    }\n\t  s += 2;\n\t  fputs(\"while (\", dapfile);\n\t  while (step[s] && linecmp(step + s, \")\"))\n\t    s += opfix(step + s, dapfile);\n\t  fputs(\")\\n{\\n\", dapfile);\n\t  s += 2; /* get past the ) */\n\t  statementtype = \"do while\";\n\t}\n      else /* no, just a do */\n\t{\n\t  fputs(\"{\\n\", dapfile);\n\t  statementtype = \"do\";\n\t}\n    }\n  else /* assignment? */\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (step[s] == '\\n')\n\t    putc(' ', dapfile);\n\t  else if (step[s] == '[') /* C-style array subscripting */\n\t    fputs(\"[(int)(\", dapfile);\n\t  else if (step[s] == ']') /* C-style array subscripting */\n\t    fputs(\")-1]\", dapfile);\n\t  else\n\t    putc(step[s], dapfile);\n\t  s++;\n\t}\n      putc(';', dapfile);\n      putc('\\n', dapfile);\n      statementtype = \"assignment\";\n    }\n  if (linecmp(step + s, \";\"))\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: missing ; after %s statement in data step\\n\",\n\t      sbslineno, statementtype);\n      exit(1);\n    }\n  s += 2;\n  return s;\n}",
      "lines": 105,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "globaltrans": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "void globaltrans(char *statement, FILE *dapfile)\n{\n  int s; /* index to statement */\n\n  if (!linecmp(statement, \"title\"))\n    {\n      fputs(\"title(\", dapfile);\n      if (statement[6] == '\"')\n\t{\n\t  for (s = 6; statement[s] && statement[s] != '\\n'; s++)\n\t    putc(statement[s], dapfile);\n\t  s++;\n\t  if (statement[s] != ';')\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing ; at end of title statement\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t}\n      else if (statement[6] == ';')\n\tfputs(\"NULL\", dapfile);\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: title must begin with \\\"\\n\", sbslineno);\n\t  exit(1);\n\t}\n      fputs(\");\\n\", dapfile);\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: unknown global statement: %s\\n\", sbslineno, statement);\n      exit(1);\n    }\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "datatrans": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        1219,
        1
      ],
      "content": "void datatrans(char *step, FILE *dapfile)\n{\n  static char inputname[TOKENLEN + 5]; /* +4 extra for .srt if needed */\n  static char outputname[TOKENLEN + 1];\n  int setnum; /* to count to 2 for \"merge\" */\n  static char delim[5]; /* need 5 for, for example, \"\\t\" */\n  static char var[MAXVARS][TOKENLEN + 1];\n  static int len[MAXVARS]; /* descriptor for each var: DBL, INT, or length */\n  int vn; /* variable number */\n  int nvars;\n  static char varname[TOKENLEN + 1];\n  int v; /* index to varname */\n  int s; /* index to step */\n  int sincr; /* increment for s */\n  int inputisfile; /* is input a file? 0 if not or, if so, position following \"infile\" */\n  static char skip[TOKENLEN + 1]; /* number of lines to skip on input */\n  int inputisnull; /* but is that file just NULL? */\n  int inputcolumn; /* is input in columns? */\n  int sic; /* index to step if input is column */\n  int startcol, endcol; /* start and end columns of column input */\n  int isdouble; /* are there vars of type double? */\n  int firstdec; /* first declaration on line (no comma) */\n  int isoutput; /* is there an output statement? */\n  int dropping; /* is there a drop option or statement? */\n  int keeping; /* is there a keep option or statement? */\n  int start; /* start of first.variable name for dropping */\n  int bymark; /* if there was a \"by\" statement, its position, otherwise -1 */\n  int nby; /* number of \"by\" variables */\n  int b; /* index to \"by\" vars */\n  int i; /* index to constant string for character variables */\n  \n  nvars = 0;\n  dropping = 0;\n  keeping = 0;\n\n  /* Because the order of statements differs between SBS and Dap, we pass\n   * through step several times.\n   */\n\n  fputs(\"sbstrans: processing data step...\\n\", stderr);\n  fflush(stderr);\n\n  bymark = isby(step); /* get this out of the way */\n\n  /* first take care of globals */\n  if ((s = findstatement(step, \"title\")))\n    globaltrans(step + s - 6, dapfile);\n\n  /* then we look for the input file name */\n  inputisnull = 0; /* not NULL until proven guilty */\n  inputcolumn = 0; /* not unless columns found */\n  delim[0] = '\\0';\n  if ((inputisfile = findstatement(step, \"infile\")))\n    {\n      s = inputisfile + linecpy(inputname, step + inputisfile) + 1;\n      fprintf(dapfile, \"infile(%s, \", inputname);\n      if ((sincr = getoption(step + s, \"delimiter\", delim, 1)) ||\n\t  (sincr = getoption(step + s, \"dlm\", delim, 1)))\n\t{\n\t  s += sincr;\n\t  fputs(delim, dapfile);\n\t}\n      else if ((sic = findstatement(step, \"input\"))) /* do we have column input? */\n\t{\n\t  while (step[sic] && step[sic] != ';')\n\t    {\n\t      while (step[sic] && step[sic] != '\\n') /* skip variable name */\n\t\tsic++;\n\t      sic++; /* get to next variable or column number */\n\t      if (num(step[sic])) /* looks like a column number */\n\t\t{\n\t\t  if (!inputcolumn) /* haven't started yet */\n\t\t    {\n\t\t      inputcolumn = 1;\n\t\t      putc('\"', dapfile);\n\t\t      endcol = 0;\n\t\t    }\n\t\t  for (startcol = 0; step[sic] && num(step[sic]); sic++)\n\t\t    startcol = 10 * startcol + step[sic] - '0';\n\t\t  if (step[sic] != '\\n' || startcol != endcol + 1)\n\t\t    {\n\t\t      fprintf(stderr,\n\t\t\t      \"sbstrans: before %d: bad start column in input statement.\\n\",\n\t\t\t      sbslineno);\n\t\t      exit(1);\n\t\t    }\n\t\t  sic++; /* get to next variable or - */\n\t\t  if (step[sic] == '-') /* we have an end column */\n\t\t    {\n\t\t      for (sic += 2, endcol = 0; step[sic] && num(step[sic]); sic++)\n\t\t\tendcol = 10 * endcol + step[sic] - '0';\n\t\t      if (step[sic] != '\\n')\n\t\t\t{\n\t\t\t  fprintf(stderr,\n\t\t\t\t  \"sbstrans: before %d: bad end column in input statement.\\n\",\n\t\t\t\t  sbslineno);\n\t\t\t  exit(1);\n\t\t\t}\n\t\t      sic++; /* get to next variable or - */\n\t\t    }\n\t\t  else\n\t\t    endcol = startcol;\n\t\t  fprintf(dapfile, \"x%d\", endcol - startcol + 1);\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\t}\n      if (inputcolumn)\n\tfputs(\"\\\"\", dapfile);\n      else if (!delim[0])\n\tfputs(\"\\\" \\\"\", dapfile);\n      fputs(\")\\n{\\n\", dapfile);\n    }\n  else if ((s = findstatement(step, \"set\")))\n    {\n      s += linecpy(inputname, step + s) + 1;\n      fprintf(dapfile, \"inset (\\\"%s\\\")\\n{\\n\", inputname);\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; or extra characters at end of set statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else if ((s = findstatement(step, \"merge\")))\n    {\n      fputs(\"merge (\\\"\", dapfile);\n      for (setnum = 0; setnum < 2; setnum++)\n\t{\n\t  s += linecpy(inputname, step + s) + 1;\n\t  fprintf(dapfile, \"%s\\\", \\\"\", inputname);\n\t  if (!linecmp(step + s, \"(\")) /* have \"drop\" or \"keep\" */\n\t    {\n\t      s += 2;\n\t      if (!linecmp(step + s, \"keep\") || !linecmp(step + s, \"drop\"))\n\t\t{\n\t\t  if (step[s] == 'd') /* for drop */\n\t\t    putc('!', dapfile);\n\t\t  s += 5;\n\t\t  if (linecmp(step + s, \"=\"))\n\t\t    {\n\t\t      fprintf(stderr,\n\t\t\t      \"sbstrans: before %d: missing = after keep or drop option in merge statement.\\n\",\n\t\t\t      sbslineno);\n\t\t      exit(1);\n\t\t    }\n\t\t  s += 2; /* to next token */\n\t\t  s += putlines(step + s, dapfile, ')');\n\t\t  if (step[s] != ')')\n\t\t    {\n\t\t      fprintf(stderr,\n\t\t\t      \"sbstrans: before %d: missing ) after keep or drop option in merge statement.\\n\",\n\t\t\t      sbslineno);\n\t\t      exit(1);\n\t\t    }\n\t\t  s += 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"sbstrans: before %d: invalid dataset option in merge statement.\\n\",\n\t\t\t  sbslineno);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t}\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; at end of merge statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      copylist(step, \"by\", dapfile);\n      sprintf(sbstmp, \"sbstmp%02d\", ++sbstempnum);\n      strcpy(inputname, sbstmp);\n      fprintf(dapfile, \"\\\", \\\"%s\\\");\\n\", sbstmp);\n      fprintf(dapfile, \"inset(\\\"%s\\\")\\n{\\n\", sbstmp);\n    }\n  else /* no infile or set or merge found */\n    {\n      inputisnull = 1;\n      fputs(\"infile (NULL, NULL)\\n{\\n\", dapfile);\n    }\n\n  /* now we look for length statement declaring string variables */\n  if ((s = findstatement(step, \"length\")))\n    {\n      fputs(\"char \", dapfile);\n      firstdec = 1;\n      while (step[s] && step[s] != ';')\n\t{\n\t  s += linecpy(varname, step + s) + 1;\n\t  if (findvar(varname, var, nvars) == nvars)\n\t    {\n\t      if (firstdec)\n\t\tfirstdec = 0;\n\t      else\n\t\tputc(',', dapfile);\n\t      fprintf(dapfile, \"%s[\", varname);\n\t    }\n\t  else\n\t    {\n\t      fprintf(stderr, \"sbstrans: before %d: redeclaration of %s\\n\",\n\t\t      sbslineno, varname);\n\t      exit(1);\n\t    }\n\t  if (linecmp(step + s, \"$\"))\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing $ in length statement for %s\\n\",\n\t\t      sbslineno, varname);\n\t      exit(1);\n\t    }\n\t  s += 2;\n\t  s += linecpy(varname, step + s) + 1;\n\t  if (!sscanf(varname, \"%d\", len + nvars) || len[nvars] <= 0)\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: bad length in length statement: %s\\n\",\n\t\t      sbslineno, varname);\n\t      exit(1);\n\t    }\n\t  fprintf(dapfile, \"%d]\", len[nvars] + 1);\n\t  nvars++;\n\t}\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; or extra characters at end of length statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\";\\n\", dapfile);\n    }\n\n  /* now look for variables and declare them: if not declared with \"length\"\n   * statement, then assume double\n   */\n  /* first see if there are any */\n  isdouble = 0;\n  /* check \"input\" statement */\n  if ((s = findstatement(step, \"input\")))\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  s += linecpy(varname, step + s) + 1;\n\t  if (findvar(varname, var, nvars) == nvars) /* if not declared in length statement */\n\t    {\n\t      isdouble = 1; /* then it's a double */\n\t      break;\n\t    }\n\t  if (inputcolumn) /* this was determined previously */\n\t    {\n\t      while (step[s] && num(step[s])) /* skip column number */\n\t\ts++;\n\t      s++; /* to next column number or variable */\n\t      if (step[s] == '-')\n\t\t{\n\t\t  for (s += 2; step[s] && num(step[s]); s++) /* skip column number */\n\t\t    ;\n\t\t  s++; /* to next column number or variable */\n\t\t}\n\t    }\n\t}\n    }\n  /* skip past data statement */\n  for (s = 0; step[s] && step[s] != ';'; s++)\n    ;\n  if (!step[s])\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: null data step body or missing ; in data statement.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  for (s += 2; !isdouble && step[s]; s += 2)\n    {\n      if (nonaction(step + s))\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    s++;\n\t}\n      else\n\t{\n\t  while (!isdouble && step[s] && step[s] != ';')\n\t    {\n\t      if ((('a' <= step[s] && step[s] <= 'z') || step[s] == '_')\n\t\t  && !iskeyword(step + s))\n\t\t{\n\t\t  s += linecpy(varname, step + s) + 1;\n\t\t  if (step[s] != '(' && strncmp(varname, \"first.\", 6) &&\n\t\t      findvar(varname, var, nvars) == nvars)\n\t\t    {\n\t\t      isdouble = 1;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  while (step[s] && step[s] != '\\n')\n\t\t    s++;\n\t\t  s++;\n\t\t}\n\t    }\n\t}\n    }\n  /* now declare them */\n  if (isdouble)\n    {\n      fputs(\"double \", dapfile);\n      firstdec = 1;\n      /* now do vars from input statement, if exists */\n      if ((s = findstatement(step, \"input\")))\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    {\n\t      s += linecpy(varname, step + s) + 1;\n\t      if (findvar(varname, var, nvars) == nvars) /* not declared in length statement */\n\t\t{\n\t\t  if (firstdec)\n\t\t    firstdec = 0;\n\t\t  else\n\t\t    putc(',', dapfile);\n\t\t  len[nvars] = DBL;\n\t\t  nvars++;\n\t\t  fputs(varname, dapfile);\n\t\t}\n\t      if (inputcolumn) /* this was determined previously */\n\t\t{\n\t\t  while (step[s] && num(step[s])) /* skip column number */\n\t\t    s++;\n\t\t  s++; /* to next column number or variable */\n\t\t  if (step[s] == '-')\n\t\t    {\n\t\t      for (s += 2; step[s] && num(step[s]); s++) /* skip column number */\n\t\t\t;\n\t\t      s++; /* to next column number or variable */\n\t\t    }\n\t\t}\n\t    }\n\t}\n      /* skip past data statement */\n      for (s = 0; step[s] && step[s] != ';'; s++)\n\t;\n      if (!step[s])\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: null data step body or missing ; in data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      for (s += 2; step[s]; s += 2)\n\t{\n\t  if (nonaction(step + s))\n\t    {\n\t      while (step[s] && step[s] != ';')\n\t\ts++;\n\t    }\n\t  else\n\t    {\n\t      while (step[s] && step[s] != ';')\n\t\t{\n\t\t  if ((('a' <= step[s] && step[s] <= 'z') || step[s] == '_')\n\t\t      && !iskeyword(step + s))\n\t\t    {\n\t\t      s += linecpy(varname, step + s) + 1;\n\t\t      if (step[s] != '(' && strncmp(varname, \"first.\", 6) &&\n\t\t\t  findvar(varname, var, nvars) == nvars)\n\t\t\t{\n\t\t\t  if (firstdec)\n\t\t\t    firstdec = 0;\n\t\t\t  else\n\t\t\t    putc(',', dapfile);\n\t\t\t  fputs(varname, dapfile);\n\t\t\t  len[nvars] = DBL;\n\t\t\t  nvars++;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      while (step[s] && step[s] != '\\n')\n\t\t\ts++;\n\t\t      s++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      fputs(\";\\n\", dapfile);\n    }\n\n  /* if there are \"by\" variables, we'll need an array of ints */\n  if (bymark >= 0)\n    {\n      fputs(\"int\", dapfile);\n      /* now we have to declare \"by\" string vars for first.variables */\n      for (s = bymark, nby = 0; step[s] && step[s] != ';'; nby++)\n\t{\n\t  s += linecpy(varname, step + s) + 1;\n\t  if (nby)\n\t    putc(',', dapfile);\n\t  fprintf(dapfile, \" _%s_\", varname);\n\t}\n      fprintf(dapfile, \", _partv_[%d], _firstobs_;\\n\", nby);\n    }\n\n  /* now, if input is file, look for input statement */\n  if (inputisfile)\n    {\n      if ((s = findstatement(step, \"input\")))\n\t{\n\t  fputs(\"input(\\\"\", dapfile);\n\t  while (step[s] && step[s] != ';')\n\t    {\n\t      while (step[s] && step[s] != '\\n')\n\t\t{\n\t\t  putc(step[s], dapfile);\n\t\t  s++;\n\t\t}\n\t      s++; /* to next variable or column number */\n\t      putc(' ', dapfile);\n\t      if (inputcolumn) /* this was determined previously */\n\t\t{\n\t\t  while (step[s] && num(step[s])) /* skip column number */\n\t\t    s++;\n\t\t  s++; /* to next column number or variable */\n\t\t  if (step[s] == '-')\n\t\t    {\n\t\t      for (s += 2; step[s] && num(step[s]); s++) /* skip column number */\n\t\t\t;\n\t\t      s++; /* to next column number or variable */\n\t\t    }\n\t\t}\n\t    }\n\t  fputs(\"\\\");\\n\", dapfile);\n\t  if (step[s] != ';')\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing ; in input statement.\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: infile statement present but missing input statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n\n  s = 5; /* get to token following \"data\" */\n  if ('a' <= step[s] && step[s] <= 'z')\n    {\n      s += linecpy(outputname, step + s) + 1;\n      strcpy(sbstmp, outputname);\n      if (step[s] != '(' && step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; or extra characters at end of data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else\n    {\n      sprintf(sbstmp, \"sbstmp%02d\", ++sbstempnum);\n      strcpy(outputname, sbstmp);\n    }\n\n  fprintf(dapfile, \"outset(\\\"%s\\\", \\\"\", outputname);\n\n  if (step[s] == '(') /* output dataset options */\n    {\n      s += 2;\n      if (!linecmp(step + s, \"drop\"))\n\t{\n\t  dropping = 1;\n\t  putc('!', dapfile);\n\t}\n      else if (!linecmp(step + s, \"keep\"))\n\tkeeping = 1;\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad option for data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      s += 5;\n      if (linecmp(step + s, \"=\"))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing = after option name in data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      s += 2;\n      s += putlines(step + s, dapfile, ')');\n      if (step[s] != ')')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ) after option for data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      s += 2;\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; at end of data statement.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else if ((s = findstatement(step, \"drop\")))\n    {\n      dropping = 1;\n      putc('!', dapfile);\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (step[s] == '\\n')\n\t    putc(' ', dapfile);\n\t  else if (alphanum(step[s]))\n\t    putc(step[s], dapfile);\n\t  else\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: invalid character %c in variable name in drop statement.\\n\",\n\t\t      sbslineno, step[s]);\n\t      exit(1);\n\t    }\n\t  s++;\n\t}\n    }\n  else if ((s = findstatement(step, \"keep\")))\n    {\n      keeping = 1;\n      s += putlines(step + s, dapfile, ';');\n    }\n\n  /* now need to drop the first.variables unless there's dropping or no keeping */\n  if ((dropping || !keeping) && (s = bymark) >= 0)\n    {\n      start = 1;\n      if (!dropping)\n\tfputs(\"!_firstobs_ _partv_ \", dapfile);\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (start)\n\t    putc('_', dapfile);\n\t  if (step[s] == '\\n')\n\t    {\n\t      fputs(\"_ \", dapfile);\n\t      start = 1;\n\t    }\n\t  else\n\t    {\n\t      putc(step[s], dapfile);\n\t      start = 0;\n\t    }\n\t  s++;\n\t}\n    }\n\n  fputs(\"\\\");\\n\", dapfile);\n\n      /* if there's a \"by\" statement, need to set up first.variables */\n  if ((s = bymark) >= 0)\n    {\n      fputs(\"dap_list(\\\"\", dapfile);\n      copylist(step, \"by\", dapfile);\n      fprintf(dapfile, \"\\\", _partv_, %d);\\n\", nby);\n      /* and mark first obs */\n      fputs(\"_firstobs_ = 1;\\n\", dapfile);\n    }\n  /* initialize null terminators of character variables */\n  for (v = 0; v < nvars; v++)\n    {\n      if (len[v] > 0) /* char variable */\n\tfprintf(dapfile, \"%s[%d] = '\\\\0';\\n\", var[v], len[v]);\n    }\n\n  if (!inputisnull)\n    {\n      if (inputisfile && (s = getoption(step + inputisfile, \"firstobs\", skip, 1)))\n\tfprintf(dapfile, \"skip(%s - 1);\\n\", skip);\n      fputs(\"while (step())\\n{\\n\", dapfile);\n      if ((s = bymark) >= 0)\n\t{\n\t  for (b = 1; b <= nby; b++)\n\t    {\n\t      fprintf(dapfile, \"if (_firstobs_ || dap_newpart(_partv_, %d))\\n\", b);\n\t      s += linecpy(varname, step + s) + 1;\n\t      fprintf(dapfile, \"_%s_ = 1;\\nelse _%s_ = 0;\\n\", varname, varname);\n\t    }\n\t}\n    }\n\n  /* now copy action statements */\n  /* skip past data statement */\n  for (s = 0; step[s] && step[s] != ';'; s++)\n    ;\n\n  if (!step[s])\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: null data step body or missing ; in data statement.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  for (s += 2, isoutput = 0; step[s]; )\n    s += statementtrans(step + s, dapfile, &isoutput);\n\n  if (!isoutput)\n    fputs(\"output();\\n\", dapfile);\n  if (!inputisnull)\n    {\n      if (bymark >= 0)\n\tfputs(\"_firstobs_ = 0;\\n\", dapfile);\n      fputs(\"}\\n\", dapfile);\n    }\n  fputs(\"}\\n\", dapfile);\n}",
      "lines": 628,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "proctrans": {
      "start_point": [
        1221,
        0
      ],
      "end_point": [
        1278,
        1
      ],
      "content": "void proctrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  char procname[TOKENLEN + 1];\n\n  linecpy(procname, step + 5);\n  fprintf(stderr, \"sbstrans: processing proc %s...\\n\", procname);\n  fflush(stderr);\n\n  /* look for globals */\n  if (linecmp(step + 5, \"dap\") && (s = findstatement(step, \"title\")))\n    globaltrans(step + s - 6, dapfile);\n\n  if (!linecmp(step + 5, \"print\"))\n    printtrans(step + 11, dapfile);\n  else if (!linecmp(step + 5, \"means\"))\n    meanstrans(step + 11, dapfile);\n  else if (!linecmp(step + 5, \"sort\"))\n    sorttrans(step + 10, dapfile);\n  else if (!linecmp(step + 5, \"chart\"))\n    charttrans(step + 11, dapfile);\n  else if (!linecmp(step + 5, \"datasets\"))\n    datasetstrans(step + 14, dapfile);\n  else if (!linecmp(step + 5, \"freq\"))\n    freqtrans(step + 10, dapfile);\n  else if (!linecmp(step + 5, \"tabulate\"))\n    tabulatetrans(step + 14, dapfile);\n  else if (!linecmp(step + 5, \"corr\"))\n    corrtrans(step + 10, dapfile);\n  else if (!linecmp(step + 5, \"plot\"))\n    plottrans(step + 10, dapfile);\n  else if (!linecmp(step + 5, \"rank\"))\n    ranktrans(step + 10, dapfile);\n  else if (!linecmp(step + 5, \"univariate\"))\n    univariatetrans(step + 16, dapfile);\n  else if (!linecmp(step + 5, \"glm\"))\n    glmtrans(step + 9, dapfile);\n  else if (!linecmp(step + 5, \"logistic\"))\n    logistictrans(step + 14, dapfile);\n  else if (!linecmp(step + 5, \"npar1way\"))\n    npar1waytrans(step + 14, dapfile);\n  else if (!linecmp(step + 5, \"reg\"))\n    regtrans(step + 9, dapfile);\n  else if (!linecmp(step + 5, \"dap\"))\n    daptrans(step + 9, dapfile);\n   else if (!linecmp(step + 5, \"import\"))\n    importtrans(step + 9, dapfile);\n   else if (!linecmp(step + 5, \"surveyselect\"))\n    surveyselecttrans(step + 9, dapfile);\n  else\n    {\n      for (s = 5; step[s] && step[s] != '\\n'; s++)\n\t;\n      step[s] = '\\0';\n      fprintf(stderr, \"sbstrans: before %d: unknown proc.\\n\", sbslineno);\n      exit(1);\n    }\n}",
      "lines": 58,
      "depth": 26,
      "decorators": [
        "void"
      ]
    },
    "header": {
      "start_point": [
        1280,
        0
      ],
      "end_point": [
        1289,
        1
      ],
      "content": "void header(FILE *dap)\n{\n  fputs(\"#include <dap.h>\\n\", dap);\n  fputs(\"void main()\\n\", dap);\n  fputs(\"{\\n\", dap);\n  fprintf(dap, \"pict *_sbspict_[%d];\\n\", MAXPICTS); /* alloc pict lists */\n  fprintf(dap, \"int _sbspictcnt_[%d];\\n\", MAXPICTS); /* number of picts in each array */\n  fprintf(dap, \"int _sbspictpage_[%d];\\n\", MAXPICTS); /* number of picts per page */\n  fputs(\"int _sbsnpicts_ = 0, _sbspictn_, _sbspictindex_;\\n\", dap);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "trailer": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "void trailer(FILE *dap)\n{\n  if (sbshaspicts)\n    {\n      fprintf(dap, \"pict_port(%d);\\n\", MAXPICTS);\n      fputs(\"for (_sbspictn_ = 0; _sbspictn_ < _sbsnpicts_; _sbspictn_++)\\n{\\n\", dap);\n      fputs(\"for (_sbspictindex_ = 0; _sbspictindex_ < _sbspictcnt_[_sbspictn_];\", dap);\n      fputs(\"_sbspictindex_++)\\n{\\n\", dap);\n      fputs(\"pict_page();\\n\", dap);\n      fputs(\"pict_show(_sbspict_[_sbspictn_] + _sbspictindex_ * _sbspictpage_[_sbspictn_]);\\n\",\n\t    dap);\n      fputs(\"}\\n}\\npict_end();\\n\", dap);\n    }\n  fputs(\"}\\n\", dap);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "isby": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "int isby(char *step)\n{\n  int s;\n\n  for (s = 0; step[s]; s += 2)\n    {\n      if (!linecmp(step + s, \"by\"))\n\treturn s + 3;\n      else\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    s++;\n\t}\n    }\n  return -1;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "getoption": {
      "start_point": [
        1334,
        0
      ],
      "end_point": [
        1362,
        1
      ],
      "content": "int getoption(char *step, char *key, char *optvalue, int equals)\n{\n  int s;\n  int keylen;\n\n  keylen = strlen(key);\n  for (s = 0; step[s] && step[s] != ';'; s++)\n    {\n      if (!linecmp(step + s, key))\n\t{\n\t  s += keylen + 1;\n\t  if (!linecmp(step + s, \"=\"))\n\t    {\n\t      s += 2;\n\t      if (optvalue)\n\t\ts += linecpy(optvalue, step + s) + 1;\n\t      return s;\n\t    }\n\t  else if (equals)\n\t    {\n\t      fprintf(stderr, \"sbstrans: before %d: missing = in option\\n\", sbslineno);\n\t      exit(1);\n\t    }\n\t}\n      while (step[s] && step[s] != '\\n')\n\ts++;\n    }\n  return 0;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "findstatement": {
      "start_point": [
        1367,
        0
      ],
      "end_point": [
        1381,
        1
      ],
      "content": "int findstatement(char *step, char *key)\n{\n  int s;\n  int keylen;\n\n  keylen = strlen(key);\n  for (s = 0; step[s]; s += 2)\n    {\n      if (!linecmp(step + s, key))\n\treturn s + keylen + 1;\n      while (step[s] && step[s] != ';')\n\ts++;\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "countparts": {
      "start_point": [
        1384,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "void countparts(char *step, char *setname, FILE *dapfile)\n{\n  char sortname[TOKENLEN + 4 + 1]; /* +4 for .srt */\n\n  fprintf(dapfile, \"sort(\\\"%s\\\", \\\"\", setname);\n  strcpy(sortname, setname);\n  strcat(sortname, \".srt\");\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\", \\\"u\\\");\\n\", dapfile);\n  fprintf(dapfile, \"inset(\\\"%s\\\")\\n{\\n\", sortname);\n  fputs(\"for (_sbspictcnt_[_sbsnpicts_] = 0; step(); _sbspictcnt_[_sbsnpicts_]++)\\n;\\n}\\n\",\n\tdapfile);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "copylist": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "int copylist(char *step, char *key, FILE *dapfile)\n{\n  int s; /* index to step */\n  int start; /* start of tokens */\n\n  for (s = 0, start = -1; step[s]; s += 2)\n    {\n      if (!linecmp(step + s, key))\n\t{\n\t  s += strlen(key) + 1;\n\t  start = s;\n\t  putc(' ', dapfile);\n\t  s += putlines(step + s, dapfile, ';');\n\t}\n      else\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    s++;\n\t}\n    }\n  return start;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sbstrans": {
      "start_point": [
        1424,
        0
      ],
      "end_point": [
        1466,
        1
      ],
      "content": "void sbstrans(char *name)\n{\n  FILE *sbs, *dap;\n  static char step[STEPLEN + 1];\n  int steptype;\n\n  if (!(sbs = fopen(name, \"r\")))\n    {\n      fprintf(stderr, \"sbstrans: can't read %s\\n\", name);\n      exit(1);\n    }\n  namecvt(name);\n  if (!(dap = fopen(name, \"w\")))\n    {\n      fprintf(stderr, \"sbstrans: can't write %s\\n\", name);\n      exit(1);\n    }\n  sbstempnum = 0;\n  sbslineno = 1;\n  sbshaspicts = 0;\n  header(dap);\n  sbstmp[0] = '\\0';\n  newline = 1; /* set up variables for dgetc to process comments */\n  incomment = 0;\n  inquote1 = 0;\n  inquote2 = 0;\n  escape = 0;\n  while ((steptype = getstep(sbs, step)))\n    {\n      switch (steptype)\n\t{\n\tcase DATA:\n\t  datatrans(step, dap);\n\t  break;\n\tcase PROC:\n\t  proctrans(step, dap);\n\t  break;\n\t}\n    }\n  trailer(dap);\n  fclose(sbs);\n  fclose(dap);\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/sbstrans1.c": {
    "upper": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "void upper(char *str) /* convert string to upper case: for stats */\n{\n  while (*str)\n    {\n      if ('a' <= *str && *str <= 'z')\n\t*str += 'A' - 'a';\n      str++;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "printtrans": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void printtrans(char *step, FILE *dapfile)\n{\n  char filename[TOKENLEN + 1];\n\n  if (!getoption(step, \"data\", filename, 1))\n    strcpy(filename, sbstmp);\n  fprintf(dapfile, \"print(\\\"%s\\\", \\\"\", filename);\n  /* are there vars? */\n  copylist(step, \"var\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "meanstrans": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void meanstrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n  int noprint; /* suppress printing? */\n  int statsreq; /* other than default stats requested? */\n  int vardf; /* specifies denominator in variance computation: use weights? */\n  char stat[TOKENLEN + 1]; /* statistics name */\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"means(\\\"%s\\\", \\\"\", setname);\n\n  /* now get variables and out= */\n  copylist(step, \"var\", dapfile);\n  if (findstatement(step, \"weight\"))\n    {\n      putc('*', dapfile);\n      copylist(step, \"weight\", dapfile);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* find out which denominator we're to use for variance */\n  vardf = 0;\n  if (getoption(step, \"vardf\", stat, 1))\n    {\n      if (!linecmp(stat, \"wdf\"))\n\tvardf = 1;\n      else if (linecmp(stat, \"df\"))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: invalid option for vardf in proc means\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  /* now get list of statistics and possibly noprint option */\n  for (s = 0, noprint = 0, statsreq = 0; step[s] && step[s] != ';'; s++)\n    {\n      if (!linecmp(step + s, \"noprint\"))\n\t{\n\t  noprint = 1;\n\t  s += 7;\n\t}\n      else if (!linecmp(step + s, \"data\"))\n\t{ /* skip it */\n\t  for (s += 7; step[s] && step[s] != '\\n'; s++)\n\t    ;\n\t}\n      else if (!linecmp(step + s, \"vardf\"))\n\t{\n\t  s += 8;\n\t  if (!linecmp(step + s, \"wdf\"))\n\t    s += 3;\n\t  else /* must be df */\n\t    s += 2;\n\t}\n      else\n\t{\n\t  statsreq = 1;\n\t  s += linecpy(stat, step + s);\n\t  upper(stat);\n\t  if (!linecmp(stat, \"STD\"))\n\t    strcpy(stat, \"SD\");\n\t  else if (!linecmp(stat, \"STDERR\"))\n\t    strcpy(stat, \"SEM\");\n\t  if (vardf && (!linecmp(stat, \"SD\") || !linecmp(stat, \"SEM\") || !linecmp(stat, \"VAR\")))\n\t    strcat(stat, \"FREQ\");\n\t  fputs(stat, dapfile);\n\t  putc(' ', dapfile);\n\t}\n    }\n  if (!statsreq)\n    {\n      if (vardf)\n\tfputs(\"N MEAN SDFREQ MIN MAX\", dapfile);\n      else\n\tfputs(\"N MEAN SD MIN MAX\", dapfile);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  if ((s = findstatement(step, \"output\")))\n    {\n      if (!getoption(step + s, \"out\", outname, 1))\n\t{\n\t  sprintf(sbstmp, \"sbstmp%02d\", ++sbstempnum);\n\t  strcpy(outname, sbstmp);\n\t}\n    }\n  else\n    outname[0] = '\\0';\n\n  /* now print unless noprint */\n  if (!noprint)\n    fprintf(dapfile, \"print(\\\"%s.mns\\\", \\\"\\\");\\n\", setname);\n\n  if (outname[0])\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.mns\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname); /* most recently created dataset */\n    }\n}",
      "lines": 109,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "sorttrans": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void sorttrans(char *step, FILE *dapfile)\n{\n  int s;\n  int sin, sout; /* position following data= and out= options */\n  char inname[TOKENLEN + 4 + 1]; /* +4 to accomodat .srt */\n  char outname[TOKENLEN + 1];\n  int optstart; /* index of start of option list */\n  int descend; /* any descendings? */\n\n  /* first get file name */\n  fputs(\"sort(\\\"\", dapfile);\n  inname[0] = '\\0';\n  outname[0] = '\\0';\n  if (!(sin = getoption(step, \"data\", inname, 1)))\n    strcpy(inname, sbstmp);\n  if (!(sout = getoption(step, \"out\", outname, 1)))\n    strcpy(outname, inname);\n  fprintf(dapfile, \"%s\\\", \\\"\", inname);\n  optstart = sin; /* hold place for option list */\n  if (sout > optstart)\n    optstart = sout;\n\n  /* now do \"by\" */\n  descend = 0;\n  if ((s = findstatement(step, \"by\")))\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (!linecmp(step + s, \"descending\"))\n\t    {\n\t      s += 11;\n\t      descend = 1;\n\t    }\n\t  while (step[s] && step[s] != '\\n')\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t  putc(' ', dapfile);\n\t  s++;\n\t}\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing by statement in proc sort.\\n\", sbslineno);\n      exit(1);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do options */\n  if (!linecmp(step + optstart, \"nodupkey\"))\n    putc('u', dapfile);\n  if (descend)\n    {\n      s = findstatement(step, \"by\");\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (!linecmp(step + s, \"descending\"))\n\t    {\n\t      s += 11;\n\t      while (step[s] && step[s] != '\\n')\n\t\ts++;\n\t      putc('d', dapfile);\n\t    }\n\t  else\n\t    {\n\t      while (step[s] && step[s] != '\\n')\n\t\ts++;\n\t      putc('i', dapfile);\n\t    }\n\t  s++;\n\t}\n    }\n  fputs(\"\\\");\\n\", dapfile);\n\n  if (!outname[0])\n    strcpy(outname, inname);\n  strcat(inname, \".srt\");\n  fprintf(dapfile, \"dataset(\\\"%s\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", inname, outname);\n  strcpy(sbstmp, outname); /* most recently created dataset */\n}",
      "lines": 81,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "datasetstrans": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void datasetstrans(char *step, FILE *dapfile)\n{\n  char oldname[TOKENLEN + 1];\n  char newname[TOKENLEN + 1];\n  int s; /* index to step */\n  int t; /* length of token in step */\n\n  if ((s = findstatement(step, \"append\")))\n    {\n      if (getoption(step + s, \"base\", newname, 1) || getoption(step + s, \"out\", newname, 1))\n\t{\n\t  if (!(getoption(step + s, \"data\", oldname, 1) ||\n\t\tgetoption(step + s, \"new\", oldname, 1)))\n\t    strcpy(oldname, sbstmp);\n\t  fprintf(dapfile, \"dataset(\\\"%s\\\", \\\"%s\\\", \\\"APPEND\\\");\\n\", oldname, newname);\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing base or out statement in proc datasets.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  if ((s = findstatement(step, \"change\")))\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  s += linecpy(oldname, step + s) + 1;\n\t  if (!linecmp(step + s, \"=\"))\n\t    {\n\t      s += 2;\n\t      if ((t = linecpy(newname, step + s)) && linecmp(newname, \";\"))\n\t\t{\n\t\t  fprintf(dapfile, \"dataset(\\\"%s\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", oldname, newname);\n\t\t  s += t + 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"sbstrans: before %d: missing filename after = in change statement in proc datasets.\\n\",\n\t\t\t  sbslineno);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing = after filename in change statement in proc datasets.\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t}\n    }\n  if ((s = findstatement(step, \"delete\")))\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  s += linecpy(oldname, step + s) + 1;\n\t  fprintf(dapfile, \"dataset(\\\"%s\\\", \\\"\\\", \\\"REMOVE\\\");\\n\", oldname);\n\t}\n    }\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "freqtrans": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "void freqtrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n  int tablesstart; /* position of start of variable list in tables statement */\n  int optionsstart; /* position of start of table options or 0 if none */\n  int nstats; /* number of stats reported */\n  char stat[TOKENLEN + 1]; /* stat requested */\n  int nofreq; /* has NOFREQ? */\n  int nopercent; /* has NOPERCENT? */\n  int norow; /* has NOROW? */\n  int nocol; /* has NOCOL? */\n  int noprint; /* suppress printing? */\n  int nvars; /* number of table vars */\n  int newvar; /* starting new variable in list */\n  int varn; /* number of the variable */\n\n  noprint = 0;\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"sort(\\\"%s\\\", \\\"\", setname);\n  if ((s = findstatement(step, \"tables\")))\n    {\n      tablesstart = s;\n      copylist(step, \"by\", dapfile);\n      putc(' ', dapfile);\n      while (step[s] && step[s] != '/' && step[s] != ';')\n\t{\n\t  if (step[s] == '*')\n\t    {\n\t      putc(' ', dapfile);\n\t      s++;\n\t    }\n\t  else if (step[s] != '\\n')\n\t    putc(step[s], dapfile);\n\t  s++;\n\t}\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing tables statement in proc freq.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  fputs(\"\\\", \\\"\\\");\\n\", dapfile);\n\n  if (step[s] == '/')\n    optionsstart = s + 2;\n  else\n    optionsstart = 0;\n\n  fprintf(dapfile, \"freq(\\\"%s.srt\\\", \\\"\", setname);\n\n  /* now copy from tables statement, again */\n  for (s = tablesstart, newvar = 1, nvars = 0;\n       step[s] && step[s] != '/' && step[s] != ';'; s++)\n    {\n      if (step[s] == '*')\n\t{\n\t  putc(' ', dapfile);\n\t  s ++;\n\t  newvar = 1;\n\t}\n      else if (step[s] != '\\n')\n\t{\n\t  if (newvar)\n\t    {\n\t      newvar = 0;\n\t      nvars++;\n\t    }\n\t  putc(step[s], dapfile);\n\t}\n    }\n  if (!nvars)\n    {\n      fprintf(stderr, \"sbstrans: before %d: no variables in tables statement in proc freq.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n\n  if ((s = findstatement(step, \"weight\")))\n    {\n      putc('*', dapfile);\n      while (step[s] && step[s] != '\\n')\n\t{\n\t  putc(step[s], dapfile);\n\t  s++;\n\t}\n      s++;\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: only one weight variable allowed in proc freq.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n\n  fputs(\"\\\", \\\"\", dapfile);\n \n  outname[0] = '\\0';\n\n  nofreq = 0;\n  nopercent = 0;\n  norow = 0;\n  nocol = 0;\n  /* now get list of statistics and possibly out option */\n  nstats = 4; /* for FREQ, PERCENT, ROWPERC, COLPERC */\n  for (s = optionsstart; step[s] && step[s] != ';'; s++)\n    {\n      if (!linecmp(step + s, \"noprint\"))\n\t{\n\t  noprint = 1;\n\t  s += 7;\n\t}\n      else if (!linecmp(step + s, \"out\"))\n\t{\n\t  s += 4;\n\t  if (linecmp(step + s, \"=\"))\n\t    {\n\t      fprintf(stderr, \"sbstrans: before %d: missing = after out option in tables statement in proc freq.\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t  s += 2;\n\t  s += linecpy(outname, step + s);\n\t}\n      else\n\t{\n\t  s += linecpy(stat, step + s);\n\t  upper(stat);\n\t  if (!linecmp(stat, \"NOFREQ\"))\n\t    {\n\t      nofreq = 1;\n\t      --nstats;\n\t    }\n\t  else if (!linecmp(stat, \"NOPERCENT\"))\n\t    {\n\t      nopercent = 1;\n\t      --nstats;\n\t    }\n\t  else if (!linecmp(stat, \"NOROW\"))\n\t    {\n\t      norow = 1;\n\t      --nstats;\n\t    }\n\t  else if (!linecmp(stat, \"NOCOL\"))\n\t    {\n\t      nocol = 1;\n\t      --nstats;\n\t    }\n\t  else\n\t    {\n\t      if (!linecmp(stat, \"EXPECTED\"))\n\t\tnstats++;\n\t      else if (!linecmp(stat, \"CHISQ\"))\n\t\tfputs(\" FISHER \", dapfile);\n\t      else if (!linecmp(stat, \"MEASURES\"))\n\t\t{\n\t\t  fputs(\" ODDSRAT \", dapfile);\n\t\t  strcpy(stat, \"ORDINAL\");\n\t\t}\n\t      fputs(stat, dapfile);\n\t    }\n\t  putc(' ', dapfile);\n\t}\n    }\n  if (step[s] != ';')\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing ; at end of tables statement in proc freq.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  if (!noprint)\n    {\n      if (!nofreq)\n\tfputs(\" COUNT\", dapfile);\n      if (!nopercent)\n\tfputs(\" PERCENT\", dapfile);\n      if (!norow)\n\tfputs(\" ROWPERC\", dapfile);\n      if (!nocol)\n\tfputs(\" COLPERC\", dapfile);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  /* now print or table if there's anything to print, unless noprint */\n  if (!noprint && nstats > 0)\n    {\n      if (nvars == 1)\n\tfprintf(dapfile, \"print(\\\"%s.srt.frq\\\", \\\"\\\");\\n\", setname);\n      else\n\t{\n\t  fprintf(dapfile, \"sort(\\\"%s.srt.frq\\\", \\\"\", setname);\n\t  copylist(step, \"by\", dapfile);\n\t  /* copy up through row variable */\n\t  for (s = tablesstart, varn = 0; varn < nvars - 1; varn++)\n\t    {\n\t      while (step[s] && step[s] != '\\n')\n\t\t{\n\t\t  putc(step[s], dapfile);\n\t\t  s++;\n\t\t}\n\t      putc(' ', dapfile);\n\t      s += 3; /* skip \\n and * and \\n */\n\t    }\n\t  fputs(\" _type_ \", dapfile);\n\t  while (step[s] && step[s] != '\\n') /* column variable */\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t  fputs(\"\\\", \\\"\\\");\\n\", dapfile);\n\n\t  fprintf(dapfile, \"table(\\\"%s.srt.frq.srt\\\", \\\"\", setname);\n\t  for (s = tablesstart, varn = 0; varn < nvars - 2; varn++)\n\t    {\n\t      while (step[s] && step[s] != '\\n')\n\t\ts++;\n\t      s += 3; /* skip \\n and * and \\n */\n\t    }\n\t  while (step[s] && step[s] != '\\n') /* row variable */\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t  if (nstats > 1)\n\t    fputs(\" _type_\", dapfile);\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  for (s += 3; step[s] && step[s] != '\\n'; s++) /* column variable */\n\t    putc(step[s], dapfile);\n\t  fputs(\" _cell_\\\", \\\"s12\\\", \\\"\", dapfile);\n\t  /* now do tables by by and tables variables */\n\t  copylist(step, \"by\", dapfile);\n\t  for (s = tablesstart, varn = 0; varn < nvars - 2; varn++)\n\t    {\n\t      while (step[s] && step[s] != '\\n')\n\t\t{\n\t\t  putc(step[s], dapfile);\n\t\t  s++;\n\t\t}\n\t      putc(' ', dapfile);\n\t      s += 3; /* skip \\n and * and \\n */\n\t    }\n\t  fputs(\"\\\");\\n\", dapfile);\n\t}\n    }\n\n  if (outname[0])\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.srt.frq\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname); /* most recently created dataset */\n    }\n}",
      "lines": 261,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "tabulatetrans": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "void tabulatetrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 1];\n  char sortname[TOKENLEN + 4 + 1]; /* +4 to accomodate .srt */\n  char format[TOKENLEN + 1]; /* format string */\n  int tablestart; /* position following \"table\" in table statement */\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  strcpy(sortname, setname);\n  strcat(sortname, \".srt\");\n\n  fprintf(dapfile, \"sort(\\\"%s\\\", \\\"\", setname);\n  copylist(step, \"by\", dapfile);\n  if ((tablestart = findstatement(step, \"table\")))\n    {\n      for (s = tablestart; step[s] && step[s] != '*' && step[s] != ';'; s++)\n\t{\n\t  if (step[s] == '\\n')\n\t    putc(' ', dapfile);\n\t  else if (step[s] == ',')\n\t    s++;\n\t  else\n\t    putc(step[s], dapfile);\n\t}\n      if (step[s] != '*')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: no analysis variable in table statement in proc tabulate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: no table statement in proc tabulate.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  fputs(\"\\\", \\\"\\\");\\n\", dapfile);\n\n  fprintf(dapfile, \"table(\\\"%s\\\", \\\"\", sortname);\n  if (!getoption(step, \"format\", format, 1))\n    strcpy(format, \"12\");\n\n  /* now get row, column, and cell variables */\n  s = tablestart;\n  while (step[s] && step[s] != ',' && step[s] != ';')\n    {\n      if (step[s] == '\\n')\n\tputc(' ', dapfile);\n      else\n\tputc(step[s], dapfile);\n      s++;\n    }\n  if (step[s] != ',')\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: no column variables in table statement in proc tabulate.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  s += 2;\n  fputs(\"\\\", \\\"\", dapfile);\n  while (step[s] && step[s] != '*' && step[s] != ';')\n    {\n      if (step[s] == '\\n')\n\tputc(' ', dapfile);\n      else\n\tputc(step[s], dapfile);\n      s++;\n    }\n  if (step[s] != '*')\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: no analysis variable in table statement in proc tabulate.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  s += 2;\n  while (step[s] && step[s] != '\\n')\n    {\n      putc(step[s], dapfile);\n      s++;\n    }\n  fprintf(dapfile, \"\\\", \\\"%s \", format);\n  s++;\n  if (step[s] == '/') /* rts option */\n    {\n      s += 2;\n      if (!linecmp(step + s, \"rtspace\"))\n\ts += 8;\n      else if (!linecmp(step + s, \"rts\"))\n\ts += 4;\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad option in table statement in proc tabulate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      if (!linecmp(step + s, \"=\"))\n\t{\n\t  s += 2;\n\t  while (step[s] && step[s] != '\\n')\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad format for rtspace in table statement in proc tabulate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else if (step[s] != ';')\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: extra characters at end of table statement in proc tabulate.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n}",
      "lines": 136,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "corrtrans": {
      "start_point": [
        710,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "void corrtrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n  int noprint; /* NOPRINT option present? */\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"corr(\\\"%s\\\", \\\"\", setname);\n\n  /* now get variables and outp= */\n  copylist(step, \"var\", dapfile);\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  noprint = 0;\n  for (s = 0; step[s] && step[s] != ';'; s++)\n    {\n      if (!linecmp(step + s, \"noprint\"))\n\t{\n\t  noprint++;\n\t  break;\n\t}\n      else\n\t{\n\t  while (step[s] && step[s] != '\\n')\n\t    s++;\n\t}\n    }\n\n  if (!noprint)\n    {\n      fprintf(dapfile, \"sort(\\\"%s.cor\\\", \\\"\", setname);\n      copylist(step, \"by\", dapfile);\n      fputs(\" _var1_ _type_ _var2_\\\", \\\"\\\");\\n\", dapfile);\n      fprintf(dapfile,\n\t      \"table(\\\"%s.cor.srt\\\", \\\"_var1_ _type_\\\", \\\"_var2_ _corr_\\\", \\\"s12\\\", \\\"\",\n\t      setname);\n      copylist(step, \"by\", dapfile);\n      fputs(\"\\\");\\n\", dapfile);\n    }\n\n  if (getoption(step, \"outp\", outname, 1))\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.cor\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname); /* most recently created dataset */\n    }\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ranktrans": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "void ranktrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 4 + 1]; /* +4 to accomodat .srt */\n  char outname[TOKENLEN + 1];\n  char option[TOKENLEN + 1];\n  int ngroups; /* number of groups */\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"group(\\\"%s\\\", \\\"\", setname);\n\n  ngroups = 0;\n  if (getoption(step, \"groups\", option, 1)) /* get number of groups */\n    { /* do this first to check for conflicting option \"descending\" */\n      if (sscanf(option, \"%d\", &ngroups) != 1 || ngroups <= 0)\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad number %s of groups in proc rank\\n\",\n\t\t  sbslineno, option);\n\t  exit(1);\n\t}\n    }\n  for (s = 0; step[s] && step[s] != ';'; )\n    {\n      s += linecpy(option, step + s) + 1;\n      if (!linecmp(option, \"groups\") || !linecmp(option, \"data\") || !linecmp(option, \"out\"))\n\t{\n\t  s += 2; /* skip = */\n\t  while (alphanum(step[s]))\n\t    s++;\n\t  s++;\n\t}\n      else if (ngroups) /* already chose groups= option */\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: can't combine %s with groups= in proc rank\\n\",\n\t\t  sbslineno, option);\n\t  exit(1);\n\t}\n      else if (!linecmp(option, \"fraction\") || !linecmp(option, \"f\"))\n\tfputs(\"/ \", dapfile);\n      else if (!linecmp(option, \"percent\") || !linecmp(option, \"p\"))\n\tfputs(\"% \", dapfile);\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: invalid option %s for proc rank\\n\",\n\t\t  sbslineno, option);\n\t  exit(1);\n\t}\n    }\n  \n  /* now get variables */\n  if ((s = findstatement(step, \"var\")))\n    {\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (step[s] == '\\n')\n\t    {\n\t      if (ngroups)\n\t\tfprintf(dapfile, \" %d# \", ngroups);\n\t      else\n\t\tputc(' ', dapfile);\n\t    }\n\t  else\n\t    putc(step[s], dapfile);\n\t  s++;\n\t}\n    }\n  else\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: missing var statement in proc rank\\n\",\n\t      sbslineno, option);\n      exit(1);\n    }\n\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  if (!getoption(step, \"out\", outname, 1))\n    {\n      sprintf(sbstmp, \"sbstmp%02d\", ++sbstempnum);\n      strcpy(outname, sbstmp);\n    }\n\n  fprintf(dapfile, \"dataset(\\\"%s.grp\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n  strcpy(sbstmp, outname); /* most recently created dataset */\n}",
      "lines": 95,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "univariatetrans": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "void univariatetrans(char *step, FILE *dapfile)\n{\n  int s;\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n  char varname[TOKENLEN + 1];\n  int noprint; /* suppress printing? */\n  int normal; /* want to test normality? */\n  int plot; /* normal plot requested? */\n  int statsreq; /* other than default stats requested? */\n\n  /* get file name */\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"pctiles(\\\"%s\\\", \\\"\", setname);\n\n  /* now get variables and out= */\n  copylist(step, \"var\", dapfile);\n  if (findstatement(step, \"weight\"))\n    {\n      putc('*', dapfile);\n      copylist(step, \"weight\", dapfile);\n    }\n\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now get stats */\n  statsreq = 0;\n  /* first check validity of out= if present */\n  outname[0] = '\\0'; /* null unless specified */\n  if ((s = findstatement(step, \"output\")))\n    {\n      if (!getoption(step + s, \"out\", outname, 1))\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: bad option for output in proc univariate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      while (step[s] && step[s] != ';')\n\t{\n\t  if (!linecmp(step + s, \"out\"))\n\t    { /* skip now, get it later */\n\t      s += 6; /* skip out= */\n\t      while (step[s] && step[s] != '\\n')\n\t\ts++;\n\t    }\n\t  else if (!linecmp(step + s, \"pctlpts\"))\n\t    {\n\t      statsreq = 1;\n\t      s += 8;\n\t      if (linecmp(step + s, \"=\"))\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"sbstrans: before %d: missing = after pctlpts in proc univariate.\\n\",\n\t\t\t  sbslineno);\n\t\t  exit(1);\n\t\t}\n\t      s += 2;\n\t      while (num(step[s]))\n\t\t{\n\t\t  putc('P', dapfile);\n\t\t  while (step[s] && step[s] != '\\n')\n\t\t    {\n\t\t      putc(step[s], dapfile);\n\t\t      s++;\n\t\t    }\n\t\t  putc(' ', dapfile);\n\t\t  s++;\n\t\t}\n\t      --s; /* back off from ; or next stat name found */\n\t    }\n\t  else\n\t    {\n\t      statsreq = 1;\n\t      while (step[s] && step[s] != '\\n')\n\t\t{\n\t\t  if ('a' <= step[s] && step[s] <= 'z')\n\t\t    putc(step[s] + 'A' - 'a', dapfile);\n\t\t  else\n\t\t    putc(step[s], dapfile);\n\t\t  s++;\n\t\t}\n\t      putc(' ', dapfile);\n\t    }\n\t  s++;\n\t}\n    }\n\n  if (!statsreq)\n    fputs(\"MAX MED MIN N P1 P5 P10 P90 P95 P99 Q1 Q3 QRANGE RANGE\", dapfile);\n\n  fputs(\"\\\", \\\"\", dapfile);\n\n  /* now do \"by\" */\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  /* now get normal, plot, and noprint options */\n  for (s = 0, noprint = 0, normal = 0, plot = 0; step[s] && step[s] != ';'; s++)\n    {\n      if (!linecmp(step + s, \"noprint\"))\n\t{\n\t  noprint = 1;\n\t  s += 7;\n\t}\n      else if (!linecmp(step + s, \"data\"))\n\t{ /* skip it */\n\t  for (s += 7; step[s] && step[s] != '\\n'; s++)\n\t    ;\n\t}\n      else if (!linecmp(step + s, \"normal\"))\n\t{\n\t  normal = 1;\n\t  s += 6;\n\t}\n      else if (!linecmp(step + s, \"plot\"))\n\t{\n\t  plot = 1;\n\t  s += 4;\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: invalid option for proc univariate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n\n  /* now print unless noprint */\n  if (!noprint)\n    {\n      fprintf(dapfile, \"print(\\\"%s.pct\\\", \\\"\\\");\\n\", setname);\n      /* and to Wilcoxon signed rank for each variable */\n      if ((s = findstatement(step, \"var\")))\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    {\n\t      fprintf(dapfile, \"nonparam(\\\"%s\\\", \\\"\", setname);\n\t      while (step[s] && step[s] != '\\n')\n\t\t{\n\t\t  putc(step[s], dapfile);\n\t\t  s++;\n\t\t}\n\t      s++; /* on to next variable */\n\t      fputs(\"\\\", \\\"\", dapfile);\n\t      copylist(step, \"by\", dapfile);\n\t      fputs(\"\\\");\\n\", dapfile);\n\t    }\n\t}\n    }\n\n\n  if (outname[0])\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.pct\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname); /* most recently created dataset */\n    }\n\n  /* now if normal, plot requested */\n  if (normal)\n    {\n      if ((s = findstatement(step, \"var\")))\n\t{\n\t  while (step[s] && step[s] != ';')\n\t    { /* need to run each variable separately */\n\t      s += linecpy(varname, step + s) + 1;\n\t      if (plot)\n\t\t{\n\t\t  if (isby(step) >= 0)\n\t\t    countparts(step, setname, dapfile);\n\t\t  else\n\t\t    fputs(\"_sbspictcnt_[_sbsnpicts_] = 1;\\n\", dapfile);\n\t\t  fputs(\"_sbspict_[_sbsnpicts_] = \", dapfile);\n\t\t}\n\t      fprintf(dapfile, \"normal(\\\"%s\\\", \\\"%s\\\", \\\"\", setname, varname);\n\t      copylist(step, \"by\", dapfile);\n\t      fprintf(dapfile, \"\\\", %d);\\n\", (plot ? MAXPICTS : 0));\n\t      if (plot)\n\t\tfputs(\"_sbspictpage_[_sbsnpicts_++] = 1;\\n\", dapfile);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: var statement required for normality testing proc univariate.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      if (plot)\n\tsbshaspicts = 1;\n    }\n}",
      "lines": 194,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/sbstrans2.c": {
    "charttrans": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void charttrans(char *step, FILE *dapfile)\n{\n  int s;\n  int sincr; /* increment for s */\n  char setname[TOKENLEN + 1];\n  char varname[TOKENLEN + 1 + 1]; /* +1 to accomodate + or - */\n\n  if (!(s = getoption(step, \"data\", setname, 1)))\n    strcpy(setname, sbstmp);\n  if (isby(step) >= 0)\n    countparts(step, setname, dapfile);\n  else\n    fputs(\"_sbspictcnt_[_sbsnpicts_] = 1;\\n\", dapfile);\n  fprintf(dapfile, \"_sbspict_[_sbsnpicts_] = histogram(\\\"%s\\\", \\\"\", setname);\n  if ((s = findstatement(step, \"vbar\")))\n    {\n      s += linecpy(varname, step + s) + 1;\n      fprintf(dapfile, \"%s \", varname);\n      if ((s = getoption(step + s, \"freq\", varname, 0))) /* weight or freq variable */\n\tfputs(varname, dapfile);\n      fputs(\"\\\", \\\"\", dapfile);\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing vbar statement in proc chart.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\", \", dapfile);\n  s = findstatement(step, \"vbar\");\n  if (getoption(step + s, \"levels\", varname, 1)) /* shouldn't really use varname... */\n    fputs(varname, dapfile);\n  else\n    fputs(\"10\", dapfile);\n  fputs(\", \\\"\", dapfile);\n  /* STYLE, XFUNCT, NPLOTS) */\n  fputs(\"== \", dapfile);\n  if (getoption(step + s, \"type\", varname, 1)) /* shouldn't really use varname... */\n    {\n      if (!linecmp(varname, \"freq\"))\n\tstrcpy(varname, \"COUNT\");\n      else if (!linecmp(varname, \"percent\") || !linecmp(varname, \"pct\"))\n\tstrcpy(varname, \"PERCENT\");\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad option %s in vbar statement in proc chart.\\n\",\n\t\t  sbslineno, varname);\n\t  exit(1);\n\t}\n      fputs(varname, dapfile);\n    }\n  if ((sincr = getoption(step + s, \"axis\", varname, 1))) /* min if another, else max */\n    {\n      if (!linecmp(varname, \"+\") || !linecmp(varname, \"-\"))\n\t{ /* '+', '-' are tokens, but need to attach to number */\n\t  s += sincr;\n\t  s += linecpy(varname + 1, step + s) + 1;\n\t}\n      else\n\ts += sincr;\n      if ('0' <= step[s] && step[s] <= '9' ||\n\t  step[s] == '.' || step[s] == '-' || step[s] == '+') /* varname was min, after all */\n\t{\n\t  fprintf(dapfile, \" MINX%s\", varname);\n\t  if (step[s] == '-' || step[s] == '-')\n\t    { /* '-' is token, but need to attach to number */\n\t      s += linecpy(varname, step + s) + 1;\n\t      linecpy(varname + 1, step + s);\n\t    }\n\t  else\n\t    linecpy(varname, step + s);\n\t}\n      fprintf(dapfile, \" MAXX%s\", varname);      \n    }\n\n  fprintf(dapfile, \"\\\", NULL, %d);\\n\", MAXPICTS);\n  fputs(\"_sbspictpage_[_sbsnpicts_++] = 1;\\n\", dapfile);\n  \n  sbshaspicts = 1;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "plottrans": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void plottrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  int sincr; /* increment for s */\n  int by; /* are there \"by\" variables? */\n  char setname[TOKENLEN + 1];\n  char xname[TOKENLEN + 1]; /* name of x-variable */\n  char yname[TOKENLEN + 1]; /* name of y-variable */\n\n  if (!(s = getoption(step, \"data\", setname, 1)))\n    strcpy(setname, sbstmp);\n\n  by = isby(step); /* so we don't have to do this over and over */\n\n  for (s = 0; (sincr = findstatement(step + s, \"plot\")); s += 2)\n    {\n      if (by >= 0)\n\tcountparts(step, setname, dapfile);\n      else\n\tfputs(\"_sbspictcnt_[_sbsnpicts_] = 1;\\n\", dapfile);\n      s += sincr;\n      fprintf(dapfile, \"_sbspict_[_sbsnpicts_] = plot(\\\"%s\\\", \\\"\", setname);\n      s += linecpy(yname, step + s) + 1;\n      if (!alpha(yname[0]))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad vertical variable name in plot statement in proc plot.\\n\",\n\t\t  sbslineno, yname);\n\t  exit(1);\n\t}\n      if (linecmp(step + s, \"*\"))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing * after vertical variable name in plot statement in proc plot.\\n\",\n\t\t  sbslineno, yname);\n\t  exit(1);\n\t}\n      s += 2;\n      s += linecpy(xname, step + s) + 1;\n      if (!alpha(xname[0]))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: bad horizontal variable name in plot statement in proc plot.\\n\",\n\t\t  sbslineno, xname);\n\t  exit(1);\n\t}\n      fprintf(dapfile, \"%s %s\\\", \\\"\", xname, yname);\n\n      copylist(step, \"by\", dapfile);\n      fputs(\"\\\", \\\"\", dapfile);\n\n      /* STYLE, XFUNCT, YFUNCT, NPLOTS) */\n      if (step[s] == '/')\n\t{\n\t  s += 2;\n\t  while (step[s] && step[s] != ';')\n\t    {\n\t      s += linecpy(xname, step + s) + 1; /* using xname, should have optname instead */\n\t      if (!linecmp(xname, \"box\"))\n\t\tfputs(\"== \", dapfile);\n\t      else\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"sbstrans: before %d: bad option %s in plot statement in proc plot.\\n\",\n\t\t\t  sbslineno, xname);\n\t\t  exit(1);\n\t\t}\n\t    }\n\t}\n      fprintf(dapfile, \"\\\", NULL, NULL, %d);\\n\", MAXPICTS);\n      fputs(\"_sbspictpage_[_sbsnpicts_++] = 1;\\n\", dapfile);\n  \n      sbshaspicts = 1;\n    }\n\n  if (!s)\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing plot statement in proc plot.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "dap/dap-3.10/src/sbstrans3.c": {
    "glmtrans": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "void glmtrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  int sincr; /* increment for s */\n  static char setname[TOKENLEN + 1];\n  int modelstart; /* starting position of model */\n  static char response[TOKENLEN + 1]; /* name of response variable */\n  int resplen; /* length of response variable name */\n  int e; /* index to step, for stepping through effects of the model */\n  int lsmeans; /* 0 = no lsmeans statement, > 0 is start of lsmeans statement. */\n  static char test[TOKENLEN + 1]; /* dunnett, tukey, or lsd */\n  static char level[TOKENLEN + 1]; /* alpha requested for lsmeans */\n  int term; /* starting position of term in numerator of ftest */\n  int nomatch; /* lsmeans term doesn't match ftest term */\n  int classstart; /* start of class variable list */\n  int nbyvars; /* number of by vars: need to know this for contrasts */\n  int classvar; /* index of class var in contrast */\n  int c; /* index to class vars */\n  static char classname[TOKENLEN + 1]; /* name of class var in contrast */\n  unsigned int contrastterm; /* value for _term_ variable for contrasts */\n  int *coeff; /* coefficients for the effect */\n  int ncoeff; /* number of coefficients for contrast */\n  int minus; /* coeff has minus sign? (read as separate token) */\n  int coeffsum; /* sum of coefficients for contrast */\n\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  if ((modelstart = findstatement(step, \"model\")))\n    resplen = linecpy(response, step + modelstart);\n  else\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: missing model statement in proc glm\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n\n  if (!(classstart = findstatement(step, \"class\")))\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: missing class statement in proc glm\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n\n  if ((s = findstatement(step, \"by\")))\n    {\n      for (nbyvars = 0; step[s] && step[s] != ';'; nbyvars++)\n\ts += linecpy((char *) NULL, step + s) + 1;\n    }\n  else\n    nbyvars = 0;\n\n  /* we have to sort by the class vars and to get means, etc. */\n  fprintf(dapfile, \"sort(\\\"%s\\\", \\\"\", setname);\n  copylist(step, \"by\", dapfile);\n  copylist(step, \"class\", dapfile);\n  fputs(\"\\\", \\\"\\\");\\n\", dapfile);\n\n  /* we have to get means and vars */\n  fprintf(dapfile, \"means(\\\"%s.srt\\\", \\\"%s\\\", \\\"N MEAN VAR\\\", \\\"\", setname, response);\n  copylist(step, \"by\", dapfile);\n  copylist(step, \"class\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  /* now we can start the ANOVA and test the whole model */\n  fprintf(dapfile, \"effects(\\\"%s.srt.mns\\\", \\\"%s \", setname, response);\n  copylist(step, \"class\", dapfile);\n  fputs(\"\\\", \\\"\", dapfile);\n  s = modelstart + resplen + 1;\n  if (step[s] != '=')\n    {\n      fprintf(stderr,\n\t      \"sbstrans: before %d: missing = in model statement in proc glm\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  for (s += 2; step[s] && step[s] != '/' && step[s] != ';'; s++)\n    {\n      if (step[s] == '\\n')\n\tputc(' ', dapfile);\n      else\n\tputc(step[s], dapfile);\n    }\n  fputs(\"\\\", \\\"\", dapfile);\n  copylist(step, \"by\", dapfile);\n  fputs(\"\\\");\\n\", dapfile);\n\n  /* now we've run the model, it's time to test each effect in it */\n  /* we need a separate call to ftest for each effect and check for lsmeans statements\n   */\n\n  /* first get the first lsmeans statement */\n  if ((lsmeans = findstatement(step, \"lsmeans\")))\n    { /* see if it specifies an error term */\n      if (getoption(step + lsmeans, \"e\", (char *) NULL, 1))\n\tlsmeans = 0; /* not going to use it */\n      else /* need to get test name, alpha */\n\t{\n\t  for (s = lsmeans; step[s] && step[s] != '/' && step[s] != ';'; s++)\n\t    ; /* get to options */\n\t  test[0] = '\\0'; /* haven't found one yet... */\n\t  if (step[s] == '/')\n\t    {\n\t      for (s += 2; step[s] && step[s] != ';'; )\n\t\t{\n\t\t  s += linecpy(test, step + s) + 1;\n\t\t  upper(test);\n\t\t  if (strcmp(test, \"DUNNETT\") && strcmp(test, \"TUKEY\") && strcmp(test, \"LSD\"))\n\t\t    test[0] = '\\0'; /* wasn't, after all */\n\t\t}\n\t    }\n\t  if (!test[0])\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: no test specified in lsmeans statement in proc glm\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t  if (!getoption(step + lsmeans, \"alpha\", level, 1))\n\t    strcpy(level, \"0.05\");\n\t}\n    }\n\n  /* now we're ready to test the terms in the model, one-by-one */\n\n  e = modelstart + resplen + 3;\n  while (step[e] && step[e] != '/' && step[e] != ';')\n    {\n      fprintf(dapfile, \"ftest(\\\"%s.srt.mns.con\\\", \\\"%s \", setname, response);\n      copylist(step, \"class\", dapfile);\n      fputs(\"\\\", \\\"\", dapfile);\n      /* here comes the numerator */\n      term = e; /* mark this place for lsmeans */\n      while (step[e] && step[e] != '\\n')\n\t{\n\t  putc(step[e], dapfile);\n\t  e++;\n\t  /* now see if it's a crossed or nested effect */\n\t  if (step[e] == '\\n' && step[e + 1] == '*') /* then need to keep copying */\n\t    {\n\t      putc('*', dapfile);\n\t      e += 3; /* get to next variable */\n\t      term = 0; /* mark as crossed: lsmeans can't handle these yet */\n\t    }\n\t}\n      fputs(\"\\\", \\\"\\\", \\\"\", dapfile); /* null denominator */\n      copylist(step, \"by\", dapfile);\n      fputs(\"\\\");\\n\", dapfile);\n      e++; /* position at next term */\n\n      if (lsmeans && term) /* term is position of numerator in ftest just run */\n\t{\n\t  for (s = lsmeans; step[s] && step[s] != '/' && step[s] != ';' &&\n\t\t (nomatch = linecmp(step + s, step + term));\n\t       s += linecpy((char *) NULL, step + s) + 1)\n\t    ; /* search for ftest effect in lsmeans statement */\n\t  if (!nomatch)\n\t    {\n\t      fprintf(dapfile,\n\t\t      \"lsmeans(\\\"%s.srt.mns.tst\\\", \\\"%s\\\", %s, \\\"%s \",\n\t\t      setname, test, level, response);\n\t      copylist(step, \"class\", dapfile);\n\t      fputs(\"\\\", \\\"\", dapfile);\n\t      for (s = term; step[s] && step[s] != '\\n'; s++)\n\t\tputc(step[s], dapfile);\n\t      fputs(\"\\\", \\\"\", dapfile);\n\t      copylist(step, \"by\", dapfile);\n\t      fputs(\"\\\", \\\"s12\\\");\\n\", dapfile);\n\t    }\n\t}\n    }\n\n  /* now do specific test request */\n  for (s = 0; (sincr = findstatement(step + s, \"test\")); )\n    {\n      s += sincr;\n      fprintf(dapfile, \"ftest(\\\"%s.srt.mns.con\\\", \\\"%s \", setname, response);\n      copylist(step, \"class\", dapfile);\n      fputs(\"\\\", \\\"\", dapfile);\n      if (!step[s] || linecmp(step + s, \"h\") || linecmp(step + s + 2, \"=\"))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing h= in test statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      for (s += 4; step[s] &&\n\t     (linecmp(step + s, \"e\") || (step[s + 2] && linecmp(step + s + 2, \"=\"))); s++)\n\ts += putlines(step + s, dapfile, '\\n'); /* putlines puts a space */\n      if (!step[s] || linecmp(step + s, \"e\") || linecmp(step + s + 2, \"=\"))\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing e= in test statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\"\\\", \\\"\", dapfile);\n      s += 4;\n      s += putlines(step + s, dapfile, ';');\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: extra characters after e=<effect> in test statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\"\\\", \\\"\", dapfile);\n      copylist(step, \"by\", dapfile);\n      fputs(\"\\\");\\n\", dapfile);\n    }\n\n  /* Now do contrasts: each contrast statement runs a separate ftest */\n  /* First set up array for coefficient values: this is an overestimate; so? */\n  /* And it's unncessary if there's no contrast statement */\n  coeff = (int *) malloc(sizeof(int) * strlen(step) / 2);\n  /* First set up array for coefficient values: this is an overestimate; so? */\n  for (s = 0; (sincr = findstatement(step + s, \"contrast\")); )\n    {\n      s += sincr;\n      if (step[s] != '\"')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing \\\"LABEL\\\" in contrast statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\"title(\\\"\", dapfile);\n      for (s++; step[s] && step[s] != '\"'; s++)\n\t/* can't use putlines because we want the newlines */\n\tputc(step[s], dapfile);\n      if (step[s] != '\"')\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: no terminating \\\" in contrast statement label in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\"\\\");\\n\", dapfile);\n      s += 2; /* on to effect and values */\n      /* We need to revise the .con file \"by hand\" for ftest */\n      /* We need to set up _term_ for the class variable specified in the contrast. */\n      /* Find class variable referenced */\n      for (contrastterm = 0x1, e = classstart, classvar = 0; step[e] && step[e] != ';';\n\t   contrastterm = (contrastterm << 1), classvar++)\n\t{\n\t  if (!linecmp(step + s, step + e))\n\t    break;\n\t  else\n\t    e += linecpy((char *) NULL, step + e) + 1;\n\t}\n      classvar++; /* now is 1, 2, ..., 3 */\n      s += linecpy(classname, step + s) + 1;\n      /* should have coefficients now */\n      for (ncoeff = 0, coeffsum = 0; num(step[s]) || step[s] == '+' || step[s] == '-';\n\t   ncoeff++)\n\t{\n\t  if (step[s] == '+' || step[s] == '-')\n\t    {\n\t      minus = (step[s] == '-');\n\t      s += 2;\n\t    }\n\t  else\n\t    minus = 0;\n\t  if (sscanf(step + s, \"%d\", coeff + ncoeff) != 1)\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: invalid coefficient in contrast statement in proc glm\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t  if (minus)\n\t    coeff[ncoeff] = -coeff[ncoeff];\n\t  coeffsum += coeff[ncoeff];\n\t  s += linecpy((char *) NULL, step + s) + 1;\n\t}\n      if (coeffsum)\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: coefficients sum to nonzero in contrast statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      if (step[s] == '/') /* on to e=, if any */\n\ts += 2;\n      /* We'll start with the file that effects created */\n      fprintf(dapfile, \"inset(\\\"%s.srt.mns.con\\\")\\n{\\n\", setname);\n      fprintf(dapfile, \"char _type_[9];\\ndouble %s;\\nint _n_, _term_;\\n\", response);\n      fprintf(dapfile, \"int _partv_[%d];\\n\", nbyvars + classvar);\n      fprintf(dapfile, \"int _c_, _more_, _contr1_;\\ndouble _coeff_[%d];\\n\", ncoeff);\n      fprintf(dapfile, \"outset(\\\"%s.srt.mns.con.con\\\", \\\"\\\");\\n\", setname);\n      fputs(\"dap_list(\\\"\", dapfile);\n      copylist(step, \"by\", dapfile);\n      for (e = classstart, c = 0; c < classvar; c++)\n\te += putlines(step + e, dapfile, '\\n') + 1;\n      fprintf(dapfile, \"\\\", _partv_, %d);\\n\", nbyvars + classvar);\n      /* now we need to set the coefficient array values */\n      for (c = 0; c < ncoeff; c++)\n\tfprintf(dapfile, \"_coeff_[%d] = %d.0;\\n\", c, coeff[c]);\n      /* first write out N, MEAN, VAR */\n      fputs(\"for (_c_ = 0, _contr1_ = 1, _more_ = step(); _more_; )\\n{\\n\", dapfile);\n      fprintf(dapfile, \"if (dap_newpart(_partv_, %d))\\n_c_ = 0;\\n\", nbyvars + classvar - 1);\n      fprintf(dapfile, \"else if (dap_newpart(_partv_, %d))\\n_c_++;\\n\", nbyvars + classvar);\n      fputs(\"output();\\nstep();\\noutput();\\nstep();\\noutput();\\n\", dapfile);\n      /* need to include ERROR lines, but skip CONTR lines for specified effect */\n      fputs(\"while ((_more_ = step()))\\n{\\n\", dapfile);\n      fputs(\"if (!strcmp(_type_, \\\"ERROR\\\"))\\noutput();\\n\", dapfile);\n      fputs(\"else if (!strcmp(_type_, \\\"CONTR\\\"))\\n{\\n\", dapfile);\n      fprintf(dapfile, \"if (_term_ == %d)\\n{\\n\", contrastterm); /* if 1st, change to contrast */\n      fprintf(dapfile, \"if (_contr1_)\\n{\\n_contr1_ = 0;\\n_term_ = %d;\\n\", contrastterm);\n      fprintf(dapfile, \"if (_c_ < %d)\\n\", ncoeff);\n      fprintf(dapfile, \"%s = _coeff_[_c_];\\nelse\\n%s = 0.0;\\n\", response, response);\n      fputs(\"output();\\n}\\n}\\n\", dapfile);\n      fputs(\"else\\noutput();\\n}\\n\", dapfile);\n      fputs(\"else if (!strcmp(_type_, \\\"LSMEAN\\\"))\\noutput();\\n\", dapfile);\n      fputs(\"else\\n\\{\\n_contr1_ = 1;\\nbreak;\\n}\\n}\\n}\\n}\\n\", dapfile); /* at another cell */\n      fprintf(dapfile, \"ftest(\\\"%s.srt.mns.con.con\\\", \\\"%s \", setname, response);\n      copylist(step, \"class\", dapfile);\n      fprintf(dapfile, \"\\\", \\\"%s\\\", \\\"\", classname);\n      if ((sincr = getoption(step + s, \"e\", (char *) NULL, 1)))\n\t{\n\t  s += sincr;\n\t  s += putlines(step + s, dapfile, ';');\n\t}\n      if (!linecmp(step + s, \";\"))\n\ts += 2;\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing ; at end of contrast statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      fputs(\"\\\", \\\"\", dapfile);\n      copylist(step, \"by\", dapfile);\n      fputs(\"\\\");\\ntitle(NULL);\\n\", dapfile);\n    }\n  free(coeff);\n\n  /* now do lsmeans statement(s) that we haven't done yet, if any */\n\n  while ((s = findstatement(step + lsmeans, \"lsmeans\"))) /* find next lsmeans statement */\n    {\n      lsmeans += s;\n      /* first get position of denominator, if any */\n      e = lsmeans + getoption(step + lsmeans, \"e\", (char *) NULL, 1);\n      if (!getoption(step + lsmeans, \"alpha\", level, 1))\n\tstrcpy(level, \"0.05\");\n      /* get test type */\n      test[0] = '\\0'; /* in case we never find one */\n      for (s = lsmeans; step[s] && step[s] != '/' && step[s] != ';'; s++)\n\t;\n      if (step[s] == '/')\n\t{\n\t  for (s += 2; step[s] && step[s] != ';'; )\n\t    {\n\t      s += linecpy(test, step + s) + 1;\n\t      upper(test);\n\t      if (strcmp(test, \"DUNNETT\") && strcmp(test, \"TUKEY\") && strcmp(test, \"LSD\"))\n\t\ttest[0] = '\\0'; /* wasn't, after all */\n\t    }\n\t}\n      if (!test[0])\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: no test specified in lsmeans statement in proc glm\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n      upper(test);\n      for (s = lsmeans; step[s] && step[s] != '/' && step[s] != ';'; s++)\n\t{ /* one term at a time */\n\t  fprintf(dapfile, \"ftest(\\\"%s.srt.mns.con\\\", \\\"%s \", setname, response);\n\t  copylist(step, \"class\", dapfile);\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  /* here comes the numerator */\n\t  term = s; /* mark this place for call to lsmeans */\n\t  s += putlines(step + s, dapfile, '\\n');\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  if (e > lsmeans) /* put denominator */\n\t    {\n\t      for (s = e; step[s] && step[s] != ';' && linecmp(step + s, \"alpha\") &&\n\t\t     linecmp(step + s, \"dunnett\") && linecmp(step + s, \"tukey\") &&\n\t\t     linecmp(step + s, \"lsd\"); s += putlines(step + s, dapfile, '\\n') + 1)\n\t\t;\n\t    }\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  copylist(step, \"by\", dapfile);\n\t  fputs(\"\\\");\\n\", dapfile);\n\n\t  /* now the lsmeans statement */\n\n\t  fprintf(dapfile, \"lsmeans(\\\"%s.srt.mns.tst\\\", \\\"%s\\\", %s, \\\"%s \",\n\t\t  setname, test, level, response);\n\t  copylist(step, \"class\", dapfile);\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  s = term + putlines(step + term, dapfile, '\\n');\n\t  fputs(\"\\\", \\\"\", dapfile);\n\t  copylist(step, \"by\", dapfile);\n\t  fputs(\"\\\", \\\"s12\\\");\\n\", dapfile);\n\t}\n    }\n}",
      "lines": 404,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "logistictrans": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "void logistictrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  fprintf(dapfile, \"logreg(\\\"%s\\\", \\\"\", setname);\n  if ((s = findstatement(step, \"model\")))\n    {\n      /* response variable */\n      s += putlines(step + s, dapfile, '\\n') + 1; /* only one response variable allowed */\n      putc('/', dapfile); /* both forms use / in Dap */\n      if (step[s] == '/') /* we have the events / trials form */\n\t{\n\t  s += 2;\n\t  s += putlines(step + s, dapfile, '\\n') + 1;\n\t}\n      else\n\tputc('1', dapfile); /* binary response */\n      if (step[s] == '=')\n\t{\n\t  fputs(\"\\\", \\\"\\\", \\\"\", dapfile); /* x0-var-list is empty */\n\t  s += 2;\n\t  s += putlines(step + s, dapfile, ';');\n\t  fputs(\"\\\", \\\"\", dapfile); /* closes the x1 variable list */\n\t  copylist(step, \"by\", dapfile);\n\t  fputs(\"\\\", NULL, 0.95);\\n\", dapfile);\n\t}\n      else\n\t{\n\t  fprintf(stderr,\n\t\t  \"sbstrans: before %d: missing = in model statement in proc logistic.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing model statement in proc logistic.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n  if (getoption(step, \"outest\", outname, 1))\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.cov\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname);\n    }\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "npar1waytrans": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "void npar1waytrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  char setname[TOKENLEN + 1];\n  char classname[TOKENLEN + 1]; /* name of class variable */\n\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  if ((s = findstatement(step, \"class\")))\n    linecpy(classname, step + s);\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing class statement in proc npar1way.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n\n  if ((s = findstatement(step, \"var\")))\n    {\n      while (step[s] && step[s] != ';') /* if there are multiple variables, then... */\n\t{ /* need to run nonparam for each */\n\t  fprintf(dapfile, \"nonparam(\\\"%s\\\", \\\"\", setname);\n\t  while (step[s] && step[s] != '\\n')\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t  fprintf(dapfile, \" %s\\\", \\\"\", classname);\n\t  copylist(step, \"by\", dapfile);\n\t  fputs(\"\\\");\\n\", dapfile);\n\t  s++;\n\t}\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: missing ; at end of proc npar1way.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else\n    {\n      fprintf(stderr, \"sbstrans: before %d: missing var statement in proc npar1way.\\n\",\n\t      sbslineno);\n      exit(1);\n    }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "regtrans": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "void regtrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  char setname[TOKENLEN + 1];\n  char outname[TOKENLEN + 1];\n  int isadd; /* is there an add statement? */\n\n  if (!getoption(step, \"data\", setname, 1))\n    strcpy(setname, sbstmp);\n\n  if (findstatement(step, \"plot\")) /* we're going to call plotlinreg */\n    {\n      if (isby(step) >= 0)\n\tcountparts(step, setname, dapfile);\n      else\n\tfputs(\"_sbspictcnt_[_sbsnpicts_] = 1;\\n\", dapfile);\n      fprintf(dapfile, \"_sbspict_[_sbsnpicts_] = plotlinreg(\\\"%s\\\", \\\"\", setname);\n      if ((s = findstatement(step, \"model\")))\n\t{\n\t  /* response variable: must be only 1 */\n\t  while (step[s] && step[s] != '\\n')\n\t    {\n\t      putc(step[s], dapfile);\n\t      s++;\n\t    }\n\t  s++;\n\t  if (step[s] == '=')\n\t    {\n\t      fputs(\"\\\", \\\"\", dapfile);\n\t      for (s += 2; step[s] && step[s] != '\\n'; s++)\n\t\tputc(step[s], dapfile);\n\t      if (step[s + 1] != ';')\n\t\t{\n\t\t  fprintf(stderr,\n\t\t\t  \"sbstrans: before %d: only one explanatory variable allowed in model statement in proc reg with plotting\\n\",\n\t\t\t  sbslineno);\n\t\t  exit(1);\n\t\t}\n\t      fputs(\"\\\", \\\"==\\\", \\\"\", dapfile);\n\t      copylist(step, \"by\", dapfile);\n\t      fputs(\"\\\", _sbspictcnt_[_sbsnpicts_], 0.95);\\n\", dapfile);\n\t      fputs(\"_sbspictpage_[_sbsnpicts_++] = 4;\\n\", dapfile);\n\t      sbshaspicts = 1;\n\t    }\n\t  else\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: only one response variable allowed in model statement in proc reg with plotting\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: missing model statement in proc reg.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  else /* just use linreg */\n    {\n      fprintf(dapfile, \"linreg(\\\"%s\\\", \\\"\", setname);\n      if ((s = findstatement(step, \"model\")))\n\t{\n\t  /* response variables */\n\t  s += putlines(step + s, dapfile, '=');\n\t  if (step[s] == '=')\n\t    {\n\t      fputs(\"\\\", \\\"\", dapfile);\n\t      if (!(isadd = findstatement(step, \"add\"))) /* reduced model is intercept only */\n\t\tfputs(\"\\\", \\\"\", dapfile); /* close x0-variables list */\n\t      s += 2;\n\t      s += putlines(step + s, dapfile, ';');\n\t      fputs(\"\\\", \\\"\", dapfile); /* either closes the x0 or x1 variable list */\n\t      if (isadd) /* put in the x1-variables */\n\t\t{\n\t\t  copylist(step, \"add\", dapfile);\n\t\t  fputs(\"\\\", \\\"\", dapfile); /* closes the x1 variable list */\n\t\t}\n\t      copylist(step, \"by\", dapfile);\n\t      fputs(\"\\\", NULL, 0.95);\\n\", dapfile);\n\t    }\n\t  else\n\t    {\n\t      fprintf(stderr,\n\t\t      \"sbstrans: before %d: missing = in model statement in proc reg.\\n\",\n\t\t      sbslineno);\n\t      exit(1);\n\t    }\n\t}\n      else\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: missing model statement in proc reg.\\n\",\n\t\t  sbslineno);\n\t  exit(1);\n\t}\n    }\n  if (getoption(step, \"outest\", outname, 1))\n    {\n      fprintf(dapfile, \"dataset(\\\"%s.cov\\\", \\\"%s\\\", \\\"RENAME\\\");\\n\", setname, outname);\n      strcpy(sbstmp, outname);\n    }\n}",
      "lines": 103,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "daptrans": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "void daptrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  int brace; /* level of braces nesting */\n\n  s = 0;\n  if (step[s] != ';')\n    {\n      fprintf(stderr, \"sbstrans: before %d: no options allowed for proc dap\\n\", sbslineno);\n      exit(1);\n    }\n  s += 2;\n  if (step[s] == '{')\n    {\n      fputs(\"{\\n\", dapfile);\n      for (s += 2, brace = 1; brace && step[s]; s++)\n\t{\n\t  if (step[s] == '\\n')\n\t    putc(' ', dapfile);\n\t  else\n\t    putc(step[s], dapfile);\n\t  if (step[s] == ';' || step[s] == '{' || step[s] == '}')\n\t    putc('\\n', dapfile);\n\t  if (step[s] == '{')\n\t    brace++;\n\t  else if (step[s] == '}')\n\t    --brace;\n\t}\n      if (brace)\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: missing } in proc dap\\n\", sbslineno);\n\t  exit(1);\n\t}\n      putc('\\n', dapfile);\n    }\n  else\n    {\n      s += putlines(step + s, dapfile, ';');\n      if (step[s] != ';')\n\t{\n\t  fprintf(stderr, \"sbstrans: before %d: missing ; in proc dap\\n\", sbslineno);\n\t  exit(1);\n\t}\n      fputs(\";\\n\", dapfile);\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "importtrans": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "void importtrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  int brace; /* level of braces nesting */\n  int start; /* starting position */\n  int resplen; /* length of response variable name */\n  int replace=0;\n  static char delimiter[TOKENLEN + 1];\n  static char setname[TOKENLEN + 1];\n  static char datafile[TOKENLEN + 1];\n  static char dbms[TOKENLEN + 1];\n  static char strreplace[TOKENLEN + 1];\n  static char getnames[4];\n\t\n  if (!getoption(step, \"out\", setname, 1))\n    strcpy(setname, sbstmp);\n  if (!getoption(step, \"datafile\", datafile, 1))\n    strcpy(datafile, sbstmp);\n  if (!getoption(step, \"dbms\", dbms, 1))\n    strcpy(dbms, sbstmp);\n  if (!getoption(step, \"delimiter\", delimiter, 1))\n    strcpy(delimiter, \"\");\n  else{\n\tif(delimiter[0]=='\\'')\n\t\tdelimiter[0]='\"';\n\tif(delimiter[strlen(delimiter)-1]=='\\'')\n\t\tdelimiter[strlen(delimiter)-1]='\"';\n}\n   \n   if ((s = findstatement(step, \"getnames\")))\n   {\n\tint i=8;\n\twhile(step[s+i]!='n'&&step[s+i]!='y'&&step[s+i]!=';'&&step[s+i]!='\\0')\n\t\ti++;\n\tif (step[s+i]=='n'||step[s+i]=='N')\n\t\tstrcpy(getnames, \"no\");\n\telse\n\t\tstrcpy(getnames, \"yes\");\n   }\n\n  int getnam=1;\n  if(strcmp(getnames,\"no\")==0)\n\t  getnam=0;\n  if (!getoption(step, \"replace\", strreplace, 0))\n    replace=1;\n  /* we have to sort by the class vars and to get means, etc. */\n  fprintf(dapfile, \"import(\\\"%s\\\", %s , \\\"%s\\\",%s, %i,%i);\\n\", setname,datafile,dbms,delimiter,replace,getnam);\n  \n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "surveyselecttrans": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "void surveyselecttrans(char *step, FILE *dapfile)\n{\n  int s; /* index to step */\n  int brace; /* level of braces nesting */\n  int start; /* starting position */\n  int resplen; /* length of response variable name */\n  int replace=0;\n  static char nbtirage[TOKENLEN + 1];\n  static char setname[TOKENLEN + 1];\n  static char datafile[TOKENLEN + 1];\n  static char method[TOKENLEN + 1];\n  static char strreplace[TOKENLEN + 1];\n  static char getnames[4];\n\t//data =tPres2007 method=SRS  n = 220  reps= 50  seed= 1213   out=sasPres2007 stats\n  if (!getoption(step, \"out\", setname, 1))\n    strcpy(setname, sbstmp);\n  if (!getoption(step, \"data\", datafile, 1))\n    strcpy(datafile, sbstmp);\n  if (!getoption(step, \"method\", method, 1))\n    strcpy(method, sbstmp);\n  if (!getoption(step, \"n\", nbtirage, 1))\n    strcpy(nbtirage, \"1\");\n \n\n   \n  \n  /* we have to sort by the class vars and to get means, etc. */\n  // surveyselect(char *fname,char *outname,char *method,int tirage);\n  fprintf(dapfile, \" surveyselect(\\\"%s\\\", \\\"%s\\\" , \\\"%s\\\",%s);\\n\", datafile,setname,method,nbtirage);\n  \n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  }
}