{
  "units/units-2.16/getopt.c": {},
  "units/units-2.16/getopt.h": {},
  "units/units-2.16/getopt1.c": {},
  "units/units-2.16/parse.tab.c": {
    "getnewunit": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "struct unittype *\ngetnewunit()\n{\n  struct unittype *unit;\n\n  if (unitcount>=MAXMEM)\n    return 0;\n  unit = (struct unittype *) \n    mymalloc(sizeof(struct unittype),\"(getnewunit)\");\n  if (!unit)\n    return 0;\n  initializeunit(unit);\n  unitcount++;\n  return unit;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "struct unittype",
        "struct",
        "unittype",
        "*\ngetnewunit()",
        "*"
      ]
    },
    "destroyunit": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\ndestroyunit(struct unittype *unit)\n{\n  freeunit(unit);\n  free(unit);\n  unitcount--;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "makenumunit": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "struct unittype *\nmakenumunit(double num,int *myerr)\n{\n  struct unittype *ret;\n  ret=getnewunit();\n  if (!ret){\n    *myerr = E_PARSEMEM;\n    return 0;  \n  }\n  ret->factor = num;\n  *myerr = 0;\n  return ret;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "struct unittype",
        "struct",
        "unittype",
        "*\nmakenumunit(double num,int *myerr)",
        "*"
      ]
    },
    "logb2": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "double \nlogb2(double x)\n{\n  return log(x)/log(2.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "funcunit": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "int\nfuncunit(struct unittype *theunit, struct function const *fun)\n{\n  struct unittype angleunit;\n\n  if (fun->type==ANGLEIN){\n    err=unit2num(theunit);\n    if (err==E_NOTANUMBER){\n      initializeunit(&angleunit);\n      angleunit.denominator[0] = dupstr(\"radian\");\n      angleunit.denominator[1] = 0;\n      err = multunit(theunit, &angleunit);\n      freeunit(&angleunit);\n      if (!err)\n        err = unit2num(theunit);\n    }\n    if (err)\n      return err;\n  } else if (fun->type==ANGLEOUT || fun->type == DIMENSIONLESS) {\n    if ((err=unit2num(theunit)))\n      return err;\n    \n  } else \n     return E_BADFUNCTYPE;\n  errno = 0;\n  theunit->factor = (*(fun->func))(theunit->factor);\n  if (errno)\n    return E_FUNC;\n  if (fun->type==ANGLEOUT) {\n    theunit->numerator[0] = dupstr(\"radian\");\n    theunit->numerator[1] = 0;\n  }\n  return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "yy_symbol_value_print": {
      "start_point": [
        815,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, struct commtype *comm)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  YYUSE (comm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        843,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, struct commtype *comm)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep, comm);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, struct commtype *comm)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , comm);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        934,
        0
      ],
      "end_point": [
        941,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        973,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1146,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1200,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, struct commtype *comm)\n{\n  YYUSE (yyvaluep);\n  YYUSE (comm);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 4: /* UNIT  */\n#line 187 \"parse.y\" /* yacc.c:1257  */\n      { destroyunit(((*yyvaluep).unit));}\n#line 1170 \"parse.tab.c\" /* yacc.c:1257  */\n        break;\n\n    case 28: /* unitexpr  */\n#line 187 \"parse.y\" /* yacc.c:1257  */\n      { destroyunit(((*yyvaluep).unit));}\n#line 1176 \"parse.tab.c\" /* yacc.c:1257  */\n        break;\n\n    case 29: /* expr  */\n#line 187 \"parse.y\" /* yacc.c:1257  */\n      { destroyunit(((*yyvaluep).unit));}\n#line 1182 \"parse.tab.c\" /* yacc.c:1257  */\n        break;\n\n    case 31: /* pexpr  */\n#line 187 \"parse.y\" /* yacc.c:1257  */\n      { destroyunit(((*yyvaluep).unit));}\n#line 1188 \"parse.tab.c\" /* yacc.c:1257  */\n        break;\n\n    case 32: /* list  */\n#line 187 \"parse.y\" /* yacc.c:1257  */\n      { destroyunit(((*yyvaluep).unit));}\n#line 1194 \"parse.tab.c\" /* yacc.c:1257  */\n        break;\n\n\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1901,
        1
      ],
      "content": "int\nyyparse (struct commtype *comm)\n{\n/* The lookahead symbol.  */\nint yychar;\n\n\n/* The semantic value of the lookahead symbol.  */\n/* Default value used for initialization, for pacifying older GCCs\n   or non-GCC compilers.  */\nYY_INITIAL_VALUE (static YYSTYPE yyval_default;)\nYYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n\n    /* Number of syntax errors so far.  */\n    int yynerrs;\n\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex (&yylval, comm);\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 2:\n#line 199 \"parse.y\" /* yacc.c:1646  */\n    { comm->result = makenumunit(1,&err); CHECK(0);\n                       comm->errorcode = 0; YYACCEPT; }\n#line 1463 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 3:\n#line 201 \"parse.y\" /* yacc.c:1646  */\n    { comm->result = (yyvsp[-1].unit); comm->errorcode = 0; YYACCEPT; }\n#line 1469 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 4:\n#line 202 \"parse.y\" /* yacc.c:1646  */\n    { YYABORT; }\n#line 1475 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 205 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[0].unit);}\n#line 1481 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 206 \"parse.y\" /* yacc.c:1646  */\n    { invertunit((yyvsp[0].unit)); (yyval.unit)=(yyvsp[0].unit);}\n#line 1487 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 209 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[0].unit); }\n#line 1493 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 210 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[0].unit); (yyval.unit)->factor *= -1; }\n#line 1499 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 211 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[0].unit); (yyval.unit)->factor *= -1; }\n#line 1505 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 212 \"parse.y\" /* yacc.c:1646  */\n    { err = addunit((yyvsp[-2].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                      CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1512 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 214 \"parse.y\" /* yacc.c:1646  */\n    { (yyvsp[0].unit)->factor *= -1;\n                                      err = addunit((yyvsp[-2].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                      CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1520 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 217 \"parse.y\" /* yacc.c:1646  */\n    { err = divunit((yyvsp[-2].unit), (yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                      CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1527 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 219 \"parse.y\" /* yacc.c:1646  */\n    { err = multunit((yyvsp[-2].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                      CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1534 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 221 \"parse.y\" /* yacc.c:1646  */\n    { err = multunit((yyvsp[-2].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                      CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1541 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 225 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.number) = (yyvsp[0].number);         }\n#line 1547 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 16:\n#line 226 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.number) = (yyvsp[-2].number) / (yyvsp[0].number);    }\n#line 1553 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 229 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[-1].unit);  }\n#line 1559 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 235 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = makenumunit((yyvsp[0].number),&err); CHECK(0);}\n#line 1565 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 236 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit) = (yyvsp[0].unit); }\n#line 1571 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 237 \"parse.y\" /* yacc.c:1646  */\n    { err = unitpower((yyvsp[-2].unit),(yyvsp[0].unit));destroyunit((yyvsp[0].unit));\n                                     CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1578 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 239 \"parse.y\" /* yacc.c:1646  */\n    { err = multunit((yyvsp[-2].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                     CHECK((yyvsp[-2].unit));(yyval.unit)=(yyvsp[-2].unit);}\n#line 1585 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 241 \"parse.y\" /* yacc.c:1646  */\n    { err = multunit((yyvsp[-1].unit),(yyvsp[0].unit)); destroyunit((yyvsp[0].unit));\n                                     CHECK((yyvsp[-1].unit));(yyval.unit)=(yyvsp[-1].unit);}\n#line 1592 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 243 \"parse.y\" /* yacc.c:1646  */\n    { (yyval.unit)=(yyvsp[0].unit); }\n#line 1598 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 244 \"parse.y\" /* yacc.c:1646  */\n    { err = rootunit((yyvsp[0].unit),2); CHECK((yyvsp[0].unit)); (yyval.unit)=(yyvsp[0].unit);}\n#line 1604 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 245 \"parse.y\" /* yacc.c:1646  */\n    { err = rootunit((yyvsp[0].unit),3); CHECK((yyvsp[0].unit)); (yyval.unit)=(yyvsp[0].unit);}\n#line 1610 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 246 \"parse.y\" /* yacc.c:1646  */\n    { err = funcunit((yyvsp[0].unit),(yyvsp[-1].realfunc));CHECK((yyvsp[0].unit)); (yyval.unit)=(yyvsp[0].unit);}\n#line 1616 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 247 \"parse.y\" /* yacc.c:1646  */\n    { err = evalfunc((yyvsp[0].unit),(yyvsp[-1].unitfunc),0,0); CHECK((yyvsp[0].unit));(yyval.unit)=(yyvsp[0].unit);}\n#line 1622 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 248 \"parse.y\" /* yacc.c:1646  */\n    { err = evalfunc((yyvsp[0].unit),(yyvsp[-1].unitfunc),1,0); CHECK((yyvsp[0].unit));(yyval.unit)=(yyvsp[0].unit);}\n#line 1628 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 250 \"parse.y\" /* yacc.c:1646  */\n    { (yyvsp[0].unit)->factor *= -1; err = unitpower((yyvsp[-3].unit),(yyvsp[0].unit));\n                                     destroyunit((yyvsp[0].unit));CHECK((yyvsp[-3].unit));(yyval.unit)=(yyvsp[-3].unit);}\n#line 1635 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 253 \"parse.y\" /* yacc.c:1646  */\n    { (yyvsp[0].unit)->factor *= -1; err = unitpower((yyvsp[-3].unit),(yyvsp[0].unit));\n                                     destroyunit((yyvsp[0].unit));CHECK((yyvsp[-3].unit));(yyval.unit)=(yyvsp[-3].unit);}\n#line 1642 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 255 \"parse.y\" /* yacc.c:1646  */\n    { err = E_BADNUM;   CHECK(0); }\n#line 1648 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 256 \"parse.y\" /* yacc.c:1646  */\n    { err = E_PARSEMEM; CHECK(0); }\n#line 1654 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 257 \"parse.y\" /* yacc.c:1646  */\n    { err = E_UNITEND;  CHECK(0); }\n#line 1660 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 258 \"parse.y\" /* yacc.c:1646  */\n    { err = E_LASTUNSET;CHECK(0); }\n#line 1666 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 259 \"parse.y\" /* yacc.c:1646  */\n    { err = E_NOTAFUNC; CHECK((yyvsp[0].unit));}\n#line 1672 \"parse.tab.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 1676 \"parse.tab.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (comm, YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (comm, yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval, comm);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp, comm);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (comm, YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval, comm);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp, comm);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 693,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "yylex": {
      "start_point": [
        1942,
        0
      ],
      "end_point": [
        2111,
        1
      ],
      "content": "int yylex(YYSTYPE *lvalp, struct commtype *comm)\n{\n  int length, count;\n  struct unittype *output;\n  const char *inptr;\n  char *name;\n\n  char *nonunitchars = \"~;+-*/|\\t\\n^ ()\"; /* Chars not allowed in unit name */\n  char *nonunitends = \".,_\";              /* Can't start or end a unit */\n  char *number_start = \".,0123456789\";    /* Can be first char of a number */\n  \n  if (comm->location==-1) return 0;\n  inptr = comm->data + comm->location;   /* Point to start of data */\n\n  /* Skip spaces */\n  while(*inptr==' ') inptr++, comm->location++;\n\n  if (*inptr==0) {\n    comm->location = -1;\n    return EOL;  /* Return failure if string has ended */\n  }  \n\n  /* Check for **, an exponent operator.  */\n\n  if (0==strncmp(\"**\",inptr,2)){\n    comm->location += 2;\n    return EXPONENT;\n  }\n\n  /* Check for '-' and '*' which get special handling */\n\n  if (*inptr=='-'){\n    comm->location++;\n    if (parserflags.minusminus)\n      return MINUS;\n    return MULTMINUS;\n  }      \n\n  if (*inptr=='*'){\n    comm->location++;\n    if (parserflags.oldstar)\n      return MULTIPLY;\n    return MULTSTAR;\n  }      \n\n  /* Check for the \"last unit\" symbol */ \n\n  if (*inptr == LASTUNIT) {\n    comm->location++;\n    if (!lastunitset) \n      return LASTUNSET;\n    output = getnewunit();\n    if (!output)\n      return MEMERROR;\n    unitcopy(output, &lastunit);\n    lvalp->unit = output;\n    return UNIT;\n  } \n\n  /* Look for single character ops */\n\n  for(count=0; optable[count].op; count++){\n    if (*inptr==optable[count].op) {\n       comm->location++;\n       return optable[count].value;\n    }\n  }\n\n  /* Look for numbers */\n\n  if (strchr(number_start,*inptr)){  /* prevent \"nan\" from being recognized */\n    char *endloc;\n    lvalp->number = strtod(inptr, &endloc);\n    if (inptr != endloc) { \n      comm->location += (endloc-inptr);\n      if (*endloc && strchr(number_start,*endloc))\n        return BADNUMBER;\n      else\n        return REAL;\n    }\n  }\n\n  /* Look for a word (function name or unit name) */\n\n  length = strcspn(inptr,nonunitchars);   \n\n  if (!length){  /* Next char is not a valid unit char */\n     comm->location++;\n     return 0;\n  }\n\n  /* Check that unit name doesn't start or end with forbidden chars */\n  if (strchr(nonunitends,*inptr)){\n    comm->location++;\n    return 0;\n  }\n  if (strchr(nonunitends, inptr[length-1])){\n    comm->location+=length;\n    return 0;\n  }\n\n  name = dupnstr(inptr, length);\n\n  /* Look for string operators */\n\n  for(count=0;strtable[count].name;count++){\n    if (!strcmp(name,strtable[count].name)){\n      free(name);\n      comm->location += length;\n      return strtable[count].value;\n    }\n  }\n  \n  /* Look for real function names */\n\n  for(count=0;realfunctions[count].name;count++){\n    if (!strcmp(name,realfunctions[count].name)){\n      lvalp->realfunc = realfunctions+count;\n      comm->location += length;\n      free(name);\n      return REALFUNC;\n    }\n  }\n\n  /* Look for function parameter */\n\n  if (function_parameter && !strcmp(name,function_parameter)){\n    free(name);\n    output = getnewunit();\n    if (!output)\n      return MEMERROR;\n    unitcopy(output, parameter_value);\n    lvalp->unit = output;\n    comm->location += length;\n    return UNIT;\n  } \n\n  /* Look for user defined function */\n\n  lvalp->unitfunc = fnlookup(name);\n  if (lvalp->unitfunc){\n    comm->location += length;\n    free(name);\n    return UNITFUNC;\n  }\n\n  /* Didn't find a special string, so treat it as unit name */\n\n  comm->location+=length;\n  if (strchr(\"23456789\",inptr[length-1]) && !hassubscript(name)) {\n    /* ends with digit but not a subscript, so do exponent handling like m3 */\n    count = name[length-1] - '0';\n    length--;\n    if (strchr(number_start, name[length-1])){\n      free(name);\n      return UNITEND;\n    }\n  } else count=1;\n\n  free(name);\n    \n  output = getnewunit();\n  if (!output)\n    return MEMERROR;\n  output->numerator[count--]=0;\n  for(;count>=0;count--)\n    output->numerator[count] = dupnstr(inptr, length);\n  lvalp->unit=output;\n  return UNIT;\n}",
      "lines": 170,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        2114,
        0
      ],
      "end_point": [
        2114,
        46
      ],
      "content": "void yyerror(struct commtype *comm, char *s){}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "parseunit": {
      "start_point": [
        2117,
        0
      ],
      "end_point": [
        2155,
        1
      ],
      "content": "int\nparseunit(struct unittype *output, char const *input,char **errstr,int *errloc)\n{\n  struct commtype comm;\n  int saveunitcount;\n\n  saveunitcount = unitcount;\n  initializeunit(output);\n  comm.result = 0;\n  comm.location = 0;\n  comm.data = input;\n  comm.errorcode = E_PARSE;    /* Assume parse error */\n  errno=0;\n  if (yyparse(&comm) || errno){\n    if (comm.location==-1) \n      comm.location = strlen(input);\n    if (errstr){\n      if (comm.errorcode==E_FUNC || errno)\n        *errstr = strerror(errno);\n      else\n        *errstr=errormsg[comm.errorcode];\n    }\n    if (errloc)\n      *errloc = comm.location;\n    if (unitcount!=saveunitcount)\n      fprintf(stderr,\"units: Parser leaked memory with error: %d in %d out\\n\",\n             saveunitcount, unitcount);\n    return comm.errorcode;\n  } else {\n    if (errstr)\n      *errstr = 0;\n    multunit(output,comm.result);\n    destroyunit(comm.result);\n    if (unitcount!=saveunitcount)\n      fprintf(stderr,\"units: Parser leaked memory without error: %d in %d out\\n\",\n\t      saveunitcount, unitcount);\n    return 0;\n  }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "units/units-2.16/parse.y": {
    "getnewunit": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "struct unittype *\ngetnewunit()\n{\n  struct unittype *unit;\n\n  if (unitcount>=MAXMEM)\n    return 0;\n  unit = (struct unittype *) \n    mymalloc(sizeof(struct unittype),\"(getnewunit)\");\n  if (!unit)\n    return 0;\n  initializeunit(unit);\n  unitcount++;\n  return unit;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "struct unittype",
        "struct",
        "unittype",
        "*\ngetnewunit()",
        "*"
      ]
    },
    "destroyunit": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\ndestroyunit(struct unittype *unit)\n{\n  freeunit(unit);\n  free(unit);\n  unitcount--;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "makenumunit": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "struct unittype *\nmakenumunit(double num,int *myerr)\n{\n  struct unittype *ret;\n  ret=getnewunit();\n  if (!ret){\n    *myerr = E_PARSEMEM;\n    return 0;  \n  }\n  ret->factor = num;\n  *myerr = 0;\n  return ret;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "struct unittype",
        "struct",
        "unittype",
        "*\nmakenumunit(double num,int *myerr)",
        "*"
      ]
    },
    "logb2": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "double \nlogb2(double x)\n{\n  return log(x)/log(2.0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "funcunit": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\nfuncunit(struct unittype *theunit, struct function const *fun)\n{\n  struct unittype angleunit;\n\n  if (fun->type==ANGLEIN){\n    err=unit2num(theunit);\n    if (err==E_NOTANUMBER){\n      initializeunit(&angleunit);\n      angleunit.denominator[0] = dupstr(\"radian\");\n      angleunit.denominator[1] = 0;\n      err = multunit(theunit, &angleunit);\n      freeunit(&angleunit);\n      if (!err)\n        err = unit2num(theunit);\n    }\n    if (err)\n      return err;\n  } else if (fun->type==ANGLEOUT || fun->type == DIMENSIONLESS) {\n    if ((err=unit2num(theunit)))\n      return err;\n    \n  } else \n     return E_BADFUNCTYPE;\n  errno = 0;\n  theunit->factor = (*(fun->func))(theunit->factor);\n  if (errno)\n    return E_FUNC;\n  if (fun->type==ANGLEOUT) {\n    theunit->numerator[0] = dupstr(\"radian\");\n    theunit->numerator[1] = 0;\n  }\n  return 0;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "comm": [
      {
        "start_point": [
          148,
          14
        ],
        "end_point": [
          201,
          33
        ],
        "content": "struct commtype *comm}\n%lex-param {struct commtype *comm}\n%define api.pure full\n%define api.prefix {units}\n\n%union {\n  double number;\n  int integer;\n  struct unittype *unit;\n  struct function *realfunc;\n  struct func *unitfunc;\n}\n\n%token <number> REAL\n%token <unit> UNIT\n%token <realfunc> REALFUNC\n%token <unitfunc> UNITFUNC\n%token <integer> EXPONENT\n%token <integer> MULTIPLY\n%token <integer> MULTSTAR\n%token <integer> DIVIDE\n%token <integer> NUMDIV\n%token <integer> SQRT\n%token <integer> CUBEROOT\n%token <integer> MULTMINUS\n%token <integer> EOL\n%token <integer> FUNCINV\n%token <integer> MEMERROR\n%token <integer> BADNUMBER\n%token <integer> UNITEND\n%token <integer> LASTUNSET\n\n%type <number> numexpr\n%type <unit> expr\n%type <unit> list\n%type <unit> pexpr\n%type <unit> unitexpr\n\n%destructor { destroyunit($$);} <unit>\n\n%left ADD MINUS\n%left UNARY\n%left DIVIDE MULTSTAR\n%left MULTIPLY MULTMINUS\n%nonassoc '(' SQRT CUBEROOT REALFUNC UNIT REAL UNITFUNC FUNCINV MEMERROR BADNUMBER UNITEND LASTUNSET\n%right EXPONENT\n%left NUMDIV\n\n\n%%\n input: EOL           { comm->result = makenumunit(1,&err); CHECK(0);\n                       comm->errorcode = 0; YYACCEPT; }\n      | unitexpr EOL { comm->result = $1; comm->errorcode = 0; YYACCEPT; }\n      | error        { YYABORT; }",
        "lines": 54,
        "depth": 51,
        "decorators": null
      },
      {
        "start_point": [
          200,
          8
        ],
        "end_point": [
          200,
          74
        ],
        "content": "unitexpr EOL { comm->result = $1; comm->errorcode = 0; YYACCEPT; }",
        "lines": 1,
        "depth": 6,
        "decorators": null
      }
    ],
    "list": [
      {
        "start_point": [
          205,
          12
        ],
        "end_point": [
          205,
          61
        ],
        "content": "DIVIDE list             { invertunit($2); $$=$2;}",
        "lines": 1,
        "depth": 4,
        "decorators": null
      },
      {
        "start_point": [
          209,
          7
        ],
        "end_point": [
          209,
          66
        ],
        "content": "MULTMINUS list %prec UNARY   { $$ = $2; $$->factor *= -1; }",
        "lines": 1,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          210,
          7
        ],
        "end_point": [
          210,
          66
        ],
        "content": "MINUS list %prec UNARY       { $$ = $2; $$->factor *= -1; }",
        "lines": 1,
        "depth": 5,
        "decorators": null
      }
    ],
    "ADD": {
      "start_point": [
        211,
        7
      ],
      "end_point": [
        212,
        55
      ],
      "content": "expr ADD expr                { err = addunit($1,$3); destroyunit($3);\n                                      CHECK($1);$$=$1;}",
      "lines": 2,
      "depth": 8,
      "decorators": null
    },
    "MINUS": {
      "start_point": [
        213,
        7
      ],
      "end_point": [
        215,
        55
      ],
      "content": "expr MINUS expr              { $3->factor *= -1;\n                                      err = addunit($1,$3); destroyunit($3);\n                                      CHECK($1);$$=$1;}",
      "lines": 3,
      "depth": 8,
      "decorators": null
    },
    "MULTSTAR": {
      "start_point": [
        225,
        11
      ],
      "end_point": [
        225,
        56
      ],
      "content": "numexpr NUMDIV numexpr   { $$ = $1 / $3;    }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    },
    "MULTMINUS": [
      {
        "start_point": [
          240,
          8
        ],
        "end_point": [
          241,
          54
        ],
        "content": "list list %prec MULTIPLY   { err = multunit($1,$2); destroyunit($2);\n                                     CHECK($1);$$=$1;}",
        "lines": 2,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          243,
          8
        ],
        "end_point": [
          243,
          77
        ],
        "content": "SQRT pexpr                 { err = rootunit($2,2); CHECK($2); $$=$2;}",
        "lines": 1,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          244,
          8
        ],
        "end_point": [
          244,
          77
        ],
        "content": "CUBEROOT pexpr             { err = rootunit($2,3); CHECK($2); $$=$2;}",
        "lines": 1,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          245,
          8
        ],
        "end_point": [
          245,
          77
        ],
        "content": "REALFUNC pexpr             { err = funcunit($2,$1);CHECK($2); $$=$2;}",
        "lines": 1,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          246,
          8
        ],
        "end_point": [
          246,
          81
        ],
        "content": "UNITFUNC pexpr             { err = evalfunc($2,$1,0,0); CHECK($2);$$=$2;}",
        "lines": 1,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          247,
          8
        ],
        "end_point": [
          247,
          81
        ],
        "content": "FUNCINV UNITFUNC pexpr     { err = evalfunc($3,$2,1,0); CHECK($3);$$=$3;}",
        "lines": 1,
        "depth": 8,
        "decorators": null
      }
    ],
    "EXPONENT": [
      {
        "start_point": [
          248,
          22
        ],
        "end_point": [
          250,
          70
        ],
        "content": "MULTMINUS list %prec EXPONENT  \n                                   { $4->factor *= -1; err = unitpower($1,$4);\n                                     destroyunit($4);CHECK($1);$$=$1;}",
        "lines": 3,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          251,
          22
        ],
        "end_point": [
          253,
          70
        ],
        "content": "MINUS list %prec EXPONENT  \n                                   { $4->factor *= -1; err = unitpower($1,$4);\n                                     destroyunit($4);CHECK($1);$$=$1;}",
        "lines": 3,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          258,
          8
        ],
        "end_point": [
          258,
          66
        ],
        "content": "FUNCINV UNIT               { err = E_NOTAFUNC; CHECK($2);}",
        "lines": 1,
        "depth": 5,
        "decorators": null
      }
    ],
    "yylex": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "int yylex(YYSTYPE *lvalp, struct commtype *comm)\n{\n  int length, count;\n  struct unittype *output;\n  const char *inptr;\n  char *name;\n\n  char *nonunitchars = \"~;+-*/|\\t\\n^ ()\"; /* Chars not allowed in unit name */\n  char *nonunitends = \".,_\";              /* Can't start or end a unit */\n  char *number_start = \".,0123456789\";    /* Can be first char of a number */\n  \n  if (comm->location==-1) return 0;\n  inptr = comm->data + comm->location;   /* Point to start of data */\n\n  /* Skip spaces */\n  while(*inptr==' ') inptr++, comm->location++;\n\n  if (*inptr==0) {\n    comm->location = -1;\n    return EOL;  /* Return failure if string has ended */\n  }  \n\n  /* Check for **, an exponent operator.  */\n\n  if (0==strncmp(\"**\",inptr,2)){\n    comm->location += 2;\n    return EXPONENT;\n  }\n\n  /* Check for '-' and '*' which get special handling */\n\n  if (*inptr=='-'){\n    comm->location++;\n    if (parserflags.minusminus)\n      return MINUS;\n    return MULTMINUS;\n  }      \n\n  if (*inptr=='*'){\n    comm->location++;\n    if (parserflags.oldstar)\n      return MULTIPLY;\n    return MULTSTAR;\n  }      \n\n  /* Check for the \"last unit\" symbol */ \n\n  if (*inptr == LASTUNIT) {\n    comm->location++;\n    if (!lastunitset) \n      return LASTUNSET;\n    output = getnewunit();\n    if (!output)\n      return MEMERROR;\n    unitcopy(output, &lastunit);\n    lvalp->unit = output;\n    return UNIT;\n  } \n\n  /* Look for single character ops */\n\n  for(count=0; optable[count].op; count++){\n    if (*inptr==optable[count].op) {\n       comm->location++;\n       return optable[count].value;\n    }\n  }\n\n  /* Look for numbers */\n\n  if (strchr(number_start,*inptr)){  /* prevent \"nan\" from being recognized */\n    char *endloc;\n    lvalp->number = strtod(inptr, &endloc);\n    if (inptr != endloc) { \n      comm->location += (endloc-inptr);\n      if (*endloc && strchr(number_start,*endloc))\n        return BADNUMBER;\n      else\n        return REAL;\n    }\n  }\n\n  /* Look for a word (function name or unit name) */\n\n  length = strcspn(inptr,nonunitchars);   \n\n  if (!length){  /* Next char is not a valid unit char */\n     comm->location++;\n     return 0;\n  }\n\n  /* Check that unit name doesn't start or end with forbidden chars */\n  if (strchr(nonunitends,*inptr)){\n    comm->location++;\n    return 0;\n  }\n  if (strchr(nonunitends, inptr[length-1])){\n    comm->location+=length;\n    return 0;\n  }\n\n  name = dupnstr(inptr, length);\n\n  /* Look for string operators */\n\n  for(count=0;strtable[count].name;count++){\n    if (!strcmp(name,strtable[count].name)){\n      free(name);\n      comm->location += length;\n      return strtable[count].value;\n    }\n  }\n  \n  /* Look for real function names */\n\n  for(count=0;realfunctions[count].name;count++){\n    if (!strcmp(name,realfunctions[count].name)){\n      lvalp->realfunc = realfunctions+count;\n      comm->location += length;\n      free(name);\n      return REALFUNC;\n    }\n  }\n\n  /* Look for function parameter */\n\n  if (function_parameter && !strcmp(name,function_parameter)){\n    free(name);\n    output = getnewunit();\n    if (!output)\n      return MEMERROR;\n    unitcopy(output, parameter_value);\n    lvalp->unit = output;\n    comm->location += length;\n    return UNIT;\n  } \n\n  /* Look for user defined function */\n\n  lvalp->unitfunc = fnlookup(name);\n  if (lvalp->unitfunc){\n    comm->location += length;\n    free(name);\n    return UNITFUNC;\n  }\n\n  /* Didn't find a special string, so treat it as unit name */\n\n  comm->location+=length;\n  if (strchr(\"23456789\",inptr[length-1]) && !hassubscript(name)) {\n    /* ends with digit but not a subscript, so do exponent handling like m3 */\n    count = name[length-1] - '0';\n    length--;\n    if (strchr(number_start, name[length-1])){\n      free(name);\n      return UNITEND;\n    }\n  } else count=1;\n\n  free(name);\n    \n  output = getnewunit();\n  if (!output)\n    return MEMERROR;\n  output->numerator[count--]=0;\n  for(;count>=0;count--)\n    output->numerator[count] = dupnstr(inptr, length);\n  lvalp->unit=output;\n  return UNIT;\n}",
      "lines": 170,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        472,
        46
      ],
      "content": "void yyerror(struct commtype *comm, char *s){}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "parseunit": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "int\nparseunit(struct unittype *output, char const *input,char **errstr,int *errloc)\n{\n  struct commtype comm;\n  int saveunitcount;\n\n  saveunitcount = unitcount;\n  initializeunit(output);\n  comm.result = 0;\n  comm.location = 0;\n  comm.data = input;\n  comm.errorcode = E_PARSE;    /* Assume parse error */\n  errno=0;\n  if (yyparse(&comm) || errno){\n    if (comm.location==-1) \n      comm.location = strlen(input);\n    if (errstr){\n      if (comm.errorcode==E_FUNC || errno)\n        *errstr = strerror(errno);\n      else\n        *errstr=errormsg[comm.errorcode];\n    }\n    if (errloc)\n      *errloc = comm.location;\n    if (unitcount!=saveunitcount)\n      fprintf(stderr,\"units: Parser leaked memory with error: %d in %d out\\n\",\n             saveunitcount, unitcount);\n    return comm.errorcode;\n  } else {\n    if (errstr)\n      *errstr = 0;\n    multunit(output,comm.result);\n    destroyunit(comm.result);\n    if (unitcount!=saveunitcount)\n      fprintf(stderr,\"units: Parser leaked memory without error: %d in %d out\\n\",\n\t      saveunitcount, unitcount);\n    return 0;\n  }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "units/units-2.16/strfunc.c": {
    "strpbrk": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "char *\nstrpbrk(char *s, char *accept)\n{\n  while (*s != '\\0')\n    if (strchr(accept, *s) == NULL)\n      ++s;\n    else\n      return (char *) s;\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "char",
        "*\nstrpbrk(char *s, char *accept)",
        "*"
      ]
    },
    "strtok": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "char *\nstrtok(char *s, char *delim)\n{\n  char *token;\n\n  if (s == NULL)\n    {\n      if (olds == NULL)\n\t{\n\t  /*errno = EINVAL;  Wonder where errno is defined....*/\n\t  return NULL;\n\t}\n      else\n\ts = olds;\n    }\n\n  /* Scan leading delimiters.  */\n  s += strspn(s, delim);\n  if (*s == '\\0')\n    {\n      olds = NULL;\n      return NULL;\n    }\n\n  /* Find the end of the token.  */\n  token = s;\n  s = strpbrk(token, delim);\n  if (s == NULL)\n    /* This token finishes the string.  */\n    olds = NULL;\n  else\n    {\n      /* Terminate the token and make OLDS point past it.  */\n      *s = '\\0';\n      olds = s + 1;\n    }\n  return token;\n}",
      "lines": 38,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrtok(char *s, char *delim)",
        "*"
      ]
    },
    "strspn": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "size_t\nstrspn(char *s, char *accept)\n{\n  register char *p;\n  register char *a;\n  register size_t count = 0;\n\n  for (p = s; *p != '\\0'; ++p)\n    {\n      for (a = accept; *a != '\\0'; ++a)\n\tif (*p == *a)\n\t  break;\n      if (*a == '\\0')\n\treturn count;\n      else\n\t++count;\n    }\n\n  return count;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "units/units-2.16/units.c": {
    "save_history": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "void\nsave_history(void)\n{\n  int newentries;\n  int err;\n\n  newentries = history_length-init_history_length;\n  if (history_max_entries > 0){\n    newentries += history_base - init_history_base;\n    if (newentries > history_max_entries)\n      newentries = history_max_entries;\n  }\n  \n  err = append_history(newentries,historyfile);\n  if (err){\n    if (err == ENOENT)\n      err = write_history(historyfile);\n    if (err) {\n      printf(\"Unable to write history to '%s': %s\\n\",historyfile,strerror(err));\n      return;\n    }\n  } \n  history_truncate_file(historyfile,MAXHISTORYFILE);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "growbuffer": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "void\ngrowbuffer(char **buf, int *bufsize)\n{\n  int usemalloc;\n\n  usemalloc = !*buf || !*bufsize;\n  *bufsize += BUFGROW;\n  if (usemalloc)\n    *buf = malloc(*bufsize);\n  else\n    *buf = realloc(*buf,*bufsize);\n  if (!*buf){\n    fprintf(stderr, \"%s: memory allocation error (growbuffer)\\n\",progname);  \n    exit(EXIT_FAILURE); \n  }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hassubscript": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "int\nhassubscript(const char *str)\n{\n  const char *ptr = &lastchar(str);\n  while (ptr>str){\n    if (!strchr(digits, *ptr))\n      return 0;\n    ptr--;\n    if (*ptr=='_')\n      return 1;\n  }\n  return 0;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "replace_minus": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "void\nreplace_minus(char *input)\n{\n  char *unicode_minus[] = {\n    \"\\xE2\\x80\\x92\", /* U+2012: figure dash */\n    \"\\xE2\\x80\\x93\", /* U+2013: en dash */\n    \"\\xE2\\x88\\x92\",  /* U+2212: minus */\n    0\n  };\n  char *inptr, *outptr, *ptr, **minus;\n\n  for (minus=unicode_minus; *minus; minus++) {\n    inptr = outptr = input;\n    do {\n      ptr = strstr(inptr, *minus);  /* find next unicode minus */\n      if (ptr) {\n        while (inptr < ptr)   /* copy the input up to the minus symbol */\n          *outptr++ = *inptr++;\n        *outptr++ = '-';        /* U+002D: hyphen-minus */\n        inptr = ptr + strlen(*minus);\n      }\n    } while (ptr);\n    /* if no replacements were made, the input isn't changed */\n    if (inptr > input) {\n      while (*inptr)\n        *outptr++ = *inptr++;\n      *outptr = '\\0';\n    }\n  }\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "replacectrlchars": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "void\nreplacectrlchars(char *string)\n{\n  for(;*string;string++)\n    if (iscntrl(*string))\n      *string = ' ';\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fgetscont": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "char *\nfgetscont(char *buf, int size, FILE *file, int *count)\n{\n  if (!fgets(buf,size,file))\n    return 0;\n  (*count)++;\n  while(strlen(buf)>=2 && 0==strcmp(buf+strlen(buf)-2,\"\\\\\\n\")){\n    (*count)++;\n    buf[strlen(buf)-2] = 0; /* delete trailing \\n and \\ char */\n    if (strlen(buf)>=size-1) /* return if the buffer is full */\n      return buf;\n    if (!fgets(buf+strlen(buf), size - strlen(buf), file))\n      return buf;  /* already read some data so return success */\n  }\n  if (lastchar(buf) == '\\\\') {   /* If last char of buffer is \\ then   */\n    ungetc('\\\\', file);           /* we don't know if it is followed by */\n    lastchar(buf) = 0;           /* a \\n, so put it back and try again */\n  }\n  return buf;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "char",
        "*\nfgetscont(char *buf, int size, FILE *file, int *count)",
        "*"
      ]
    },
    "fgetslong": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "char *\nfgetslong(char **buf, int *bufsize, FILE *file, int *count)\n{\n  int dummy;\n  if (!count)\n    count = &dummy;\n  if (!*bufsize) growbuffer(buf,bufsize);\n  if (!fgetscont(*buf, *bufsize, file, count))\n    return 0;\n  while (lastchar(*buf) != '\\n' && !feof(file)){\n    growbuffer(buf, bufsize);\n    fgetscont(*buf+strlen(*buf), *bufsize-strlen(*buf), file, count);\n    (*count)--;\n  }  \n  /* These nonprinting characters must be removed so that the test\n     for UTF-8 validity will work. */ \n  replacectrlchars(*buf);\n  return *buf;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "char",
        "*\nfgetslong(char **buf, int *bufsize, FILE *file, int *count)",
        "*"
      ]
    },
    "mymalloc": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "void *\nmymalloc(int bytes,const char *mesg)\n{\n   void *pointer;\n\n   pointer = malloc(bytes);\n   if (!pointer){\n     fprintf(stderr, \"%s: memory allocation error %s\\n\", progname, mesg);\n     exit(EXIT_FAILURE);\n   }\n   return pointer;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "*\nmymalloc(int bytes,const char *mesg)",
        "*"
      ]
    },
    "dupstr": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "char *\ndupstr(const char *str)\n{\n   char *ret;\n\n   ret = mymalloc(strlen(str) + 1,\"(dupstr)\");\n   strcpy(ret, str);\n   return ret;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\ndupstr(const char *str)",
        "*"
      ]
    },
    "dupnstr": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "char *\ndupnstr(const char *string, int length)\n{  \n  char *newstr;\n  newstr = mymalloc(length+1,\"(dupnstr)\");\n  strncpy(newstr, string, length);\n  newstr[length]=0;\n  return newstr;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\ndupnstr(const char *string, int length)",
        "*"
      ]
    },
    "strwidth": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "int \nstrwidth(const char *str)\n{\n  wchar_t *widestr;\n  int len;\n\n  if (!utf8mode)\n    return strlen(str);\n  len = strlen(str)+1;\n  widestr = mymalloc(sizeof(wchar_t)*len, \"(strwidth)\");\n  len = mbsrtowcs(widestr, &str, len, NULL);\n\n  if (len==-1){\n    free(widestr);\n    return -1; /* invalid multibyte sequence */\n  }\n\n  len=wcswidth(widestr, len);\n  free(widestr);\n  return len;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "uhash": {
      "start_point": [
        570,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "unsigned\nuhash(const char *str)\n{\n   unsigned hashval;\n\n   for (hashval = 0; *str; str++)\n      hashval = *str + HASHNUMBER * hashval;\n   return (hashval % HASHSIZE);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "ulookup": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "struct unitlist *\nulookup(const char *str)\n{\n   struct unitlist *uptr;\n\n   for (uptr = utab[uhash(str)]; uptr; uptr = uptr->next)\n      if (strcmp(str, uptr->name) == 0)\n         return uptr;\n   return NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct unitlist",
        "struct",
        "unitlist",
        "*\nulookup(const char *str)",
        "*"
      ]
    },
    "plookup": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "struct prefixlist *\nplookup(const char *str)\n{\n   struct prefixlist *prefix;\n   struct prefixlist *bestprefix=NULL;\n   int bestlength=0;\n\n   for (prefix = ptab[simplehash(str)]; prefix; prefix = prefix->next) {\n     if (prefix->len > bestlength && !strncmp(str, prefix->name, prefix->len)){\n       bestlength = prefix->len;\n       bestprefix = prefix;\n     }\n   }\n   return bestprefix;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "struct prefixlist",
        "struct",
        "prefixlist",
        "*\nplookup(const char *str)",
        "*"
      ]
    },
    "fnlookup": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "struct func *\nfnlookup(const char *str)\n{ \n  struct func *funcptr;\n\n  for(funcptr=ftab[simplehash(str)];funcptr;funcptr = funcptr->next)\n    if (!strcmp(funcptr->name, str))\n      return funcptr;\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct func",
        "struct",
        "func",
        "*\nfnlookup(const char *str)",
        "*"
      ]
    },
    "aliaslookup": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "struct wantalias *\naliaslookup(const char *str)\n{\n  struct wantalias *aliasptr;\n  for(aliasptr = firstalias; aliasptr; aliasptr=aliasptr->next)\n    if (!strcmp(aliasptr->name, str))\n      return aliasptr;\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "struct wantalias",
        "struct",
        "wantalias",
        "*\naliaslookup(const char *str)",
        "*"
      ]
    },
    "addfunction": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "void\naddfunction(struct func *newfunc)\n{\n  int val;\n\n  val = simplehash(newfunc->name);\n  newfunc->next = ftab[val];\n  ftab[val] = newfunc;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "freefunction": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "void\nfreefunction(struct func *funcentry)\n{\n  if (funcentry->table){\n    free(funcentry->table);\n    free(funcentry->tableunit);\n  } else {\n    free(funcentry->forward.param);\n    free(funcentry->forward.def);\n    if (funcentry->forward.domain_min) free(funcentry->forward.domain_min);\n    if (funcentry->forward.domain_max) free(funcentry->forward.domain_max);\n    if (funcentry->inverse.domain_min) free(funcentry->inverse.domain_min);\n    if (funcentry->inverse.domain_max) free(funcentry->inverse.domain_max);\n    if (funcentry->forward.dimen) free(funcentry->forward.dimen);\n    if (funcentry->inverse.dimen) free(funcentry->inverse.dimen);\n    if (funcentry->inverse.def) free(funcentry->inverse.def);    \n    if (funcentry->inverse.param) free(funcentry->inverse.param);\n  }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "removespaces": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "void\nremovespaces(char *in)\n{\n  char *ptr;\n  if (*in) {\n    for(ptr = &lastchar(in); *ptr==' '; ptr--); /* Last non-space */\n    *(ptr+1)=0;\n    if (*in==' '){\n      ptr = in + strspn(in,\" \");\n      memmove(in, ptr, strlen(ptr)+1);\n    }\n  }\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "invfnlookup": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        705,
        1
      ],
      "content": "struct func *\ninvfnlookup(char *str)\n{\n  if (*str != '~')\n    return 0;\n  removespaces(str+1);\n  return fnlookup(str+1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "struct func",
        "struct",
        "func",
        "*\ninvfnlookup(char *str)",
        "*"
      ]
    },
    "strip_comment": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "char *\nstrip_comment(char *line)\n{\n  char *comment = 0;\n  \n  if ((line = strchr(line,COMMENTCHAR))) {\n    comment = line+1;\n    *line = 0;\n  }\n  return comment;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstrip_comment(char *line)",
        "*"
      ]
    },
    "tightprint": {
      "start_point": [
        723,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "void\ntightprint(FILE *outfile, char *string)\n{\n  while(*string){\n    fputc(*string, outfile);\n    if (*string != ' ') string++;\n    else while(*string==' ') string++;\n  }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "splitline": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "void\nsplitline(char *line, char **first, char **second)\n{\n  *second = 0;\n  *first = strtok(line, \" \");\n  if (*first){\n    *second = strtok(0, \"\\n\");\n    if (*second){\n      removespaces(*second);\n      if (emptystr(*second))\n        *second = 0;\n    }\n  }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "isdecimal": {
      "start_point": [
        766,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "int\nisdecimal(char c)\n{\n  return strchr(digits, c) != NULL;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "checkunitname": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        796,
        1
      ],
      "content": "int\ncheckunitname(char *name, int linenum, char *file, FILE *errfile)\n{\n  char **ptr;\n\n  if (strchr(digits, name[0])){\n    if (errfile) fprintf(errfile,\n         \"%s: unit '%s' in units file '%s' on line %d ignored.  It starts with a digit\\n\", \n              progname, name, file, linenum);\n    return 1;\n  }\n  for(ptr=builtins;*ptr;ptr++)\n    if (!strcmp(name, *ptr)){\n      if (errfile) fprintf(errfile,\n           \"%s: redefinition of built-in function '%s' in file '%s' on line %d ignored.\\n\",\n                           progname, name, file, linenum);\n      return 1;\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "newunit": {
      "start_point": [
        799,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "int\nnewunit(char *unitname, char *unitdef, int *count, int linenum, \n        char *file,FILE *errfile)\n{\n  struct unitlist *uptr;\n  unsigned hashval; \n\n  /* units ending with '_' create ambiguity for exponents */\n\n  if (unitname[0]=='_' || lastchar(unitname)=='_'){\n    if (errfile) fprintf(errfile,\n       \"%s: unit '%s' on line %d of '%s' ignored.  It starts or ends with '_'\\n\",\n              progname, unitname, linenum, file);\n    return E_BADFILE;\n  }\n\n  /* Units that end in [2-9] can never be accessed */\n  if (strchr(\".,23456789\", lastchar(unitname)) && !hassubscript(unitname)){\n    if (errfile) fprintf(errfile,\n       \"%s: unit '%s' on line %d of '%s' ignored.  %s\\n\",\n        progname, unitname, linenum, file,errormsg[E_UNITEND]);\n    return E_BADFILE;\n  }\n\n  if (checkunitname(unitname, linenum, file, errfile))\n    return E_BADFILE;\n\n  if ((uptr=ulookup(unitname))) {    /* Is it a redefinition? */\n    if (flags.unitcheck && errfile)\n      fprintf(errfile,\n      \"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n              progname, unitname, uptr->linenumber,uptr->file,\n              linenum, file);\n    free(uptr->value);\n  } else {       \n    /* make new units table entry */\n\n    uptr = (struct unitlist *) mymalloc(sizeof(*uptr),\"(newunit)\");\n    uptr->name = dupstr(unitname);\n\n    /* install unit name/value pair in list */\n\n    hashval = uhash(uptr->name);\n    uptr->next = utab[hashval];\n    utab[hashval] = uptr;\n    (*count)++;\n  }\n  uptr->value = dupstr(unitdef);\n  uptr->linenumber = linenum;\n  uptr->file = file;\n  return 0;\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "newprefix": {
      "start_point": [
        853,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "int \nnewprefix(char *unitname, char *unitdef, int *count, int linenum, \n          char *file,FILE *errfile)\n{\n  struct prefixlist *pfxptr;\n  unsigned pval;\n\n  lastchar(unitname) = 0;\n  if (checkunitname(unitname,linenum,file,errfile))\n    return E_BADFILE;\n  if ((pfxptr = plookup(unitname))     /* already there: redefinition */\n      && !strcmp(pfxptr->name, unitname)){\n    if (flags.unitcheck && errfile)\n      fprintf(errfile,\n             \"%s: prefix '%s-' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n              progname, unitname, pfxptr->linenumber,pfxptr->file,\n              linenum, file);\n    free(pfxptr->value);\n  } else {  \n    pfxptr = (struct prefixlist *) mymalloc(sizeof(*pfxptr),\"(newprefix)\");  \n    pfxptr->name = dupstr(unitname);\n    pfxptr->len = strlen(unitname);\n    pval = simplehash(unitname);\n    pfxptr->next = ptab[pval];\n    ptab[pval] = pfxptr;\n    (*count)++;\n  }\n  pfxptr->value = dupstr(unitdef);\n  pfxptr->linenumber = linenum;\n  pfxptr->file = file;\n  return 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "parsepair": {
      "start_point": [
        895,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "char *\nparsepair(char *input, char **first, char **second, \n          int *firstopen, int *secondopen, char delimiter, int checkopen,\n          char *unitname, int linenum, char *file,FILE *errfile)\n{\n  char *start, *end, *middle;\n\n  start = strpbrk(input, checkopen?\"[(\":\"[\");\n  if (!start){\n    if (errfile) fprintf(errfile,\n             \"%s: expecting '[' %s in definition of '%s' in '%s' line %d\\n\",\n             progname, checkopen ? \"or '('\":\"\", unitname, file, linenum);\n    return 0;\n  }\n  if (*start=='(') *firstopen=1;\n  else *firstopen=0;\n  *start++=0;\n  removespaces(input);\n  if (!emptystr(input)){\n    if (errfile) fprintf(errfile,\n        \"%s: unexpected characters before '%c' in definition of '%s' in '%s' line %d\\n\",\n        progname, *firstopen?'(':'[',unitname, file, linenum);\n    return 0;\n  }\n  end = strpbrk(start, checkopen?\"])\":\"]\");\n  if (!end){\n    if (errfile) fprintf(errfile,\n             \"%s: expecting ']' %s in definition of '%s' in '%s' line %d\\n\",\n             progname, checkopen?\"or ')'\":\"\",unitname, file, linenum);\n    return 0;\n  }\n  if (*end==')') *secondopen=1;\n  else *secondopen=0;\n  *end++=0;\n\n  middle = strchr(start,delimiter);\n  \n  if (middle){\n    *middle++=0;\n    removespaces(middle);\n    *second = middle;\n  } else\n    *second = 0;\n\n  removespaces(start);\n  *first = start;\n  return end;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "char",
        "*\nparsepair(char *input, char **first, char **second, \n          int *firstopen, int *secondopen, char delimiter, int checkopen,\n          char *unitname, int linenum, char *file,FILE *errfile)",
        "*"
      ]
    },
    "extract_interval": {
      "start_point": [
        954,
        0
      ],
      "end_point": [
        982,
        1
      ],
      "content": "int\nextract_interval(char *first, char *second, \n                 double **firstout, double **secondout)\n{\n  double val;\n  char *end;\n\n  if (!emptystr(first)){\n    val = strtod(first, &end);\n    if (*end)\n      return EI_ERR_MALF;\n    else {\n      *firstout=(double *)mymalloc(sizeof(double), \"(extract_interval)\");\n      **firstout = val;\n    }\n  }\n  if (second && !emptystr(second)){\n    val = strtod(second, &end);\n    if (*end)\n      return EI_ERR_MALF;\n    else if (*firstout && **firstout>=val)\n      return EI_ERR_DEC;\n    else {\n      *secondout=(double *)mymalloc(sizeof(double), \"(extract_interval)\");\n      **secondout = val;\n    }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "copyfunctype": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1004,
        1
      ],
      "content": "void \ncopyfunctype(struct functype *dest, struct functype *src)\n{\n  dest->domain_min_open = src->domain_min_open;\n  dest->domain_max_open = src->domain_max_open;\n  dest->param = dest->def = dest->dimen = NULL;\n  dest->domain_min = dest->domain_max = NULL;\n  if (src->param) dest->param = dupstr(src->param); \n  if (src->def) dest->def = dupstr(src->def);\n  if (src->dimen) dest->dimen = dupstr(src->dimen);\n  if (src->domain_min){\n    dest->domain_min = (double *) mymalloc(sizeof(double), \"(copyfunctype)\");\n    *dest->domain_min = *src->domain_min;\n  }\n  if (src->domain_max){\n    dest->domain_max = (double *) mymalloc(sizeof(double), \"(copyfunctype)\");\n    *dest->domain_max = *src->domain_max;\n  }\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "copyfunction": {
      "start_point": [
        1007,
        0
      ],
      "end_point": [
        1062,
        1
      ],
      "content": "int\ncopyfunction(char *unitname, char *funcname, int *count, int linenum, \n             char *file, FILE *errfile)\n{\n  struct func *source, *funcentry;\n  int i;\n  if (checkunitname(unitname, linenum, file, errfile))\n    return E_BADFILE;\n  removespaces(funcname);\n  i = strlen(funcname)-2;                /* strip trailing () if present */\n  if (i>0 && !strcmp(funcname+i,\"()\"))  \n    funcname[i]=0;\n  source = fnlookup(funcname);\n  if (!source) {\n    if (errfile){ \n      if (!strpbrk(funcname,\" ;][()+*/-^\")) \n        fprintf(errfile,\"%s: bad definition for '%s' in '%s' line %d, function '%s' not defined\\n\",\n                progname, unitname, file, linenum, funcname);\n      else\n        fprintf(errfile,\"%s: bad function definition of '%s' in '%s' line %d\\n\",\n                progname,unitname,file,linenum);\n    }\n    return E_BADFILE;\n  }\n  if ((funcentry=fnlookup(unitname))){\n    if (flags.unitcheck && errfile)          \n      fprintf(errfile,\n             \"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n              progname, unitname, funcentry->linenumber,funcentry->file,\n              linenum, file);\n    freefunction(funcentry);\n  } else {\n    funcentry = (struct func*)mymalloc(sizeof(struct func),\"(newfunction)\");    \n    funcentry->name = dupstr(unitname);\n    addfunction(funcentry);\n    (*count)++;\n  }\n  funcentry->linenumber = linenum;\n  funcentry->file = file;\n  funcentry->skip_error_check = source->skip_error_check;\n  if (source->table){\n    funcentry->tablelen = source->tablelen;\n    funcentry->tableunit = dupstr(source->tableunit);\n    funcentry->table = (struct pair *)\n        mymalloc(sizeof(struct pair)*funcentry->tablelen, \"(copyfunction)\");\n    for(i=0;i<funcentry->tablelen;i++){\n      funcentry->table[i].location = source->table[i].location;\n      funcentry->table[i].value = source->table[i].value;\n    }\n  } else {\n    funcentry->table = 0;\n      copyfunctype(&funcentry->forward, &source->forward);\n      copyfunctype(&funcentry->inverse, &source->inverse);\n  }\n  return 0;\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "newfunction": {
      "start_point": [
        1077,
        0
      ],
      "end_point": [
        1280,
        1
      ],
      "content": "int\nnewfunction(char *unitname, char *unitdef, int *count, \n            int linenum, char *file,FILE *errfile)\n{\n  char *start, *end, *inv, *forward_dim, *inverse_dim, *first, *second;\n  double *domain_min, *domain_max, *range_min, *range_max;\n  struct func *funcentry;\n  int looking_for_keywords,i, firstopen, secondopen;\n  int domain_min_open, domain_max_open, range_min_open, range_max_open;\n  int noerror = 0;\n\n  if (*unitname=='('){\n    if (errfile) fprintf(errfile,\n         \"%s: unit '%s' on line %d of '%s' ignored.  It starts with a '('\\n\", \n         progname, unitname, linenum, file);\n    return E_BADFILE;\n  }\n                                   /* coverity[returned_null] */\n  start = strchr(unitname,'(');\n  end = strchr(unitname,')');\n  *start++ = 0;\n    \n  if (checkunitname(unitname,linenum,file,errfile))\n    return E_BADFILE;\n  \n  if (start==end)  /* no argument: function() so make a function copy */\n    return copyfunction(unitname, unitdef, count, linenum, file, errfile);\n\n  if (!end || strlen(end)>1){\n    if (errfile) fprintf(errfile,\n              \"%s: bad function definition of '%s' in '%s' line %d\\n\",\n              progname,unitname,file,linenum);\n    return E_BADFILE;\n  }\n  *end=0;\n  forward_dim = NULL;\n  inverse_dim = NULL;\n  domain_min = NULL;\n  domain_max = NULL;\n  range_min = NULL;\n  range_max = NULL;\n  domain_min_open = 0;\n  domain_max_open = 0;\n  range_min_open = 0;\n  range_max_open = 0;\n  looking_for_keywords=1;\n  while (looking_for_keywords) {\n    looking_for_keywords = 0;\n    for(i=0;fnkeywords[i].word;i++){\n      if (startswith(unitdef, fnkeywords[i].word)){\n        looking_for_keywords = 1;  /* found keyword so keep looking */\n        unitdef+=strlen(fnkeywords[i].word);\n        if (fnkeywords[i].checkopen!=CO_NOARG){\n          unitdef = parsepair(unitdef,&first, &second, &firstopen, &secondopen, \n                            fnkeywords[i].delimit, fnkeywords[i].checkopen,\n                            unitname, linenum, file,errfile);\n          if (!unitdef){\n            FREE_STUFF;\n            return E_BADFILE;\n          }\n          removespaces(unitdef);\n        }\n        if (i==FN_NOERROR)\n          noerror = 1;\n        if (i==FN_UNITS){\n          if (forward_dim || inverse_dim){\n            REPEAT_ERR;\n            return E_BADFILE;\n          }\n          forward_dim = dupstr(first);\n          if (second)\n            inverse_dim = dupstr(second);\n        }\n        if (i==FN_DOMAIN){\n          int err=0;\n          if (domain_min || domain_max){\n            REPEAT_ERR;\n            return E_BADFILE;\n          }\n          err = extract_interval(first,second,&domain_min, &domain_max);\n          domain_min_open = firstopen;\n          domain_max_open = secondopen;\n          if (err)\n            FREE_STUFF;\n          if (err==EI_ERR_DEC){\n            if (errfile) fprintf(errfile,\n               \"%s: second endpoint for domain must be greater than the first\\n       in definition of '%s' in '%s' line %d\\n\",\n                progname, unitname, file, linenum);\n            return E_BADFILE;\n          }\n          if (err==EI_ERR_MALF){\n            if (errfile) fprintf(errfile,\n              \"%s: malformed domain in definition of '%s' in '%s' line %d\\n\",\n              progname, unitname, file, linenum);\n            return E_BADFILE;\n          }\n        } \n        if (i==FN_RANGE){\n          int err=0;\n          if (range_min || range_max){\n            REPEAT_ERR;\n            FREE_STUFF;\n            return E_BADFILE;\n          }\n          err = extract_interval(first,second,&range_min, &range_max);\n          range_min_open = firstopen;\n          range_max_open = secondopen;\n          if (err)\n            FREE_STUFF;\n          if (err==EI_ERR_DEC){\n            if (errfile) fprintf(errfile,\n               \"%s: second endpoint for range must be greater than the first\\n       in definition of '%s' in '%s' line %d\\n\",\n                progname, unitname, file, linenum);\n            return E_BADFILE;\n          }\n          if (err==EI_ERR_MALF){\n            if (errfile) fprintf(errfile,\n              \"%s: malformed range in definition of '%s' in '%s' line %d\\n\",\n              progname, unitname, file, linenum);\n            return E_BADFILE;\n          }\n        }\n      }\n    }\n  }\n\n  if (emptystr(unitdef)){\n    if (errfile) fprintf(errfile,\n                 \"%s: function '%s' lacks a definition at line %d of '%s'\\n\",\n                 progname, unitname, linenum, file);\n    FREE_STUFF;\n    return E_BADFILE;\n  }\n\n  if (*unitdef=='['){\n    if (errfile) fprintf(errfile,\n         \"%s: function '%s' missing keyword before '[' on line %d of '%s'\\n\", \n         progname, unitname, linenum, file);\n    FREE_STUFF;\n    return E_BADFILE;\n  }\n\n  /* Check that if domain and range are specified and nonzero then the \n     units are given.  Otherwise these are meaningless.  */\n  if (!forward_dim &&\n      ((domain_min && *domain_min) || (domain_max && *domain_max))){ \n    if (errfile)\n      fprintf(errfile,\"%s: function '%s' defined on line %d of '%s' has domain with no units.\\n\", \n              progname, unitname, linenum, file);\n    FREE_STUFF;\n    return E_BADFILE;\n  }\n  if (!inverse_dim &&\n      ((range_min && *range_min) || (range_max && *range_max))){ \n    if (errfile)\n      fprintf(errfile,\"%s: function '%s' defined on line %d of '%s' has range with no units.\\n\", \n              progname, unitname, linenum, file);\n    FREE_STUFF;\n    return E_BADFILE;\n  }\n  if ((funcentry=fnlookup(unitname))){\n    if (flags.unitcheck && errfile)          \n      fprintf(errfile,\n             \"%s: function '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n              progname, unitname, funcentry->linenumber,funcentry->file,\n              linenum, file);\n    freefunction(funcentry);\n  } else {\n    funcentry = (struct func*)mymalloc(sizeof(struct func),\"(newfunction)\");    \n    funcentry->name = dupstr(unitname);\n    addfunction(funcentry);\n    (*count)++;\n  }\n  funcentry->table = 0;\n  funcentry->skip_error_check = noerror;\n  funcentry->forward.dimen = forward_dim;\n  funcentry->inverse.dimen = inverse_dim;\n  funcentry->forward.domain_min = domain_min;\n  funcentry->forward.domain_max = domain_max;\n  funcentry->inverse.domain_min = range_min;\n  funcentry->inverse.domain_max = range_max;\n  funcentry->forward.domain_min_open = domain_min_open;\n  funcentry->forward.domain_max_open = domain_max_open;\n  funcentry->inverse.domain_min_open = range_min_open;\n  funcentry->inverse.domain_max_open = range_max_open;\n  inv = strchr(unitdef,FUNCSEPCHAR);\n  if (inv)\n    *inv++ = 0;\n  funcentry->forward.param = dupstr(start);\n  removespaces(unitdef);\n  funcentry->forward.def = dupstr(unitdef);\n  if (inv){\n    removespaces(inv);\n    funcentry->inverse.def = dupstr(inv);\n    funcentry->inverse.param = dupstr(unitname);\n  } \n  else {\n    funcentry->inverse.def = 0;\n    funcentry->inverse.param = 0;\n  }\n  funcentry->linenumber = linenum;\n  funcentry->file = file;\n  return 0;\n}",
      "lines": 204,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "newtable": {
      "start_point": [
        1283,
        0
      ],
      "end_point": [
        1383,
        1
      ],
      "content": "int \nnewtable(char *unitname,char *unitdef, int *count,\n           int linenum, char *file,FILE *errfile)\n{\n  char *start, *end;\n  char *tableunit;\n  int tablealloc, tabpt;\n  struct pair *tab;\n  struct func *funcentry;\n  int noerror = 0;\n\n                                      /* coverity[returned_null] */\n  tableunit = strchr(unitname,'[');\n  end = strchr(unitname,']');\n  *tableunit++=0;\n  if (checkunitname(unitname, linenum, file, errfile))\n    return E_BADFILE;\n  if (!end){\n    if (errfile) fprintf(errfile,\"%s: missing ']' in units file '%s' line %d\\n\",\n              progname,file,linenum);\n    return E_BADFILE;\n  } \n  if (strlen(end)>1){\n    if (errfile) fprintf(errfile,\n              \"%s: unexpected characters after ']' in units file '%s' line %d\\n\",\n              progname,file,linenum);\n    return E_BADFILE;\n  }\n  *end=0;\n  tab = (struct pair *)mymalloc(sizeof(struct pair)*20, \"(newtable)\");\n  tablealloc=20;\n  tabpt = 0;\n  start = unitdef;\n  if (startswith(start, NOERROR_KEYWORD)) {\n    noerror = 1;\n    start += strlen(NOERROR_KEYWORD);\n    removespaces(start);\n  }\n  while (1) {\n    if (tabpt>=tablealloc){\n      tablealloc+=20;\n      tab = (struct pair *)realloc(tab,sizeof(struct pair)*tablealloc);\n      if (!tab){\n        if (errfile) fprintf(errfile, \"%s: memory allocation error (newtable)\\n\",\n                  progname);  \n        return E_MEMORY;\n      }\n    }\n    tab[tabpt].location = strtod(start,&end);\n    if (start==end || (!emptystr(end) && *end !=' ')){ \n      if (!emptystr(start)) {  \n        if (strlen(start)>15) start[15]=0;  /* Truncate for error msg display */\n        if (errfile) fprintf(errfile, \n             \"%s: cannot parse table definition %s at '%s' on line %d of '%s'\\n\", \n             progname, unitname, start, linenum, file);\n        free(tab);\n        return E_BADFILE;\n      }\n      break;\n    }\n    if (tabpt>0 && tab[tabpt].location<=tab[tabpt-1].location){\n      if (errfile)\n        fprintf(errfile,\"%s: points don't increase (%.8g to %.8g) in units file '%s' line %d\\n\",\n                progname, tab[tabpt-1].location, tab[tabpt].location,\n                file, linenum);\n      free(tab);\n      return E_BADFILE;\n    }\n    start=end+strspn(end,\" \");\n    tab[tabpt].value = strtod(start,&end);\n    if (start==end){\n      if (errfile)\n        fprintf(errfile,\"%s: missing value after %.8g in units file '%s' line %d\\n\",\n                progname, tab[tabpt].location, file, linenum);\n      free(tab);\n      return E_BADFILE;\n    }\n    tabpt++;\n    start=end+strspn(end,\" ,\");\n  }\n  if ((funcentry=fnlookup(unitname))){\n    if (flags.unitcheck && errfile)\n      fprintf(errfile,\n      \"%s: unit '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n                    progname, unitname, funcentry->linenumber,funcentry->file,\n                                         linenum, file);\n    freefunction(funcentry);\n  } else {\n    funcentry = (struct func *)mymalloc(sizeof(struct func),\"(newtable)\");\n    funcentry->name = dupstr(unitname);\n    addfunction(funcentry);\n    (*count)++;\n  }\n  funcentry->tableunit = dupstr(tableunit);\n  funcentry->tablelen = tabpt;\n  funcentry->table = tab;\n  funcentry->skip_error_check = noerror;\n  funcentry->linenumber = linenum;\n  funcentry->file = file;\n  return 0;\n}",
      "lines": 101,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "newalias": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "int\nnewalias(char *unitname, char *unitdef,int linenum, char *file,FILE *errfile)\n{\n  struct wantalias *aliasentry;\n\n  if (!strchr(unitdef, UNITSEPCHAR)){\n    if (errfile) fprintf(errfile,\n            \"%s: unit list missing '%c' on line %d of '%s'\\n\",\n            progname, UNITSEPCHAR, linenum, file);\n    return E_BADFILE;\n  }\n  if ((aliasentry=aliaslookup(unitname))){   /* duplicate alias */\n    if (flags.unitcheck && errfile)\n      fprintf(errfile,\n              \"%s: unit list '%s' defined on line %d of '%s' is redefined on line %d of '%s'.\\n\",\n              progname, unitname, aliasentry->linenumber,\n              aliasentry->file, linenum, file);\n    free(aliasentry->definition);\n  } else { \n    aliasentry = (struct wantalias *)\n      mymalloc(sizeof(struct wantalias),\"(newalias)\");\n    aliasentry->name = dupstr(unitname);\n    aliasentry->next = 0;\n    *aliaslistend = aliasentry;\n    aliaslistend = &aliasentry->next;\n  }\n  aliasentry->definition = dupstr(unitdef);\n  aliasentry->linenumber = linenum;\n  aliasentry->file = file;\n  return 0;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "checkvar": {
      "start_point": [
        1426,
        0
      ],
      "end_point": [
        1440,
        1
      ],
      "content": "int\ncheckvar(char *name, char *list)\n{\n  char *listitem;\n  name = getenv(name);\n  if (!name)\n    return 2;\n  listitem = strtok(list,\" \");\n  while (listitem){\n    if (!strcmp(name, listitem))\n      return 1;\n    listitem = strtok(0,\" \");\n  }\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1465,
        1
      ],
      "content": "int\nsetenv(const char *name, const char *val, int overwrite)\n{\n  char *environment;\n\n  if (!overwrite && getenv(name) != NULL)\n    return 0;\n  environment = (char *) malloc(strlen(name) + strlen(val) + 2);\n  if (!environment)\n    return 1;\n  strcpy(environment, name);\n  strcat(environment, \"=\");\n  strcat(environment, val);\n\n  /* putenv() doesn't copy its argument, so don't free environment */\n\n#if defined (_WIN32) && defined (_MSC_VER)\n  return _putenv(environment);\n#else\n  return putenv(environment);\n#endif\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "pathend": {
      "start_point": [
        1481,
        0
      ],
      "end_point": [
        1493,
        1
      ],
      "content": "char *\npathend(char *filename)\n{\n  char *pointer;\n\n  for(pointer=filename+strlen(filename);pointer>filename;pointer--){\n    if (isdirsep(*pointer)) {\n      pointer++;\n      break;\n    }\n  }\n  return pointer;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "char",
        "*\npathend(char *filename)",
        "*"
      ]
    },
    "isfullpath": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1504,
        1
      ],
      "content": "int\nisfullpath(char *path)\n{\n#ifdef _WIN32\n  /* handle Windows drive specifier */\n  if (isalpha(*path) && *(path + 1) == ':')\n      path += 2;\n#endif\n  return isdirsep(*path);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "readunits": {
      "start_point": [
        1519,
        0
      ],
      "end_point": [
        1786,
        1
      ],
      "content": "int\nreadunits(char *file, FILE *errfile, \n          int *unitcount, int *prefixcount, int *funccount, int depth)\n{\n   FILE *unitfile;\n   char *line = 0, *lineptr, *unitdef, *unitname, *permfile;\n   int len, linenum, linebufsize, goterr, retcode;\n   int locunitcount, locprefixcount, locfunccount;\n   int wronglocale = 0;   /* If set then we are currently reading data */\n   int inlocale = 0;      /* for the wrong locale so we should skip it */\n   int in_utf8 = 0;       /* If set we are reading utf8 data */\n   int invar = 0;         /* If set we are in data for an env variable.*/\n   int wrongvar = 0;      /* If set then we are not processing */\n\n   locunitcount = 0;\n   locprefixcount = 0;\n   locfunccount  = 0;\n   linenum = 0;\n   linebufsize = 0;\n   goterr = 0;\n\n\n   unitfile = fopen(file, \"rt\");\n   if (!unitfile) \n     return E_FILE;\n\n   growbuffer(&line,&linebufsize);\n                                            /* coverity[alloc_fn] */\n   permfile = dupstr(file);    /* This is a permanent copy to reference in */\n                               /* the database. It is never freed. */\n   while (!feof(unitfile)) {\n      if (!fgetslong(&line, &linebufsize, unitfile, &linenum)) \n        break;\n      if (linenum==1 && startswith(line, UTF8MARKER)){ \n        int i;\n        for(lineptr=line,i=0;i<strlen(UTF8MARKER);i++, lineptr++)\n          *lineptr=' ';\n      }\n      strip_comment(line);\n      if (-1 == strwidth(line)){\n        readerror(errfile, \"%s: %s on line %d of '%s'\\n\",\n                      progname, invalid_utf8, linenum, file);\n        continue;\n      }\n      replace_minus(line);\n\n      if (*line == COMMANDCHAR) {         /* Process units file commands */\n        unitname = strtok(line+1, \" \");\n        if (!unitname){\n          readerror(errfile, VAGUE_ERR);\n          continue;\n        }\n\n        /* Check for locale and utf8 declarations.  Any other commands\n           most likely belong after these tests. */\n        if (!strcmp(unitname,\"var\") || !strcmp(unitname,\"varnot\")){\n          int not = 0;\n          if (unitname[3]=='n')\n            not = 1;\n          unitname=strtok(0,\" \");\n          unitdef=strtok(0,\"\");  /* Get rest of the line */\n          if (!unitname)\n            readerror(errfile, \n                      \"%s: no variable name specified on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else if (!unitdef)\n            readerror(errfile, \n                      \"%s: no value specified on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else if (invar)\n            readerror(errfile,\n                 \"%s: nested var statements not allowed, line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else {\n            int check;\n            invar = 1;\n            check = checkvar(unitname, unitdef);\n            if (check==2){\n              readerror(errfile,\n                 \"%s: environment variable %s not set at line %d of '%s'\\n\",\n                         progname, unitname, linenum, file);\n              wrongvar = 1;\n            }\n            else if (!(not^check))\n              wrongvar = 1;\n          }         \n          continue;\n        }\n        else if (!strcmp(unitname, \"endvar\")){\n          if (!invar)\n            readerror(errfile, \n                      \"%s: unmatched !endvar on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          wrongvar = 0;\n          invar = 0;\n          continue;\n        }\n        else if (!strcmp(unitname,\"locale\")){ \n          unitname = strtok(0, \" \"); \n          if (!unitname)\n            readerror(errfile, \n                      \"%s: no locale specified on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else if (inlocale)\n            readerror(errfile,\n                      \"%s: nested locales not allowed, line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else {\n            inlocale = 1;\n            if (strcmp(unitname,mylocale))  /* locales don't match           */\n              wronglocale = 1;\n          }\n          continue;\n        } \n        else if (!strcmp(unitname, \"endlocale\")){\n          if (!inlocale)\n            readerror(errfile, \n                      \"%s: unmatched !endlocale on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          wronglocale = 0;\n          inlocale = 0;\n          continue;\n        }\n        else if (!strcmp(unitname, \"utf8\")){\n          if (in_utf8)\n            readerror(errfile,\"%s: nested utf8 not allowed, line %d of '%s'\\n\",\n                              progname, linenum, file);\n          else in_utf8 = 1;\n          continue;\n        } \n        else if (!strcmp(unitname, \"endutf8\")){\n          if (!in_utf8)\n            readerror(errfile,\"%s: unmatched !endutf8 on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          in_utf8 = 0;\n          continue;\n        }\n        if (in_utf8 && !utf8mode) continue;\n        if (wronglocale || wrongvar) continue;\n\n        if (!strcmp(unitname,\"message\")){\n           unitname = strtok(0,\"\");     /* Rest of the line */\n           if (!flags.quiet && unitname)\n             puts(unitname);\n          continue; \n        }\n         else if (!strcmp(unitname,\"set\")) {\n           unitname = strtok(0,\" \");\n          unitdef = strtok(0,\" \");\n          if (!unitname)\n            readerror(errfile, \n                      \"%s: no variable name specified on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else if (!unitdef)\n            readerror(errfile, \n                      \"%s: no value specified on line %d of '%s'\\n\",\n                      progname, linenum, file);\n          else \n            setenv(unitname, unitdef, 0);\n          continue;\n        }\n        else if (!strcmp(unitname,\"unitlist\")){\n          splitline(0,&unitname, &unitdef); /* 0 continues strtok call */\n          if (!unitname || !unitdef)\n            readerror(errfile,VAGUE_ERR);\n          else {\n            if (newalias(unitname, unitdef, linenum, permfile, errfile))\n              goterr = 1;\n          }\n          continue;\n        }\n        else if (!strcmp(unitname, \"include\")){\n          if (depth>MAXINCLUDE){\n            readerror(errfile, \n                \"%s: max include depth of %d exceeded in file '%s' line %d\\n\",\n                progname, MAXINCLUDE, file, linenum);\n          } else {\n            int readerr;\n            char *includefile;\n\n            unitname = strtok(0, \" \"); \n            if (!unitname){\n              readerror(errfile,\n                        \"%s: missing include filename on line %d of '%s'\\n\",\n                        progname, linenum, file);\n              continue;\n            }\n            includefile = mymalloc(strlen(file)+strlen(unitname)+1, \"(readunits)\");\n            if (isfullpath(unitname))\n              strcpy(includefile,unitname);\n            else {\n              strcpy(includefile,file);\n              strcpy(pathend(includefile), unitname);\n            }\n\n            readerr = readunits(includefile, errfile, unitcount, prefixcount, \n                                funccount, depth+1);\n            if (readerr == E_MEMORY){\n              fclose(unitfile);\n              free(line);\n              free(includefile);\n              return readerr;\n            }\n            if (readerr == E_FILE) {\n              readerror(errfile, \"%s: cannot open included file '%s' at line %d of file '%s\\n\",\n                        progname, includefile, linenum, file);\n            }\n            \n            if (readerr)\n              goterr = 1;\n            free(includefile);\n          }\n        } else                             /* not a valid command */\n          readerror(errfile,VAGUE_ERR);\n        continue;\n      } \n      if (in_utf8 && !utf8mode) continue;\n      if (wronglocale || wrongvar) continue;\n      splitline(line, &unitname, &unitdef);\n      if (!unitname) continue;\n      if (!unitdef){\n        readerror(errfile,\n              \"%s: unit '%s' lacks a definition at line %d of '%s'\\n\",\n                  progname, unitname, linenum, file);\n        continue;\n      }\n\n      len = strlen(unitname);      \n\n      if (unitname[len - 1] == '-'){      /* it's a prefix definition */\n        if (newprefix(unitname,unitdef,&locprefixcount,linenum,\n                      permfile,errfile))\n          goterr=1;\n      }\n      else if (strchr(unitname,'[')){     /* table definition  */\n        retcode=newtable(unitname,unitdef,&locfunccount,linenum,\n                         permfile,errfile);\n        if (retcode){\n          if (retcode != E_BADFILE){\n            fclose(unitfile);\n            free(line);\n            return retcode;\n          }\n          goterr=1;\n        }\n      }\n      else if (strchr(unitname,'(')){     /* function definition */\n        if (newfunction(unitname,unitdef,&locfunccount,linenum,\n                        permfile,errfile))\n          goterr = 1;\n      }\n      else {                              /* ordinary unit definition */\n        if (newunit(unitname,unitdef,&locunitcount,linenum,permfile,errfile))\n          goterr = 1;\n      }\n   }\n   fclose(unitfile);\n   free(line);\n   if (unitcount)\n     *unitcount+=locunitcount;\n   if (prefixcount)\n     *prefixcount+=locprefixcount;\n   if (funccount)\n     *funccount+=locfunccount;\n   if (goterr)\n     return E_BADFILE;\n   else return 0;\n}",
      "lines": 268,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "initializeunit": {
      "start_point": [
        1790,
        0
      ],
      "end_point": [
        1795,
        1
      ],
      "content": "void\ninitializeunit(struct unittype *theunit)\n{\n   theunit->factor = 1.0;\n   theunit->numerator[0] = theunit->denominator[0] = NULL;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "freeunit": {
      "start_point": [
        1801,
        0
      ],
      "end_point": [
        1815,
        1
      ],
      "content": "void\nfreeunit(struct unittype *theunit)\n{\n   char **ptr;\n\n   for(ptr = theunit->numerator; *ptr; ptr++)\n     if (*ptr != NULLUNIT) free(*ptr);\n   for(ptr = theunit->denominator; *ptr; ptr++)\n     if (*ptr != NULLUNIT) free(*ptr);\n\n   /* protect against repeated calls to freeunit() */\n\n   theunit->numerator[0] = 0;  \n   theunit->denominator[0] = 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "logprintf": {
      "start_point": [
        1818,
        0
      ],
      "end_point": [
        1831,
        1
      ],
      "content": "void\nlogprintf(const char *format, ...)\n{\n  va_list args;\n\n  va_start(args, format);\n  vprintf(format, args);\n  va_end(args);\n  if (logfile) {\n    va_start(args, format);\n    vfprintf(logfile, format, args);\n    va_end(args);\n  }\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "logputchar": {
      "start_point": [
        1833,
        0
      ],
      "end_point": [
        1838,
        1
      ],
      "content": "void\nlogputchar(char c)\n{\n  putchar(c);\n  if (logfile) fputc(c, logfile);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "logputs": {
      "start_point": [
        1840,
        0
      ],
      "end_point": [
        1845,
        1
      ],
      "content": "void\nlogputs(const char *s)\n{\n  fputs(s, stdout);\n  if (logfile) fputs(s, logfile);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "showunit": {
      "start_point": [
        1850,
        0
      ],
      "end_point": [
        1893,
        1
      ],
      "content": "void\nshowunit(struct unittype *theunit)\n{\n   char **ptr;\n   int printedslash;\n   int counter = 1;\n\n   logprintf(num_format.format, theunit->factor);\n\n   for (ptr = theunit->numerator; *ptr; ptr++) {\n      if (ptr > theunit->numerator && **ptr &&\n          !strcmp(*ptr, *(ptr - 1)))\n         counter++;\n      else {\n         if (counter > 1)\n           logprintf(\"%s%d\", powerstring, counter);\n         if (**ptr)\n           logprintf(\" %s\", *ptr);\n         counter = 1;\n      }\n   }\n   if (counter > 1)\n     logprintf(\"%s%d\", powerstring, counter);\n   counter = 1;\n   printedslash = 0;\n   for (ptr = theunit->denominator; *ptr; ptr++) {\n      if (ptr > theunit->denominator && **ptr &&\n          !strcmp(*ptr, *(ptr - 1)))\n         counter++;\n      else {\n         if (counter > 1)\n           logprintf(\"%s%d\", powerstring, counter);\n         if (**ptr) {\n            if (!printedslash)\n              logprintf(\" /\");\n            printedslash = 1;\n            logprintf(\" %s\", *ptr);\n         }\n         counter = 1;\n      }\n   }\n   if (counter > 1)\n     logprintf(\"%s%d\", powerstring, counter);\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "compare": {
      "start_point": [
        1898,
        0
      ],
      "end_point": [
        1902,
        1
      ],
      "content": "int\ncompare(const void *item1, const void *item2)\n{\n   return strcmp(*(char **) item1, *(char **) item2);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sortunit": {
      "start_point": [
        1907,
        0
      ],
      "end_point": [
        1917,
        1
      ],
      "content": "void\nsortunit(struct unittype *theunit)\n{\n   char **ptr;\n   int count;\n\n   for (count = 0, ptr = theunit->numerator; *ptr; ptr++, count++);\n   qsort(theunit->numerator, count, sizeof(char *), compare);\n   for (count = 0, ptr = theunit->denominator; *ptr; ptr++, count++);\n   qsort(theunit->denominator, count, sizeof(char *), compare);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cancelunit": {
      "start_point": [
        1923,
        0
      ],
      "end_point": [
        1944,
        1
      ],
      "content": "void\ncancelunit(struct unittype *theunit)\n{\n   char **den, **num;\n   int comp;\n\n   den = theunit->denominator;\n   num = theunit->numerator;\n\n   while (*num && *den) { \n      comp = strcmp(*den, *num);\n      if (!comp) { /* units match, so cancel them */\n         if (*den!=NULLUNIT) free(*den);\n         if (*num!=NULLUNIT) free(*num);  \n         *den++ = NULLUNIT;\n         *num++ = NULLUNIT;\n      } else if (comp < 0) /* Move up whichever pointer is alphabetically */\n         den++;            /* behind to look for future matches */\n      else\n         num++;\n   }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "lookupunit": {
      "start_point": [
        1974,
        0
      ],
      "end_point": [
        2035,
        1
      ],
      "content": "char *\nlookupunit(char *unit,int prefixok)\n{\n   char *copy;\n   struct prefixlist *pfxptr;\n   struct unitlist *uptr;\n\n   if ((uptr = ulookup(unit)))\n      return uptr->value;\n\n   if (strwidth(unit)>2 && lastchar(unit) == 's') {\n      copy = dupstr(unit);\n      lastchar(copy) = 0;\n      if (lookupunit(copy,prefixok)){\n         while(strlen(copy)+1 > bufsize) {\n            growbuffer(&buffer, &bufsize);\n         }\n         strcpy(buffer, copy);  /* Note: returning looked up result seems   */\n         free(copy);            /*   better but it causes problems when it  */\n         return buffer;         /*   contains PRIMITIVECHAR.                */\n      }\n      if (strlen(copy)>2 && lastchar(copy) == 'e') {\n         lastchar(copy) = 0;\n         if (lookupunit(copy,prefixok)){\n            while (strlen(copy)+1 > bufsize) {\n               growbuffer(&buffer,&bufsize);\n            }\n            strcpy(buffer,copy);\n            free(copy);\n            return buffer;\n         }\n      }\n      if (strlen(copy)>2 && lastchar(copy) == 'i') {\n         lastchar(copy) = 'y';\n         if (lookupunit(copy,prefixok)){\n            while (strlen(copy)+1 > bufsize) {\n               growbuffer(&buffer,&bufsize);\n            }\n            strcpy(buffer,copy);\n            free(copy);\n            return buffer;\n         }\n      }\n      free(copy);\n   }\n   if (prefixok && (pfxptr = plookup(unit))) {\n      copy = unit + pfxptr->len;\n      if (emptystr(copy) || lookupunit(copy,0)) {\n         char *tempbuf;\n         while (strlen(pfxptr->value)+strlen(copy)+2 > bufsize){\n            growbuffer(&buffer, &bufsize);\n         }\n         tempbuf = dupstr(copy);   /* copy might point into buffer */\n         strcpy(buffer, pfxptr->value);\n         strcat(buffer, \" \");\n         strcat(buffer, tempbuf);\n         free(tempbuf);\n         return buffer;\n      }\n   }\n   return 0;\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "char",
        "*\nlookupunit(char *unit,int prefixok)",
        "*"
      ]
    },
    "moveproduct": {
      "start_point": [
        2041,
        0
      ],
      "end_point": [
        2059,
        1
      ],
      "content": "int\nmoveproduct(char *product[], char *tomove[])\n{\n   char **dest, **src;\n\n   dest=product;\n   for(src = tomove; *src; src++){\n     if (*src == NULLUNIT) continue;\n     for(; *dest && *dest != NULLUNIT; dest++);\n     if (dest - product >= MAXSUBUNITS - 1) {\n       return E_PRODOVERFLOW;\n     }\n     if (!*dest)\n        *(dest + 1) = 0;\n     *dest = *src;\n     *src=NULLUNIT;\n   }\n   return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "copyproduct": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2079,
        1
      ],
      "content": "void\ncopyproduct(char **dest, char **source)\n{\n   for(;*source;source++,dest++) {\n     if (*source==NULLUNIT)\n       *dest = NULLUNIT;\n     else\n       *dest=dupstr(*source);\n   }\n   *dest=0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "unitcopy": {
      "start_point": [
        2083,
        0
      ],
      "end_point": [
        2089,
        1
      ],
      "content": "void\nunitcopy(struct unittype *dest, struct unittype *source)\n{\n  dest->factor = source->factor;\n  copyproduct(dest->numerator, source->numerator);\n  copyproduct(dest->denominator, source->denominator);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "multunit": {
      "start_point": [
        2095,
        0
      ],
      "end_point": [
        2104,
        1
      ],
      "content": "int \nmultunit(struct unittype *left, struct unittype *right)\n{\n  int myerr;\n  left->factor *= right->factor;\n  myerr = moveproduct(left->numerator, right->numerator);\n  if (!myerr)\n    myerr = moveproduct(left->denominator, right->denominator);\n  return myerr;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "divunit": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2115,
        1
      ],
      "content": "int \ndivunit(struct unittype *left, struct unittype *right)\n{\n  int myerr;\n  left->factor /= right->factor;\n  myerr = moveproduct(left->numerator, right->denominator);\n  if (!myerr)\n    myerr = moveproduct(left->denominator, right->numerator);\n  return myerr;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "reduceproduct": {
      "start_point": [
        2133,
        0
      ],
      "end_point": [
        2175,
        1
      ],
      "content": "int\nreduceproduct(struct unittype *theunit, int flip)\n{\n\n   char *toadd;\n   char **product;\n   int didsomething = NOREDUCTION;\n   struct unittype newunit;\n   int ret;\n\n   if (flip)\n      product = theunit->denominator;\n   else\n      product = theunit->numerator;\n\n   for (; *product; product++) {\n      for (;;) {\n         if (!strlen(*product))\n            break;\n         toadd = lookupunit(*product,1);\n         if (!toadd) {\n            if (!irreducible)\n              irreducible = dupstr(*product);\n            return REDUCTIONERROR;\n         }\n         if (strchr(toadd, PRIMITIVECHAR))\n            break;\n         didsomething = DIDREDUCTION;\n         if (*product != NULLUNIT) {\n            free(*product);\n            *product = NULLUNIT;\n         }\n         if (parseunit(&newunit, toadd, 0, 0))\n            return REDUCTIONERROR;\n         if (flip) ret=divunit(theunit,&newunit);\n         else ret=multunit(theunit,&newunit);\n         freeunit(&newunit);\n         if (ret) \n            return REDUCTIONERROR;\n      }\n   }\n   return didsomething;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "reduceunit": {
      "start_point": [
        2183,
        0
      ],
      "end_point": [
        2207,
        1
      ],
      "content": "int\nreduceunit(struct unittype *theunit)\n{\n   int ret;\n\n   if (irreducible)\n     free(irreducible);\n   irreducible=0;\n   ret = DIDREDUCTION;\n\n   /* Keep calling reduceproduct until it doesn't do anything */\n\n   while (ret & DIDREDUCTION) {\n      ret = reduceproduct(theunit, 0);\n      if (!(ret & REDUCTIONERROR))\n        ret |= reduceproduct(theunit, 1);\n      if (ret & REDUCTIONERROR){\n         if (irreducible) \n           return E_UNKNOWNUNIT;\n         else\n           return E_REDUCE;\n      }\n   }\n   return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "ignore_dimless": {
      "start_point": [
        2215,
        0
      ],
      "end_point": [
        2225,
        1
      ],
      "content": "int\nignore_dimless(char *name)\n{\n  struct unitlist *ul;\n  if (!name) \n    return 0;\n  ul = ulookup(name);\n  if (ul && !strcmp(ul->value, NODIM))\n    return 1;\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "ignore_nothing": {
      "start_point": [
        2227,
        0
      ],
      "end_point": [
        2231,
        1
      ],
      "content": "int \nignore_nothing(char *name)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "ignore_primitive": {
      "start_point": [
        2234,
        0
      ],
      "end_point": [
        2244,
        1
      ],
      "content": "int\nignore_primitive(char *name)\n{\n  struct unitlist *ul;\n  if (!name) \n    return 0;\n  ul = ulookup(name);\n  if (ul && strchr(ul->value, PRIMITIVECHAR))\n    return 1;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "compareproducts": {
      "start_point": [
        2254,
        0
      ],
      "end_point": [
        2275,
        1
      ],
      "content": "int\ncompareproducts(char **one, char **two, int (*isdimless)(char *name))\n{\n   int oneblank, twoblank;\n   while (*one || *two) {\n      oneblank = (*one==NULLUNIT) || isdimless(*one);    \n      twoblank = (*two==NULLUNIT) || isdimless(*two);    \n      if (!*one && !twoblank)\n         return 1;\n      if (!*two && !oneblank)\n         return 1;\n      if (oneblank)\n         one++;\n      else if (twoblank)\n         two++;\n      else if (strcmp(*one, *two))\n         return 1;\n      else\n         one++, two++;\n   }\n   return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "compareunits": {
      "start_point": [
        2281,
        0
      ],
      "end_point": [
        2288,
        1
      ],
      "content": "int\ncompareunits(struct unittype *first, struct unittype *second, \n             int (*isdimless)(char *name))\n{\n   return\n      compareproducts(first->numerator, second->numerator, isdimless) ||\n      compareproducts(first->denominator, second->denominator, isdimless);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "completereduce": {
      "start_point": [
        2293,
        0
      ],
      "end_point": [
        2303,
        1
      ],
      "content": "int\ncompletereduce(struct unittype *unit)\n{\n   int err;\n\n   if ((err=reduceunit(unit)))\n     return err;\n   sortunit(unit);\n   cancelunit(unit);\n   return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "expunit": {
      "start_point": [
        2309,
        0
      ],
      "end_point": [
        2350,
        1
      ],
      "content": "int\nexpunit(struct unittype *theunit, int  power)\n{\n  char **numptr, **denptr;\n  double thefactor;\n  int i, uind, denlen, numlen;\n\n  if (power==0){\n    freeunit(theunit);\n    initializeunit(theunit);\n    return 0;\n  }\n  numlen=0;\n  for(numptr=theunit->numerator;*numptr;numptr++) numlen++;\n  denlen=0;\n  for(denptr=theunit->denominator;*denptr;denptr++) denlen++;\n  thefactor=theunit->factor;\n  for(i=1;i<power;i++){\n    theunit->factor *= thefactor;\n    for(uind=0;uind<numlen;uind++){\n      if (theunit->numerator[uind]!=NULLUNIT){\n        if (numptr-theunit->numerator>=MAXSUBUNITS-1) {\n           *numptr=*denptr=0;\n           return E_PRODOVERFLOW;\n        }\n        *numptr++=dupstr(theunit->numerator[uind]);\n      }\n    }\n    for(uind=0;uind<denlen;uind++){\n      if (theunit->denominator[uind]!=NULLUNIT){\n        *denptr++=dupstr(theunit->denominator[uind]);\n        if (denptr-theunit->denominator>=MAXSUBUNITS-1) {\n          *numptr=*denptr=0;\n          return E_PRODOVERFLOW;\n        }\n      }   \n    }\n  }\n  *numptr=0;\n  *denptr=0;\n  return 0;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "unit2num": {
      "start_point": [
        2353,
        0
      ],
      "end_point": [
        2366,
        1
      ],
      "content": "int\nunit2num(struct unittype *input)\n{\n  struct unittype one;\n  int err;\n\n  initializeunit(&one);\n  if ((err=completereduce(input)))\n    return err;\n  if (compareunits(input,&one,ignore_nothing))\n    return E_NOTANUMBER;\n  freeunit(input);\n  return 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "unitdimless": {
      "start_point": [
        2369,
        0
      ],
      "end_point": [
        2378,
        1
      ],
      "content": "int\nunitdimless(struct unittype *input)\n{\n  struct unittype one;\n  initializeunit(&one);\n  if (compareunits(input, &one, ignore_dimless))\n    return 0;\n  freeunit(input);  /* Eliminate dimensionless units from list */\n  return 1;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "showunitdetail": {
      "start_point": [
        2382,
        0
      ],
      "end_point": [
        2396,
        1
      ],
      "content": "void showunitdetail(struct unittype *foo)\n{\n  char **ptr;\n\n  printf(\"%.17g \", foo->factor);\n\n  for(ptr=foo->numerator;*ptr;ptr++)\n    if (*ptr==NULLUNIT) printf(\"NULL \");\n    else printf(\"`%s' \", *ptr);\n  printf(\" / \");\n  for(ptr=foo->denominator;*ptr;ptr++)\n    if (*ptr==NULLUNIT) printf(\"NULL \");\n    else printf(\"`%s' \", *ptr);\n  putchar('\\n');\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "subunitroot": {
      "start_point": [
        2406,
        0
      ],
      "end_point": [
        2432,
        1
      ],
      "content": "int \nsubunitroot(int n,char *current[], char *out[])\n{\n  char **ptr;\n  int count=0;\n\n  while(*current==NULLUNIT) current++;  /* skip past NULLUNIT entries */\n  ptr=current;\n  while(*ptr){\n    while(*ptr){\n      if (*ptr!=NULLUNIT){\n        if (strcmp(*current,*ptr)) break;\n        count++;\n      }\n      ptr++;\n    }\n    if (count % n != 0){  /* If not dimensionless generate error, otherwise */\n      if (!ignore_dimless(*current))    /* just skip over it */\n        return E_NOTROOT;\n    } else {\n      for(count /= n;count>0;count--) *(out++) = dupstr(*current);\n    }\n    current=ptr;\n  }\n  *out = 0;\n  return 0;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "rootunit": {
      "start_point": [
        2435,
        0
      ],
      "end_point": [
        2455,
        1
      ],
      "content": "int \nrootunit(struct unittype *inunit,int n)\n{\n   struct unittype outunit;\n   int err;\n\n   initializeunit(&outunit);\n   if ((err=completereduce(inunit)))\n     return err;\n   /* Roots of negative numbers fail in pow(), even odd roots */\n   if (inunit->factor < 0)\n     return E_NOTROOT;\n   outunit.factor = pow(inunit->factor,1.0/(double)n);\n   if ((err = subunitroot(n, inunit->numerator, outunit.numerator)))\n     return err;\n   if ((err = subunitroot(n, inunit->denominator, outunit.denominator)))\n     return err;\n   freeunit(inunit);\n   initializeunit(inunit);\n   return multunit(inunit,&outunit);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "invertunit": {
      "start_point": [
        2460,
        0
      ],
      "end_point": [
        2477,
        1
      ],
      "content": "void\ninvertunit(struct unittype *theunit)\n{\n  char **ptr, *swap;\n  int numlen, length, ind;\n\n  theunit->factor = 1.0/theunit->factor;  \n  length=numlen=0;\n  for(ptr=theunit->denominator;*ptr;ptr++,length++);\n  for(ptr=theunit->numerator;*ptr;ptr++,numlen++);\n  if (numlen>length)\n    length=numlen;\n  for(ind=0;ind<=length;ind++){\n    swap = theunit->numerator[ind];\n    theunit->numerator[ind] = theunit->denominator[ind];\n    theunit->denominator[ind] = swap;\n  }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "float2rat": {
      "start_point": [
        2480,
        0
      ],
      "end_point": [
        2510,
        1
      ],
      "content": "int\nfloat2rat(double y, int *p, int *q)\n{\n  int coef[20];           /* How long does this buffer need to be? */\n  int i,termcount,saveq;\n  double fracpart,x;\n\n  /* Compute continued fraction approximation */\n\n  x=y;\n  termcount=0;\n  while(1){\n    coef[termcount] = (int) floor(x);\n    fracpart = x-coef[termcount];\n    if (fracpart < .001 || termcount==19) break;\n    x = 1/fracpart;\n    termcount++;\n  }\n\n  /* Compress continued fraction into rational p/q */\n \n  *p=0;\n  *q=1;\n  for(i=termcount;i>=1;i--) {\n    saveq=*q;\n    *q = coef[i] * *q + *p;\n    *p = saveq;\n  }\n  *p+=*q*coef[0];\n  return *q<MAXSUBUNITS && fabs((double)*p / (double)*q - y) < DBL_EPSILON;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "unitpower": {
      "start_point": [
        2515,
        0
      ],
      "end_point": [
        2557,
        1
      ],
      "content": "int\nunitpower(struct unittype *base, struct unittype *exponent)\n{\n  int errcode, p, q;\n\n  errcode = unit2num(exponent);\n  if (errcode == E_NOTANUMBER)\n    return E_DIMEXPONENT;\n  if (errcode) \n    return errcode;\n  errcode = unit2num(base);\n  if (!errcode){                     /* Exponent base is dimensionless */\n    base->factor = pow(base->factor,exponent->factor);\n    if (errno)\n      return E_FUNC;\n  }\n  else if (errcode==E_NOTANUMBER) {          /* Base not dimensionless */\n    if (!float2rat(exponent->factor,&p,&q)){ /* Exponent must be rational */\n      if (unitdimless(base)){\n        base->factor = pow(base->factor,exponent->factor);\n        if (errno)\n          return E_FUNC;\n      }\n      else\n        return E_IRRATIONAL_EXPONENT;\n    } else {\n      if (q!=1) {\n        errcode = rootunit(base, q);\n        if (errcode == E_NOTROOT) \n          return E_BASE_NOTROOT;\n        if (errcode)\n          return errcode;\n      }\n      errcode = expunit(base, abs(p));\n      if (errcode)\n        return errcode;\n      if (p<0)\n        invertunit(base);\n    }\n  } \n  else return errcode;\n  return 0;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "addunit": {
      "start_point": [
        2564,
        0
      ],
      "end_point": [
        2578,
        1
      ],
      "content": "int\naddunit(struct unittype *unita, struct unittype *unitb)\n{\n  int err;\n\n  if ((err=completereduce(unita)))\n    return err;\n  if ((err=completereduce(unitb)))\n    return err;\n  if (compareunits(unita,unitb,ignore_nothing))\n    return E_BADSUM;\n  unita->factor += unitb->factor;\n  freeunit(unitb);\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "linearinterp": {
      "start_point": [
        2581,
        0
      ],
      "end_point": [
        2588,
        1
      ],
      "content": "double\nlinearinterp(double  a, double b, double aval, double bval, double c)\n{\n  double lambda;\n\n  lambda = (b-c)/(b-a);\n  return lambda*aval + (1-lambda)*bval;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "evalfunc": {
      "start_point": [
        2598,
        0
      ],
      "end_point": [
        2713,
        1
      ],
      "content": "int\nevalfunc(struct unittype *theunit, struct func *infunc, int inverse, \n         int allerrors)\n{\n   struct unittype result;\n   struct functype *thefunc;\n   int err;\n   double value;\n   int foundit, count;\n   struct unittype *save_value;\n   char *save_function;\n\n   if (infunc->table) {  /* Tables are short, so use dumb search algorithm */\n     err = parseunit(&result, infunc->tableunit, 0, 0);\n     if (err)\n       return E_BADFUNCDIMEN;\n     if (inverse){\n       err = divunit(theunit, &result);\n       if (err)\n         return err;\n       err = unit2num(theunit);\n       if (err==E_NOTANUMBER)\n         return E_BADFUNCARG;\n       if (err)\n         return err;\n       value = theunit->factor;\n       foundit=0;\n       for(count=0;count<infunc->tablelen-1;count++)\n         if ((infunc->table[count].value<=value &&\n              value<=infunc->table[count+1].value) ||\n             (infunc->table[count+1].value<=value &&\n              value<=infunc->table[count].value)){\n           foundit=1;\n           value  = linearinterp(infunc->table[count].value,\n                                 infunc->table[count+1].value,\n                                 infunc->table[count].location,\n                                 infunc->table[count+1].location,\n                                 value);\n           break;\n         }\n       if (!foundit)\n         return E_NOTINDOMAIN;\n       freeunit(&result);\n       freeunit(theunit);\n       theunit->factor = value;\n       return 0;\n     } else {\n       err=unit2num(theunit);\n       if (err)\n         return err;\n       value=theunit->factor;\n       foundit=0;\n       for(count=0;count<infunc->tablelen-1;count++)\n         if (infunc->table[count].location<=value &&\n             value<=infunc->table[count+1].location){\n           foundit=1;\n           value =  linearinterp(infunc->table[count].location,\n                        infunc->table[count+1].location,\n                        infunc->table[count].value,\n                        infunc->table[count+1].value,\n                        value);\n           break;\n         } \n       if (!foundit)\n         return E_NOTINDOMAIN;\n       result.factor *= value;\n     }\n   } else {  /* it's a function */\n     if (inverse){\n       thefunc=&(infunc->inverse);\n       if (!thefunc->def)\n         return E_NOINVERSE;\n     }\n     else\n       thefunc=&(infunc->forward);\n     err = completereduce(theunit);\n     if (err)\n       return err;\n     if (thefunc->dimen){\n       err = parseunit(&result, thefunc->dimen, 0, 0);\n       if (err)\n         return E_BADFUNCDIMEN;\n       err = completereduce(&result);\n       if (err)\n         return E_BADFUNCDIMEN;\n       if (compareunits(&result, theunit, ignore_nothing))\n         return E_BADFUNCARG;\n       value = theunit->factor/result.factor;\n     } else \n       value = theunit->factor;\n     if (thefunc->domain_max && \n         (value > *thefunc->domain_max || \n          (thefunc->domain_max_open && value == *thefunc->domain_max)))\n       return E_NOTINDOMAIN;\n     if (thefunc->domain_min && \n         (value < *thefunc->domain_min ||\n          (thefunc->domain_min_open && value == *thefunc->domain_min)))\n       return E_NOTINDOMAIN;\n     save_value = parameter_value;\n     save_function = function_parameter;\n     parameter_value = theunit;\n     function_parameter = thefunc->param;\n     err = parseunit(&result, thefunc->def, 0,0);\n     function_parameter = save_function;\n     parameter_value = save_value;\n     if (err && (allerrors == ALLERR || err==E_PARSEMEM || err==E_PRODOVERFLOW \n                 || err==E_NOTROOT || err==E_BADFUNCTYPE))\n       return err;\n     if (err)\n       return E_FUNARGDEF;\n   }\n   freeunit(theunit);\n   initializeunit(theunit);\n   multunit(theunit, &result);\n   return 0;\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "showdefinition": {
      "start_point": [
        2722,
        0
      ],
      "end_point": [
        2735,
        1
      ],
      "content": "void\nshowdefinition(char *unitstr, struct unittype *theunit)\n{\n  logputs(deftext);\n  while((unitstr = lookupunit(unitstr,1))\n        && strspn(unitstr,digits) != strlen(unitstr)\n        && !strchr(unitstr,PRIMITIVECHAR)) {\n    tightprint(stdout,unitstr);\n    if (logfile) tightprint(logfile,unitstr);\n    logputs(\" = \");\n  } \n  showunit(theunit);\n  logputchar('\\n');\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "showfunction": {
      "start_point": [
        2738,
        0
      ],
      "end_point": [
        2792,
        1
      ],
      "content": "void \nshowfunction(struct functype *func)\n{\n  struct unittype unit;\n  int not_dimensionless, i;\n\n  if (!func->def) {\n    logputs(\" is undefined\");\n    return;\n  }\n\n  if (func->dimen){                       /* coverity[check_return] */\n    parseunit(&unit,func->dimen,0,0);     /* unit2num returns 0 for */\n    not_dimensionless = unit2num(&unit);  /* dimensionless units    */\n  } \n    \n  logprintf(\"(%s) = %s\", func->param, func->def);\n  if (func->domain_min || func->domain_max){\n    logputchar('\\n');\n    for(i=strwidth(deftext);i;i--) logputchar(' ');\n    logputs(\"defined for \");\n    if (func->domain_min && func->domain_max) {\n      logprintf(num_format.format, *func->domain_min);\n      if (func->dimen && (not_dimensionless || unit.factor != 1)){\n        if (isdecimal(*func->dimen))\n          logputs(\" *\");\n        logprintf(\" %s\",func->dimen);\n      }\n      logputs(func->domain_min_open?\" < \":\" <= \");\n    }\n    logputs(func->param);\n    if (func->domain_max){\n      logputs(func->domain_max_open?\" < \":\" <= \");\n      logprintf(num_format.format, *func->domain_max);\n    }\n    else {\n      logputs(func->domain_min_open?\" > \":\" >= \");\n      logprintf(num_format.format, *func->domain_min);\n    }\n    if (func->dimen && (not_dimensionless || unit.factor != 1)){\n      if (isdecimal(*func->dimen))\n        logputs(\" *\");\n      logprintf(\" %s\",func->dimen);\n    }\n    if (!func->dimen) logputs(\" (any units)\");\n  } else if (func->dimen){\n    logputchar('\\n');\n    for(i=strwidth(deftext);i;i--) logputchar(' ');\n    if (not_dimensionless) \n      logprintf(\"%s has units %s\",func->param, func->dimen);\n    else\n      logprintf(\"%s is dimensionless\",func->param);\n  }    \n  logputchar('\\n');\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "showtable": {
      "start_point": [
        2794,
        0
      ],
      "end_point": [
        2830,
        1
      ],
      "content": "void\nshowtable(struct func *fun, int inverse)\n{\n  int i;\n\n  logprintf(\"%sinterpolated table with points\\n\",deftext);\n  if (inverse){\n    int reverse, j;\n    reverse = (fun->table[0].value > fun->table[fun->tablelen-1].value);\n    for(i=0;i<fun->tablelen;i++){\n      if (reverse) j = fun->tablelen-i-1;\n      else j=i;\n      if (flags.verbose>0)\n        logputs(\"\\t\\t    \");\n      logprintf(\"~%s(\", fun->name);\n      logprintf(num_format.format, fun->table[j].value);\n      if (isdecimal(fun->tableunit[0]))\n        logputs(\" *\");\n      logprintf(\" %s\",fun->tableunit);\n      logputs(\") = \");\n      logprintf(num_format.format, fun->table[j].location);\n      logputchar('\\n');\n    }\n  } else {\n    for(i=0;i<fun->tablelen;i++){\n      if (flags.verbose>0)\n        logputs(\"\\t\\t    \");\n      logprintf(\"%s(\", fun->name);\n      logprintf(num_format.format, fun->table[i].location);\n      logputs(\") = \");\n      logprintf(num_format.format, fun->table[i].value);\n      if (isdecimal(fun->tableunit[0]))\n        logputs(\" *\");\n      logprintf(\" %s\\n\",fun->tableunit);\n    }\n  }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "showfuncdefinition": {
      "start_point": [
        2833,
        0
      ],
      "end_point": [
        2845,
        1
      ],
      "content": "void\nshowfuncdefinition(struct func *fun, int inverse)\n{\n  if (fun->table)  /* It's a table */\n    showtable(fun, inverse);\n  else { \n    logprintf(\"%s%s%s\", deftext,inverse?\"~\":\"\", fun->name);\n    if (inverse)\n      showfunction(&fun->inverse);\n    else\n      showfunction(&fun->forward);\n  }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "showunitlistdef": {
      "start_point": [
        2848,
        0
      ],
      "end_point": [
        2855,
        1
      ],
      "content": "void\nshowunitlistdef(struct wantalias *alias)\n{\n  logprintf(\"%sunit list, \",deftext);\n  tightprint(stdout,alias->definition);\n  if (logfile) tightprint(logfile,alias->definition);\n  logputchar('\\n');\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "showfunc": {
      "start_point": [
        2861,
        0
      ],
      "end_point": [
        2913,
        1
      ],
      "content": "int\nshowfunc(char *havestr, struct unittype *have, struct func *fun)\n{\n   int err;\n   char *dimen;\n\n   err = evalfunc(have, fun, INVERSE, NORMALERR);\n   if (!err)\n     err = completereduce(have);\n   if (err) {\n     if (err==E_BADFUNCARG){\n       logputs(\"conformability error\");\n       if (fun->table)\n         dimen = fun->tableunit;\n       else if (fun->inverse.dimen)\n         dimen = fun->inverse.dimen;\n       else \n         dimen = 0;\n       if (!dimen)\n         logputchar('\\n');\n       else {\n         struct unittype want;\n         \n         if (emptystr(dimen))\n           dimen = \"1\";\n         logprintf(\": conversion requires dimensions of '%s'\\n\",dimen);\n         if (flags.verbose==2) logprintf(\"\\t%s = \",havestr);\n         else if (flags.verbose==1) logputchar('\\t');\n         showunit(have);\n         if (flags.verbose==2) logprintf(\"\\n\\t%s = \",dimen);\n         else if (flags.verbose==1) logprintf(\"\\n\\t\");\n         else logputchar('\\n');            /* coverity[check_return] */\n         parseunit(&want, dimen, 0, 0);    /* coverity[check_return] */\n         completereduce(&want);         /* dimen was already checked for */\n         showunit(&want);               /* errors so no need to check here */\n         logputchar('\\n');\n         }\n     } else if (err==E_NOTINDOMAIN)\n       logprintf(\"Value '%s' is not in the function's range\\n\",havestr);\n     else\n       logputs(\"Function evaluation error (bad function definition)\\n\");\n     return 1;\n   }\n   if (flags.verbose==2)\n     logprintf(\"\\t%s = %s(\", havestr, fun->inverse.param);\n   else if (flags.verbose==1) \n     logputchar('\\t');\n   showunit(have);\n   if (flags.verbose==2)\n     logputchar(')');\n   logputchar('\\n');\n   return 0;\n}",
      "lines": 53,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "showconformabilityerr": {
      "start_point": [
        2917,
        0
      ],
      "end_point": [
        2935,
        1
      ],
      "content": "void\nshowconformabilityerr(char *havestr,struct unittype *have,\n                      char *wantstr,struct unittype *want)\n{\n  logputs(\"conformability error\\n\");\n  if (flags.verbose==2)\n    logprintf(\"\\t%s = \",havestr);\n  else if (flags.verbose==1)\n    logputchar('\\t');\n  showunit(have);\n  if (flags.verbose==2)\n    logprintf(\"\\n\\t%s = \",wantstr);\n  else if (flags.verbose==1)\n    logputs(\"\\n\\t\");\n  else\n    logputchar('\\n');\n  showunit(want);\n  logputchar('\\n');\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "isfract": {
      "start_point": [
        2943,
        0
      ],
      "end_point": [
        2957,
        1
      ],
      "content": "int\nisfract(const char *unitstr)\n{\n  char *enddouble=0, *endlong=0;\n\n  while (isdigit(*unitstr))\n    unitstr++;\n  if (*unitstr++ == '|') {\n    (void)strtod(unitstr, &enddouble);\n    (void)strtol(unitstr, &endlong, 10);\n    if (enddouble == endlong)\n      return 1;\n  }\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "checksigdigits": {
      "start_point": [
        2959,
        0
      ],
      "end_point": [
        2995,
        1
      ],
      "content": "int\nchecksigdigits(char *arg)\n{\n  int errors, ival;\n  char *nonum;\n\n  errors = 0;\n\n  if (!strcmp(arg, \"max\"))\n    num_format.precision = MAXPRECISION;\n  else {\n    ival = (int) strtol(arg, &nonum, 10);\n    if (!emptystr(nonum)) {\n      fprintf(stderr,\n      \"%s: invalid significant digits (%s)--integer value or 'max' required\\n\",\n              progname, arg);\n      errors++;\n    }\n    else if (ival <= 0) {\n      fprintf(stderr, \"%s: number of significant digits must be positive\\n\",\n              progname);\n      errors++;\n    }\n    else if (ival > MAXPRECISION) {\n      fprintf(stderr,\n           \"%s: too many significant digits (%d)--using maximum value (%d)\\n\",\n           progname, ival, MAXPRECISION);\n      num_format.precision = MAXPRECISION;\n    }\n    else\n      num_format.precision = ival;\n  }\n  if (errors)\n    return -1;\n  else\n    return 0;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "setnumformat": {
      "start_point": [
        2999,
        0
      ],
      "end_point": [
        3013,
        1
      ],
      "content": "int\nsetnumformat()\n{\n  size_t len;\n\n  if (strchr(\"Ee\", num_format.type))\n    num_format.precision--;\n\n  len = 4;      /* %, decimal point, type, terminating NUL */\n  if (num_format.precision > 0)\n    len += (size_t) floor(log10((double) num_format.precision))+1;\n  num_format.format = (char *) mymalloc(len, \"(setnumformat)\");\n  sprintf(num_format.format, \"%%.%d%c\", num_format.precision, num_format.type);\n  return 0;\n}",
      "lines": 15,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "parsenumformat": {
      "start_point": [
        3021,
        0
      ],
      "end_point": [
        3166,
        1
      ],
      "content": "int\nparsenumformat()\n{\n  static char *format_types = NULL;\n  static char *format_flags = \"+-# 0'\";\n  static char badflag;\n  char *two = \"0x1p+1\";\n  char *valid=\"ABCDEFGHIJKLMNOPQRSTUVWXYXabcdefghijklmnopqrstuvwxyx.01234567890\";\n  char *dotptr, *lptr, *nonum, *p;\n  char testbuf[80];\n  int errors, ndx;\n\n  if (format_types == NULL){\n    format_types = (char *) mymalloc(strlen(BASE_FORMATS)+4, \"(parsenumformat)\");\n    strcpy(format_types,BASE_FORMATS);\n\n    /* check for support of type 'F' (MS VS 2012 doesn't have it) */\n    sprintf(testbuf, \"%.1F\", 1.2);\n    if (strlen(testbuf) == 3 && testbuf[0] == '1' && testbuf[2] == '2')\n      strcat(format_types,\"F\");\n\n    /* check for support of hexadecimal floating point */\n    sprintf(testbuf, \"%.0a\", 2.0);\n    if (!strcmp(testbuf,two))\n      strcat(format_types, \"aA\");\n\n    /* check for support of digit-grouping (') flag */\n    sprintf(testbuf, \"%'.0f\", 1234.0);\n    if (strlen(testbuf) > 2 && testbuf[0] == '1' && testbuf[2] == '2')\n      badflag = '\\0'; /* supported */\n    else\n      badflag = '\\''; /* not supported */\n  }\n\n  errors = 0;\n\n  p = num_format.format;\n\n  if (*p != '%') {\n    fprintf(stderr, \"%s: number format specification must start with '%%'\\n\",\n            progname);\n    errors++;\n  }\n  else if (strrchr(num_format.format, '%') != num_format.format) {\n    fprintf(stderr, \"%s: only one '%%' allowed in number format specification\\n\",\n            progname);\n    errors++;\n    p++;\n  }\n  else\n    p++;\n\n  dotptr = strchr(num_format.format, '.');\n  if (dotptr && strrchr(num_format.format, '.') != dotptr) {\n    fprintf(stderr, \"%s: only one '.' allowed in number format specification\\n\",\n            progname);\n    errors++;\n  }\n\n  /* skip over flags */\n  while (*p && strchr(format_flags, *p)) {\n    if (*p == badflag) {   /* only if digit-grouping flag (') not supported */\n      fprintf(stderr, \"%s: digit-grouping flag (') not supported\\n\", progname);\n      errors++;\n    }\n    p++;\n  }\n\n  /* check for type length modifiers, which aren't allowed */\n  if ((lptr = strstr(num_format.format, \"hh\"))\n     || (lptr = strstr(num_format.format, \"ll\"))) {\n    fprintf(stderr, \"%s: type length modifier (%.2s) not supported\\n\", progname, lptr);\n    errors++;\n  }\n  else if ((lptr = strpbrk(num_format.format, \"hjLltz\"))) {\n    fprintf(stderr, \"%s: type length modifier (%c) not supported\\n\", progname, lptr[0]);\n    errors++;\n  }\n\n  /* check for other invalid characters */\n  ndx = strspn(p, valid);\n  if (ndx < strlen(p)) {\n    fprintf(stderr, \"%s: invalid character (%c) in width, precision, or type\\n\",\n    progname, p[ndx]);\n    errors++;\n  }\n\n  if (errors) { /* results of any other checks are likely to be misleading */\n    fprintf(stderr, \"%s: invalid number format specification (%s)\\n\", \n                    progname, num_format.format);\n    fprintf(stderr, \"%s: valid specification is %%[flags][width][.precision]type\\n\",\n            progname);\n    return -1;\n  }\n\n  /* get width and precision if specified; check precision */\n  num_format.width = (int) strtol(p, &nonum, 10);\n\n  if (*nonum == '.'){\n    if (isdigit(nonum[1]))\n      num_format.precision = (int) strtol(nonum+1, &nonum, 10);\n    else {\n      num_format.precision = 0;\n      nonum++;\n    }\n  }\n  else  /* precision not given--use printf() default */\n    num_format.precision = 6;\n\n  /* check for valid format type */\n  if (emptystr(nonum)) {\n    fprintf(stderr, \"%s: missing format type\\n\", progname);\n    errors++;\n  }\n  else {\n    if (strchr(format_types, *nonum)) {\n      if (nonum[1]) {\n        fprintf(stderr, \"%s: invalid character(s) (%s) after format type\\n\",\n                progname, nonum + 1);\n        errors++;\n      }\n      else \n        num_format.type = *nonum;\n    }\n    else {\n      fprintf(stderr,\n              \"%s: invalid format type (%c)--valid types are [%s]\\n\",\n              progname, *nonum, format_types);\n      errors++;\n    }\n  }\n\n  if (num_format.precision == 0 && \n      (num_format.type == 'G' || num_format.type == 'g'))\n    num_format.precision = 1;\n\n  if (errors) {\n    fprintf(stderr, \"%s: invalid number format specification (%s)\\n\", \n                    progname, num_format.format);\n    fprintf(stderr, \"%s: valid specification is %%[flags][width][.precision]type\\n\",\n            progname);\n    return -1;\n  }\n  else\n    return 0;\n}",
      "lines": 146,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "round_to_displayed": {
      "start_point": [
        3172,
        0
      ],
      "end_point": [
        3217,
        1
      ],
      "content": "double\nround_to_displayed(double value, int *hasnondigits)\n{\n  int buflen;\n  char *buf;\n  double rounded;  \n\n  if (!isfinite(value)){\n    if (hasnondigits)\n      *hasnondigits = 1;\n    return value;\n  }\n  \n  /* allow for sign (1), radix (1), exponent (5), E or E formats (1), NUL */\n  buflen = num_format.precision + 9;\n\n  if (num_format.width > buflen)\n    buflen = num_format.width;\n\n  if (strchr(\"Ff\", num_format.type)) {\n    int len=num_format.precision+2;\n    if (fabs(value) > 1.0)\n      len += (int) floor(log10(fabs(value))) + 1;\n    if (len > buflen)\n      buflen = len;\n  }\n\n  /* allocate space for thousands separators with digit-grouping (') flag */\n  /* assume worst case--that all groups are two digits */\n  if (strchr(num_format.format, '\\'') && strchr(\"FfGg\", num_format.type)) \n    buflen = buflen*3/2;\n\n  buf = (char *) mymalloc(buflen, \"(round_to_displayed)\");\n  sprintf(buf, num_format.format, value);\n\n  if (hasnondigits){\n    if (strspn(buf, \"1234567890\") != strlen(buf))\n      *hasnondigits = 1;\n    else\n      *hasnondigits = 0;\n  }\n\n  rounded = strtod(buf, NULL);\n  free(buf);\n  return rounded;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "showunitname": {
      "start_point": [
        3229,
        0
      ],
      "end_point": [
        3258,
        1
      ],
      "content": "void\nshowunitname(double value, char *unitstr, int printnum)\n{\n  int hasnondigits;     /* flag to indicate nondigits in displayed value */\n  double rnd_value;     /* value rounded to displayed precision */\n\n  rnd_value = round_to_displayed(value, &hasnondigits);\n\n  if (printnum && !(rnd_value == 1 && isdecimal(*unitstr)))\n    logprintf(num_format.format, value);\n\n  if (strpbrk(unitstr, \"+-\"))   /* show sums and differences of units */\n    logprintf(\" (%s)\", unitstr);   /* in parens */\n     /* fractional unit 1|x and multiplier is all digits and not one--   */\n     /* no space or asterisk or numerator (3|8 in instead of 3 * 1|8 in) */\n  else if (printnum && !flags.showfactor\n           && startswith(unitstr,\"1|\") && isfract(unitstr)\n           && rnd_value != 1 && !hasnondigits)\n    logputs(unitstr+1);\n     /* multiplier is unity and unit begins with a number--no space or       */\n     /* asterisk (multiplier was not shown, and the space was already output)*/\n  else if (rnd_value ==  1 && isdecimal(*unitstr))\n    logputs(unitstr);\n     /* unitstr begins with a non-fraction number and multiplier was */\n     /* shown--prefix a spaced asterisk */\n  else if (isdecimal(unitstr[0]))\n    logprintf(\" * %s\", unitstr);\n  else\n    logprintf(\" %s\", unitstr);\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "showanswer": {
      "start_point": [
        3263,
        0
      ],
      "end_point": [
        3332,
        1
      ],
      "content": "int\nshowanswer(char *havestr,struct unittype *have,\n           char *wantstr,struct unittype *want)\n{\n   struct unittype invhave;\n   int doingrec;  /* reciprocal conversion? */\n   char *right = NULL, *left = NULL;\n\n   doingrec=0;\n   if (compareunits(have, want, ignore_dimless)) {\n        char **src,**dest;\n\n        invhave.factor=1/have->factor;\n        for(src=have->numerator,dest=invhave.denominator;*src;src++,dest++)\n           *dest=*src;\n        *dest=0;\n        for(src=have->denominator,dest=invhave.numerator;*src;src++,dest++)\n           *dest=*src;\n        *dest=0;\n        if (flags.strictconvert || compareunits(&invhave, want, ignore_dimless)){\n          showconformabilityerr(havestr, have, wantstr, want);\n          return -1;\n        }\n        if (flags.verbose>0)\n          logputchar('\\t');\n        logputs(\"reciprocal conversion\\n\");\n        have=&invhave;\n        doingrec=1;\n   } \n   if (flags.verbose==2) {\n     if (!doingrec) \n       left=right=\"\";\n     else if (strchr(havestr,'/')) {\n       left=\"1 / (\";\n       right=\")\";\n     } else {\n       left=\"1 / \";\n       right=\"\";\n     }\n   }   \n\n   /* Print the first line of output. */\n\n   if (flags.verbose==2) \n     logprintf(\"\\t%s%s%s = \",left,havestr,right);\n   else if (flags.verbose==1)\n     logputs(\"\\t* \");\n   if (flags.verbose==2)\n     showunitname(have->factor / want->factor, wantstr, PRINTNUM);\n   else\n     logprintf(num_format.format, have->factor / want->factor);\n\n   /* Print the second line of output. */\n\n   if (!flags.oneline){\n     if (flags.verbose==2) \n       logprintf(\"\\n\\t%s%s%s = (1 / \",left,havestr,right);\n     else if (flags.verbose==1)\n       logputs(\"\\n\\t/ \");\n     else \n       logputchar('\\n');\n     logprintf(num_format.format, want->factor / have->factor);\n     if (flags.verbose==2) {\n       logputchar(')');\n       showunitname(0,wantstr, NOPRINTNUM); \n     }\n   }\n   logputchar('\\n');\n   return 0;\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "checkfunc": {
      "start_point": [
        3344,
        0
      ],
      "end_point": [
        3493,
        1
      ],
      "content": "void\ncheckfunc(struct func *infunc, int verbose)\n{\n  struct unittype theunit, saveunit;\n  struct prefixlist *prefix;\n  int err, i;\n  double direction;\n\n  if (infunc->skip_error_check){\n    if (verbose)\n      printf(\"skipped function '%s'\\n\", infunc->name);\n    return;\n  }\n  if (verbose)\n    printf(\"doing function '%s'\\n\", infunc->name);\n  if ((prefix=plookup(infunc->name)) \n      && strlen(prefix->name)==strlen(infunc->name))\n    printf(\"Warning: '%s' defined as prefix and function\\n\",infunc->name);\n  if (infunc->table){\n    /* Check for valid unit for the table */\n    if (parseunit(&theunit, infunc->tableunit, 0, 0) ||\n        completereduce(&theunit))\n      printf(\"Table '%s' has invalid units '%s'\\n\",\n             infunc->name, infunc->tableunit);\n    freeunit(&theunit);\n\n    /* Check for monotonicity which is needed for unique inverses */\n    if (infunc->tablelen<=1){ \n      printf(\"Table '%s' has only one data point\\n\", infunc->name);\n      return;\n    }\n    direction = SIGN(infunc->table[1].value -  infunc->table[0].value);\n    for(i=2;i<infunc->tablelen;i++)\n      if (SIGN(infunc->table[i].value-infunc->table[i-1].value) != direction){\n        printf(\"Table '%s' lacks unique inverse around entry %.8g\\n\",\n               infunc->name, infunc->table[i].location);\n        return;\n      }\n    return;\n  }\n  if (infunc->forward.dimen){\n    if (parseunit(&theunit, infunc->forward.dimen, 0, 0) ||\n        completereduce(&theunit)){\n      printf(\"Function '%s' has invalid units '%s'\\n\", \n             infunc->name, infunc->forward.dimen);\n      freeunit(&theunit);\n      return;\n    }\n  } else initializeunit(&theunit); \n  if (infunc->forward.domain_max && infunc->forward.domain_min)\n    theunit.factor *= \n             (*infunc->forward.domain_max+*infunc->forward.domain_min)/2;\n  else if (infunc->forward.domain_max) \n    theunit.factor = theunit.factor * *infunc->forward.domain_max - 1;\n  else if (infunc->forward.domain_min)\n    theunit.factor = theunit.factor * *infunc->forward.domain_min + 1;\n  else \n    theunit.factor *= 7;   /* Arbitrary choice where we evaluate inverse */\n  if (infunc->forward.dimen){\n    unitcopy(&saveunit, &theunit);\n    err = evalfunc(&theunit, infunc, FUNCTION, ALLERR);\n    if (err) {\n      printf(\"Error in definition %s(%s) as '%s':\\n\",\n             infunc->name, infunc->forward.param, infunc->forward.def);\n      printf(\"      %s\\n\",errormsg[err]);\n      freeunit(&theunit);\n      freeunit(&saveunit);\n      return;\n    }\n  } else {\n#   define MAXPOWERTOCHECK 4\n    struct unittype resultunit, arbunit;\n    char unittext[9]; \n    double factor;\n    int errors[MAXPOWERTOCHECK], errcount=0;\n    char *indent;\n\n    strcpy(unittext,\"(kg K)^ \");\n    factor = theunit.factor;\n    initializeunit(&saveunit);\n    initializeunit(&resultunit);\n    for(i=0;i<MAXPOWERTOCHECK;i++){\n      lastchar(unittext) = '0'+i;\n      err = parseunit(&arbunit, unittext, 0, 0);\n      if (err) initializeunit(&arbunit);\n      arbunit.factor = factor;\n      unitcopy(&resultunit, &arbunit);\n      errors[i] = evalfunc(&resultunit, infunc, FUNCTION, ALLERR); \n      if (errors[i]) errcount++;\n      else {\n        freeunit(&saveunit);\n        freeunit(&theunit);\n        unitcopy(&saveunit, &arbunit);\n        unitcopy(&theunit, &resultunit);\n      }\n      freeunit(&resultunit);\n      freeunit(&arbunit);\n    }\n    if (!errors[0] && errcount==3) {\n      printf(\"Warning: function '%s(%s)' defined as '%s'\\n\",\n             infunc->name, infunc->forward.param, infunc->forward.def);\n      printf(\"         appears to require a dimensionless argument, 'units' keyword not given\\n\");\n      indent = \"         \";\n    }\n    else if (errcount==MAXPOWERTOCHECK) {\n      printf(\"Error or missing 'units' keyword in definion %s(%s) as '%s'\\n\",\n             infunc->name, infunc->forward.param, infunc->forward.def);\n      indent=\"      \";\n    }\n    else if (errcount){\n      printf(\"Warning: function '%s(%s)' defined as '%s'\\n\",\n             infunc->name, infunc->forward.param, infunc->forward.def);\n      printf(\"         failed for some test inputs:\\n\");\n      indent = \"         \";\n    }\n    for(i=0;i<MAXPOWERTOCHECK;i++) \n      if (errors[i]) {\n        lastchar(unittext) = '0'+i;\n        printf(\"%s%s(\",indent,infunc->name);\n        printf(num_format.format, factor);\n        printf(\"%s): %s\\n\", unittext, errormsg[errors[i]]);\n      }\n  }\n  if (completereduce(&theunit)){\n    printf(\"Definition %s(%s) as '%s' is irreducible\\n\",\n           infunc->name, infunc->forward.param, infunc->forward.def);\n    freeunit(&theunit);\n    freeunit(&saveunit);\n    return;\n  }    \n  if (!(infunc->inverse.def)){\n    printf(\"Warning: no inverse for function '%s'\\n\", infunc->name);\n    freeunit(&theunit);\n    freeunit(&saveunit);\n    return;\n  }\n  err = evalfunc(&theunit, infunc, INVERSE, ALLERR);\n  if (err){\n    printf(\"Error in inverse ~%s(%s) as '%s':\\n\",\n           infunc->name,infunc->inverse.param, infunc->inverse.def);\n    printf(\"      %s\\n\",errormsg[err]);\n    freeunit(&theunit);\n    freeunit(&saveunit);\n    return;\n  }\n  divunit(&theunit, &saveunit);\n  if (unit2num(&theunit) || fabs(theunit.factor-1)>1e-12)\n    printf(\"Inverse is not the inverse for function '%s'\\n\", infunc->name);\n  freeunit(&theunit);\n}",
      "lines": 150,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "addtolist": {
      "start_point": [
        3504,
        0
      ],
      "end_point": [
        3545,
        1
      ],
      "content": "void \naddtolist(struct unittype *have, char *searchstring, char *rname, char *name, \n               char *def, struct namedef **list, int *listsize, \n               int *maxnamelen, int *count, int searchtype)\n{\n  struct unittype want;\n  int len = 0;\n  int keepit = 0;\n\n  if (!name) \n    return;\n  if (searchtype==CONFORMABLE){\n    initializeunit(&want);\n    if (!parseunit(&want, name,0,0) && !completereduce(&want))\n      keepit = !compareunits(have,&want,ignore_dimless);\n  } else if (searchtype == TEXTMATCH) {\n    keepit = (strstr(rname,searchstring) != NULL);\n  }\n  if (keepit){\n    if (*count==*listsize){\n      *listsize += 100;\n      *list = (struct namedef *) \n        realloc(*list,*listsize*sizeof(struct namedef));\n      if (!*list){\n        fprintf(stderr, \"%s: memory allocation error (addtolist)\\n\",\n                progname);  \n        exit(EXIT_FAILURE);\n      }\n    }\n    (*list)[*count].name = rname;\n    if (strchr(def, PRIMITIVECHAR))\n      (*list)[*count].def = \"<primitive unit>\";\n    else\n      (*list)[*count].def = def;\n    (*count)++;\n    len = strwidth(name);\n    if (len>*maxnamelen)\n          *maxnamelen = len;\n  }\n  if (searchtype == CONFORMABLE)\n    freeunit(&want);\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "compnd": {
      "start_point": [
        3548,
        0
      ],
      "end_point": [
        3552,
        1
      ],
      "content": "int \ncompnd(const void *a, const void *b)\n{\n  return strcmp(((struct namedef *)a)->name, ((struct namedef *)b)->name);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "screensize": {
      "start_point": [
        3559,
        0
      ],
      "end_point": [
        3563,
        1
      ],
      "content": "int \nscreensize()\n{\n   return 20;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    },
    "tryallunits": {
      "start_point": [
        3572,
        0
      ],
      "end_point": [
        3648,
        1
      ],
      "content": "void \ntryallunits(struct unittype *have, char *searchstring)\n{\n  struct unitlist *uptr;\n  struct namedef *list;\n  int listsize, maxnamelen, count;\n  struct func *funcptr;\n  struct wantalias *aliasptr;\n  int i, j, searchtype;\n  FILE *outfile;\n  char *seploc, *firstunit;\n\n  list = (struct namedef *) mymalloc( 100 * sizeof(struct namedef), \n                                       \"(tryallunits)\");\n  listsize = 100;\n  maxnamelen = 0;\n  count = 0;\n\n  if (have)\n    searchtype = CONFORMABLE;\n  else {\n    if (!searchstring)\n      searchstring=\"\";\n    searchtype = TEXTMATCH;\n  }\n\n  for(i=0;i<HASHSIZE;i++)\n    for (uptr = utab[i]; uptr; uptr = uptr->next)\n      addtolist(have, searchstring, uptr->name, uptr->name, uptr->value, \n                &list, &listsize, &maxnamelen, &count, searchtype);\n  for(i=0;i<SIMPLEHASHSIZE;i++)\n    for(funcptr=ftab[i];funcptr;funcptr=funcptr->next){\n      if (funcptr->table) \n        addtolist(have, searchstring, funcptr->name, funcptr->tableunit, \n                \"<piecewise linear>\", &list, &listsize, &maxnamelen, &count, \n                searchtype);\n      else\n        addtolist(have, searchstring, funcptr->name, funcptr->inverse.dimen, \n                \"<nonlinear>\", &list, &listsize, &maxnamelen, &count, \n                searchtype);\n  }\n  for(aliasptr=firstalias;aliasptr;aliasptr=aliasptr->next){\n    firstunit = dupstr(aliasptr->definition);/* coverity[var_assigned] */\n    seploc = strchr(firstunit,UNITSEPCHAR);  /* Alias definitions allowed in */\n    *seploc = 0;                             /* database contain UNITSEPCHAR */\n    addtolist(have, searchstring, aliasptr->name, firstunit, \n              aliasptr->definition, &list, &listsize, &maxnamelen, &count,\n              searchtype);\n    free(firstunit);\n  }\n    \n  qsort(list, count, sizeof(struct namedef), compnd);\n\n  outfile = 0;\n  if (count==0)\n    puts(\"No matching units found.\");\n#ifdef SIGPIPE\n  signal(SIGPIPE, SIG_IGN);\n#endif\n  if (count>screensize()){\n    outfile = popen(pager, \"w\");\n  }\n  if (!outfile)\n    outfile = stdout;\n  for(i=0;i<count;i++){\n    fputs(list[i].name,outfile);\n    for(j=strwidth(list[i].name);j<=maxnamelen;j++)\n      putc(' ',outfile);\n    tightprint(outfile,list[i].def);\n    fputc('\\n',outfile);\n  }\n  if (outfile != stdout)\n    pclose(outfile);\n#ifdef SIGPIPE\n  signal(SIGPIPE, SIG_DFL);\n#endif\n}",
      "lines": 77,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "getuser_noreadline": {
      "start_point": [
        3663,
        0
      ],
      "end_point": [
        3687,
        1
      ],
      "content": "void\ngetuser_noreadline(char **buffer, int *bufsize, const char *query)\n{\n#ifdef SUPPORT_UTF8\n  int valid = 0;\n  while(!valid){\n    fputs(query, stdout);\n    if (!fgetslong(buffer, bufsize, stdin,0)){\n      if (!flags.quiet)\n        putchar('\\n');\n      exit(EXIT_SUCCESS);\n    }\n    valid = strwidth(*buffer)>=0;\n    if (!valid)\n      printf(\"Error: %s\\n\",invalid_utf8);\n  }\n#else\n  fputs(query, stdout);\n  if (!fgetslong(buffer, bufsize, stdin,0)){\n    if (!flags.quiet)\n      putchar('\\n');\n    exit(EXIT_SUCCESS);\n  }\n#endif\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "getuser_readline": {
      "start_point": [
        3694,
        0
      ],
      "end_point": [
        3716,
        1
      ],
      "content": "void\ngetuser_readline(char **buffer, int *bufsize, const char *query)\n{\n#ifdef SUPPORT_UTF8\n  int valid = 0;\n  while (!valid){\n    if (*buffer) free(*buffer);\n    *buffer = readline(query);\n    valid = !*buffer || strwidth(*buffer)>=0;\n    if (!valid)\n      printf(\"Error: %s\\n\",invalid_utf8);\n  }\n#else\n    if (*buffer) free(*buffer);\n    *buffer = readline(query);\n#endif\n  if (*buffer && **buffer) add_history(*buffer);\n  if (!*buffer){\n    if (!flags.quiet)\n       putchar('\\n');\n    exit(EXIT_SUCCESS);\n  }\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "getuser": {
      "start_point": [
        3719,
        0
      ],
      "end_point": [
        3726,
        1
      ],
      "content": "void\ngetuser(char **buffer, int *bufsize, const char *query)\n{\n  if (flags.readline)\n    getuser_readline(buffer,bufsize,query);\n  else\n    getuser_noreadline(buffer,bufsize,query);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "completeunits": {
      "start_point": [
        3746,
        0
      ],
      "end_point": [
        3850,
        1
      ],
      "content": "char *\ncompleteunits(char *text, int state)\n{\n  static int uhash, fhash, phash, checktype;\n  static struct prefixlist *curprefix, *unitprefix;\n  static struct unitlist *curunit;\n  static struct func *curfunc;\n  static struct wantalias *curalias;\n  static char **curbuiltin;\n  char *output = 0;\n\n#ifndef NO_SUPPRESS_APPEND\n  rl_completion_suppress_append = 1;\n#endif\n  \n  if (!state){     /* state == 0 means this is the first call, so initialize */\n    checktype = 0; /* start at first type */\n    fhash = uhash = phash = 0;\n    unitprefix=0; /* search for unit continuations starting with this prefix */\n    curfunc=ftab[fhash];\n    curunit=utab[uhash];\n    curprefix=ptab[phash];\n    curbuiltin = builtins;\n    curalias = firstalias;\n  }\n  while (checktype != CU_DONE){\n    if (checktype == CU_ALIAS){\n      while(curalias){\n        if (startswith(curalias->name,text))\n          output = dupstr(curalias->name);\n        curalias = curalias->next;\n        if (output) return output;\n      }\n      checktype++;\n    }\n    if (checktype == CU_BUILTIN){\n      while(*curbuiltin){\n        if (startswith(*curbuiltin,text))\n          output = dupstr(*curbuiltin);\n        curbuiltin++;\n        if (output) return output;\n      }\n      checktype++;\n    }\n    while (checktype == CU_FUNC){\n      while (!curfunc && fhash<SIMPLEHASHSIZE-1){\n        fhash++;\n        curfunc = ftab[fhash];\n      }\n      if (!curfunc) \n        checktype++;\n      else {\n        if (startswith(curfunc->name,text))\n          output = dupstr(curfunc->name);\n        curfunc = curfunc->next;\n        if (output) return output;  \n      }\n    }\n    while (checktype == CU_PREFIX){\n      while (!curprefix && phash<SIMPLEHASHSIZE-1){\n        phash++;\n        curprefix = ptab[phash];\n      }\n      if (!curprefix)\n        checktype++;\n      else {\n        if (startswith(curprefix->name,text))\n          output = dupstr(curprefix->name);\n        curprefix = curprefix->next;\n        if (output) return output;\n      }\n    }\n    while (checktype == CU_UNITS){    \n      while (!curunit && uhash<HASHSIZE-1){\n        uhash++;\n        curunit = utab[uhash];\n      }\n      /* If we're done with the units go through them again with */\n      /* the largest possible prefix stripped off */\n      if (!curunit && !unitprefix \n            && (unitprefix = plookup(text)) && strlen(unitprefix->name)>1){\n        uhash = 0;\n        curunit = utab[uhash];\n      }\n      if (!curunit) {\n        checktype++;\n        break;\n      }\n      if (unitprefix){\n        if (startswith(curunit->name, text+unitprefix->len)){\n          output = (char *)mymalloc(1+strlen(curunit->name)+unitprefix->len,\n                                    \"(completeunits)\");\n          strcpy(output, unitprefix->name);\n          strcat(output, curunit->name);\n        }       \n      } \n      else if (startswith(curunit->name,text)) \n        output = dupstr(curunit->name);\n      curunit=curunit->next;\n      if (output)\n        return output;\n    }\n  } \n  return 0;\n}",
      "lines": 105,
      "depth": 21,
      "decorators": [
        "char",
        "*\ncompleteunits(char *text, int state)",
        "*"
      ]
    },
    "checkcwd": {
      "start_point": [
        3857,
        0
      ],
      "end_point": [
        3886,
        1
      ],
      "content": "int\ncheckcwd (char *file)\n{\n  FILE *fp;\n  char *p;\n\n  fp = fopen(file, \"r\");\n  if (fp){\n    fclose(fp);\n    return 1;\n  }\n#ifdef _WIN32\n  else if (!((p = strrchr(file, '.')) && isexe(p))) {\n    char *pathname;\n\n    pathname = mymalloc(strlen(file) + strlen(EXE_EXT) + 1,\n                        \"(checkcwd)\");\n    strcpy(pathname, file);\n    strcat(pathname, EXE_EXT);\n    fp = fopen(pathname, \"r\");\n    free(pathname);\n    if (fp) {\n      fclose(fp);\n      return 1;\n    }\n  }\n#endif\n\n  return 0;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "getprogramname": {
      "start_point": [
        3893,
        0
      ],
      "end_point": [
        3907,
        1
      ],
      "content": "char *\ngetprogramname(char *path)\n{\n  size_t proglen;\n  char *p;\n\n  path = pathend(path);\n\n  /* get rid of filename extensions in Windows */\n  proglen = strlen(path);\n\n  if ((p = strrchr(path, '.')) && isexe(p))\n    proglen -= 4;\n  return dupnstr(path, proglen);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngetprogramname(char *path)",
        "*"
      ]
    },
    "getprogdir": {
      "start_point": [
        3913,
        0
      ],
      "end_point": [
        4009,
        1
      ],
      "content": "char *\ngetprogdir(char *progname, char **fullprogname)\n{\n  char *progdir = NULL;\n  char *p;\n\n#if defined (_WIN32) && defined (_MSC_VER)\n  char buf[FILENAME_MAX + 1];\n\n  /* get the full pathname of the current executable and be done with it */\n  /* TODO: is there way to do this with gcc? */\n\n  if (GetModuleFileName(NULL, buf, FILENAME_MAX + 1))\n    progdir = dupstr(buf);\n#endif\n\n  /* If path name is absolute or includes more than one component use it */\n\n  if (!progdir && (isfullpath(progname) || hasdirsep(progname)))\n    progdir = dupstr(progname);\n\n\n  /*\n  command.com and cmd.exe under Windows always run a program that's in the\n  current directory whether or not the current directory is in PATH, so we need\n  to check the current directory.\n\n  This could return a false positive if units is run from a Unix-like command\n  interpreter under Windows if the current directory is not in PATH but\n  contains 'units' or 'units.exe'\n  */\n#if defined (_WIN32) && !defined (_MSC_VER)\n  if (!progdir && checkcwd(progname)) \n      progdir = dupstr(progname);\n#endif\n\n  /* search PATH to find the executable */\n  if (!progdir) {\n    char *env;\n    env = getenv(\"PATH\");\n    if (env) {\n      /* search PATH */\n      char *direc, *direc_end, *pathname;\n      int len;\n      FILE *fp;\n\n      pathname = mymalloc(strlen(env)+strlen(progname)+strlen(EXE_EXT)+2,\n                                                         \"(getprogdir)\");\n      direc = env;\n      while (direc) {\n        direc_end = strchr(direc,PATHSEP);\n        if (!direc_end)\n          len = strlen(direc);\n        else \n          len = direc_end-direc;\n        strncpy(pathname, direc, len);\n        if (len>0) pathname[len++]='/';\n        strcpy(pathname+len, progname);\n        fp = fopen(pathname, \"r\");\n        if (fp){\n          progdir = dupstr(pathname);\n          break;\n        }\n#ifdef _WIN32\n        /*\n          executable may or may not have '.exe' suffix, so we need to\n          look for both\n        */\n        if (!((p = strrchr(pathname, '.')) && isexe(p))) {\n          strcat(pathname, EXE_EXT);\n          fp = fopen(pathname, \"r\");\n          if (fp){\n            progdir = dupstr(pathname);\n            break;\n          }\n        }\n#endif\n        direc = direc_end;\n        if (direc) direc++;\n      }\n      free(pathname);\n      if (fp)\n        fclose(fp);\n    }\n  }\n\n  if (!progdir) {\n    fprintf(stderr, \"%s: cannot find program directory\\n\", progname);\n    exit(EXIT_FAILURE);\n  }\n\n  *fullprogname = dupstr(progdir);      /* used by printversion() */\n  p = pathend(progdir);\n  *p = '\\0';  \n \n  return progdir; \n}",
      "lines": 97,
      "depth": 20,
      "decorators": [
        "char",
        "*\ngetprogdir(char *progname, char **fullprogname)",
        "*"
      ]
    },
    "getdatadir": {
      "start_point": [
        4016,
        0
      ],
      "end_point": [
        4042,
        1
      ],
      "content": "char *\ngetdatadir()\n{\n    int progdirlen;\n    char *p;\n\n    progdirlen = strlen(progdir);\n    datadir = (char *) mymalloc(progdirlen + strlen(DATADIR) + 2,\n                                \"(getdatadir)\");\n    strcpy(datadir, progdir);\n    if (isdirsep(progdir[progdirlen - 1]))\n      datadir[progdirlen - 1] = '\\0';   /* so pathend() can work */\n    p = pathend(datadir);\n    if ((strlen(p) == 3) && (tolower(p[0]) == 'b') \\\n       && (tolower(p[1]) == 'i') && (tolower(p[2]) == 'n')) {\n      p = DATADIR;\n      while (*p == '.')         /* ignore \"./\", \"../\" */\n        p++;\n      if (isdirsep(*p))\n        p++;\n      strcpy(pathend(datadir), p);\n      \n      return datadir;\n    }\n    else\n      return NULL;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "char",
        "*\ngetdatadir()",
        "*"
      ]
    },
    "findlocalemap": {
      "start_point": [
        4044,
        0
      ],
      "end_point": [
        4139,
        1
      ],
      "content": "char *\nfindlocalemap(int checkonly)\n{\n  FILE *map = NULL;\n  char *filename = NULL;\n  char *file;\n\n  /*\n      Try the environment variable UNITSLOCALEMAP, then the #defined\n      value LOCALEMAP, then the directory containing the units\n      executable, then the directory given by DATADIR (relative to the\n      directory with the executable), and finally, the directory\n      containing the units data file.\n\n  */\n  file = getenv(\"UNITSLOCALEMAP\");\n  if (file && *file) {\n    map = fopen(file,\"rt\");\n    if (!map) {\n      if (!checkonly) {\n        fprintf(stderr,\n                \"%s: cannot open locale map '%s'\\n  specified in UNITSLOCALEMAP environment variable. \",\n                progname, file);\n        perror((char *) NULL);\n      }\n      return NULL;\n    }\n    else\n      filename = dupstr(file);\n  }\n\n  if (!map) {\n    file = LOCALEMAP;\n    map = fopen(file,\"rt\");\n    if (map)\n      filename = dupstr(file);\n  }\n\n  if (!map && !progdir) {\n    if (!checkonly) {\n      fprintf(stderr,\n              \"%s: cannot find locale map--program directory not set\\n\",\n              progname);\n      exit(EXIT_FAILURE);\n    }\n    else\n      return NULL;\n  }\n\n  /* check the directory with the units executable */\n  if (!map) {\n    filename = (char *) mymalloc(strlen(progdir) + strlen(file) + 2,\n               \"(findlocalemap)\");\n    strcpy(filename, progdir);\n    strcat(filename, file);\n    map = fopen(filename,\"rt\");\n  }\n\n  if (!map && !emptystr(DATADIR)) {\n    /* check data directory relative to the units executable directory */\n\n    if (!datadir)\n      datadir = getdatadir();\n    if (datadir) {\n      if (filename)\n        free(filename);\n      filename = (char *) mymalloc(strlen(datadir) + strlen(DATADIR) + strlen(file) + 2,\n                                   \"(findlocalemap)\");\n      strcpy(filename, datadir);\n      strcat(filename, \"/\");\n      strcat(filename, file);\n      map = fopen(filename, \"rt\");\n    }\n  }\n\n  /* check the directory with the units data file  */\n  if (!map) {\n    if (filename)\n      free(filename);\n    filename = (char *) mymalloc(strlen(unitsfiles[0]) + strlen(file) + 2,\n               \"(findlocalemap)\");\n    strcpy(filename, unitsfiles[0]);\n    strcpy(pathend(filename), file);\n    map = fopen(filename,\"rt\");\n  }\n\n  if (map) {\n    fclose(map);\n    return filename;\n  }\n  else {\n    if (filename)\n      free(filename);\n    return NULL;\n  }\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "char",
        "*\nfindlocalemap(int checkonly)",
        "*"
      ]
    },
    "findunitsfile": {
      "start_point": [
        4143,
        0
      ],
      "end_point": [
        4223,
        1
      ],
      "content": "char *\nfindunitsfile(int noerrmsg)\n{\n  FILE *testfile=0;\n  char *file;\n\n  file = getenv(\"UNITSFILE\");\n  if (file && *file) {\n    testfile = fopen(file, \"rt\");\n    if (!testfile) {\n      if (!noerrmsg) {\n        fprintf(stderr,\n                \"%s: cannot open units file '%s' in environment variable UNITSFILE.  \",\n                progname, file);\n        perror((char *) NULL);\n      }\n      return NULL;\n    }\n  }\n\n  if (!testfile && isfullpath(UNITSFILE)){\n    file = UNITSFILE;\n    testfile = fopen(file, \"rt\");\n    if (!testfile) {\n      if (!noerrmsg) {\n        fprintf(stderr,\n                \"%s: cannot open units data file '%s'.  \", progname, UNITSFILE);\n        perror((char *) NULL);\n      }\n      return NULL;\n    }\n  }      \n\n  if (!testfile && !progdir) {\n    if (!noerrmsg) {\n      fprintf(stderr,\n              \"%s: cannot open units file '%s' and cannot find program directory.\\n\", progname, UNITSFILE);\n      perror((char *) NULL);\n    }\n    return NULL;\n  }\n\n  if (!testfile) {\n    /* check the directory containing the units executable */\n    file = (char *) mymalloc(strlen(progdir)+strlen(UNITSFILE)+1,\n                             \"(findunitsfile)\");\n    strcpy(file, progdir);\n    strcat(file, UNITSFILE);\n    testfile = fopen(file, \"rt\");\n    if (!testfile)\n      free(file);\n  }\n\n  if (!testfile && !emptystr(DATADIR)) {\n    /* check data directory relative to the units executable directory */\n\n    if (!datadir)\n      datadir = getdatadir();\n    if (datadir) {\n      file = (char *) mymalloc(strlen(datadir) + strlen(UNITSFILE) + 2,\n                               \"(findunitsfile)\");\n      strcpy(file, datadir);\n      strcat(file, \"/\");\n      strcat(file, UNITSFILE);\n\n      testfile = fopen(file, \"rt\");\n      if (!testfile)\n        free(file);\n    }\n  }\n\n  if (!testfile) {\n    if (!noerrmsg)\n      fprintf(stderr,\"%s: cannot find units file '%s'\\n\", progname, UNITSFILE);\n     return NULL;\n  }\n  else {\n    fclose(testfile);\n    return file;\n  }\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "char",
        "*\nfindunitsfile(int noerrmsg)",
        "*"
      ]
    },
    "personalfile": {
      "start_point": [
        4236,
        0
      ],
      "end_point": [
        4319,
        1
      ],
      "content": "char *\npersonalfile(const char *envname, const char *basename,\n             int checkonly, int *exists)\n{\n  FILE *testfile=0;\n  char *homedir, *filename=0;\n\n  *exists = 0; \n\n  /* First check the specified environment variable for a file name */ \n\n  if (envname) \n    filename = getenv(envname);\n  if (filename && *filename){         /* environment variable exists */\n    testfile = fopen(filename, \"rt\");\n    if (testfile){\n      fclose(testfile);\n      *exists = 1;\n      return filename;\n    }\n    if (checkonly)  return filename;\n    else {\n      fprintf(stderr, \"%s: cannot open file '%s' specified in %s environment variable. \", progname, filename, envname);\n      perror((char *) NULL);\n      return 0;\n    }\n  }\n\n  /* The environment variable was not set so identify the user's home\n  directory.  Under Windows if HOME is set we assume it's meant to override\n  HOMEDRIVE, HOMEPATH, and USERPROFILE  */\n\n  homedir = getenv(\"HOME\");\n  if (homedir) {\n    filename = mymalloc(strlen(homedir)+strlen(basename)+2,\n                        \"(personalfile)\");\n    strcpy(filename,homedir);\n  }\n  else \n#ifndef _WIN32\n  { /* If not running Windows there is nothing else to try */\n    return 0; \n  }\n#else  \n  { /* If running Windows try a few other places */\n    /* try HOMEDRIVE and HOMEPATH */\n    char *homedrive, *homepath;\n    if ((homedrive = getenv(\"HOMEDRIVE\")) && (homepath = getenv(\"HOMEPATH\"))) {\n        filename = mymalloc(strlen(homedrive)+strlen(homepath)\n                           +strlen(basename)+2,\"(personalfile)\");\n        strcpy(filename,homedrive);\n        strcat(filename,homepath);\n    }\n    /* finally, try USERPROFILE */\n    else if ((homedir = getenv(\"USERPROFILE\"))) {\n        filename = mymalloc(strlen(homedir)+strlen(basename)+2,\n                            \"(personalfile)\");\n        strcpy(filename,homedir);\n    }\n    else return 0;\n  }\n#endif  /* _WIN32 */\n\n  /* With home directory in hand we now look for the file */\n\n  strcat(filename,\"/\");\n  strcat(filename,basename);\n\n  testfile = fopen(filename, \"rt\");\n  if (testfile){\n    fclose(testfile);\n    *exists = 1;\n    return filename;\n  }\n  if (checkonly) return filename;\n  else {\n    if (errno==EACCES) {\n      fprintf(stderr,\"%s: cannot read file '%s'.  \",progname,filename);\n      perror(0);\n    }\n    free(filename);\n    return 0;\n  }\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "char",
        "*\npersonalfile(const char *envname, const char *basename,\n             int checkonly, int *exists)",
        "*"
      ]
    },
    "usage": {
      "start_point": [
        4325,
        0
      ],
      "end_point": [
        4376,
        1
      ],
      "content": "void \nusage()\n{\n   char *unitsfile;\n\n   /* nonzero argument suppresses error messages */\n   unitsfile = findunitsfile(1);\n\n   printf(\"\\nUsage: %s [options] ['from-unit' 'to-unit']\\n\",progname);\n   printf(\"\\n\\\nOptions:\\n\\\n    -h, --help           show this help and exit\\n\\\n    -c, --check          check that all units reduce to primitive units\\n\\\n        --check-verbose  like --check, but lists units as they are checked\\n\\\n        --verbose-check    so you can find units that cause endless loops\\n\\\n    -d, --digits         show output to specified number of digits (default: %d)\\n\\\n    -e, --exponential    exponential format output\\n\\\n    -f, --file           specify a units data file (-f '' loads default file)\\n\",\n          DEFAULTPRECISION);\n#ifdef READLINE\n   printf(\"\\\n    -H, --history        specify readline history file (-H '' disables history)\\n\");\n#endif\n   printf(\"\\\n    -L, --log            specify a file to log conversions\\n\\\n    -l, --locale         specify a desired locale\\n\\\n    -m, --minus          make - into a subtraction operator (default)\\n\\\n        --oldstar        use old '*' precedence, higher than '/'\\n\\\n        --newstar        use new '*' precedence, equal to '/'\\n\\\n    -n, --nolists        disable conversion to unit lists\\n\\\n    -S, --show-factor    show non-unity factor before 1|x in multi-unit output\\n\\\n    -o, --output-format  specify printf numeric output format (default: %%.%d%c)\\n\\\n    -p, --product        make '-' into a product operator\\n\\\n    -q, --quiet          suppress prompting\\n\\\n        --silent         same as --quiet\\n\\\n    -s, --strict         suppress reciprocal unit conversion (e.g. Hz<->s)\\n\\\n    -v, --verbose        show slightly more verbose output\\n\\\n        --compact        suppress printing of tab, '*', and '/' character\\n\\\n    -1, --one-line       suppress the second line of output\\n\\\n    -t, --terse          terse output (--strict --compact --quiet --one-line)\\n\\\n    -r, --round          round last element of unit list output to an integer\\n\\\n    -U, --unitsfile      show units data filename and exit\\n\\\n    -V, --version        show version, data filenames (with -t: version only)\\n\\\n    -I, --info           show version, files, and program properties\\n\",\n           DEFAULTTYPE,DEFAULTPRECISION);\n\n   if (!unitsfile)\n     printf(\"Units data file '%s' not found.\\n\\n\", UNITSFILE);\n   else\n     printf(\"To learn about the available units look in '%s'\\n\\n\", unitsfile);\n   puts(\"Report bugs to adrianm@gnu.org.\\n\\n\");\n}",
      "lines": 52,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "helpmsg": {
      "start_point": [
        4380,
        0
      ],
      "end_point": [
        4385,
        1
      ],
      "content": "void \nhelpmsg()\n{\n  fprintf(stderr,\"\\nTry '%s --help' for more information.\\n\",progname);\n  exit(EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "printversion": {
      "start_point": [
        4389,
        0
      ],
      "end_point": [
        4495,
        1
      ],
      "content": "void\nprintversion()\n{\n  int exists;\n  char *unitsfile, *localemap;\n\n  if (flags.verbose == 0) {\n    printf(\"GNU Units version %s\\n\", VERSION);\n    return;\n  }\n\n  printf(\"GNU Units version %s\\n%s, %s, locale %s\\n\",\n         VERSION, RVERSTR,UTF8VERSTR,mylocale);\n#if defined (_WIN32) && defined (HAVE_MKS_TOOLKIT)\n  puts(\"With MKS Toolkit\");\n#endif\n\n  if (flags.verbose == 2) {\n    if (!fullprogname)\n      getprogdir(progname, &fullprogname);\n    if (fullprogname)\n      printf(\"\\n%s program is %s\\n\", progname, fullprogname);\n  }\n\n  /* units data file */\n  if (flags.verbose == 2) {\n    putchar('\\n');\n    unitsfile = getenv(\"UNITSFILE\");\n    if (unitsfile)\n      printf(\"Environment variable UNITSFILE set to '%s'\\n\", unitsfile);\n    else\n      puts(\"Environment variable UNITSFILE not set\");\n\n    if (isfullpath(UNITSFILE))\n      printf(\"Default units data file is '%s'\\n\", UNITSFILE);\n    else\n      printf(\"Default units data file is '%s';\\n  %s will search for this file\\n\",\n             UNITSFILE, progname);\n  }\n\n  unitsfile = findunitsfile(1);\n  if (unitsfile && flags.verbose == 2 && !isfullpath(UNITSFILE))\n    printf(\"Found data file '%s'\\n\", unitsfile);\n  else if (unitsfile)\n    printf(\"Units data file is '%s'\\n\", unitsfile);\n  else\n    puts(\"*** Units data file not found ***\");\n\n  /* personal units data file */\n  if (flags.verbose == 2) {\n    putchar('\\n');\n    unitsfile = getenv(HOME_UNITS_ENV);\n    if (unitsfile)\n      printf(\"Environment variable %s set to '%s'\\n\", HOME_UNITS_ENV,unitsfile);\n    else\n      printf(\"Environment variable %s not set\\n\", HOME_UNITS_ENV);\n  }\n\n  unitsfile = personalfile(HOME_UNITS_ENV, homeunitsfile, 1, &exists);\n  if (unitsfile) {\n    printf(\"Personal units data file is '%s'\", unitsfile);\n    if (!exists)\n      puts(\"\\n  (file does not exist)\");\n    else\n      putchar('\\n');\n  }\n  else\n    puts(\"Personal units data file not found: no home directory\");\n\n#ifdef READLINE\n  if (flags.verbose == 2) {\n    historyfile = personalfile(NULL,HISTORY_FILE,1,&exists);\n    if (historyfile)\n      printf(\"\\nDefault readline history file is '%s'\\n\", historyfile);\n    else \n      puts(\"\\nReadline history file unusable: no home directory\");\n  }\n#endif\n\n#ifdef _WIN32\n  /* locale map */\n  if (flags.verbose == 2) {\n    putchar('\\n');\n    localemap = getenv(\"UNITSLOCALEMAP\");\n    if (localemap)\n      printf(\"Environment variable UNITSLOCALEMAP set to '%s'\\n\", localemap);\n    else\n      puts(\"Environment variable UNITSLOCALEMAP not set\");\n\n    if (isfullpath(LOCALEMAP))\n      printf(\"Default locale map is '%s'\\n\", LOCALEMAP);\n    else\n      printf(\"Default locale map is '%s';\\n  %s will search for this file\\n\",\n             LOCALEMAP, progname);\n\n    localemap = findlocalemap(1);\n    if (localemap && !isfullpath(LOCALEMAP))\n      printf(\"Found locale map '%s'\\n\", localemap);\n    else if (localemap)\n      printf(\"Locale map is '%s'\\n\", localemap);\n    else\n      puts(\"*** Locale map not found ***\");\n  }\n#endif\n\n  printf(\"\\n\\n%s\\n\\n\", LICENSE);\n}",
      "lines": 107,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "showunitsfile": {
      "start_point": [
        4497,
        0
      ],
      "end_point": [
        4506,
        1
      ],
      "content": "void\nshowunitsfile()\n{\n  char *unitsfile;\n  unitsfile = findunitsfile(1);\n  if (unitsfile)\n    printf(\"%s\\n\", unitsfile);\n  else\n    puts(\"Units data file not found\");\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "processargs": {
      "start_point": [
        4552,
        0
      ],
      "end_point": [
        4699,
        1
      ],
      "content": "int\nprocessargs(int argc, char **argv, char **from, char **to)\n{\n   extern char *optarg;\n   extern int optind;\n   int optchar, optindex;\n   int ind;\n   int doprintversion=0;\n\n   while ( -1 != \n      (optchar = \n         getopt_long(argc, argv,shortoptions,longoptions, &optindex ))) {\n      switch (optchar) {\n         case 'm':\n            parserflags.minusminus = 1;\n            break;\n         case 'p':\n            parserflags.minusminus = 0;\n            break;\n         case 't':\n            flags.oneline = 1;\n            flags.quiet = 1;\n            flags.strictconvert = 1;\n            flags.verbose = 0;\n            break;\n\n         /* numeric output format */\n         case 'd':\n            if (checksigdigits(optarg) < 0)\n              exit(EXIT_FAILURE);\n            else    /* ignore anything given with 'o' option */\n              num_format.format = NULL; \n            break;\n         case 'e':  /* ignore anything given with 'o' option */\n            num_format.format = NULL;   \n            num_format.type = 'e';\n            break;\n         case 'o':\n            num_format.format = optarg;\n            break;\n\n         case 'c':\n            flags.unitcheck = 1;\n            break;\n         case 'f':\n            for(ind=0;unitsfiles[ind];ind++); \n            if (ind==MAXFILES){\n              fprintf(stderr, \"At most %d -f specifications are allowed\\n\",\n                      MAXFILES);\n              exit(EXIT_FAILURE);\n            }\n            if (optarg && *optarg)\n              unitsfiles[ind] = optarg;\n            else {\n              unitsfiles[ind] = findunitsfile(0);\n              if (!unitsfiles[ind]) \n                exit(EXIT_FAILURE);\n            }\n            unitsfiles[ind+1] = 0;\n            break;\n         case 'L':\n            logfilename = optarg;\n            break;\n         case 'l':\n            mylocale = optarg;\n            break;\n         case 'n':\n            flags.unitlists = 0;\n            break;\n         case 'q':\n            flags.quiet = 1;\n            break; \n         case 'r':\n            flags.round = 1;\n            break;\n         case 'S':\n            flags.showfactor = 1;\n            break;\n         case 's':\n            flags.strictconvert = 1;\n            break;\n         case 'v':\n            flags.verbose = 2;\n            break;\n         case '1':\n            flags.oneline = 1;\n            break;\n         case 'I':\n            flags.verbose = 2;  /* fall through */\n         case 'V':\n            doprintversion = 1;\n            break;\n         case 'U':\n            showunitsfile();\n            exit(EXIT_SUCCESS);\n            break;\n         case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n#ifdef READLINE     \n         case 'H':\n           if (emptystr(optarg))\n              historyfile=NULL;\n            else\n              historyfile = optarg;\n            break;\n#endif      \n         case 0: break;  /* This is reached if a long option is \n                            processed with no return value set. */\n         case '?':        /* Invalid option or missing argument returns '?' */\n         default:\n            helpmsg();    /* helpmsg() exits with error */\n      } \n   }\n\n   if (doprintversion){\n     printversion();\n     exit(EXIT_SUCCESS);\n   }\n\n   if (flags.unitcheck) {\n     if (optind != argc){\n       fprintf(stderr, \n               \"Too many arguments (arguments are not allowed with -c).\\n\");\n       helpmsg();         /* helpmsg() exits with error */\n     }\n   } else {\n     if (optind == argc - 2) {\n        flags.quiet=1;\n        *from = argv[optind];\n        *to = dupstr(argv[optind+1]); /* This string may get rewritten later */\n        return 0;                     /* and we might call free() on it      */\n     }\n\n     if (optind == argc - 1) {\n        flags.quiet=1;\n        *from = argv[optind];\n        *to=0;\n        return 0;\n     }\n     if (optind < argc - 2) {\n        fprintf(stderr,\"Too many arguments (maybe you need quotes).\\n\");\n        helpmsg();             /* helpmsg() exits with error */\n     }\n   }\n\n   return 1;\n}",
      "lines": 148,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "showpointer": {
      "start_point": [
        4707,
        0
      ],
      "end_point": [
        4714,
        1
      ],
      "content": "void\nshowpointer(int position)\n{\n  if (position >= 0){\n    while (position--) putchar(' ');\n    puts(\"^\");\n  }\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "processunit": {
      "start_point": [
        4727,
        0
      ],
      "end_point": [
        4766,
        1
      ],
      "content": "int \nprocessunit(struct unittype *theunit, char *unitstr, int promptlen)\n{\n  char *errmsg;\n  int errloc,err;\n  char savechar;\n\n  if (flags.unitlists && strchr(unitstr, UNITSEPCHAR)){\n    puts(\"Unit list not allowed\");\n    return 1;\n  }\n  if ((err=parseunit(theunit, unitstr, &errmsg, &errloc))){\n    if (promptlen >= 0){\n      if (err!=E_UNKNOWNUNIT || !irreducible){\n        if (errloc>0) {\n          savechar = unitstr[errloc];\n          unitstr[errloc] = 0;\n          showpointer(promptlen+strwidth(unitstr)-1);\n          unitstr[errloc] = savechar;\n        } \n        else showpointer(promptlen);\n      }\n    }\n    else\n      printf(\"Error in '%s': \", unitstr);\n    fputs(errmsg,stdout);\n    if (err==E_UNKNOWNUNIT && irreducible)\n      printf(\" '%s'\", irreducible);\n    putchar('\\n');\n    return 1;\n  }\n  if ((err=completereduce(theunit))){\n    fputs(errormsg[err],stdout);\n    if (err==E_UNKNOWNUNIT)\n      printf(\" '%s'\", irreducible);\n    putchar('\\n');\n    return 1;\n  }\n  return 0;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "checkunitlist": {
      "start_point": [
        4786,
        0
      ],
      "end_point": [
        4870,
        1
      ],
      "content": "int\ncheckunitlist(char *unitstr, int promptlen)\n{\n  struct unittype unit[2], one;\n  char *firstunitstr,*nextunitstr;\n  int unitidx = 0;\n\n  int printerror = promptlen != NOERRMSG;\n\n  initializeunit(&one);\n\n  firstunitstr = unitstr;\n\n  initializeunit(unit);\n  initializeunit(unit+1);\n\n  while (unitstr) {\n    if ((nextunitstr = strchr(unitstr, UNITSEPCHAR)) != 0)\n      *nextunitstr = '\\0';\n\n    if (!unitstr[strspn(unitstr, \" \")]) {  /* unitstr is blank */\n      if (!nextunitstr) {  /* terminal UNITSEPCHAR indicates repetition */\n        freeunit(unit);    /* of last unit and is permitted */\n        return 0;\n      }\n      else {               /* internal blank units are not allowed */\n        if (printerror){\n          showpointer(promptlen);\n          puts(\"Error: blank unit not allowed\");\n        }\n        freeunit(unit);\n        return 1;\n      }\n    }\n\n    /* processunit() prints error messages; avoid it to supress them */\n\n    if ((printerror && processunit(unit+unitidx,unitstr,promptlen)) ||\n        (!printerror && \n           (parseunit(unit+unitidx, unitstr,0,0) \n             || completereduce(unit+unitidx) \n             || compareunits(unit+unitidx,&one, ignore_primitive)))){\n      if (printerror)\n        printf(\"Error in unit list entry: %s\\n\",unitstr);\n      freeunit(unit);\n      freeunit(unit+1);\n      return 1;\n    }\n\n    if (unitidx == 0)\n      unitidx = 1;\n    else {\n      if (compareunits(unit, unit+1, ignore_dimless)){\n        if (printerror){\n          int wasverbose = flags.verbose;\n          FILE *savelog = logfile;\n          logfile=0;\n          flags.verbose = 2;   /* always use verbose form to be unambiguous */\n                               /* coverity[returned_null] */\n          *(strchr(firstunitstr, UNITSEPCHAR)) = '\\0';\n          removespaces(firstunitstr);\n          removespaces(unitstr);\n          showpointer(promptlen);\n          showconformabilityerr(firstunitstr, unit, unitstr, unit+1);\n          flags.verbose = wasverbose;\n          logfile = savelog;\n        }\n        freeunit(unit);\n        freeunit(unit+1);\n        return 1;\n      }\n      freeunit(unit+1);\n    }\n\n    if (nextunitstr) {\n      if (promptlen >= 0) promptlen += strwidth(unitstr)+1;\n      *(nextunitstr++) = UNITSEPCHAR;\n    }\n    unitstr = nextunitstr;\n  }\n\n  freeunit(unit);\n\n  return 0;\n}",
      "lines": 85,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "processwant": {
      "start_point": [
        4884,
        0
      ],
      "end_point": [
        4891,
        1
      ],
      "content": "int\nprocesswant(struct unittype *theunit, char *unitstr, int promptlen)\n{\n  if (flags.unitlists && strchr(unitstr, UNITSEPCHAR))\n    return checkunitlist(unitstr, promptlen);\n  else\n    return processunit(theunit, unitstr, promptlen);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "checkallaliases": {
      "start_point": [
        4894,
        0
      ],
      "end_point": [
        4909,
        1
      ],
      "content": "void\ncheckallaliases(int verbose)\n{\n  struct wantalias *aliasptr;\n\n  for(aliasptr = firstalias; aliasptr; aliasptr=aliasptr->next){\n    if (verbose)\n      printf(\"doing unit list '%s'\\n\", aliasptr->name);\n    if (checkunitlist(aliasptr->definition,NOERRMSG))\n      printf(\"Unit list '%s' contains errors\\n\", aliasptr->name);\n    if (ulookup(aliasptr->name))\n      printf(\"Unit list '%s' hides a unit definition.\\n\", aliasptr->name);\n    if (fnlookup(aliasptr->name))\n      printf(\"Unit list '%s' hides a function definition.\\n\", aliasptr->name);\n  }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "checkunits": {
      "start_point": [
        4921,
        0
      ],
      "end_point": [
        5001,
        1
      ],
      "content": "void \ncheckunits(int verbosecheck)\n{\n  struct unittype have,second,one;\n  struct unitlist *uptr;\n  struct prefixlist *pptr;\n  struct func *funcptr;\n  char *prefixbuf, *testunit;\n  int i;\n\n  initializeunit(&one);\n\n  /* Check all functions for valid definition and correct inverse */\n  \n  for(i=0;i<SIMPLEHASHSIZE;i++)\n    for(funcptr=ftab[i];funcptr;funcptr=funcptr->next)\n      checkfunc(funcptr, verbosecheck);\n\n  checkallaliases(verbosecheck);\n\n  /* Now check all units for validity */\n\n  for(i=0;i<HASHSIZE;i++)\n    for (uptr = utab[i]; uptr; uptr = uptr->next){\n      if (verbosecheck)\n        printf(\"doing '%s'\\n\",uptr->name);\n      if (parseunit(&have, uptr->name,0,0) \n          || completereduce(&have) \n          || compareunits(&have,&one, ignore_primitive)){\n        if (fnlookup(uptr->name)) \n          printf(\"Unit '%s' hidden by function '%s'\\n\", uptr->name, uptr->name);\n        else\n          printf(\"'%s' defined as '%s' irreducible\\n\",uptr->name, uptr->value);\n      } else {\n        parserflags.minusminus = !parserflags.minusminus; \n                                                 /* coverity[check_return] */\n        parseunit(&second, uptr->name, 0, 0);    /* coverity[check_return] */\n        completereduce(&second);     /* Can't fail because it worked above */\n        if (compareunits(&have, &second, ignore_nothing)){\n          printf(\"'%s': replace '-' with '+-' for subtraction or '*' to multiply\\n\", uptr->name);\n        }\n        freeunit(&second);\n        parserflags.minusminus=!parserflags.minusminus;\n      }\n\n      freeunit(&have);\n    }\n\n  /* Check prefixes */ \n\n  testunit=\"meter\";\n  for(i=0;i<SIMPLEHASHSIZE;i++)\n    for(pptr = ptab[i]; pptr; pptr = pptr->next){\n      if (verbosecheck)\n        printf(\"doing '%s-'\\n\",pptr->name);\n      prefixbuf = mymalloc(strlen(pptr->name) + strlen(testunit) + 1,\n                           \"(checkunits)\");\n      strcpy(prefixbuf,pptr->name);\n      strcat(prefixbuf,testunit);\n      if (parseunit(&have, prefixbuf,0,0) || completereduce(&have) || \n          compareunits(&have,&one,ignore_primitive))\n        printf(\"'%s-' defined as '%s' irreducible\\n\",pptr->name, pptr->value);\n      else { \n        int plevel;    /* check for bad '/' character in prefix */\n        char *ch;\n        plevel = 0;\n        for(ch=pptr->value;*ch;ch++){\n          if (*ch==')') plevel--;\n          else if (*ch=='(') plevel++;\n          else if (plevel==0 && *ch=='/'){\n            printf(\n              \"'%s-' defined as '%s' contains a bad '/'. (Add parentheses.)\\n\",\n              pptr->name, pptr->value);\n            break;\n          }\n        }           \n      }  \n      freeunit(&have);\n      free(prefixbuf);\n    }\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "showunitlist": {
      "start_point": [
        5012,
        0
      ],
      "end_point": [
        5141,
        1
      ],
      "content": "int\nshowunitlist(char *havestr, struct unittype *have, char *wantstr)\n{\n  struct unittype want, lastwant;\n  char *lastunitstr, *nextunitstr, *lastwantstr=0;\n  double remainder;     /* portion of have->factor remaining */\n  double round_dir;     /* direction of rounding */\n  double value;         /* value (rounded to integer with 'r' option) */\n  int firstunit = 1;    /* first unit in a multi-unit string */\n  int value_shown = 0;  /* has a value been shown? */\n\n  initializeunit(&want);\n  remainder = have->factor;\n  lastunitstr = 0;\n  nextunitstr = 0;\n  round_dir = 0;\n\n  if (flags.round) {\n    /* disable unit repetition with terminal UNITSEPCHAR when rounding */\n    if (lastchar(wantstr) == UNITSEPCHAR)\n      lastchar(wantstr) = 0;\n    if ((lastwantstr = strrchr(wantstr, UNITSEPCHAR)))\n      lastwantstr++;\n  }\n\n  while (wantstr) {\n    if ((nextunitstr = strchr(wantstr, UNITSEPCHAR)))\n      *(nextunitstr++) = '\\0';\n    removespaces(wantstr);\n\n    /*\n      if wantstr ends in UNITSEPCHAR, repeat last unit--to give integer\n      and fractional parts (3 oz + 0.371241 oz rather than 3.371241 oz)\n    */\n    if (emptystr(wantstr))              /* coverity[alias_transfer] */\n      wantstr = lastunitstr;\n\n    if (processunit(&want, wantstr, NOPOINT)) {\n      freeunit(&want);\n      return 1;\n    }\n\n    if (firstunit){\n      /* checkunitlist() ensures conformability within 'wantstr',\n         so we just need to check the first unit to see if it conforms\n         to 'have' */\n      if (compareunits(have, &want, ignore_dimless)) {\n        showconformabilityerr(havestr, have, wantstr, &want);\n        freeunit(&want);\n        return 1;\n      }\n\n      /* round to nearest integral multiple of last unit */\n      if (flags.round) {\n        value = remainder;\n        if (lastwantstr && *lastwantstr) {      /* more than one unit */\n          removespaces(lastwantstr);\n          initializeunit(&lastwant);\n          if (processunit(&lastwant, lastwantstr, NOPOINT)) {\n            freeunit(&lastwant);\n            return 1;\n          }\n          remainder = floor(remainder / lastwant.factor + 0.5) * lastwant.factor;\n        }\n        else    /* first unit is last unit */\n          remainder = floor(remainder / want.factor + 0.5) * want.factor;\n\n        round_dir = remainder - value;\n      }\n      if (flags.verbose == 2) {\n        removespaces(havestr);\n        logprintf(\"\\t%s = \", havestr);\n      } else if (flags.verbose == 1)\n        logputchar('\\t');\n    } /* end if first unit */\n\n    if (nextunitstr) {\n      remainder = want.factor * modf(remainder / want.factor, &value);\n      if (round_to_displayed(remainder / want.factor, NULL) == 1) {\n        value++;               /* at displayed precision, value rounds up */\n        remainder = 0;         /* and remainder is zero */\n      }\n      else if (fabs(remainder / have->factor) < DBL_EPSILON)\n        remainder = 0;              /* remainder is just rounding error */\n    }\n    else {      /* last unit */\n      value = remainder / want.factor;\n      if (!flags.round) {    /* round to displayed precision */\n        value = round_to_displayed(value, NULL);\n      }\n    }\n    if (!flags.verbose){\n      if (!firstunit) \n        logputchar(UNITSEPCHAR);\n      logprintf(num_format.format,value);\n      value_shown=1;\n    } else { /* verbose case */\n      if (value != 0) {\n        if (value_shown) /* have already displayed a number so need a '+' */\n          logputs(\" + \");\n        showunitname(value, wantstr, PRINTNUM);\n      value_shown=1;\n      }\n    }\n    freeunit(&want);\n    lastunitstr = wantstr;\n    wantstr = nextunitstr;\n    firstunit = 0;\n  }\n\n  /* if the final unit value was rounded print indication */\n  if (!value_shown) {  /* provide output if every value rounded to zero */\n    logputs(\"0 \");\n    if (isdecimal(*lastunitstr))\n      logputs(\"* \");\n    logputs(lastunitstr);\n  }\n\n  if (round_dir != 0) {\n    if (flags.verbose){\n      if (round_dir > 0)\n        logprintf(\" (rounded up to nearest %s) \", lastunitstr);\n      else\n        logprintf(\" (rounded down to nearest %s) \", lastunitstr);\n    } else \n      logprintf(\"%c%c\", UNITSEPCHAR, round_dir > 0 ?'-':'+');   \n  }\n  logputchar('\\n');\n  return 0;\n}",
      "lines": 130,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "ismksmore": {
      "start_point": [
        5145,
        0
      ],
      "end_point": [
        5226,
        1
      ],
      "content": "int\nismksmore(char *pager)\n{\n    static int mksmore = -1;\n\n    if (mksmore >= 0)\n      return mksmore;\n\n    /*\n      Tries to determine whether the MKS Toolkit version of more(1) or\n      less(1) will run.  Neither accepts '+<lineno>', so if either will\n      run, we need to give the option as '+<lineno>g'.\n    */\n    if (strstr(pager, \"more\") || strstr(pager, \"less\")) {\n      char *mypager, *mkspager, *mksroot, *p;\n      char pathbuf[FILENAME_MAX + 1];\n      struct _stat mybuf, mksbuf;\n\n      mypager = NULL;\n      mkspager = NULL;\n      mksmore = 0;\n      if (strlen(pager) > FILENAME_MAX) {\n        fprintf(stderr, \"%s: cannot invoke pager--value '%s' in PAGER too long\\n\",\n                progname, pager);\n        return 0;       /* TODO: this really isn't the right value */\n      }\n      else if (!isfullpath(pager)) {\n        mypager = (char *) mymalloc(strlen(pager) + strlen(EXE_EXT) + 1, \"(ishelpquery)\");\n        strcpy(mypager, pager);\n        if (!((p = strrchr(mypager, '.')) && isexe(p)))\n          strcat(mypager, EXE_EXT);\n\n        _searchenv(mypager, \"PATH\", pathbuf);\n      }\n      else\n        strcpy(pathbuf, pager);\n\n      mksroot = getenv(\"ROOTDIR\");\n      if (mksroot) {\n        char * mksprog;\n\n        if (strstr(pager, \"more\"))\n          mksprog = \"more.exe\";\n        else\n          mksprog = \"less.exe\";\n        mkspager = (char *) mymalloc(strlen(mksroot) + strlen(\"/mksnt/\") + strlen(mksprog) + 1,\n                                     \"(ishelpquery)\");\n        strcpy(mkspager, mksroot);\n        strcat(mkspager, \"/mksnt/\");\n        strcat(mkspager, mksprog);\n      }\n\n      if (*pathbuf && mksroot) {\n        if (_stat(mkspager, &mksbuf)) {\n          fprintf(stderr, \"%s: cannot stat file '%s'. \", progname, mkspager);\n          perror((char *) NULL);\n          return 0;\n        }\n        if (_stat(pathbuf, &mybuf)) {\n          fprintf(stderr, \"%s: cannot stat file '%s'. \", progname, pathbuf);\n          perror((char *) NULL);\n          return 0;\n        }\n        /*\n          if we had inodes, this would be simple ... but if it walks\n          like a duck and swims like a duck and quacks like a duck ...\n        */\n        if (mybuf.st_size   == mksbuf.st_size\n          && mybuf.st_ctime == mksbuf.st_ctime\n          && mybuf.st_mtime == mksbuf.st_mtime\n          && mybuf.st_atime == mksbuf.st_atime\n          && mybuf.st_mode  == mksbuf.st_mode)\n            mksmore = 1;\n      }\n      if (mypager)\n        free(mypager);\n      if (mkspager)\n        free(mkspager);\n    }\n\n    return mksmore;\n}",
      "lines": 82,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "ishelpquery": {
      "start_point": [
        5235,
        0
      ],
      "end_point": [
        5350,
        1
      ],
      "content": "int\nishelpquery(char *str, struct unittype *have)\n{\n  struct unitlist *unit;\n  struct func *function;\n  struct wantalias *alias;\n  struct prefixlist *prefix;\n  char commandbuf[1000];  /* Hopefully this is enough overkill as no bounds */\n  int unitline;           /* checking is performed. */\n  char *file;\n  \n  if (have && !strcmp(str, UNITMATCH)){\n    tryallunits(have,0);\n    return 1;\n  }\n  if (startswith(str, SEARCHCOMMAND)){\n    str+=strlen(SEARCHCOMMAND);\n    if (!emptystr(str) && *str != ' ')\n      return 0;\n    removespaces(str);\n    if (emptystr(str)){\n      printf(\"\\n\\\nType 'search text' to see a list of all unit names \\n\\\ncontaining 'text' as a substring\\n\\n\");\n      return 1;\n    }\n    tryallunits(0,str);\n    return 1;\n  }\n  if (startswith(str, HELPCOMMAND)){\n    str+=strlen(HELPCOMMAND);\n    if (!emptystr(str) && *str != ' ')\n      return 0;\n    removespaces(str);\n    if (emptystr(str)){\n      printf(\"\\n\\\nUnits converts between different measuring systems and    %s6 inches\\n\\\nacts as a units-aware calculator.  At the '%s'    %scm\\n\\\nprompt, type in the units you want to convert from or             * 15.24\\n\\\nan expression to evaluate.  At the '%s' prompt,           / 0.065\\n\\\nenter the units to convert to or press return to see\\n\\\nthe reduced form or definition.                           %stempF(75)\\n\\\n                                                          %stempC\\n\\\nThe first example shows that 6 inches is about 15 cm              23.889\\n\\\nor (1/0.065) cm.  The second example shows how to\\n\\\nconvert 75 degrees Fahrenheit to Celsius.  The third      %sbu^(1/3)\\n\\\nexample converts the cube root of a bushel to a list      %sft;in\\n\\\nof semicolon-separated units.                                     1 ft + 0.9 in\\n\\\n\\n\\\nTo quit from units type Ctrl-%s or Ctrl-C.       %s2 btu + 450 ft lbf\\n\\\n                                                %s(kg^2/s)/(day lb/m^2)\\n\\\nAt the '%s' prompt type '%s' to get a            * 1.0660684e+08\\n\\\nlist of conformable units.  At either prompt you        / 9.3802611e-09\\n\\\ntype 'help myunit' to browse the units database\\n\\\nand read the comments relating to myunit or see         %s6 tbsp sugar\\n\\\nother units related to myunit.  Typing 'search          %sg\\n\\\ntext' will show units whose names contain 'text'.               * 75\\n\\\n                                                                / 0.013333333\\n\",\nQUERYHAVE,\nQUERYHAVE, QUERYWANT,\nQUERYWANT,\nQUERYHAVE,QUERYWANT,QUERYHAVE,QUERYWANT,\nEOFCHAR,\nQUERYHAVE,QUERYWANT,\nQUERYWANT,\nUNITMATCH,\nQUERYHAVE,QUERYWANT);\n      return 1;\n    }\n    if ((function = fnlookup(str))){\n      file = function->file;\n      unitline = function->linenumber;\n    }\n    else if ((unit = ulookup(str))){\n      unitline = unit->linenumber;\n      file = unit->file;\n    }\n    else if ((prefix = plookup(str)) && strlen(str)==prefix->len){\n      unitline = prefix->linenumber;\n      file = prefix->file;\n    }\n    else if ((alias = aliaslookup(str))){\n      unitline = alias->linenumber;\n      file = alias->file;\n    }\n    else {\n      printf(\"Unknown unit '%s'\\n\",str);\n      return 1;\n    }\n\n#if defined (_WIN32) && defined (HAVE_MKS_TOOLKIT)\n    if (ismksmore(pager))\n      /*\n        inner escaped quotes are necessary for filenames with spaces;\n        outer escaped quotes are necessary for cmd.exe to see the\n        command as a single string containing one or more quoted strings\n        (e.g., cmd /c \"\"command\" \"arg1\" \"arg2\" ... \")\n      */\n      sprintf(commandbuf,\"\\\"\\\"%s\\\" +%dg \\\"%s\\\"\\\"\", pager, unitline, file);\n    else\n      /* more.com seems to have positioning problems, and it can't back up */\n      sprintf(commandbuf,\"\\\"\\\"%s\\\"  +%d \\\"%s\\\"\\\"\", pager,\n              unitline > 2 ? unitline - 3 : unitline, file);\n#elif defined (_WIN32)\n    sprintf(commandbuf,\"\\\"\\\"%s\\\" +%d \\\"%s\\\"\\\"\", pager,\n            unitline > 2 ? unitline - 3 : unitline, file);\n#else\n    sprintf(commandbuf,\"%s +%d %s\", pager, unitline, file);\n#endif\n    if (system(commandbuf))\n      fprintf(stderr,\"%s: cannot invoke pager '%s' to display help\\n\", \n              progname, pager);\n    return 1;\n  }\n  return 0;\n}",
      "lines": 116,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "checklocale": [
      {
        "start_point": [
          5353,
          0
        ],
        "end_point": [
          5366,
          1
        ],
        "content": "void\nchecklocale()\n{\n  char *temp;\n  temp = setlocale(LC_CTYPE,\"\");\n  utf8mode = (strcmp(nl_langinfo(CODESET),\"UTF-8\")==0);\n  if (temp){\n    mylocale = dupstr(temp);\n    temp = strchr(mylocale,'.');\n    if (temp)\n      *temp = 0;\n  } else\n    mylocale = DEFAULTLOCALE;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5370,
          0
        ],
        "end_point": [
          5389,
          1
        ],
        "content": "void\nchecklocale()\n{\n  char *temp=0;\n#ifndef NO_SETLOCALE  \n  temp = setlocale(LC_CTYPE,\"\");\n#endif\n  if (!temp)\n    temp = getenv(\"LC_CTYPE\");\n  if (!temp)\n    temp = getenv(\"LANG\");\n  if (!temp)\n    mylocale = DEFAULTLOCALE;\n  else {\n    mylocale = dupstr(temp);  \n    temp = strchr(mylocale,'.');\n    if (temp)\n      *temp = 0;\n  }\n}",
        "lines": 20,
        "depth": 10,
        "decorators": [
          "void"
        ]
      }
    ],
    "replacealias": {
      "start_point": [
        5398,
        0
      ],
      "end_point": [
        5427,
        1
      ],
      "content": "int\nreplacealias(char **string, int *buflen)\n{\n  int usefree = 1;\n  struct wantalias *aliasptr;\n  char *input;\n\n  if (!flags.readline && buflen)\n    usefree = 0;\n\n  if (*string && **string) {   /* check that string is defined and nonempty */\n    input = *string;\n    removespaces(input);\n    if ((aliasptr=aliaslookup(input))){\n      if (checkunitlist(aliasptr->definition,NOERRMSG)){\n        puts(\"Unit list definition contains errors.\");\n        return 1;\n      }\n      if (usefree){\n        free(*string);\n        *string = dupstr(aliasptr->definition);\n      } else {                           /* coverity[dead_error_line] */\n        while (strlen(aliasptr->definition)>*buflen)\n          growbuffer(string, buflen);\n        strcpy(*string, aliasptr->definition);\n      }\n    }\n  }\n  return 0;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "remaplocale": {
      "start_point": [
        5435,
        0
      ],
      "end_point": [
        5463,
        1
      ],
      "content": "void\nremaplocale(char *filename)\n{\n  FILE *map;\n  char *value;\n  char name[80];\n\n  map = fopen(filename,\"rt\");\n  if (!map) {\n    fprintf(stderr,\"%s: cannot open locale map '%s'. \",progname,filename);\n    perror((char *) NULL);\n  }\n  else {\n    while(!feof(map)){\n      if (!fgets(name,80,map))\n        break;\n      value=strchr(name,'#');\n      if (value) *value=0;\n      value=strchr(name,'\\t');\n      if (!value) continue;\n      *value++=0;\n      removespaces(value);\n      removespaces(name);\n      if (!strcmp(name, mylocale))\n        mylocale = dupstr(value);\n    }\n    fclose(map);\n  }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "close_logfile": {
      "start_point": [
        5466,
        0
      ],
      "end_point": [
        5473,
        1
      ],
      "content": "void\nclose_logfile(void)\n{\n  if (logfile){\n    fputc('\\n',logfile);\n    fclose(logfile);\n  }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "open_logfile": {
      "start_point": [
        5476,
        0
      ],
      "end_point": [
        5493,
        1
      ],
      "content": "void\nopen_logfile(void)\n{  \n  time_t logtime;\n  char * timestr;\n\n  logfile = fopen(logfilename, \"at\");\n  if (!logfile){\n    fprintf(stderr, \"%s: cannot write to log file '%s'.  \", \n            progname, logfilename);\n    perror(0);\n    exit(EXIT_FAILURE);\n  }\n  time(&logtime);\n  timestr = ctime(&logtime);\n  fprintf(logfile, \"### Log started %s \\n\", timestr);\n  atexit(close_logfile);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_files_sig": {
      "start_point": [
        5496,
        0
      ],
      "end_point": [
        5506,
        1
      ],
      "content": "void\nwrite_files_sig(int sig)\n{\n#ifdef READLINE\n  if (historyfile)\n    save_history();\n#endif\n  close_logfile();\n  signal(sig, SIG_DFL);\n  raise(sig);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        5509,
        0
      ],
      "end_point": [
        5803,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n   static struct unittype have, want;\n   char *havestr=0, *wantstr=0;\n   struct func *funcval;\n   struct wantalias *alias;\n   int havestrsize=0;   /* Only used if READLINE is undefined */\n   int wantstrsize=0;   /* Only used if READLINE is undefined */\n   int interactive;\n   int readerr;\n   char **unitfileptr;\n   int unitcount=0, prefixcount=0, funccount=0;   /* for counting units */\n   char *queryhave, *querywant, *comment;\n   int queryhavewidth, querywantwidth;\n#ifdef _WIN32\n   char *localemap;\n#endif\n\n   /* Set program parameter defaults */\n   num_format.format = NULL;\n   num_format.precision = DEFAULTPRECISION;\n   num_format.type = DEFAULTTYPE;\n\n   flags.quiet = 0;       /* Do not supress prompting */\n   flags.unitcheck = 0;   /* Unit checking is off */\n   flags.verbose = 1;     /* Medium verbosity */\n   flags.round = 0;       /* Rounding off */\n   flags.strictconvert=0; /* Strict conversion disabled (reciprocals active) */\n   flags.unitlists = 1;   /* Multi-unit conversion active */\n   flags.oneline = 0;     /* One line output is disabled */\n   flags.showfactor = 0;  /* Don't show a multiplier for a 1|x fraction */\n                          /*       in unit list output */\n   parserflags.minusminus = 1;  /* '-' character gives subtraction */\n   parserflags.oldstar = 0;     /* '*' has same precedence as '/' */\n\n   progname = getprogramname(argv[0]);\n\n   /*\n     unless UNITSFILE and LOCALEMAP have absolute pathnames, we may need\n     progdir to search for supporting files\n   */\n   if (!(isfullpath(UNITSFILE) && isfullpath(LOCALEMAP)))\n     progdir = getprogdir(argv[0], &fullprogname);\n   else {\n     progdir = NULL;\n     fullprogname = NULL;\n   }\n   datadir = NULL;      /* directory to search as last resort */\n\n   checklocale();\n#ifdef READLINE\n#  if RL_READLINE_VERSION > 0x0402 \n      rl_completion_entry_function = (rl_compentry_func_t *)completeunits;\n#  else\n      rl_completion_entry_function = (Function *)completeunits;\n#  endif\n   rl_basic_word_break_characters = \" \\t+-*/()|^;\";\n   flags.readline = isatty(0);\n   if (flags.readline){\n     int file_exists;\n     historyfile = personalfile(NULL,HISTORY_FILE,1,&file_exists);\n   }\n#else\n   flags.readline = 0;\n#endif\n\n   unitsfiles[0] = 0;\n\n#ifdef _WIN32\n   if (!strcmp(homeunitsfile,\".units\"))\n     homeunitsfile = \"unitdef.units\";\n#endif\n\n   interactive = processargs(argc, argv, &havestr, &wantstr);\n\n#ifdef READLINE   \n   if (interactive && flags.readline && historyfile){\n     rl_initialize();\n     read_history(historyfile);\n     init_history_length = history_length;\n     init_history_base = history_base;\n     atexit(save_history);\n   }\n#endif\n\n   signal(SIGINT, write_files_sig);\n   signal(SIGTERM, write_files_sig);\n\n   if (logfilename) {\n     if (!interactive)\n       fprintf(stderr,\n               \"Log file '%s' ignored in non-interactive mode.\\n\",logfilename);\n     else open_logfile();\n   }\n  \n   /* user has specified the complete format--use it */\n   if (num_format.format != NULL) {\n       if (parsenumformat())\n         exit(EXIT_FAILURE);\n   }\n   else\n       setnumformat();\n\n   if (flags.verbose==0)\n     deftext = \"\";\n\n   if (!unitsfiles[0]){\n     char *unitsfile;\n     unitsfile = findunitsfile(0);\n     if (!unitsfile)\n       exit(EXIT_FAILURE);\n     else {\n       int file_exists;\n\n       unitsfiles[0] = unitsfile;\n       unitsfiles[1] = personalfile(HOME_UNITS_ENV, homeunitsfile, \n                                         0, &file_exists);\n       unitsfiles[2] = 0;\n     }\n   }\n\n#ifdef _WIN32\n   localemap = findlocalemap(0);\n   if (localemap)\n     remaplocale(localemap);\n#endif\n\n   for(unitfileptr=unitsfiles;*unitfileptr;unitfileptr++){      \n     readerr = readunits(*unitfileptr, stderr, &unitcount, &prefixcount, \n                         &funccount, 0);\n     if (readerr==E_MEMORY) \n       exit(EXIT_FAILURE);\n     if (readerr==E_FILE){\n       fprintf(stderr, \"%s: cannot open units file '%s'.  \",\n               progname, *unitfileptr);\n       perror(0);\n       exit(EXIT_FAILURE);\n     }\n   }\n\n   if (flags.quiet)\n     queryhave = querywant = \"\";   /* No prompts are being printed */\n   else {\n     queryhave = QUERYHAVE;\n     querywant = QUERYWANT;\n     printf(\"%d units, %d prefixes, %d nonlinear units\\n\\n\", \n            unitcount, prefixcount,funccount);\n   }\n   queryhavewidth = strwidth(queryhave);\n   querywantwidth = strwidth(querywant);\n\n   if (flags.unitcheck) {\n     checkunits(flags.unitcheck==2 || flags.verbose==2);\n     exit(EXIT_SUCCESS);\n   }\n\n   if (!interactive) {\n     replacectrlchars(havestr);\n     if (wantstr)\n       replacectrlchars(wantstr);\n#ifdef SUPPORT_UTF8\n     if (strwidth(havestr)<0){\n       printf(\"Error: %s on input\\n\",invalid_utf8);\n       exit(EXIT_FAILURE);\n     }\n     if (wantstr && strwidth(wantstr)<0){\n       printf(\"Error: %s on input\\n\",invalid_utf8);\n       exit(EXIT_FAILURE);\n     }\n#endif\n     replace_minus(havestr);\n     removespaces(havestr);\n     if (wantstr) {\n       replace_minus(wantstr);\n       removespaces(wantstr);\n     }\n     if ((funcval = fnlookup(havestr))){\n       showfuncdefinition(funcval, FUNCTION);\n       exit(EXIT_SUCCESS);\n     }\n     if ((funcval = invfnlookup(havestr))){\n       showfuncdefinition(funcval, INVERSE);\n       exit(EXIT_SUCCESS);\n     }\n     if ((alias = aliaslookup(havestr))){\n       showunitlistdef(alias);\n       exit(EXIT_SUCCESS);\n     }\n     if (processunit(&have, havestr, NOPOINT))\n       exit(EXIT_FAILURE);\n     if (!wantstr){\n       showdefinition(havestr,&have);\n       exit(EXIT_SUCCESS);\n     }\n     if (replacealias(&wantstr, 0)) /* the 0 says that we can free wantstr */\n       exit(EXIT_FAILURE);\n     if ((funcval = fnlookup(wantstr))){\n       if (showfunc(havestr, &have, funcval))  /* Clobbers have */\n         exit(EXIT_FAILURE);\n       else\n         exit(EXIT_SUCCESS);\n     }\n     if (processwant(&want, wantstr, NOPOINT))\n       exit(EXIT_FAILURE);\n     if (strchr(wantstr, UNITSEPCHAR)){\n       if (showunitlist(havestr, &have, wantstr))\n         exit(EXIT_FAILURE);\n       else\n         exit(EXIT_SUCCESS);\n     }\n     if (showanswer(havestr,&have,wantstr,&want))\n       exit(EXIT_FAILURE);\n     else\n       exit(EXIT_SUCCESS);\n   } else {       /* interactive */\n     pager = getenv(\"PAGER\");\n     if (!pager)\n       pager = DEFAULTPAGER;\n     for (;;) {\n       do {\n         fflush(stdout);\n         getuser(&havestr,&havestrsize,queryhave);\n         replace_minus(havestr);\n         comment = strip_comment(havestr);\n         removespaces(havestr);\n         if (logfile && comment && emptystr(havestr))\n           fprintf(logfile, \"#%s\\n\", comment);\n       } while (emptystr(havestr) || ishelpquery(havestr,0) ||\n                (!fnlookup(havestr) && !invfnlookup(havestr)\n                 && !aliaslookup(havestr) \n                 && processunit(&have, havestr, queryhavewidth)));\n       if (logfile) {\n         if (comment)\n           fprintf(logfile, \"%s%s\\t#%s\\n\", LOGFROM, havestr,comment);\n         else\n           fprintf(logfile, \"%s%s\\n\", LOGFROM, havestr);\n       }\n       if ((alias = aliaslookup(havestr))){\n         showunitlistdef(alias);\n         continue;\n       }\n       if ((funcval = fnlookup(havestr))){\n         showfuncdefinition(funcval, FUNCTION);\n         continue;\n       }\n       if ((funcval = invfnlookup(havestr))){\n         showfuncdefinition(funcval, INVERSE);\n         continue;\n       }\n       do { \n         int repeat; \n         do {\n           repeat = 0;\n           fflush(stdout);\n           getuser(&wantstr,&wantstrsize,querywant);\n           replace_minus(wantstr);\n           comment = strip_comment(wantstr);\n           removespaces(wantstr);\n           if (logfile && comment && emptystr(wantstr)){\n             fprintf(logfile, \"#%s\\n\", comment);\n             repeat = 1;\n           }\n           if (ishelpquery(wantstr, &have)){\n             repeat = 1;\n             printf(\"%s%s\\n\",queryhave, havestr);\n           }\n         } while (repeat);\n       } while (replacealias(&wantstr, &wantstrsize)\n                || (!fnlookup(wantstr)\n                    && processwant(&want, wantstr, querywantwidth)));\n       if (logfile) {\n         fprintf(logfile, \"%s\", LOGTO);\n         tightprint(logfile, wantstr);\n         if (comment)\n           fprintf(logfile, \"\\t#%s\", comment);\n         putc('\\n', logfile);\n       }\n       if (emptystr(wantstr))\n         showdefinition(havestr,&have);\n       else if (strchr(wantstr, UNITSEPCHAR))\n         showunitlist(havestr, &have, wantstr);\n       else if ((funcval = fnlookup(wantstr)))\n         showfunc(havestr, &have, funcval); /* Clobbers have */\n       else {\n         showanswer(havestr,&have,wantstr, &want);\n         freeunit(&want);\n       }\n       unitcopy(&lastunit, &have);\n       lastunitset=1;\n       freeunit(&have);\n     }\n   }\n   return (0);\n}",
      "lines": 295,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "units/units-2.16/units.h": {}
}