{
  "libiconv/libiconv-1.15/build-aux/snippet/arg-nonnull.h": {},
  "libiconv/libiconv-1.15/build-aux/snippet/c++defs.h": {},
  "libiconv/libiconv-1.15/build-aux/snippet/warn-on-use.h": {},
  "libiconv/libiconv-1.15/build-aux/snippet/_Noreturn.h": {},
  "libiconv/libiconv-1.15/extras/iconv_string.c": {
    "iconv_string": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int iconv_string (const char* tocode, const char* fromcode,\n                  const char* start, const char* end,\n                  char** resultp, size_t* lengthp)\n{\n  iconv_t cd = iconv_open(tocode,fromcode);\n  size_t length;\n  char* result;\n  if (cd == (iconv_t)(-1)) {\n    if (errno != EINVAL)\n      return -1;\n    /* Unsupported fromcode or tocode. Check whether the caller requested\n       autodetection. */\n    if (!strcmp(fromcode,\"autodetect_utf8\")) {\n      int ret;\n      /* Try UTF-8 first. There are very few ISO-8859-1 inputs that would\n         be valid UTF-8, but many UTF-8 inputs are valid ISO-8859-1. */\n      ret = iconv_string(tocode,\"UTF-8\",start,end,resultp,lengthp);\n      if (!(ret < 0 && errno == EILSEQ))\n        return ret;\n      ret = iconv_string(tocode,\"ISO-8859-1\",start,end,resultp,lengthp);\n      return ret;\n    }\n    if (!strcmp(fromcode,\"autodetect_jp\")) {\n      int ret;\n      /* Try 7-bit encoding first. If the input contains bytes >= 0x80,\n         it will fail. */\n      ret = iconv_string(tocode,\"ISO-2022-JP-2\",start,end,resultp,lengthp);\n      if (!(ret < 0 && errno == EILSEQ))\n        return ret;\n      /* Try EUC-JP next. Short SHIFT_JIS inputs may come out wrong. This\n         is unavoidable. People will condemn SHIFT_JIS.\n         If we tried SHIFT_JIS first, then some short EUC-JP inputs would\n         come out wrong, and people would condemn EUC-JP and Unix, which\n         would not be good. */\n      ret = iconv_string(tocode,\"EUC-JP\",start,end,resultp,lengthp);\n      if (!(ret < 0 && errno == EILSEQ))\n        return ret;\n      /* Finally try SHIFT_JIS. */\n      ret = iconv_string(tocode,\"SHIFT_JIS\",start,end,resultp,lengthp);\n      return ret;\n    }\n    if (!strcmp(fromcode,\"autodetect_kr\")) {\n      int ret;\n      /* Try 7-bit encoding first. If the input contains bytes >= 0x80,\n         it will fail. */\n      ret = iconv_string(tocode,\"ISO-2022-KR\",start,end,resultp,lengthp);\n      if (!(ret < 0 && errno == EILSEQ))\n        return ret;\n      /* Finally try EUC-KR. */\n      ret = iconv_string(tocode,\"EUC-KR\",start,end,resultp,lengthp);\n      return ret;\n    }\n    errno = EINVAL;\n    return -1;\n  }\n  /* Determine the length we need. */\n  {\n    size_t count = 0;\n    char tmpbuf[tmpbufsize];\n    const char* inptr = start;\n    size_t insize = end-start;\n    while (insize > 0) {\n      char* outptr = tmpbuf;\n      size_t outsize = tmpbufsize;\n      size_t res = iconv(cd,&inptr,&insize,&outptr,&outsize);\n      if (res == (size_t)(-1) && errno != E2BIG) {\n        int saved_errno = (errno == EINVAL ? EILSEQ : errno);\n        iconv_close(cd);\n        errno = saved_errno;\n        return -1;\n      }\n      count += outptr-tmpbuf;\n    }\n    {\n      char* outptr = tmpbuf;\n      size_t outsize = tmpbufsize;\n      size_t res = iconv(cd,NULL,NULL,&outptr,&outsize);\n      if (res == (size_t)(-1)) {\n        int saved_errno = errno;\n        iconv_close(cd);\n        errno = saved_errno;\n        return -1;\n      }\n      count += outptr-tmpbuf;\n    }\n    length = count;\n  }\n  if (lengthp != NULL)\n    *lengthp = length;\n  if (resultp == NULL) {\n    iconv_close(cd);\n    return 0;\n  }\n  result = (*resultp == NULL ? malloc(length) : realloc(*resultp,length));\n  *resultp = result;\n  if (length == 0) {\n    iconv_close(cd);\n    return 0;\n  }\n  if (result == NULL) {\n    iconv_close(cd);\n    errno = ENOMEM;\n    return -1;\n  }\n  iconv(cd,NULL,NULL,NULL,NULL); /* return to the initial state */\n  /* Do the conversion for real. */\n  {\n    const char* inptr = start;\n    size_t insize = end-start;\n    char* outptr = result;\n    size_t outsize = length;\n    while (insize > 0) {\n      size_t res = iconv(cd,&inptr,&insize,&outptr,&outsize);\n      if (res == (size_t)(-1)) {\n        if (errno == EINVAL)\n          break;\n        else {\n          int saved_errno = errno;\n          iconv_close(cd);\n          errno = saved_errno;\n          return -1;\n        }\n      }\n    }\n    {\n      size_t res = iconv(cd,NULL,NULL,&outptr,&outsize);\n      if (res == (size_t)(-1)) {\n        int saved_errno = errno;\n        iconv_close(cd);\n        errno = saved_errno;\n        return -1;\n      }\n    }\n    if (outsize != 0) abort();\n  }\n  iconv_close(cd);\n  return 0;\n}",
      "lines": 138,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/extras/iconv_string.h": {},
  "libiconv/libiconv-1.15/gnulib-local/lib/alloca.in.h": {},
  "libiconv/libiconv-1.15/gnulib-local/lib/xalloc.h": {
    "xrealloc": {
      "start_point": [
        51,
        9
      ],
      "end_point": [
        54,
        3
      ],
      "content": "T * xrealloc (T * ptr, size_t size)\n  {\n    return (T *) xrealloc ((void *) ptr, size);\n  }",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "T",
        "* xrealloc (T * ptr, size_t size)",
        "*"
      ]
    },
    "xnboundedmalloc": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static inline void *\nxnboundedmalloc (size_t n, size_t bound, size_t s)\n{\n  if (n > bound)\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nxnboundedmalloc (size_t n, size_t bound, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        125,
        9
      ],
      "end_point": [
        128,
        3
      ],
      "content": "T * xmemdup (const T * p, size_t n)\n  {\n    return (T *) xmemdup ((const void *) p, n);\n  }",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "T",
        "* xmemdup (const T * p, size_t n)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/gnulib-local/lib/xmalloc.c": {
    "xalloc_die": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nxalloc_die ()\n{\n  error (xmalloc_exit_failure, 0, _(\"memory exhausted\"));\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does terminate, call exit. */\n  exit (EXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fixup_null_alloc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void *\nfixup_null_alloc (size_t n)\n{\n  void *p;\n\n  p = NULL;\n  if (n == 0)\n    p = malloc ((size_t) 1);\n  if (p == NULL)\n    xalloc_die ();\n  return p;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nfixup_null_alloc (size_t n)",
        "*"
      ]
    },
    "xmalloc": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p;\n\n  p = malloc (n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xnmalloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void *\nxnmalloc (size_t nmemb, size_t size)\n{\n  size_t n;\n  void *p;\n\n  if (xalloc_oversized (nmemb, size))\n    xalloc_die ();\n  n = nmemb * size;\n  p = malloc (n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxnmalloc (size_t nmemb, size_t size)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void *\nxzalloc (size_t size)\n{\n  void *p;\n\n  p = xmalloc (size);\n  memset (p, 0, size);\n  return p;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxzalloc (size_t size)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n\n  p = calloc (n, s);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (p == NULL)\n    return xmalloc (n);\n  p = realloc (p, n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/gnulib-local/lib/xstrdup.c": {
    "xmemdup": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void *\nxmemdup (const void *p, size_t n)\n{\n  void *q = xmalloc (n);\n  memcpy (q, p, n);\n  return q;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmemdup (const void *p, size_t n)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "char *\nxstrdup (const char *string)\n{\n  return strcpy (XNMALLOC (strlen (string) + 1, char), string);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxstrdup (const char *string)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/include/export.h": {},
  "libiconv/libiconv-1.15/lib/aliases.h": {
    "aliases_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static unsigned int\naliases_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned short asso_values[] =\n    {\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922,   5,   6, 922,  97,   7,\n       33, 102,  15,  17,   5, 173,  23,  25, 193, 922,\n      922, 922, 922, 922, 922, 168, 159,  11,  32,  25,\n      159,  13,  70,   6, 308, 186,   8, 132,   7,   6,\n       62, 922,   5,   8,  30, 174, 163, 180,  79,  28,\n        6, 922, 922, 922, 922,   6, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922, 922, 922,\n      922, 922, 922, 922, 922, 922, 922, 922\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "aliases_lookup": {
      "start_point": [
        1717,
        0
      ],
      "end_point": [
        1737,
        1
      ],
      "content": "const struct alias *\naliases_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = aliases_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = aliases[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &aliases[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/aliases2.h": {},
  "libiconv/libiconv-1.15/lib/aliases_aix.h": {},
  "libiconv/libiconv-1.15/lib/aliases_aix_sysaix.h": {},
  "libiconv/libiconv-1.15/lib/aliases_dos.h": {},
  "libiconv/libiconv-1.15/lib/aliases_extra.h": {},
  "libiconv/libiconv-1.15/lib/aliases_osf1.h": {},
  "libiconv/libiconv-1.15/lib/aliases_osf1_sysosf1.h": {},
  "libiconv/libiconv-1.15/lib/aliases_sysaix.h": {
    "aliases_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static unsigned int\naliases_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned short asso_values[] =\n    {\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040,    0,  174, 1040,   44,    2,\n        16,   28,    9,   13,    5,  188,   20,    0,  170, 1040,\n      1040, 1040, 1040, 1040, 1040,    9,  191,    2,   19,   65,\n       140,   65,   42,   88,  376,  199,    6,  206,    3,    0,\n        52, 1040,    0,   11,  118,   97,   59,  189,  220,   13,\n         4, 1040, 1040, 1040, 1040,    1, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040,\n      1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "aliases_lookup": {
      "start_point": [
        1754,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "const struct alias *\naliases_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = aliases_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = aliases[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &aliases[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/aliases_syshpux.h": {
    "aliases_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static unsigned int\naliases_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned short asso_values[] =\n    {\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034,    2,   22, 1034,   56,    4,\n        36,   62,   23,   18,   11,  100,   30,    3,  115, 1034,\n      1034, 1034, 1034, 1034, 1034,   62,  170,  101,    3,   35,\n        78,   78,  169,    3,  375,   55,   16,  149,   18,    8,\n         3, 1034,    2,    4,  161,  210,  136,  158,  191,    6,\n         5, 1034, 1034, 1034, 1034,    3, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n      1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "aliases_lookup": {
      "start_point": [
        1759,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "const struct alias *\naliases_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = aliases_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = aliases[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &aliases[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/aliases_sysosf1.h": {
    "aliases_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static unsigned int\naliases_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned short asso_values[] =\n    {\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982,   5,  96, 982,  97,   7,\n       33, 102,  15,  17,   5, 173,  23,  25, 298, 982,\n      982, 982, 982, 982, 982, 168, 248,  11,  26,  25,\n       17,  29,  29,   6, 139, 153,   8, 132,   7,   6,\n      114, 982,   5,   8,  30, 235, 185, 182, 225,   5,\n       18, 982, 982, 982, 982,   6, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982, 982, 982,\n      982, 982, 982, 982, 982, 982, 982, 982\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "aliases_lookup": {
      "start_point": [
        1729,
        0
      ],
      "end_point": [
        1749,
        1
      ],
      "content": "const struct alias *\naliases_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = aliases_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = aliases[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &aliases[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/aliases_syssolaris.h": {
    "aliases_hash": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static unsigned int\naliases_hash (register const char *str, register unsigned int len)\n{\n  static const unsigned short asso_values[] =\n    {\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957,  10, 110, 957,  34,   2,\n        8,  85,  31,   4,   3, 170,   6,   7, 192, 957,\n      957, 957, 957, 957, 957,  26, 164,   2,  39,  78,\n      125,  98, 118,   2, 168, 103, 149, 143,   4,   2,\n      139, 957,  40,  64,  28, 123, 106, 162, 190,   5,\n        4, 957, 957, 957, 957,  82, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957, 957, 957,\n      957, 957, 957, 957, 957, 957, 957, 957\n    };\n  register int hval = len;\n\n  switch (hval)\n    {\n      default:\n        hval += asso_values[(unsigned char)str[10]];\n      /*FALLTHROUGH*/\n      case 10:\n        hval += asso_values[(unsigned char)str[9]];\n      /*FALLTHROUGH*/\n      case 9:\n        hval += asso_values[(unsigned char)str[8]];\n      /*FALLTHROUGH*/\n      case 8:\n        hval += asso_values[(unsigned char)str[7]];\n      /*FALLTHROUGH*/\n      case 7:\n        hval += asso_values[(unsigned char)str[6]];\n      /*FALLTHROUGH*/\n      case 6:\n        hval += asso_values[(unsigned char)str[5]];\n      /*FALLTHROUGH*/\n      case 5:\n        hval += asso_values[(unsigned char)str[4]];\n      /*FALLTHROUGH*/\n      case 4:\n        hval += asso_values[(unsigned char)str[3]];\n      /*FALLTHROUGH*/\n      case 3:\n        hval += asso_values[(unsigned char)str[2]];\n      /*FALLTHROUGH*/\n      case 2:\n      case 1:\n        hval += asso_values[(unsigned char)str[0]];\n        break;\n    }\n  return hval + asso_values[(unsigned char)str[len - 1]];\n}",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "aliases_lookup": {
      "start_point": [
        1739,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "const struct alias *\naliases_lookup (register const char *str, register unsigned int len)\n{\n  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n    {\n      register int key = aliases_hash (str, len);\n\n      if (key <= MAX_HASH_VALUE && key >= 0)\n        {\n          register int o = aliases[key].name;\n          if (o >= 0)\n            {\n              register const char *s = o + stringpool;\n\n              if (*str == *s && !strcmp (str + 1, s + 1))\n                return &aliases[key];\n            }\n        }\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases_lookup (register const char *str, register unsigned int len)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/armscii_8.h": {
    "armscii_8_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\narmscii_8_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = armscii_8_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "armscii_8_wctomb": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\narmscii_8_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0028) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0028 && wc < 0x0030)\n    c = armscii_8_page00[wc-0x0028];\n  else if (wc >= 0x0030 && wc < 0x00a0)\n    c = wc;\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = armscii_8_page00_1[wc-0x00a0];\n  else if (wc >= 0x0530 && wc < 0x0590)\n    c = armscii_8_page05[wc-0x0530];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = armscii_8_page20[wc-0x2010];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ascii.h": {
    "ascii_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static int\nascii_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ascii_wctomb": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static int\nascii_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/atarist.h": {
    "atarist_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\natarist_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) atarist_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "atarist_wctomb": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static int\natarist_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = atarist_page00[wc-0x00a0];\n  else if (wc >= 0x0130 && wc < 0x0198)\n    c = atarist_page01[wc-0x0130];\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = atarist_page03[wc-0x0390];\n  else if (wc >= 0x05d0 && wc < 0x05f0)\n    c = atarist_page05[wc-0x05d0];\n  else if (wc == 0x2020)\n    c = 0xbb;\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x2122)\n    c = 0xbf;\n  else if (wc >= 0x2208 && wc < 0x2268)\n    c = atarist_page22[wc-0x2208];\n  else if (wc >= 0x2310 && wc < 0x2328)\n    c = atarist_page23[wc-0x2310];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5.h": {
    "big5_mbtowc": {
      "start_point": [
        1871,
        0
      ],
      "end_point": [
        1898,
        1
      ],
      "content": "static int\nbig5_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0xa1 && c1 <= 0xc7) || (c1 >= 0xc9 && c1 <= 0xf9)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0xa1) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        unsigned short wc = 0xfffd;\n        if (i < 6280) {\n          if (i < 6121)\n            wc = big5_2uni_pagea1[i];\n        } else {\n          if (i < 13932)\n            wc = big5_2uni_pagec9[i-6280];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5_wctomb": {
      "start_point": [
        4117,
        0
      ],
      "end_point": [
        4158,
        1
      ],
      "content": "static int\nbig5_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0100)\n      summary = &big5_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x0200 && wc < 0x0460)\n      summary = &big5_uni2indx_page02[(wc>>4)-0x020];\n    else if (wc >= 0x2000 && wc < 0x22c0)\n      summary = &big5_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x2400 && wc < 0x2650)\n      summary = &big5_uni2indx_page24[(wc>>4)-0x240];\n    else if (wc >= 0x3000 && wc < 0x33e0)\n      summary = &big5_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x4e00 && wc < 0x9fb0)\n      summary = &big5_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xfa00 && wc < 0xfa10)\n      summary = &big5_uni2indx_pagefa[(wc>>4)-0xfa0];\n    else if (wc >= 0xfe00 && wc < 0xff70)\n      summary = &big5_uni2indx_pagefe[(wc>>4)-0xfe0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = big5_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 42,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5hkscs1999.h": {
    "big5hkscs1999_mbtowc": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\nbig5hkscs1999_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    /* Code set 0 (ASCII) */\n    if (c < 0x80)\n      return ascii_mbtowc(conv,pwc,s,n);\n    /* Code set 1 (BIG5 extended) */\n    if (c >= 0xa1 && c < 0xff) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            int ret = big5_mbtowc(conv,pwc,s,2);\n            if (ret != RET_ILSEQ)\n              return ret;\n          }\n        }\n      }\n    }\n    {\n      int ret = hkscs1999_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    if (c == 0x88) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if (c2 == 0x62 || c2 == 0x64 || c2 == 0xa3 || c2 == 0xa5) {\n          /* It's a composed character. */\n          ucs4_t wc1 = ((c2 >> 3) << 2) + 0x009a; /* = 0x00ca or 0x00ea */\n          ucs4_t wc2 = ((c2 & 6) << 2) + 0x02fc; /* = 0x0304 or 0x030c */\n          /* We cannot output two Unicode characters at once. So,\n             output the first character and buffer the second one. */\n          *pwc = wc1;\n          conv->istate = wc2;\n          return 2;\n        }\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 54,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs1999_wctomb": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static int\nbig5hkscs1999_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    /* last is = 0x66 or = 0xa7. */\n    if (wc == 0x0304 || wc == 0x030c) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        r[0] = 0x88;\n        r[1] = last + ((wc & 24) >> 2) - 4; /* = 0x62 or 0x64 or 0xa3 or 0xa5 */\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    r += 2;\n    count = 2;\n  }\n\n  /* Code set 0 (ASCII) */\n  if (wc < 0x0080) {\n    /* Plain ASCII character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned char buf[2];\n    int ret;\n\n    /* Code set 1 (BIG5 extended) */\n    ret = big5_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (!((buf[0] == 0xc6 && buf[1] >= 0xa1) || buf[0] == 0xc7)) {\n        if (n >= count+2) {\n          r[0] = buf[0];\n          r[1] = buf[1];\n          conv->ostate = 0;\n          return count+2;\n        } else\n          return RET_TOOSMALL;\n      }\n    }\n    ret = hkscs1999_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if ((wc & ~0x0020) == 0x00ca) {\n        /* A possible first character of a multi-character sequence. We have to\n           buffer it. */\n        if (!(buf[0] == 0x88 && (buf[1] == 0x66 || buf[1] == 0xa7))) abort();\n        conv->ostate = buf[1]; /* = 0x66 or = 0xa7 */\n        return count+0;\n      }\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 76,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs1999_reset": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static int\nbig5hkscs1999_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5hkscs2001.h": {
    "big5hkscs2001_mbtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\nbig5hkscs2001_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    /* Code set 0 (ASCII) */\n    if (c < 0x80)\n      return ascii_mbtowc(conv,pwc,s,n);\n    /* Code set 1 (BIG5 extended) */\n    if (c >= 0xa1 && c < 0xff) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            int ret = big5_mbtowc(conv,pwc,s,2);\n            if (ret != RET_ILSEQ)\n              return ret;\n          }\n        }\n      }\n    }\n    {\n      int ret = hkscs1999_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2001_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    if (c == 0x88) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if (c2 == 0x62 || c2 == 0x64 || c2 == 0xa3 || c2 == 0xa5) {\n          /* It's a composed character. */\n          ucs4_t wc1 = ((c2 >> 3) << 2) + 0x009a; /* = 0x00ca or 0x00ea */\n          ucs4_t wc2 = ((c2 & 6) << 2) + 0x02fc; /* = 0x0304 or 0x030c */\n          /* We cannot output two Unicode characters at once. So,\n             output the first character and buffer the second one. */\n          *pwc = wc1;\n          conv->istate = wc2;\n          return 2;\n        }\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2001_wctomb": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static int\nbig5hkscs2001_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    /* last is = 0x66 or = 0xa7. */\n    if (wc == 0x0304 || wc == 0x030c) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        r[0] = 0x88;\n        r[1] = last + ((wc & 24) >> 2) - 4; /* = 0x62 or 0x64 or 0xa3 or 0xa5 */\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    r += 2;\n    count = 2;\n  }\n\n  /* Code set 0 (ASCII) */\n  if (wc < 0x0080) {\n    /* Plain ASCII character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned char buf[2];\n    int ret;\n\n    /* Code set 1 (BIG5 extended) */\n    ret = big5_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (!((buf[0] == 0xc6 && buf[1] >= 0xa1) || buf[0] == 0xc7)) {\n        if (n >= count+2) {\n          r[0] = buf[0];\n          r[1] = buf[1];\n          conv->ostate = 0;\n          return count+2;\n        } else\n          return RET_TOOSMALL;\n      }\n    }\n    ret = hkscs1999_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if ((wc & ~0x0020) == 0x00ca) {\n        /* A possible first character of a multi-character sequence. We have to\n           buffer it. */\n        if (!(buf[0] == 0x88 && (buf[1] == 0x66 || buf[1] == 0xa7))) abort();\n        conv->ostate = buf[1]; /* = 0x66 or = 0xa7 */\n        return count+0;\n      }\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2001_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2001_reset": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int\nbig5hkscs2001_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5hkscs2004.h": {
    "big5hkscs2004_mbtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\nbig5hkscs2004_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    /* Code set 0 (ASCII) */\n    if (c < 0x80)\n      return ascii_mbtowc(conv,pwc,s,n);\n    /* Code set 1 (BIG5 extended) */\n    if (c >= 0xa1 && c < 0xff) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            int ret = big5_mbtowc(conv,pwc,s,2);\n            if (ret != RET_ILSEQ)\n              return ret;\n          }\n        }\n      }\n    }\n    {\n      int ret = hkscs1999_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2001_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2004_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    if (c == 0x88) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if (c2 == 0x62 || c2 == 0x64 || c2 == 0xa3 || c2 == 0xa5) {\n          /* It's a composed character. */\n          ucs4_t wc1 = ((c2 >> 3) << 2) + 0x009a; /* = 0x00ca or 0x00ea */\n          ucs4_t wc2 = ((c2 & 6) << 2) + 0x02fc; /* = 0x0304 or 0x030c */\n          /* We cannot output two Unicode characters at once. So,\n             output the first character and buffer the second one. */\n          *pwc = wc1;\n          conv->istate = wc2;\n          return 2;\n        }\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 64,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2004_wctomb": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int\nbig5hkscs2004_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    /* last is = 0x66 or = 0xa7. */\n    if (wc == 0x0304 || wc == 0x030c) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        r[0] = 0x88;\n        r[1] = last + ((wc & 24) >> 2) - 4; /* = 0x62 or 0x64 or 0xa3 or 0xa5 */\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    r += 2;\n    count = 2;\n  }\n\n  /* Code set 0 (ASCII) */\n  if (wc < 0x0080) {\n    /* Plain ASCII character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned char buf[2];\n    int ret;\n\n    /* Code set 1 (BIG5 extended) */\n    ret = big5_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (!((buf[0] == 0xc6 && buf[1] >= 0xa1) || buf[0] == 0xc7)) {\n        if (n >= count+2) {\n          r[0] = buf[0];\n          r[1] = buf[1];\n          conv->ostate = 0;\n          return count+2;\n        } else\n          return RET_TOOSMALL;\n      }\n    }\n    ret = hkscs1999_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if ((wc & ~0x0020) == 0x00ca) {\n        /* A possible first character of a multi-character sequence. We have to\n           buffer it. */\n        if (!(buf[0] == 0x88 && (buf[1] == 0x66 || buf[1] == 0xa7))) abort();\n        conv->ostate = buf[1]; /* = 0x66 or = 0xa7 */\n        return count+0;\n      }\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2001_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2004_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2004_reset": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nbig5hkscs2004_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5hkscs2008.h": {
    "big5hkscs2008_mbtowc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nbig5hkscs2008_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    /* Code set 0 (ASCII) */\n    if (c < 0x80)\n      return ascii_mbtowc(conv,pwc,s,n);\n    /* Code set 1 (BIG5 extended) */\n    if (c >= 0xa1 && c < 0xff) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            int ret = big5_mbtowc(conv,pwc,s,2);\n            if (ret != RET_ILSEQ)\n              return ret;\n          }\n        }\n      }\n    }\n    {\n      int ret = hkscs1999_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2001_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2004_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    {\n      int ret = hkscs2008_mbtowc(conv,pwc,s,n);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n    if (c == 0x88) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if (c2 == 0x62 || c2 == 0x64 || c2 == 0xa3 || c2 == 0xa5) {\n          /* It's a composed character. */\n          ucs4_t wc1 = ((c2 >> 3) << 2) + 0x009a; /* = 0x00ca or 0x00ea */\n          ucs4_t wc2 = ((c2 & 6) << 2) + 0x02fc; /* = 0x0304 or 0x030c */\n          /* We cannot output two Unicode characters at once. So,\n             output the first character and buffer the second one. */\n          *pwc = wc1;\n          conv->istate = wc2;\n          return 2;\n        }\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 69,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2008_wctomb": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static int\nbig5hkscs2008_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    /* last is = 0x66 or = 0xa7. */\n    if (wc == 0x0304 || wc == 0x030c) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        r[0] = 0x88;\n        r[1] = last + ((wc & 24) >> 2) - 4; /* = 0x62 or 0x64 or 0xa3 or 0xa5 */\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    r += 2;\n    count = 2;\n  }\n\n  /* Code set 0 (ASCII) */\n  if (wc < 0x0080) {\n    /* Plain ASCII character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned char buf[2];\n    int ret;\n\n    /* Code set 1 (BIG5 extended) */\n    ret = big5_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (!((buf[0] == 0xc6 && buf[1] >= 0xa1) || buf[0] == 0xc7)) {\n        if (n >= count+2) {\n          r[0] = buf[0];\n          r[1] = buf[1];\n          conv->ostate = 0;\n          return count+2;\n        } else\n          return RET_TOOSMALL;\n      }\n    }\n    ret = hkscs1999_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if ((wc & ~0x0020) == 0x00ca) {\n        /* A possible first character of a multi-character sequence. We have to\n           buffer it. */\n        if (!(buf[0] == 0x88 && (buf[1] == 0x66 || buf[1] == 0xa7))) abort();\n        conv->ostate = buf[1]; /* = 0x66 or = 0xa7 */\n        return count+0;\n      }\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2001_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2004_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    ret = hkscs2008_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n >= count+2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 109,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5hkscs2008_reset": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static int\nbig5hkscs2008_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  unsigned char last = conv->ostate;\n\n  if (last) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x88;\n    r[1] = last;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/big5_2003.h": {
    "big5_2003_mbtowc": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static int\nbig5_2003_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (BIG5 extended) */\n  if (c >= 0x81 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        if (c >= 0xa1) {\n          if (c < 0xa3) {\n            unsigned int i = 157 * (c - 0xa1) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n            unsigned short wc = big5_2003_2uni_pagea1[i];\n            if (wc != 0xfffd) {\n              *pwc = (ucs4_t) wc;\n              return 2;\n            }\n          }\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            if (!(c == 0xc2 && c2 == 0x55)) {\n              int ret = big5_mbtowc(conv,pwc,s,2);\n              if (ret != RET_ILSEQ)\n                return ret;\n              if (c == 0xa3) {\n                if (c2 >= 0xc0 && c2 <= 0xe1) {\n                  *pwc = (c2 == 0xe1 ? 0x20ac : c2 == 0xe0 ? 0x2421 : 0x2340 + c2);\n                  return 2;\n                }\n              } else if (c == 0xf9) {\n                if (c2 >= 0xd6) {\n                  *pwc = big5_2003_2uni_pagef9[c2-0xd6];\n                  return 2;\n                }\n              } else if (c >= 0xfa) {\n                *pwc = 0xe000 + 157 * (c - 0xfa) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n                return 2;\n              }\n            } else {\n              /* c == 0xc2 && c2 == 0x55. */\n              *pwc = 0x5f5e;\n              return 2;\n            }\n          } else {\n            /* (c == 0xc6 && c2 >= 0xa1) || c == 0xc7. */\n            unsigned int i = 157 * (c - 0xc6) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n            if (i < 133) {\n              /* 63 <= i < 133. */\n              unsigned short wc = big5_2003_2uni_pagec6[i-63];\n              if (wc != 0xfffd) {\n                *pwc = (ucs4_t) wc;\n                return 2;\n              }\n            } else if (i < 216) {\n              /* 133 <= i < 216. Hiragana. */\n              *pwc = 0x3041 - 133 + i;\n              return 2;\n            } else if (i < 302) {\n              /* 216 <= i < 302. Katakana. */\n              *pwc = 0x30a1 - 216 + i;\n              return 2;\n            }\n          }\n        } else {\n          /* 0x81 <= c < 0xa1. */\n          *pwc = (c >= 0x8e ? 0xdb18 : 0xeeb8) + 157 * (c - 0x81)\n                 + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n          return 2;\n        }\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 78,
      "depth": 26,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "big5_2003_wctomb": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "static int\nbig5_2003_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (BIG5 extended) */\n  switch (wc >> 8) {\n    case 0x00:\n      if (wc == 0x00a8) { buf[0] = 0xc6; buf[1] = 0xd8; ret = 2; break; }\n      if (wc == 0x00a2 || wc == 0x00a3 || wc == 0x00a5)\n        return RET_ILUNI;\n      break;\n    case 0x02:\n      if (wc == 0x02cd) { buf[0] = 0xa1; buf[1] = 0xc5; ret = 2; break; }\n      break;\n    case 0x04:\n      return RET_ILUNI;\n    case 0x20:\n      if (wc == 0x2015) { buf[0] = 0xa1; buf[1] = 0x56; ret = 2; break; }\n      if (wc == 0x2027) { buf[0] = 0xa1; buf[1] = 0x45; ret = 2; break; }\n      if (wc == 0x20ac) { buf[0] = 0xa3; buf[1] = 0xe1; ret = 2; break; }\n      if (wc == 0x2013 || wc == 0x2022)\n        return RET_ILUNI;\n      break;\n    case 0x21:\n      if (wc >= 0x2170 && wc <= 0x2179) {\n        buf[0] = 0xc6; buf[1] = wc - 0x20bb; ret = 2;\n        break;\n      }\n      break;\n    case 0x22:\n      if (wc == 0x2215) { buf[0] = 0xa2; buf[1] = 0x41; ret = 2; break; }\n      if (wc == 0x2295) { buf[0] = 0xa1; buf[1] = 0xf2; ret = 2; break; }\n      if (wc == 0x2299) { buf[0] = 0xa1; buf[1] = 0xf3; ret = 2; break; }\n      if (wc == 0x223c)\n        return RET_ILUNI;\n      break;\n    case 0x24:\n      if (wc <= 0x241f) { buf[0] = 0xa3; buf[1] = wc - 0x2340; ret = 2; break; }\n      if (wc == 0x2421) { buf[0] = 0xa3; buf[1] = 0xe0; ret = 2; break; }\n      if (wc >= 0x2460 && wc <= 0x2469) {\n        buf[0] = 0xc6; buf[1] = wc - 0x23bf; ret = 2;\n        break;\n      }\n      if (wc >= 0x2474 && wc <= 0x247d) {\n        buf[0] = 0xc6; buf[1] = wc - 0x23c9; ret = 2;\n        break;\n      }\n      break;\n    case 0x25:\n      if (wc == 0x2501) { buf[0] = 0xa2; buf[1] = 0xa4; ret = 2; break; }\n      if (wc == 0x251d) { buf[0] = 0xa2; buf[1] = 0xa5; ret = 2; break; }\n      if (wc == 0x2525) { buf[0] = 0xa2; buf[1] = 0xa7; ret = 2; break; }\n      if (wc == 0x253f) { buf[0] = 0xa2; buf[1] = 0xa6; ret = 2; break; }\n      if (wc >= 0x2550 && wc <= 0x256c) {\n        buf[0] = 0xf9; buf[1] = big5_2003_2charset_page25[wc-0x2550]; ret = 2;\n        break;\n      }\n      if (wc == 0x2574) { buf[0] = 0xa1; buf[1] = 0x5a; ret = 2; break; }\n      if (wc == 0x2593) { buf[0] = 0xf9; buf[1] = 0xfe; ret = 2; break; }\n      break;\n    case 0x26:\n      if (wc == 0x2609 || wc == 0x2641)\n        return RET_ILUNI;\n      break;\n    case 0x27:\n      if (wc == 0x273d) { buf[0] = 0xc6; buf[1] = 0xe6; ret = 2; break; }\n      break;\n    case 0x2f:\n      if (wc == 0x2f02) { buf[0] = 0xc6; buf[1] = 0xbf; ret = 2; break; }\n      if (wc == 0x2f03) { buf[0] = 0xc6; buf[1] = 0xc0; ret = 2; break; }\n      if (wc == 0x2f05) { buf[0] = 0xc6; buf[1] = 0xc1; ret = 2; break; }\n      if (wc == 0x2f07) { buf[0] = 0xc6; buf[1] = 0xc2; ret = 2; break; }\n      if (wc == 0x2f0c) { buf[0] = 0xc6; buf[1] = 0xc3; ret = 2; break; }\n      if (wc == 0x2f0d) { buf[0] = 0xc6; buf[1] = 0xc4; ret = 2; break; }\n      if (wc == 0x2f0e) { buf[0] = 0xc6; buf[1] = 0xc5; ret = 2; break; }\n      if (wc == 0x2f13) { buf[0] = 0xc6; buf[1] = 0xc6; ret = 2; break; }\n      if (wc == 0x2f16) { buf[0] = 0xc6; buf[1] = 0xc7; ret = 2; break; }\n      if (wc == 0x2f19) { buf[0] = 0xc6; buf[1] = 0xc8; ret = 2; break; }\n      if (wc == 0x2f1b) { buf[0] = 0xc6; buf[1] = 0xc9; ret = 2; break; }\n      if (wc == 0x2f22) { buf[0] = 0xc6; buf[1] = 0xca; ret = 2; break; }\n      if (wc == 0x2f27) { buf[0] = 0xc6; buf[1] = 0xcb; ret = 2; break; }\n      if (wc == 0x2f2e) { buf[0] = 0xc6; buf[1] = 0xcc; ret = 2; break; }\n      if (wc == 0x2f33) { buf[0] = 0xc6; buf[1] = 0xcd; ret = 2; break; }\n      if (wc == 0x2f34) { buf[0] = 0xc6; buf[1] = 0xce; ret = 2; break; }\n      if (wc == 0x2f35) { buf[0] = 0xc6; buf[1] = 0xcf; ret = 2; break; }\n      if (wc == 0x2f39) { buf[0] = 0xc6; buf[1] = 0xd0; ret = 2; break; }\n      if (wc == 0x2f3a) { buf[0] = 0xc6; buf[1] = 0xd1; ret = 2; break; }\n      if (wc == 0x2f41) { buf[0] = 0xc6; buf[1] = 0xd2; ret = 2; break; }\n      if (wc == 0x2f46) { buf[0] = 0xc6; buf[1] = 0xd3; ret = 2; break; }\n      if (wc == 0x2f67) { buf[0] = 0xc6; buf[1] = 0xd4; ret = 2; break; }\n      if (wc == 0x2f68) { buf[0] = 0xc6; buf[1] = 0xd5; ret = 2; break; }\n      if (wc == 0x2fa1) { buf[0] = 0xc6; buf[1] = 0xd6; ret = 2; break; }\n      if (wc == 0x2faa) { buf[0] = 0xc6; buf[1] = 0xd7; ret = 2; break; }\n      break;\n    case 0x30:\n      if (wc >= 0x3005 && wc <= 0x3007) {\n        buf[0] = 0xc6; buf[1] = wc - 0x2f25; ret = 2;\n        break;\n      }\n      if (wc >= 0x3038 && wc <= 0x303a) {\n        buf[0] = 0xa2; buf[1] = wc - 0x2f6c; ret = 2;\n        break;\n      }\n      if (wc >= 0x3041 && wc <= 0x3093) {\n        if (wc < 0x3059) {\n          buf[0] = 0xc6; buf[1] = wc - 0x2f5a;\n        } else {\n          buf[0] = 0xc7; buf[1] = wc - 0x3019;\n        }\n        ret = 2;\n        break;\n      }\n      if (wc == 0x309d) { buf[0] = 0xc6; buf[1] = 0xdc; ret = 2; break; }\n      if (wc == 0x309e) { buf[0] = 0xc6; buf[1] = 0xdd; ret = 2; break; }\n      if (wc >= 0x30a1 && wc <= 0x30f6) {\n        buf[0] = 0xc7; buf[1] = wc - (wc < 0x30a5 ? 0x3026 : 0x3004); ret = 2;\n        break;\n      }\n      if (wc == 0x30fc) { buf[0] = 0xc6; buf[1] = 0xe3; ret = 2; break; }\n      if (wc == 0x30fd) { buf[0] = 0xc6; buf[1] = 0xda; ret = 2; break; }\n      if (wc == 0x30fe) { buf[0] = 0xc6; buf[1] = 0xdb; ret = 2; break; }\n      break;\n    case 0x53:\n      if (wc == 0x5344)\n        return RET_ILUNI;\n      break;\n    case 0x58:\n      if (wc == 0x58bb) { buf[0] = 0xf9; buf[1] = 0xd9; ret = 2; break; }\n      break;\n    case 0x5a:\n      if (wc == 0x5afa) { buf[0] = 0xf9; buf[1] = 0xdc; ret = 2; break; }\n      break;\n    case 0x5f:\n      if (wc == 0x5f5e) { buf[0] = 0xc2; buf[1] = 0x55; ret = 2; break; }\n      if (wc == 0x5f5d)\n        return RET_ILUNI;\n      break;\n    case 0x60:\n      if (wc == 0x6052) { buf[0] = 0xf9; buf[1] = 0xda; ret = 2; break; }\n      break;\n    case 0x78:\n      if (wc == 0x7881) { buf[0] = 0xf9; buf[1] = 0xd6; ret = 2; break; }\n      break;\n    case 0x7c:\n      if (wc == 0x7ca7) { buf[0] = 0xf9; buf[1] = 0xdb; ret = 2; break; }\n      break;\n    case 0x88:\n      if (wc == 0x88cf) { buf[0] = 0xf9; buf[1] = 0xd8; ret = 2; break; }\n      break;\n    case 0x92:\n      if (wc == 0x92b9) { buf[0] = 0xf9; buf[1] = 0xd7; ret = 2; break; }\n      break;\n    case 0xe0: case 0xe1: case 0xe2: case 0xe3: case 0xe4: case 0xe5:\n    case 0xe6: case 0xe7: case 0xe8: case 0xe9: case 0xea: case 0xeb:\n    case 0xec: case 0xed: case 0xee: case 0xef: case 0xf0: case 0xf1:\n    case 0xf2: case 0xf3: case 0xf4: case 0xf5: case 0xf6:\n      {\n        unsigned int i = wc - 0xe000;\n        if (i < 5809) {\n          unsigned int c1 = i / 157;\n          unsigned int c2 = i % 157;\n          buf[0] = c1 + (c1 < 5 ? 0xfa : c1 < 24 ? 0x89 : 0x69);\n          buf[1] = c2 + (c2 < 0x3f ? 0x40 : 0x62);\n          ret = 2;\n          break;\n        }\n      }\n      break;\n    case 0xfe:\n      if (wc == 0xfe51) { buf[0] = 0xa1; buf[1] = 0x4e; ret = 2; break; }\n      if (wc == 0xfe68) { buf[0] = 0xa2; buf[1] = 0x42; ret = 2; break; }\n      break;\n    case 0xff:\n      if (wc == 0xff0f) { buf[0] = 0xa1; buf[1] = 0xfe; ret = 2; break; }\n      if (wc == 0xff3b) { buf[0] = 0xc6; buf[1] = 0xe4; ret = 2; break; }\n      if (wc == 0xff3c) { buf[0] = 0xa2; buf[1] = 0x40; ret = 2; break; }\n      if (wc == 0xff3d) { buf[0] = 0xc6; buf[1] = 0xe5; ret = 2; break; }\n      if (wc == 0xff3e) { buf[0] = 0xc6; buf[1] = 0xd9; ret = 2; break; }\n      if (wc == 0xff5e) { buf[0] = 0xa1; buf[1] = 0xe3; ret = 2; break; }\n      if (wc == 0xffe0) { buf[0] = 0xa2; buf[1] = 0x46; ret = 2; break; }\n      if (wc == 0xffe1) { buf[0] = 0xa2; buf[1] = 0x47; ret = 2; break; }\n      if (wc == 0xffe3) { buf[0] = 0xa1; buf[1] = 0xc3; ret = 2; break; }\n      if (wc == 0xffe5) { buf[0] = 0xa2; buf[1] = 0x44; ret = 2; break; }\n      if (wc == 0xff64)\n        return RET_ILUNI;\n      break;\n  }\n  if (ret == RET_ILUNI)\n    ret = big5_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 207,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/c99.h": {
    "c99_mbtowc": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static int\nc99_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c;\n  ucs4_t wc;\n  int i;\n\n  c = s[0];\n  if (c < 0xa0) {\n    if (c != '\\\\') {\n      *pwc = c;\n      return 1;\n    }\n    if (n < 2)\n      return RET_TOOFEW(0);\n    c = s[1];\n    if (c == 'u') {\n      wc = 0;\n      for (i = 2; i < 6; i++) {\n        if (n <= i)\n          return RET_TOOFEW(0);\n        c = s[i];\n        if (c >= '0' && c <= '9')\n          c -= '0';\n        else if (c >= 'A' && c <= 'Z')\n          c -= 'A'-10;\n        else if (c >= 'a' && c <= 'z')\n          c -= 'a'-10;\n        else\n          goto simply_backslash;\n        wc |= (ucs4_t) c << (4 * (5-i));\n      }\n      if ((wc >= 0x00a0 && !(wc >= 0xd800 && wc < 0xe000))\n          || wc == 0x0024 || wc == 0x0040 || wc == 0x0060) {\n        *pwc = wc;\n        return 6;\n      }\n    } else if (c == 'U') {\n      wc = 0;\n      for (i = 2; i < 10; i++) {\n        if (n <= i)\n          return RET_TOOFEW(0);\n        c = s[i];\n        if (c >= '0' && c <= '9')\n          c -= '0';\n        else if (c >= 'A' && c <= 'Z')\n          c -= 'A'-10;\n        else if (c >= 'a' && c <= 'z')\n          c -= 'a'-10;\n        else\n          goto simply_backslash;\n        wc |= (ucs4_t) c << (4 * (9-i));\n      }\n      if ((wc >= 0x00a0 && !(wc >= 0xd800 && wc < 0xe000))\n          || wc == 0x0024 || wc == 0x0040 || wc == 0x0060) {\n        *pwc = wc;\n        return 10;\n      }\n    } else\n      goto simply_backslash;\n  }\n  return RET_ILSEQ;\nsimply_backslash:\n  *pwc = '\\\\';\n  return 1;\n}",
      "lines": 66,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "c99_wctomb": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static int\nc99_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0xa0) {\n    *r = wc;\n    return 1;\n  } else {\n    int result;\n    unsigned char u;\n    if (wc < 0x10000) {\n      result = 6;\n      u = 'u';\n    } else {\n      result = 10;\n      u = 'U';\n    }\n    if (n >= result) {\n      int count;\n      r[0] = '\\\\';\n      r[1] = u;\n      r += 2;\n      for (count = result-3; count >= 0; count--) {\n        unsigned int i = (wc >> (4*count)) & 0x0f;\n        *r++ = (i < 10 ? '0'+i : 'a'-10+i);\n      }\n      return result;\n    } else\n      return RET_TOOSMALL;\n  }\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/canonical.h": {},
  "libiconv/libiconv-1.15/lib/canonical_aix.h": {},
  "libiconv/libiconv-1.15/lib/canonical_aix_sysaix.h": {},
  "libiconv/libiconv-1.15/lib/canonical_dos.h": {},
  "libiconv/libiconv-1.15/lib/canonical_extra.h": {},
  "libiconv/libiconv-1.15/lib/canonical_local.h": {},
  "libiconv/libiconv-1.15/lib/canonical_local_sysaix.h": {},
  "libiconv/libiconv-1.15/lib/canonical_local_syshpux.h": {},
  "libiconv/libiconv-1.15/lib/canonical_local_sysosf1.h": {},
  "libiconv/libiconv-1.15/lib/canonical_local_syssolaris.h": {},
  "libiconv/libiconv-1.15/lib/canonical_osf1.h": {},
  "libiconv/libiconv-1.15/lib/canonical_osf1_sysosf1.h": {},
  "libiconv/libiconv-1.15/lib/canonical_sysaix.h": {},
  "libiconv/libiconv-1.15/lib/canonical_syshpux.h": {},
  "libiconv/libiconv-1.15/lib/canonical_sysosf1.h": {},
  "libiconv/libiconv-1.15/lib/canonical_syssolaris.h": {},
  "libiconv/libiconv-1.15/lib/ces_big5.h": {
    "ces_big5_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int\nces_big5_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (BIG5) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff))\n        return big5_mbtowc(conv,pwc,s,2);\n      else\n        return RET_ILSEQ;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ces_big5_wctomb": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nces_big5_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (BIG5) */\n  ret = big5_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ces_gbk.h": {
    "ces_gbk_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int\nces_gbk_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n\n  /* Code set 0 (ASCII or GB 1988-89) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (GBK) */\n  if (c >= 0x81 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    return gbk_mbtowc(conv,pwc,s,2);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ces_gbk_wctomb": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\nces_gbk_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or GB 1988-89) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (GBK) */\n  ret = gbk_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cjk_variants.h": {},
  "libiconv/libiconv-1.15/lib/cns11643.h": {},
  "libiconv/libiconv-1.15/lib/cns11643_1.h": {
    "cns11643_1_mbtowc": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static int\ncns11643_1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x27) || (c1 == 0x42) || (c1 >= 0x44 && c1 <= 0x7d)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 3102) {\n          if (i < 500)\n            wc = cns11643_1_2uni_page21[i];\n          else if (i == 571)\n            wc = 0x4ea0;\n          else if (i == 578)\n            wc = 0x51ab;\n          else if (i == 583)\n            wc = 0x52f9;\n        } else if (i < 3290) {\n          if (i < 3136)\n            wc = cns11643_1_2uni_page42[i-3102];\n        } else {\n          if (i < 8691)\n            wc = cns11643_1_2uni_page44[i-3290];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 37,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_15.h": {
    "cns11643_15_mbtowc": {
      "start_point": [
        1054,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "static int\ncns11643_15_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x6d)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 7169)\n            swc = cns11643_15_2uni_page21[i],\n            wc = cns11643_15_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_2.h": {
    "cns11643_2_mbtowc": {
      "start_point": [
        1085,
        0
      ],
      "end_point": [
        1109,
        1
      ],
      "content": "static int\ncns11643_2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x72)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        {\n          if (i < 7650)\n            wc = cns11643_2_2uni_page21[i];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_3.h": {
    "cns11643_3_mbtowc": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        971,
        1
      ],
      "content": "static int\ncns11643_3_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x62) || (c1 >= 0x64 && c1 <= 0x67)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        if (i < 6298) {\n          if (i < 6148)\n            swc = cns11643_3_2uni_page21[i],\n            wc = cns11643_3_2uni_upages[swc>>8] | (swc & 0xff);\n        } else {\n          if (i < 6590)\n            swc = cns11643_3_2uni_page64[i-6298],\n            wc = cns11643_3_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 31,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_4.h": {
    "cns11643_4_mbtowc": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncns11643_4_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x6e)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 2914)\n            swc = cns11643_4a_2uni_page21[i],\n            wc = cns11643_4a_2uni_upages[swc>>8] | (swc & 0xff);\n          else if (i < 7298)\n            swc = cns11643_4b_2uni_page40[i-2914],\n            wc = cns11643_4b_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 30,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_4a.h": {},
  "libiconv/libiconv-1.15/lib/cns11643_4b.h": {},
  "libiconv/libiconv-1.15/lib/cns11643_5.h": {
    "cns11643_5_mbtowc": {
      "start_point": [
        1249,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "static int\ncns11643_5_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x7c)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 8603)\n            swc = cns11643_5_2uni_page21[i],\n            wc = cns11643_5_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_6.h": {
    "cns11643_6_mbtowc": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "static int\ncns11643_6_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x64)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 6388)\n            swc = cns11643_6_2uni_page21[i],\n            wc = cns11643_6_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_7.h": {
    "cns11643_7_mbtowc": {
      "start_point": [
        959,
        0
      ],
      "end_point": [
        985,
        1
      ],
      "content": "static int\ncns11643_7_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x66)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 6539)\n            swc = cns11643_7_2uni_page21[i],\n            wc = cns11643_7_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cns11643_inv.h": {
    "cns11643_inv_wctomb": {
      "start_point": [
        15366,
        0
      ],
      "end_point": [
        15410,
        1
      ],
      "content": "static int\ncns11643_inv_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0100)\n      summary = &cns11643_inv_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x0200 && wc < 0x03d0)\n      summary = &cns11643_inv_uni2indx_page02[(wc>>4)-0x020];\n    else if (wc >= 0x2000 && wc < 0x22c0)\n      summary = &cns11643_inv_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x2400 && wc < 0x2650)\n      summary = &cns11643_inv_uni2indx_page24[(wc>>4)-0x240];\n    else if (wc >= 0x3000 && wc < 0x9fb0)\n      summary = &cns11643_inv_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0xfa00 && wc < 0xfa30)\n      summary = &cns11643_inv_uni2indx_pagefa[(wc>>4)-0xfa0];\n    else if (wc >= 0xfe00 && wc < 0xfff0)\n      summary = &cns11643_inv_uni2indx_pagefe[(wc>>4)-0xfe0];\n    else if (wc >= 0x20000 && wc < 0x2a6e0)\n      summary = &cns11643_inv_uni2indx_page200[(wc>>4)-0x2000];\n    else if (wc >= 0x2f800 && wc < 0x2fa20)\n      summary = &cns11643_inv_uni2indx_page2f8[(wc>>4)-0x2f80];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        used += summary->indx;\n        r[0] = cns11643_inv_2charset[3*used];\n        r[1] = cns11643_inv_2charset[3*used+1];\n        r[2] = cns11643_inv_2charset[3*used+2];\n        return 3;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 45,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/converters.h": {},
  "libiconv/libiconv-1.15/lib/cp1046.h": {
    "cp1046_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp1046_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1046_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1046_wctomb": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static int\ncp1046_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0088 && wc < 0x00f8)\n    c = cp1046_page00[wc-0x0088];\n  else if (wc >= 0x0608 && wc < 0x0670)\n    c = cp1046_page06[wc-0x0608];\n  else if (wc >= 0x2500 && wc < 0x2520)\n    c = cp1046_page25[wc-0x2500];\n  else if (wc == 0x25a0)\n    c = 0x89;\n  else if (wc >= 0xf8f0 && wc < 0xf900)\n    c = cp1046_pagef8[wc-0xf8f0];\n  else if (wc >= 0xfe70 && wc < 0xff00)\n    c = cp1046_pagefe[wc-0xfe70];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1124.h": {
    "cp1124_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\ncp1124_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp1124_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1124_wctomb": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\ncp1124_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b0)\n    c = cp1124_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = cp1124_page04[wc-0x0400];\n  else if (wc == 0x2116)\n    c = 0xf0;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1125.h": {
    "cp1125_mbtowc": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ncp1125_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else if (c < 0xb0)\n    *pwc = (ucs4_t) c + 0x0390;\n  else\n    *pwc = (ucs4_t) cp1125_2uni[c-0xb0];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1125_wctomb": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static int\ncp1125_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b8)\n    c = cp1125_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = cp1125_page04[wc-0x0400];\n  else if (wc == 0x2116)\n    c = 0xfc;\n  else if (wc == 0x221a)\n    c = 0xfb;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp1125_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1129.h": {
    "cp1129_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\ncp1129_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp1129_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1129_wctomb": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static int\ncp1129_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a8) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a8 && wc < 0x01b8)\n    c = cp1129_page00[wc-0x00a8];\n  else if (wc >= 0x0300 && wc < 0x0328)\n    c = cp1129_page03[wc-0x0300];\n  else if (wc == 0x20ab)\n    c = 0xfe;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1131.h": {
    "cp1131_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp1131_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp1131_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1131_wctomb": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int\ncp1131_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b8)\n    c = cp1131_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = cp1131_page04[wc-0x0400];\n  else if (wc == 0x2219)\n    c = 0xfe;\n  else if (wc >= 0x2500 && wc < 0x2598)\n    c = cp1131_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1133.h": {
    "cp1133_mbtowc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\ncp1133_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0xe0) {\n    unsigned short wc = cp1133_2uni_1[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  else if (c < 0xf0) {\n  }\n  else {\n    unsigned short wc = cp1133_2uni_2[c-0xf0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1133_wctomb": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ncp1133_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b0)\n    c = cp1133_page00[wc-0x00a0];\n  else if (wc >= 0x0e80 && wc < 0x0ee0)\n    c = cp1133_page0e[wc-0x0e80];\n  else if (wc == 0x20ad)\n    c = 0xdf;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1161.h": {
    "cp1161_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp1161_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0xa0) {\n  }\n  else {\n    *pwc = (ucs4_t) cp1161_2uni[c-0xa0];\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1161_wctomb": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\ncp1161_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b0)\n    c = cp1161_page00[wc-0x00a0];\n  else if (wc >= 0x0e48 && wc < 0x0e4c)\n    c = wc-0x0d60;\n  else if (wc >= 0x0e00 && wc < 0x0e60)\n    c = cp874_page0e[wc-0x0e00];\n  else if (wc == 0x20ac)\n    c = 0xde;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1162.h": {
    "cp1162_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int\ncp1162_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp874_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n    if (c < 0xa0) {\n      *pwc = (ucs4_t) c;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1162_wctomb": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\ncp1162_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0080 && wc < 0x00a0 && cp874_2uni[wc-0x0080] == 0xfffd)\n    c = wc;\n  else if (wc == 0x00a0)\n    c = 0xa0;\n  else if (wc >= 0x0e00 && wc < 0x0e60)\n    c = cp874_page0e[wc-0x0e00];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = cp874_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1163.h": {
    "cp1163_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\ncp1163_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else if (c == 0xa4)\n    *pwc = 0x20ac;\n  else\n    *pwc = (ucs4_t) cp1129_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1163_wctomb": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\ncp1163_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0 || (wc < 0x00a8 && wc != 0x00a4) || wc == 0x00d0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a8 && wc < 0x01b8)\n    c = cp1129_page00[wc-0x00a8];\n  else if (wc >= 0x0300 && wc < 0x0328)\n    c = cp1129_page03[wc-0x0300];\n  else if (wc == 0x203e)\n    c = 0xaf;\n  else if (wc >= 0x20a8 && wc < 0x20b0)\n    c = cp1163_page20[wc-0x20a8];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1250.h": {
    "cp1250_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp1250_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1250_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1250_wctomb": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\ncp1250_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = cp1250_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1250_page02[wc-0x02c0];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1250_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1251.h": {
    "cp1251_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp1251_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1251_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1251_wctomb": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static int\ncp1251_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = cp1251_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = cp1251_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1251_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x88;\n  else if (wc == 0x2116)\n    c = 0xb9;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1252.h": {
    "cp1252_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\ncp1252_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80 || c >= 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1252_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1252_wctomb": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\ncp1252_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = wc;\n  else if (wc >= 0x0150 && wc < 0x0198)\n    c = cp1252_page01[wc-0x0150];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1252_page02[wc-0x02c0];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1252_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1253.h": {
    "cp1253_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp1253_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1253_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1253_wctomb": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\ncp1253_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = cp1253_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x83;\n  else if (wc >= 0x0380 && wc < 0x03d0)\n    c = cp1253_page03[wc-0x0380];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1253_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1254.h": {
    "cp1254_mbtowc": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\ncp1254_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0xa0) {\n    unsigned short wc = cp1254_2uni_1[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  else if (c < 0xd0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0xe0) {\n    *pwc = (ucs4_t) cp1254_2uni_2[c-0xd0];\n    return 1;\n  }\n  else if (c < 0xf0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    *pwc = (ucs4_t) cp1254_2uni_3[c-0xf0];\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1254_wctomb": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\ncp1254_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00d0)\n    c = wc;\n  else if (wc >= 0x00d0 && wc < 0x0100)\n    c = cp1254_page00[wc-0x00d0];\n  else if (wc >= 0x0118 && wc < 0x0198)\n    c = cp1254_page01[wc-0x0118];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1254_page02[wc-0x02c0];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1254_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1255.h": {
    "cp1255_mbtowc": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\ncp1255_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  unsigned short wc;\n  unsigned short last_wc;\n  if (c < 0x80) {\n    wc = c;\n  } else {\n    wc = cp1255_2uni[c-0x80];\n    if (wc == 0xfffd)\n      return RET_ILSEQ;\n  }\n  last_wc = conv->istate;\n  if (last_wc) {\n    if (wc >= 0x05b0 && wc < 0x05c5) {\n      /* See whether last_wc and wc can be combined. */\n      unsigned int k;\n      unsigned int i1, i2;\n      switch (wc) {\n        case 0x05b4: k = 0; break;\n        case 0x05b7: k = 1; break;\n        case 0x05b8: k = 2; break;\n        case 0x05b9: k = 3; break;\n        case 0x05bc: k = 4; break;\n        case 0x05bf: k = 5; break;\n        case 0x05c1: k = 6; break;\n        case 0x05c2: k = 7; break;\n        default: goto not_combining;\n      }\n      i1 = cp1255_comp_table[k].idx;\n      i2 = i1 + cp1255_comp_table[k].len-1;\n      if (last_wc >= cp1255_comp_table_data[i1].base\n          && last_wc <= cp1255_comp_table_data[i2].base) {\n        unsigned int i;\n        for (;;) {\n          i = (i1+i2)>>1;\n          if (last_wc == cp1255_comp_table_data[i].base)\n            break;\n          if (last_wc < cp1255_comp_table_data[i].base) {\n            if (i1 == i)\n              goto not_combining;\n            i2 = i;\n          } else {\n            if (i1 != i)\n              i1 = i;\n            else {\n              i = i2;\n              if (last_wc == cp1255_comp_table_data[i].base)\n                break;\n              goto not_combining;\n            }\n          }\n        }\n        last_wc = cp1255_comp_table_data[i].composed;\n        if (last_wc == 0xfb2a || last_wc == 0xfb2b || last_wc == 0xfb49) {\n          /* Buffer the combined character. */\n          conv->istate = last_wc;\n          return RET_TOOFEW(1);\n        } else {\n          /* Output the combined character. */\n          conv->istate = 0;\n          *pwc = (ucs4_t) last_wc;\n          return 1;\n        }\n      }\n    }\n  not_combining:\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = (ucs4_t) last_wc;\n    return 0; /* Don't advance the input pointer. */\n  }\n  if ((wc >= 0x05d0 && wc <= 0x05ea && ((0x07db5f7f >> (wc - 0x05d0)) & 1))\n      || wc == 0x05f2) {\n    /* wc is a possible match in cp1255_comp_table_data. Buffer it. */\n    conv->istate = wc;\n    return RET_TOOFEW(1);\n  } else {\n    /* Output wc immediately. */\n    *pwc = (ucs4_t) wc;\n    return 1;\n  }\n}",
      "lines": 84,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1255_wctomb": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static int\ncp1255_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = cp1255_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x83;\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1255_page02[wc-0x02c0];\n  else if (wc >= 0x05b0 && wc < 0x05f8)\n    c = cp1255_page05[wc-0x05b0];\n  else if (wc >= 0x2008 && wc < 0x2040)\n    c = cp1255_page20[wc-0x2008];\n  else if (wc == 0x20aa)\n    c = 0xa4;\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  /* Try canonical decomposition. */\n  {\n    /* Binary search through cp1255_decomp_table. */\n    unsigned int i1 = 0;\n    unsigned int i2 = sizeof(cp1255_decomp_table)/sizeof(cp1255_decomp_table[0])-1;\n    if (wc >= cp1255_decomp_table[i1].composed\n        && wc <= cp1255_decomp_table[i2].composed) {\n      unsigned int i;\n      for (;;) {\n        /* Here i2 - i1 > 0. */\n        i = (i1+i2)>>1;\n        if (wc == cp1255_decomp_table[i].composed)\n          break;\n        if (wc < cp1255_decomp_table[i].composed) {\n          if (i1 == i)\n            return RET_ILUNI;\n          /* Here i1 < i < i2. */\n          i2 = i;\n        } else {\n          /* Here i1 <= i < i2. */\n          if (i1 != i)\n            i1 = i;\n          else {\n            /* Here i2 - i1 = 1. */\n            i = i2;\n            if (wc == cp1255_decomp_table[i].composed)\n              break;\n            else\n              return RET_ILUNI;\n          }\n        }\n      }\n      /* Found a canonical decomposition. */\n      wc = cp1255_decomp_table[i].base;\n      /* wc is one of 0x05d0..0x05d6, 0x05d8..0x05dc, 0x05de, 0x05e0..0x05e1,\n         0x05e3..0x05e4, 0x05e6..0x05ea, 0x05f2. */\n      c = cp1255_page05[wc-0x05b0];\n      if (cp1255_decomp_table[i].comb2 < 0) {\n        if (n < 2)\n          return RET_TOOSMALL;\n        r[0] = c;\n        r[1] = cp1255_comb_table[cp1255_decomp_table[i].comb1];\n        return 2;\n      } else {\n        if (n < 3)\n          return RET_TOOSMALL;\n        r[0] = c;\n        r[1] = cp1255_comb_table[cp1255_decomp_table[i].comb1];\n        r[2] = cp1255_comb_table[cp1255_decomp_table[i].comb2];\n        return 3;\n      }\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1256.h": {
    "cp1256_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp1256_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp1256_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1256_wctomb": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\ncp1256_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp1256_page00[wc-0x00a0];\n  else if (wc >= 0x0150 && wc < 0x0198)\n    c = cp1256_page01[wc-0x0150];\n  else if (wc == 0x02c6)\n    c = 0x88;\n  else if (wc >= 0x0608 && wc < 0x06d8)\n    c = cp1256_page06[wc-0x0608];\n  else if (wc >= 0x2008 && wc < 0x2040)\n    c = cp1256_page20[wc-0x2008];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1257.h": {
    "cp1257_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp1257_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp1257_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1257_wctomb": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\ncp1257_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = cp1257_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1257_page02[wc-0x02c0];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1257_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp1258.h": {
    "cp1258_mbtowc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\ncp1258_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  unsigned short wc;\n  unsigned short last_wc;\n  if (c < 0x80) {\n    wc = c;\n  } else {\n    wc = cp1258_2uni[c-0x80];\n    if (wc == 0xfffd)\n      return RET_ILSEQ;\n  }\n  last_wc = conv->istate;\n  if (last_wc) {\n    if (wc >= 0x0300 && wc < 0x0340) {\n      /* See whether last_wc and wc can be combined. */\n      unsigned int k;\n      unsigned int i1, i2;\n      switch (wc) {\n        case 0x0300: k = 0; break;\n        case 0x0301: k = 1; break;\n        case 0x0303: k = 2; break;\n        case 0x0309: k = 3; break;\n        case 0x0323: k = 4; break;\n        default: abort();\n      }\n      i1 = viet_comp_table[k].idx;\n      i2 = i1 + viet_comp_table[k].len-1;\n      if (last_wc >= viet_comp_table_data[i1].base\n          && last_wc <= viet_comp_table_data[i2].base) {\n        unsigned int i;\n        for (;;) {\n          i = (i1+i2)>>1;\n          if (last_wc == viet_comp_table_data[i].base)\n            break;\n          if (last_wc < viet_comp_table_data[i].base) {\n            if (i1 == i)\n              goto not_combining;\n            i2 = i;\n          } else {\n            if (i1 != i)\n              i1 = i;\n            else {\n              i = i2;\n              if (last_wc == viet_comp_table_data[i].base)\n                break;\n              goto not_combining;\n            }\n          }\n        }\n        last_wc = viet_comp_table_data[i].composed;\n        /* Output the combined character. */\n        conv->istate = 0;\n        *pwc = (ucs4_t) last_wc;\n        return 1;\n      }\n    }\n  not_combining:\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = (ucs4_t) last_wc;\n    return 0; /* Don't advance the input pointer. */\n  }\n  if (wc >= 0x0041 && wc <= 0x01b0\n      && ((cp1258_comp_bases[(wc - 0x0040) >> 5] >> (wc & 0x1f)) & 1)) {\n    /* wc is a possible match in viet_comp_table_data. Buffer it. */\n    conv->istate = wc;\n    return RET_TOOFEW(1);\n  } else {\n    /* Output wc immediately. */\n    *pwc = (ucs4_t) wc;\n    return 1;\n  }\n}",
      "lines": 75,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp1258_wctomb": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static int\ncp1258_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = wc;\n  else if (wc >= 0x00c0 && wc < 0x0118)\n    c = cp1258_page00[wc-0x00c0];\n  else if (wc >= 0x0150 && wc < 0x01b8)\n    c = cp1258_page01[wc-0x0150];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp1258_page02[wc-0x02c0];\n  else if (wc >= 0x0300 && wc < 0x0328)\n    c = cp1258_page03[wc-0x0300];\n  else if (wc >= 0x0340 && wc < 0x0342) /* deprecated Vietnamese tone marks */\n    c = cp1258_page03[wc-0x0340];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = cp1258_page20[wc-0x2010];\n  else if (wc == 0x20ab)\n    c = 0xfe;\n  else if (wc == 0x20ac)\n    c = 0x80;\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  /* Try canonical decomposition. */\n  {\n    /* Binary search through viet_decomp_table. */\n    unsigned int i1 = 0;\n    unsigned int i2 = sizeof(viet_decomp_table)/sizeof(viet_decomp_table[0])-1;\n    if (wc >= viet_decomp_table[i1].composed\n        && wc <= viet_decomp_table[i2].composed) {\n      unsigned int i;\n      for (;;) {\n        /* Here i2 - i1 > 0. */\n        i = (i1+i2)>>1;\n        if (wc == viet_decomp_table[i].composed)\n          break;\n        if (wc < viet_decomp_table[i].composed) {\n          if (i1 == i)\n            return RET_ILUNI;\n          /* Here i1 < i < i2. */\n          i2 = i;\n        } else {\n          /* Here i1 <= i < i2. */\n          if (i1 != i)\n            i1 = i;\n          else {\n            /* Here i2 - i1 = 1. */\n            i = i2;\n            if (wc == viet_decomp_table[i].composed)\n              break;\n            else\n              return RET_ILUNI;\n          }\n        }\n      }\n      /* Found a canonical decomposition. */\n      wc = viet_decomp_table[i].base;\n      /* wc is one of 0x0020, 0x0041..0x005a, 0x0061..0x007a, 0x00a5, 0x00a8,\n         0x00c2, 0x00c5..0x00c7, 0x00ca, 0x00cf, 0x00d3, 0x00d4, 0x00d6,\n         0x00d8, 0x00da, 0x00dc, 0x00e2, 0x00e5..0x00e7, 0x00ea, 0x00ef,\n         0x00f3, 0x00f4, 0x00f6, 0x00f8, 0x00fc, 0x0102, 0x0103, 0x01a0,\n         0x01a1, 0x01af, 0x01b0. */\n      if (wc < 0x0100)\n        c = wc;\n      else if (wc < 0x0118)\n        c = cp1258_page00[wc-0x00c0];\n      else\n        c = cp1258_page01[wc-0x0150];\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = c;\n      r[1] = cp1258_comb_table[viet_decomp_table[i].comb1];\n      return 2;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp437.h": {
    "cp437_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp437_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp437_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp437_wctomb": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ncp437_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp437_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp437_page03[wc-0x0390];\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x20a7)\n    c = 0x9e;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp437_page22[wc-0x2218];\n  else if (wc >= 0x2310 && wc < 0x2328)\n    c = cp437_page23[wc-0x2310];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp437_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp50221_0208_ext.h": {
    "cp50221_0208_ext_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ncp50221_0208_ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x60) {\n    unsigned short wc = cp50221_0208_ext_2uni[c];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp50221_0208_ext_wctomb": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static int\ncp50221_0208_ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc >= 0x2110 && wc < 0x2170)\n    c = cp50221_0208_ext_page21[wc-0x2110];\n  else if (wc >= 0x2210 && wc < 0x2230)\n    c = cp50221_0208_ext_page22[wc-0x2210];\n  else if (wc == 0x22bf)\n    c = 0x59;\n  else if (wc >= 0x2460 && wc < 0x2478)\n    c = cp50221_0208_ext_page24[wc-0x2460];\n  else if (wc >= 0x3018 && wc < 0x3020)\n    c = cp50221_0208_ext_page30[wc-0x3018];\n  else if (wc >= 0x3230 && wc < 0x3240)\n    c = cp50221_0208_ext_page32[wc-0x3230];\n  else if (wc >= 0x32a0 && wc < 0x32b0)\n    c = cp50221_0208_ext_page32_1[wc-0x32a0];\n  else if (wc >= 0x3300 && wc < 0x33d0)\n    c = cp50221_0208_ext_page33[wc-0x3300];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp50221_0212_ext.h": {
    "cp50221_0212_ext_mbtowc": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\ncp50221_0212_ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x70) {\n    unsigned short wc = cp50221_0212_ext_2uni[c];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  else if (c == 0xa1) {\n    *pwc = 0x974d;\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp50221_0212_ext_wctomb": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static int\ncp50221_0212_ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc >= 0x2170 && wc < 0x2180)\n    c = cp50221_0212_ext_page21[wc-0x2170];\n  else if (wc == 0x4efc)\n    c = 0x1b;\n  else if (wc == 0x50f4)\n    c = 0x1c;\n  else if (wc == 0x51ec)\n    c = 0x1d;\n  else if (wc >= 0x5300 && wc < 0x5328)\n    c = cp50221_0212_ext_page53[wc-0x5300];\n  else if (wc == 0x548a)\n    c = 0x21;\n  else if (wc == 0x5759)\n    c = 0x22;\n  else if (wc == 0x589e)\n    c = 0x25;\n  else if (wc == 0x5bec)\n    c = 0x26;\n  else if (wc == 0x5cf5)\n    c = 0x27;\n  else if (wc == 0x5d53)\n    c = 0x28;\n  else if (wc == 0x5fb7)\n    c = 0x2a;\n  else if (wc == 0x6085)\n    c = 0x2b;\n  else if (wc == 0x6120)\n    c = 0x2c;\n  else if (wc == 0x654e)\n    c = 0x2d;\n  else if (wc == 0x6665)\n    c = 0x2f;\n  else if (wc == 0x6801)\n    c = 0x32;\n  else if (wc == 0x6a6b)\n    c = 0x35;\n  else if (wc == 0x6ae2)\n    c = 0x36;\n  else if (wc >= 0x6df0 && wc < 0x6e00)\n    c = cp50221_0212_ext_page6d[wc-0x6df0];\n  else if (wc == 0x7028)\n    c = 0x39;\n  else if (wc == 0x70bb)\n    c = 0x1a;\n  else if (wc == 0x7501)\n    c = 0x3c;\n  else if (wc >= 0x7680 && wc < 0x76a0)\n    c = cp50221_0212_ext_page76[wc-0x7680];\n  else if (wc == 0x7930)\n    c = 0x40;\n  else if (wc == 0x7ae7)\n    c = 0x45;\n  else if (wc >= 0x7da0 && wc < 0x7dd8)\n    c = cp50221_0212_ext_page7d[wc-0x7da0];\n  else if (wc == 0x8362)\n    c = 0x4b;\n  else if (wc == 0x85b0)\n    c = 0x4d;\n  else if (wc == 0x8807)\n    c = 0x50;\n  else if (wc == 0x8b7f)\n    c = 0x52;\n  else if (wc == 0x8cf4)\n    c = 0x53;\n  else if (wc == 0x8d76)\n    c = 0x54;\n  else if (wc == 0x90de)\n    c = 0x58;\n  else if (wc == 0x9115)\n    c = 0x5a;\n  else if (wc == 0x9592)\n    c = 0x5d;\n  else if (wc >= 0x9738 && wc < 0x9758)\n    c = cp50221_0212_ext_page97[wc-0x9738];\n  else if (wc == 0x999e)\n    c = 0x66;\n  else if (wc == 0x9ad9)\n    c = 0x67;\n  else if (wc == 0x9b72)\n    c = 0x68;\n  else if (wc == 0x9ed1)\n    c = 0x6a;\n  else if (wc == 0xf929)\n    c = 0x31;\n  else if (wc == 0xf9dc)\n    c = 0x5e;\n  else if (wc >= 0xfa08 && wc < 0xfa30)\n    c = cp50221_0212_ext_pagefa[wc-0xfa08];\n  else if (wc >= 0xff00 && wc < 0xff08)\n    c = cp50221_0212_ext_pageff[wc-0xff00];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 100,
      "depth": 52,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp737.h": {
    "cp737_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp737_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp737_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp737_wctomb": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\ncp737_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b8)\n    c = cp737_page00[wc-0x00a0];\n  else if (wc == 0x00f7)\n    c = 0xf6;\n  else if (wc >= 0x0380 && wc < 0x03d0)\n    c = cp737_page03[wc-0x0380];\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp737_page22[wc-0x2218];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp737_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp775.h": {
    "cp775_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp775_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp775_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp775_wctomb": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ncp775_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = cp775_page00[wc-0x00a0];\n  else if (wc >= 0x2018 && wc < 0x2020)\n    c = cp775_page20[wc-0x2018];\n  else if (wc == 0x2219)\n    c = 0xf9;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp775_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp850.h": {
    "cp850_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp850_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp850_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp850_wctomb": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\ncp850_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp850_page00[wc-0x00a0];\n  else if (wc == 0x0131)\n    c = 0xd5;\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc == 0x2017)\n    c = 0xf2;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp850_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp852.h": {
    "cp852_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp852_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp852_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp852_wctomb": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\ncp852_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = cp852_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = cp852_page02[wc-0x02c0];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp852_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp853.h": {
    "cp853_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp853_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp853_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp853_wctomb": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static int\ncp853_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp853_page00[wc-0x00a0];\n  else if (wc >= 0x0108 && wc < 0x0180)\n    c = cp853_page01[wc-0x0108];\n  else if (wc >= 0x02d8 && wc < 0x02e0)\n    c = cp853_page02[wc-0x02d8];\n  else if (wc == 0x2113)\n    c = 0xf2;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp853_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp855.h": {
    "cp855_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp855_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp855_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp855_wctomb": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\ncp855_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = cp855_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0460)\n    c = cp855_page04[wc-0x0400];\n  else if (wc == 0x2116)\n    c = 0xef;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp855_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp856.h": {
    "cp856_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp856_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp856_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp856_wctomb": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static int\ncp856_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = cp856_page00[wc-0x00a0];\n  else if (wc >= 0x05d0 && wc < 0x05f0)\n    c = cp856_page05[wc-0x05d0];\n  else if (wc == 0x2017)\n    c = 0xf2;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp856_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp857.h": {
    "cp857_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp857_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp857_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp857_wctomb": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static int\ncp857_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp857_page00[wc-0x00a0];\n  else if (wc >= 0x0118 && wc < 0x0160)\n    c = cp857_page01[wc-0x0118];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp857_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp858.h": {
    "cp858_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\ncp858_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else if (c == 0xd5)\n    *pwc = 0x20ac;\n  else\n    *pwc = (ucs4_t) cp850_2uni[c-0x80];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp858_wctomb": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp858_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp850_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc == 0x2017)\n    c = 0xf2;\n  else if (wc == 0x20ac)\n    c = 0xd5;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp850_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp860.h": {
    "cp860_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp860_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp860_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp860_wctomb": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static int\ncp860_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp860_page00[wc-0x00a0];\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp860_page03[wc-0x0390];\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x20a7)\n    c = 0x9e;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp860_page22[wc-0x2218];\n  else if (wc >= 0x2320 && wc < 0x2322)\n    c = wc-0x222c;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp860_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp861.h": {
    "cp861_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp861_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp861_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp861_wctomb": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ncp861_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp861_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp861_page03[wc-0x0390];\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x20a7)\n    c = 0x9e;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp861_page22[wc-0x2218];\n  else if (wc >= 0x2310 && wc < 0x2328)\n    c = cp861_page23[wc-0x2310];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp861_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp862.h": {
    "cp862_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp862_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp862_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp862_wctomb": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ncp862_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp862_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp862_page03[wc-0x0390];\n  else if (wc >= 0x05d0 && wc < 0x05eb)\n    c = wc-0x0550;\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x20a7)\n    c = 0x9e;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp862_page22[wc-0x2218];\n  else if (wc == 0x2310)\n    c = 0xa9;\n  else if (wc >= 0x2320 && wc < 0x2322)\n    c = wc-0x222c;\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp862_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 34,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp863.h": {
    "cp863_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp863_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp863_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp863_wctomb": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ncp863_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp863_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp863_page03[wc-0x0390];\n  else if (wc == 0x2017)\n    c = 0x8d;\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp863_page22[wc-0x2218];\n  else if (wc >= 0x2310 && wc < 0x2328)\n    c = cp863_page23[wc-0x2310];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp863_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp864.h": {
    "cp864_mbtowc": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\ncp864_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x20) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0x30) {\n    *pwc = (ucs4_t) cp864_2uni_1[c-0x20];\n    return 1;\n  }\n  else if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp864_2uni_2[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp864_wctomb": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static int\ncp864_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0020) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0020 && wc < 0x0028)\n    c = cp864_page00[wc-0x0020];\n  else if (wc >= 0x0028 && wc < 0x0080)\n    c = wc;\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = cp864_page00_1[wc-0x00a0];\n  else if (wc == 0x03b2)\n    c = 0x90;\n  else if (wc == 0x03c6)\n    c = 0x92;\n  else if (wc >= 0x0608 && wc < 0x0670)\n    c = cp864_page06[wc-0x0608];\n  else if (wc >= 0x2218 && wc < 0x2250)\n    c = cp864_page22[wc-0x2218];\n  else if (wc >= 0x2500 && wc < 0x2540)\n    c = cp864_page25[wc-0x2500];\n  else if (wc == 0x2592)\n    c = 0x84;\n  else if (wc == 0x25a0)\n    c = 0xfe;\n  else if (wc >= 0xfe78 && wc < 0xff00)\n    c = cp864_pagefe[wc-0xfe78];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp865.h": {
    "cp865_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\ncp865_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp865_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp865_wctomb": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static int\ncp865_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = cp865_page00[wc-0x00a0];\n  else if (wc == 0x0192)\n    c = 0x9f;\n  else if (wc >= 0x0390 && wc < 0x03c8)\n    c = cp865_page03[wc-0x0390];\n  else if (wc == 0x207f)\n    c = 0xfc;\n  else if (wc == 0x20a7)\n    c = 0x9e;\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = cp865_page22[wc-0x2218];\n  else if (wc >= 0x2310 && wc < 0x2328)\n    c = cp865_page23[wc-0x2310];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp865_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp866.h": {
    "cp866_mbtowc": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static int\ncp866_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else if (c < 0xb0)\n    *pwc = (ucs4_t) c + 0x0390;\n  else\n    *pwc = (ucs4_t) cp866_2uni[c-0xb0];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp866_wctomb": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static int\ncp866_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b8)\n    c = cp866_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0460)\n    c = cp866_page04[wc-0x0400];\n  else if (wc == 0x2116)\n    c = 0xfc;\n  else if (wc >= 0x2218 && wc < 0x2220)\n    c = cp866_page22[wc-0x2218];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp866_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp869.h": {
    "cp869_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp869_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp869_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp869_wctomb": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\ncp869_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = cp869_page00[wc-0x00a0];\n  else if (wc >= 0x0380 && wc < 0x03d0)\n    c = cp869_page03[wc-0x0380];\n  else if (wc >= 0x2010 && wc < 0x2020)\n    c = cp869_page20[wc-0x2010];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = cp869_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp874.h": {
    "cp874_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\ncp874_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = cp874_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp874_wctomb": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ncp874_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc == 0x00a0)\n    c = 0xa0;\n  else if (wc >= 0x0e00 && wc < 0x0e60)\n    c = cp874_page0e[wc-0x0e00];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = cp874_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x80;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp922.h": {
    "cp922_mbtowc": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\ncp922_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else if (c < 0xb0)\n    *pwc = (ucs4_t) cp922_2uni_1[c-0xa0];\n  else if (c < 0xd0)\n    *pwc = (ucs4_t) c;\n  else if (c < 0xe0)\n    *pwc = (ucs4_t) cp922_2uni_2[c-0xd0];\n  else if (c < 0xf0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) cp922_2uni_3[c-0xf0];\n  return 1;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp922_wctomb": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\ncp922_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a8) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a8 && wc < 0x0100)\n    c = cp922_page00[wc-0x00a8];\n  else if (wc >= 0x0160 && wc < 0x0180)\n    c = cp922_page01[wc-0x0160];\n  else if (wc == 0x203e)\n    c = 0xaf;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp932.h": {
    "cp932_mbtowc": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\ncp932_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  else if (c >= 0xa1 && c <= 0xdf)\n    return jisx0201_mbtowc(conv,pwc,s,n);\n  else {\n    unsigned char s1, s2;\n    s1 = c;\n    if ((s1 >= 0x81 && s1 <= 0x9f && s1 != 0x87) || (s1 >= 0xe0 && s1 <= 0xea)) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      s2 = s[1];\n      if ((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0x80 && s2 <= 0xfc)) {\n        unsigned char t1 = (s1 < 0xe0 ? s1-0x81 : s1-0xc1);\n        unsigned char t2 = (s2 < 0x80 ? s2-0x40 : s2-0x41);\n        unsigned char buf[2];\n        buf[0] = 2*t1 + (t2 < 0x5e ? 0 : 1) + 0x21;\n        buf[1] = (t2 < 0x5e ? t2 : t2-0x5e) + 0x21;\n        return jisx0208_mbtowc(conv,pwc,buf,2);\n      }\n    } else if ((s1 == 0x87) || (s1 >= 0xed && s1 <= 0xee) || (s1 >= 0xfa)) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      return cp932ext_mbtowc(conv,pwc,s,2);\n    } else if (s1 >= 0xf0 && s1 <= 0xf9) {\n      /* User-defined range. See\n       * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n      if (n < 2)\n        return RET_TOOFEW(0);\n      s2 = s[1];\n      if ((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0x80 && s2 <= 0xfc)) {\n        *pwc = 0xe000 + 188*(s1 - 0xf0) + (s2 < 0x80 ? s2-0x40 : s2-0x41);\n        return 2;\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 41,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp932_wctomb": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\ncp932_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    unsigned char c;\n    if (ret != 1) abort();\n    c = buf[0];\n    if (c < 0x80) {\n      r[0] = c;\n      return 1;\n    }\n  }\n\n  /* Try JIS X 0201-1976 Katakana. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    unsigned char c;\n    if (ret != 1) abort();\n    c = buf[0];\n    if (c >= 0xa1 && c <= 0xdf) {\n      r[0] = c;\n      return 1;\n    }\n  }\n\n  /* Try JIS X 0208-1990. */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    unsigned char c1, c2;\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    c1 = buf[0];\n    c2 = buf[1];\n    if ((c1 >= 0x21 && c1 <= 0x74) && (c2 >= 0x21 && c2 <= 0x7e)) {\n      unsigned char t1 = (c1 - 0x21) >> 1;\n      unsigned char t2 = (((c1 - 0x21) & 1) ? 0x5e : 0) + (c2 - 0x21);\n      r[0] = (t1 < 0x1f ? t1+0x81 : t1+0xc1);\n      r[1] = (t2 < 0x3f ? t2+0x40 : t2+0x41);\n      return 2;\n    }\n  }\n\n  /* Try CP932 extensions. */\n  ret = cp932ext_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  /* User-defined range. See\n   * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n  if (wc >= 0xe000 && wc < 0xe758) {\n    unsigned char c1, c2;\n    if (n < 2)\n      return RET_TOOSMALL;\n    c1 = (unsigned int) (wc - 0xe000) / 188;\n    c2 = (unsigned int) (wc - 0xe000) % 188;\n    r[0] = c1+0xf0;\n    r[1] = (c2 < 0x3f ? c2+0x40 : c2+0x41);\n    return 2;\n  }\n\n  /* Irreversible mappings.  */\n  if (wc == 0xff5e) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x81;\n    r[1] = 0x60;\n    return 2;\n  }\n  if (wc == 0x2225) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x81;\n    r[1] = 0x61;\n    return 2;\n  }\n  if (wc == 0xff0d) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x81;\n    r[1] = 0x7c;\n    return 2;\n  }\n  if (wc == 0xffe0) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x81;\n    r[1] = 0x91;\n    return 2;\n  }\n  if (wc == 0xffe1) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x81;\n    r[1] = 0x92;\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 111,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp932ext.h": {
    "cp932ext_mbtowc": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static int\ncp932ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x87) || (c1 >= 0xed && c1 <= 0xee) || (c1 >= 0xfa && c1 <= 0xfc)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xfd)) {\n        unsigned int i = 188 * (c1 - (c1 >= 0xe0 ? 0xc1 : 0x81)) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n        unsigned short wc = 0xfffd;\n        if (i < 8272) {\n          if (i < 1220)\n            wc = cp932ext_2uni_page87[i-1128];\n        } else if (i < 10716) {\n          if (i < 8648)\n            wc = cp932ext_2uni_pageed[i-8272];\n        } else {\n          if (i < 11104)\n            wc = cp932ext_2uni_pagefa[i-10716];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 31,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp932ext_wctomb": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "static int\ncp932ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x2100 && wc < 0x22c0)\n      summary = &cp932ext_uni2indx_page21[(wc>>4)-0x210];\n    else if (wc >= 0x2400 && wc < 0x2480)\n      summary = &cp932ext_uni2indx_page24[(wc>>4)-0x240];\n    else if (wc >= 0x3000 && wc < 0x3020)\n      summary = &cp932ext_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x3200 && wc < 0x33d0)\n      summary = &cp932ext_uni2indx_page32[(wc>>4)-0x320];\n    else if (wc >= 0x4e00 && wc < 0x5590)\n      summary = &cp932ext_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0x5700 && wc < 0x59c0)\n      summary = &cp932ext_uni2indx_page57[(wc>>4)-0x570];\n    else if (wc >= 0x5b00 && wc < 0x5de0)\n      summary = &cp932ext_uni2indx_page5b[(wc>>4)-0x5b0];\n    else if (wc >= 0x5f00 && wc < 0x7ba0)\n      summary = &cp932ext_uni2indx_page5f[(wc>>4)-0x5f0];\n    else if (wc >= 0x7d00 && wc < 0x7fb0)\n      summary = &cp932ext_uni2indx_page7d[(wc>>4)-0x7d0];\n    else if (wc >= 0x8300 && wc < 0x85c0)\n      summary = &cp932ext_uni2indx_page83[(wc>>4)-0x830];\n    else if (wc >= 0x8800 && wc < 0x8ed0)\n      summary = &cp932ext_uni2indx_page88[(wc>>4)-0x880];\n    else if (wc >= 0x9000 && wc < 0x9ee0)\n      summary = &cp932ext_uni2indx_page90[(wc>>4)-0x900];\n    else if (wc >= 0xf900 && wc < 0xfa30)\n      summary = &cp932ext_uni2indx_pagef9[(wc>>4)-0xf90];\n    else if (wc >= 0xff00 && wc < 0xfff0)\n      summary = &cp932ext_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = cp932ext_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 54,
      "depth": 26,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp936.h": {
    "cp936_mbtowc": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static int\ncp936_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  /* Try GBK first. */\n  {\n    int ret = ces_gbk_mbtowc(conv,pwc,s,n);\n    if (ret != RET_ILSEQ)\n      return ret;\n  }\n  /* Then handle the additional mappings. */\n  {\n    unsigned char c = *s;\n    if (c == 0x80) {\n      *pwc = 0x20ac;\n      return 1;\n    }\n    /* User-defined characters */\n    if (c >= 0xa1 && c <= 0xa2) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xa1)) {\n          *pwc = 0xe4c6 + 96 * (c - 0xa1) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n          return 2;\n        }\n      }\n    } else if ((c >= 0xaa && c < 0xb0) || (c >= 0xf8 && c < 0xff)) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      {\n        unsigned char c2 = s[1];\n        if (c2 >= 0xa1 && c2 < 0xff) {\n          *pwc = 0xe000 + 94 * (c - (c >= 0xf8 ? 0xf2 : 0xaa)) + (c2 - 0xa1);\n          return 2;\n        }\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 41,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp936_wctomb": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\ncp936_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  /* Try GBK first. */\n  {\n    int ret = ces_gbk_wctomb(conv,r,wc,n);\n    if (ret != RET_ILUNI)\n      return ret;\n  }\n  /* Then handle the additional mappings. */\n  if (wc >= 0xe000 && wc < 0xe586) {\n    /* User-defined characters */\n    if (n < 2)\n      return RET_TOOFEW(0);\n    if (wc < 0xe4c6) {\n      unsigned int i = wc - 0xe000;\n      unsigned int c1 = i / 94;\n      unsigned int c2 = i % 94;\n      r[0] = c1 + (c1 < 6 ? 0xaa : 0xf2);\n      r[1] = c2 + 0xa1;\n      return 2;\n    } else {\n      unsigned int i = wc - 0xe4c6;\n      unsigned int c1 = i / 96;\n      unsigned int c2 = i % 96;\n      r[0] = c1 + 0xa1;\n      r[1] = c2 + (c2 < 0x3f ? 0x40 : 0x41);\n      return 2;\n    }\n  } else if (wc == 0x20ac) {\n    r[0] = 0x80;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp936ext.h": {
    "cp936ext_mbtowc": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static int\ncp936ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0xa6) || (c1 == 0xa8)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xff)) {\n        unsigned int i = 190 * (c1 - 0x81) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n        unsigned short wc = 0xfffd;\n        if (i < 7410) {\n          if (i >= 7189 && i < 7211)\n            wc = cp936ext_2uni_pagea6[i-7189];\n        } else {\n          if (i >= 7532 && i < 7538)\n            wc = cp936ext_2uni_pagea8[i-7532];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp936ext_wctomb": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\ncp936ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    unsigned short c = 0;\n    if (wc >= 0x0140 && wc < 0x0150)\n      c = cp936ext_page01[wc-0x0140];\n    else if (wc >= 0x0250 && wc < 0x0268)\n      c = cp936ext_page02[wc-0x0250];\n    else if (wc >= 0xfe30 && wc < 0xfe48)\n      c = cp936ext_pagefe[wc-0xfe30];\n    if (c != 0) {\n      r[0] = (c >> 8); r[1] = (c & 0xff);\n      return 2;\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp943.h": {},
  "libiconv/libiconv-1.15/lib/cp949.h": {
    "cp949_mbtowc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\ncp949_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* UHC part 1 */\n  if (c >= 0x81 && c <= 0xa0)\n    return uhc_1_mbtowc(conv,pwc,s,n);\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 < 0xa1)\n        /* UHC part 2 */\n        return uhc_2_mbtowc(conv,pwc,s,n);\n      else if (c2 < 0xff && !(c == 0xa2 && c2 == 0xe8)) {\n        /* Code set 1 (KS C 5601-1992, now KS X 1001:1998) */\n        unsigned char buf[2];\n        int ret;\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        ret = ksc5601_mbtowc(conv,pwc,buf,2);\n        if (ret != RET_ILSEQ)\n          return ret;\n        /* User-defined characters */\n        if (c == 0xc9) {\n          *pwc = 0xe000 + (c2 - 0xa1);\n          return 2;\n        }\n        if (c == 0xfe) {\n          *pwc = 0xe05e + (c2 - 0xa1);\n          return 2;\n        }\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp949_wctomb": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\ncp949_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (KS C 5601-1992, now KS X 1001:1998) */\n  if (wc != 0x327e) {\n    ret = ksc5601_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[0]+0x80;\n      r[1] = buf[1]+0x80;\n      return 2;\n    }\n  }\n\n  /* UHC */\n  if (wc >= 0xac00 && wc < 0xd7a4) {\n    if (wc < 0xc8a5)\n      return uhc_1_wctomb(conv,r,wc,n);\n    else\n      return uhc_2_wctomb(conv,r,wc,n);\n  }\n\n  /* User-defined characters */\n  if (wc >= 0xe000 && wc < 0xe0bc) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    if (wc < 0xe05e) {\n      r[0] = 0xc9;\n      r[1] = wc - 0xe000 + 0xa1;\n    } else {\n      r[0] = 0xfe;\n      r[1] = wc - 0xe05e + 0xa1;\n    }\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp950.h": {
    "cp950_mbtowc": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static int\ncp950_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (BIG5 extended) */\n  if (c >= 0x81 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        if (c >= 0xa1) {\n          if (c < 0xa3) {\n            unsigned int i = 157 * (c - 0xa1) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n            unsigned short wc = cp950_2uni_pagea1[i];\n            if (wc != 0xfffd) {\n              *pwc = (ucs4_t) wc;\n              return 2;\n            }\n          }\n          if (!((c == 0xc6 && c2 >= 0xa1) || c == 0xc7)) {\n            int ret = big5_mbtowc(conv,pwc,s,2);\n            if (ret != RET_ILSEQ)\n              return ret;\n          }\n          if (c == 0xa3 && c2 == 0xe1) {\n            *pwc = 0x20ac;\n            return 2;\n          }\n          if (c >= 0xfa) {\n            /* User-defined characters */\n            *pwc = 0xe000 + 157 * (c - 0xfa) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n            return 2;\n          }\n        } else {\n          /* 0x81 <= c < 0xa1. */\n          /* User-defined characters */\n          *pwc = (c >= 0x8e ? 0xdb18 : 0xeeb8) + 157 * (c - 0x81)\n                 + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n          return 2;\n        }\n      }\n    }\n    if (c == 0xf9) {\n      int ret = cp950ext_mbtowc(conv,pwc,s,2);\n      if (ret != RET_ILSEQ)\n        return ret;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp950_wctomb": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static int\ncp950_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (BIG5 extended) */\n  switch (wc >> 8) {\n    case 0x00:\n      if (wc == 0x00af) { buf[0] = 0xa1; buf[1] = 0xc2; ret = 2; break; }\n      if (wc == 0x00a2 || wc == 0x00a3 || wc == 0x00a4)\n        return RET_ILUNI;\n      break;\n    case 0x02:\n      if (wc == 0x02cd) { buf[0] = 0xa1; buf[1] = 0xc5; ret = 2; break; }\n      break;\n    case 0x20:\n      if (wc == 0x2027) { buf[0] = 0xa1; buf[1] = 0x45; ret = 2; break; }\n      if (wc == 0x20ac) { buf[0] = 0xa3; buf[1] = 0xe1; ret = 2; break; }\n      if (wc == 0x2022 || wc == 0x203e)\n        return RET_ILUNI;\n      break;\n    case 0x22:\n      if (wc == 0x2215) { buf[0] = 0xa2; buf[1] = 0x41; ret = 2; break; }\n      if (wc == 0x2295) { buf[0] = 0xa1; buf[1] = 0xf2; ret = 2; break; }\n      if (wc == 0x2299) { buf[0] = 0xa1; buf[1] = 0xf3; ret = 2; break; }\n      if (wc == 0x223c)\n        return RET_ILUNI;\n      break;\n    case 0x25:\n      if (wc == 0x2574) { buf[0] = 0xa1; buf[1] = 0x5a; ret = 2; break; }\n      break;\n    case 0x26:\n      if (wc == 0x2609 || wc == 0x2641)\n        return RET_ILUNI;\n      break;\n    case 0xe0: case 0xe1: case 0xe2: case 0xe3: case 0xe4: case 0xe5:\n    case 0xe6: case 0xe7: case 0xe8: case 0xe9: case 0xea: case 0xeb:\n    case 0xec: case 0xed: case 0xee: case 0xef: case 0xf0: case 0xf1:\n    case 0xf2: case 0xf3: case 0xf4: case 0xf5: case 0xf6:\n      {\n        /* User-defined characters */\n        unsigned int i = wc - 0xe000;\n        if (i < 5809) {\n          unsigned int c1 = i / 157;\n          unsigned int c2 = i % 157;\n          buf[0] = c1 + (c1 < 5 ? 0xfa : c1 < 24 ? 0x89 : 0x69);\n          buf[1] = c2 + (c2 < 0x3f ? 0x40 : 0x62);\n          ret = 2;\n          break;\n        }\n      }\n      break;\n    case 0xfe:\n      if (wc == 0xfe51) { buf[0] = 0xa1; buf[1] = 0x4e; ret = 2; break; }\n      if (wc == 0xfe68) { buf[0] = 0xa2; buf[1] = 0x42; ret = 2; break; }\n      break;\n    case 0xff:\n      if (wc == 0xff0f) { buf[0] = 0xa1; buf[1] = 0xfe; ret = 2; break; }\n      if (wc == 0xff3c) { buf[0] = 0xa2; buf[1] = 0x40; ret = 2; break; }\n      if (wc == 0xff5e) { buf[0] = 0xa1; buf[1] = 0xe3; ret = 2; break; }\n      if (wc == 0xffe0) { buf[0] = 0xa2; buf[1] = 0x46; ret = 2; break; }\n      if (wc == 0xffe1) { buf[0] = 0xa2; buf[1] = 0x47; ret = 2; break; }\n      if (wc == 0xffe3) { buf[0] = 0xa1; buf[1] = 0xc3; ret = 2; break; }\n      if (wc == 0xffe5) { buf[0] = 0xa2; buf[1] = 0x44; ret = 2; break; }\n      if (wc == 0xff64)\n        return RET_ILUNI;\n      break;\n  }\n  if (ret == RET_ILUNI)\n    ret = big5_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (!((buf[0] == 0xc6 && buf[1] >= 0xa1) || buf[0] == 0xc7)) {\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[0];\n      r[1] = buf[1];\n      return 2;\n    }\n  }\n  ret = cp950ext_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 98,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/cp950ext.h": {
    "cp950ext_mbtowc": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static int\ncp950ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0xf9)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0xa1) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        unsigned short wc = 0xfffd;\n        {\n          if (i >= 13932 && i < 13973)\n            wc = cp950ext_2uni_pagef9[i-13932];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 25,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cp950ext_wctomb": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\ncp950ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x2500 && wc < 0x25a0)\n      summary = &cp950ext_uni2indx_page25[(wc>>4)-0x250];\n    else if (wc >= 0x5800 && wc < 0x58c0)\n      summary = &cp950ext_uni2indx_page58[(wc>>4)-0x580];\n    else if (wc >= 0x5a00 && wc < 0x5b00)\n      summary = &cp950ext_uni2indx_page5a[(wc>>4)-0x5a0];\n    else if (wc >= 0x6000 && wc < 0x6060)\n      summary = &cp950ext_uni2indx_page60[(wc>>4)-0x600];\n    else if (wc >= 0x7800 && wc < 0x7890)\n      summary = &cp950ext_uni2indx_page78[(wc>>4)-0x780];\n    else if (wc >= 0x7c00 && wc < 0x7cb0)\n      summary = &cp950ext_uni2indx_page7c[(wc>>4)-0x7c0];\n    else if (wc >= 0x8800 && wc < 0x88d0)\n      summary = &cp950ext_uni2indx_page88[(wc>>4)-0x880];\n    else if (wc >= 0x9200 && wc < 0x92c0)\n      summary = &cp950ext_uni2indx_page92[(wc>>4)-0x920];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = cp950ext_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 42,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/dec_hanyu.h": {
    "dec_hanyu_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\ndec_hanyu_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (CNS 11643-1992 Plane 1),\n     Code set 2 (CNS 11643-1992 Plane 2),\n     Code set 3 (CNS 11643-1992 Plane 3) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c == 0xc2 && c2 == 0xcb) {\n        if (n < 4)\n          return RET_TOOFEW(0);\n        if (s[2] >= 0xa1 && s[2] < 0xff && s[3] >= 0xa1 && s[3] < 0xff) {\n          unsigned char buf[2];\n          int ret;\n          buf[0] = s[2]-0x80; buf[1] = s[3]-0x80;\n          ret = cns11643_3_mbtowc(conv,pwc,buf,2);\n          if (ret != RET_ILSEQ) {\n            if (ret != 2) abort();\n            return 4;\n          }\n        }\n      } else if (c2 >= 0xa1 && c2 < 0xff) {\n        if (c != 0xc2 || c2 < 0xc2) {\n          unsigned char buf[2];\n          buf[0] = c-0x80; buf[1] = c2-0x80;\n          return cns11643_1_mbtowc(conv,pwc,buf,2);\n        }\n      } else if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2;\n        return cns11643_2_mbtowc(conv,pwc,buf,2);\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dec_hanyu_wctomb": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int\ndec_hanyu_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[3];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  ret = cns11643_wctomb(conv,buf,wc,3);\n  if (ret != RET_ILUNI) {\n    if (ret != 3) abort();\n\n    /* Code set 1 (CNS 11643-1992 Plane 1) */\n    if (buf[0] == 1 && (buf[1] != 0x42 || buf[2] < 0x42)) {\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[1]+0x80;\n      r[1] = buf[2]+0x80;\n      return 2;\n    }\n\n    /* Code set 2 (CNS 11643-1992 Plane 2) */\n    if (buf[0] == 2) {\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[1]+0x80;\n      r[1] = buf[2];\n      return 2;\n    }\n\n    /* Code set 3 (CNS 11643-1992 Plane 3) */\n    if (buf[0] == 3) {\n      if (n < 4)\n        return RET_TOOSMALL;\n      r[0] = 0xc2;\n      r[1] = 0xcb;\n      r[2] = buf[1]+0x80;\n      r[3] = buf[2]+0x80;\n      return 4;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/dec_kanji.h": {
    "dec_kanji_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\ndec_kanji_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII or JIS X 0201-1976 Roman) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (JIS X 0208) */\n  if (c >= 0xa1 && c < 0xf5) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        return jisx0208_mbtowc(conv,pwc,buf,2);\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dec_kanji_wctomb": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\ndec_kanji_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or JIS X 0201-1976 Roman) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (JIS X 0208) */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0]+0x80;\n    r[1] = buf[1]+0x80;\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/euc_cn.h": {
    "euc_cn_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int\neuc_cn_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII or GB 1988-89) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (GB 2312-1980) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        return gb2312_mbtowc(conv,pwc,buf,2);\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_cn_wctomb": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static int\neuc_cn_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or GB 1988-89) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (GB 2312-1980) */\n  ret = gb2312_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0]+0x80;\n    r[1] = buf[1]+0x80;\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/euc_jisx0213.h": {
    "euc_jisx0213_mbtowc": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\neuc_jisx0213_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    if (c < 0x80) {\n      /* Plain ASCII character. */\n      *pwc = (ucs4_t) c;\n      return 1;\n    } else {\n      if ((c >= 0xa1 && c <= 0xfe) || c == 0x8e || c == 0x8f) {\n        /* Two or three byte character. */\n        if (n >= 2) {\n          unsigned char c2 = s[1];\n          if (c2 >= 0xa1 && c2 <= 0xfe) {\n            if (c == 0x8e) {\n              /* Half-width katakana. */\n              if (c2 <= 0xdf) {\n                *pwc = c2 + 0xfec0;\n                return 2;\n              }\n            } else {\n              ucs4_t wc;\n              if (c == 0x8f) {\n                /* JISX 0213 plane 2. */\n                if (n >= 3) {\n                  unsigned char c3 = s[2];\n                  wc = jisx0213_to_ucs4(0x200-0x80+c2,c3^0x80);\n                } else\n                  return RET_TOOFEW(0);\n              } else {\n                /* JISX 0213 plane 1. */\n                wc = jisx0213_to_ucs4(0x100-0x80+c,c2^0x80);\n              }\n              if (wc) {\n                if (wc < 0x80) {\n                  /* It's a combining character. */\n                  ucs4_t wc1 = jisx0213_to_ucs_combining[wc - 1][0];\n                  ucs4_t wc2 = jisx0213_to_ucs_combining[wc - 1][1];\n                  /* We cannot output two Unicode characters at once. So,\n                     output the first character and buffer the second one. */\n                  *pwc = wc1;\n                  conv->istate = wc2;\n                } else\n                  *pwc = wc;\n                return (c == 0x8f ? 3 : 2);\n              }\n            }\n          }\n        } else\n          return RET_TOOFEW(0);\n      }\n      return RET_ILSEQ;\n    }\n  }\n}",
      "lines": 62,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_jisx0213_wctomb": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int\neuc_jisx0213_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned short lasttwo = conv->ostate;\n\n  if (lasttwo) {\n    /* Attempt to combine the last character with this one. */\n    unsigned int idx;\n    unsigned int len;\n\n    if (wc == 0x02e5)\n      idx = euc_jisx0213_comp_table02e5_idx,\n      len = euc_jisx0213_comp_table02e5_len;\n    else if (wc == 0x02e9)\n      idx = euc_jisx0213_comp_table02e9_idx,\n      len = euc_jisx0213_comp_table02e9_len;\n    else if (wc == 0x0300)\n      idx = euc_jisx0213_comp_table0300_idx,\n      len = euc_jisx0213_comp_table0300_len;\n    else if (wc == 0x0301)\n      idx = euc_jisx0213_comp_table0301_idx,\n      len = euc_jisx0213_comp_table0301_len;\n    else if (wc == 0x309a)\n      idx = euc_jisx0213_comp_table309a_idx,\n      len = euc_jisx0213_comp_table309a_len;\n    else\n      goto not_combining;\n\n    do\n      if (euc_jisx0213_comp_table_data[idx].base == lasttwo)\n        break;\n    while (++idx, --len > 0);\n\n    if (len > 0) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        lasttwo = euc_jisx0213_comp_table_data[idx].composed;\n        r[0] = (lasttwo >> 8) & 0xff;\n        r[1] = lasttwo & 0xff;\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n  not_combining:\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = (lasttwo >> 8) & 0xff;\n    r[1] = lasttwo & 0xff;\n    r += 2;\n    count = 2;\n  }\n\n  if (wc < 0x80) {\n    /* Plain ASCII character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else if (wc >= 0xff61 && wc <= 0xff9f) {\n    /* Half-width katakana. */\n    if (n >= count+2) {\n      r[0] = 0x8e;\n      r[1] = wc - 0xfec0;\n      conv->ostate = 0;\n      return count+2;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned short jch = ucs4_to_jisx0213(wc);\n    if (jch != 0) {\n      if (jch & 0x0080) {\n        /* A possible match in comp_table_data. We have to buffer it. */\n        /* We know it's a JISX 0213 plane 1 character. */\n        if (jch & 0x8000) abort();\n        conv->ostate = jch | 0x8080;\n        return count+0;\n      }\n      if (jch & 0x8000) {\n        /* JISX 0213 plane 2. */\n        if (n >= count+3) {\n          r[0] = 0x8f;\n          r[1] = (jch >> 8) | 0x80;\n          r[2] = (jch & 0xff) | 0x80;\n          conv->ostate = 0;\n          return count+3;\n        } else\n          return RET_TOOSMALL;\n      } else {\n        /* JISX 0213 plane 1. */\n        if (n >= count+2) {\n          r[0] = (jch >> 8) | 0x80;\n          r[1] = (jch & 0xff) | 0x80;\n          conv->ostate = 0;\n          return count+2;\n        } else\n          return RET_TOOSMALL;\n      }\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_jisx0213_reset": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\neuc_jisx0213_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t lasttwo = conv->ostate;\n\n  if (lasttwo) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = (lasttwo >> 8) & 0xff;\n    r[1] = lasttwo & 0xff;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/euc_jp.h": {
    "euc_jp_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\neuc_jp_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII or JIS X 0201-1976 Roman) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (JIS X 0208) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    if (c < 0xf5) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        return jisx0208_mbtowc(conv,pwc,buf,2);\n      } else\n        return RET_ILSEQ;\n    } else {\n      /* User-defined range. See\n       * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        *pwc = 0xe000 + 94*(c-0xf5) + (c2-0xa1);\n        return 2;\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  /* Code set 2 (half-width katakana) */\n  if (c == 0x8e) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xe0) {\n        int ret = jisx0201_mbtowc(conv,pwc,s+1,n-1);\n        if (ret == RET_ILSEQ)\n          return RET_ILSEQ;\n        if (ret != 1) abort();\n        return 2;\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  /* Code set 3 (JIS X 0212-1990) */\n  if (c == 0x8f) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        if (n < 3)\n          return RET_TOOFEW(0);\n        if (c2 < 0xf5) {\n          unsigned char c3 = s[2];\n          if (c3 >= 0xa1 && c3 < 0xff) {\n            unsigned char buf[2];\n            int ret;\n            buf[0] = c2-0x80; buf[1] = c3-0x80;\n            ret = jisx0212_mbtowc(conv,pwc,buf,2);\n            if (ret == RET_ILSEQ)\n              return RET_ILSEQ;\n            if (ret != 2) abort();\n            return 3;\n          } else\n            return RET_ILSEQ;\n        } else {\n          /* User-defined range. See\n           * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n          unsigned char c3 = s[2];\n          if (c3 >= 0xa1 && c3 < 0xff) {\n            *pwc = 0xe3ac + 94*(c2-0xf5) + (c3-0xa1);\n            return 3;\n          } else\n            return RET_ILSEQ;\n        }\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 84,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_jp_wctomb": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static int\neuc_jp_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or JIS X 0201-1976 Roman) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (JIS X 0208) */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0]+0x80;\n    r[1] = buf[1]+0x80;\n    return 2;\n  }\n\n  /* Code set 2 (half-width katakana) */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI && buf[0] >= 0x80) {\n    if (ret != 1) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0x8e;\n    r[1] = buf[0];\n    return 2;\n  }\n\n  /* Code set 3 (JIS X 0212-1990) */\n  ret = jisx0212_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 3)\n      return RET_TOOSMALL;\n    r[0] = 0x8f;\n    r[1] = buf[0]+0x80;\n    r[2] = buf[1]+0x80;\n    return 3;\n  }\n\n  /* Extra compatibility with Shift_JIS.  */\n  if (wc == 0x00a5) {\n    r[0] = 0x5c;\n    return 1;\n  }\n  if (wc == 0x203e) {\n    r[0] = 0x7e;\n    return 1;\n  }\n\n  /* User-defined range. See\n   * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n  if (wc >= 0xe000 && wc < 0xe758) {\n    if (wc < 0xe3ac) {\n      unsigned char c1, c2;\n      if (n < 2)\n        return RET_TOOSMALL;\n      c1 = (unsigned int) (wc - 0xe000) / 94;\n      c2 = (unsigned int) (wc - 0xe000) % 94;\n      r[0] = c1+0xf5;\n      r[1] = c2+0xa1;\n      return 2;\n    } else {\n      unsigned char c1, c2;\n      if (n < 3)\n        return RET_TOOSMALL;\n      c1 = (unsigned int) (wc - 0xe3ac) / 94;\n      c2 = (unsigned int) (wc - 0xe3ac) % 94;\n      r[0] = 0x8f;\n      r[1] = c1+0xf5;\n      r[2] = c2+0xa1;\n      return 3;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/euc_kr.h": {
    "euc_kr_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static int\neuc_kr_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII or KS C 5636-1993) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (KS C 5601-1992, now KS X 1001:2002) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        return ksc5601_mbtowc(conv,pwc,buf,2);\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_kr_wctomb": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\neuc_kr_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or KS C 5636-1993) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (KS C 5601-1992, now KS X 1001:2002) */\n  ret = ksc5601_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0]+0x80;\n    r[1] = buf[1]+0x80;\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/euc_tw.h": {
    "euc_tw_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\neuc_tw_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  /* Code set 0 (ASCII) */\n  if (c < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n  /* Code set 1 (CNS 11643-1992 Plane 1) */\n  if (c >= 0xa1 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        return cns11643_1_mbtowc(conv,pwc,buf,2);\n      } else\n        return RET_ILSEQ;\n    }\n  }\n  /* Code set 2 (CNS 11643-1992 Planes 1-16) */\n  if (c == 0x8e) {\n    if (n < 4)\n      return RET_TOOFEW(0);\n    {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 <= 0xb0) {\n        unsigned char c3 = s[2];\n        unsigned char c4 = s[3];\n        if (c3 >= 0xa1 && c3 < 0xff && c4 >= 0xa1 && c4 < 0xff) {\n          unsigned char buf[2];\n          int ret;\n          buf[0] = c3-0x80; buf[1] = c4-0x80;\n          switch (c2-0xa0) {\n            case 1: ret = cns11643_1_mbtowc(conv,pwc,buf,2); break;\n            case 2: ret = cns11643_2_mbtowc(conv,pwc,buf,2); break;\n            case 3: ret = cns11643_3_mbtowc(conv,pwc,buf,2); break;\n            case 4: ret = cns11643_4_mbtowc(conv,pwc,buf,2); break;\n            case 5: ret = cns11643_5_mbtowc(conv,pwc,buf,2); break;\n            case 6: ret = cns11643_6_mbtowc(conv,pwc,buf,2); break;\n            case 7: ret = cns11643_7_mbtowc(conv,pwc,buf,2); break;\n            case 15: ret = cns11643_15_mbtowc(conv,pwc,buf,2); break;\n            default: return RET_ILSEQ;\n          }\n          if (ret == RET_ILSEQ)\n            return RET_ILSEQ;\n          if (ret != 2) abort();\n          return 4;\n        }\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 55,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "euc_tw_wctomb": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\neuc_tw_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[3];\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  ret = cns11643_wctomb(conv,buf,wc,3);\n  if (ret != RET_ILUNI) {\n    if (ret != 3) abort();\n\n    /* Code set 1 (CNS 11643-1992 Plane 1) */\n    if (buf[0] == 1) {\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[1]+0x80;\n      r[1] = buf[2]+0x80;\n      return 2;\n    }\n\n    /* Code set 2 (CNS 11643-1992 Planes 1-16) */\n    if (n < 4)\n      return RET_TOOSMALL;\n    r[0] = 0x8e;\n    r[1] = buf[0]+0xa0;\n    r[2] = buf[1]+0x80;\n    r[3] = buf[2]+0x80;\n    return 4;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/flags.h": {},
  "libiconv/libiconv-1.15/lib/flushwc.h": {
    "normal_flushwc": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\nnormal_flushwc (conv_t conv, ucs4_t *pwc)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = (ucs4_t) last_wc;\n    return 1;\n  } else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb12345.h": {
    "gb12345_mbtowc": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static int\ngb12345_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  int ret;\n\n  /* The gb12345ext table overrides some entries in the gb2312 table. */\n  /* Try the GB12345 extensions -> Unicode table. */\n  ret = gb12345ext_mbtowc(conv,pwc,s,n);\n  if (ret != RET_ILSEQ)\n    return ret;\n  /* Try the GB2312 -> Unicode table. */\n  ret = gb2312_mbtowc(conv,pwc,s,n);\n  return ret;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb12345_wctomb": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\ngb12345_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int ret;\n\n  /* The gb12345ext table overrides some entries in the gb2312 table. */\n  /* Try the Unicode -> GB12345 extensions table. */\n  ret = gb12345ext_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n  /* Try the Unicode -> GB2312 table, and check that the resulting GB2312\n     byte sequence is not overridden by the GB12345 extensions table. */\n  ret = gb2312_wctomb(conv,r,wc,n);\n  if (ret == 2 && gb12345ext_mbtowc(conv,&wc,r,2) == 2)\n    return RET_ILUNI;\n  else\n    return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb12345ext.h": {
    "gb12345ext_mbtowc": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "static int\ngb12345ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x21) || (c1 == 0x26) || (c1 == 0x28) || (c1 >= 0x30 && c1 <= 0x79)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 470) {\n          if (i < 12)\n            wc = gb12345ext_2uni_page21[i];\n        } else if (i < 658) {\n          if (i < 555)\n            wc = gb12345ext_2uni_page26[i-470];\n        } else if (i < 1410) {\n          if (i < 690)\n            wc = gb12345ext_2uni_page28[i-658];\n        } else {\n          if (i < 8281)\n            wc = gb12345ext_2uni_page30[i-1410];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 34,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb12345ext_wctomb": {
      "start_point": [
        1759,
        0
      ],
      "end_point": [
        1794,
        1
      ],
      "content": "static int\ngb12345ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0100 && wc < 0x0270)\n      summary = &gb12345ext_uni2indx_page01[(wc>>4)-0x010];\n    else if (wc >= 0x1e00 && wc < 0x1e40)\n      summary = &gb12345ext_uni2indx_page1e[(wc>>4)-0x1e0];\n    else if (wc >= 0x2200 && wc < 0x2230)\n      summary = &gb12345ext_uni2indx_page22[(wc>>4)-0x220];\n    else if (wc >= 0x4e00 && wc < 0x9fa0)\n      summary = &gb12345ext_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xfe00 && wc < 0xfe50)\n      summary = &gb12345ext_uni2indx_pagefe[(wc>>4)-0xfe0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = gb12345ext_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 36,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb18030.h": {
    "gb18030_mbtowc": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\ngb18030_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  if (*s < 0x80)\n    return ascii_mbtowc(conv,pwc,s,n);\n\n  /* Code set 1 (GBK extended) */\n  ret = gbk_mbtowc(conv,pwc,s,n);\n  if (ret != RET_ILSEQ)\n    return ret;\n\n  ret = gb18030ext_mbtowc(conv,pwc,s,n);\n  if (ret != RET_ILSEQ)\n    return ret;\n\n  /* Code set 2 (remainder of Unicode U+0000..U+FFFF), including\n     User-defined characters, two-byte part of range U+E766..U+E864 */\n  ret = gb18030uni_mbtowc(conv,pwc,s,n);\n  if (ret != RET_ILSEQ)\n    return ret;\n  /* User-defined characters range U+E000..U+E765 */\n  {\n    unsigned char c1 = s[0];\n    if ((c1 >= 0xaa && c1 <= 0xaf) || (c1 >= 0xf8 && c1 <= 0xfe)) {\n      if (n >= 2) {\n        unsigned char c2 = s[1];\n        if (c2 >= 0xa1 && c2 <= 0xfe) {\n          *pwc = 0xe000 + 94 * (c1 >= 0xf8 ? c1 - 0xf2 : c1 - 0xaa) + (c2 - 0xa1);\n          return 2;\n        }\n      } else\n        return RET_TOOFEW(0);\n    } else if (c1 >= 0xa1 && c1 <= 0xa7) {\n      if (n >= 2) {\n        unsigned char c2 = s[1];\n        if (c2 >= 0x40 && c2 <= 0xa1 && c2 != 0x7f) {\n          *pwc = 0xe4c6 + 96 * (c1 - 0xa1) + c2 - (c2 >= 0x80 ? 0x41 : 0x40);\n          return 2;\n        }\n      } else\n        return RET_TOOFEW(0);\n    }\n  }\n\n  /* Code set 3 (Unicode U+10000..U+10FFFF) */\n  {\n    unsigned char c1 = s[0];\n    if (c1 >= 0x90 && c1 <= 0xe3) {\n      if (n >= 2) {\n        unsigned char c2 = s[1];\n        if (c2 >= 0x30 && c2 <= 0x39) {\n          if (n >= 3) {\n            unsigned char c3 = s[2];\n            if (c3 >= 0x81 && c3 <= 0xfe) {\n              if (n >= 4) {\n                unsigned char c4 = s[3];\n                if (c4 >= 0x30 && c4 <= 0x39) {\n                  unsigned int i = (((c1 - 0x90) * 10 + (c2 - 0x30)) * 126 + (c3 - 0x81)) * 10 + (c4 - 0x30);\n                  if (i >= 0 && i < 0x100000) {\n                    *pwc = (ucs4_t) (0x10000 + i);\n                    return 4;\n                  }\n                }\n                return RET_ILSEQ;\n              }\n              return RET_TOOFEW(0);\n            }\n            return RET_ILSEQ;\n          }\n          return RET_TOOFEW(0);\n        }\n        return RET_ILSEQ;\n      }\n      return RET_TOOFEW(0);\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 81,
      "depth": 30,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb18030_wctomb": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "static int\ngb18030_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int ret;\n\n  /* Code set 0 (ASCII) */\n  ret = ascii_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 1 (GBK extended) */\n  ret = gbk_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  ret = gb18030ext_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 2 (remainder of Unicode U+0000..U+FFFF) */\n  if (wc >= 0xe000 && wc <= 0xe864) {\n    if (n >= 2) {\n      if (wc < 0xe766) {\n        /* User-defined characters range U+E000..U+E765 */\n        if (wc < 0xe4c6) {\n          unsigned int i = wc - 0xe000;\n          r[1] = (i % 94) + 0xa1; i = i / 94;\n          r[0] = (i < 6 ? i + 0xaa : i + 0xf2);\n          return 2;\n        } else {\n          unsigned int i = wc - 0xe4c6;\n          r[0] = (i / 96) + 0xa1; i = i % 96;\n          r[1] = i + (i >= 0x3f ? 0x41 : 0x40);\n          return 2;\n        }\n      } else {\n        /* User-defined characters, two-byte part of range U+E766..U+E864 */\n        unsigned int k1 = 0;\n        unsigned int k2 = 31;\n        /* Invariant: We know that if wc occurs in Unicode interval in\n           gb18030_pua2charset, it does so at a k with  k1 <= k < k2. */\n        while (k1 < k2) {\n          unsigned int k = (k1 + k2) / 2;\n          if (wc < gb18030_pua2charset[k*3+0])\n            k2 = k;\n          else if (wc > gb18030_pua2charset[k*3+1])\n            k1 = k + 1;\n          else {\n            unsigned short c =\n              gb18030_pua2charset[k*3+2] + (wc - gb18030_pua2charset[k*3+0]);\n            r[0] = (c >> 8);\n            r[1] = (c & 0xff);\n            return 2;\n          }\n        }\n      }\n    } else\n      return RET_TOOSMALL;\n  }\n  ret = gb18030uni_wctomb(conv,r,wc,n);\n  if (ret != RET_ILUNI)\n    return ret;\n\n  /* Code set 3 (Unicode U+10000..U+10FFFF) */\n  if (n >= 4) {\n    if (wc >= 0x10000 && wc < 0x110000) {\n      unsigned int i = wc - 0x10000;\n      r[3] = (i % 10) + 0x30; i = i / 10;\n      r[2] = (i % 126) + 0x81; i = i / 126;\n      r[1] = (i % 10) + 0x30; i = i / 10;\n      r[0] = i + 0x90;\n      return 4;\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 77,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb18030ext.h": {
    "gb18030ext_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\ngb18030ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0xa2) || (c1 >= 0xa4 && c1 <= 0xa9) || (c1 == 0xd7) || (c1 == 0xfe)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xff)) {\n        unsigned int i = 190 * (c1 - 0x81) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n        unsigned int wc = 0xfffd;\n        switch (c1) {\n          case 0xa2:\n            if (i >= 6376 && i <= 6381) /* 0xA2AB..0xA2B0 */\n              wc = 0xe766 + (i - 6376);\n            else if (i == 6432) /* 0xA2E3 */\n              wc = 0x20ac;\n            else if (i == 6433) /* 0xA2E4 */\n              wc = 0xe76d;\n            else if (i >= 6444 && i <= 6445) /* 0xA2EF..0xA2F0 */\n              wc = 0xe76e + (i - 6444);\n            else if (i >= 6458 && i <= 6459) /* 0xA2FD..0xA2FE */\n              wc = 0xe770 + (i - 6458);\n            break;\n          case 0xa4:\n            if (i >= 6829 && i <= 6839) /* 0xA4F4..0xA4FE */\n              wc = 0xe772 + (i - 6829);\n            break;\n          case 0xa5:\n            if (i >= 7022 && i <= 7029) /* 0xA5F7..0xA5FE */\n              wc = 0xe77d + (i - 7022);\n            break;\n          case 0xa6:\n            if (i >= 7150 && i <= 7157) /* 0xA6B9..0xA6C0 */\n              wc = 0xe785 + (i - 7150);\n            else if (i >= 7183 && i <= 7184) /* 0xA6DA..0xA6DB */\n              wc = 0xfe12 - (i - 7183);\n            else if (i >= 7182 && i <= 7190) /* 0xA6D9..0xA6DF */\n              wc = 0xfe10 + (i - 7182);\n            else if (i >= 7201 && i <= 7202) /* 0xA6EC..0xA6ED */\n              wc = 0xfe17 + (i - 7201);\n            else if (i == 7208) /* 0xA6F3 */\n              wc = 0xfe19;\n            else if (i >= 7211 && i <= 7219) /* 0xA6F6..0xA6FE */\n              wc = 0xe797 + (i - 7211);\n            break;\n          case 0xa7:\n            if (i >= 7349 && i <= 7363) /* 0xA7C2..0xA7D0 */\n              wc = 0xe7a0 + (i - 7349);\n            else if (i >= 7397 && i <= 7409) /* 0xA7F2..0xA7FE */\n              wc = 0xe7af + (i - 7397);\n            break;\n          case 0xa8:\n            if (i >= 7495 && i <= 7505) /* 0xA896..0xA8A0 */\n              wc = 0xe7bc + (i - 7495);\n            else if (i == 7533) /* 0xA8BC */\n              wc = 0x1e3f;\n            else if (i == 7536) /* 0xA8BF */\n              wc = 0x01f9;\n            else if (i >= 7538 && i <= 7541) /* 0xA8C1..0xA8C4 */\n              wc = 0xe7c9 + (i - 7538);\n            else if (i >= 7579 && i <= 7599) /* 0xA8EA..0xA8FE */\n              wc = 0xe7cd + (i - 7579);\n            break;\n          case 0xa9:\n            if (i == 7624) /* 0xA958 */\n              wc = 0xe7e2;\n            else if (i == 7627) /* 0xA95B */\n              wc = 0xe7e3;\n            else if (i >= 7629 && i <= 7631) /* 0xA95D..0xA95F */\n              wc = 0xe7e4 + (i - 7629);\n            else if (i >= 7672 && i < 7685) /* 0xA989..0xA995 */\n              wc = gb18030ext_2uni_pagea9[i-7672];\n            else if (i >= 7686 && i <= 7698) /* 0xA997..0xA9A3 */\n              wc = 0xe7f4 + (i - 7686);\n            else if (i >= 7775 && i <= 7789) /* 0xA9F0..0xA9FE */\n              wc = 0xe801 + (i - 7775);\n            break;\n          case 0xd7:\n            if (i >= 16525 && i <= 16529) /* 0xD7FA..0xD7FE */\n              wc = 0xe810 + (i - 16525);\n            break;\n          case 0xfe:\n            if (i < 23846)\n              wc = gb18030ext_2uni_pagefe[i-23750];\n            break;\n          default:\n            break;\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 99,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb18030ext_wctomb": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static int\ngb18030ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    unsigned short c = 0;\n    if (wc == 0x01f9)\n      c = 0xa8bf;\n    else if (wc == 0x1e3f)\n      c = 0xa8bc;\n    else if (wc == 0x20ac)\n      c = 0xa2e3;\n    else if (wc >= 0x2e80 && wc < 0x2ed0)\n      c = gb18030ext_page2e[wc-0x2e80];\n    else if (wc >= 0x2ff0 && wc < 0x3000)\n      c = gb18030ext_page2f[wc-0x2ff0];\n    else if (wc == 0x303e)\n      c = 0xa989;\n    else if (wc >= 0x3440 && wc < 0x3478)\n      c = gb18030ext_page34[wc-0x3440];\n    else if (wc == 0x359e)\n      c = 0xfe5a;\n    else if (wc >= 0x3608 && wc < 0x3620)\n      c = gb18030ext_page36[wc-0x3608];\n    else if (wc == 0x3918)\n      c = 0xfe60;\n    else if (wc == 0x396e)\n      c = 0xfe5f;\n    else if (wc >= 0x39c8 && wc < 0x39e0)\n      c = gb18030ext_page39[wc-0x39c8];\n    else if (wc == 0x3a73)\n      c = 0xfe64;\n    else if (wc == 0x3b4e)\n      c = 0xfe68;\n    else if (wc == 0x3c6e)\n      c = 0xfe69;\n    else if (wc == 0x3ce0)\n      c = 0xfe6a;\n    else if (wc == 0x4056)\n      c = 0xfe6f;\n    else if (wc == 0x415f)\n      c = 0xfe70;\n    else if (wc == 0x4337)\n      c = 0xfe72;\n    else if (wc >= 0x43a8 && wc < 0x43e0)\n      c = gb18030ext_page43[wc-0x43a8];\n    else if (wc == 0x44d6)\n      c = 0xfe7b;\n    else if (wc >= 0x4648 && wc < 0x4668)\n      c = gb18030ext_page46[wc-0x4648];\n    else if (wc >= 0x4720 && wc < 0x4730)\n      c = gb18030ext_page47_1[wc-0x4720];\n    else if (wc >= 0x4778 && wc < 0x4790)\n      c = gb18030ext_page47_2[wc-0x4778];\n    else if (wc >= 0x4940 && wc < 0x49b8)\n      c = gb18030ext_page49[wc-0x4940];\n    else if (wc >= 0x4c70 && wc < 0x4ca8)\n      c = gb18030ext_page4c[wc-0x4c70];\n    else if (wc >= 0x4d10 && wc < 0x4d20)\n      c = gb18030ext_page4d[wc-0x4d10];\n    else if (wc == 0x4dae)\n      c = 0xfe9f;\n    else if (wc >= 0x9fb4 && wc < 0x9fbc)\n      c = gb18030ext_page9f[wc-0x9fb0];\n    else if (wc >= 0xfe10 && wc < 0xfe1a)\n      c = gb18030ext_pagefe[wc-0xfe10];\n    else if (wc == 0x20087)\n      c = 0xfe51;\n    else if (wc == 0x20089)\n      c = 0xfe52;\n    else if (wc == 0x200cc)\n      c = 0xfe53;\n    else if (wc == 0x215d7)\n      c = 0xfe6c;\n    else if (wc == 0x2298f)\n      c = 0xfe76;\n    else if (wc == 0x241fe)\n      c = 0xfe91;\n    if (c != 0) {\n      r[0] = (c >> 8); r[1] = (c & 0xff);\n      return 2;\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 85,
      "depth": 43,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb18030uni.h": {
    "gb18030uni_mbtowc": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\ngb18030uni_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if (c1 >= 0x81 && c1 <= 0x84) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x30 && c2 <= 0x39) {\n        if (n >= 3) {\n          unsigned char c3 = s[2];\n          if (c3 >= 0x81 && c3 <= 0xfe) {\n            if (n >= 4) {\n              unsigned char c4 = s[3];\n              if (c4 >= 0x30 && c4 <= 0x39) {\n                unsigned int i = (((c1 - 0x81) * 10 + (c2 - 0x30)) * 126 + (c3 - 0x81)) * 10 + (c4 - 0x30);\n                if (i >= 0 && i <= 39419) {\n                  if (i == 7457) {\n                    *pwc = 0xe7c7;\n                  } else {\n                    unsigned int k1 = 0;\n                    unsigned int k2 = 205;\n                    while (k1 < k2) {\n                      unsigned int k = (k1 + k2) / 2;\n                      if (i <= gb18030uni_charset2uni_ranges[2*k+1])\n                        k2 = k;\n                      else if (i >= gb18030uni_charset2uni_ranges[2*k+2])\n                        k1 = k + 1;\n                      else\n                        return RET_ILSEQ;\n                    }\n                    {\n                      unsigned int diff = gb18030uni_ranges[k1];\n                      *pwc = (ucs4_t) (i + diff);\n                    }\n                  }\n                  return 4;\n                }\n              }\n              return RET_ILSEQ;\n            }\n            return RET_TOOFEW(0);\n          }\n          return RET_ILSEQ;\n        }\n        return RET_TOOFEW(0);\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 52,
      "depth": 30,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb18030uni_wctomb": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static int\ngb18030uni_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 4) {\n    unsigned int i = wc;\n    if (i >= 0x0080 && i <= 0xffff) {\n      if (i == 0xe7c7) {\n        i = 7457;\n      } else {\n        unsigned int k1 = 0;\n        unsigned int k2 = 205;\n        while (k1 < k2) {\n          unsigned int k = (k1 + k2) / 2;\n          if (i <= gb18030uni_uni2charset_ranges[2*k+1])\n            k2 = k;\n          else if (i >= gb18030uni_uni2charset_ranges[2*k+2])\n            k1 = k + 1;\n          else\n            return RET_ILUNI;\n        }\n        {\n          unsigned int diff = gb18030uni_ranges[k1];\n          i -= diff;\n        }\n      }\n      r[3] = (i % 10) + 0x30; i = i / 10;\n      r[2] = (i % 126) + 0x81; i = i / 126;\n      r[1] = (i % 10) + 0x30; i = i / 10;\n      r[0] = i + 0x81;\n      return 4;\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 35,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gb2312.h": {
    "gb2312_mbtowc": {
      "start_point": [
        1079,
        0
      ],
      "end_point": [
        1106,
        1
      ],
      "content": "static int\ngb2312_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x29) || (c1 >= 0x30 && c1 <= 0x77)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 1410) {\n          if (i < 831)\n            wc = gb2312_2uni_page21[i];\n        } else {\n          if (i < 8178)\n            wc = gb2312_2uni_page30[i-1410];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gb2312_wctomb": {
      "start_point": [
        2532,
        0
      ],
      "end_point": [
        2569,
        1
      ],
      "content": "static int\ngb2312_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0460)\n      summary = &gb2312_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x2000 && wc < 0x2650)\n      summary = &gb2312_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x3000 && wc < 0x3230)\n      summary = &gb2312_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x4e00 && wc < 0x9cf0)\n      summary = &gb2312_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0x9e00 && wc < 0x9fb0)\n      summary = &gb2312_uni2indx_page9e[(wc>>4)-0x9e0];\n    else if (wc >= 0xff00 && wc < 0xfff0)\n      summary = &gb2312_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = gb2312_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 38,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gbk.h": {
    "gbk_mbtowc": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\ngbk_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n\n  if (c >= 0x81 && c < 0xff) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    if (c >= 0xa1 && c <= 0xf7) {\n      unsigned char c2 = s[1];\n      if (c == 0xa1) {\n        if (c2 == 0xa4) {\n          *pwc = 0x00b7;\n          return 2;\n        }\n        if (c2 == 0xaa) {\n          *pwc = 0x2014;\n          return 2;\n        }\n      }\n      if (c2 >= 0xa1 && c2 < 0xff) {\n        unsigned char buf[2];\n        int ret;\n        buf[0] = c-0x80; buf[1] = c2-0x80;\n        ret = gb2312_mbtowc(conv,pwc,buf,2);\n        if (ret != RET_ILSEQ)\n          return ret;\n        buf[0] = c; buf[1] = c2;\n        ret = cp936ext_mbtowc(conv,pwc,buf,2);\n        if (ret != RET_ILSEQ)\n          return ret;\n      }\n    }\n    if (c >= 0x81 && c <= 0xa0)\n      return gbkext1_mbtowc(conv,pwc,s,2);\n    if (c >= 0xa8 && c <= 0xfe)\n      return gbkext2_mbtowc(conv,pwc,s,2);\n    if (c == 0xa2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0xa1 && c2 <= 0xaa) {\n        *pwc = 0x2170+(c2-0xa1);\n        return 2;\n      }\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gbk_wctomb": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static int\ngbk_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  if (wc != 0x30fb && wc != 0x2015) {\n    ret = gb2312_wctomb(conv,buf,wc,2);\n    if (ret != RET_ILUNI) {\n      if (ret != 2) abort();\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = buf[0]+0x80;\n      r[1] = buf[1]+0x80;\n      return 2;\n    }\n  }\n  ret = gbkext_inv_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n  if (wc >= 0x2170 && wc <= 0x2179) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0xa2;\n    r[1] = 0xa1 + (wc-0x2170);\n    return 2;\n  }\n  ret = cp936ext_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n  if (wc == 0x00b7) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0xa1;\n    r[1] = 0xa4;\n    return 2;\n  }\n  if (wc == 0x2014) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = 0xa1;\n    r[1] = 0xaa;\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gbkext1.h": {
    "gbkext1_mbtowc": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        850,
        1
      ],
      "content": "static int\ngbkext1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x81 && c1 <= 0xa0)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xff)) {\n        unsigned int i = 190 * (c1 - 0x81) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n        unsigned short wc = 0xfffd;\n        {\n          if (i < 6080)\n            wc = gbkext1_2uni_page81[i];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 25,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gbkext2.h": {
    "gbkext2_mbtowc": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1171,
        1
      ],
      "content": "static int\ngbkext2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0xa8 && c1 <= 0xfe)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0x80 && c2 < 0xa1)) {\n        unsigned int i = 96 * (c1 - 0x81) + (c2 - (c2 >= 0x80 ? 0x41 : 0x40));\n        unsigned short wc = 0xfffd;\n        {\n          if (i < 12016)\n            wc = gbkext2_2uni_pagea8[i-3744];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 25,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gbkext_inv.h": {
    "gbkext_inv_wctomb": {
      "start_point": [
        2300,
        0
      ],
      "end_point": [
        2341,
        1
      ],
      "content": "static int\ngbkext_inv_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0200 && wc < 0x02e0)\n      summary = &gbkext_inv_uni2indx_page02[(wc>>4)-0x020];\n    else if (wc >= 0x2000 && wc < 0x22c0)\n      summary = &gbkext_inv_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x2500 && wc < 0x2610)\n      summary = &gbkext_inv_uni2indx_page25[(wc>>4)-0x250];\n    else if (wc >= 0x3000 && wc < 0x3100)\n      summary = &gbkext_inv_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x3200 && wc < 0x33e0)\n      summary = &gbkext_inv_uni2indx_page32[(wc>>4)-0x320];\n    else if (wc >= 0x4e00 && wc < 0x9fb0)\n      summary = &gbkext_inv_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xf900 && wc < 0xfa30)\n      summary = &gbkext_inv_uni2indx_pagef9[(wc>>4)-0xf90];\n    else if (wc >= 0xfe00 && wc < 0xfff0)\n      summary = &gbkext_inv_uni2indx_pagefe[(wc>>4)-0xfe0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = gbkext_inv_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 42,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/genaliases.c": {
    "emit_alias": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void emit_alias (FILE* out1, const char* alias, const char* c_name)\n{\n  /* Output alias in upper case. */\n  const char* s = alias;\n  for (; *s; s++) {\n    unsigned char c = * (unsigned char *) s;\n    if (c >= 0x80)\n      exit(1);\n    if (c >= 'a' && c <= 'z')\n      c -= 'a'-'A';\n    putc(c, out1);\n  }\n  fprintf(out1,\", ei_%s\\n\", c_name);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_encoding": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void emit_encoding (FILE* out1, FILE* out2, const char* const* names, size_t n, const char* c_name)\n{\n  fprintf(out2,\"grep 'sizeof(\\\"\");\n  /* Output *names in upper case. */\n  {\n    const char* s = *names;\n    for (; *s; s++) {\n      unsigned char c = * (unsigned char *) s;\n      if (c >= 0x80)\n        exit(1);\n      if (c >= 'a' && c <= 'z')\n        c -= 'a'-'A';\n      putc(c, out2);\n    }\n  }\n  fprintf(out2,\"\\\")' tmp.h | sed -e 's|^.*\\\\(stringpool_str[0-9]*\\\\).*$|  (int)(long)\\\\&((struct stringpool_t *)0)->\\\\1,|'\\n\");\n  for (; n > 0; names++, n--)\n    emit_alias(out1, *names, c_name);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  char* aliases_file_name;\n  char* canonical_sh_file_name;\n  char* canonical_local_sh_file_name;\n  FILE* aliases_file;\n  FILE* canonical_sh_file;\n\n  if (argc != 4) {\n    fprintf(stderr, \"Usage: genaliases aliases.gperf canonical.sh canonical_local.sh\\n\");\n    exit(1);\n  }\n\n  aliases_file_name = argv[1];\n  canonical_sh_file_name = argv[2];\n  canonical_local_sh_file_name = argv[3];\n\n  aliases_file = fopen(aliases_file_name, \"w\");\n  if (aliases_file == NULL) {\n    fprintf(stderr, \"Could not open '%s' for writing\\n\", aliases_file_name);\n    exit(1);\n  }\n\n  fprintf(aliases_file, \"struct alias { int name; unsigned int encoding_index; };\\n\");\n  fprintf(aliases_file, \"%%struct-type\\n\");\n  fprintf(aliases_file, \"%%language=ANSI-C\\n\");\n  fprintf(aliases_file, \"%%define hash-function-name aliases_hash\\n\");\n  fprintf(aliases_file, \"%%define lookup-function-name aliases_lookup\\n\");\n  fprintf(aliases_file, \"%%7bit\\n\");\n  fprintf(aliases_file, \"%%readonly-tables\\n\");\n  fprintf(aliases_file, \"%%global-table\\n\");\n  fprintf(aliases_file, \"%%define word-array-name aliases\\n\");\n  fprintf(aliases_file, \"%%pic\\n\");\n  fprintf(aliases_file, \"%%%%\\n\");\n\n#define DEFENCODING(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \\\n  {                                                           \\\n    static const char* const names[] = BRACIFY xxx_names;     \\\n    emit_encoding(aliases_file,canonical_sh_file,names,sizeof(names)/sizeof(names[0]),#xxx); \\\n  }\n#define BRACIFY(...) { __VA_ARGS__ }\n#define DEFALIAS(xxx_alias,xxx) emit_alias(aliases_file,xxx_alias,#xxx);\n\n  canonical_sh_file = fopen(canonical_sh_file_name, \"w\");\n  if (canonical_sh_file == NULL) {\n    fprintf(stderr, \"Could not open '%s' for writing\\n\", canonical_sh_file_name);\n    exit(1);\n  }\n#include \"encodings.def\"\n  if (ferror(canonical_sh_file) || fclose(canonical_sh_file))\n    exit(1);\n\n  canonical_sh_file = fopen(canonical_local_sh_file_name, \"w\");\n  if (canonical_sh_file == NULL) {\n    fprintf(stderr, \"Could not open '%s' for writing\\n\", canonical_local_sh_file_name);\n    exit(1);\n  }\n#include \"encodings_local.def\"\n  if (ferror(canonical_sh_file) || fclose(canonical_sh_file))\n    exit(1);\n\n#undef DEFALIAS\n#undef BRACIFY\n#undef DEFENCODING\n\n  if (ferror(aliases_file) || fclose(aliases_file))\n    exit(1);\n  exit(0);\n}",
      "lines": 69,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/genaliases2.c": {
    "emit_alias": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void emit_alias (FILE* out1, const char* tag, const char* alias, const char* c_name)\n{\n  fprintf(out1,\"  S(%s_%u, \\\"\",tag,counter);\n  /* Output alias in upper case. */\n  {\n    const char* s = alias;\n    for (; *s; s++) {\n      unsigned char c = * (unsigned char *) s;\n      if (c >= 0x80)\n        exit(1);\n      if (c >= 'a' && c <= 'z')\n        c -= 'a'-'A';\n      putc(c, out1);\n    }\n  }\n  fprintf(out1,\"\\\", ei_%s )\\n\", c_name);\n  counter++;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "emit_encoding": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void emit_encoding (FILE* out1, FILE* out2, const char* tag, const char* const* names, size_t n, const char* c_name)\n{\n  fprintf(out2,\"  (int)(long)&((struct stringpool2_t *)0)->stringpool_%s_%u,\\n\",tag,counter);\n  for (; n > 0; names++, n--)\n    emit_alias(out1, tag, *names, c_name);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  const char* tag;\n  char* aliases_file_name;\n  char* canonical_file_name;\n  FILE* aliases_file;\n  FILE* canonical_file;\n\n  if (argc != 4) {\n    fprintf(stderr, \"Usage: genaliases2 tag aliases.h canonical.h\\n\");\n    exit(1);\n  }\n\n  tag = argv[1];\n  aliases_file_name = argv[2];\n  canonical_file_name = argv[3];\n\n  aliases_file = fopen(aliases_file_name, \"w\");\n  if (aliases_file == NULL) {\n    fprintf(stderr, \"Could not open '%s' for writing\\n\", aliases_file_name);\n    exit(1);\n  }\n\n  canonical_file = fopen(canonical_file_name, \"w\");\n  if (canonical_file == NULL) {\n    fprintf(stderr, \"Could not open '%s' for writing\\n\", canonical_file_name);\n    exit(1);\n  }\n\n#define DEFENCODING(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \\\n  {                                                           \\\n    static const char* const names[] = BRACIFY xxx_names;     \\\n    emit_encoding(aliases_file,canonical_file,tag,names,sizeof(names)/sizeof(names[0]),#xxx); \\\n  }\n#define BRACIFY(...) { __VA_ARGS__ }\n#define DEFALIAS(xxx_alias,xxx) emit_alias(aliases_file,tag,xxx_alias,#xxx);\n#ifdef USE_AIX\n#include \"encodings_aix.def\"\n#endif\n#ifdef USE_OSF1\n#include \"encodings_osf1.def\"\n#endif\n#ifdef USE_DOS\n#include \"encodings_dos.def\"\n#endif\n#ifdef USE_EXTRA\n#include \"encodings_extra.def\"\n#endif\n#undef DEFALIAS\n#undef BRACIFY\n#undef DEFENCODING\n  if (ferror(aliases_file) || fclose(aliases_file))\n    exit(1);\n  if (ferror(canonical_file) || fclose(canonical_file))\n    exit(1);\n  exit(0);\n}",
      "lines": 57,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/genflags.c": {
    "emit_encoding": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void emit_encoding (struct wctomb_funcs * ofuncs, const char* c_name)\n{\n  /* Prepare a converter struct. */\n  struct conv_struct conv;\n  memset(&conv,'\\0',sizeof(conv));\n  conv.ofuncs = *ofuncs;\n\n  {\n    /* See whether the encoding can encode the accents and quotation marks. */\n    ucs4_t probe[6] = { 0x0060, 0x00b4, 0x2018, 0x2019, 0x3131, 0x3163, };\n    int res[6];\n    int i;\n    for (i = 0; i < 6; i++) {\n      unsigned char buf[10];\n      memset(&conv.ostate,'\\0',sizeof(state_t));\n      res[i] = (conv.ofuncs.xxx_wctomb(&conv,buf,probe[i],sizeof(buf)) != RET_ILUNI);\n    }\n    printf(\"#define ei_%s_oflags (\",c_name);\n    {\n      int first = 1;\n      if (res[0] && res[1]) {\n        printf(\"HAVE_ACCENTS\");\n        first = 0;\n      }\n      if (res[2] && res[3]) {\n        if (!first) printf(\" | \");\n        printf(\"HAVE_QUOTATION_MARKS\");\n        first = 0;\n      }\n      if (res[4] && res[5]) {\n        if (!first) printf(\" | \");\n        printf(\"HAVE_HANGUL_JAMO\");\n        first = 0;\n      }\n      if (first) printf(\"0\");\n    }\n    printf(\")\\n\");\n  }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int main ()\n{\n  int bitmask = 1;\n  printf(\"/* Generated automatically by genflags. */\\n\");\n  printf(\"\\n\");\n  printf(\"/* Set if the encoding can encode\\n\");\n  printf(\"   the acute and grave accents U+00B4 and U+0060. */\\n\");\n  printf(\"#define HAVE_ACCENTS %d\\n\",bitmask);\n  printf(\"\\n\");\n  bitmask = bitmask << 1;\n  printf(\"/* Set if the encoding can encode\\n\");\n  printf(\"   the single quotation marks U+2018 and U+2019. */\\n\");\n  printf(\"#define HAVE_QUOTATION_MARKS %d\\n\",bitmask);\n  printf(\"\\n\");\n  bitmask = bitmask << 1;\n  printf(\"/* Set if the encoding can encode\\n\");\n  printf(\"   the double-width Hangul letters (Jamo) U+3131 to U+3163. */\\n\");\n  printf(\"#define HAVE_HANGUL_JAMO %d\\n\",bitmask);\n  printf(\"\\n\");\n\n#define DEFENCODING(xxx_names,xxx,xxx_ifuncs1,xxx_ifuncs2,xxx_ofuncs1,xxx_ofuncs2) \\\n  {                                                       \\\n    struct wctomb_funcs ofuncs = xxx_ofuncs1,xxx_ofuncs2; \\\n    emit_encoding(&ofuncs,#xxx);                          \\\n  }\n#define DEFALIAS(xxx_alias,xxx) /* nothing */\n/* Consider all encodings, including the system dependent ones. */\n#include \"encodings.def\"\n#include \"encodings_aix.def\"\n#include \"encodings_osf1.def\"\n#include \"encodings_dos.def\"\n#include \"encodings_extra.def\"\n#undef DEFALIAS\n#undef DEFENCODING\n\n  if (ferror(stdout) || fclose(stdout))\n    exit(1);\n  exit(0);\n}",
      "lines": 39,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/gentranslit.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int main (int argc, char *argv[])\n{\n  unsigned int *data;\n  int *uni2index;\n  int index;\n\n  if (argc != 1)\n    exit(1);\n\n  data = malloc(0x100000 * sizeof(*data));\n  uni2index = malloc(0x110000 * sizeof(*uni2index));\n  if (data == NULL || uni2index == NULL) {\n    fprintf(stderr, \"out of memory\\n\");\n    exit(1);\n  }\n\n  printf(\"/*\\n\");\n  printf(\" * Copyright (C) 1999-2003 Free Software Foundation, Inc.\\n\");\n  printf(\" * This file is part of the GNU LIBICONV Library.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is free software; you can redistribute it\\n\");\n  printf(\" * and/or modify it under the terms of the GNU Library General Public\\n\");\n  printf(\" * License as published by the Free Software Foundation; either version 2\\n\");\n  printf(\" * of the License, or (at your option) any later version.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is distributed in the hope that it will be\\n\");\n  printf(\" * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n  printf(\" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\");\n  printf(\" * Library General Public License for more details.\\n\");\n  printf(\" *\\n\");\n  printf(\" * You should have received a copy of the GNU Library General Public\\n\");\n  printf(\" * License along with the GNU LIBICONV Library; see the file COPYING.LIB.\\n\");\n  printf(\" * If not, see <http://www.gnu.org/licenses/>.\\n\");\n  printf(\" */\\n\");\n  printf(\"\\n\");\n  printf(\"/*\\n\");\n  printf(\" * Transliteration table\\n\");\n  printf(\" */\\n\");\n  printf(\"\\n\");\n  {\n    int c;\n    int j;\n    for (j = 0; j < 0x110000; j++)\n      uni2index[j] = -1;\n    index = 0;\n    for (;;) {\n      c = getc(stdin);\n      if (c == EOF)\n        break;\n      if (c == '#') {\n        do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n        continue;\n      }\n      ungetc(c,stdin);\n      if (scanf(\"%x\",&j) != 1)\n        exit(1);\n      c = getc(stdin);\n      if (c != '\\t')\n        exit(1);\n      for (;;) {\n        c = getc(stdin);\n        if (c == EOF || c == '\\n')\n          exit(1);\n        if (c == '\\t')\n          break;\n        if (uni2index[j] < 0) {\n          uni2index[j] = index;\n          data[index++] = 0;\n        }\n        if (c >= 0x80) {\n          /* Finish reading an UTF-8 character. */\n          if (c < 0xc0)\n            exit(1);\n          else {\n            unsigned int i = (c < 0xe0 ? 2 : c < 0xf0 ? 3 : c < 0xf8 ? 4 : c < 0xfc ? 5 : 6);\n            c &= (1 << (8-i)) - 1;\n            while (--i > 0) {\n              int cc = getc(stdin);\n              if (!(cc >= 0x80 && cc < 0xc0))\n                exit(1);\n              c <<= 6; c |= (cc & 0x3f);\n            }\n          }\n        }\n        data[index++] = (unsigned int) c;\n      }\n      if (uni2index[j] >= 0)\n        data[uni2index[j]] = index - uni2index[j] - 1;\n      do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n    }\n  }\n  printf(\"static const unsigned int translit_data[%d] = {\",index);\n  {\n    int i;\n    for (i = 0; i < index; i++) {\n      if (data[i] < 32)\n        printf(\"\\n %3d,\",data[i]);\n      else if (data[i] == '\\'')\n        printf(\"'\\\\'',\");\n      else if (data[i] == '\\\\')\n        printf(\"'\\\\\\\\',\");\n      else if (data[i] < 127)\n        printf(\" '%c',\",data[i]);\n      else if (data[i] < 256)\n        printf(\"0x%02X,\",data[i]);\n      else\n        printf(\"0x%04X,\",data[i]);\n    }\n    printf(\"\\n};\\n\");\n  }\n  printf(\"\\n\");\n  {\n    int line[0x22000];\n    int tableno;\n    struct { int minline; int maxline; int usecount; const char* suffix; } tables[0x2000];\n    int i, j, p, j1, j2, t;\n\n    for (j1 = 0; j1 < 0x22000; j1++) {\n      bool all_invalid = true;\n      for (j2 = 0; j2 < 8; j2++) {\n        j = 8*j1+j2;\n        if (uni2index[j] >= 0)\n          all_invalid = false;\n      }\n      if (all_invalid)\n        line[j1] = -1;\n      else\n        line[j1] = 0;\n    }\n    tableno = 0;\n    for (j1 = 0; j1 < 0x22000; j1++) {\n      if (line[j1] >= 0) {\n        if (tableno > 0\n            && ((j1 > 0 && line[j1-1] == tableno-1)\n                || ((tables[tableno-1].maxline >> 5) == (j1 >> 5)\n                    && j1 - tables[tableno-1].maxline <= 8))) {\n          line[j1] = tableno-1;\n          tables[tableno-1].maxline = j1;\n        } else {\n          tableno++;\n          line[j1] = tableno-1;\n          tables[tableno-1].minline = tables[tableno-1].maxline = j1;\n        }\n      }\n    }\n    for (t = 0; t < tableno; t++) {\n      tables[t].usecount = 0;\n      j1 = 8*tables[t].minline;\n      j2 = 8*(tables[t].maxline+1);\n      for (j = j1; j < j2; j++)\n        if (uni2index[j] >= 0)\n          tables[t].usecount++;\n    }\n    for (t = 0, p = -1, i = 0; t < tableno; t++) {\n      if (tables[t].usecount > 1) {\n        char* s;\n        if (p == tables[t].minline >> 5) {\n          s = (char*) malloc(4+1+2+1);\n          sprintf(s, \"%02x_%d\", p, ++i);\n        } else {\n          p = tables[t].minline >> 5;\n          s = (char*) malloc(4+1);\n          sprintf(s, \"%02x\", p);\n        }\n        tables[t].suffix = s;\n      } else\n        tables[t].suffix = NULL;\n    }\n    {\n      p = -1;\n      for (t = 0; t < tableno; t++)\n        if (tables[t].usecount > 1) {\n          p = 0;\n          printf(\"static const short translit_page%s[%d] = {\\n\", tables[t].suffix, 8*(tables[t].maxline-tables[t].minline+1));\n          for (j1 = tables[t].minline; j1 <= tables[t].maxline; j1++) {\n            if ((j1 % 0x20) == 0 && j1 > tables[t].minline)\n              printf(\"  /* 0x%04x */\\n\", 8*j1);\n            printf(\" \");\n            for (j2 = 0; j2 < 8; j2++) {\n              j = 8*j1+j2;\n              printf(\" %4d,\", uni2index[j]);\n            }\n            printf(\" /* 0x%02x-0x%02x */\\n\", 8*(j1 % 0x20), 8*(j1 % 0x20)+7);\n          }\n          printf(\"};\\n\");\n        }\n      if (p >= 0)\n        printf(\"\\n\");\n    }\n    printf(\"#define translit_index(wc) \\\\\\n  (\");\n    for (j1 = 0; j1 < 0x22000;) {\n      t = line[j1];\n      for (j2 = j1; j2 < 0x22000 && line[j2] == t; j2++);\n      if (t >= 0) {\n        if (j1 != tables[t].minline) abort();\n        if (j2 > tables[t].maxline+1) abort();\n        j2 = tables[t].maxline+1;\n      }\n      if (t == -1) {\n      } else {\n        if (t >= 0 && tables[t].usecount == 0) abort();\n        if (t >= 0 && tables[t].usecount == 1) {\n          if (j2 != j1+1) abort();\n          for (j = 8*j1; j < 8*j2; j++)\n            if (uni2index[j] >= 0) {\n              printf(\"wc == 0x%04x ? %d\", j, uni2index[j]);\n              break;\n            }\n        } else {\n          if (j1 == 0) {\n            printf(\"wc < 0x%04x\", 8*j2);\n          } else {\n            printf(\"wc >= 0x%04x && wc < 0x%04x\", 8*j1, 8*j2);\n          }\n          printf(\" ? translit_page%s[wc\", tables[t].suffix);\n          if (tables[t].minline > 0)\n            printf(\"-0x%04x\", 8*j1);\n          printf(\"]\");\n        }\n        printf(\" : \\\\\\n   \");\n      }\n      j1 = j2;\n    }\n    printf(\"-1)\\n\");\n  }\n\n  if (ferror(stdout) || fclose(stdout))\n    exit(1);\n  exit(0);\n}",
      "lines": 230,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/georgian_academy.h": {
    "georgian_academy_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static int\ngeorgian_academy_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0x80 && c < 0xa0)\n    *pwc = (ucs4_t) georgian_academy_2uni[c-0x80];\n  else if (c >= 0xc0 && c < 0xe7)\n    *pwc = (ucs4_t) c + 0x1010;\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "georgian_academy_wctomb": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\ngeorgian_academy_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0080 && wc < 0x00a0)\n    c = georgian_academy_page00[wc-0x0080];\n  else if ((wc >= 0x00a0 && wc < 0x00c0) || (wc >= 0x00e7 && wc < 0x0100))\n    c = wc;\n  else if (wc >= 0x0150 && wc < 0x0198)\n    c = georgian_academy_page01[wc-0x0150];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = georgian_academy_page02[wc-0x02c0];\n  else if (wc >= 0x10d0 && wc < 0x10f7)\n    c = wc-0x1010;\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = georgian_academy_page20[wc-0x2010];\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/georgian_ps.h": {
    "georgian_ps_mbtowc": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\ngeorgian_ps_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0x80 && c < 0xa0)\n    *pwc = (ucs4_t) georgian_ps_2uni_1[c-0x80];\n  else if (c >= 0xc0 && c < 0xe6)\n    *pwc = (ucs4_t) georgian_ps_2uni_2[c-0xc0];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "georgian_ps_wctomb": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\ngeorgian_ps_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0080 && wc < 0x00a0)\n    c = georgian_ps_page00[wc-0x0080];\n  else if ((wc >= 0x00a0 && wc < 0x00c0) || (wc >= 0x00e6 && wc < 0x0100))\n    c = wc;\n  else if (wc >= 0x0150 && wc < 0x0198)\n    c = georgian_ps_page01[wc-0x0150];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = georgian_ps_page02[wc-0x02c0];\n  else if (wc >= 0x10d0 && wc < 0x10f8)\n    c = georgian_ps_page10[wc-0x10d0];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = georgian_ps_page20[wc-0x2010];\n  else if (wc == 0x2122)\n    c = 0x99;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hkscs1999.h": {
    "hkscs1999_mbtowc": {
      "start_point": [
        850,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "static int\nhkscs1999_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x88 && c1 <= 0x8b) || (c1 >= 0x8d && c1 <= 0xa0) || (c1 >= 0xc6 && c1 <= 0xc8) || (c1 >= 0xf9 && c1 <= 0xfe)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0x80) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        if (i < 2041) {\n          if (i < 1883)\n            swc = hkscs1999_2uni_page88[i-1256],\n            wc = hkscs1999_2uni_upages[swc>>6] | (swc & 0x3f);\n        } else if (i < 10990) {\n          if (i < 5181)\n            swc = hkscs1999_2uni_page8d[i-2041],\n            wc = hkscs1999_2uni_upages[swc>>6] | (swc & 0x3f);\n        } else if (i < 18997) {\n          if (i < 11461)\n            swc = hkscs1999_2uni_pagec6[i-10990],\n            wc = hkscs1999_2uni_upages[swc>>6] | (swc & 0x3f);\n        } else {\n          if (i < 19939)\n            swc = hkscs1999_2uni_pagef9[i-18997],\n            wc = hkscs1999_2uni_upages[swc>>6] | (swc & 0x3f);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 39,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hkscs1999_wctomb": {
      "start_point": [
        2950,
        0
      ],
      "end_point": [
        3003,
        1
      ],
      "content": "static int\nhkscs1999_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x02d0)\n      summary = &hkscs1999_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x0400 && wc < 0x0460)\n      summary = &hkscs1999_uni2indx_page04[(wc>>4)-0x040];\n    else if (wc >= 0x1e00 && wc < 0x1ed0)\n      summary = &hkscs1999_uni2indx_page1e[(wc>>4)-0x1e0];\n    else if (wc >= 0x2100 && wc < 0x21f0)\n      summary = &hkscs1999_uni2indx_page21[(wc>>4)-0x210];\n    else if (wc >= 0x2300 && wc < 0x2580)\n      summary = &hkscs1999_uni2indx_page23[(wc>>4)-0x230];\n    else if (wc >= 0x2700 && wc < 0x2740)\n      summary = &hkscs1999_uni2indx_page27[(wc>>4)-0x270];\n    else if (wc >= 0x2e00 && wc < 0x3240)\n      summary = &hkscs1999_uni2indx_page2e[(wc>>4)-0x2e0];\n    else if (wc >= 0x3400 && wc < 0x9fc0)\n      summary = &hkscs1999_uni2indx_page34[(wc>>4)-0x340];\n    else if (wc >= 0xf900 && wc < 0xf910)\n      summary = &hkscs1999_uni2indx_pagef9[(wc>>4)-0xf90];\n    else if (wc >= 0xff00 && wc < 0xfff0)\n      summary = &hkscs1999_uni2indx_pageff[(wc>>4)-0xff0];\n    else if (wc >= 0x20000 && wc < 0x291f0)\n      summary = &hkscs1999_uni2indx_page200[(wc>>4)-0x2000];\n    else if (wc >= 0x29400 && wc < 0x29600)\n      summary = &hkscs1999_uni2indx_page294[(wc>>4)-0x2940];\n    else if (wc >= 0x29700 && wc < 0x2a6b0)\n      summary = &hkscs1999_uni2indx_page297[(wc>>4)-0x2970];\n    else if (wc >= 0x2f800 && wc < 0x2f9e0)\n      summary = &hkscs1999_uni2indx_page2f8[(wc>>4)-0x2f80];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = hkscs1999_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 54,
      "depth": 26,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hkscs2001.h": {
    "hkscs2001_mbtowc": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\nhkscs2001_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x8c)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0x80) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 2007)\n            swc = hkscs2001_2uni_page8c[i-1884],\n            wc = hkscs2001_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hkscs2001_wctomb": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "static int\nhkscs2001_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc < 0x9f00) {\n      if (wc < 0x6900) {\n        if (wc >= 0x3500 && wc < 0x3560)\n          summary = &hkscs2001_uni2indx_page35[(wc>>4)-0x350];\n        else if (wc >= 0x3c00 && wc < 0x3ee0)\n          summary = &hkscs2001_uni2indx_page3c[(wc>>4)-0x3c0];\n        else if (wc >= 0x4000 && wc < 0x4080)\n          summary = &hkscs2001_uni2indx_page40[(wc>>4)-0x400];\n        else if (wc >= 0x4200 && wc < 0x42b0)\n          summary = &hkscs2001_uni2indx_page42[(wc>>4)-0x420];\n        else if (wc >= 0x4b00 && wc < 0x4c90)\n          summary = &hkscs2001_uni2indx_page4b[(wc>>4)-0x4b0];\n        else if (wc >= 0x4e00 && wc < 0x51b0)\n          summary = &hkscs2001_uni2indx_page4e[(wc>>4)-0x4e0];\n        else if (wc >= 0x5300 && wc < 0x5440)\n          summary = &hkscs2001_uni2indx_page53[(wc>>4)-0x530];\n        else if (wc >= 0x5700 && wc < 0x58e0)\n          summary = &hkscs2001_uni2indx_page57[(wc>>4)-0x570];\n        else if (wc >= 0x5a00 && wc < 0x5fd0)\n          summary = &hkscs2001_uni2indx_page5a[(wc>>4)-0x5a0];\n        else if (wc >= 0x6100 && wc < 0x6130)\n          summary = &hkscs2001_uni2indx_page61[(wc>>4)-0x610];\n        else if (wc >= 0x6500 && wc < 0x6590)\n          summary = &hkscs2001_uni2indx_page65[(wc>>4)-0x650];\n        else if (wc >= 0x6700 && wc < 0x6770)\n          summary = &hkscs2001_uni2indx_page67[(wc>>4)-0x670];\n      } else {\n        if (wc >= 0x6900 && wc < 0x6a70)\n          summary = &hkscs2001_uni2indx_page69[(wc>>4)-0x690];\n        else if (wc >= 0x6c00 && wc < 0x6e00)\n          summary = &hkscs2001_uni2indx_page6c[(wc>>4)-0x6c0];\n        else if (wc >= 0x7000 && wc < 0x74c0)\n          summary = &hkscs2001_uni2indx_page70[(wc>>4)-0x700];\n        else if (wc >= 0x7600 && wc < 0x78f0)\n          summary = &hkscs2001_uni2indx_page76[(wc>>4)-0x760];\n        else if (wc >= 0x7a00 && wc < 0x7e70)\n          summary = &hkscs2001_uni2indx_page7a[(wc>>4)-0x7a0];\n        else if (wc >= 0x8200 && wc < 0x8300)\n          summary = &hkscs2001_uni2indx_page82[(wc>>4)-0x820];\n        else if (wc >= 0x8500 && wc < 0x8610)\n          summary = &hkscs2001_uni2indx_page85[(wc>>4)-0x850];\n        else if (wc >= 0x8800 && wc < 0x88a0)\n          summary = &hkscs2001_uni2indx_page88[(wc>>4)-0x880];\n        else if (wc >= 0x8b00 && wc < 0x8b90)\n          summary = &hkscs2001_uni2indx_page8b[(wc>>4)-0x8b0];\n        else if (wc >= 0x8e00 && wc < 0x8fd0)\n          summary = &hkscs2001_uni2indx_page8e[(wc>>4)-0x8e0];\n        else if (wc >= 0x9100 && wc < 0x9400)\n          summary = &hkscs2001_uni2indx_page91[(wc>>4)-0x910];\n        else if (wc >= 0x9700 && wc < 0x99f0)\n          summary = &hkscs2001_uni2indx_page97[(wc>>4)-0x970];\n      }\n    } else {\n      if (wc < 0x25600) {\n        if (wc >= 0x9f00 && wc < 0x9fb0)\n          summary = &hkscs2001_uni2indx_page9f[(wc>>4)-0x9f0];\n        else if (wc >= 0x21400 && wc < 0x21440)\n          summary = &hkscs2001_uni2indx_page214[(wc>>4)-0x2140];\n        else if (wc >= 0x21900 && wc < 0x21990)\n          summary = &hkscs2001_uni2indx_page219[(wc>>4)-0x2190];\n        else if (wc >= 0x21d00 && wc < 0x21dc0)\n          summary = &hkscs2001_uni2indx_page21d[(wc>>4)-0x21d0];\n        else if (wc >= 0x22000 && wc < 0x22080)\n          summary = &hkscs2001_uni2indx_page220[(wc>>4)-0x2200];\n        else if (wc >= 0x22700 && wc < 0x22720)\n          summary = &hkscs2001_uni2indx_page227[(wc>>4)-0x2270];\n        else if (wc >= 0x23200 && wc < 0x23400)\n          summary = &hkscs2001_uni2indx_page232[(wc>>4)-0x2320];\n        else if (wc >= 0x23c00 && wc < 0x23c70)\n          summary = &hkscs2001_uni2indx_page23c[(wc>>4)-0x23c0];\n        else if (wc >= 0x24100 && wc < 0x24150)\n          summary = &hkscs2001_uni2indx_page241[(wc>>4)-0x2410];\n        else if (wc >= 0x24500 && wc < 0x24510)\n          summary = &hkscs2001_uni2indx_page245[(wc>>4)-0x2450];\n        else if (wc >= 0x24900 && wc < 0x24a20)\n          summary = &hkscs2001_uni2indx_page249[(wc>>4)-0x2490];\n        else if (wc >= 0x25100 && wc < 0x251d0)\n          summary = &hkscs2001_uni2indx_page251[(wc>>4)-0x2510];\n      } else {\n        if (wc >= 0x25600 && wc < 0x256a0)\n          summary = &hkscs2001_uni2indx_page256[(wc>>4)-0x2560];\n        else if (wc >= 0x25c00 && wc < 0x25d40)\n          summary = &hkscs2001_uni2indx_page25c[(wc>>4)-0x25c0];\n        else if (wc >= 0x26b00 && wc < 0x26b20)\n          summary = &hkscs2001_uni2indx_page26b[(wc>>4)-0x26b0];\n        else if (wc >= 0x26d00 && wc < 0x26d80)\n          summary = &hkscs2001_uni2indx_page26d[(wc>>4)-0x26d0];\n        else if (wc >= 0x26f00 && wc < 0x26fc0)\n          summary = &hkscs2001_uni2indx_page26f[(wc>>4)-0x26f0];\n        else if (wc >= 0x27100 && wc < 0x27110)\n          summary = &hkscs2001_uni2indx_page271[(wc>>4)-0x2710];\n        else if (wc >= 0x28700 && wc < 0x28710)\n          summary = &hkscs2001_uni2indx_page287[(wc>>4)-0x2870];\n        else if (wc >= 0x28900 && wc < 0x28af0)\n          summary = &hkscs2001_uni2indx_page289[(wc>>4)-0x2890];\n        else if (wc >= 0x28d00 && wc < 0x28dc0)\n          summary = &hkscs2001_uni2indx_page28d[(wc>>4)-0x28d0];\n        else if (wc >= 0x29900 && wc < 0x29950)\n          summary = &hkscs2001_uni2indx_page299[(wc>>4)-0x2990];\n        else if (wc >= 0x29c00 && wc < 0x29c80)\n          summary = &hkscs2001_uni2indx_page29c[(wc>>4)-0x29c0];\n        else if (wc >= 0x2a100 && wc < 0x2a2c0)\n          summary = &hkscs2001_uni2indx_page2a1[(wc>>4)-0x2a10];\n      }\n    }\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = hkscs2001_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 131,
      "depth": 28,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hkscs2004.h": {
    "hkscs2004_mbtowc": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int\nhkscs2004_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x87) || (c1 >= 0x8c && c1 <= 0x8d)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0x80) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        if (i < 1884) {\n          if (i < 1157)\n            swc = hkscs2004_2uni_page87[i-1099],\n            wc = hkscs2004_2uni_upages[swc>>8] | (swc & 0xff);\n        } else {\n          if (i < 2073)\n            swc = hkscs2004_2uni_page8c[i-1884],\n            wc = hkscs2004_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 31,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hkscs2004_wctomb": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static int\nhkscs2004_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc < 0x21a00) {\n      if (wc < 0x6e00) {\n        if (wc >= 0x3400 && wc < 0x3450)\n          summary = &hkscs2004_uni2indx_page34[(wc>>4)-0x340];\n        else if (wc >= 0x3600 && wc < 0x3980)\n          summary = &hkscs2004_uni2indx_page36[(wc>>4)-0x360];\n        else if (wc >= 0x3b00 && wc < 0x3ba0)\n          summary = &hkscs2004_uni2indx_page3b[(wc>>4)-0x3b0];\n        else if (wc >= 0x3d00 && wc < 0x3e00)\n          summary = &hkscs2004_uni2indx_page3d[(wc>>4)-0x3d0];\n        else if (wc >= 0x3f00 && wc < 0x41f0)\n          summary = &hkscs2004_uni2indx_page3f[(wc>>4)-0x3f0];\n        else if (wc >= 0x4300 && wc < 0x4750)\n          summary = &hkscs2004_uni2indx_page43[(wc>>4)-0x430];\n        else if (wc >= 0x4a00 && wc < 0x4ab0)\n          summary = &hkscs2004_uni2indx_page4a[(wc>>4)-0x4a0];\n        else if (wc >= 0x4c00 && wc < 0x4d90)\n          summary = &hkscs2004_uni2indx_page4c[(wc>>4)-0x4c0];\n        else if (wc >= 0x4f00 && wc < 0x4fc0)\n          summary = &hkscs2004_uni2indx_page4f[(wc>>4)-0x4f0];\n        else if (wc >= 0x5600 && wc < 0x5700)\n          summary = &hkscs2004_uni2indx_page56[(wc>>4)-0x560];\n        else if (wc >= 0x5900 && wc < 0x5d80)\n          summary = &hkscs2004_uni2indx_page59[(wc>>4)-0x590];\n        else if (wc >= 0x5f00 && wc < 0x5f40)\n          summary = &hkscs2004_uni2indx_page5f[(wc>>4)-0x5f0];\n        else if (wc >= 0x6600 && wc < 0x6770)\n          summary = &hkscs2004_uni2indx_page66[(wc>>4)-0x660];\n      } else {\n        if (wc >= 0x6e00 && wc < 0x6e60)\n          summary = &hkscs2004_uni2indx_page6e[(wc>>4)-0x6e0];\n        else if (wc >= 0x7100 && wc < 0x7230)\n          summary = &hkscs2004_uni2indx_page71[(wc>>4)-0x710];\n        else if (wc >= 0x7400 && wc < 0x74a0)\n          summary = &hkscs2004_uni2indx_page74[(wc>>4)-0x740];\n        else if (wc >= 0x7900 && wc < 0x79d0)\n          summary = &hkscs2004_uni2indx_page79[(wc>>4)-0x790];\n        else if (wc >= 0x7d00 && wc < 0x7da0)\n          summary = &hkscs2004_uni2indx_page7d[(wc>>4)-0x7d0];\n        else if (wc >= 0x8100 && wc < 0x8170)\n          summary = &hkscs2004_uni2indx_page81[(wc>>4)-0x810];\n        else if (wc >= 0x8500 && wc < 0x85a0)\n          summary = &hkscs2004_uni2indx_page85[(wc>>4)-0x850];\n        else if (wc >= 0x8a00 && wc < 0x8b00)\n          summary = &hkscs2004_uni2indx_page8a[(wc>>4)-0x8a0];\n        else if (wc >= 0x9700 && wc < 0x9860)\n          summary = &hkscs2004_uni2indx_page97[(wc>>4)-0x970];\n        else if (wc >= 0x9f00 && wc < 0x9fc0)\n          summary = &hkscs2004_uni2indx_page9f[(wc>>4)-0x9f0];\n        else if (wc >= 0x20100 && wc < 0x20240)\n          summary = &hkscs2004_uni2indx_page201[(wc>>4)-0x2010];\n        else if (wc >= 0x20a00 && wc < 0x20ba0)\n          summary = &hkscs2004_uni2indx_page20a[(wc>>4)-0x20a0];\n      }\n    } else {\n      if (wc < 0x26b00) {\n        if (wc >= 0x21a00 && wc < 0x21a70)\n          summary = &hkscs2004_uni2indx_page21a[(wc>>4)-0x21a0];\n        else if (wc >= 0x21d00 && wc < 0x21e30)\n          summary = &hkscs2004_uni2indx_page21d[(wc>>4)-0x21d0];\n        else if (wc >= 0x22100 && wc < 0x221d0)\n          summary = &hkscs2004_uni2indx_page221[(wc>>4)-0x2210];\n        else if (wc >= 0x22700 && wc < 0x227a0)\n          summary = &hkscs2004_uni2indx_page227[(wc>>4)-0x2270];\n        else if (wc >= 0x23200 && wc < 0x23260)\n          summary = &hkscs2004_uni2indx_page232[(wc>>4)-0x2320];\n        else if (wc >= 0x23500 && wc < 0x23620)\n          summary = &hkscs2004_uni2indx_page235[(wc>>4)-0x2350];\n        else if (wc >= 0x23b00 && wc < 0x23b20)\n          summary = &hkscs2004_uni2indx_page23b[(wc>>4)-0x23b0];\n        else if (wc >= 0x23e00 && wc < 0x240f0)\n          summary = &hkscs2004_uni2indx_page23e[(wc>>4)-0x23e0];\n        else if (wc >= 0x24200 && wc < 0x242c0)\n          summary = &hkscs2004_uni2indx_page242[(wc>>4)-0x2420];\n        else if (wc >= 0x24b00 && wc < 0x24b10)\n          summary = &hkscs2004_uni2indx_page24b[(wc>>4)-0x24b0];\n        else if (wc >= 0x25400 && wc < 0x254a0)\n          summary = &hkscs2004_uni2indx_page254[(wc>>4)-0x2540];\n        else if (wc >= 0x25a00 && wc < 0x25a60)\n          summary = &hkscs2004_uni2indx_page25a[(wc>>4)-0x25a0];\n      } else {\n        if (wc >= 0x26b00 && wc < 0x26c50)\n          summary = &hkscs2004_uni2indx_page26b[(wc>>4)-0x26b0];\n        else if (wc >= 0x26e00 && wc < 0x26e90)\n          summary = &hkscs2004_uni2indx_page26e[(wc>>4)-0x26e0];\n        else if (wc >= 0x27000 && wc < 0x270e0)\n          summary = &hkscs2004_uni2indx_page270[(wc>>4)-0x2700];\n        else if (wc >= 0x27200 && wc < 0x27400)\n          summary = &hkscs2004_uni2indx_page272[(wc>>4)-0x2720];\n        else if (wc >= 0x27b00 && wc < 0x27cd0)\n          summary = &hkscs2004_uni2indx_page27b[(wc>>4)-0x27b0];\n        else if (wc >= 0x28600 && wc < 0x286c0)\n          summary = &hkscs2004_uni2indx_page286[(wc>>4)-0x2860];\n        else if (wc >= 0x28900 && wc < 0x28970)\n          summary = &hkscs2004_uni2indx_page289[(wc>>4)-0x2890];\n        else if (wc >= 0x28b00 && wc < 0x28bc0)\n          summary = &hkscs2004_uni2indx_page28b[(wc>>4)-0x28b0];\n        else if (wc >= 0x29000 && wc < 0x29080)\n          summary = &hkscs2004_uni2indx_page290[(wc>>4)-0x2900];\n        else if (wc >= 0x29800 && wc < 0x29950)\n          summary = &hkscs2004_uni2indx_page298[(wc>>4)-0x2980];\n        else if (wc >= 0x29e00 && wc < 0x29ec0)\n          summary = &hkscs2004_uni2indx_page29e[(wc>>4)-0x29e0];\n        else if (wc >= 0x2a100 && wc < 0x2a1c0)\n          summary = &hkscs2004_uni2indx_page2a1[(wc>>4)-0x2a10];\n        else if (wc >= 0x2a300 && wc < 0x2a360)\n          summary = &hkscs2004_uni2indx_page2a3[(wc>>4)-0x2a30];\n      }\n    }\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = hkscs2004_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 135,
      "depth": 29,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hkscs2008.h": {
    "hkscs2008_mbtowc": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\nhkscs2008_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x87)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x40 && c2 < 0x7f) || (c2 >= 0xa1 && c2 < 0xff)) {\n        unsigned int i = 157 * (c1 - 0x80) + (c2 - (c2 >= 0xa1 ? 0x62 : 0x40));\n        ucs4_t wc = 0xfffd;\n        unsigned short swc;\n        {\n          if (i < 1225)\n            swc = hkscs2008_2uni_page87[i-1099],\n            wc = hkscs2008_2uni_upages[swc>>8] | (swc & 0xff);\n        }\n        if (wc != 0xfffd) {\n          *pwc = wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hkscs2008_wctomb": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static int\nhkscs2008_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x3400 && wc < 0x34f0)\n      summary = &hkscs2008_uni2indx_page34[(wc>>4)-0x340];\n    else if (wc >= 0x3800 && wc < 0x3880)\n      summary = &hkscs2008_uni2indx_page38[(wc>>4)-0x380];\n    else if (wc >= 0x3a00 && wc < 0x3b00)\n      summary = &hkscs2008_uni2indx_page3a[(wc>>4)-0x3a0];\n    else if (wc >= 0x3e00 && wc < 0x3ef0)\n      summary = &hkscs2008_uni2indx_page3e[(wc>>4)-0x3e0];\n    else if (wc >= 0x4000 && wc < 0x4190)\n      summary = &hkscs2008_uni2indx_page40[(wc>>4)-0x400];\n    else if (wc >= 0x4300 && wc < 0x44f0)\n      summary = &hkscs2008_uni2indx_page43[(wc>>4)-0x430];\n    else if (wc >= 0x4600 && wc < 0x46b0)\n      summary = &hkscs2008_uni2indx_page46[(wc>>4)-0x460];\n    else if (wc >= 0x4900 && wc < 0x4940)\n      summary = &hkscs2008_uni2indx_page49[(wc>>4)-0x490];\n    else if (wc >= 0x5200 && wc < 0x5250)\n      summary = &hkscs2008_uni2indx_page52[(wc>>4)-0x520];\n    else if (wc >= 0x5400 && wc < 0x5450)\n      summary = &hkscs2008_uni2indx_page54[(wc>>4)-0x540];\n    else if (wc >= 0x5700 && wc < 0x58a0)\n      summary = &hkscs2008_uni2indx_page57[(wc>>4)-0x570];\n    else if (wc >= 0x6200 && wc < 0x62d0)\n      summary = &hkscs2008_uni2indx_page62[(wc>>4)-0x620];\n    else if (wc >= 0x6600 && wc < 0x6790)\n      summary = &hkscs2008_uni2indx_page66[(wc>>4)-0x660];\n    else if (wc >= 0x6a00 && wc < 0x6a30)\n      summary = &hkscs2008_uni2indx_page6a[(wc>>4)-0x6a0];\n    else if (wc >= 0x7000 && wc < 0x7070)\n      summary = &hkscs2008_uni2indx_page70[(wc>>4)-0x700];\n    else if (wc >= 0x7300 && wc < 0x74d0)\n      summary = &hkscs2008_uni2indx_page73[(wc>>4)-0x730];\n    else if (wc >= 0x7900 && wc < 0x7bd0)\n      summary = &hkscs2008_uni2indx_page79[(wc>>4)-0x790];\n    else if (wc >= 0x8400 && wc < 0x8620)\n      summary = &hkscs2008_uni2indx_page84[(wc>>4)-0x840];\n    else if (wc >= 0x8800 && wc < 0x88a0)\n      summary = &hkscs2008_uni2indx_page88[(wc>>4)-0x880];\n    else if (wc >= 0x8b00 && wc < 0x8b90)\n      summary = &hkscs2008_uni2indx_page8b[(wc>>4)-0x8b0];\n    else if (wc >= 0x9000 && wc < 0x9050)\n      summary = &hkscs2008_uni2indx_page90[(wc>>4)-0x900];\n    else if (wc >= 0x9200 && wc < 0x9220)\n      summary = &hkscs2008_uni2indx_page92[(wc>>4)-0x920];\n    else if (wc >= 0x9400 && wc < 0x9430)\n      summary = &hkscs2008_uni2indx_page94[(wc>>4)-0x940];\n    else if (wc >= 0x9700 && wc < 0x9750)\n      summary = &hkscs2008_uni2indx_page97[(wc>>4)-0x970];\n    else if (wc >= 0x9f00 && wc < 0x9fd0)\n      summary = &hkscs2008_uni2indx_page9f[(wc>>4)-0x9f0];\n    else if (wc >= 0x20a00 && wc < 0x20a90)\n      summary = &hkscs2008_uni2indx_page20a[(wc>>4)-0x20a0];\n    else if (wc >= 0x21d00 && wc < 0x21d60)\n      summary = &hkscs2008_uni2indx_page21d[(wc>>4)-0x21d0];\n    else if (wc >= 0x22400 && wc < 0x224d0)\n      summary = &hkscs2008_uni2indx_page224[(wc>>4)-0x2240];\n    else if (wc >= 0x23100 && wc < 0x23260)\n      summary = &hkscs2008_uni2indx_page231[(wc>>4)-0x2310];\n    else if (wc >= 0x23500 && wc < 0x236a0)\n      summary = &hkscs2008_uni2indx_page235[(wc>>4)-0x2350];\n    else if (wc >= 0x24100 && wc < 0x24170)\n      summary = &hkscs2008_uni2indx_page241[(wc>>4)-0x2410];\n    else if (wc >= 0x25800 && wc < 0x258e0)\n      summary = &hkscs2008_uni2indx_page258[(wc>>4)-0x2580];\n    else if (wc >= 0x25d00 && wc < 0x25dc0)\n      summary = &hkscs2008_uni2indx_page25d[(wc>>4)-0x25d0];\n    else if (wc >= 0x26000 && wc < 0x26030)\n      summary = &hkscs2008_uni2indx_page260[(wc>>4)-0x2600];\n    else if (wc >= 0x26e00 && wc < 0x26e90)\n      summary = &hkscs2008_uni2indx_page26e[(wc>>4)-0x26e0];\n    else if (wc >= 0x27b00 && wc < 0x27b70)\n      summary = &hkscs2008_uni2indx_page27b[(wc>>4)-0x27b0];\n    else if (wc >= 0x28900 && wc < 0x28910)\n      summary = &hkscs2008_uni2indx_page289[(wc>>4)-0x2890];\n    else if (wc >= 0x2ad00 && wc < 0x2ae00)\n      summary = &hkscs2008_uni2indx_page2ad[(wc>>4)-0x2ad0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = hkscs2008_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 102,
      "depth": 50,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hp_roman8.h": {
    "hp_roman8_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\nhp_roman8_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = hp_roman8_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hp_roman8_wctomb": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static int\nhp_roman8_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = hp_roman8_page00[wc-0x00a0];\n  else if (wc >= 0x0160 && wc < 0x0198)\n    c = hp_roman8_page01[wc-0x0160];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = hp_roman8_page02[wc-0x02c0];\n  else if (wc == 0x2014)\n    c = 0xf6;\n  else if (wc == 0x20a4)\n    c = 0xaf;\n  else if (wc == 0x25a0)\n    c = 0xfc;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/hz.h": {
    "hz_mbtowc": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nhz_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  unsigned int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == '~') {\n      if (n < count+2)\n        goto none;\n      c = s[1];\n      if (state == 0) {\n        if (c == '~') {\n          *pwc = (ucs4_t) '~';\n          conv->istate = state;\n          return count+2;\n        }\n        if (c == '{') {\n          state = 1;\n          s += 2; count += 2;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (c == '\\n') {\n          s += 2; count += 2;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n      } else {\n        if (c == '}') {\n          state = 0;\n          s += 2; count += 2;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n      }\n      goto ilseq;\n    }\n    break;\n  }\n  if (state == 0) {\n    *pwc = (ucs4_t) c;\n    conv->istate = state;\n    return count+1;\n  } else {\n    int ret;\n    if (n < count+2)\n      goto none;\n    ret = gb2312_mbtowc(conv,pwc,s,2);\n    if (ret == RET_ILSEQ)\n      goto ilseq;\n    if (ret != 2) abort();\n    conv->istate = state;\n    return count+2;\n  }\n\nnone:\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hz_wctomb": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static int\nhz_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  unsigned char buf[2];\n  int ret;\n\n  /* Code set 0 (ASCII or GB 1988-89) */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state ? 3 : 1);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state) {\n        r[0] = '~';\n        r[1] = '}';\n        r += 2;\n        state = 0;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Code set 1 (GB 2312-1980) */\n  ret = gb2312_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state ? 2 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (!state) {\n        r[0] = '~';\n        r[1] = '{';\n        r += 2;\n        state = 1;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hz_reset": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int\nhz_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  if (state) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = '~';\n    r[1] = '}';\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iconv.c": {
    "aliases2_lookup": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static const struct alias *\naliases2_lookup (register const char *str)\n{\n  const struct alias * ptr;\n  unsigned int count;\n  for (ptr = sysdep_aliases, count = sizeof(sysdep_aliases)/sizeof(sysdep_aliases[0]); count > 0; ptr++, count--)\n    if (!strcmp(str, stringpool2 + ptr->name))\n      return ptr;\n  return NULL;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "struct alias",
        "struct",
        "alias",
        "*\naliases2_lookup (register const char *str)",
        "*"
      ]
    },
    "strequal": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int strequal (const char* str1, const char* str2)\n{\n  unsigned char c1;\n  unsigned char c2;\n  for (;;) {\n    c1 = * (unsigned char *) str1++;\n    c2 = * (unsigned char *) str2++;\n    if (c1 == 0)\n      break;\n    if (c2 >= 'a' && c2 <= 'z')\n      c2 -= 'a'-'A';\n    if (c1 != c2)\n      break;\n  }\n  return (c1 == c2);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iconv_open": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "iconv_t iconv_open (const char* tocode, const char* fromcode)\n{\n  struct conv_struct * cd;\n  unsigned int from_index;\n  int from_wchar;\n  unsigned int to_index;\n  int to_wchar;\n  int transliterate;\n  int discard_ilseq;\n\n#include \"iconv_open1.h\"\n\n  cd = (struct conv_struct *) malloc(from_wchar != to_wchar\n                                     ? sizeof(struct wchar_conv_struct)\n                                     : sizeof(struct conv_struct));\n  if (cd == NULL) {\n    errno = ENOMEM;\n    return (iconv_t)(-1);\n  }\n\n#include \"iconv_open2.h\"\n\n  return (iconv_t)cd;\ninvalid:\n  errno = EINVAL;\n  return (iconv_t)(-1);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "iconv_t"
      ]
    },
    "iconv": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "size_t iconv (iconv_t icd,\n              ICONV_CONST char* * inbuf, size_t *inbytesleft,\n              char* * outbuf, size_t *outbytesleft)\n{\n  conv_t cd = (conv_t) icd;\n  if (inbuf == NULL || *inbuf == NULL)\n    return cd->lfuncs.loop_reset(icd,outbuf,outbytesleft);\n  else\n    return cd->lfuncs.loop_convert(icd,\n                                   (const char* *)inbuf,inbytesleft,\n                                   outbuf,outbytesleft);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "iconv_close": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int iconv_close (iconv_t icd)\n{\n  conv_t cd = (conv_t) icd;\n  free(cd);\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "iconv_open_into": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "int iconv_open_into (const char* tocode, const char* fromcode,\n                     iconv_allocation_t* resultp)\n{\n  struct conv_struct * cd;\n  unsigned int from_index;\n  int from_wchar;\n  unsigned int to_index;\n  int to_wchar;\n  int transliterate;\n  int discard_ilseq;\n\n#include \"iconv_open1.h\"\n\n  cd = (struct conv_struct *) resultp;\n\n#include \"iconv_open2.h\"\n\n  return 0;\ninvalid:\n  errno = EINVAL;\n  return -1;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "iconvctl": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "int iconvctl (iconv_t icd, int request, void* argument)\n{\n  conv_t cd = (conv_t) icd;\n  switch (request) {\n    case ICONV_TRIVIALP:\n      *(int *)argument =\n        ((cd->lfuncs.loop_convert == unicode_loop_convert\n          && cd->iindex == cd->oindex)\n         || cd->lfuncs.loop_convert == wchar_id_loop_convert\n         ? 1 : 0);\n      return 0;\n    case ICONV_GET_TRANSLITERATE:\n      *(int *)argument = cd->transliterate;\n      return 0;\n    case ICONV_SET_TRANSLITERATE:\n      cd->transliterate = (*(const int *)argument ? 1 : 0);\n      return 0;\n    case ICONV_GET_DISCARD_ILSEQ:\n      *(int *)argument = cd->discard_ilseq;\n      return 0;\n    case ICONV_SET_DISCARD_ILSEQ:\n      cd->discard_ilseq = (*(const int *)argument ? 1 : 0);\n      return 0;\n    case ICONV_SET_HOOKS:\n      if (argument != NULL) {\n        cd->hooks = *(const struct iconv_hooks *)argument;\n      } else {\n        cd->hooks.uc_hook = NULL;\n        cd->hooks.wc_hook = NULL;\n        cd->hooks.data = NULL;\n      }\n      return 0;\n    case ICONV_SET_FALLBACKS:\n      if (argument != NULL) {\n        cd->fallbacks = *(const struct iconv_fallbacks *)argument;\n      } else {\n        cd->fallbacks.mb_to_uc_fallback = NULL;\n        cd->fallbacks.uc_to_mb_fallback = NULL;\n        cd->fallbacks.mb_to_wc_fallback = NULL;\n        cd->fallbacks.wc_to_mb_fallback = NULL;\n        cd->fallbacks.data = NULL;\n      }\n      return 0;\n    default:\n      errno = EINVAL;\n      return -1;\n  }\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "compare_by_index": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static int compare_by_index (const void * arg1, const void * arg2)\n{\n  const struct nalias * alias1 = (const struct nalias *) arg1;\n  const struct nalias * alias2 = (const struct nalias *) arg2;\n  return (int)alias1->encoding_index - (int)alias2->encoding_index;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compare_by_name": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int compare_by_name (const void * arg1, const void * arg2)\n{\n  const char * name1 = *(const char **)arg1;\n  const char * name2 = *(const char **)arg2;\n  /* Compare alphabetically, but put \"CS\" names at the end. */\n  int sign = strcmp(name1,name2);\n  if (sign != 0) {\n    sign = ((name1[0]=='C' && name1[1]=='S') - (name2[0]=='C' && name2[1]=='S'))\n           * 4 + (sign >= 0 ? 1 : -1);\n  }\n  return sign;\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iconvlist": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "void iconvlist (int (*do_one) (unsigned int namescount,\n                               const char * const * names,\n                               void* data),\n                void* data)\n{\n#define aliascount1  sizeof(aliases)/sizeof(aliases[0])\n#ifndef aliases2_lookup\n#define aliascount2  sizeof(sysdep_aliases)/sizeof(sysdep_aliases[0])\n#else\n#define aliascount2  0\n#endif\n#define aliascount  (aliascount1+aliascount2)\n  struct nalias aliasbuf[aliascount];\n  const char * namesbuf[aliascount];\n  size_t num_aliases;\n  {\n    /* Put all existing aliases into a buffer. */\n    size_t i;\n    size_t j;\n    j = 0;\n    for (i = 0; i < aliascount1; i++) {\n      const struct alias * p = &aliases[i];\n      if (p->name >= 0\n          && p->encoding_index != ei_local_char\n          && p->encoding_index != ei_local_wchar_t) {\n        aliasbuf[j].name = stringpool + p->name;\n        aliasbuf[j].encoding_index = p->encoding_index;\n        j++;\n      }\n    }\n#ifndef aliases2_lookup\n    for (i = 0; i < aliascount2; i++) {\n      aliasbuf[j].name = stringpool2 + sysdep_aliases[i].name;\n      aliasbuf[j].encoding_index = sysdep_aliases[i].encoding_index;\n      j++;\n    }\n#endif\n    num_aliases = j;\n  }\n  /* Sort by encoding_index. */\n  if (num_aliases > 1)\n    qsort(aliasbuf, num_aliases, sizeof(struct nalias), compare_by_index);\n  {\n    /* Process all aliases with the same encoding_index together. */\n    size_t j;\n    j = 0;\n    while (j < num_aliases) {\n      unsigned int ei = aliasbuf[j].encoding_index;\n      size_t i = 0;\n      do\n        namesbuf[i++] = aliasbuf[j++].name;\n      while (j < num_aliases && aliasbuf[j].encoding_index == ei);\n      if (i > 1)\n        qsort(namesbuf, i, sizeof(const char *), compare_by_name);\n      /* Call the callback. */\n      if (do_one(i,namesbuf,data))\n        break;\n    }\n  }\n#undef aliascount\n#undef aliascount2\n#undef aliascount1\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "iconv_canonicalize": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "const char * iconv_canonicalize (const char * name)\n{\n  const char* code;\n  char buf[MAX_WORD_LENGTH+10+1];\n  const char* cp;\n  char* bp;\n  const struct alias * ap;\n  unsigned int count;\n  unsigned int index;\n  const char* pool;\n\n  /* Before calling aliases_lookup, convert the input string to upper case,\n   * and check whether it's entirely ASCII (we call gperf with option \"-7\"\n   * to achieve a smaller table) and non-empty. If it's not entirely ASCII,\n   * or if it's too long, it is not a valid encoding name.\n   */\n  for (code = name;;) {\n    /* Search code in the table. */\n    for (cp = code, bp = buf, count = MAX_WORD_LENGTH+10+1; ; cp++, bp++) {\n      unsigned char c = * (unsigned char *) cp;\n      if (c >= 0x80)\n        goto invalid;\n      if (c >= 'a' && c <= 'z')\n        c -= 'a'-'A';\n      *bp = c;\n      if (c == '\\0')\n        break;\n      if (--count == 0)\n        goto invalid;\n    }\n    for (;;) {\n      if (bp-buf >= 10 && memcmp(bp-10,\"//TRANSLIT\",10)==0) {\n        bp -= 10;\n        *bp = '\\0';\n        continue;\n      }\n      if (bp-buf >= 8 && memcmp(bp-8,\"//IGNORE\",8)==0) {\n        bp -= 8;\n        *bp = '\\0';\n        continue;\n      }\n      break;\n    }\n    if (buf[0] == '\\0') {\n      code = locale_charset();\n      /* Avoid an endless loop that could occur when using an older version\n         of localcharset.c. */\n      if (code[0] == '\\0')\n        goto invalid;\n      continue;\n    }\n    pool = stringpool;\n    ap = aliases_lookup(buf,bp-buf);\n    if (ap == NULL) {\n      pool = stringpool2;\n      ap = aliases2_lookup(buf);\n      if (ap == NULL)\n        goto invalid;\n    }\n    if (ap->encoding_index == ei_local_char) {\n      code = locale_charset();\n      /* Avoid an endless loop that could occur when using an older version\n         of localcharset.c. */\n      if (code[0] == '\\0')\n        goto invalid;\n      continue;\n    }\n    if (ap->encoding_index == ei_local_wchar_t) {\n      /* On systems which define __STDC_ISO_10646__, wchar_t is Unicode.\n         This is also the case on native Woe32 systems and Cygwin >= 1.7, where\n         we know that it is UTF-16.  */\n#if ((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) || (defined __CYGWIN__ && CYGWIN_VERSION_DLL_MAJOR >= 1007)\n      if (sizeof(wchar_t) == 4) {\n        index = ei_ucs4internal;\n        break;\n      }\n      if (sizeof(wchar_t) == 2) {\n# if WORDS_LITTLEENDIAN\n        index = ei_utf16le;\n# else\n        index = ei_utf16be;\n# endif\n        break;\n      }\n#elif __STDC_ISO_10646__\n      if (sizeof(wchar_t) == 4) {\n        index = ei_ucs4internal;\n        break;\n      }\n      if (sizeof(wchar_t) == 2) {\n        index = ei_ucs2internal;\n        break;\n      }\n      if (sizeof(wchar_t) == 1) {\n        index = ei_iso8859_1;\n        break;\n      }\n#endif\n    }\n    index = ap->encoding_index;\n    break;\n  }\n  return all_canonical[index] + pool;\n invalid:\n  return name;\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "* iconv_canonicalize (const char * name)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iconv_open1.h": {},
  "libiconv/libiconv-1.15/lib/iconv_open2.h": {},
  "libiconv/libiconv-1.15/lib/iso2022_cn.h": {
    "iso2022_cn_mbtowc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static int\niso2022_cn_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  SPLIT_STATE;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+4)\n        goto none;\n      if (s[1] == '$') {\n        if (s[2] == ')') {\n          if (s[3] == 'A') {\n            state2 = STATE2_DESIGNATED_GB2312;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'G') {\n            state2 = STATE2_DESIGNATED_CNS11643_1;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n        if (s[2] == '*') {\n          if (s[3] == 'H') {\n            state3 = STATE3_DESIGNATED_CNS11643_2;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n      }\n      if (s[1] == 'N') {\n        switch (state3) {\n          case STATE3_NONE:\n            goto ilseq;\n          case STATE3_DESIGNATED_CNS11643_2:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_2_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          default: abort();\n        }\n      }\n      goto ilseq;\n    }\n    if (c == SO) {\n      if (state2 != STATE2_DESIGNATED_GB2312 && state2 != STATE2_DESIGNATED_CNS11643_1)\n        goto ilseq;\n      state1 = STATE_TWOBYTE;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    if (c == SI) {\n      state1 = STATE_ASCII;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    break;\n  }\n  switch (state1) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        if (*pwc == 0x000a || *pwc == 0x000d) {\n          state2 = STATE2_NONE; state3 = STATE3_NONE;\n        }\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_TWOBYTE:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret;\n        switch (state2) {\n          case STATE2_NONE:\n            goto ilseq;\n          case STATE2_DESIGNATED_GB2312:\n            ret = gb2312_mbtowc(conv,pwc,s,2); break;\n          case STATE2_DESIGNATED_CNS11643_1:\n            ret = cns11643_1_mbtowc(conv,pwc,s,2); break;\n          default: abort();\n        }\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 127,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_cn_wctomb": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static int\niso2022_cn_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  unsigned char buf[3];\n  int ret;\n\n  /* There is no need to handle Unicode 3.1 tag characters and to look for\n     \"zh-CN\" or \"zh-TW\" tags, because GB2312 and CNS11643 are disjoint. */\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state1 == STATE_ASCII ? 1 : 2);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state1 != STATE_ASCII) {\n        r[0] = SI;\n        r += 1;\n        state1 = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      if (wc == 0x000a || wc == 0x000d) {\n        state2 = STATE2_NONE; state3 = STATE3_NONE;\n      }\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try GB 2312-1980. */\n  ret = gb2312_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_GB2312 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_GB2312) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'A';\n        r += 4;\n        state2 = STATE2_DESIGNATED_GB2312;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  ret = cns11643_wctomb(conv,buf,wc,3);\n  if (ret != RET_ILUNI) {\n    if (ret != 3) abort();\n\n    /* Try CNS 11643-1992 Plane 1. */\n    if (buf[0] == 1 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_CNS11643_1 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_CNS11643_1) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'G';\n        r += 4;\n        state2 = STATE2_DESIGNATED_CNS11643_1;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[1];\n      r[1] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 2. */\n    if (buf[0] == 2 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state3 == STATE3_DESIGNATED_CNS11643_2 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state3 != STATE3_DESIGNATED_CNS11643_2) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '*';\n        r[3] = 'H';\n        r += 4;\n        state3 = STATE3_DESIGNATED_CNS11643_2;\n      }\n      r[0] = ESC;\n      r[1] = 'N';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_cn_reset": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static int\niso2022_cn_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  (void)state2;\n  (void)state3;\n  if (state1 != STATE_ASCII) {\n    if (n < 1)\n      return RET_TOOSMALL;\n    r[0] = SI;\n    /* conv->ostate = 0; will be done by the caller */\n    return 1;\n  } else\n    return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_cnext.h": {
    "iso2022_cn_ext_mbtowc": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static int\niso2022_cn_ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  SPLIT_STATE;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+4)\n        goto none;\n      if (s[1] == '$') {\n        if (s[2] == ')') {\n          if (s[3] == 'A') {\n            state2 = STATE2_DESIGNATED_GB2312;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'G') {\n            state2 = STATE2_DESIGNATED_CNS11643_1;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'E') {\n            state2 = STATE2_DESIGNATED_ISO_IR_165;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n        if (s[2] == '*') {\n          if (s[3] == 'H') {\n            state3 = STATE3_DESIGNATED_CNS11643_2;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n        if (s[2] == '+') {\n          if (s[3] == 'I') {\n            state4 = STATE4_DESIGNATED_CNS11643_3;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'J') {\n            state4 = STATE4_DESIGNATED_CNS11643_4;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'K') {\n            state4 = STATE4_DESIGNATED_CNS11643_5;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'L') {\n            state4 = STATE4_DESIGNATED_CNS11643_6;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'M') {\n            state4 = STATE4_DESIGNATED_CNS11643_7;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n      }\n      if (s[1] == 'N') {\n        switch (state3) {\n          case STATE3_NONE:\n            goto ilseq;\n          case STATE3_DESIGNATED_CNS11643_2:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_2_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          default: abort();\n        }\n      }\n      if (s[1] == 'O') {\n        switch (state4) {\n          case STATE4_NONE:\n            goto ilseq;\n          case STATE4_DESIGNATED_CNS11643_3:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_3_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          case STATE4_DESIGNATED_CNS11643_4:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_4_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          case STATE4_DESIGNATED_CNS11643_5:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_5_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          case STATE4_DESIGNATED_CNS11643_6:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_6_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          case STATE4_DESIGNATED_CNS11643_7:\n            if (s[2] < 0x80 && s[3] < 0x80) {\n              int ret = cns11643_7_mbtowc(conv,pwc,s+2,2);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 2) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+4;\n            } else\n              goto ilseq;\n          default: abort();\n        }\n      }\n      goto ilseq;\n    }\n    if (c == SO) {\n      if (state2 != STATE2_DESIGNATED_GB2312 && state2 != STATE2_DESIGNATED_CNS11643_1 && state2 != STATE2_DESIGNATED_ISO_IR_165)\n        goto ilseq;\n      state1 = STATE_TWOBYTE;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    if (c == SI) {\n      state1 = STATE_ASCII;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    break;\n  }\n  switch (state1) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        if (*pwc == 0x000a || *pwc == 0x000d) {\n          state2 = STATE2_NONE; state3 = STATE3_NONE; state4 = STATE3_NONE;\n        }\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_TWOBYTE:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret;\n        switch (state2) {\n          case STATE2_NONE:\n            goto ilseq;\n          case STATE2_DESIGNATED_GB2312:\n            ret = gb2312_mbtowc(conv,pwc,s,2); break;\n          case STATE2_DESIGNATED_CNS11643_1:\n            ret = cns11643_1_mbtowc(conv,pwc,s,2); break;\n          case STATE2_DESIGNATED_ISO_IR_165:\n            ret = isoir165_mbtowc(conv,pwc,s,2); break;\n          default: abort();\n        }\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 235,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_cn_ext_wctomb": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "static int\niso2022_cn_ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  unsigned char buf[3];\n  int ret;\n\n  /* There is no need to handle Unicode 3.1 tag characters and to look for\n     \"zh-CN\" or \"zh-TW\" tags, because GB2312 and CNS11643 are disjoint. */\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state1 == STATE_ASCII ? 1 : 2);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state1 != STATE_ASCII) {\n        r[0] = SI;\n        r += 1;\n        state1 = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      if (wc == 0x000a || wc == 0x000d) {\n        state2 = STATE2_NONE; state3 = STATE3_NONE; state4 = STATE3_NONE;\n      }\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try GB 2312-1980. */\n  ret = gb2312_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_GB2312 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_GB2312) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'A';\n        r += 4;\n        state2 = STATE2_DESIGNATED_GB2312;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  ret = cns11643_wctomb(conv,buf,wc,3);\n  if (ret != RET_ILUNI) {\n    if (ret != 3) abort();\n\n    /* Try CNS 11643-1992 Plane 1. */\n    if (buf[0] == 1 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_CNS11643_1 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_CNS11643_1) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'G';\n        r += 4;\n        state2 = STATE2_DESIGNATED_CNS11643_1;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[1];\n      r[1] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 2. */\n    if (buf[0] == 2 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state3 == STATE3_DESIGNATED_CNS11643_2 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state3 != STATE3_DESIGNATED_CNS11643_2) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '*';\n        r[3] = 'H';\n        r += 4;\n        state3 = STATE3_DESIGNATED_CNS11643_2;\n      }\n      r[0] = ESC;\n      r[1] = 'N';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 3. */\n    if (buf[0] == 3 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state4 == STATE4_DESIGNATED_CNS11643_3 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state4 != STATE4_DESIGNATED_CNS11643_3) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '+';\n        r[3] = 'I';\n        r += 4;\n        state4 = STATE4_DESIGNATED_CNS11643_3;\n      }\n      r[0] = ESC;\n      r[1] = 'O';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 4. */\n    if (buf[0] == 4 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state4 == STATE4_DESIGNATED_CNS11643_4 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state4 != STATE4_DESIGNATED_CNS11643_4) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '+';\n        r[3] = 'J';\n        r += 4;\n        state4 = STATE4_DESIGNATED_CNS11643_4;\n      }\n      r[0] = ESC;\n      r[1] = 'O';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 5. */\n    if (buf[0] == 5 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state4 == STATE4_DESIGNATED_CNS11643_5 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state4 != STATE4_DESIGNATED_CNS11643_5) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '+';\n        r[3] = 'K';\n        r += 4;\n        state4 = STATE4_DESIGNATED_CNS11643_5;\n      }\n      r[0] = ESC;\n      r[1] = 'O';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 6. */\n    if (buf[0] == 6 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state4 == STATE4_DESIGNATED_CNS11643_6 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state4 != STATE4_DESIGNATED_CNS11643_6) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '+';\n        r[3] = 'L';\n        r += 4;\n        state4 = STATE4_DESIGNATED_CNS11643_6;\n      }\n      r[0] = ESC;\n      r[1] = 'O';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n    /* Try CNS 11643-1992 Plane 7. */\n    if (buf[0] == 7 && buf[1] < 0x80 && buf[2] < 0x80) {\n      int count = (state4 == STATE4_DESIGNATED_CNS11643_7 ? 0 : 4) + 4;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state4 != STATE4_DESIGNATED_CNS11643_7) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '+';\n        r[3] = 'M';\n        r += 4;\n        state4 = STATE4_DESIGNATED_CNS11643_7;\n      }\n      r[0] = ESC;\n      r[1] = 'O';\n      r[2] = buf[1];\n      r[3] = buf[2];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n\n  }\n\n  /* Try ISO-IR-165. */\n  ret = isoir165_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_ISO_IR_165 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_ISO_IR_165) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'E';\n        r += 4;\n        state2 = STATE2_DESIGNATED_ISO_IR_165;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 257,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_cn_ext_reset": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "static int\niso2022_cn_ext_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  (void)state2;\n  (void)state3;\n  (void)state4;\n  if (state1 != STATE_ASCII) {\n    if (n < 1)\n      return RET_TOOSMALL;\n    r[0] = SI;\n    /* conv->ostate = 0; will be done by the caller */\n    return 1;\n  } else\n    return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_jp.h": {
    "iso2022_jp_mbtowc": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\niso2022_jp_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+3)\n        goto none;\n      if (s[1] == '(') {\n        if (s[2] == 'B') {\n          state = STATE_ASCII;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'J') {\n          state = STATE_JISX0201ROMAN;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      if (s[1] == '$') {\n        if (s[2] == '@' || s[2] == 'B') {\n          /* We don't distinguish JIS X 0208-1978 and JIS X 0208-1983. */\n          state = STATE_JISX0208;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      goto ilseq;\n    }\n    break;\n  }\n  switch (state) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201ROMAN:\n      if (c < 0x80) {\n        int ret = jisx0201_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0208:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = jisx0208_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp_wctomb": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\niso2022_jp_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state == STATE_ASCII ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_ASCII) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0201-1976 Roman. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state == STATE_JISX0201ROMAN ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0201ROMAN) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'J';\n        r += 3;\n        state = STATE_JISX0201ROMAN;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0208-1990 in place of JIS X 0208-1978 and JIS X 0208-1983. */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state == STATE_JISX0208 ? 2 : 5);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0208) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_JISX0208;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp_reset": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static int\niso2022_jp_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  if (state != STATE_ASCII) {\n    if (n < 3)\n      return RET_TOOSMALL;\n    r[0] = ESC;\n    r[1] = '(';\n    r[2] = 'B';\n    /* conv->ostate = 0; will be done by the caller */\n    return 3;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_jp1.h": {
    "iso2022_jp1_mbtowc": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "static int\niso2022_jp1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+3)\n        goto none;\n      if (s[1] == '(') {\n        if (s[2] == 'B') {\n          state = STATE_ASCII;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'J') {\n          state = STATE_JISX0201ROMAN;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      if (s[1] == '$') {\n        if (s[2] == '@' || s[2] == 'B') {\n          /* We don't distinguish JIS X 0208-1978 and JIS X 0208-1983. */\n          state = STATE_JISX0208;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == '(') {\n          if (n < count+4)\n            goto none;\n          if (s[3] == 'D') {\n            state = STATE_JISX0212;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n        goto ilseq;\n      }\n      goto ilseq;\n    }\n    break;\n  }\n  switch (state) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201ROMAN:\n      if (c < 0x80) {\n        int ret = jisx0201_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0208:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = jisx0208_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    case STATE_JISX0212:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = jisx0212_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 110,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp1_wctomb": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static int\niso2022_jp1_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state == STATE_ASCII ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_ASCII) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0201-1976 Roman. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state == STATE_JISX0201ROMAN ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0201ROMAN) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'J';\n        r += 3;\n        state = STATE_JISX0201ROMAN;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0208-1990 in place of JIS X 0208-1978 and JIS X 0208-1983. */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state == STATE_JISX0208 ? 2 : 5);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0208) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_JISX0208;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0212-1990. */\n  ret = jisx0212_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state == STATE_JISX0212 ? 2 : 6);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0212) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '(';\n        r[3] = 'D';\n        r += 4;\n        state = STATE_JISX0212;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 96,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp1_reset": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static int\niso2022_jp1_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  if (state != STATE_ASCII) {\n    if (n < 3)\n      return RET_TOOSMALL;\n    r[0] = ESC;\n    r[1] = '(';\n    r[2] = 'B';\n    /* conv->ostate = 0; will be done by the caller */\n    return 3;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_jp2.h": {
    "iso2022_jp2_mbtowc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static int\niso2022_jp2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  SPLIT_STATE;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+3)\n        goto none;\n      if (s[1] == '(') {\n        if (s[2] == 'B') {\n          state1 = STATE_ASCII;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'J') {\n          state1 = STATE_JISX0201ROMAN;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'I') {\n          state1 = STATE_JISX0201KATAKANA;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      if (s[1] == '$') {\n        if (s[2] == '@' || s[2] == 'B') {\n          /* We don't distinguish JIS X 0208-1978 and JIS X 0208-1983. */\n          state1 = STATE_JISX0208;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'A') {\n          state1 = STATE_GB2312;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == '(') {\n          if (n < count+4)\n            goto none;\n          if (s[3] == 'D') {\n            state1 = STATE_JISX0212;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[3] == 'C') {\n            state1 = STATE_KSC5601;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          goto ilseq;\n        }\n        goto ilseq;\n      }\n      if (s[1] == '.') {\n        if (n < count+3)\n          goto none;\n        if (s[2] == 'A') {\n          state2 = STATE_G2_ISO8859_1;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'F') {\n          state2 = STATE_G2_ISO8859_7;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      if (s[1] == 'N') {\n        switch (state2) {\n          case STATE_G2_NONE:\n            goto ilseq;\n          case STATE_G2_ISO8859_1:\n            if (s[2] < 0x80) {\n              unsigned char buf = s[2]+0x80;\n              int ret = iso8859_1_mbtowc(conv,pwc,&buf,1);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 1) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+3;\n            } else\n              goto ilseq;\n          case STATE_G2_ISO8859_7:\n            if (s[2] < 0x80) {\n              unsigned char buf = s[2]+0x80;\n              int ret = iso8859_7_mbtowc(conv,pwc,&buf,1);\n              if (ret == RET_ILSEQ)\n                goto ilseq;\n              if (ret != 1) abort();\n              COMBINE_STATE;\n              conv->istate = state;\n              return count+3;\n            } else\n              goto ilseq;\n          default: abort();\n        }\n      }\n      goto ilseq;\n    }\n    break;\n  }\n  switch (state1) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        if (*pwc == 0x000a || *pwc == 0x000d)\n          state2 = STATE_G2_NONE;\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201ROMAN:\n      if (c < 0x80) {\n        int ret = jisx0201_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        if (*pwc == 0x000a || *pwc == 0x000d)\n          state2 = STATE_G2_NONE;\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201KATAKANA:\n      if (c < 0x80) {\n        unsigned char buf = c+0x80;\n        int ret = jisx0201_mbtowc(conv,pwc,&buf,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0208:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = jisx0208_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    case STATE_JISX0212:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = jisx0212_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    case STATE_GB2312:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = gb2312_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    case STATE_KSC5601:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = ksc5601_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 231,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp2_wctomb": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "static int\niso2022_jp2_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  unsigned char buf[2];\n  int ret;\n  /* This defines the conversion preferences depending on the current\n     langauge tag. */\n  enum conversion { none = 0, european, japanese, chinese, korean, other };\n  static const unsigned int conversion_lists[STATE_TAG_LANGUAGE] = {\n    /* STATE_TAG_NONE */\n    japanese + (european << 3) + (chinese << 6) + (korean << 9) + (other << 12),\n    /* STATE_TAG_LANGUAGE_ja */\n    japanese + (european << 3) + (chinese << 6) + (korean << 9) + (other << 12),\n    /* STATE_TAG_LANGUAGE_ko */\n    korean + (european << 3) + (japanese << 6) + (chinese << 9) + (other << 12),\n    /* STATE_TAG_LANGUAGE_zh */\n    chinese + (european << 3) + (japanese << 6) + (korean << 9) + (other << 12)\n  };\n  unsigned int conversion_list;\n\n  /* Handle Unicode tag characters (range U+E0000..U+E007F). */\n  if ((wc >> 7) == (0xe0000 >> 7)) {\n    char c = wc & 0x7f;\n    if (c >= 'A' && c <= 'Z')\n      c += 'a'-'A';\n    switch (c) {\n      case 0x01:\n        state3 = STATE_TAG_LANGUAGE;\n        COMBINE_STATE;\n        conv->ostate = state;\n        return 0;\n      case 'j':\n        if (state3 == STATE_TAG_LANGUAGE) {\n          state3 = STATE_TAG_LANGUAGE_j;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 'a':\n        if (state3 == STATE_TAG_LANGUAGE_j) {\n          state3 = STATE_TAG_LANGUAGE_ja;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 'k':\n        if (state3 == STATE_TAG_LANGUAGE) {\n          state3 = STATE_TAG_LANGUAGE_k;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 'o':\n        if (state3 == STATE_TAG_LANGUAGE_k) {\n          state3 = STATE_TAG_LANGUAGE_ko;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 'z':\n        if (state3 == STATE_TAG_LANGUAGE) {\n          state3 = STATE_TAG_LANGUAGE_z;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 'h':\n        if (state3 == STATE_TAG_LANGUAGE_z) {\n          state3 = STATE_TAG_LANGUAGE_zh;\n          COMBINE_STATE;\n          conv->ostate = state;\n          return 0;\n        }\n        break;\n      case 0x7f:\n        state3 = STATE_TAG_NONE;\n        COMBINE_STATE;\n        conv->ostate = state;\n        return 0;\n      default:\n        break;\n    }\n    /* Other tag characters reset the tag parsing state or are ignored. */\n    if (state3 >= STATE_TAG_LANGUAGE)\n      state3 = STATE_TAG_NONE;\n    COMBINE_STATE;\n    conv->ostate = state;\n    return 0;\n  }\n  if (state3 >= STATE_TAG_LANGUAGE)\n    state3 = STATE_TAG_NONE;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state1 == STATE_ASCII ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state1 != STATE_ASCII) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'B';\n        r += 3;\n        state1 = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      if (wc == 0x000a || wc == 0x000d)\n        state2 = STATE_G2_NONE;\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  conversion_list = conversion_lists[state3];\n\n  do {\n    switch (conversion_list & ((1 << 3) - 1)) {\n\n      case european:\n\n        /* Try ISO-8859-1. */\n        ret = iso8859_1_wctomb(conv,buf,wc,1);\n        if (ret != RET_ILUNI) {\n          if (ret != 1) abort();\n          if (buf[0] >= 0x80) {\n            int count = (state2 == STATE_G2_ISO8859_1 ? 3 : 6);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state2 != STATE_G2_ISO8859_1) {\n              r[0] = ESC;\n              r[1] = '.';\n              r[2] = 'A';\n              r += 3;\n              state2 = STATE_G2_ISO8859_1;\n            }\n            r[0] = ESC;\n            r[1] = 'N';\n            r[2] = buf[0]-0x80;\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        /* Try ISO-8859-7. */\n        ret = iso8859_7_wctomb(conv,buf,wc,1);\n        if (ret != RET_ILUNI) {\n          if (ret != 1) abort();\n          if (buf[0] >= 0x80) {\n            int count = (state2 == STATE_G2_ISO8859_7 ? 3 : 6);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state2 != STATE_G2_ISO8859_7) {\n              r[0] = ESC;\n              r[1] = '.';\n              r[2] = 'F';\n              r += 3;\n              state2 = STATE_G2_ISO8859_7;\n            }\n            r[0] = ESC;\n            r[1] = 'N';\n            r[2] = buf[0]-0x80;\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        break;\n\n      case japanese:\n\n        /* Try JIS X 0201-1976 Roman. */\n        ret = jisx0201_wctomb(conv,buf,wc,1);\n        if (ret != RET_ILUNI) {\n          if (ret != 1) abort();\n          if (buf[0] < 0x80) {\n            int count = (state1 == STATE_JISX0201ROMAN ? 1 : 4);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_JISX0201ROMAN) {\n              r[0] = ESC;\n              r[1] = '(';\n              r[2] = 'J';\n              r += 3;\n              state1 = STATE_JISX0201ROMAN;\n            }\n            r[0] = buf[0];\n            if (wc == 0x000a || wc == 0x000d)\n              state2 = STATE_G2_NONE;\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        /* Try JIS X 0208-1990 in place of JIS X 0208-1978 and\n           JIS X 0208-1983. */\n        ret = jisx0208_wctomb(conv,buf,wc,2);\n        if (ret != RET_ILUNI) {\n          if (ret != 2) abort();\n          if (buf[0] < 0x80 && buf[1] < 0x80) {\n            int count = (state1 == STATE_JISX0208 ? 2 : 5);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_JISX0208) {\n              r[0] = ESC;\n              r[1] = '$';\n              r[2] = 'B';\n              r += 3;\n              state1 = STATE_JISX0208;\n            }\n            r[0] = buf[0];\n            r[1] = buf[1];\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        /* Try JIS X 0212-1990. */\n        ret = jisx0212_wctomb(conv,buf,wc,2);\n        if (ret != RET_ILUNI) {\n          if (ret != 2) abort();\n          if (buf[0] < 0x80 && buf[1] < 0x80) {\n            int count = (state1 == STATE_JISX0212 ? 2 : 6);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_JISX0212) {\n              r[0] = ESC;\n              r[1] = '$';\n              r[2] = '(';\n              r[3] = 'D';\n              r += 4;\n              state1 = STATE_JISX0212;\n            }\n            r[0] = buf[0];\n            r[1] = buf[1];\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        break;\n\n      case chinese:\n\n        /* Try GB 2312-1980. */\n        ret = gb2312_wctomb(conv,buf,wc,2);\n        if (ret != RET_ILUNI) {\n          if (ret != 2) abort();\n          if (buf[0] < 0x80 && buf[1] < 0x80) {\n            int count = (state1 == STATE_GB2312 ? 2 : 5);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_GB2312) {\n              r[0] = ESC;\n              r[1] = '$';\n              r[2] = 'A';\n              r += 3;\n              state1 = STATE_GB2312;\n            }\n            r[0] = buf[0];\n            r[1] = buf[1];\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        break;\n\n      case korean:\n\n        /* Try KS C 5601-1992. */\n        ret = ksc5601_wctomb(conv,buf,wc,2);\n        if (ret != RET_ILUNI) {\n          if (ret != 2) abort();\n          if (buf[0] < 0x80 && buf[1] < 0x80) {\n            int count = (state1 == STATE_KSC5601 ? 2 : 6);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_KSC5601) {\n              r[0] = ESC;\n              r[1] = '$';\n              r[2] = '(';\n              r[3] = 'C';\n              r += 4;\n              state1 = STATE_KSC5601;\n            }\n            r[0] = buf[0];\n            r[1] = buf[1];\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        break;\n\n      case other:\n\n        /* Try JIS X 0201-1976 Kana. This is not officially part of\n           ISO-2022-JP-2, according to RFC 1554. Therefore we try this\n           only after all other attempts. */\n        ret = jisx0201_wctomb(conv,buf,wc,1);\n        if (ret != RET_ILUNI) {\n          if (ret != 1) abort();\n          if (buf[0] >= 0x80) {\n            int count = (state1 == STATE_JISX0201KATAKANA ? 1 : 4);\n            if (n < count)\n              return RET_TOOSMALL;\n            if (state1 != STATE_JISX0201KATAKANA) {\n              r[0] = ESC;\n              r[1] = '(';\n              r[2] = 'I';\n              r += 3;\n              state1 = STATE_JISX0201KATAKANA;\n            }\n            r[0] = buf[0]-0x80;\n            COMBINE_STATE;\n            conv->ostate = state;\n            return count;\n          }\n        }\n\n        break;\n\n      default:\n        abort();\n    }\n\n    conversion_list = conversion_list >> 3;\n  } while (conversion_list != 0);\n\n  return RET_ILUNI;\n}",
      "lines": 348,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp2_reset": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        670,
        1
      ],
      "content": "static int\niso2022_jp2_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  (void)state2;\n  (void)state3;\n  if (state1 != STATE_ASCII) {\n    if (n < 3)\n      return RET_TOOSMALL;\n    r[0] = ESC;\n    r[1] = '(';\n    r[2] = 'B';\n    /* conv->ostate = 0; will be done by the caller */\n    return 3;\n  } else\n    return 0;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_jp3.h": {
    "iso2022_jp3_mbtowc": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static int\niso2022_jp3_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate >> 3;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate &= 7;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    state_t state = conv->istate;\n    int count = 0;\n    unsigned char c;\n    for (;;) {\n      c = *s;\n      if (c == ESC) {\n        if (n < count+3)\n          goto none;\n        if (s[1] == '(') {\n          if (s[2] == 'B') {\n            state = STATE_ASCII;\n            s += 3; count += 3;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[2] == 'J') {\n            state = STATE_JISX0201ROMAN;\n            s += 3; count += 3;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[2] == 'I') {\n            state = STATE_JISX0201KATAKANA;\n            s += 3; count += 3;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          goto ilseq;\n        }\n        if (s[1] == '$') {\n          if (s[2] == '@' || s[2] == 'B') {\n            /* We don't distinguish JIS X 0208-1978 and JIS X 0208-1983. */\n            state = STATE_JISX0208;\n            s += 3; count += 3;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n          if (s[2] == '(') {\n            if (n < count+4)\n              goto none;\n            if (s[3] == 'O' || s[3] == 'Q') {\n              state = STATE_JISX02131;\n              s += 4; count += 4;\n              if (n < count+1)\n                goto none;\n              continue;\n            }\n            if (s[3] == 'P') {\n              state = STATE_JISX02132;\n              s += 4; count += 4;\n              if (n < count+1)\n                goto none;\n              continue;\n            }\n          }\n          goto ilseq;\n        }\n        goto ilseq;\n      }\n      break;\n    }\n    switch (state) {\n      case STATE_ASCII:\n        if (c < 0x80) {\n          int ret = ascii_mbtowc(conv,pwc,s,1);\n          if (ret == RET_ILSEQ)\n            goto ilseq;\n          if (ret != 1) abort();\n          conv->istate = state;\n          return count+1;\n        } else\n          goto ilseq;\n      case STATE_JISX0201ROMAN:\n        if (c < 0x80) {\n          int ret = jisx0201_mbtowc(conv,pwc,s,1);\n          if (ret == RET_ILSEQ)\n            goto ilseq;\n          if (ret != 1) abort();\n          conv->istate = state;\n          return count+1;\n        } else\n          goto ilseq;\n      case STATE_JISX0201KATAKANA:\n        if (c < 0x80) {\n          unsigned char buf = c+0x80;\n          int ret = jisx0201_mbtowc(conv,pwc,&buf,1);\n          if (ret == RET_ILSEQ)\n            goto ilseq;\n          if (ret != 1) abort();\n          conv->istate = state;\n          return count+1;\n        } else\n          goto ilseq;\n      case STATE_JISX0208:\n        if (n < count+2)\n          goto none;\n        if (s[0] < 0x80 && s[1] < 0x80) {\n          int ret = jisx0208_mbtowc(conv,pwc,s,2);\n          if (ret == RET_ILSEQ)\n            goto ilseq;\n          if (ret != 2) abort();\n          conv->istate = state;\n          return count+2;\n        } else\n          goto ilseq;\n      case STATE_JISX02131:\n      case STATE_JISX02132:\n        if (n < count+2)\n          goto none;\n        if (s[0] < 0x80 && s[1] < 0x80) {\n          ucs4_t wc = jisx0213_to_ucs4(((state-STATE_JISX02131+1)<<8)+s[0],s[1]);\n          if (wc) {\n            if (wc < 0x80) {\n              /* It's a combining character. */\n              ucs4_t wc1 = jisx0213_to_ucs_combining[wc - 1][0];\n              ucs4_t wc2 = jisx0213_to_ucs_combining[wc - 1][1];\n              /* We cannot output two Unicode characters at once. So,\n                 output the first character and buffer the second one. */\n              *pwc = wc1;\n              conv->istate = (wc2 << 3) | state;\n            } else {\n              *pwc = wc;\n              conv->istate = state;\n            }\n            return count+2;\n          }\n        }\n        goto ilseq;\n      default: abort();\n    }\n  none:\n    conv->istate = state;\n    return RET_TOOFEW(count);\n\n  ilseq:\n    conv->istate = state;\n    return RET_SHIFT_ILSEQ(count);\n  }\n}",
      "lines": 153,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp3_flushwc": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static int\niso2022_jp3_flushwc (conv_t conv, ucs4_t *pwc)\n{\n  ucs4_t last_wc = conv->istate >> 3;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate &= 7;\n    *pwc = last_wc;\n    return 1;\n  } else\n    return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp3_wctomb": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static int\niso2022_jp3_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned char buf[2];\n  unsigned short jch;\n  int ret;\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n\n  if (lasttwo) {\n    /* Attempt to combine the last character with this one. */\n    unsigned int idx;\n    unsigned int len;\n\n    if (wc == 0x02e5)\n      idx = iso2022_jp3_comp_table02e5_idx,\n      len = iso2022_jp3_comp_table02e5_len;\n    else if (wc == 0x02e9)\n      idx = iso2022_jp3_comp_table02e9_idx,\n      len = iso2022_jp3_comp_table02e9_len;\n    else if (wc == 0x0300)\n      idx = iso2022_jp3_comp_table0300_idx,\n      len = iso2022_jp3_comp_table0300_len;\n    else if (wc == 0x0301)\n      idx = iso2022_jp3_comp_table0301_idx,\n      len = iso2022_jp3_comp_table0301_len;\n    else if (wc == 0x309a)\n      idx = iso2022_jp3_comp_table309a_idx,\n      len = iso2022_jp3_comp_table309a_len;\n    else\n      goto not_combining;\n\n    do\n      if (iso2022_jp3_comp_table_data[idx].base == lasttwo)\n        break;\n    while (++idx, --len > 0);\n\n    if (len > 0) {\n      /* Output the combined character. */\n      /* We know the combined character is in JISX0213 plane 1, but\n         the buffered character may have been in JISX0208 or in\n         JISX0213 plane 1. */\n      count = (state != STATE_JISX02131 ? 4 : 0) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX02131) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '(';\n        r[3] = 'Q';\n        r += 4;\n        state = STATE_JISX02131;\n      }\n      lasttwo = iso2022_jp3_comp_table_data[idx].composed;\n      r[0] = (lasttwo >> 8) & 0xff;\n      r[1] = lasttwo & 0xff;\n      COMBINE_STATE_NO_LASTTWO;\n      conv->ostate = state;\n      return count;\n    }\n\n  not_combining:\n    /* Output the buffered character. */\n    /* We know it is in JISX0208 or in JISX0213 plane 1. */\n    count = (prevstate != state ? 3 : 0) + 2;\n    if (n < count)\n      return RET_TOOSMALL;\n    if (prevstate != state) {\n      if (state != STATE_JISX0208) abort();\n      r[0] = ESC;\n      r[1] = '$';\n      r[2] = 'B';\n      r += 3;\n    }\n    r[0] = (lasttwo >> 8) & 0xff;\n    r[1] = lasttwo & 0xff;\n    r += 2;\n  }\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      count += (state == STATE_ASCII ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_ASCII) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      COMBINE_STATE_NO_LASTTWO;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0201-1976 Roman. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      count += (state == STATE_JISX0201ROMAN ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0201ROMAN) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'J';\n        r += 3;\n        state = STATE_JISX0201ROMAN;\n      }\n      r[0] = buf[0];\n      COMBINE_STATE_NO_LASTTWO;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  jch = ucs4_to_jisx0213(wc);\n\n  /* Try JIS X 0208-1990 in place of JIS X 0208-1978 and JIS X 0208-1983. */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      if (jch & 0x0080) {\n        /* A possible match in comp_table_data. Buffer it. */\n        prevstate = state;\n        lasttwo = jch & 0x7f7f;\n        state = STATE_JISX0208;\n        COMBINE_STATE;\n        conv->ostate = state;\n        return count;\n      } else {\n        count += (state == STATE_JISX0208 ? 2 : 5);\n        if (n < count)\n          return RET_TOOSMALL;\n        if (state != STATE_JISX0208) {\n          r[0] = ESC;\n          r[1] = '$';\n          r[2] = 'B';\n          r += 3;\n          state = STATE_JISX0208;\n        }\n        r[0] = buf[0];\n        r[1] = buf[1];\n        COMBINE_STATE_NO_LASTTWO;\n        conv->ostate = state;\n        return count;\n      }\n    }\n  }\n\n  /* Try JISX 0213 plane 1 and JISX 0213 plane 2. */\n  if (jch != 0) {\n    if (jch & 0x8000) {\n      /* JISX 0213 plane 2. */\n      if (state != STATE_JISX02132) {\n        count += 4;\n        if (n < count)\n          return RET_TOOSMALL;\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '(';\n        r[3] = 'P';\n        r += 4;\n        state = STATE_JISX02132;\n      }\n    } else {\n      /* JISX 0213 plane 1. */\n      if (state != STATE_JISX02131) {\n        count += 4;\n        if (n < count)\n          return RET_TOOSMALL;\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '(';\n        r[3] = 'Q';\n        r += 4;\n        state = STATE_JISX02131;\n      }\n    }\n    if (jch & 0x0080) {\n      /* A possible match in comp_table_data. We have to buffer it. */\n      /* We know it's a JISX 0213 plane 1 character. */\n      if (jch & 0x8000) abort();\n      prevstate = state;\n      lasttwo = jch & 0x7f7f;\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n    count += 2;\n    if (n < count)\n      return RET_TOOSMALL;\n    r[0] = (jch >> 8) & 0x7f;\n    r[1] = jch & 0x7f;\n    COMBINE_STATE_NO_LASTTWO;\n    conv->ostate = state;\n    return count;\n  }\n\n  /* Try JIS X 0201-1976 Katakana. This is not officially part of\n     ISO-2022-JP-3. Therefore we try it after all other attempts. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] >= 0x80) {\n      count += (state == STATE_JISX0201KATAKANA ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0201KATAKANA) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'I';\n        r += 3;\n        state = STATE_JISX0201KATAKANA;\n      }\n      r[0] = buf[0]-0x80;\n      COMBINE_STATE_NO_LASTTWO;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 233,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jp3_reset": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        526,
        1
      ],
      "content": "static int\niso2022_jp3_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  {\n    int count =\n      (lasttwo ? (prevstate != state ? 3 : 0) + 2 : 0)\n      + (state != STATE_ASCII ? 3 : 0);\n    if (n < count)\n      return RET_TOOSMALL;\n    if (lasttwo) {\n      if (prevstate != state) {\n        if (state != STATE_JISX0208) abort();\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = 'B';\n        r += 3;\n      }\n      r[0] = (lasttwo >> 8) & 0xff;\n      r[1] = lasttwo & 0xff;\n      r += 2;\n    }\n    if (state != STATE_ASCII) {\n      r[0] = ESC;\n      r[1] = '(';\n      r[2] = 'B';\n    }\n    /* conv->ostate = 0; will be done by the caller */\n    return count;\n  }\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_jpms.h": {
    "iso2022_jpms_mbtowc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static int\niso2022_jpms_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+3)\n        goto none;\n      if (s[1] == '(') {\n        if (s[2] == 'B') {\n          state = STATE_ASCII;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'I') {\n          state = STATE_JISX0201KATAKANA;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == 'J') {\n          state = STATE_JISX0201ROMAN;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        goto ilseq;\n      }\n      if (s[1] == '$') {\n        if (s[2] == '@' || s[2] == 'B') {\n          /* We don't distinguish JIS X 0208-1978 and JIS X 0208-1983. */\n          state = STATE_JISX0208MS;\n          s += 3; count += 3;\n          if (n < count+1)\n            goto none;\n          continue;\n        }\n        if (s[2] == '(') {\n          if (n < count+4)\n            goto none;\n          if (s[3] == 'D') {\n            state = STATE_JISX0212MS;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n        goto ilseq;\n      }\n      goto ilseq;\n    }\n    if (c == SO) {\n      if (state == STATE_JISX0201ROMAN)\n        state = STATE_JISX0201KATAKANA;\n      s += 1; count += 1;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    if (c == SI) {\n      if (state == STATE_JISX0201KATAKANA)\n        state = STATE_JISX0201ROMAN;\n      s += 1; count += 1;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    break;\n  }\n  switch (state) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201ROMAN:\n      if (c < 0x80) {\n        int ret = jisx0201_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0201KATAKANA:\n      if (c < 0x80) {\n        unsigned char buf = c+0x80;\n        int ret = jisx0201_mbtowc(conv,pwc,&buf,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_JISX0208MS:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret;\n        if (s[0] < 0x75) {\n          if (s[0] == 0x2d) {\n            /* Extension of JIS X 0208.  */\n            if (s[1] >= 0x21 && s[1] <= 0x79) {\n              unsigned char i = (s[1] - 0x21) + 1;\n              ret = cp50221_0208_ext_mbtowc(conv,pwc,&i,1);\n              if (ret == 1)\n                ret = 2;\n            } else\n              ret = RET_ILSEQ;\n          } else {\n            /* JIS X 0208.  */\n            ret = jisx0208_mbtowc(conv,pwc,s,2);\n          }\n        } else {\n          /* Extension of JIS X 0208.\n             0x{75..7E}{21..8E} maps to U+E000..U+E3AB.\n             But some rows maps to characters present in CP932.  */\n          if (s[0] <= 0x7e && (s[1] >= 0x21 && s[1] <= 0x7e)) {\n            unsigned short wc = 0xfffd;\n            if (s[0] >= 0x79 && s[0] <= 0x7c)\n              wc = cp932ext_2uni_pageed[(s[0] - 0x79) * 94 + (s[1] - 0x21)];\n            if (wc == 0xfffd)\n              wc = (s[0] - 0x75) * 94 + (s[1] - 0x21) + 0xe000;\n            *pwc = wc;\n            ret = 2;\n          } else\n            ret = RET_ILSEQ;\n        }\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    case STATE_JISX0212MS:\n      if (n < count+2)\n        goto none;\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret;\n        if (s[0] < 0x73) {\n          /* JIS X 0212.  */\n          ret = jisx0212_mbtowc(conv,pwc,s,2);\n        } else {\n          if (s[0] < 0x75) {\n            /* Extension of JIS X 0212.  */\n            if (s[1] >= 0x21 && s[1] <= 0x7e) {\n              unsigned char i = (s[0] - 0x73) * 94 + (s[1] - 0x21) + 1;\n              ret = cp50221_0212_ext_mbtowc(conv,pwc,&i,1);\n              if (ret == 1)\n                ret = 2;\n            } else\n              ret = RET_ILSEQ;\n          } else {\n            /* Extension of JIS X 0208.\n               0x{75..7E}{21..8E} maps to U+E3AC..U+E757.  */\n            if (s[0] <= 0x7e && (s[1] >= 0x21 && s[1] <= 0x7e)) {\n              *pwc = (s[0] - 0x75) * 94 + (s[1] - 0x21) + 0xe3ac;\n              ret = 2;\n            } else\n              ret = RET_ILSEQ;\n          }\n        }\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 196,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jpms_wctomb": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "static int\niso2022_jpms_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state == STATE_ASCII ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_ASCII) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0201-1976 Katakana. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] >= 0x80) {\n      int count = (state == STATE_JISX0201KATAKANA ? 1 : 4);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0201KATAKANA) {\n        r[0] = ESC;\n        r[1] = '(';\n        r[2] = 'I';\n        r += 3;\n        state = STATE_JISX0201KATAKANA;\n      }\n      r[0] = buf[0]-0x80;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0208-1990, in place of JIS X 0208-1978 and JIS X 0208-1983,\n     and the extensions mentioned above.  */\n  if (wc >= 0xe000 && wc < 0xe3ac) {\n    unsigned short i = wc - 0xe000;\n    buf[0] = (i / 94) + 0x75;\n    buf[1] = (i % 94) + 0x21;\n    ret = 2;\n  } else {\n    ret = jisx0208_wctomb(conv,buf,wc,2);\n    if (ret == RET_ILUNI) {\n      /* Extension of JIS X 0208.  */\n      unsigned char i;\n      ret = cp50221_0208_ext_wctomb(conv,&i,wc,1);\n      if (ret == 1) {\n        buf[0] = 0x2d;\n        buf[1] = i-1 + 0x21;\n        ret = 2;\n      } else if (wc == 0x663B) {\n        buf[0] = 0x7a;\n        buf[1] = 0x36;\n        ret = 2;\n      } else if (wc == 0xffe2) {\n        buf[0] = 0x7c;\n        buf[1] = 0x7b;\n        ret = 2;\n      } else if (wc == 0xffe4) {\n        buf[0] = 0x7c;\n        buf[1] = 0x7c;\n        ret = 2;\n      }\n    }\n  }\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state == STATE_JISX0208MS ? 2 : 5);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0208MS) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = 'B';\n        r += 3;\n        state = STATE_JISX0208MS;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try JIS X 0212-1990 and the extensions mentioned above. */\n  if (wc >= 0xe3ac && wc < 0xe758) {\n    unsigned short i = wc - 0xe3ac;\n    buf[0] = (i / 94) + 0x75;\n    buf[1] = (i % 94) + 0x21;\n    ret = 2;\n  } else {\n    ret = jisx0212_wctomb(conv,buf,wc,2);\n    if (ret == RET_ILUNI) {\n      /* Extension of JIS X 0212.  */\n      unsigned char i;\n      ret = cp50221_0212_ext_wctomb(conv,&i,wc,1);\n      if (ret == 1) {\n        i -= 1;\n        buf[0] = (i / 94) + 0x73;\n        buf[1] = (i % 94) + 0x21;\n        ret = 2;\n      }\n    }\n  }\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state == STATE_JISX0212MS ? 2 : 6);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state != STATE_JISX0212MS) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = '(';\n        r[3] = 'D';\n        r += 4;\n        state = STATE_JISX0212MS;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 144,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_jpms_reset": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static int\niso2022_jpms_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  if (state != STATE_ASCII) {\n    if (n < 3)\n      return RET_TOOSMALL;\n    r[0] = ESC;\n    r[1] = '(';\n    r[2] = 'B';\n    /* conv->ostate = 0; will be done by the caller */\n    return 3;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso2022_kr.h": {
    "iso2022_kr_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\niso2022_kr_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  SPLIT_STATE;\n  int count = 0;\n  unsigned char c;\n  for (;;) {\n    c = *s;\n    if (c == ESC) {\n      if (n < count+4)\n        goto none;\n      if (s[1] == '$') {\n        if (s[2] == ')') {\n          if (s[3] == 'C') {\n            state2 = STATE2_DESIGNATED_KSC5601;\n            s += 4; count += 4;\n            if (n < count+1)\n              goto none;\n            continue;\n          }\n        }\n      }\n      goto ilseq;\n    }\n    if (c == SO) {\n      if (state2 != STATE2_DESIGNATED_KSC5601)\n        goto ilseq;\n      state1 = STATE_TWOBYTE;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    if (c == SI) {\n      state1 = STATE_ASCII;\n      s++; count++;\n      if (n < count+1)\n        goto none;\n      continue;\n    }\n    break;\n  }\n  switch (state1) {\n    case STATE_ASCII:\n      if (c < 0x80) {\n        int ret = ascii_mbtowc(conv,pwc,s,1);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 1) abort();\n#if 0 /* Accept ISO-2022-KR according to CJK.INF. */\n        if (*pwc == 0x000a || *pwc == 0x000d)\n          state2 = STATE2_NONE;\n#endif\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+1;\n      } else\n        goto ilseq;\n    case STATE_TWOBYTE:\n      if (n < count+2)\n        goto none;\n      if (state2 != STATE2_DESIGNATED_KSC5601) abort();\n      if (s[0] < 0x80 && s[1] < 0x80) {\n        int ret = ksc5601_mbtowc(conv,pwc,s,2);\n        if (ret == RET_ILSEQ)\n          goto ilseq;\n        if (ret != 2) abort();\n        COMBINE_STATE;\n        conv->istate = state;\n        return count+2;\n      } else\n        goto ilseq;\n    default: abort();\n  }\n\nnone:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  COMBINE_STATE;\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_kr_wctomb": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static int\niso2022_kr_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII. */\n  ret = ascii_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] < 0x80) {\n      int count = (state1 == STATE_ASCII ? 1 : 2);\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state1 != STATE_ASCII) {\n        r[0] = SI;\n        r += 1;\n        state1 = STATE_ASCII;\n      }\n      r[0] = buf[0];\n      if (wc == 0x000a || wc == 0x000d)\n        state2 = STATE2_NONE;\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  /* Try KS C 5601-1992. */\n  ret = ksc5601_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (buf[0] < 0x80 && buf[1] < 0x80) {\n      int count = (state2 == STATE2_DESIGNATED_KSC5601 ? 0 : 4) + (state1 == STATE_TWOBYTE ? 0 : 1) + 2;\n      if (n < count)\n        return RET_TOOSMALL;\n      if (state2 != STATE2_DESIGNATED_KSC5601) {\n        r[0] = ESC;\n        r[1] = '$';\n        r[2] = ')';\n        r[3] = 'C';\n        r += 4;\n        state2 = STATE2_DESIGNATED_KSC5601;\n      }\n      if (state1 != STATE_TWOBYTE) {\n        r[0] = SO;\n        r += 1;\n        state1 = STATE_TWOBYTE;\n      }\n      r[0] = buf[0];\n      r[1] = buf[1];\n      COMBINE_STATE;\n      conv->ostate = state;\n      return count;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso2022_kr_reset": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int\niso2022_kr_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  SPLIT_STATE;\n  (void)state2;\n  if (state1 != STATE_ASCII) {\n    if (n < 1)\n      return RET_TOOSMALL;\n    r[0] = SI;\n    /* conv->ostate = 0; will be done by the caller */\n    return 1;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso646_cn.h": {
    "iso646_cn_mbtowc": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static int\niso646_cn_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    if (c == 0x24)\n      *pwc = (ucs4_t) 0x00a5;\n    else if (c == 0x7e)\n      *pwc = (ucs4_t) 0x203e;\n    else\n      *pwc = (ucs4_t) c;\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso646_cn_wctomb": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\niso646_cn_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0080 && !(wc == 0x0024 || wc == 0x007e)) {\n    *r = wc;\n    return 1;\n  }\n  if (wc == 0x00a5) {\n    *r = 0x24;\n    return 1;\n  }\n  if (wc == 0x203e) {\n    *r = 0x7e;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso646_jp.h": {
    "iso646_jp_mbtowc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static int\niso646_jp_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    if (c == 0x5c)\n      *pwc = (ucs4_t) 0x00a5;\n    else if (c == 0x7e)\n      *pwc = (ucs4_t) 0x203e;\n    else\n      *pwc = (ucs4_t) c;\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso646_jp_wctomb": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\niso646_jp_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0080 && !(wc == 0x005c || wc == 0x007e)) {\n    *r = wc;\n    return 1;\n  }\n  if (wc == 0x00a5) {\n    *r = 0x5c;\n    return 1;\n  }\n  if (wc == 0x203e) {\n    *r = 0x7e;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_1.h": {
    "iso8859_1_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static int\niso8859_1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_1_wctomb": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static int\niso8859_1_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0100) {\n    *r = wc;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_10.h": {
    "iso8859_10_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_10_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_10_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_10_wctomb": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\niso8859_10_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = iso8859_10_page00[wc-0x00a0];\n  else if (wc == 0x2015)\n    c = 0xbd;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_11.h": {
    "iso8859_11_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\niso8859_11_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa1) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c <= 0xfb && !(c >= 0xdb && c <= 0xde)) {\n    *pwc = (ucs4_t) (c + 0x0d60);\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_11_wctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\niso8859_11_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x00a1) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0e01 && wc <= 0x0e5b && !(wc >= 0x0e3b && wc <= 0x0e3e)) {\n    *r = wc-0x0d60;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_13.h": {
    "iso8859_13_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_13_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_13_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_13_wctomb": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\niso8859_13_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = iso8859_13_page00[wc-0x00a0];\n  else if (wc >= 0x2018 && wc < 0x2020)\n    c = iso8859_13_page20[wc-0x2018];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_14.h": {
    "iso8859_14_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_14_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0xa0)\n    *pwc = (ucs4_t) iso8859_14_2uni[c-0xa0];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_14_wctomb": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\niso8859_14_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = iso8859_14_page00[wc-0x00a0];\n  else if (wc >= 0x0108 && wc < 0x0128)\n    c = iso8859_14_page01_0[wc-0x0108];\n  else if (wc >= 0x0170 && wc < 0x0180)\n    c = iso8859_14_page01_1[wc-0x0170];\n  else if (wc >= 0x1e00 && wc < 0x1e88)\n    c = iso8859_14_page1e_0[wc-0x1e00];\n  else if (wc >= 0x1ef0 && wc < 0x1ef8)\n    c = iso8859_14_page1e_1[wc-0x1ef0];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_15.h": {
    "iso8859_15_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\niso8859_15_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0xa0 && c < 0xc0)\n    *pwc = (ucs4_t) iso8859_15_2uni[c-0xa0];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_15_wctomb": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\niso8859_15_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = iso8859_15_page00[wc-0x00a0];\n  else if (wc >= 0x00c0 && wc < 0x0100)\n    c = wc;\n  else if (wc >= 0x0150 && wc < 0x0180)\n    c = iso8859_15_page01[wc-0x0150];\n  else if (wc == 0x20ac)\n    c = 0xa4;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_16.h": {
    "iso8859_16_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_16_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_16_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_16_wctomb": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\niso8859_16_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = iso8859_16_page00[wc-0x00a0];\n  else if (wc >= 0x0218 && wc < 0x0220)\n    c = iso8859_16_page02[wc-0x0218];\n  else if (wc >= 0x2018 && wc < 0x2020)\n    c = iso8859_16_page20[wc-0x2018];\n  else if (wc == 0x20ac)\n    c = 0xa4;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_2.h": {
    "iso8859_2_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_2_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_2_wctomb": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static int\niso8859_2_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = iso8859_2_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = iso8859_2_page02[wc-0x02c0];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_3.h": {
    "iso8859_3_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\niso8859_3_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = iso8859_3_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_3_wctomb": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\niso8859_3_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = iso8859_3_page00[wc-0x00a0];\n  else if (wc >= 0x0108 && wc < 0x0180)\n    c = iso8859_3_page01[wc-0x0108];\n  else if (wc >= 0x02d8 && wc < 0x02e0)\n    c = iso8859_3_page02[wc-0x02d8];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_4.h": {
    "iso8859_4_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_4_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_4_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_4_wctomb": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static int\niso8859_4_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = iso8859_4_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = iso8859_4_page02[wc-0x02c0];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_5.h": {
    "iso8859_5_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\niso8859_5_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) iso8859_5_2uni[c-0xa0];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_5_wctomb": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\niso8859_5_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b0)\n    c = iso8859_5_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0460)\n    c = iso8859_5_page04[wc-0x0400];\n  else if (wc == 0x2116)\n    c = 0xf0;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_6.h": {
    "iso8859_6_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\niso8859_6_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = iso8859_6_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_6_wctomb": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\niso8859_6_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00b0)\n    c = iso8859_6_page00[wc-0x00a0];\n  else if (wc >= 0x0608 && wc < 0x0658)\n    c = iso8859_6_page06[wc-0x0608];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_7.h": {
    "iso8859_7_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\niso8859_7_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = iso8859_7_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_7_wctomb": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\niso8859_7_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = iso8859_7_page00[wc-0x00a0];\n  else if (wc >= 0x0378 && wc < 0x03d0)\n    c = iso8859_7_page03[wc-0x0378];\n  else if (wc >= 0x2010 && wc < 0x2020)\n    c = iso8859_7_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0xa4;\n  else if (wc == 0x20af)\n    c = 0xa5;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_8.h": {
    "iso8859_8_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\niso8859_8_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0xa0) {\n    unsigned short wc = iso8859_8_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  else {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_8_wctomb": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static int\niso8859_8_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = iso8859_8_page00[wc-0x00a0];\n  else if (wc >= 0x05d0 && wc < 0x05f0)\n    c = iso8859_8_page05[wc-0x05d0];\n  else if (wc >= 0x2008 && wc < 0x2018)\n    c = iso8859_8_page20[wc-0x2008];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/iso8859_9.h": {
    "iso8859_9_mbtowc": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\niso8859_9_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0xd0)\n    *pwc = (ucs4_t) iso8859_9_2uni[c-0xd0];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "iso8859_9_wctomb": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\niso8859_9_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00d0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00d0 && wc < 0x0100)\n    c = iso8859_9_page00[wc-0x00d0];\n  else if (wc >= 0x0118 && wc < 0x0160)\n    c = iso8859_9_page01[wc-0x0118];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/isoir165.h": {
    "isoir165_mbtowc": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static int\nisoir165_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  int ret;\n\n  /* Map full-width pinyin (row 0x28) like half-width pinyin (row 0x2B). */\n  if (s[0] == 0x28) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 <= 0x40) {\n        unsigned char buf[2];\n        buf[0] = 0x2b;\n        buf[1] = c2;\n        ret = isoir165ext_mbtowc(conv,pwc,buf,2);\n        if (ret != RET_ILSEQ)\n          return ret;\n      }\n    }\n  }\n  /* Try the GB2312 -> Unicode table. */\n  ret = gb2312_mbtowc(conv,pwc,s,n);\n  if (ret != RET_ILSEQ)\n    return ret;\n  /* Row 0x2A is GB_1988-80. */\n  if (s[0] == 0x2a) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        ret = iso646_cn_mbtowc(conv,pwc,s+1,1);\n        if (ret != 1) abort();\n        return 2;\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  /* Try the ISO-IR-165 extensions -> Unicode table. */\n  ret = isoir165ext_mbtowc(conv,pwc,s,n);\n  return ret;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isoir165_wctomb": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static int\nisoir165_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Try the Unicode -> GB2312 table. */\n  ret = gb2312_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (!(buf[0] == 0x28 && buf[1] >= 0x21 && buf[1] <= 0x40)) {\n      if (n >= 2) {\n        r[0] = buf[0];\n        r[1] = buf[1];\n        return 2;\n      }\n      return RET_TOOSMALL;\n    }\n  }\n  /* Row 0x2A is GB_1988-80. */\n  ret = iso646_cn_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    if (ret != 1) abort();\n    if (buf[0] >= 0x21 && buf[0] < 0x7f) {\n      if (n >= 2) {\n        r[0] = 0x2a;\n        r[1] = buf[0];\n        return 2;\n      }\n      return RET_TOOSMALL;\n    }\n  }\n  /* Try the Unicode -> ISO-IR-165 extensions table. */\n  ret = isoir165ext_wctomb(conv,r,wc,n);\n  return ret;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/isoir165ext.h": {
    "isoir165ext_mbtowc": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nisoir165ext_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x2b && c1 <= 0x2f) || (c1 >= 0x7a && c1 <= 0x7e)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 8366) {\n          if (i < 1410)\n            wc = isoir165ext_2uni_page2b[i-940];\n        } else {\n          if (i < 8836)\n            wc = isoir165ext_2uni_page7a[i-8366];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isoir165ext_wctomb": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        798,
        1
      ],
      "content": "static int\nisoir165ext_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0200)\n      summary = &isoir165ext_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x0300 && wc < 0x03c0)\n      summary = &isoir165ext_uni2indx_page03[(wc>>4)-0x030];\n    else if (wc >= 0x1e00 && wc < 0x1fc0)\n      summary = &isoir165ext_uni2indx_page1e[(wc>>4)-0x1e0];\n    else if (wc >= 0x3000 && wc < 0x3040)\n      summary = &isoir165ext_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x3200 && wc < 0x3400)\n      summary = &isoir165ext_uni2indx_page32[(wc>>4)-0x320];\n    else if (wc >= 0x4e00 && wc < 0x7d00)\n      summary = &isoir165ext_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0x7e00 && wc < 0x92d0)\n      summary = &isoir165ext_uni2indx_page7e[(wc>>4)-0x7e0];\n    else if (wc >= 0x9400 && wc < 0x9cf0)\n      summary = &isoir165ext_uni2indx_page94[(wc>>4)-0x940];\n    else if (wc >= 0x9e00 && wc < 0x9f90)\n      summary = &isoir165ext_uni2indx_page9e[(wc>>4)-0x9e0];\n    else if (wc >= 0xff00 && wc < 0xff50)\n      summary = &isoir165ext_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = isoir165ext_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 46,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/java.h": {
    "java_mbtowc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static int\njava_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c;\n  ucs4_t wc, wc2;\n  int i;\n\n  c = s[0];\n  if (c != '\\\\') {\n    *pwc = c;\n    return 1;\n  }\n  if (n < 2)\n    return RET_TOOFEW(0);\n  if (s[1] != 'u')\n    goto simply_backslash;\n  wc = 0;\n  for (i = 2; i < 6; i++) {\n    if (n <= i)\n      return RET_TOOFEW(0);\n    c = s[i];\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'A' && c <= 'Z')\n      c -= 'A'-10;\n    else if (c >= 'a' && c <= 'z')\n      c -= 'a'-10;\n    else\n      goto simply_backslash;\n    wc |= (ucs4_t) c << (4 * (5-i));\n  }\n  if (!(wc >= 0xd800 && wc < 0xe000)) {\n    *pwc = wc;\n    return 6;\n  }\n  if (wc >= 0xdc00)\n    goto simply_backslash;\n  if (n < 7)\n    return RET_TOOFEW(0);\n  if (s[6] != '\\\\')\n    goto simply_backslash;\n  if (n < 8)\n    return RET_TOOFEW(0);\n  if (s[7] != 'u')\n    goto simply_backslash;\n  wc2 = 0;\n  for (i = 8; i < 12; i++) {\n    if (n <= i)\n      return RET_TOOFEW(0);\n    c = s[i];\n    if (c >= '0' && c <= '9')\n      c -= '0';\n    else if (c >= 'A' && c <= 'Z')\n      c -= 'A'-10;\n    else if (c >= 'a' && c <= 'z')\n      c -= 'a'-10;\n    else\n      goto simply_backslash;\n    wc2 |= (ucs4_t) c << (4 * (11-i));\n  }\n  if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n    goto simply_backslash;\n  *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n  return 12;\nsimply_backslash:\n  *pwc = '\\\\';\n  return 1;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "java_wctomb": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\njava_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x80) {\n    *r = wc;\n    return 1;\n  } else if (wc < 0x10000) {\n    if (n >= 6) {\n      unsigned int i;\n      r[0] = '\\\\';\n      r[1] = 'u';\n      i = (wc >> 12) & 0x0f; r[2] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc >> 8) & 0x0f;  r[3] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc >> 4) & 0x0f;  r[4] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = wc & 0x0f;         r[5] = (i < 10 ? '0'+i : 'a'-10+i);\n      return 6;\n    } else\n      return RET_TOOSMALL;\n  } else if (wc < 0x110000) {\n    if (n >= 12) {\n      ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n      ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n      unsigned int i;\n      r[0] = '\\\\';\n      r[1] = 'u';\n      i = (wc1 >> 12) & 0x0f; r[2] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc1 >> 8) & 0x0f;  r[3] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc1 >> 4) & 0x0f;  r[4] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = wc1 & 0x0f;         r[5] = (i < 10 ? '0'+i : 'a'-10+i);\n      r[6] = '\\\\';\n      r[7] = 'u';\n      i = (wc2 >> 12) & 0x0f; r[8] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc2 >> 8) & 0x0f;  r[9] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = (wc2 >> 4) & 0x0f; r[10] = (i < 10 ? '0'+i : 'a'-10+i);\n      i = wc2 & 0x0f;        r[11] = (i < 10 ? '0'+i : 'a'-10+i);\n      return 12;\n    } else\n      return RET_TOOSMALL;\n  }\n  return RET_ILUNI;\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/jisx0201.h": {
    "jisx0201_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static int\njisx0201_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    if (c == 0x5c)\n      *pwc = (ucs4_t) 0x00a5;\n    else if (c == 0x7e)\n      *pwc = (ucs4_t) 0x203e;\n    else\n      *pwc = (ucs4_t) c;\n    return 1;\n  } else {\n    if (c >= 0xa1 && c < 0xe0) {\n      *pwc = (ucs4_t) c + 0xfec0;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "jisx0201_wctomb": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\njisx0201_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0080 && !(wc == 0x005c || wc == 0x007e)) {\n    *r = wc;\n    return 1;\n  }\n  if (wc == 0x00a5) {\n    *r = 0x5c;\n    return 1;\n  }\n  if (wc == 0x203e) {\n    *r = 0x7e;\n    return 1;\n  }\n  if (wc >= 0xff61 && wc < 0xffa0) {\n    *r = wc - 0xfec0;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/jisx0208.h": {
    "jisx0208_mbtowc": {
      "start_point": [
        1010,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "static int\njisx0208_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x28) || (c1 >= 0x30 && c1 <= 0x74)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 1410) {\n          if (i < 690)\n            wc = jisx0208_2uni_page21[i];\n        } else {\n          if (i < 7808)\n            wc = jisx0208_2uni_page30[i-1410];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "jisx0208_wctomb": {
      "start_point": [
        2374,
        0
      ],
      "end_point": [
        2413,
        1
      ],
      "content": "static int\njisx0208_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0100)\n      summary = &jisx0208_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x0300 && wc < 0x0460)\n      summary = &jisx0208_uni2indx_page03[(wc>>4)-0x030];\n    else if (wc >= 0x2000 && wc < 0x2320)\n      summary = &jisx0208_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x2500 && wc < 0x2670)\n      summary = &jisx0208_uni2indx_page25[(wc>>4)-0x250];\n    else if (wc >= 0x3000 && wc < 0x3100)\n      summary = &jisx0208_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x4e00 && wc < 0x9fb0)\n      summary = &jisx0208_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xff00 && wc < 0xfff0)\n      summary = &jisx0208_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = jisx0208_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 40,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/jisx0212.h": {
    "jisx0212_mbtowc": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        944,
        1
      ],
      "content": "static int\njisx0212_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 == 0x22) || (c1 >= 0x26 && c1 <= 0x27) || (c1 >= 0x29 && c1 <= 0x2b) || (c1 >= 0x30 && c1 <= 0x6d)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 470) {\n          if (i < 175)\n            wc = jisx0212_2uni_page22[i-94];\n        } else if (i < 752) {\n          if (i < 658)\n            wc = jisx0212_2uni_page26[i-470];\n        } else if (i < 1410) {\n          if (i < 1027)\n            wc = jisx0212_2uni_page29[i-752];\n        } else {\n          if (i < 7211)\n            wc = jisx0212_2uni_page30[i-1410];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 34,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "jisx0212_wctomb": {
      "start_point": [
        2154,
        0
      ],
      "end_point": [
        2187,
        1
      ],
      "content": "static int\njisx0212_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0460)\n      summary = &jisx0212_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x2100 && wc < 0x2130)\n      summary = &jisx0212_uni2indx_page21[(wc>>4)-0x210];\n    else if (wc >= 0x4e00 && wc < 0x9fb0)\n      summary = &jisx0212_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xff00 && wc < 0xff60)\n      summary = &jisx0212_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = jisx0212_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 34,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/jisx0213.h": {
    "jisx0213_to_ucs4": {
      "start_point": [
        5861,
        0
      ],
      "end_point": [
        5890,
        1
      ],
      "content": "static ucs4_t jisx0213_to_ucs4 (unsigned int row, unsigned int col)\n{\n  ucs4_t val;\n\n  if (row >= 0x121 && row <= 0x17e)\n    row -= 289;\n  else if (row == 0x221)\n    row -= 451;\n  else if (row >= 0x223 && row <= 0x225)\n    row -= 452;\n  else if (row == 0x228)\n    row -= 454;\n  else if (row >= 0x22c && row <= 0x22f)\n    row -= 457;\n  else if (row >= 0x26e && row <= 0x27e)\n    row -= 519;\n  else\n    return 0x0000;\n\n  if (col >= 0x21 && col <= 0x7e)\n    col -= 0x21;\n  else\n    return 0x0000;\n\n  val = jisx0213_to_ucs_main[row * 94 + col];\n  val = jisx0213_to_ucs_pagestart[val >> 8] + (val & 0xff);\n  if (val == 0xfffd)\n    val = 0x0000;\n  return val;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ucs4_t"
      ]
    },
    "ucs4_to_jisx0213": {
      "start_point": [
        5899,
        0
      ],
      "end_point": [
        5920,
        1
      ],
      "content": "static unsigned short ucs4_to_jisx0213 (ucs4_t ucs)\n{\n  if (ucs < (sizeof(jisx0213_from_ucs_level1)/sizeof(jisx0213_from_ucs_level1[0])) << 6) {\n    int index1 = jisx0213_from_ucs_level1[ucs >> 6];\n    if (index1 >= 0) {\n      const Summary16 *summary = &jisx0213_from_ucs_level2_2indx[((index1 << 6) + (ucs & 0x3f)) >> 4];\n      unsigned short used = summary->used;\n      unsigned int i = ucs & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        return jisx0213_from_ucs_level2_data[summary->indx + used];\n      };\n    };\n  }\n  return 0x0000;\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "unsigned short",
        "unsigned",
        "short"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/johab.h": {
    "johab_mbtowc": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static int\njohab_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    if (c == 0x5c)\n      *pwc = (ucs4_t) 0x20a9;\n    else\n      *pwc = (ucs4_t) c;\n    return 1;\n  } else if (c < 0xd8) {\n    return johab_hangul_mbtowc(conv,pwc,s,n);\n  } else {\n    unsigned char s1, s2;\n    s1 = c;\n    if ((s1 >= 0xd9 && s1 <= 0xde) || (s1 >= 0xe0 && s1 <= 0xf9)) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      s2 = s[1];\n      if ((s2 >= 0x31 && s2 <= 0x7e) || (s2 >= 0x91 && s2 <= 0xfe)) {\n        /* In KSC 5601, now KS X 1001, the region s1 = 0xDA, 0xA1 <= s2 <= 0xD3\n           contains the 51 Jamo (Hangul letters). But in the Johab encoding,\n           they have been moved to the Hangul section, see\n           johab_hangul_page31. */\n        if (!(s1 == 0xda && (s2 >= 0xa1 && s2 <= 0xd3))) {\n          unsigned char t1 = (s1 < 0xe0 ? 2*(s1-0xd9) : 2*s1-0x197);\n          unsigned char t2 = (s2 < 0x91 ? s2-0x31 : s2-0x43);\n          unsigned char buf[2];\n          buf[0] = t1 + (t2 < 0x5e ? 0 : 1) + 0x21;\n          buf[1] = (t2 < 0x5e ? t2 : t2-0x5e) + 0x21;\n          return ksc5601_mbtowc(conv,pwc,buf,2);\n        }\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 37,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "johab_wctomb": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\njohab_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Try ASCII variation. */\n  if (wc < 0x0080 && wc != 0x005c) {\n    *r = wc;\n    return 1;\n  }\n  if (wc == 0x20a9) {\n    *r = 0x5c;\n    return 1;\n  }\n\n  /* Try JOHAB Hangul table before KSC5601 table, because the KSC5601 table\n     contains some (2350 out of 11172) Hangul syllables (rows 0x30XX..0x48XX),\n     and we want the search to return the JOHAB Hangul table entry. */\n\n  /* Try JOHAB Hangul. */\n  ret = johab_hangul_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = buf[0];\n    r[1] = buf[1];\n    return 2;\n  }\n\n  /* Try KSC5601, now KS X 1001. */\n  ret = ksc5601_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    unsigned char c1, c2;\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    c1 = buf[0];\n    c2 = buf[1];\n    if (((c1 >= 0x21 && c1 <= 0x2c) || (c1 >= 0x4a && c1 <= 0x7d))\n        && (c2 >= 0x21 && c2 <= 0x7e)) {\n      unsigned int t = (c1 < 0x4A ? (c1-0x21+0x1B2) : (c1-0x21+0x197));\n      unsigned char t2 = ((t & 1) ? 0x5e : 0) + (c2 - 0x21);\n      r[0] = t >> 1;\n      r[1] = (t2 < 0x4e ? t2+0x31 : t2+0x43);\n      return 2;\n    }\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/johab_hangul.h": {
    "johab_hangul_mbtowc": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static int\njohab_hangul_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x84 && c1 <= 0xd3)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x41 && c2 < 0x7f) || (c2 >= 0x81 && c2 < 0xff)) {\n        unsigned int johab = (c1 << 8) | c2;\n        unsigned int bitspart1 = (johab >> 10) & 31;\n        unsigned int bitspart2 = (johab >> 5) & 31;\n        unsigned int bitspart3 = johab & 31;\n        int index1 = jamo_initial_index[bitspart1];\n        int index2 = jamo_medial_index[bitspart2];\n        int index3 = jamo_final_index[bitspart3];\n        /* Exclude \"none\" values. */\n        if (index1 >= 0 && index2 >= 0 && index3 >= 0) {\n          /* Deal with \"fill\" values in initial or medial position. */\n          if (index1 == fill) {\n            if (index2 == fill) {\n              unsigned char jamo3 = jamo_final_notinitial[bitspart3];\n              if (jamo3 != NONE) {\n                *pwc = (ucs4_t) 0x3130 + jamo3;\n                return 2;\n              }\n            } else if (index3 == fill) {\n              unsigned char jamo2 = jamo_medial[bitspart2];\n              if (jamo2 != NONE && jamo2 != FILL) {\n                *pwc = (ucs4_t) 0x3130 + jamo2;\n                return 2;\n              }\n            }\n            /* Syllables composed only of medial and final don't exist. */\n          } else if (index2 == fill) {\n            if (index3 == fill) {\n              unsigned char jamo1 = jamo_initial[bitspart1];\n              if (jamo1 != NONE && jamo1 != FILL) {\n                *pwc = (ucs4_t) 0x3130 + jamo1;\n                return 2;\n              }\n            }\n            /* Syllables composed only of initial and final don't exist. */\n          } else {\n             /* index1 and index2 are not fill, but index3 may be fill. */\n             /* Nothing more to exclude. All 11172 code points are valid. */\n             *pwc = 0xac00 + ((index1 - 1) * 21 + (index2 - 1)) * 28 + index3;\n             return 2;\n          }\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 56,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "johab_hangul_wctomb": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static int\njohab_hangul_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    if (wc >= 0x3131 && wc < 0x3164) {\n      unsigned short c = johab_hangul_page31[wc-0x3131];\n      r[0] = (c >> 8); r[1] = (c & 0xff);\n      return 2;\n    } else if (wc >= 0xac00 && wc < 0xd7a4) {\n      unsigned int index1;\n      unsigned int index2;\n      unsigned int index3;\n      unsigned short c;\n      unsigned int tmp = wc - 0xac00;\n      index3 = tmp % 28; tmp = tmp / 28;\n      index2 = tmp % 21; tmp = tmp / 21;\n      index1 = tmp;\n      c = (((((1 << 5)\n              | jamo_initial_index_inverse[index1]) << 5)\n            | jamo_medial_index_inverse[index2]) << 5)\n          | jamo_final_index_inverse[index3];\n      r[0] = (c >> 8); r[1] = (c & 0xff);\n      return 2;\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 28,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "johab_hangul_decompose": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static int johab_hangul_decompose (conv_t conv, ucs4_t* r, ucs4_t wc)\n{\n  unsigned char buf[2];\n  int ret = johab_hangul_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    unsigned int hangul = (buf[0] << 8) | buf[1];\n    unsigned char jamo1 = jamo_initial[(hangul >> 10) & 31];\n    unsigned char jamo2 = jamo_medial[(hangul >> 5) & 31];\n    unsigned char jamo3 = jamo_final[hangul & 31];\n    if ((hangul >> 15) != 1) abort();\n    if (jamo1 != NONE && jamo2 != NONE && jamo3 != NONE) {\n      /* They are not all three == FILL because that would correspond to\n         johab = 0x8441, which doesn't exist. */\n      ucs4_t* p = r;\n      if (jamo1 != FILL)\n        *p++ = 0x3130 + jamo1;\n      if (jamo2 != FILL)\n        *p++ = 0x3130 + jamo2;\n      if (jamo3 != FILL)\n        *p++ = 0x3130 + jamo3;\n      return p-r;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/koi8_r.h": {
    "koi8_r_mbtowc": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nkoi8_r_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) koi8_r_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "koi8_r_wctomb": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\nkoi8_r_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = koi8_r_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0458)\n    c = koi8_r_page04[wc-0x0400];\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = koi8_r_page22[wc-0x2218];\n  else if (wc >= 0x2320 && wc < 0x2328)\n    c = koi8_r_page23[wc-0x2320];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = koi8_r_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/koi8_ru.h": {
    "koi8_ru_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nkoi8_ru_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) koi8_ru_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "koi8_ru_wctomb": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static int\nkoi8_ru_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = koi8_ru_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = koi8_ru_page04[wc-0x0400];\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = koi8_ru_page22[wc-0x2218];\n  else if (wc >= 0x2320 && wc < 0x2328)\n    c = koi8_ru_page23[wc-0x2320];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = koi8_ru_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/koi8_t.h": {
    "koi8_t_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nkoi8_t_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = koi8_t_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "koi8_t_wctomb": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nkoi8_t_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = koi8_t_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x04f0)\n    c = koi8_t_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = koi8_t_page20[wc-0x2010];\n  else if (wc >= 0x2110 && wc < 0x2128)\n    c = koi8_t_page21[wc-0x2110];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/koi8_u.h": {
    "koi8_u_mbtowc": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static int\nkoi8_u_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) koi8_u_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "koi8_u_wctomb": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\nkoi8_u_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00f8)\n    c = koi8_u_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = koi8_u_page04[wc-0x0400];\n  else if (wc >= 0x2218 && wc < 0x2268)\n    c = koi8_u_page22[wc-0x2218];\n  else if (wc >= 0x2320 && wc < 0x2328)\n    c = koi8_u_page23[wc-0x2320];\n  else if (wc >= 0x2500 && wc < 0x25a8)\n    c = koi8_u_page25[wc-0x2500];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ksc5601.h": {
    "ksc5601_mbtowc": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1216,
        1
      ],
      "content": "static int\nksc5601_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x21 && c1 <= 0x2c) || (c1 >= 0x30 && c1 <= 0x48) || (c1 >= 0x4a && c1 <= 0x7d)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if (c2 >= 0x21 && c2 < 0x7f) {\n        unsigned int i = 94 * (c1 - 0x21) + (c2 - 0x21);\n        unsigned short wc = 0xfffd;\n        if (i < 1410) {\n          if (i < 1115)\n            wc = ksc5601_2uni_page21[i];\n        } else if (i < 3854) {\n          if (i < 3760)\n            wc = ksc5601_2uni_page30[i-1410];\n        } else {\n          if (i < 8742)\n            wc = ksc5601_2uni_page4a[i-3854];\n        }\n        if (wc != 0xfffd) {\n          *pwc = (ucs4_t) wc;\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 31,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ksc5601_wctomb": {
      "start_point": [
        2981,
        0
      ],
      "end_point": [
        3020,
        1
      ],
      "content": "static int\nksc5601_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    const Summary16 *summary = NULL;\n    if (wc >= 0x0000 && wc < 0x0460)\n      summary = &ksc5601_uni2indx_page00[(wc>>4)];\n    else if (wc >= 0x2000 && wc < 0x2670)\n      summary = &ksc5601_uni2indx_page20[(wc>>4)-0x200];\n    else if (wc >= 0x3000 && wc < 0x33e0)\n      summary = &ksc5601_uni2indx_page30[(wc>>4)-0x300];\n    else if (wc >= 0x4e00 && wc < 0x9fa0)\n      summary = &ksc5601_uni2indx_page4e[(wc>>4)-0x4e0];\n    else if (wc >= 0xac00 && wc < 0xd7a0)\n      summary = &ksc5601_uni2indx_pageac[(wc>>4)-0xac0];\n    else if (wc >= 0xf900 && wc < 0xfa10)\n      summary = &ksc5601_uni2indx_pagef9[(wc>>4)-0xf90];\n    else if (wc >= 0xff00 && wc < 0xfff0)\n      summary = &ksc5601_uni2indx_pageff[(wc>>4)-0xff0];\n    if (summary) {\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        c = ksc5601_2charset[summary->indx + used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 40,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/loops.h": {},
  "libiconv/libiconv-1.15/lib/loop_unicode.h": {
    "unicode_transliterate": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int unicode_transliterate (conv_t cd, ucs4_t wc,\n                                  unsigned char* outptr, size_t outleft)\n{\n  if (cd->oflags & HAVE_HANGUL_JAMO) {\n    /* Decompose Hangul into Jamo. Use double-width Jamo (contained\n       in all Korean encodings and ISO-2022-JP-2), not half-width Jamo\n       (contained in Unicode only). */\n    ucs4_t buf[3];\n    int ret = johab_hangul_decompose(cd,buf,wc);\n    if (ret != RET_ILUNI) {\n      /* we know 1 <= ret <= 3 */\n      state_t backup_state = cd->ostate;\n      unsigned char* backup_outptr = outptr;\n      size_t backup_outleft = outleft;\n      int i, sub_outcount;\n      for (i = 0; i < ret; i++) {\n        if (outleft == 0) {\n          sub_outcount = RET_TOOSMALL;\n          goto johab_hangul_failed;\n        }\n        sub_outcount = cd->ofuncs.xxx_wctomb(cd,outptr,buf[i],outleft);\n        if (sub_outcount <= RET_ILUNI)\n          goto johab_hangul_failed;\n        if (!(sub_outcount <= outleft)) abort();\n        outptr += sub_outcount; outleft -= sub_outcount;\n      }\n      return outptr-backup_outptr;\n    johab_hangul_failed:\n      cd->ostate = backup_state;\n      outptr = backup_outptr;\n      outleft = backup_outleft;\n      if (sub_outcount != RET_ILUNI)\n        return RET_TOOSMALL;\n    }\n  }\n  {\n    /* Try to use a variant, but postfix it with\n       U+303E IDEOGRAPHIC VARIATION INDICATOR\n       (cf. Ken Lunde's \"CJKV information processing\", p. 188). */\n    int indx = -1;\n    if (wc == 0x3006)\n      indx = 0;\n    else if (wc == 0x30f6)\n      indx = 1;\n    else if (wc >= 0x4e00 && wc < 0xa000)\n      indx = cjk_variants_indx[wc-0x4e00];\n    if (indx >= 0) {\n      for (;; indx++) {\n        ucs4_t buf[2];\n        unsigned short variant = cjk_variants[indx];\n        unsigned short last = variant & 0x8000;\n        variant &= 0x7fff;\n        variant += 0x3000;\n        buf[0] = variant; buf[1] = 0x303e;\n        {\n          state_t backup_state = cd->ostate;\n          unsigned char* backup_outptr = outptr;\n          size_t backup_outleft = outleft;\n          int i, sub_outcount;\n          for (i = 0; i < 2; i++) {\n            if (outleft == 0) {\n              sub_outcount = RET_TOOSMALL;\n              goto variant_failed;\n            }\n            sub_outcount = cd->ofuncs.xxx_wctomb(cd,outptr,buf[i],outleft);\n            if (sub_outcount <= RET_ILUNI)\n              goto variant_failed;\n            if (!(sub_outcount <= outleft)) abort();\n            outptr += sub_outcount; outleft -= sub_outcount;\n          }\n          return outptr-backup_outptr;\n        variant_failed:\n          cd->ostate = backup_state;\n          outptr = backup_outptr;\n          outleft = backup_outleft;\n          if (sub_outcount != RET_ILUNI)\n            return RET_TOOSMALL;\n        }\n        if (last)\n          break;\n      }\n    }\n  }\n  if (wc >= 0x2018 && wc <= 0x201a) {\n    /* Special case for quotation marks 0x2018, 0x2019, 0x201a */\n    ucs4_t substitute =\n      (cd->oflags & HAVE_QUOTATION_MARKS\n       ? (wc == 0x201a ? 0x2018 : wc)\n       : (cd->oflags & HAVE_ACCENTS\n          ? (wc==0x2019 ? 0x00b4 : 0x0060) /* use accents */\n          : 0x0027 /* use apostrophe */\n      )  );\n    int outcount = cd->ofuncs.xxx_wctomb(cd,outptr,substitute,outleft);\n    if (outcount != RET_ILUNI)\n      return outcount;\n  }\n  {\n    /* Use the transliteration table. */\n    int indx = translit_index(wc);\n    if (indx >= 0) {\n      const unsigned int * cp = &translit_data[indx];\n      unsigned int num = *cp++;\n      state_t backup_state = cd->ostate;\n      unsigned char* backup_outptr = outptr;\n      size_t backup_outleft = outleft;\n      unsigned int i;\n      int sub_outcount;\n      for (i = 0; i < num; i++) {\n        if (outleft == 0) {\n          sub_outcount = RET_TOOSMALL;\n          goto translit_failed;\n        }\n        sub_outcount = cd->ofuncs.xxx_wctomb(cd,outptr,cp[i],outleft);\n        if (sub_outcount == RET_ILUNI)\n          /* Recursive transliteration. */\n          sub_outcount = unicode_transliterate(cd,cp[i],outptr,outleft);\n        if (sub_outcount <= RET_ILUNI)\n          goto translit_failed;\n        if (!(sub_outcount <= outleft)) abort();\n        outptr += sub_outcount; outleft -= sub_outcount;\n      }\n      return outptr-backup_outptr;\n    translit_failed:\n      cd->ostate = backup_state;\n      outptr = backup_outptr;\n      outleft = backup_outleft;\n      if (sub_outcount != RET_ILUNI)\n        return RET_TOOSMALL;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 132,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "uc_to_mb_write_replacement": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static void uc_to_mb_write_replacement (const char *buf, size_t buflen,\n                                        void* callback_arg)\n{\n  struct uc_to_mb_fallback_locals * plocals =\n    (struct uc_to_mb_fallback_locals *) callback_arg;\n  /* Do nothing if already encountered an error in a previous call. */\n  if (plocals->l_errno == 0) {\n    /* Attempt to copy the passed buffer to the output buffer. */\n    if (plocals->l_outbytesleft < buflen)\n      plocals->l_errno = E2BIG;\n    else {\n      memcpy(plocals->l_outbuf, buf, buflen);\n      plocals->l_outbuf += buflen;\n      plocals->l_outbytesleft -= buflen;\n    }\n  }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mb_to_uc_write_replacement": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void mb_to_uc_write_replacement (const unsigned int *buf, size_t buflen,\n                                        void* callback_arg)\n{\n  struct mb_to_uc_fallback_locals * plocals =\n    (struct mb_to_uc_fallback_locals *) callback_arg;\n  /* Do nothing if already encountered an error in a previous call. */\n  if (plocals->l_errno == 0) {\n    /* Attempt to convert the passed buffer to the target encoding. */\n    conv_t cd = plocals->l_cd;\n    unsigned char* outptr = plocals->l_outbuf;\n    size_t outleft = plocals->l_outbytesleft;\n    for (; buflen > 0; buf++, buflen--) {\n      ucs4_t wc = *buf;\n      int outcount;\n      if (outleft == 0) {\n        plocals->l_errno = E2BIG;\n        break;\n      }\n      outcount = cd->ofuncs.xxx_wctomb(cd,outptr,wc,outleft);\n      if (outcount != RET_ILUNI)\n        goto outcount_ok;\n      /* Handle Unicode tag characters (range U+E0000..U+E007F). */\n      if ((wc >> 7) == (0xe0000 >> 7))\n        goto outcount_zero;\n      /* Try transliteration. */\n      if (cd->transliterate) {\n        outcount = unicode_transliterate(cd,wc,outptr,outleft);\n        if (outcount != RET_ILUNI)\n          goto outcount_ok;\n      }\n      if (cd->discard_ilseq) {\n        outcount = 0;\n        goto outcount_ok;\n      }\n      #ifndef LIBICONV_PLUG\n      else if (cd->fallbacks.uc_to_mb_fallback != NULL) {\n        struct uc_to_mb_fallback_locals locals;\n        locals.l_outbuf = outptr;\n        locals.l_outbytesleft = outleft;\n        locals.l_errno = 0;\n        cd->fallbacks.uc_to_mb_fallback(wc,\n                                        uc_to_mb_write_replacement,\n                                        &locals,\n                                        cd->fallbacks.data);\n        if (locals.l_errno != 0) {\n          plocals->l_errno = locals.l_errno;\n          break;\n        }\n        outptr = locals.l_outbuf;\n        outleft = locals.l_outbytesleft;\n        outcount = 0;\n        goto outcount_ok;\n      }\n      #endif\n      outcount = cd->ofuncs.xxx_wctomb(cd,outptr,0xFFFD,outleft);\n      if (outcount != RET_ILUNI)\n        goto outcount_ok;\n      plocals->l_errno = EILSEQ;\n      break;\n    outcount_ok:\n      if (outcount < 0) {\n        plocals->l_errno = E2BIG;\n        break;\n      }\n      #ifndef LIBICONV_PLUG\n      if (cd->hooks.uc_hook)\n        (*cd->hooks.uc_hook)(wc, cd->hooks.data);\n      #endif\n      if (!(outcount <= outleft)) abort();\n      outptr += outcount; outleft -= outcount;\n    outcount_zero: ;\n    }\n    plocals->l_outbuf = outptr;\n    plocals->l_outbytesleft = outleft;\n  }\n}",
      "lines": 76,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unicode_loop_convert": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "static size_t unicode_loop_convert (iconv_t icd,\n                                    const char* * inbuf, size_t *inbytesleft,\n                                    char* * outbuf, size_t *outbytesleft)\n{\n  conv_t cd = (conv_t) icd;\n  size_t result = 0;\n  const unsigned char* inptr = (const unsigned char*) *inbuf;\n  size_t inleft = *inbytesleft;\n  unsigned char* outptr = (unsigned char*) *outbuf;\n  size_t outleft = *outbytesleft;\n  while (inleft > 0) {\n    state_t last_istate = cd->istate;\n    ucs4_t wc;\n    int incount;\n    int outcount;\n    incount = cd->ifuncs.xxx_mbtowc(cd,&wc,inptr,inleft);\n    if (incount < 0) {\n      if ((unsigned int)(-1-incount) % 2 == (unsigned int)(-1-RET_ILSEQ) % 2) {\n        /* Case 1: invalid input, possibly after a shift sequence */\n        incount = DECODE_SHIFT_ILSEQ(incount);\n        if (cd->discard_ilseq) {\n          switch (cd->iindex) {\n            case ei_ucs4: case ei_ucs4be: case ei_ucs4le:\n            case ei_utf32: case ei_utf32be: case ei_utf32le:\n            case ei_ucs4internal: case ei_ucs4swapped:\n              incount += 4; break;\n            case ei_ucs2: case ei_ucs2be: case ei_ucs2le:\n            case ei_utf16: case ei_utf16be: case ei_utf16le:\n            case ei_ucs2internal: case ei_ucs2swapped:\n              incount += 2; break;\n            default:\n              incount += 1; break;\n          }\n          goto outcount_zero;\n        }\n        #ifndef LIBICONV_PLUG\n        else if (cd->fallbacks.mb_to_uc_fallback != NULL) {\n          unsigned int incount2;\n          struct mb_to_uc_fallback_locals locals;\n          switch (cd->iindex) {\n            case ei_ucs4: case ei_ucs4be: case ei_ucs4le:\n            case ei_utf32: case ei_utf32be: case ei_utf32le:\n            case ei_ucs4internal: case ei_ucs4swapped:\n              incount2 = 4; break;\n            case ei_ucs2: case ei_ucs2be: case ei_ucs2le:\n            case ei_utf16: case ei_utf16be: case ei_utf16le:\n            case ei_ucs2internal: case ei_ucs2swapped:\n              incount2 = 2; break;\n            default:\n              incount2 = 1; break;\n          }\n          locals.l_cd = cd;\n          locals.l_outbuf = outptr;\n          locals.l_outbytesleft = outleft;\n          locals.l_errno = 0;\n          cd->fallbacks.mb_to_uc_fallback((const char*)inptr+incount, incount2,\n                                          mb_to_uc_write_replacement,\n                                          &locals,\n                                          cd->fallbacks.data);\n          if (locals.l_errno != 0) {\n            inptr += incount; inleft -= incount;\n            errno = locals.l_errno;\n            result = -1;\n            break;\n          }\n          incount += incount2;\n          outptr = locals.l_outbuf;\n          outleft = locals.l_outbytesleft;\n          result += 1;\n          goto outcount_zero;\n        }\n        #endif\n        inptr += incount; inleft -= incount;\n        errno = EILSEQ;\n        result = -1;\n        break;\n      }\n      if (incount == RET_TOOFEW(0)) {\n        /* Case 2: not enough bytes available to detect anything */\n        errno = EINVAL;\n        result = -1;\n        break;\n      }\n      /* Case 3: k bytes read, but only a shift sequence */\n      incount = DECODE_TOOFEW(incount);\n    } else {\n      /* Case 4: k bytes read, making up a wide character */\n      if (outleft == 0) {\n        cd->istate = last_istate;\n        errno = E2BIG;\n        result = -1;\n        break;\n      }\n      outcount = cd->ofuncs.xxx_wctomb(cd,outptr,wc,outleft);\n      if (outcount != RET_ILUNI)\n        goto outcount_ok;\n      /* Handle Unicode tag characters (range U+E0000..U+E007F). */\n      if ((wc >> 7) == (0xe0000 >> 7))\n        goto outcount_zero;\n      /* Try transliteration. */\n      result++;\n      if (cd->transliterate) {\n        outcount = unicode_transliterate(cd,wc,outptr,outleft);\n        if (outcount != RET_ILUNI)\n          goto outcount_ok;\n      }\n      if (cd->discard_ilseq) {\n        outcount = 0;\n        goto outcount_ok;\n      }\n      #ifndef LIBICONV_PLUG\n      else if (cd->fallbacks.uc_to_mb_fallback != NULL) {\n        struct uc_to_mb_fallback_locals locals;\n        locals.l_outbuf = outptr;\n        locals.l_outbytesleft = outleft;\n        locals.l_errno = 0;\n        cd->fallbacks.uc_to_mb_fallback(wc,\n                                        uc_to_mb_write_replacement,\n                                        &locals,\n                                        cd->fallbacks.data);\n        if (locals.l_errno != 0) {\n          cd->istate = last_istate;\n          errno = locals.l_errno;\n          return -1;\n        }\n        outptr = locals.l_outbuf;\n        outleft = locals.l_outbytesleft;\n        outcount = 0;\n        goto outcount_ok;\n      }\n      #endif\n      outcount = cd->ofuncs.xxx_wctomb(cd,outptr,0xFFFD,outleft);\n      if (outcount != RET_ILUNI)\n        goto outcount_ok;\n      cd->istate = last_istate;\n      errno = EILSEQ;\n      result = -1;\n      break;\n    outcount_ok:\n      if (outcount < 0) {\n        cd->istate = last_istate;\n        errno = E2BIG;\n        result = -1;\n        break;\n      }\n      #ifndef LIBICONV_PLUG\n      if (cd->hooks.uc_hook)\n        (*cd->hooks.uc_hook)(wc, cd->hooks.data);\n      #endif\n      if (!(outcount <= outleft)) abort();\n      outptr += outcount; outleft -= outcount;\n    }\n  outcount_zero:\n    if (!(incount <= inleft)) abort();\n    inptr += incount; inleft -= incount;\n  }\n  *inbuf = (const char*) inptr;\n  *inbytesleft = inleft;\n  *outbuf = (char*) outptr;\n  *outbytesleft = outleft;\n  return result;\n}",
      "lines": 162,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "unicode_loop_reset": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static size_t unicode_loop_reset (iconv_t icd,\n                                  char* * outbuf, size_t *outbytesleft)\n{\n  conv_t cd = (conv_t) icd;\n  if (outbuf == NULL || *outbuf == NULL) {\n    /* Reset the states. */\n    memset(&cd->istate,'\\0',sizeof(state_t));\n    memset(&cd->ostate,'\\0',sizeof(state_t));\n    return 0;\n  } else {\n    size_t result = 0;\n    if (cd->ifuncs.xxx_flushwc) {\n      state_t last_istate = cd->istate;\n      ucs4_t wc;\n      if (cd->ifuncs.xxx_flushwc(cd, &wc)) {\n        unsigned char* outptr = (unsigned char*) *outbuf;\n        size_t outleft = *outbytesleft;\n        int outcount = cd->ofuncs.xxx_wctomb(cd,outptr,wc,outleft);\n        if (outcount != RET_ILUNI)\n          goto outcount_ok;\n        /* Handle Unicode tag characters (range U+E0000..U+E007F). */\n        if ((wc >> 7) == (0xe0000 >> 7))\n          goto outcount_zero;\n        /* Try transliteration. */\n        result++;\n        if (cd->transliterate) {\n          outcount = unicode_transliterate(cd,wc,outptr,outleft);\n          if (outcount != RET_ILUNI)\n            goto outcount_ok;\n        }\n        if (cd->discard_ilseq) {\n          outcount = 0;\n          goto outcount_ok;\n        }\n        #ifndef LIBICONV_PLUG\n        else if (cd->fallbacks.uc_to_mb_fallback != NULL) {\n          struct uc_to_mb_fallback_locals locals;\n          locals.l_outbuf = outptr;\n          locals.l_outbytesleft = outleft;\n          locals.l_errno = 0;\n          cd->fallbacks.uc_to_mb_fallback(wc,\n                                          uc_to_mb_write_replacement,\n                                          &locals,\n                                          cd->fallbacks.data);\n          if (locals.l_errno != 0) {\n            cd->istate = last_istate;\n            errno = locals.l_errno;\n            return -1;\n          }\n          outptr = locals.l_outbuf;\n          outleft = locals.l_outbytesleft;\n          outcount = 0;\n          goto outcount_ok;\n        }\n        #endif\n        outcount = cd->ofuncs.xxx_wctomb(cd,outptr,0xFFFD,outleft);\n        if (outcount != RET_ILUNI)\n          goto outcount_ok;\n        cd->istate = last_istate;\n        errno = EILSEQ;\n        return -1;\n      outcount_ok:\n        if (outcount < 0) {\n          cd->istate = last_istate;\n          errno = E2BIG;\n          return -1;\n        }\n        #ifndef LIBICONV_PLUG\n        if (cd->hooks.uc_hook)\n          (*cd->hooks.uc_hook)(wc, cd->hooks.data);\n        #endif\n        if (!(outcount <= outleft)) abort();\n        outptr += outcount;\n        outleft -= outcount;\n      outcount_zero:\n        *outbuf = (char*) outptr;\n        *outbytesleft = outleft;\n      }\n    }\n    if (cd->ofuncs.xxx_reset) {\n      unsigned char* outptr = (unsigned char*) *outbuf;\n      size_t outleft = *outbytesleft;\n      int outcount = cd->ofuncs.xxx_reset(cd,outptr,outleft);\n      if (outcount < 0) {\n        errno = E2BIG;\n        return -1;\n      }\n      if (!(outcount <= outleft)) abort();\n      *outbuf = (char*) (outptr + outcount);\n      *outbytesleft = outleft - outcount;\n    }\n    memset(&cd->istate,'\\0',sizeof(state_t));\n    memset(&cd->ostate,'\\0',sizeof(state_t));\n    return result;\n  }\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/loop_wchar.h": {
    "wc_to_mb_write_replacement": [
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "static void wc_to_mb_write_replacement (const char *buf, size_t buflen,\n                                        void* callback_arg)\n{\n  struct wc_to_mb_fallback_locals * plocals =\n    (struct wc_to_mb_fallback_locals *) callback_arg;\n  /* Do nothing if already encountered an error in a previous call. */\n  if (plocals->l_errno == 0) {\n    /* Attempt to convert the passed buffer to the target encoding.\n       Here we don't support characters split across multiple calls. */\n    const char* bufptr = buf;\n    size_t bufleft = buflen;\n    size_t res = unicode_loop_convert(&plocals->l_wcd->parent,\n                                      &bufptr,&bufleft,\n                                      &plocals->l_outbuf,&plocals->l_outbytesleft);\n    if (res == (size_t)(-1)) {\n      if (errno == EILSEQ || errno == EINVAL)\n        /* Invalid buf contents. */\n        plocals->l_errno = EILSEQ;\n      else if (errno == E2BIG)\n        /* Output buffer too small. */\n        plocals->l_errno = E2BIG;\n      else \n        abort();\n    } else {\n      /* Successful conversion. */\n      if (bufleft > 0)\n        abort();\n    }\n  }\n}",
        "lines": 30,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          133,
          1
        ],
        "content": "static void wc_to_mb_write_replacement (const char *buf, size_t buflen,\n                                        void* callback_arg)\n{\n  struct wc_to_mb_fallback_locals * plocals =\n    (struct wc_to_mb_fallback_locals *) callback_arg;\n  /* Do nothing if already encountered an error in a previous call. */\n  if (plocals->l_errno == 0) {\n    /* Attempt to copy the passed buffer to the output buffer. */\n    if (plocals->l_outbytesleft < buflen)\n      plocals->l_errno = E2BIG;\n    else {\n      memcpy(plocals->l_outbuf, buf, buflen);\n      plocals->l_outbuf += buflen;\n      plocals->l_outbytesleft -= buflen;\n    }\n  }\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "wchar_from_loop_convert": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        236,
        3
      ],
      "content": "static size_t wchar_from_loop_convert (iconv_t icd,\n                                       const char* * inbuf, size_t *inbytesleft,\n                                       char* * outbuf, size_t *outbytesleft)\n{\n  struct wchar_conv_struct * wcd = (struct wchar_conv_struct *) icd;\n  size_t result = 0;\n  while (*inbytesleft >= sizeof(wchar_t)) {\n    const wchar_t * inptr = (const wchar_t *) *inbuf;\n    size_t inleft = *inbytesleft;\n    char buf[BUF_SIZE];\n    mbstate_t state = wcd->state;\n    size_t bufcount = 0;\n    while (inleft >= sizeof(wchar_t)) {\n      /* Convert one wchar_t to multibyte representation. */\n      size_t count = wcrtomb(buf+bufcount,*inptr,&state);\n      if (count == (size_t)(-1)) {\n        /* Invalid input. */\n        if (wcd->parent.discard_ilseq) {\n          count = 0;\n        }\n        #ifndef LIBICONV_PLUG\n        else if (wcd->parent.fallbacks.wc_to_mb_fallback != NULL) {\n          /* Drop the contents of buf[] accumulated so far, and instead\n             pass all queued wide characters to the fallback handler. */\n          struct wc_to_mb_fallback_locals locals;\n          const wchar_t * fallback_inptr;\n          #if 0\n          locals.l_wcd = wcd;\n          #endif\n          locals.l_outbuf = *outbuf;\n          locals.l_outbytesleft = *outbytesleft;\n          locals.l_errno = 0;\n          for (fallback_inptr = (const wchar_t *) *inbuf;\n               fallback_inptr <= inptr;\n               fallback_inptr++)\n            wcd->parent.fallbacks.wc_to_mb_fallback(*fallback_inptr,\n                                                    wc_to_mb_write_replacement,\n                                                    &locals,\n                                                    wcd->parent.fallbacks.data);\n          if (locals.l_errno != 0) {\n            errno = locals.l_errno;\n            return -1;\n          }\n          wcd->state = state;\n          *inbuf = (const char *) (inptr + 1);\n          *inbytesleft = inleft - sizeof(wchar_t);\n          *outbuf = locals.l_outbuf;\n          *outbytesleft = locals.l_outbytesleft;\n          result += 1;\n          break;\n        }\n        #endif\n        else {\n          errno = EILSEQ;\n          return -1;\n        }\n      }\n      inptr++;\n      inleft -= sizeof(wchar_t);\n      bufcount += count;\n      if (count == 0) {\n        /* Continue, append next wchar_t. */\n      } else {\n        /* Attempt to convert the accumulated multibyte representations\n           to the target encoding. */\n        const char* bufptr = buf;\n        size_t bufleft = bufcount;\n        char* outptr = *outbuf;\n        size_t outleft = *outbytesleft;\n        size_t res = unicode_loop_convert(&wcd->parent,\n                                          &bufptr,&bufleft,\n                                          &outptr,&outleft);\n        if (res == (size_t)(-1)) {\n          if (errno == EILSEQ)\n            /* Invalid input. */\n            return -1;\n          else if (errno == E2BIG)\n            /* Output buffer too small. */\n            return -1;\n          else if (errno == EINVAL) {\n            /* Continue, append next wchar_t, but avoid buffer overrun. */\n            if (bufcount + MB_CUR_MAX > BUF_SIZE)\n              abort();\n          } else\n            abort();\n        } else {\n          /* Successful conversion. */\n          wcd->state = state;\n          *inbuf = (const char *) inptr;\n          *inbytesleft = inleft;\n          *outbuf = outptr;\n          *outbytesleft = outleft;\n          result += res;\n          break;\n        }\n      }\n    }\n  }",
      "lines": 98,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wchar_from_loop_reset": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static size_t wchar_from_loop_reset (iconv_t icd,\n                                     char* * outbuf, size_t *outbytesleft)\n{\n  struct wchar_conv_struct * wcd = (struct wchar_conv_struct *) icd;\n  if (outbuf == NULL || *outbuf == NULL) {\n    /* Reset the states. */\n    memset(&wcd->state,'\\0',sizeof(mbstate_t));\n    return unicode_loop_reset(&wcd->parent,NULL,NULL);\n  } else {\n    if (!mbsinit(&wcd->state)) {\n      mbstate_t state = wcd->state;\n      char buf[BUF_SIZE];\n      size_t bufcount = wcrtomb(buf,(wchar_t)0,&state);\n      if (bufcount == (size_t)(-1) || bufcount == 0 || buf[bufcount-1] != '\\0')\n        abort();\n      else {\n        const char* bufptr = buf;\n        size_t bufleft = bufcount-1;\n        char* outptr = *outbuf;\n        size_t outleft = *outbytesleft;\n        size_t res = unicode_loop_convert(&wcd->parent,\n                                          &bufptr,&bufleft,\n                                          &outptr,&outleft);\n        if (res == (size_t)(-1)) {\n          if (errno == E2BIG)\n            return -1;\n          else\n            abort();\n        } else {\n          res = unicode_loop_reset(&wcd->parent,&outptr,&outleft);\n          if (res == (size_t)(-1))\n            return res;\n          else {\n            /* Successful. */\n            wcd->state = state;\n            *outbuf = outptr;\n            *outbytesleft = outleft;\n            return 0;\n          }\n        }\n      }\n    } else\n      return unicode_loop_reset(&wcd->parent,outbuf,outbytesleft);\n  }\n}",
      "lines": 45,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mb_to_wc_write_replacement": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static void mb_to_wc_write_replacement (const wchar_t *buf, size_t buflen,\n                                        void* callback_arg)\n{\n  struct mb_to_wc_fallback_locals * plocals =\n    (struct mb_to_wc_fallback_locals *) callback_arg;\n  /* Do nothing if already encountered an error in a previous call. */\n  if (plocals->l_errno == 0) {\n    /* Attempt to copy the passed buffer to the output buffer. */\n    if (plocals->l_outbytesleft < sizeof(wchar_t)*buflen)\n      plocals->l_errno = E2BIG;\n    else {\n      for (; buflen > 0; buf++, buflen--) {\n        *(wchar_t*) plocals->l_outbuf = *buf;\n        plocals->l_outbuf += sizeof(wchar_t);\n        plocals->l_outbytesleft -= sizeof(wchar_t);\n      }\n    }\n  }\n}",
      "lines": 19,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wchar_to_loop_convert": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static size_t wchar_to_loop_convert (iconv_t icd,\n                                     const char* * inbuf, size_t *inbytesleft,\n                                     char* * outbuf, size_t *outbytesleft)\n{\n  struct wchar_conv_struct * wcd = (struct wchar_conv_struct *) icd;\n  size_t result = 0;\n  while (*inbytesleft > 0) {\n    size_t incount;\n    for (incount = 1; ; ) {\n      /* Here incount <= *inbytesleft. */\n      char buf[BUF_SIZE];\n      const char* inptr = *inbuf;\n      size_t inleft = incount;\n      char* bufptr = buf;\n      size_t bufleft = BUF_SIZE;\n      size_t res = unicode_loop_convert(&wcd->parent,\n                                        &inptr,&inleft,\n                                        &bufptr,&bufleft);\n      if (res == (size_t)(-1)) {\n        if (errno == EILSEQ)\n          /* Invalid input. */\n          return -1;\n        else if (errno == EINVAL) {\n          /* Incomplete input. Next try with one more input byte. */\n        } else\n          /* E2BIG shouldn't occur. */\n          abort();\n      } else {\n        /* Successful conversion. */\n        size_t bufcount = bufptr-buf; /* = BUF_SIZE-bufleft */\n        mbstate_t state = wcd->state;\n        wchar_t wc;\n        res = mbrtowc(&wc,buf,bufcount,&state);\n        if (res == (size_t)(-2)) {\n          /* Next try with one more input byte. */\n        } else {\n          if (res == (size_t)(-1)) {\n            /* Invalid input. */\n            if (wcd->parent.discard_ilseq) {\n            }\n            #ifndef LIBICONV_PLUG\n            else if (wcd->parent.fallbacks.mb_to_wc_fallback != NULL) {\n              /* Drop the contents of buf[] accumulated so far, and instead\n                 pass all queued chars to the fallback handler. */\n              struct mb_to_wc_fallback_locals locals;\n              locals.l_outbuf = *outbuf;\n              locals.l_outbytesleft = *outbytesleft;\n              locals.l_errno = 0;\n              wcd->parent.fallbacks.mb_to_wc_fallback(*inbuf, incount,\n                                                      mb_to_wc_write_replacement,\n                                                      &locals,\n                                                      wcd->parent.fallbacks.data);\n              if (locals.l_errno != 0) {\n                errno = locals.l_errno;\n                return -1;\n              }\n              /* Restoring the state is not needed because it is the initial\n                 state anyway: For all known locale encodings, the multibyte\n                 to wchar_t conversion doesn't have shift state, and we have\n                 excluded partial accumulated characters. */\n              /* wcd->state = state; */\n              *inbuf += incount;\n              *inbytesleft -= incount;\n              *outbuf = locals.l_outbuf;\n              *outbytesleft = locals.l_outbytesleft;\n              result += 1;\n              break;\n            }\n            #endif\n            else\n              return -1;\n          } else {\n            if (*outbytesleft < sizeof(wchar_t)) {\n              errno = E2BIG;\n              return -1;\n            }\n            *(wchar_t*) *outbuf = wc;\n            /* Restoring the state is not needed because it is the initial\n               state anyway: For all known locale encodings, the multibyte\n               to wchar_t conversion doesn't have shift state, and we have\n               excluded partial accumulated characters. */\n            /* wcd->state = state; */\n            *outbuf += sizeof(wchar_t);\n            *outbytesleft -= sizeof(wchar_t);\n          }\n          *inbuf += incount;\n          *inbytesleft -= incount;\n          result += res;\n          break;\n        }\n      }\n      incount++;\n      if (incount > *inbytesleft) {\n        /* Incomplete input. */\n        errno = EINVAL;\n        return -1;\n      }\n    }\n  }\n  return result;\n}",
      "lines": 101,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wchar_to_loop_reset": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "static size_t wchar_to_loop_reset (iconv_t icd,\n                                   char* * outbuf, size_t *outbytesleft)\n{\n  struct wchar_conv_struct * wcd = (struct wchar_conv_struct *) icd;\n  size_t res = unicode_loop_reset(&wcd->parent,outbuf,outbytesleft);\n  if (res == (size_t)(-1))\n    return res;\n  memset(&wcd->state,0,sizeof(mbstate_t));\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wchar_id_loop_convert": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static size_t wchar_id_loop_convert (iconv_t icd,\n                                     const char* * inbuf, size_t *inbytesleft,\n                                     char* * outbuf, size_t *outbytesleft)\n{\n  struct conv_struct * cd = (struct conv_struct *) icd;\n  const wchar_t* inptr = (const wchar_t*) *inbuf;\n  size_t inleft = *inbytesleft / sizeof(wchar_t);\n  wchar_t* outptr = (wchar_t*) *outbuf;\n  size_t outleft = *outbytesleft / sizeof(wchar_t);\n  size_t count = (inleft <= outleft ? inleft : outleft);\n  if (count > 0) {\n    *inbytesleft -= count * sizeof(wchar_t);\n    *outbytesleft -= count * sizeof(wchar_t);\n    do {\n      wchar_t wc = *inptr++;\n      *outptr++ = wc;\n      #ifndef LIBICONV_PLUG\n      if (cd->hooks.wc_hook)\n        (*cd->hooks.wc_hook)(wc, cd->hooks.data);\n      #endif\n    } while (--count > 0);\n    *inbuf = (const char*) inptr;\n    *outbuf = (char*) outptr;\n  }\n  return 0;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wchar_id_loop_reset": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static size_t wchar_id_loop_reset (iconv_t icd,\n                                   char* * outbuf, size_t *outbytesleft)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_arabic.h": {
    "mac_arabic_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_arabic_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_arabic_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_arabic_wctomb": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int\nmac_arabic_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_arabic_page00[wc-0x00a0];\n  else if (wc >= 0x0608 && wc < 0x06d8)\n    c = mac_arabic_page06[wc-0x0608];\n  else if (wc == 0x2026)\n    c = 0x93;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_centraleurope.h": {
    "mac_centraleurope_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nmac_centraleurope_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) mac_centraleurope_2uni[c-0x80];\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_centraleurope_wctomb": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "static int\nmac_centraleurope_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0180)\n    c = mac_centraleurope_page00[wc-0x00a0];\n  else if (wc == 0x02c7)\n    c = 0xff;\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = mac_centraleurope_page20[wc-0x2010];\n  else if (wc == 0x2122)\n    c = 0xaa;\n  else if (wc >= 0x2200 && wc < 0x2220)\n    c = mac_centraleurope_page22[wc-0x2200];\n  else if (wc >= 0x2260 && wc < 0x2268)\n    c = mac_centraleurope_page22_1[wc-0x2260];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_croatian.h": {
    "mac_croatian_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_croatian_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_croatian_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_croatian_wctomb": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int\nmac_croatian_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0198)\n    c = mac_croatian_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = mac_croatian_page02[wc-0x02c0];\n  else if (wc == 0x03c0)\n    c = 0xf9;\n  else if (wc >= 0x2010 && wc < 0x2048)\n    c = mac_croatian_page20[wc-0x2010];\n  else if (wc >= 0x2120 && wc < 0x2128)\n    c = mac_croatian_page21[wc-0x2120];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_croatian_page22[wc-0x2200];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_cyrillic.h": {
    "mac_cyrillic_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nmac_cyrillic_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0x80)\n    *pwc = (ucs4_t) mac_cyrillic_2uni[c-0x80];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_cyrillic_wctomb": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static int\nmac_cyrillic_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = mac_cyrillic_page00[wc-0x00a0];\n  else if (wc == 0x00f7)\n    c = 0xd6;\n  else if (wc == 0x0192)\n    c = 0xc4;\n  else if (wc >= 0x0400 && wc < 0x0460)\n    c = mac_cyrillic_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = mac_cyrillic_page20[wc-0x2010];\n  else if (wc >= 0x2110 && wc < 0x2128)\n    c = mac_cyrillic_page21[wc-0x2110];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_cyrillic_page22[wc-0x2200];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_greek.h": {
    "mac_greek_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_greek_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_greek_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_greek_wctomb": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static int\nmac_greek_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_greek_page00[wc-0x00a0];\n  else if (wc == 0x0153)\n    c = 0xcf;\n  else if (wc >= 0x0380 && wc < 0x03d0)\n    c = mac_greek_page03[wc-0x0380];\n  else if (wc >= 0x2010 && wc < 0x2038)\n    c = mac_greek_page20[wc-0x2010];\n  else if (wc == 0x2122)\n    c = 0x93;\n  else if (wc >= 0x2248 && wc < 0x2268)\n    c = mac_greek_page22[wc-0x2248];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_hebrew.h": {
    "mac_hebrew_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_hebrew_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c >= 0x80) {\n    unsigned short wc = mac_hebrew_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_hebrew_wctomb": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int\nmac_hebrew_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_hebrew_page00[wc-0x00a0];\n  else if (wc >= 0x05b0 && wc < 0x05f0)\n    c = mac_hebrew_page05[wc-0x05b0];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = mac_hebrew_page20[wc-0x2010];\n  else if (wc == 0x20aa)\n    c = 0xa6;\n  else if (wc >= 0xfb18 && wc < 0xfb50)\n    c = mac_hebrew_pagefb[wc-0xfb18];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_iceland.h": {
    "mac_iceland_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_iceland_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_iceland_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_iceland_wctomb": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nmac_iceland_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_iceland_page00[wc-0x00a0];\n  else if (wc >= 0x0130 && wc < 0x0198)\n    c = mac_iceland_page01[wc-0x0130];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = mac_iceland_page02[wc-0x02c0];\n  else if (wc == 0x03c0)\n    c = 0xb9;\n  else if (wc >= 0x2010 && wc < 0x2048)\n    c = mac_iceland_page20[wc-0x2010];\n  else if (wc >= 0x2120 && wc < 0x2128)\n    c = mac_iceland_page21[wc-0x2120];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_iceland_page22[wc-0x2200];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_roman.h": {
    "mac_roman_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_roman_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_roman_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_roman_wctomb": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\nmac_roman_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_roman_page00[wc-0x00a0];\n  else if (wc >= 0x0130 && wc < 0x0198)\n    c = mac_roman_page01[wc-0x0130];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = mac_roman_page02[wc-0x02c0];\n  else if (wc == 0x03c0)\n    c = 0xb9;\n  else if (wc >= 0x2010 && wc < 0x2048)\n    c = mac_roman_page20[wc-0x2010];\n  else if (wc >= 0x2120 && wc < 0x2128)\n    c = mac_roman_page21[wc-0x2120];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_roman_page22[wc-0x2200];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  else if (wc >= 0xfb00 && wc < 0xfb08)\n    c = mac_roman_pagefb[wc-0xfb00];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_romania.h": {
    "mac_romania_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_romania_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_romania_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_romania_wctomb": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int\nmac_romania_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0198)\n    c = mac_romania_page00[wc-0x00a0];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = mac_romania_page02[wc-0x02c0];\n  else if (wc == 0x03c0)\n    c = 0xb9;\n  else if (wc >= 0x2010 && wc < 0x2048)\n    c = mac_romania_page20[wc-0x2010];\n  else if (wc >= 0x2120 && wc < 0x2128)\n    c = mac_romania_page21[wc-0x2120];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_romania_page22[wc-0x2200];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_thai.h": {
    "mac_thai_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_thai_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_thai_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_thai_wctomb": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nmac_thai_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = mac_thai_page00[wc-0x00a0];\n  else if (wc >= 0x0e00 && wc < 0x0e60)\n    c = mac_thai_page0e[wc-0x0e00];\n  else if (wc >= 0x2008 && wc < 0x2028)\n    c = mac_thai_page20[wc-0x2008];\n  else if (wc == 0x2122)\n    c = 0xee;\n  else if (wc >= 0xf880 && wc < 0xf8a0)\n    c = mac_thai_pagef8[wc-0xf880];\n  else if (wc == 0xfeff)\n    c = 0xdb;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_turkish.h": {
    "mac_turkish_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nmac_turkish_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mac_turkish_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_turkish_wctomb": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\nmac_turkish_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = mac_turkish_page00[wc-0x00a0];\n  else if (wc >= 0x0118 && wc < 0x0198)\n    c = mac_turkish_page01[wc-0x0118];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = mac_turkish_page02[wc-0x02c0];\n  else if (wc == 0x03c0)\n    c = 0xb9;\n  else if (wc >= 0x2010 && wc < 0x2038)\n    c = mac_turkish_page20[wc-0x2010];\n  else if (wc >= 0x2120 && wc < 0x2128)\n    c = mac_turkish_page21[wc-0x2120];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_turkish_page22[wc-0x2200];\n  else if (wc == 0x25ca)\n    c = 0xd7;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mac_ukraine.h": {
    "mac_ukraine_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nmac_ukraine_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0x80)\n    *pwc = (ucs4_t) mac_ukraine_2uni[c-0x80];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mac_ukraine_wctomb": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nmac_ukraine_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = mac_ukraine_page00[wc-0x00a0];\n  else if (wc == 0x00f7)\n    c = 0xd6;\n  else if (wc == 0x0192)\n    c = 0xc4;\n  else if (wc >= 0x0400 && wc < 0x0498)\n    c = mac_ukraine_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = mac_ukraine_page20[wc-0x2010];\n  else if (wc >= 0x2110 && wc < 0x2128)\n    c = mac_ukraine_page21[wc-0x2110];\n  else if (wc >= 0x2200 && wc < 0x2268)\n    c = mac_ukraine_page22[wc-0x2200];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/mulelao.h": {
    "mulelao_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\nmulelao_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0xa0) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = mulelao_2uni[c-0xa0];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mulelao_wctomb": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\nmulelao_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x00a0) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc == 0x00a0)\n    c = 0xa0;\n  else if (wc >= 0x0e80 && wc < 0x0ee0)\n    c = mulelao_page0e[wc-0x0e80];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/nextstep.h": {
    "nextstep_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nnextstep_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = nextstep_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nextstep_wctomb": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\nnextstep_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x0100)\n    c = nextstep_page00[wc-0x00a0];\n  else if (wc >= 0x0130 && wc < 0x0198)\n    c = nextstep_page01[wc-0x0130];\n  else if (wc >= 0x02c0 && wc < 0x02e0)\n    c = nextstep_page02[wc-0x02c0];\n  else if (wc >= 0x2010 && wc < 0x2048)\n    c = nextstep_page20[wc-0x2010];\n  else if (wc >= 0xfb00 && wc < 0xfb08)\n    c = nextstep_pagefb[wc-0xfb00];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/pt154.h": {
    "pt154_mbtowc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\npt154_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else if (c >= 0xc0)\n    *pwc = (ucs4_t) c + 0x0350;\n  else\n    *pwc = (ucs4_t) pt154_2uni[c-0x80];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pt154_wctomb": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\npt154_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = pt154_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x04f0)\n    c = pt154_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2028)\n    c = pt154_page20[wc-0x2010];\n  else if (wc == 0x2116)\n    c = 0xb9;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n                            const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n         relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n        {\n          memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n          orig_prefix = memory;\n          memory += orig_prefix_len + 1;\n          memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n          curr_prefix = memory;\n          return;\n        }\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "char *\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)\n{\n  char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n        p--;\n        if (ISSLASH (*p))\n          break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n        bool same = false;\n        const char *rpi = rp;\n        const char *cpi = cp;\n\n        while (rpi > rel_installdir && cpi > cp_base)\n          {\n            rpi--;\n            cpi--;\n            if (ISSLASH (*rpi) || ISSLASH (*cpi))\n              {\n                if (ISSLASH (*rpi) && ISSLASH (*cpi))\n                  same = true;\n                break;\n              }\n            /* Do case-insensitive comparison if the file system is always or\n               often case-insensitive.  It's better to accept the comparison\n               if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */\n            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n              break;\n#else\n            if (*rpi != *cpi)\n              break;\n#endif\n          }\n        if (!same)\n          break;\n        /* The last pathname component was the same.  opi and cpi now point\n           to the slash before it.  */\n        rp = rpi;\n        cp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      {\n        /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n        free (curr_installdir);\n        return NULL;\n      }\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n        {\n          free (curr_installdir);\n          return NULL;\n        }\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      free (curr_installdir);\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      shared_library_fullname = strdup (location);\n    }\n\n  return TRUE;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "_DLL_InitTerm": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "unsigned long _System\n_DLL_InitTerm (unsigned long hModule, unsigned long ulFlag)\n{\n  static char location[CCHMAXPATH];\n\n  switch (ulFlag)\n    {\n      case 0:\n        if (_CRT_init () == -1)\n          return 0;\n\n        __ctordtorInit();\n\n        /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/1247_L2H_DosQueryModuleNameSy.html\n           for specification of DosQueryModuleName(). */\n        if (DosQueryModuleName (hModule, sizeof (location), location))\n          return 0;\n\n        _fnslashify (location);\n        shared_library_fullname = strdup (location);\n        break;\n\n      case 1:\n        __ctordtorTerm();\n\n        _CRT_term ();\n        break;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "unsigned long _System",
        "unsigned",
        "long",
        "_System"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__\n  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()\n     function.\n     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.\n     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on\n     Cygwin 1.7.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n        {\n          unsigned long start, end;\n          int c;\n\n          if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n            break;\n          if (address >= start && address <= end - 1)\n            {\n              /* Found it.  Now see if this line contains a filename.  */\n              while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n                continue;\n              if (c == '/')\n                {\n                  size_t size;\n                  int len;\n\n                  ungetc (c, fp);\n                  shared_library_fullname = NULL; size = 0;\n                  len = getline (&shared_library_fullname, &size, fp);\n                  if (len >= 0)\n                    {\n                      /* Success: filled shared_library_fullname.  */\n                      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n                        shared_library_fullname[len - 1] = '\\0';\n                    }\n                }\n              break;\n            }\n          while (c = getc (fp), c != EOF && c != '\\n')\n            continue;\n        }\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if (!((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) \\\n     && !defined __EMX__)\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n         set through the main program's set_program_name_and_installdir\n         function.  This is sufficient in the case that the library has\n         initially been installed in the same orig_prefix.  But we can do\n         better, to also cover the cases that 1. it has been installed\n         in a different prefix before being moved to orig_prefix and (later)\n         to curr_prefix, 2. unlike the program, it has not moved away from\n         orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      char *curr_prefix_better;\n\n      curr_prefix_better =\n        compute_curr_prefix (orig_installprefix, orig_installdir,\n                             get_shared_library_fullname ());\n\n      set_relocation_prefix (orig_installprefix,\n                             curr_prefix_better != NULL\n                             ? curr_prefix_better\n                             : curr_prefix);\n\n      if (curr_prefix_better != NULL)\n        free (curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like file systems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n        {\n          /* pathname equals orig_prefix.  */\n          char *result = (char *) xmalloc (strlen (curr_prefix) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, curr_prefix);\n              return result;\n            }\n        }\n      else if (ISSLASH (pathname[orig_prefix_len]))\n        {\n          /* pathname starts with orig_prefix.  */\n          const char *pathname_tail = &pathname[orig_prefix_len];\n          char *result =\n            (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, curr_prefix, curr_prefix_len);\n              strcpy (result + curr_prefix_len, pathname_tail);\n              return result;\n            }\n        }\n    }\n\n#ifdef __EMX__\n# ifdef __KLIBC__\n#  undef strncmp\n\n  if (pathname && strncmp (pathname, \"/@unixroot\", 10) == 0\n      && (pathname[10] == '\\0' || pathname[10] == '/' || pathname[10] == '\\\\'))\n    {\n      /* kLIBC itself processes /@unixroot prefix */\n\n      return pathname;\n    }\n  else\n# endif\n  if (pathname && ISSLASH (pathname[0]))\n    {\n      const char *unixroot = getenv (\"UNIXROOT\");\n\n      if (unixroot && HAS_DEVICE (unixroot) && !unixroot[2])\n        {\n          char *result = (char *) xmalloc (2 + strlen (pathname) + 1);\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, unixroot);\n              strcpy (result + 2, pathname);\n              return result;\n            }\n        }\n    }\n#endif\n\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 110,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/relocatable.h": {},
  "libiconv/libiconv-1.15/lib/riscos1.h": {
    "riscos1_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\nriscos1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c >= 0x80 && c < 0xa0)\n    *pwc = (ucs4_t) riscos1_2uni[c-0x80];\n  else\n    *pwc = (ucs4_t) c;\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "riscos1_wctomb": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\nriscos1_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080 || wc == 0x0083 || wc == 0x0087 || (wc >= 0x00a0 && wc < 0x0100)) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0150 && wc < 0x0178)\n    c = riscos1_page01[wc-0x0150];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = riscos1_page20[wc-0x2010];\n  else if (wc == 0x2122)\n    c = 0x8d;\n  else if (wc >= 0x21e0 && wc < 0x21f0)\n    c = riscos1_page21[wc-0x21e0];\n  else if (wc >= 0x2210 && wc < 0x2220)\n    c = riscos1_page22[wc-0x2210];\n  else if (wc == 0x2573)\n    c = 0x84;\n  else if (wc >= 0xfb01 && wc < 0xfb03)\n    c = wc-0xfa63;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/rk1048.h": {
    "rk1048_mbtowc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nrk1048_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else {\n    unsigned short wc = rk1048_2uni[c-0x80];\n    if (wc != 0xfffd) {\n      *pwc = (ucs4_t) wc;\n      return 1;\n    }\n  }\n  return RET_ILSEQ;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rk1048_wctomb": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static int\nrk1048_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x00c0)\n    c = rk1048_page00[wc-0x00a0];\n  else if (wc >= 0x0400 && wc < 0x04f0)\n    c = rk1048_page04[wc-0x0400];\n  else if (wc >= 0x2010 && wc < 0x2040)\n    c = rk1048_page20[wc-0x2010];\n  else if (wc == 0x20ac)\n    c = 0x88;\n  else if (wc >= 0x2110 && wc < 0x2128)\n    c = rk1048_page21[wc-0x2110];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/shift_jisx0213.h": {
    "shift_jisx0213_mbtowc": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static int\nshift_jisx0213_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  ucs4_t last_wc = conv->istate;\n  if (last_wc) {\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = last_wc;\n    return 0; /* Don't advance the input pointer. */\n  } else {\n    unsigned char c = *s;\n    if (c < 0x80) {\n      /* Plain ISO646-JP character. */\n      if (c == 0x5c)\n        *pwc = (ucs4_t) 0x00a5;\n      else if (c == 0x7e)\n        *pwc = (ucs4_t) 0x203e;\n      else\n        *pwc = (ucs4_t) c;\n      return 1;\n    } else if (c >= 0xa1 && c <= 0xdf) {\n      *pwc = c + 0xfec0;\n      return 1;\n    } else {\n      if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xfc)) {\n        /* Two byte character. */\n        if (n >= 2) {\n          unsigned char c2 = s[1];\n          if ((c2 >= 0x40 && c2 <= 0x7e) || (c2 >= 0x80 && c2 <= 0xfc)) {\n            unsigned int c1;\n            ucs4_t wc;\n            /* Convert to row and column. */\n            if (c < 0xe0)\n              c -= 0x81;\n            else\n              c -= 0xc1;\n            if (c2 < 0x80)\n              c2 -= 0x40;\n            else\n              c2 -= 0x41;\n            /* Now 0 <= c <= 0x3b, 0 <= c2 <= 0xbb. */\n            c1 = 2 * c;\n            if (c2 >= 0x5e)\n              c2 -= 0x5e, c1++;\n            c2 += 0x21;\n            if (c1 >= 0x5e) {\n              /* Handling of JISX 0213 plane 2 rows. */\n              if (c1 >= 0x67)\n                c1 += 230;\n              else if (c1 >= 0x63 || c1 == 0x5f)\n                c1 += 168;\n              else\n                c1 += 162;\n            }\n            wc = jisx0213_to_ucs4(0x121+c1,c2);\n            if (wc) {\n              if (wc < 0x80) {\n                /* It's a combining character. */\n                ucs4_t wc1 = jisx0213_to_ucs_combining[wc - 1][0];\n                ucs4_t wc2 = jisx0213_to_ucs_combining[wc - 1][1];\n                /* We cannot output two Unicode characters at once. So,\n                   output the first character and buffer the second one. */\n                *pwc = wc1;\n                conv->istate = wc2;\n              } else\n                *pwc = wc;\n              return 2;\n            }\n          }\n        } else\n          return RET_TOOFEW(0);\n      }\n      return RET_ILSEQ;\n    }\n  }\n}",
      "lines": 76,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "shift_jisx0213_wctomb": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "static int\nshift_jisx0213_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  int count = 0;\n  unsigned short lasttwo = conv->ostate;\n\n  if (lasttwo) {\n    /* Attempt to combine the last character with this one. */\n    unsigned int idx;\n    unsigned int len;\n\n    if (wc == 0x02e5)\n      idx = shift_jisx0213_comp_table02e5_idx,\n      len = shift_jisx0213_comp_table02e5_len;\n    else if (wc == 0x02e9)\n      idx = shift_jisx0213_comp_table02e9_idx,\n      len = shift_jisx0213_comp_table02e9_len;\n    else if (wc == 0x0300)\n      idx = shift_jisx0213_comp_table0300_idx,\n      len = shift_jisx0213_comp_table0300_len;\n    else if (wc == 0x0301)\n      idx = shift_jisx0213_comp_table0301_idx,\n      len = shift_jisx0213_comp_table0301_len;\n    else if (wc == 0x309a)\n      idx = shift_jisx0213_comp_table309a_idx,\n      len = shift_jisx0213_comp_table309a_len;\n    else\n      goto not_combining;\n\n    do\n      if (shift_jisx0213_comp_table_data[idx].base == lasttwo)\n        break;\n    while (++idx, --len > 0);\n\n    if (len > 0) {\n      /* Output the combined character. */\n      if (n >= 2) {\n        lasttwo = shift_jisx0213_comp_table_data[idx].composed;\n        r[0] = (lasttwo >> 8) & 0xff;\n        r[1] = lasttwo & 0xff;\n        conv->ostate = 0;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n\n  not_combining:\n    /* Output the buffered character. */\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = (lasttwo >> 8) & 0xff;\n    r[1] = lasttwo & 0xff;\n    r += 2;\n    count = 2;\n  }\n\n  if (wc < 0x80 && wc != 0x5c && wc != 0x7e) {\n    /* Plain ISO646-JP character. */\n    if (n > count) {\n      r[0] = (unsigned char) wc;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else if (wc == 0x00a5) {\n    if (n > count) {\n      r[0] = 0x5c;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else if (wc == 0x203e) {\n    if (n > count) {\n      r[0] = 0x7e;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else if (wc >= 0xff61 && wc <= 0xff9f) {\n    /* Half-width katakana. */\n    if (n > count) {\n      r[0] = wc - 0xfec0;\n      conv->ostate = 0;\n      return count+1;\n    } else\n      return RET_TOOSMALL;\n  } else {\n    unsigned int s1, s2;\n    unsigned short jch = ucs4_to_jisx0213(wc);\n    if (jch != 0) {\n      /* Convert it to shifted representation. */\n      s1 = jch >> 8;\n      s2 = jch & 0x7f;\n      s1 -= 0x21;\n      s2 -= 0x21;\n      if (s1 >= 0x5e) {\n        /* Handling of JISX 0213 plane 2 rows. */\n        if (s1 >= 0xcd) /* rows 0x26E..0x27E */\n          s1 -= 102;\n        else if (s1 >= 0x8b || s1 == 0x87) /* rows 0x228, 0x22C..0x22F */\n          s1 -= 40;\n        else /* rows 0x221, 0x223..0x225 */\n          s1 -= 34;\n        /* Now 0x5e <= s1 <= 0x77. */\n      }\n      if (s1 & 1)\n        s2 += 0x5e;\n      s1 = s1 >> 1;\n      if (s1 < 0x1f)\n        s1 += 0x81;\n      else\n        s1 += 0xc1;\n      if (s2 < 0x3f)\n        s2 += 0x40;\n      else\n        s2 += 0x41;\n      if (jch & 0x0080) {\n        /* A possible match in comp_table_data. We have to buffer it. */\n        /* We know it's a JISX 0213 plane 1 character. */\n        if (jch & 0x8000) abort();\n        conv->ostate = (s1 << 8) | s2;\n        return count+0;\n      }\n      /* Output the shifted representation. */\n      if (n >= count+2) {\n        r[0] = s1;\n        r[1] = s2;\n        conv->ostate = 0;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    return RET_ILUNI;\n  }\n}",
      "lines": 135,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "shift_jisx0213_reset": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static int\nshift_jisx0213_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t lasttwo = conv->ostate;\n\n  if (lasttwo) {\n    if (n < 2)\n      return RET_TOOSMALL;\n    r[0] = (lasttwo >> 8) & 0xff;\n    r[1] = lasttwo & 0xff;\n    /* conv->ostate = 0; will be done by the caller */\n    return 2;\n  } else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/sjis.h": {
    "sjis_mbtowc": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nsjis_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80 || (c >= 0xa1 && c <= 0xdf))\n    return jisx0201_mbtowc(conv,pwc,s,n);\n  else {\n    unsigned char s1, s2;\n    s1 = c;\n    if ((s1 >= 0x81 && s1 <= 0x9f) || (s1 >= 0xe0 && s1 <= 0xea)) {\n      if (n < 2)\n        return RET_TOOFEW(0);\n      s2 = s[1];\n      if ((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0x80 && s2 <= 0xfc)) {\n        unsigned char t1 = (s1 < 0xe0 ? s1-0x81 : s1-0xc1);\n        unsigned char t2 = (s2 < 0x80 ? s2-0x40 : s2-0x41);\n        unsigned char buf[2];\n        buf[0] = 2*t1 + (t2 < 0x5e ? 0 : 1) + 0x21;\n        buf[1] = (t2 < 0x5e ? t2 : t2-0x5e) + 0x21;\n        return jisx0208_mbtowc(conv,pwc,buf,2);\n      }\n    } else if (s1 >= 0xf0 && s1 <= 0xf9) {\n      /* User-defined range. See\n       * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n      if (n < 2)\n        return RET_TOOFEW(0);\n      s2 = s[1];\n      if ((s2 >= 0x40 && s2 <= 0x7e) || (s2 >= 0x80 && s2 <= 0xfc)) {\n        *pwc = 0xe000 + 188*(s1 - 0xf0) + (s2 < 0x80 ? s2-0x40 : s2-0x41);\n        return 2;\n      }\n    }\n    return RET_ILSEQ;\n  }\n}",
      "lines": 35,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sjis_wctomb": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int\nsjis_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char buf[2];\n  int ret;\n\n  /* Try JIS X 0201-1976. */\n  ret = jisx0201_wctomb(conv,buf,wc,1);\n  if (ret != RET_ILUNI) {\n    unsigned char c;\n    if (ret != 1) abort();\n    c = buf[0];\n    if (c < 0x80 || (c >= 0xa1 && c <= 0xdf)) {\n      r[0] = c;\n      return 1;\n    }\n  }\n\n  /* Try JIS X 0208-1990. */\n  ret = jisx0208_wctomb(conv,buf,wc,2);\n  if (ret != RET_ILUNI) {\n    unsigned char c1, c2;\n    if (ret != 2) abort();\n    if (n < 2)\n      return RET_TOOSMALL;\n    c1 = buf[0];\n    c2 = buf[1];\n    if ((c1 >= 0x21 && c1 <= 0x74) && (c2 >= 0x21 && c2 <= 0x7e)) {\n      unsigned char t1 = (c1 - 0x21) >> 1;\n      unsigned char t2 = (((c1 - 0x21) & 1) ? 0x5e : 0) + (c2 - 0x21);\n      r[0] = (t1 < 0x1f ? t1+0x81 : t1+0xc1);\n      r[1] = (t2 < 0x3f ? t2+0x40 : t2+0x41);\n      return 2;\n    }\n  }\n\n  /* User-defined range. See\n   * Ken Lunde's \"CJKV Information Processing\", table 4-66, p. 206. */\n  if (wc >= 0xe000 && wc < 0xe758) {\n    unsigned char c1, c2;\n    if (n < 2)\n      return RET_TOOSMALL;\n    c1 = (unsigned int) (wc - 0xe000) / 188;\n    c2 = (unsigned int) (wc - 0xe000) % 188;\n    r[0] = c1+0xf0;\n    r[1] = (c2 < 0x3f ? c2+0x40 : c2+0x41);\n    return 2;\n  }\n\n  return RET_ILUNI;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/tcvn.h": {
    "tcvn_mbtowc": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\ntcvn_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  unsigned short wc;\n  unsigned short last_wc;\n  if (c < 0x18)\n    wc = tcvn_2uni_1[c];\n  else if (c < 0x80)\n    wc = c;\n  else\n    wc = tcvn_2uni_2[c-0x80];\n  last_wc = conv->istate;\n  if (last_wc) {\n    if (wc >= 0x0300 && wc < 0x0340) {\n      /* See whether last_wc and wc can be combined. */\n      unsigned int k;\n      unsigned int i1, i2;\n      switch (wc) {\n        case 0x0300: k = 0; break;\n        case 0x0301: k = 1; break;\n        case 0x0303: k = 2; break;\n        case 0x0309: k = 3; break;\n        case 0x0323: k = 4; break;\n        default: abort();\n      }\n      i1 = viet_comp_table[k].idx;\n      i2 = i1 + viet_comp_table[k].len-1;\n      if (last_wc >= viet_comp_table_data[i1].base\n          && last_wc <= viet_comp_table_data[i2].base) {\n        unsigned int i;\n        for (;;) {\n          i = (i1+i2)>>1;\n          if (last_wc == viet_comp_table_data[i].base)\n            break;\n          if (last_wc < viet_comp_table_data[i].base) {\n            if (i1 == i)\n              goto not_combining;\n            i2 = i;\n          } else {\n            if (i1 != i)\n              i1 = i;\n            else {\n              i = i2;\n              if (last_wc == viet_comp_table_data[i].base)\n                break;\n              goto not_combining;\n            }\n          }\n        }\n        last_wc = viet_comp_table_data[i].composed;\n        /* Output the combined character. */\n        conv->istate = 0;\n        *pwc = (ucs4_t) last_wc;\n        return 1;\n      }\n    }\n  not_combining:\n    /* Output the buffered character. */\n    conv->istate = 0;\n    *pwc = (ucs4_t) last_wc;\n    return 0; /* Don't advance the input pointer. */\n  }\n  if (wc >= 0x0041 && wc <= 0x01b0\n      && ((tcvn_comp_bases[(wc - 0x0040) >> 5] >> (wc & 0x1f)) & 1)) {\n    /* wc is a possible match in viet_comp_table_data. Buffer it. */\n    conv->istate = wc;\n    return RET_TOOFEW(1);\n  } else {\n    /* Output wc immediately. */\n    *pwc = (ucs4_t) wc;\n    return 1;\n  }\n}",
      "lines": 74,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tcvn_wctomb": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static int\ntcvn_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080 && (wc >= 0x0020 || (0x00fe0076 & (1 << wc)) == 0)) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00a0 && wc < 0x01b8)\n    c = tcvn_page00[wc-0x00a0];\n  else if (wc >= 0x0300 && wc < 0x0328)\n    c = tcvn_page03[wc-0x0300];\n  else if (wc >= 0x0340 && wc < 0x0342) /* deprecated Vietnamese tone marks */\n    c = tcvn_page03[wc-0x0340];\n  else if (wc >= 0x1ea0 && wc < 0x1f00)\n    c = tcvn_page1e[wc-0x1ea0];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  /* Try compatibility or canonical decomposition. */\n  {\n    /* Binary search through viet_decomp_table. */\n    unsigned int i1 = 0;\n    unsigned int i2 = sizeof(viet_decomp_table)/sizeof(viet_decomp_table[0])-1;\n    if (wc >= viet_decomp_table[i1].composed\n        && wc <= viet_decomp_table[i2].composed) {\n      unsigned int i;\n      for (;;) {\n        /* Here i2 - i1 > 0. */\n        i = (i1+i2)>>1;\n        if (wc == viet_decomp_table[i].composed)\n          break;\n        if (wc < viet_decomp_table[i].composed) {\n          if (i1 == i)\n            return RET_ILUNI;\n          /* Here i1 < i < i2. */\n          i2 = i;\n        } else {\n          /* Here i1 <= i < i2. */\n          if (i1 != i)\n            i1 = i;\n          else {\n            /* Here i2 - i1 = 1. */\n            i = i2;\n            if (wc == viet_decomp_table[i].composed)\n              break;\n            else\n              return RET_ILUNI;\n          }\n        }\n      }\n      /* Found a compatibility or canonical decomposition. */\n      wc = viet_decomp_table[i].base;\n      /* wc is one of 0x0020, 0x0041..0x005a, 0x0061..0x007a, 0x00a5, 0x00a8,\n         0x00c2, 0x00c5..0x00c7, 0x00ca, 0x00cf, 0x00d3, 0x00d4, 0x00d6,\n         0x00d8, 0x00da, 0x00dc, 0x00e2, 0x00e5..0x00e7, 0x00ea, 0x00ef,\n         0x00f3, 0x00f4, 0x00f6, 0x00f8, 0x00fc, 0x0102, 0x0103, 0x01a0,\n         0x01a1, 0x01af, 0x01b0. */\n      if (wc < 0x0080)\n        c = wc;\n      else {\n        c = tcvn_page00[wc-0x00a0];\n        if (c == 0)\n          return RET_ILUNI;\n      }\n      if (n < 2)\n        return RET_TOOSMALL;\n      r[0] = c;\n      r[1] = tcvn_comb_table[viet_decomp_table[i].comb1];\n      return 2;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 75,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/tds565.h": {
    "tds565_mbtowc": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\ntds565_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x40) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c < 0x80) {\n    *pwc = (ucs4_t) tds565_2uni[c-0x40];\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tds565_wctomb": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static int\ntds565_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0040) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0040 && wc < 0x0080)\n    c = tds565_page00[wc-0x0040];\n  else if (wc >= 0x00c0 && wc < 0x0100)\n    c = tds565_page00_1[wc-0x00c0];\n  else if (wc >= 0x0140 && wc < 0x0180)\n    c = tds565_page01[wc-0x0140];\n  else if (wc == 0x2116)\n    c = 0x60;\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/tis620.h": {
    "tis620_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\ntis620_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x80) {\n    *pwc = (ucs4_t) c;\n    return 1;\n  }\n  else if (c >= 0xa1 && c <= 0xfb && !(c >= 0xdb && c <= 0xde)) {\n    *pwc = (ucs4_t) (c + 0x0d60);\n    return 1;\n  }\n  return RET_ILSEQ;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tis620_wctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\ntis620_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x0080) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x0e01 && wc <= 0x0e5b && !(wc >= 0x0e3b && wc <= 0x0e3e)) {\n    *r = wc-0x0d60;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/translit.h": {},
  "libiconv/libiconv-1.15/lib/ucs2.h": {
    "ucs2_mbtowc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\nucs2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  for (; n >= 2 && count <= RET_COUNT_MAX && count <= INT_MAX-2;) {\n    ucs4_t wc = (state ? s[0] + (s[1] << 8) : (s[0] << 8) + s[1]);\n    if (wc == 0xfeff) {\n    } else if (wc == 0xfffe) {\n      state ^= 1;\n    } else if (wc >= 0xd800 && wc < 0xe000) {\n      conv->istate = state;\n      return RET_SHIFT_ILSEQ(count);\n    } else {\n      *pwc = wc;\n      conv->istate = state;\n      return count+2;\n    }\n    s += 2; n -= 2; count += 2;\n  }\n  conv->istate = state;\n  return RET_TOOFEW(count);\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs2_wctomb": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nucs2_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x10000 && wc != 0xfffe && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 2) {\n      r[0] = (unsigned char) (wc >> 8);\n      r[1] = (unsigned char) wc;\n      return 2;\n    } else\n      return RET_TOOSMALL;\n  } else\n    return RET_ILUNI;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs2be.h": {
    "ucs2be_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\nucs2be_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2) {\n    if (s[0] >= 0xd8 && s[0] < 0xe0) {\n      return RET_ILSEQ;\n    } else {\n      *pwc = (s[0] << 8) + s[1];\n      return 2;\n    }\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs2be_wctomb": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nucs2be_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x10000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 2) {\n      r[0] = (unsigned char) (wc >> 8);\n      r[1] = (unsigned char) wc;\n      return 2;\n    } else\n      return RET_TOOSMALL;\n  }\n  return RET_ILUNI;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs2internal.h": {
    "ucs2internal_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nucs2internal_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2) {\n    unsigned short x = *(const unsigned short *)s;\n    if (x >= 0xd800 && x < 0xe000) {\n      return RET_ILSEQ;\n    } else {\n      *pwc = x;\n      return 2;\n    }\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs2internal_wctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nucs2internal_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x10000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 2) {\n      *(unsigned short *)r = wc;\n      return 2;\n    } else\n      return RET_TOOSMALL;\n  } else\n    return RET_ILUNI;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs2le.h": {
    "ucs2le_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\nucs2le_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 2) {\n    if (s[1] >= 0xd8 && s[1] < 0xe0) {\n      return RET_ILSEQ;\n    } else {\n      *pwc = s[0] + (s[1] << 8);\n      return 2;\n    }\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs2le_wctomb": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\nucs2le_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x10000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 2) {\n      r[0] = (unsigned char) wc;\n      r[1] = (unsigned char) (wc >> 8);\n      return 2;\n    } else\n      return RET_TOOSMALL;\n  }\n  return RET_ILUNI;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs2swapped.h": {
    "ucs2swapped_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static int\nucs2swapped_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  /* This function assumes that 'unsigned short' has exactly 16 bits. */\n  if (sizeof(unsigned short) != 2) abort();\n\n  if (n >= 2) {\n    unsigned short x = *(const unsigned short *)s;\n    x = (x >> 8) | (x << 8);\n    if (x >= 0xd800 && x < 0xe000) {\n      return RET_ILSEQ;\n    } else {\n      *pwc = x;\n      return 2;\n    }\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs2swapped_wctomb": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nucs2swapped_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  /* This function assumes that 'unsigned short' has exactly 16 bits. */\n  if (sizeof(unsigned short) != 2) abort();\n\n  if (wc < 0x10000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 2) {\n      unsigned short x = wc;\n      x = (x >> 8) | (x << 8);\n      *(unsigned short *)r = x;\n      return 2;\n    } else\n      return RET_TOOSMALL;\n  } else\n    return RET_ILUNI;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs4.h": {
    "ucs4_mbtowc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nucs4_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  for (; n >= 4 && count <= RET_COUNT_MAX && count <= INT_MAX-4;) {\n    ucs4_t wc = (state\n                  ? s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24)\n                  : (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3]);\n    if (wc == 0x0000feff) {\n    } else if (wc == 0xfffe0000u) {\n      state ^= 1;\n    } else if (wc <= 0x7fffffff) {\n      *pwc = wc;\n      conv->istate = state;\n      return count+4;\n    } else {\n      conv->istate = state;\n      return RET_SHIFT_ILSEQ(count);\n    }\n    s += 4; n -= 4; count += 4;\n  }\n  conv->istate = state;\n  return RET_TOOFEW(count);\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4_wctomb": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nucs4_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc <= 0x7fffffff) {\n    if (n >= 4) {\n      r[0] = (unsigned char) (wc >> 24);\n      r[1] = (unsigned char) (wc >> 16);\n      r[2] = (unsigned char) (wc >> 8);\n      r[3] = (unsigned char) wc;\n      return 4;\n    } else\n      return RET_TOOSMALL;\n  } else\n    return RET_ILUNI;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs4be.h": {
    "ucs4be_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static int\nucs4be_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4) {\n    *pwc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n    return 4;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4be_wctomb": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\nucs4be_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 4) {\n    r[0] = (unsigned char) (wc >> 24);\n    r[1] = (unsigned char) (wc >> 16);\n    r[2] = (unsigned char) (wc >> 8);\n    r[3] = (unsigned char) wc;\n    return 4;\n  } else\n    return RET_TOOSMALL;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs4internal.h": {
    "ucs4internal_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static int\nucs4internal_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4) {\n    *pwc = *(const unsigned int *)s;\n    return 4;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4internal_wctomb": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\nucs4internal_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 4) {\n    *(unsigned int *)r = wc;\n    return 4;\n  } else\n    return RET_TOOSMALL;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs4le.h": {
    "ucs4le_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static int\nucs4le_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4) {\n    *pwc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n    return 4;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4le_wctomb": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\nucs4le_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 4) {\n    r[0] = (unsigned char) wc;\n    r[1] = (unsigned char) (wc >> 8);\n    r[2] = (unsigned char) (wc >> 16);\n    r[3] = (unsigned char) (wc >> 24);\n    return 4;\n  } else\n    return RET_TOOSMALL;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/ucs4swapped.h": {
    "ucs4swapped_mbtowc": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nucs4swapped_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  /* This function assumes that 'unsigned int' has exactly 32 bits. */\n  if (sizeof(unsigned int) != 4) abort();\n\n  if (n >= 4) {\n    unsigned int x = *(const unsigned int *)s;\n    x = (x >> 24) | ((x >> 8) & 0xff00) | ((x & 0xff00) << 8) | (x << 24);\n    *pwc = x;\n    return 4;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4swapped_wctomb": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\nucs4swapped_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  /* This function assumes that 'unsigned int' has exactly 32 bits. */\n  if (sizeof(unsigned int) != 4) abort();\n\n  if (n >= 4) {\n    unsigned int x = wc;\n    x = (x >> 24) | ((x >> 8) & 0xff00) | ((x & 0xff00) << 8) | (x << 24);\n    *(unsigned int *)r = x;\n    return 4;\n  } else\n    return RET_TOOSMALL;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/uhc_1.h": {
    "uhc_1_mbtowc": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static int\nuhc_1_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0x81 && c1 <= 0xa0)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x41 && c2 < 0x5b) || (c2 >= 0x61 && c2 < 0x7b) || (c2 >= 0x81 && c2 < 0xff)) {\n        unsigned int row = c1 - 0x81;\n        unsigned int col = c2 - (c2 >= 0x81 ? 0x4d : c2 >= 0x61 ? 0x47 : 0x41);\n        unsigned int i = 178 * row + col;\n        if (i < 5696) {\n          *pwc = (ucs4_t) (uhc_1_2uni_main_page81[2*row+(col>=89?1:0)] + uhc_1_2uni_page81[i]);\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 22,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "uhc_1_wctomb": {
      "start_point": [
        1697,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "static int\nuhc_1_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    if (wc >= 0xac00 && wc < 0xc8b0) {\n      const Summary16 *summary = &uhc_1_uni2indx_pageac[(wc>>4)-0xac0];\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        used += summary->indx;\n        c = uhc_1_2charset_main[used>>7] + uhc_1_2charset[used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/uhc_2.h": {
    "uhc_2_mbtowc": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nuhc_2_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c1 = s[0];\n  if ((c1 >= 0xa1 && c1 <= 0xc6)) {\n    if (n >= 2) {\n      unsigned char c2 = s[1];\n      if ((c2 >= 0x41 && c2 < 0x5b) || (c2 >= 0x61 && c2 < 0x7b) || (c2 >= 0x81 && c2 < 0xa1)) {\n        unsigned int row = c1 - 0xa1;\n        unsigned int col = c2 - (c2 >= 0x81 ? 0x4d : c2 >= 0x61 ? 0x47 : 0x41);\n        unsigned int i = 84 * row + col;\n        if (i < 3126) {\n          *pwc = (ucs4_t) (uhc_2_2uni_main_pagea1[2*row+(col>=42?1:0)] + uhc_2_2uni_pagea1[i]);\n          return 2;\n        }\n      }\n      return RET_ILSEQ;\n    }\n    return RET_TOOFEW(0);\n  }\n  return RET_ILSEQ;\n}",
      "lines": 22,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "uhc_2_wctomb": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "static int\nuhc_2_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (n >= 2) {\n    if (wc >= 0xc800 && wc < 0xd7b0) {\n      const Summary16 *summary = &uhc_2_uni2indx_pagec8[(wc>>4)-0xc80];\n      unsigned short used = summary->used;\n      unsigned int i = wc & 0x0f;\n      if (used & ((unsigned short) 1 << i)) {\n        unsigned short c;\n        /* Keep in 'used' only the bits 0..i-1. */\n        used &= ((unsigned short) 1 << i) - 1;\n        /* Add 'summary->indx' and the number of bits set in 'used'. */\n        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\n        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\n        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\n        used = (used & 0x00ff) + (used >> 8);\n        used += summary->indx;\n        c = uhc_2_2charset_main[used>>6] + uhc_2_2charset[used];\n        r[0] = (c >> 8); r[1] = (c & 0xff);\n        return 2;\n      }\n    }\n    return RET_ILUNI;\n  }\n  return RET_TOOSMALL;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf16.h": {
    "utf16_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int\nutf16_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  for (; n >= 2 && count <= RET_COUNT_MAX && count <= INT_MAX-2;) {\n    ucs4_t wc = (state ? s[0] + (s[1] << 8) : (s[0] << 8) + s[1]);\n    if (wc == 0xfeff) {\n    } else if (wc == 0xfffe) {\n      state ^= 1;\n    } else if (wc >= 0xd800 && wc < 0xdc00) {\n      if (n >= 4) {\n        ucs4_t wc2 = (state ? s[2] + (s[3] << 8) : (s[2] << 8) + s[3]);\n        if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n          goto ilseq;\n        *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n        conv->istate = state;\n        return count+4;\n      } else\n        break;\n    } else if (wc >= 0xdc00 && wc < 0xe000) {\n      goto ilseq;\n    } else {\n      *pwc = wc;\n      conv->istate = state;\n      return count+2;\n    }\n    s += 2; n -= 2; count += 2;\n  }\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 36,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16_wctomb": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "static int\nutf16_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc != 0xfffe && !(wc >= 0xd800 && wc < 0xe000)) {\n    int count = 0;\n    if (!conv->ostate) {\n      if (n >= 2) {\n        r[0] = 0xFE;\n        r[1] = 0xFF;\n        r += 2; n -= 2; count += 2;\n      } else\n        return RET_TOOSMALL;\n    }\n    if (wc < 0x10000) {\n      if (n >= 2) {\n        r[0] = (unsigned char) (wc >> 8);\n        r[1] = (unsigned char) wc;\n        conv->ostate = 1;\n        return count+2;\n      } else\n        return RET_TOOSMALL;\n    }\n    else if (wc < 0x110000) {\n      if (n >= 4) {\n        ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n        ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n        r[0] = (unsigned char) (wc1 >> 8);\n        r[1] = (unsigned char) wc1;\n        r[2] = (unsigned char) (wc2 >> 8);\n        r[3] = (unsigned char) wc2;\n        conv->ostate = 1;\n        return count+4;\n      } else\n        return RET_TOOSMALL;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 38,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf16be.h": {
    "utf16be_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nutf16be_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  int count = 0;\n  if (n >= 2) {\n    ucs4_t wc = (s[0] << 8) + s[1];\n    if (wc >= 0xd800 && wc < 0xdc00) {\n      if (n >= 4) {\n        ucs4_t wc2 = (s[2] << 8) + s[3];\n        if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n          goto ilseq;\n        *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n        return count+4;\n      }\n    } else if (wc >= 0xdc00 && wc < 0xe000) {\n      goto ilseq;\n    } else {\n      *pwc = wc;\n      return count+2;\n    }\n  }\n  return RET_TOOFEW(count);\n\nilseq:\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 26,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16be_wctomb": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nutf16be_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000)) {\n    if (wc < 0x10000) {\n      if (n >= 2) {\n        r[0] = (unsigned char) (wc >> 8);\n        r[1] = (unsigned char) wc;\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n    else if (wc < 0x110000) {\n      if (n >= 4) {\n        ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n        ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n        r[0] = (unsigned char) (wc1 >> 8);\n        r[1] = (unsigned char) wc1;\n        r[2] = (unsigned char) (wc2 >> 8);\n        r[3] = (unsigned char) wc2;\n        return 4;\n      } else\n        return RET_TOOSMALL;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf16le.h": {
    "utf16le_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int\nutf16le_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  int count = 0;\n  if (n >= 2) {\n    ucs4_t wc = s[0] + (s[1] << 8);\n    if (wc >= 0xd800 && wc < 0xdc00) {\n      if (n >= 4) {\n        ucs4_t wc2 = s[2] + (s[3] << 8);\n        if (!(wc2 >= 0xdc00 && wc2 < 0xe000))\n          goto ilseq;\n        *pwc = 0x10000 + ((wc - 0xd800) << 10) + (wc2 - 0xdc00);\n        return count+4;\n      }\n    } else if (wc >= 0xdc00 && wc < 0xe000) {\n      goto ilseq;\n    } else {\n      *pwc = wc;\n      return count+2;\n    }\n  }\n  return RET_TOOFEW(count);\n\nilseq:\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 26,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf16le_wctomb": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int\nutf16le_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (!(wc >= 0xd800 && wc < 0xe000)) {\n    if (wc < 0x10000) {\n      if (n >= 2) {\n        r[0] = (unsigned char) wc;\n        r[1] = (unsigned char) (wc >> 8);\n        return 2;\n      } else\n        return RET_TOOSMALL;\n    }\n    else if (wc < 0x110000) {\n      if (n >= 4) {\n        ucs4_t wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n        ucs4_t wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n        r[0] = (unsigned char) wc1;\n        r[1] = (unsigned char) (wc1 >> 8);\n        r[2] = (unsigned char) wc2;\n        r[3] = (unsigned char) (wc2 >> 8);\n        return 4;\n      } else\n        return RET_TOOSMALL;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 27,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf32.h": {
    "utf32_mbtowc": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nutf32_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0;\n  for (; n >= 4 && count <= RET_COUNT_MAX && count <= INT_MAX-4;) {\n    ucs4_t wc = (state\n                  ? s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24)\n                  : (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3]);\n    if (wc == 0x0000feff) {\n    } else if (wc == 0xfffe0000u) {\n      state ^= 1;\n    } else {\n      if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n        *pwc = wc;\n        conv->istate = state;\n        return count+4;\n      } else {\n        conv->istate = state;\n        return RET_SHIFT_ILSEQ(count);\n      }\n    }\n    s += 4; n -= 4; count += 4;\n  }\n  conv->istate = state;\n  return RET_TOOFEW(count);\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32_wctomb": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nutf32_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    int count = 0;\n    if (!conv->ostate) {\n      if (n >= 4) {\n        r[0] = 0x00;\n        r[1] = 0x00;\n        r[2] = 0xFE;\n        r[3] = 0xFF;\n        r += 4; n -= 4; count += 4;\n      } else\n        return RET_TOOSMALL;\n    }\n    if (wc < 0x110000) {\n      if (n >= 4) {\n        r[0] = 0;\n        r[1] = (unsigned char) (wc >> 16);\n        r[2] = (unsigned char) (wc >> 8);\n        r[3] = (unsigned char) wc;\n        conv->ostate = 1;\n        return count+4;\n      } else\n        return RET_TOOSMALL;\n    }\n  }\n  return RET_ILUNI;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf32be.h": {
    "utf32be_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\nutf32be_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4) {\n    ucs4_t wc = (s[0] << 24) + (s[1] << 16) + (s[2] << 8) + s[3];\n    if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n      *pwc = wc;\n      return 4;\n    } else\n      return RET_ILSEQ;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32be_wctomb": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\nutf32be_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 4) {\n      r[0] = 0;\n      r[1] = (unsigned char) (wc >> 16);\n      r[2] = (unsigned char) (wc >> 8);\n      r[3] = (unsigned char) wc;\n      return 4;\n    } else\n      return RET_TOOSMALL;\n  }\n  return RET_ILUNI;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf32le.h": {
    "utf32le_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\nutf32le_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  if (n >= 4) {\n    ucs4_t wc = s[0] + (s[1] << 8) + (s[2] << 16) + (s[3] << 24);\n    if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n      *pwc = wc;\n      return 4;\n    } else\n      return RET_ILSEQ;\n  }\n  return RET_TOOFEW(0);\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf32le_wctomb": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\nutf32le_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  if (wc < 0x110000 && !(wc >= 0xd800 && wc < 0xe000)) {\n    if (n >= 4) {\n      r[0] = (unsigned char) wc;\n      r[1] = (unsigned char) (wc >> 8);\n      r[2] = (unsigned char) (wc >> 16);\n      r[3] = 0;\n      return 4;\n    } else\n      return RET_TOOSMALL;\n  }\n  return RET_ILUNI;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf7.h": {
    "utf7_mbtowc": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nutf7_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  state_t state = conv->istate;\n  int count = 0; /* number of input bytes already read */\n  if (state & 3)\n    goto active;\n  else\n    goto inactive;\n\ninactive:\n  {\n    /* Here (state & 3) == 0 */\n    if (n < count+1)\n      goto none;\n    {\n      unsigned char c = *s;\n      if (isxdirect(c)) {\n        *pwc = (ucs4_t) c;\n        conv->istate = state;\n        return count+1;\n      }\n      if (c == '+') {\n        if (n < count+2)\n          goto none;\n        if (s[1] == '-') {\n          *pwc = (ucs4_t) '+';\n          conv->istate = state;\n          return count+2;\n        }\n        s++; count++;\n        state = 1;\n        goto active;\n      }\n      goto ilseq;\n    }\n  }\n\nactive:\n  {\n    /* base64 encoding active */\n    unsigned int wc = 0;\n    state_t base64state = state;\n    unsigned int kmax = 2; /* number of payload bytes to read */\n    unsigned int k = 0; /* number of payload bytes already read */\n    unsigned int base64count = 0; /* number of base64 bytes already read */\n    for (;;) {\n      unsigned char c = *s;\n      unsigned int i;\n      if (c >= 'A' && c <= 'Z')\n        i = c-'A';\n      else if (c >= 'a' && c <= 'z')\n        i = c-'a'+26;\n      else if (c >= '0' && c <= '9')\n        i = c-'0'+52;\n      else if (c == '+')\n        i = 62;\n      else if (c == '/')\n        i = 63;\n      else {\n        /* c terminates base64 encoding */\n        if (base64state & -4)\n          goto ilseq; /* data must be 0, otherwise illegal */\n        if (base64count)\n          goto ilseq; /* partial UTF-16 characters are invalid */\n        if (c == '-') {\n          s++; count++;\n        }\n        state = 0;\n        goto inactive;\n      }\n      s++; base64count++;\n      /* read 6 bits: 0 <= i < 64 */\n      switch (base64state & 3) {\n        case 1: /* inside base64, no pending bits */\n          base64state = (i << 2) | 0; break;\n        case 0: /* inside base64, 6 bits remain from 1st byte */\n          wc = (wc << 8) | (base64state & -4) | (i >> 4); k++;\n          base64state = ((i & 15) << 4) | 2; break;\n        case 2: /* inside base64, 4 bits remain from 2nd byte */\n          wc = (wc << 8) | (base64state & -4) | (i >> 2); k++;\n          base64state = ((i & 3) << 6) | 3; break;\n        case 3: /* inside base64, 2 bits remain from 3rd byte */\n          wc = (wc << 8) | (base64state & -4) | i; k++;\n          base64state = 1; break;\n      }\n      if (k == kmax) {\n        /* UTF-16: When we see a High Surrogate, we must also decode\n           the following Low Surrogate. */\n        if (kmax == 2 && (wc >= 0xd800 && wc < 0xdc00))\n          kmax = 4;\n        else\n          break;\n      }\n      if (n < count+base64count+1)\n        goto none;\n    }\n    /* Here k = kmax > 0, hence base64count > 0. */\n    if ((base64state & 3) == 0) abort();\n    if (kmax == 4) {\n      ucs4_t wc1 = wc >> 16;\n      ucs4_t wc2 = wc & 0xffff;\n      if (!(wc1 >= 0xd800 && wc1 < 0xdc00)) abort();\n      if (!(wc2 >= 0xdc00 && wc2 < 0xe000)) goto ilseq;\n      *pwc = 0x10000 + ((wc1 - 0xd800) << 10) + (wc2 - 0xdc00);\n    } else {\n      *pwc = wc;\n    }\n    conv->istate = base64state;\n    return count+base64count;\n  }\n\nnone:\n  conv->istate = state;\n  return RET_TOOFEW(count);\n\nilseq:\n  conv->istate = state;\n  return RET_SHIFT_ILSEQ(count);\n}",
      "lines": 120,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf7_wctomb": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static int\nutf7_wctomb (conv_t conv, unsigned char *r, ucs4_t iwc, size_t n)\n{\n  state_t state = conv->ostate;\n  unsigned int wc = iwc;\n  int count = 0;\n  if (state & 3)\n    goto active;\n\n/*inactive:*/\n  {\n    if (UTF7_ENCODE_OPTIONAL_CHARS ? isdirect(wc) : isxdirect(wc)) {\n      r[0] = (unsigned char) wc;\n      /*conv->ostate = state;*/\n      return 1;\n    } else {\n      *r++ = '+';\n      if (wc == '+') {\n        if (n < 2)\n          return RET_TOOSMALL;\n        *r = '-';\n        /*conv->ostate = state;*/\n        return 2;\n      }\n      count = 1;\n      state = 1;\n      goto active;\n    }\n  }\n\nactive:\n  {\n    /* base64 encoding active */\n    if (UTF7_ENCODE_OPTIONAL_CHARS ? isdirect(wc) : isxdirect(wc)) {\n      /* deactivate base64 encoding */\n      count += ((state & 3) >= 2 ? 1 : 0) + (isxbase64(wc) ? 1 : 0) + 1;\n      if (n < count)\n        return RET_TOOSMALL;\n      if ((state & 3) >= 2) {\n        unsigned int i = state & -4;\n        unsigned char c;\n        if (i < 26)\n          c = i+'A';\n        else if (i < 52)\n          c = i-26+'a';\n        else if (i < 62)\n          c = i-52+'0';\n        else if (i == 62)\n          c = '+';\n        else if (i == 63)\n          c = '/';\n        else\n          abort();\n        *r++ = c;\n      }\n      if (isxbase64(wc))\n        *r++ = '-';\n      state = 0;\n      *r++ = (unsigned char) wc;\n      conv->ostate = state;\n      return count;\n    } else {\n      unsigned int k; /* number of payload bytes to write */\n      if (wc < 0x10000) {\n        k = 2;\n        count += ((state & 3) >= 2 ? 3 : 2);\n      } else if (wc < 0x110000) {\n        unsigned int wc1 = 0xd800 + ((wc - 0x10000) >> 10);\n        unsigned int wc2 = 0xdc00 + ((wc - 0x10000) & 0x3ff);\n        wc = (wc1 << 16) | wc2;\n        k = 4;\n        count += ((state & 3) >= 3 ? 6 : 5);\n      } else\n        return RET_ILUNI;\n      if (n < count)\n        return RET_TOOSMALL;\n      for (;;) {\n        unsigned int i;\n        unsigned char c;\n        switch (state & 3) {\n          case 0: /* inside base64, 6 bits known for 4th byte */\n            c = (state & -4) >> 2; state = 1; break;\n          case 1: /* inside base64, no pending bits */\n            i = (wc >> (8 * --k)) & 0xff;\n            c = i >> 2; state = ((i & 3) << 4) | 2; break;\n          case 2: /* inside base64, 2 bits known for 2nd byte */\n            i = (wc >> (8 * --k)) & 0xff;\n            c = (state & -4) | (i >> 4); state = ((i & 15) << 2) | 3; break;\n          case 3: /* inside base64, 4 bits known for 3rd byte */\n            i = (wc >> (8 * --k)) & 0xff;\n            c = (state & -4) | (i >> 6); state = ((i & 63) << 2) | 0; break;\n          default: abort(); /* stupid gcc */\n        }\n        if (c < 26)\n          c = c+'A';\n        else if (c < 52)\n          c = c-26+'a';\n        else if (c < 62)\n          c = c-52+'0';\n        else if (c == 62)\n          c = '+';\n        else if (c == 63)\n          c = '/';\n        else\n          abort();\n        *r++ = c;\n        if ((state & 3) && (k == 0))\n          break;\n      }\n      conv->ostate = state;\n      return count;\n    }\n  }\n}",
      "lines": 114,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf7_reset": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static int\nutf7_reset (conv_t conv, unsigned char *r, size_t n)\n{\n  state_t state = conv->ostate;\n  if (state & 3) {\n    /* deactivate base64 encoding */\n    unsigned int count = ((state & 3) >= 2 ? 1 : 0) + 1;\n    if (n < count)\n      return RET_TOOSMALL;\n    if ((state & 3) >= 2) {\n      unsigned int i = state & -4;\n      unsigned char c;\n      if (i < 26)\n        c = i+'A';\n      else if (i < 52)\n        c = i-26+'a';\n      else if (i < 62)\n        c = i-52+'0';\n      else if (i == 62)\n        c = '+';\n      else if (i == 63)\n        c = '/';\n      else\n        abort();\n      *r++ = c;\n    }\n    *r++ = '-';\n    /* conv->ostate = 0; will be done by the caller */\n    return count;\n  } else\n    return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/utf8.h": {
    "utf8_mbtowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nutf8_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = s[0];\n\n  if (c < 0x80) {\n    *pwc = c;\n    return 1;\n  } else if (c < 0xc2) {\n    return RET_ILSEQ;\n  } else if (c < 0xe0) {\n    if (n < 2)\n      return RET_TOOFEW(0);\n    if (!((s[1] ^ 0x80) < 0x40))\n      return RET_ILSEQ;\n    *pwc = ((ucs4_t) (c & 0x1f) << 6)\n           | (ucs4_t) (s[1] ^ 0x80);\n    return 2;\n  } else if (c < 0xf0) {\n    if (n < 3)\n      return RET_TOOFEW(0);\n    if (!((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n          && (c >= 0xe1 || s[1] >= 0xa0)\n          && (c != 0xed || s[1] < 0xa0)))\n      return RET_ILSEQ;\n    *pwc = ((ucs4_t) (c & 0x0f) << 12)\n           | ((ucs4_t) (s[1] ^ 0x80) << 6)\n           | (ucs4_t) (s[2] ^ 0x80);\n    return 3;\n  } else if (c < 0xf8 && sizeof(ucs4_t)*8 >= 32) {\n    if (n < 4)\n      return RET_TOOFEW(0);\n    if (!((s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n          && (s[3] ^ 0x80) < 0x40\n          && (c >= 0xf1 || s[1] >= 0x90)\n          && (c < 0xf4 || (c == 0xf4 && s[1] < 0x90))))\n      return RET_ILSEQ;\n    *pwc = ((ucs4_t) (c & 0x07) << 18)\n           | ((ucs4_t) (s[1] ^ 0x80) << 12)\n           | ((ucs4_t) (s[2] ^ 0x80) << 6)\n           | (ucs4_t) (s[3] ^ 0x80);\n    return 4;\n  } else\n    return RET_ILSEQ;\n}",
      "lines": 45,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "utf8_wctomb": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\nutf8_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n) /* n == 0 is acceptable */\n{\n  int count;\n  if (wc < 0x80)\n    count = 1;\n  else if (wc < 0x800)\n    count = 2;\n  else if (wc < 0x10000) {\n    if (wc < 0xd800 || wc >= 0xe000)\n      count = 3;\n    else\n      return RET_ILUNI;\n  } else if (wc < 0x110000)\n    count = 4;\n  else\n    return RET_ILUNI;\n  if (n < count)\n    return RET_TOOSMALL;\n  switch (count) { /* note: code falls through cases! */\n    case 4: r[3] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0x10000;\n    case 3: r[2] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0x800;\n    case 2: r[1] = 0x80 | (wc & 0x3f); wc = wc >> 6; wc |= 0xc0;\n    case 1: r[0] = wc;\n  }\n  return count;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/lib/vietcomb.h": {},
  "libiconv/libiconv-1.15/lib/viscii.h": {
    "viscii_mbtowc": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int\nviscii_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\n{\n  unsigned char c = *s;\n  if (c < 0x20)\n    *pwc = (ucs4_t) viscii_2uni_1[c];\n  else if (c < 0x80)\n    *pwc = (ucs4_t) c;\n  else\n    *pwc = (ucs4_t) viscii_2uni_2[c-0x80];\n  return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "viscii_wctomb": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static int\nviscii_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\n{\n  unsigned char c = 0;\n  if (wc < 0x0080 && (wc >= 0x0020 || (0x42100064 & (1 << wc)) == 0)) {\n    *r = wc;\n    return 1;\n  }\n  else if (wc >= 0x00c0 && wc < 0x01b8)\n    c = viscii_page00[wc-0x00c0];\n  else if (wc >= 0x1ea0 && wc < 0x1f00)\n    c = viscii_page1e[wc-0x1ea0];\n  if (c != 0) {\n    *r = c;\n    return 1;\n  }\n  return RET_ILUNI;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/include/export.h": {},
  "libiconv/libiconv-1.15/libcharset/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot && 2 + strlen (pdot + 1) + 1 <= sizeof (buf))\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/lib/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n                            const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n         relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n        {\n          memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n          orig_prefix = memory;\n          memory += orig_prefix_len + 1;\n          memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n          curr_prefix = memory;\n          return;\n        }\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "char *\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)\n{\n  char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n        p--;\n        if (ISSLASH (*p))\n          break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n        bool same = false;\n        const char *rpi = rp;\n        const char *cpi = cp;\n\n        while (rpi > rel_installdir && cpi > cp_base)\n          {\n            rpi--;\n            cpi--;\n            if (ISSLASH (*rpi) || ISSLASH (*cpi))\n              {\n                if (ISSLASH (*rpi) && ISSLASH (*cpi))\n                  same = true;\n                break;\n              }\n            /* Do case-insensitive comparison if the file system is always or\n               often case-insensitive.  It's better to accept the comparison\n               if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */\n            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n              break;\n#else\n            if (*rpi != *cpi)\n              break;\n#endif\n          }\n        if (!same)\n          break;\n        /* The last pathname component was the same.  opi and cpi now point\n           to the slash before it.  */\n        rp = rpi;\n        cp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      {\n        /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n        free (curr_installdir);\n        return NULL;\n      }\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n        {\n          free (curr_installdir);\n          return NULL;\n        }\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      free (curr_installdir);\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      shared_library_fullname = strdup (location);\n    }\n\n  return TRUE;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "_DLL_InitTerm": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "unsigned long _System\n_DLL_InitTerm (unsigned long hModule, unsigned long ulFlag)\n{\n  static char location[CCHMAXPATH];\n\n  switch (ulFlag)\n    {\n      case 0:\n        if (_CRT_init () == -1)\n          return 0;\n\n        __ctordtorInit();\n\n        /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/1247_L2H_DosQueryModuleNameSy.html\n           for specification of DosQueryModuleName(). */\n        if (DosQueryModuleName (hModule, sizeof (location), location))\n          return 0;\n\n        _fnslashify (location);\n        shared_library_fullname = strdup (location);\n        break;\n\n      case 1:\n        __ctordtorTerm();\n\n        _CRT_term ();\n        break;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "unsigned long _System",
        "unsigned",
        "long",
        "_System"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__\n  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()\n     function.\n     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.\n     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on\n     Cygwin 1.7.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n        {\n          unsigned long start, end;\n          int c;\n\n          if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n            break;\n          if (address >= start && address <= end - 1)\n            {\n              /* Found it.  Now see if this line contains a filename.  */\n              while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n                continue;\n              if (c == '/')\n                {\n                  size_t size;\n                  int len;\n\n                  ungetc (c, fp);\n                  shared_library_fullname = NULL; size = 0;\n                  len = getline (&shared_library_fullname, &size, fp);\n                  if (len >= 0)\n                    {\n                      /* Success: filled shared_library_fullname.  */\n                      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n                        shared_library_fullname[len - 1] = '\\0';\n                    }\n                }\n              break;\n            }\n          while (c = getc (fp), c != EOF && c != '\\n')\n            continue;\n        }\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if (!((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) \\\n     && !defined __EMX__)\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n         set through the main program's set_program_name_and_installdir\n         function.  This is sufficient in the case that the library has\n         initially been installed in the same orig_prefix.  But we can do\n         better, to also cover the cases that 1. it has been installed\n         in a different prefix before being moved to orig_prefix and (later)\n         to curr_prefix, 2. unlike the program, it has not moved away from\n         orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      char *curr_prefix_better;\n\n      curr_prefix_better =\n        compute_curr_prefix (orig_installprefix, orig_installdir,\n                             get_shared_library_fullname ());\n\n      set_relocation_prefix (orig_installprefix,\n                             curr_prefix_better != NULL\n                             ? curr_prefix_better\n                             : curr_prefix);\n\n      if (curr_prefix_better != NULL)\n        free (curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like file systems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n        {\n          /* pathname equals orig_prefix.  */\n          char *result = (char *) xmalloc (strlen (curr_prefix) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, curr_prefix);\n              return result;\n            }\n        }\n      else if (ISSLASH (pathname[orig_prefix_len]))\n        {\n          /* pathname starts with orig_prefix.  */\n          const char *pathname_tail = &pathname[orig_prefix_len];\n          char *result =\n            (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, curr_prefix, curr_prefix_len);\n              strcpy (result + curr_prefix_len, pathname_tail);\n              return result;\n            }\n        }\n    }\n\n#ifdef __EMX__\n# ifdef __KLIBC__\n#  undef strncmp\n\n  if (pathname && strncmp (pathname, \"/@unixroot\", 10) == 0\n      && (pathname[10] == '\\0' || pathname[10] == '/' || pathname[10] == '\\\\'))\n    {\n      /* kLIBC itself processes /@unixroot prefix */\n\n      return pathname;\n    }\n  else\n# endif\n  if (pathname && ISSLASH (pathname[0]))\n    {\n      const char *unixroot = getenv (\"UNIXROOT\");\n\n      if (unixroot && HAS_DEVICE (unixroot) && !unixroot[2])\n        {\n          char *result = (char *) xmalloc (2 + strlen (pathname) + 1);\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, unixroot);\n              strcpy (result + 2, pathname);\n              return result;\n            }\n        }\n    }\n#endif\n\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 110,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/lib/relocatable.h": {},
  "libiconv/libiconv-1.15/libcharset/tools/locale_charset.c": {
    "main": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        12,
        1
      ],
      "content": "int main ()\n{\n  setlocale(LC_ALL, \"\");\n  printf(\"%s\\n\", locale_charset());\n  exit(0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/tools/locale_codeset.c": {
    "main": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        14,
        1
      ],
      "content": "int main ()\n{\n  setlocale(LC_ALL, \"\");\n  printf(\"%s\\n\", nl_langinfo(CODESET));\n  exit(0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/tools/locale_monthnames.c": {
    "main": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "int main ()\n{\n  setlocale(LC_ALL, \"\");\n  printf(\"%s\\n\", nl_langinfo(MON_1));\n  printf(\"%s\\n\", nl_langinfo(MON_2));\n  printf(\"%s\\n\", nl_langinfo(MON_3));\n  printf(\"%s\\n\", nl_langinfo(MON_4));\n  printf(\"%s\\n\", nl_langinfo(MON_5));\n  printf(\"%s\\n\", nl_langinfo(MON_6));\n  printf(\"%s\\n\", nl_langinfo(MON_7));\n  printf(\"%s\\n\", nl_langinfo(MON_8));\n  printf(\"%s\\n\", nl_langinfo(MON_9));\n  printf(\"%s\\n\", nl_langinfo(MON_10));\n  printf(\"%s\\n\", nl_langinfo(MON_11));\n  printf(\"%s\\n\", nl_langinfo(MON_12));\n  exit(0);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/libcharset/tools/locale_x11encoding.c": {
    "main": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  Display* display;\n  XTextProperty textprop;\n  char* input;\n\n  if (argc != 1)\n    exit(1);\n\n  setlocale(LC_CTYPE,\"\");\n\n  display = XOpenDisplay(NULL);\n  if (display == NULL) {\n    fprintf(stderr,\"cannot open display\\n\");\n    exit(1);\n  }\n\n  input = \"\";\n  if (XmbTextListToTextProperty(display, &input, 1, XTextStyle, &textprop) != Success) {\n    fprintf(stderr,\"XmbTextListToTextProperty failed\\n\");\n    exit(1);\n  }\n  assert(textprop.format == 8);\n  assert(textprop.nitems == 0);\n\n  printf(\"%s\\n\", XGetAtomName(display, textprop.encoding));\n\n  XCloseDisplay(display);\n\n  exit(0);\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/src/iconv.c": {
    "error": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n  fflush(stdout);\n  fprintf(stderr,\"%s: \",program_name);\n  va_start(args,message);\n  vfprintf(stderr,message,args);\n  va_end(args);\n  if (errnum) {\n    const char *s = strerror(errnum);\n    if (s == NULL)\n      s = \"Unknown system error\";\n  }\n  putc('\\n',stderr);\n  fflush(stderr);\n  if (status)\n    exit(status);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static void usage (int exitcode)\n{\n  if (exitcode != 0) {\n    const char* helpstring1 =\n      /* TRANSLATORS: The first line of the short usage message.  */\n      _(\"Usage: iconv [-c] [-s] [-f fromcode] [-t tocode] [file ...]\");\n    const char* helpstring2 =\n      /* TRANSLATORS: The second line of the short usage message.\n         Align it correctly against the first line.  */\n      _(\"or:    iconv -l\");\n    fprintf(stderr, \"%s\\n%s\\n\", helpstring1, helpstring2);\n    fprintf(stderr, _(\"Try '%s --help' for more information.\\n\"), program_name);\n  } else {\n    /* xgettext: no-wrap */\n    /* TRANSLATORS: The first line of the long usage message.\n       The %s placeholder expands to the program name.  */\n    printf(_(\"\\\nUsage: %s [OPTION...] [-f ENCODING] [-t ENCODING] [INPUTFILE...]\\n\"),\n           program_name);\n    /* xgettext: no-wrap */\n    /* TRANSLATORS: The second line of the long usage message.\n       Align it correctly against the first line.\n       The %s placeholder expands to the program name.  */\n    printf(_(\"\\\nor:    %s -l\\n\"),\n           program_name);\n    printf(\"\\n\");\n    /* xgettext: no-wrap */\n    /* TRANSLATORS: Description of the iconv program.  */\n    printf(_(\"\\\nConverts text from one encoding to another encoding.\\n\"));\n    printf(\"\\n\");\n    /* xgettext: no-wrap */\n    printf(_(\"\\\nOptions controlling the input and output format:\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  -f ENCODING, --from-code=ENCODING\\n\\\n                              the encoding of the input\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  -t ENCODING, --to-code=ENCODING\\n\\\n                              the encoding of the output\\n\"));\n    printf(\"\\n\");\n    /* xgettext: no-wrap */\n    printf(_(\"\\\nOptions controlling conversion problems:\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  -c                          discard unconvertible characters\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  --unicode-subst=FORMATSTRING\\n\\\n                              substitution for unconvertible Unicode characters\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  --byte-subst=FORMATSTRING   substitution for unconvertible bytes\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  --widechar-subst=FORMATSTRING\\n\\\n                              substitution for unconvertible wide characters\\n\"));\n    printf(\"\\n\");\n    /* xgettext: no-wrap */\n    printf(_(\"\\\nOptions controlling error output:\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  -s, --silent                suppress error messages about conversion problems\\n\"));\n    printf(\"\\n\");\n    /* xgettext: no-wrap */\n    printf(_(\"\\\nInformative output:\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  -l, --list                  list the supported encodings\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  --help                      display this help and exit\\n\"));\n    /* xgettext: no-wrap */\n    printf(_(\"\\\n  --version                   output version information and exit\\n\"));\n    printf(\"\\n\");\n    /* TRANSLATORS: The placeholder indicates the bug-reporting address\n       for this package.  Please add _another line_ saying\n       \"Report translation bugs to <...>\\n\" with the address for translation\n       bugs (typically your translation team's web or email address).  */\n    fputs(_(\"Report bugs to <bug-gnu-libiconv@gnu.org>.\\n\"),stdout);\n  }\n  exit(exitcode);\n}",
      "lines": 90,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_version": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static void print_version (void)\n{\n  printf(\"iconv (GNU libiconv %d.%d)\\n\",\n         _libiconv_version >> 8, _libiconv_version & 0xff);\n  printf(\"Copyright (C) %s Free Software Foundation, Inc.\\n\", \"2000-2017\");\n  /* xgettext: no-wrap */\n  fputs (_(\"\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\"),stdout);\n  /* TRANSLATORS: The %s placeholder expands to an author's name.  */\n  printf(_(\"Written by %s.\\n\"),\"Bruno Haible\");\n  exit(EXIT_SUCCESS);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_one": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static int print_one (unsigned int namescount, const char * const * names,\n                      void* data)\n{\n  unsigned int i;\n  (void)data;\n  for (i = 0; i < namescount; i++) {\n    if (i > 0)\n      putc(' ',stdout);\n    fputs(names[i],stdout);\n  }\n  putc('\\n',stdout);\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "update_line_column": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static void update_line_column (unsigned int uc, void* data)\n{\n  if (uc == 0x000A) {\n    line++;\n    column = 0;\n  } else {\n    int width = uc_width(uc, cjkcode);\n    if (width >= 0)\n      column += width;\n    else if (uc == 0x0009)\n      column += 8 - (column % 8);\n  }\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_subst_formatstring": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static size_t check_subst_formatstring (const char *format, const char *param_name)\n{\n  /* C format strings are described in POSIX (IEEE P1003.1 2001), section\n     XSH 3 fprintf().  See also Linux fprintf(3) manual page.\n     For simplicity, we don't accept\n       - the '%m$' reordering syntax,\n       - the 'I' flag,\n       - width specifications referring to an argument,\n       - precision specifications referring to an argument,\n       - size specifiers,\n       - format specifiers other than 'o', 'u', 'x', 'X'.\n     What remains?\n     A directive\n       - starts with '%',\n       - is optionally followed by any of the characters '#', '0', '-', ' ',\n         '+', \"'\", each of which acts as a flag,\n       - is optionally followed by a width specification: a nonempty digit\n         sequence,\n       - is optionally followed by '.' and a precision specification: a\n         nonempty digit sequence,\n       - is finished by a specifier\n         - '%', that needs no argument,\n         - 'o', 'u', 'x', 'X', that need an unsigned integer argument.\n   */\n  size_t maxsize = 0;\n  unsigned int unnumbered_arg_count = 0;\n\n  for (; *format != '\\0';) {\n    if (*format++ == '%') {\n      /* A directive. */\n      unsigned int width = 0;\n      unsigned int precision = 0;\n      unsigned int length;\n      /* Parse flags. */\n      for (;;) {\n        if (*format == ' ' || *format == '+' || *format == '-'\n            || *format == '#' || *format == '0' || *format == '\\'')\n          format++;\n        else\n          break;\n      }\n      /* Parse width. */\n      if (*format == '*')\n        error(EXIT_FAILURE,0,\n              /* TRANSLATORS: An error message.\n                 The %s placeholder expands to a command-line option.  */\n              _(\"%s argument: A format directive with a variable width is not allowed here.\"),\n              param_name);\n      if (isdigit (*format)) {\n        do {\n          width = 10*width + (*format - '0');\n          format++;\n        } while (isdigit (*format));\n      }\n      /* Parse precision. */\n      if (*format == '.') {\n        format++;\n        if (*format == '*')\n          error(EXIT_FAILURE,0,\n                /* TRANSLATORS: An error message.\n                   The %s placeholder expands to a command-line option.  */\n                _(\"%s argument: A format directive with a variable precision is not allowed here.\"),\n                param_name);\n        if (isdigit (*format)) {\n          do {\n            precision = 10*precision + (*format - '0');\n            format++;\n          } while (isdigit (*format));\n        }\n      }\n      /* Parse size. */\n      switch (*format) {\n        case 'h': case 'l': case 'L': case 'q':\n        case 'j': case 'z': case 'Z': case 't':\n          error(EXIT_FAILURE,0,\n                /* TRANSLATORS: An error message.\n                   The %s placeholder expands to a command-line option.  */\n                _(\"%s argument: A format directive with a size is not allowed here.\"),\n                param_name);\n      }\n      /* Parse end of directive. */\n      switch (*format) {\n        case '%':\n          length = 1;\n          break;\n        case 'u': case 'o': case 'x': case 'X':\n          if (*format == 'u') {\n            length = (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                                     * 0.30103 /* binary -> decimal */\n                                    )\n                     + 1; /* turn floor into ceil */\n            if (length < precision)\n              length = precision;\n            length *= 2; /* estimate for FLAG_GROUP */\n            length += 1; /* account for leading sign */\n          } else if (*format == 'o') {\n            length = (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                                     * 0.333334 /* binary -> octal */\n                                    )\n                     + 1; /* turn floor into ceil */\n            if (length < precision)\n              length = precision;\n            length += 1; /* account for leading sign */\n          } else { /* 'x', 'X' */\n            length = (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                                     * 0.25 /* binary -> hexadecimal */\n                                    )\n                     + 1; /* turn floor into ceil */\n            if (length < precision)\n              length = precision;\n            length += 2; /* account for leading sign or alternate form */\n          }\n          unnumbered_arg_count++;\n          break;\n        default:\n          if (*format == '\\0')\n            error(EXIT_FAILURE,0,\n                  /* TRANSLATORS: An error message.\n                     The %s placeholder expands to a command-line option.  */\n                  _(\"%s argument: The string ends in the middle of a directive.\"),\n                  param_name);\n          else if (c_isprint(*format))\n            error(EXIT_FAILURE,0,\n                  /* TRANSLATORS: An error message.\n                     The %s placeholder expands to a command-line option.\n                     The %c placeholder expands to an unknown format directive.  */\n                  _(\"%s argument: The character '%c' is not a valid conversion specifier.\"),\n                  param_name,*format);\n          else\n            error(EXIT_FAILURE,0,\n                  /* TRANSLATORS: An error message.\n                     The %s placeholder expands to a command-line option.  */\n                  _(\"%s argument: The character that terminates the format directive is not a valid conversion specifier.\"),\n                  param_name);\n          abort(); /*NOTREACHED*/\n      }\n      format++;\n      if (length < width)\n        length = width;\n      maxsize += length;\n    } else\n      maxsize++;\n  }\n  if (unnumbered_arg_count > 1)\n    error(EXIT_FAILURE,0,\n          /* TRANSLATORS: An error message.\n             The %s placeholder expands to a command-line option.\n             The %u placeholder expands to the number of arguments consumed by the format string.  */\n          ngettext(\"%s argument: The format string consumes more than one argument: %u argument.\",\n                   \"%s argument: The format string consumes more than one argument: %u arguments.\",\n                   unnumbered_arg_count),\n          param_name,unnumbered_arg_count);\n  return maxsize;\n}",
      "lines": 154,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "subst_mb_to_uc_fallback": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "static void subst_mb_to_uc_fallback\n            (const char* inbuf, size_t inbufsize,\n             void (*write_replacement) (const unsigned int *buf, size_t buflen,\n                                        void* callback_arg),\n             void* callback_arg,\n             void* data)\n{\n  for (; inbufsize > 0; inbuf++, inbufsize--) {\n    const char* inptr;\n    size_t inbytesleft;\n    char* outptr;\n    size_t outbytesleft;\n    sprintf(ilseq_byte_subst_buffer,\n            ilseq_byte_subst, (unsigned int)(unsigned char)*inbuf);\n    inptr = ilseq_byte_subst_buffer;\n    inbytesleft = strlen(ilseq_byte_subst_buffer);\n    outptr = (char*)subst_mb_to_uc_temp_buffer;\n    outbytesleft = ilseq_byte_subst_size*sizeof(unsigned int);\n    iconv(subst_mb_to_uc_cd,NULL,NULL,NULL,NULL);\n    if (iconv(subst_mb_to_uc_cd, (ICONV_CONST char**)&inptr,&inbytesleft, &outptr,&outbytesleft)\n        == (size_t)(-1)\n        || iconv(subst_mb_to_uc_cd, NULL,NULL, &outptr,&outbytesleft)\n           == (size_t)(-1))\n      error(EXIT_FAILURE,0,\n            /* TRANSLATORS: An error message.\n               The %s placeholder expands to a piece of text, specified through --byte-subst.  */\n            _(\"cannot convert byte substitution to Unicode: %s\"),\n            ilseq_byte_subst_buffer);\n    if (!(outbytesleft%sizeof(unsigned int) == 0))\n      abort();\n    write_replacement(subst_mb_to_uc_temp_buffer,\n                      ilseq_byte_subst_size-(outbytesleft/sizeof(unsigned int)),\n                      callback_arg);\n  }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_uc_to_mb_fallback": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static void subst_uc_to_mb_fallback\n            (unsigned int code,\n             void (*write_replacement) (const char *buf, size_t buflen,\n                                        void* callback_arg),\n             void* callback_arg,\n             void* data)\n{\n  const char* inptr;\n  size_t inbytesleft;\n  char* outptr;\n  size_t outbytesleft;\n  sprintf(ilseq_unicode_subst_buffer, ilseq_unicode_subst, code);\n  inptr = ilseq_unicode_subst_buffer;\n  inbytesleft = strlen(ilseq_unicode_subst_buffer);\n  outptr = subst_uc_to_mb_temp_buffer;\n  outbytesleft = ilseq_unicode_subst_size*4;\n  iconv(subst_uc_to_mb_cd,NULL,NULL,NULL,NULL);\n  if (iconv(subst_uc_to_mb_cd, (ICONV_CONST char**)&inptr,&inbytesleft, &outptr,&outbytesleft)\n      == (size_t)(-1)\n      || iconv(subst_uc_to_mb_cd, NULL,NULL, &outptr,&outbytesleft)\n         == (size_t)(-1))\n    error(EXIT_FAILURE,0,\n          /* TRANSLATORS: An error message.\n             The %s placeholder expands to a piece of text, specified through --unicode-subst.  */\n          _(\"cannot convert unicode substitution to target encoding: %s\"),\n          ilseq_unicode_subst_buffer);\n  write_replacement(subst_uc_to_mb_temp_buffer,\n                    ilseq_unicode_subst_size*4-outbytesleft,\n                    callback_arg);\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_mb_to_wc_fallback": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static void subst_mb_to_wc_fallback\n            (const char* inbuf, size_t inbufsize,\n             void (*write_replacement) (const wchar_t *buf, size_t buflen,\n                                        void* callback_arg),\n             void* callback_arg,\n             void* data)\n{\n  for (; inbufsize > 0; inbuf++, inbufsize--) {\n    const char* inptr;\n    size_t inbytesleft;\n    char* outptr;\n    size_t outbytesleft;\n    sprintf(ilseq_byte_subst_buffer,\n            ilseq_byte_subst, (unsigned int)(unsigned char)*inbuf);\n    inptr = ilseq_byte_subst_buffer;\n    inbytesleft = strlen(ilseq_byte_subst_buffer);\n    outptr = (char*)subst_mb_to_wc_temp_buffer;\n    outbytesleft = ilseq_byte_subst_size*sizeof(wchar_t);\n    iconv(subst_mb_to_wc_cd,NULL,NULL,NULL,NULL);\n    if (iconv(subst_mb_to_wc_cd, (ICONV_CONST char**)&inptr,&inbytesleft, &outptr,&outbytesleft)\n        == (size_t)(-1)\n        || iconv(subst_mb_to_wc_cd, NULL,NULL, &outptr,&outbytesleft)\n           == (size_t)(-1))\n      error(EXIT_FAILURE,0,\n            /* TRANSLATORS: An error message.\n               The %s placeholder expands to a piece of text, specified through --byte-subst.  */\n            _(\"cannot convert byte substitution to wide string: %s\"),\n            ilseq_byte_subst_buffer);\n    if (!(outbytesleft%sizeof(wchar_t) == 0))\n      abort();\n    write_replacement(subst_mb_to_wc_temp_buffer,\n                      ilseq_byte_subst_size-(outbytesleft/sizeof(wchar_t)),\n                      callback_arg);\n  }\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_wc_to_mb_fallback": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static void subst_wc_to_mb_fallback\n            (wchar_t code,\n             void (*write_replacement) (const char *buf, size_t buflen,\n                                        void* callback_arg),\n             void* callback_arg,\n             void* data)\n{\n  const char* inptr;\n  size_t inbytesleft;\n  char* outptr;\n  size_t outbytesleft;\n  sprintf(ilseq_wchar_subst_buffer, ilseq_wchar_subst, (unsigned int) code);\n  inptr = ilseq_wchar_subst_buffer;\n  inbytesleft = strlen(ilseq_wchar_subst_buffer);\n  outptr = subst_wc_to_mb_temp_buffer;\n  outbytesleft = ilseq_wchar_subst_size*4;\n  iconv(subst_wc_to_mb_cd,NULL,NULL,NULL,NULL);\n  if (iconv(subst_wc_to_mb_cd, (ICONV_CONST char**)&inptr,&inbytesleft, &outptr,&outbytesleft)\n      == (size_t)(-1)\n      || iconv(subst_wc_to_mb_cd, NULL,NULL, &outptr,&outbytesleft)\n         == (size_t)(-1))\n    error(EXIT_FAILURE,0,\n          /* TRANSLATORS: An error message.\n             The %s placeholder expands to a piece of text, specified through --widechar-subst.  */\n          _(\"cannot convert widechar substitution to target encoding: %s\"),\n          ilseq_wchar_subst_buffer);\n  write_replacement(subst_wc_to_mb_temp_buffer,\n                    ilseq_wchar_subst_size*4-outbytesleft,\n                    callback_arg);\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_mb_to_mb_fallback": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "static void subst_mb_to_mb_fallback (const char* inbuf, size_t inbufsize)\n{\n  for (; inbufsize > 0; inbuf++, inbufsize--) {\n    const char* inptr;\n    size_t inbytesleft;\n    char* outptr;\n    size_t outbytesleft;\n    sprintf(ilseq_byte_subst_buffer,\n            ilseq_byte_subst, (unsigned int)(unsigned char)*inbuf);\n    inptr = ilseq_byte_subst_buffer;\n    inbytesleft = strlen(ilseq_byte_subst_buffer);\n    outptr = subst_mb_to_mb_temp_buffer;\n    outbytesleft = ilseq_byte_subst_size*4;\n    iconv(subst_mb_to_mb_cd,NULL,NULL,NULL,NULL);\n    if (iconv(subst_mb_to_mb_cd, (ICONV_CONST char**)&inptr,&inbytesleft, &outptr,&outbytesleft)\n        == (size_t)(-1)\n        || iconv(subst_mb_to_mb_cd, NULL,NULL, &outptr,&outbytesleft)\n           == (size_t)(-1))\n      error(EXIT_FAILURE,0,\n            /* TRANSLATORS: An error message.\n               The %s placeholder expands to a piece of text, specified through --byte-subst.  */\n            _(\"cannot convert byte substitution to target encoding: %s\"),\n            ilseq_byte_subst_buffer);\n    fwrite(subst_mb_to_mb_temp_buffer,1,ilseq_byte_subst_size*4-outbytesleft,\n           stdout);\n  }\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "conversion_error_EILSEQ": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        639,
        1
      ],
      "content": "static void conversion_error_EILSEQ (const char* infilename)\n{\n  fflush(stdout);\n  if (column > 0)\n    putc('\\n',stderr);\n  error(0,0,\n        /* TRANSLATORS: An error message.\n           The placeholders expand to the input file name, a line number, and a column number.  */\n        _(\"%s:%u:%u: cannot convert\"),\n        infilename,line,column);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "conversion_error_EINVAL": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "static void conversion_error_EINVAL (const char* infilename)\n{\n  fflush(stdout);\n  if (column > 0)\n    putc('\\n',stderr);\n  error(0,0,\n        /* TRANSLATORS: An error message.\n           The placeholders expand to the input file name, a line number, and a column number.\n           A \"shift sequence\" is a sequence of bytes that changes the state of the converter;\n           this concept exists only for \"stateful\" encodings like ISO-2022-JP.  */\n        _(\"%s:%u:%u: incomplete character or shift sequence\"),\n        infilename,line,column);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "conversion_error_other": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "static void conversion_error_other (int errnum, const char* infilename)\n{\n  fflush(stdout);\n  if (column > 0)\n    putc('\\n',stderr);\n  error(0,errnum,\n        /* TRANSLATORS: The first part of an error message.\n           It is followed by a colon and a detail message.\n           The placeholders expand to the input file name, a line number, and a column number.  */\n        _(\"%s:%u:%u\"),\n        infilename,line,column);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "convert": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "static int convert (iconv_t cd, int infile, const char* infilename)\n{\n  char inbuf[4096+4096];\n  size_t inbufrest = 0;\n  int infile_error = 0;\n  char initial_outbuf[4096];\n  char *outbuf = initial_outbuf;\n  size_t outbufsize = sizeof(initial_outbuf);\n  int status = 0;\n\n#if O_BINARY\n  SET_BINARY(infile);\n#endif\n  line = 1; column = 0;\n  iconv(cd,NULL,NULL,NULL,NULL);\n  for (;;) {\n    size_t inbufsize;\n    /* Transfer the accumulated output to its destination, in case the\n       safe_read() call will block. */\n    fflush(stdout);\n    inbufsize = safe_read(infile,inbuf+4096,4096);\n    if (inbufsize == 0 || inbufsize == SAFE_READ_ERROR) {\n      infile_error = (inbufsize == SAFE_READ_ERROR ? errno : 0);\n      if (inbufrest == 0)\n        break;\n      else {\n        if (ilseq_byte_subst != NULL)\n          subst_mb_to_mb_fallback(inbuf+4096-inbufrest, inbufrest);\n        if (!silent)\n          conversion_error_EINVAL(infilename);\n        status = 1;\n        goto done;\n      }\n    } else {\n      const char* inptr = inbuf+4096-inbufrest;\n      size_t insize = inbufrest+inbufsize;\n      inbufrest = 0;\n      while (insize > 0) {\n        char* outptr = outbuf;\n        size_t outsize = outbufsize;\n        size_t res = iconv(cd,(ICONV_CONST char**)&inptr,&insize,&outptr,&outsize);\n        if (outptr != outbuf) {\n          int saved_errno = errno;\n          if (fwrite(outbuf,1,outptr-outbuf,stdout) < outptr-outbuf) {\n            status = 1;\n            goto done;\n          }\n          errno = saved_errno;\n        }\n        if (res == (size_t)(-1)) {\n          if (errno == EILSEQ) {\n            if (discard_unconvertible == 1) {\n              int one = 1;\n              iconvctl(cd,ICONV_SET_DISCARD_ILSEQ,&one);\n              discard_unconvertible = 2;\n              status = 1;\n            } else {\n              if (!silent)\n                conversion_error_EILSEQ(infilename);\n              status = 1;\n              goto done;\n            }\n          } else if (errno == EINVAL) {\n            if (inbufsize == 0 || insize > 4096) {\n              if (!silent)\n                conversion_error_EINVAL(infilename);\n              status = 1;\n              goto done;\n            } else {\n              inbufrest = insize;\n              if (insize > 0) {\n                /* Like memcpy(inbuf+4096-insize,inptr,insize), except that\n                   we cannot use memcpy here, because source and destination\n                   regions may overlap. */\n                char* restptr = inbuf+4096-insize;\n                do { *restptr++ = *inptr++; } while (--insize > 0);\n              }\n              break;\n            }\n          } else if (errno == E2BIG) {\n            if (outptr==outbuf) {\n              /* outbuf is too small. Double its size. */\n              if (outbuf != initial_outbuf)\n                free(outbuf);\n              outbufsize = 2*outbufsize;\n              if (outbufsize==0) /* integer overflow? */\n                xalloc_die();\n              outbuf = (char*)xmalloc(outbufsize);\n            }\n          } else {\n            if (!silent)\n              conversion_error_other(errno,infilename);\n            status = 1;\n            goto done;\n          }\n        }\n      }\n    }\n  }\n  for (;;) {\n    char* outptr = outbuf;\n    size_t outsize = outbufsize;\n    size_t res = iconv(cd,NULL,NULL,&outptr,&outsize);\n    if (outptr != outbuf) {\n      int saved_errno = errno;\n      if (fwrite(outbuf,1,outptr-outbuf,stdout) < outptr-outbuf) {\n        status = 1;\n        goto done;\n      }\n      errno = saved_errno;\n    }\n    if (res == (size_t)(-1)) {\n      if (errno == EILSEQ) {\n        if (discard_unconvertible == 1) {\n          int one = 1;\n          iconvctl(cd,ICONV_SET_DISCARD_ILSEQ,&one);\n          discard_unconvertible = 2;\n          status = 1;\n        } else {\n          if (!silent)\n            conversion_error_EILSEQ(infilename);\n          status = 1;\n          goto done;\n        }\n      } else if (errno == EINVAL) {\n        if (!silent)\n          conversion_error_EINVAL(infilename);\n        status = 1;\n        goto done;\n      } else if (errno == E2BIG) {\n        if (outptr==outbuf) {\n          /* outbuf is too small. Double its size. */\n          if (outbuf != initial_outbuf)\n            free(outbuf);\n          outbufsize = 2*outbufsize;\n          if (outbufsize==0) /* integer overflow? */\n            xalloc_die();\n          outbuf = (char*)xmalloc(outbufsize);\n        }\n      } else {\n        if (!silent)\n          conversion_error_other(errno,infilename);\n        status = 1;\n        goto done;\n      }\n    } else\n      break;\n  }\n  if (infile_error) {\n    fflush(stdout);\n    if (column > 0)\n      putc('\\n',stderr);\n    error(0,infile_error,\n          /* TRANSLATORS: An error message.\n             The placeholder expands to the input file name.  */\n          _(\"%s: I/O error\"),\n          infilename);\n    status = 1;\n    goto done;\n  }\n done:\n  if (outbuf != initial_outbuf)\n    free(outbuf);\n  return status;\n}",
      "lines": 165,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        1118,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  const char* fromcode = NULL;\n  const char* tocode = NULL;\n  int do_list = 0;\n  iconv_t cd;\n  struct iconv_fallbacks fallbacks;\n  struct iconv_hooks hooks;\n  int i;\n  int status;\n\n  set_program_name (argv[0]);\n#if HAVE_SETLOCALE\n  /* Needed for the locale dependent encodings, \"char\" and \"wchar_t\",\n     and for gettext. */\n  setlocale(LC_CTYPE,\"\");\n#if ENABLE_NLS\n  /* Needed for gettext. */\n  setlocale(LC_MESSAGES,\"\");\n#endif\n#endif\n#if ENABLE_NLS\n  bindtextdomain(\"libiconv\",relocate(LOCALEDIR));\n#endif\n  textdomain(\"libiconv\");\n  for (i = 1; i < argc;) {\n    size_t len = strlen(argv[i]);\n    if (!strcmp(argv[i],\"--\")) {\n      i++;\n      break;\n    }\n    if (!strcmp(argv[i],\"-f\")\n        /* --f ... --from-code */\n        || (len >= 3 && len <= 11 && !strncmp(argv[i],\"--from-code\",len))\n        /* --from-code=... */\n        || (len >= 12 && !strncmp(argv[i],\"--from-code=\",12))) {\n      if (len < 12)\n        if (i == argc-1) usage(1);\n      if (fromcode != NULL) usage(1);\n      if (len < 12) {\n        fromcode = argv[i+1];\n        i += 2;\n      } else {\n        fromcode = argv[i]+12;\n        i++;\n      }\n      continue;\n    }\n    if (!strcmp(argv[i],\"-t\")\n        /* --t ... --to-code */\n        || (len >= 3 && len <= 9 && !strncmp(argv[i],\"--to-code\",len))\n        /* --from-code=... */\n        || (len >= 10 && !strncmp(argv[i],\"--to-code=\",10))) {\n      if (len < 10)\n        if (i == argc-1) usage(1);\n      if (tocode != NULL) usage(1);\n      if (len < 10) {\n        tocode = argv[i+1];\n        i += 2;\n      } else {\n        tocode = argv[i]+10;\n        i++;\n      }\n      continue;\n    }\n    if (!strcmp(argv[i],\"-l\")\n        /* --l ... --list */\n        || (len >= 3 && len <= 6 && !strncmp(argv[i],\"--list\",len))) {\n      do_list = 1;\n      i++;\n      continue;\n    }\n    if (/* --by ... --byte-subst */\n        (len >= 4 && len <= 12 && !strncmp(argv[i],\"--byte-subst\",len))\n        /* --byte-subst=... */\n        || (len >= 13 && !strncmp(argv[i],\"--byte-subst=\",13))) {\n      if (len < 13) {\n        if (i == argc-1) usage(1);\n        ilseq_byte_subst = argv[i+1];\n        i += 2;\n      } else {\n        ilseq_byte_subst = argv[i]+13;\n        i++;\n      }\n      ilseq_byte_subst_size =\n        check_subst_formatstring(ilseq_byte_subst, \"--byte-subst\");\n      continue;\n    }\n    if (/* --w ... --widechar-subst */\n        (len >= 3 && len <= 16 && !strncmp(argv[i],\"--widechar-subst\",len))\n        /* --widechar-subst=... */\n        || (len >= 17 && !strncmp(argv[i],\"--widechar-subst=\",17))) {\n      if (len < 17) {\n        if (i == argc-1) usage(1);\n        ilseq_wchar_subst = argv[i+1];\n        i += 2;\n      } else {\n        ilseq_wchar_subst = argv[i]+17;\n        i++;\n      }\n      ilseq_wchar_subst_size =\n        check_subst_formatstring(ilseq_wchar_subst, \"--widechar-subst\");\n      continue;\n    }\n    if (/* --u ... --unicode-subst */\n        (len >= 3 && len <= 15 && !strncmp(argv[i],\"--unicode-subst\",len))\n        /* --unicode-subst=... */\n        || (len >= 16 && !strncmp(argv[i],\"--unicode-subst=\",16))) {\n      if (len < 16) {\n        if (i == argc-1) usage(1);\n        ilseq_unicode_subst = argv[i+1];\n        i += 2;\n      } else {\n        ilseq_unicode_subst = argv[i]+16;\n        i++;\n      }\n      ilseq_unicode_subst_size =\n        check_subst_formatstring(ilseq_unicode_subst, \"--unicode-subst\");\n      continue;\n    }\n    if /* --s ... --silent */\n       (len >= 3 && len <= 8 && !strncmp(argv[i],\"--silent\",len)) {\n      silent = 1;\n      i++;\n      continue;\n    }\n    if /* --h ... --help */\n       (len >= 3 && len <= 6 && !strncmp(argv[i],\"--help\",len)) {\n      usage(0);\n    }\n    if /* --v ... --version */\n       (len >= 3 && len <= 9 && !strncmp(argv[i],\"--version\",len)) {\n      print_version();\n    }\n#if O_BINARY\n    /* Backward compatibility with iconv <= 1.9.1. */\n    if /* --bi ... --binary */\n       (len >= 4 && len <= 8 && !strncmp(argv[i],\"--binary\",len)) {\n      i++;\n      continue;\n    }\n#endif\n    if (argv[i][0] == '-') {\n      const char *option = argv[i] + 1;\n      if (*option == '\\0')\n        usage(1);\n      for (; *option; option++)\n        switch (*option) {\n          case 'c': discard_unconvertible = 1; break;\n          case 's': silent = 1; break;\n          default: usage(1);\n        }\n      i++;\n      continue;\n    }\n    break;\n  }\n  if (do_list) {\n    if (i != 2 || i != argc)\n      usage(1);\n    iconvlist(print_one,NULL);\n    status = 0;\n  } else {\n#if O_BINARY\n    SET_BINARY(fileno(stdout));\n#endif\n    if (fromcode == NULL)\n      fromcode = \"char\";\n    if (tocode == NULL)\n      tocode = \"char\";\n    cd = iconv_open(tocode,fromcode);\n    if (cd == (iconv_t)(-1)) {\n      if (iconv_open(\"UCS-4\",fromcode) == (iconv_t)(-1))\n        error(0,0,\n              /* TRANSLATORS: An error message.\n                 The placeholder expands to the encoding name, specified through --from-code.  */\n              _(\"conversion from %s unsupported\"),\n              fromcode);\n      else if (iconv_open(tocode,\"UCS-4\") == (iconv_t)(-1))\n        error(0,0,\n              /* TRANSLATORS: An error message.\n                 The placeholder expands to the encoding name, specified through --to-code.  */\n              _(\"conversion to %s unsupported\"),\n              tocode);\n      else\n        error(0,0,\n              /* TRANSLATORS: An error message.\n                 The placeholders expand to the encoding names, specified through --from-code and --to-code, respectively.  */\n              _(\"conversion from %s to %s unsupported\"),\n              fromcode,tocode);\n      error(EXIT_FAILURE,0,\n            /* TRANSLATORS: Additional advice after an error message.\n               The %s placeholder expands to the program name.  */\n            _(\"try '%s -l' to get the list of supported encodings\"),\n            program_name);\n    }\n    /* Look at fromcode and tocode, to determine whether character widths\n       should be determined according to legacy CJK conventions. */\n    cjkcode = iconv_canonicalize(tocode);\n    if (!is_cjk_encoding(cjkcode))\n      cjkcode = iconv_canonicalize(fromcode);\n    /* Set up fallback routines for handling impossible conversions. */\n    if (ilseq_byte_subst != NULL)\n      ilseq_byte_subst_buffer = (char*)xmalloc((ilseq_byte_subst_size+1)*sizeof(char));\n    if (!discard_unconvertible) {\n      #if HAVE_WCHAR_T\n      if (ilseq_wchar_subst != NULL)\n        ilseq_wchar_subst_buffer = (char*)xmalloc((ilseq_wchar_subst_size+1)*sizeof(char));\n      #endif\n      if (ilseq_unicode_subst != NULL)\n        ilseq_unicode_subst_buffer = (char*)xmalloc((ilseq_unicode_subst_size+1)*sizeof(char));\n      if (ilseq_byte_subst != NULL) {\n        subst_mb_to_uc_cd = iconv_open(\"UCS-4-INTERNAL\",\"char\");\n        subst_mb_to_uc_temp_buffer = (unsigned int*)xmalloc(ilseq_byte_subst_size*sizeof(unsigned int));\n        #if HAVE_WCHAR_T\n        subst_mb_to_wc_cd = iconv_open(\"wchar_t\",\"char\");\n        subst_mb_to_wc_temp_buffer = (wchar_t*)xmalloc(ilseq_byte_subst_size*sizeof(wchar_t));\n        #endif\n        subst_mb_to_mb_cd = iconv_open(tocode,\"char\");\n        subst_mb_to_mb_temp_buffer = (char*)xmalloc(ilseq_byte_subst_size*4);\n      }\n      #if HAVE_WCHAR_T\n      if (ilseq_wchar_subst != NULL) {\n        subst_wc_to_mb_cd = iconv_open(tocode,\"char\");\n        subst_wc_to_mb_temp_buffer = (char*)xmalloc(ilseq_wchar_subst_size*4);\n      }\n      #endif\n      if (ilseq_unicode_subst != NULL) {\n        subst_uc_to_mb_cd = iconv_open(tocode,\"char\");\n        subst_uc_to_mb_temp_buffer = (char*)xmalloc(ilseq_unicode_subst_size*4);\n      }\n      fallbacks.mb_to_uc_fallback =\n        (ilseq_byte_subst != NULL ? subst_mb_to_uc_fallback : NULL);\n      fallbacks.uc_to_mb_fallback =\n        (ilseq_unicode_subst != NULL ? subst_uc_to_mb_fallback : NULL);\n      fallbacks.mb_to_wc_fallback =\n        (ilseq_byte_subst != NULL ? subst_mb_to_wc_fallback : NULL);\n      fallbacks.wc_to_mb_fallback =\n        (ilseq_wchar_subst != NULL ? subst_wc_to_mb_fallback : NULL);\n      fallbacks.data = NULL;\n      iconvctl(cd, ICONV_SET_FALLBACKS, &fallbacks);\n    }\n    /* Set up hooks for updating the line and column position. */\n    hooks.uc_hook = update_line_column;\n    hooks.wc_hook = NULL;\n    hooks.data = NULL;\n    iconvctl(cd, ICONV_SET_HOOKS, &hooks);\n    if (i == argc)\n      status = convert(cd,fileno(stdin),\n                       /* TRANSLATORS: A filename substitute denoting standard input.  */\n                       _(\"(stdin)\"));\n    else {\n      status = 0;\n      for (; i < argc; i++) {\n        const char* infilename = argv[i];\n        FILE* infile = fopen(infilename,\"r\");\n        if (infile == NULL) {\n          int saved_errno = errno;\n          error(0,saved_errno,\n                /* TRANSLATORS: The first part of an error message.\n                   It is followed by a colon and a detail message.\n                   The %s placeholder expands to the input file name.  */\n                _(\"%s\"),\n                infilename);\n          status = 1;\n        } else {\n          status |= convert(cd,fileno(infile),infilename);\n          fclose(infile);\n        }\n      }\n    }\n    iconv_close(cd);\n  }\n  if (ferror(stdout) || fclose(stdout)) {\n    error(0,0,\n          /* TRANSLATORS: An error message.  */\n          _(\"I/O error\"));\n    status = 1;\n  }\n  exit(status);\n}",
      "lines": 281,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/src/iconv_no_i18n.c": {},
  "libiconv/libiconv-1.15/srclib/alloca.in.h": {},
  "libiconv/libiconv-1.15/srclib/allocator.c": {},
  "libiconv/libiconv-1.15/srclib/allocator.h": {},
  "libiconv/libiconv-1.15/srclib/areadlink.c": {
    "careadlinkatcwd": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static ssize_t\ncareadlinkatcwd (int fd, char const *filename, char *buffer,\n                 size_t buffer_size)\n{\n  /* FD must be AT_FDCWD here, otherwise the caller is using this\n     function in contexts it was not meant for.  */\n  if (fd != AT_FDCWD)\n    abort ();\n  return readlink (filename, buffer, buffer_size);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "areadlink": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "char *\nareadlink (char const *filename)\n{\n  return careadlinkat (AT_FDCWD, filename, NULL, 0, NULL, careadlinkatcwd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nareadlink (char const *filename)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/areadlink.h": {},
  "libiconv/libiconv-1.15/srclib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/binary-io.c": {},
  "libiconv/libiconv-1.15/srclib/binary-io.h": {
    "set_binary_mode": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "BINARY_IO_INLINE int\nset_binary_mode (int fd, int mode)\n{\n  (void) fd;\n  (void) mode;\n  return O_BINARY;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "BINARY_IO_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/c-ctype.c": {},
  "libiconv/libiconv-1.15/srclib/c-ctype.h": {
    "c_isalnum": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalnum (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isalpha (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isascii": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isascii (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_CNTRL:\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isblank (int c)\n{\n  return c == ' ' || c == '\\t';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_iscntrl (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_CNTRL:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isgraph (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_islower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isprint (int c)\n{\n  switch (c)\n    {\n    case ' ':\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_LOWER:\n    _C_CTYPE_PUNCT:\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_ispunct (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_PUNCT:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isspace (int c)\n{\n  switch (c)\n    {\n    case ' ': case '\\t': case '\\n': case '\\v': case '\\f': case '\\r':\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        322,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "C_CTYPE_INLINE bool\nc_isxdigit (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_DIGIT:\n    _C_CTYPE_A_THRU_F:\n      return true;\n    default:\n      return false;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "C_CTYPE_INLINE",
        "bool",
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_tolower (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_UPPER:\n      return c - 'A' + 'a';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "C_CTYPE_INLINE int\nc_toupper (int c)\n{\n  switch (c)\n    {\n    _C_CTYPE_LOWER:\n      return c - 'a' + 'A';\n    default:\n      return c;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "C_CTYPE_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/canonicalize-lgpl.c": {
    "alloc_failed": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\nalloc_failed (void)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Avoid errno problem without using the malloc or realloc modules; see:\n     http://lists.gnu.org/archive/html/bug-gnulib/2016-08/msg00025.html  */\n  errno = ENOMEM;\n#endif\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__realpath": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n  size_t prefix_len;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         either parameter is a null pointer.  We extend this to allow\n         the RESOLVED parameter to be NULL in case the we are expected to\n         allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 8192;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n        {\n          alloc_failed ();\n          return NULL;\n        }\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      if (!__getcwd (rpath, path_max))\n        {\n          rpath[0] = '\\0';\n          goto error;\n        }\n      dest = strchr (rpath, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rpath);\n    }\n  else\n    {\n      dest = rpath;\n      if (prefix_len)\n        {\n          memcpy (rpath, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for (end = start; *start; start = end)\n    {\n#ifdef _LIBC\n      struct stat64 st;\n#else\n      struct stat st;\n#endif\n\n      /* Skip sequence of multiple path-separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rpath + prefix_len + 1)\n            for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rpath + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          size_t new_size;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rpath_limit)\n            {\n              ptrdiff_t dest_offset = dest - rpath;\n              char *new_rpath;\n\n              if (resolved)\n                {\n                  __set_errno (ENAMETOOLONG);\n                  if (dest > rpath + prefix_len + 1)\n                    dest--;\n                  *dest = '\\0';\n                  goto error;\n                }\n              new_size = rpath_limit - rpath;\n              if (end - start + 1 > path_max)\n                new_size += end - start + 1;\n              else\n                new_size += path_max;\n              new_rpath = (char *) realloc (rpath, new_size);\n              if (new_rpath == NULL)\n                {\n                  alloc_failed ();\n                  goto error;\n                }\n              rpath = new_rpath;\n              rpath_limit = rpath + new_size;\n\n              dest = rpath + dest_offset;\n            }\n\n#ifdef _LIBC\n          dest = __mempcpy (dest, start, end - start);\n#else\n          memcpy (dest, start, end - start);\n          dest += end - start;\n#endif\n          *dest = '\\0';\n\n#ifdef _LIBC\n          if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n#else\n          if (lstat (rpath, &st) < 0)\n#endif\n            goto error;\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t len;\n              ssize_t n;\n\n              if (++num_links > MAXSYMLINKS)\n                {\n                  __set_errno (ELOOP);\n                  goto error;\n                }\n\n              buf = malloca (path_max);\n              if (!buf)\n                {\n                  __set_errno (ENOMEM);\n                  goto error;\n                }\n\n              n = __readlink (rpath, buf, path_max - 1);\n              if (n < 0)\n                {\n                  int saved_errno = errno;\n                  freea (buf);\n                  __set_errno (saved_errno);\n                  goto error;\n                }\n              buf[n] = '\\0';\n\n              if (!extra_buf)\n                {\n                  extra_buf = malloca (path_max);\n                  if (!extra_buf)\n                    {\n                      freea (buf);\n                      __set_errno (ENOMEM);\n                      goto error;\n                    }\n                }\n\n              len = strlen (end);\n              /* Check that n + len + 1 doesn't overflow and is <= path_max. */\n              if (n >= SIZE_MAX - len || n + len >= path_max)\n                {\n                  freea (buf);\n                  __set_errno (ENAMETOOLONG);\n                  goto error;\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rpath, buf, pfxlen);\n                  dest = rpath + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rpath + prefix_len + 1)\n                    for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n            {\n              __set_errno (ENOTDIR);\n              goto error;\n            }\n        }\n    }\n  if (dest > rpath + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n\n  if (extra_buf)\n    freea (extra_buf);\n\n  return rpath;\n\nerror:\n  {\n    int saved_errno = errno;\n    if (extra_buf)\n      freea (extra_buf);\n    if (resolved == NULL)\n      free (rpath);\n    __set_errno (saved_errno);\n  }\n  return NULL;\n}",
      "lines": 276,
      "depth": 24,
      "decorators": [
        "char",
        "*\n__realpath (const char *name, char *resolved)",
        "*"
      ]
    },
    "__old_realpath": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "char *\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)\n{\n  if (resolved == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  return __realpath (name, resolved);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)",
        "*",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "__canonicalize_file_name": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__canonicalize_file_name (const char *name)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/careadlinkat.c": {
    "careadlinkat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "char *\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n{\n  char *buf;\n  size_t buf_size;\n  size_t buf_size_max =\n    SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n  char stack_buf[1024];\n\n  if (! alloc)\n    alloc = &stdlib_allocator;\n\n  if (! buffer_size)\n    {\n      /* Allocate the initial buffer on the stack.  This way, in the\n         common case of a symlink of small size, we get away with a\n         single small malloc() instead of a big malloc() followed by a\n         shrinking realloc().  */\n      buffer = stack_buf;\n      buffer_size = sizeof stack_buf;\n    }\n\n  buf = buffer;\n  buf_size = buffer_size;\n\n  do\n    {\n      /* Attempt to read the link into the current buffer.  */\n      ssize_t link_length = preadlinkat (fd, filename, buf, buf_size);\n      size_t link_size;\n      if (link_length < 0)\n        {\n          /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n             with errno == ERANGE if the buffer is too small.  */\n          int readlinkat_errno = errno;\n          if (readlinkat_errno != ERANGE)\n            {\n              if (buf != buffer)\n                {\n                  alloc->free (buf);\n                  errno = readlinkat_errno;\n                }\n              return NULL;\n            }\n        }\n\n      link_size = link_length;\n\n      if (link_size < buf_size)\n        {\n          buf[link_size++] = '\\0';\n\n          if (buf == stack_buf)\n            {\n              char *b = (char *) alloc->allocate (link_size);\n              buf_size = link_size;\n              if (! b)\n                break;\n              memcpy (b, buf, link_size);\n              buf = b;\n            }\n          else if (link_size < buf_size && buf != buffer && alloc->reallocate)\n            {\n              /* Shrink BUF before returning it.  */\n              char *b = (char *) alloc->reallocate (buf, link_size);\n              if (b)\n                buf = b;\n            }\n\n          return buf;\n        }\n\n      if (buf != buffer)\n        alloc->free (buf);\n\n      if (buf_size <= buf_size_max / 2)\n        buf_size *= 2;\n      else if (buf_size < buf_size_max)\n        buf_size = buf_size_max;\n      else if (buf_size_max < SIZE_MAX)\n        {\n          errno = ENAMETOOLONG;\n          return NULL;\n        }\n      else\n        break;\n      buf = (char *) alloc->allocate (buf_size);\n    }\n  while (buf);\n\n  if (alloc->die)\n    alloc->die (buf_size);\n  errno = ENOMEM;\n  return NULL;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "char",
        "*\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/careadlinkat.h": {},
  "libiconv/libiconv-1.15/srclib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/dirname.h": {},
  "libiconv/libiconv-1.15/srclib/dosname.h": {},
  "libiconv/libiconv-1.15/srclib/errno.in.h": {},
  "libiconv/libiconv-1.15/srclib/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%u: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%u: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/error.h": {},
  "libiconv/libiconv-1.15/srclib/fcntl.in.h": {},
  "libiconv/libiconv-1.15/srclib/getprogname.c": {
    "getprogname": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "char const *\ngetprogname (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return program_invocation_short_name;\n# elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */\n  /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */\n  return last_component (program_invocation_name);\n# elif HAVE_GETEXECNAME                                     /* Solaris */\n  /* http://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */\n  const char *p = getexecname ();\n  if (!p)\n    p = \"?\";\n  return last_component (p);\n# elif HAVE_DECL___ARGV                                     /* mingw, MSVC */\n  /* https://msdn.microsoft.com/en-us/library/dn727674.aspx */\n  const char *p = __argv && __argv[0] ? __argv[0] : \"?\";\n  return last_component (p);\n# elif HAVE_VAR___PROGNAME                                  /* OpenBSD, QNX */\n  /* http://man.openbsd.org/style.9 */\n  /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */\n  /* Be careful to declare this only when we absolutely need it\n     (OpenBSD 5.1), rather than when it's available.  Otherwise,\n     its mere declaration makes program_invocation_short_name\n     malfunction (have zero length) with Fedora 25's glibc.  */\n  extern char *__progname;\n  const char *p = __progname;\n  return p && p[0] ? p : \"?\";\n# elif _AIX                                                 /* AIX */\n  /* Idea by Bastien ROUCARI\u00c3\u0088S,\n     http://lists.gnu.org/archive/html/bug-gnulib/2010-12/msg00095.html\n     Reference: http://\n   ibm.biz/knowctr#ssw_aix_53/com.ibm.aix.basetechref/doc/basetrf1/getprocs.htm\n  */\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct procentry64 procs;\n      p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)\n           ? strdup (procs.pi_comm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif defined __hpux\n  static char *p;\n  static int first = 1;\n  if (first)\n    {\n      first = 0;\n      pid_t pid = getpid ();\n      struct pst_status status;\n      p = (0 < pstat_getproc (&status, sizeof status, 0, pid)\n           ? strdup (status.pst_ucomm)\n           : NULL);\n      if (!p)\n        p = \"?\";\n    }\n  return p;\n# elif __MVS__                                              /* z/OS */\n  /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */\n  static char *p = \"?\";\n  static int first = 1;\n  if (first)\n    {\n      pid_t pid = getpid ();\n      int token;\n      W_PSPROC buf;\n      first = 0;\n      memset (&buf, 0, sizeof(buf));\n      buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);\n      buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);\n      buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);\n      if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)\n        {\n          for (token = 0; token >= 0;\n               token = w_getpsent (token, &buf, sizeof(buf)))\n            {\n              if (token > 0 && buf.ps_pid == pid)\n                {\n                  char *s = strdup (last_component (buf.ps_pathptr));\n                  if (s)\n                    p = s;\n                  break;\n                }\n            }\n        }\n      free (buf.ps_cmdptr);\n      free (buf.ps_conttyptr);\n      free (buf.ps_pathptr);\n    }\n  return p;\n# else\n#  error \"getprogname module not ported to this OS\"\n# endif\n}",
      "lines": 101,
      "depth": 26,
      "decorators": [
        "char",
        "const",
        "const",
        "*\ngetprogname (void)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/getprogname.h": {},
  "libiconv/libiconv-1.15/srclib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n      found_translation = (translation != msg_ctxt_id);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      int found_translation;\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n      found_translation = !(translation == msg_ctxt_id || translation == msgid_plural);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (found_translation)\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/intprops.h": {},
  "libiconv/libiconv-1.15/srclib/limits.in.h": {},
  "libiconv/libiconv-1.15/srclib/localcharset.h": {},
  "libiconv/libiconv-1.15/srclib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/malloca.h": {},
  "libiconv/libiconv-1.15/srclib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/msvc-inval.h": {},
  "libiconv/libiconv-1.15/srclib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/msvc-nothrow.h": {},
  "libiconv/libiconv-1.15/srclib/pathmax.h": {},
  "libiconv/libiconv-1.15/srclib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/progname.h": {},
  "libiconv/libiconv-1.15/srclib/progreloc.c": {
    "maybe_executable": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static bool\nmaybe_executable (const char *filename)\n{\n  /* The native Windows API lacks the access() function.  */\n#if !defined WINDOWS_NATIVE\n  if (access (filename, X_OK) < 0)\n    return false;\n#endif\n\n#if defined __linux__ || defined __CYGWIN__\n  if (executable_fd >= 0)\n    {\n      /* If we already have an executable_fd, check that filename points to\n         the same inode.  */\n      struct stat statexe;\n      struct stat statfile;\n\n      if (fstat (executable_fd, &statexe) >= 0)\n        {\n          if (stat (filename, &statfile) < 0)\n            return false;\n          if (!(statfile.st_dev\n                && statfile.st_dev == statexe.st_dev\n                && statfile.st_ino == statexe.st_ino))\n            return false;\n        }\n    }\n#endif\n\n  return true;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "find_executable": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static char *\nfind_executable (const char *argv0)\n{\n#if defined WINDOWS_NATIVE\n  /* Native Windows only.\n     On Cygwin, it is better to use the Cygwin provided /proc interface, than\n     to use native Windows API and cygwin_conv_to_posix_path, because it\n     supports longer file names\n     (see <http://cygwin.com/ml/cygwin/2011-01/msg00410.html>).  */\n  char location[MAX_PATH];\n  int length = GetModuleFileName (NULL, location, sizeof (location));\n  if (length < 0)\n    return NULL;\n  if (!IS_PATH_WITH_DIR (location))\n    /* Shouldn't happen.  */\n    return NULL;\n  return xstrdup (location);\n#elif defined __EMX__\n  PPIB ppib;\n  char location[CCHMAXPATH];\n\n  /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/619_L2H_DosGetInfoBlocksSynt.html\n     for specification of DosGetInfoBlocks().  */\n  if (DosGetInfoBlocks (NULL, &ppib))\n    return NULL;\n\n  /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/1247_L2H_DosQueryModuleNameSy.html\n     for specification of DosQueryModuleName().  */\n  if (DosQueryModuleName (ppib->pib_hmte, sizeof (location), location))\n    return NULL;\n\n  _fnslashify (location);\n\n  return xstrdup (location);\n#else /* Unix */\n# ifdef __linux__\n  /* The executable is accessible as /proc/<pid>/exe.  In newer Linux\n     versions, also as /proc/self/exe.  Linux >= 2.1 provides a symlink\n     to the true pathname; older Linux versions give only device and ino,\n     enclosed in brackets, which we cannot use here.  */\n  {\n    char *link;\n\n    link = xreadlink (\"/proc/self/exe\");\n    if (link != NULL && link[0] != '[')\n      return link;\n    if (executable_fd < 0)\n      executable_fd = open (\"/proc/self/exe\", O_EXEC, 0);\n\n    {\n      char buf[6+10+5];\n      sprintf (buf, \"/proc/%d/exe\", getpid ());\n      link = xreadlink (buf);\n      if (link != NULL && link[0] != '[')\n        return link;\n      if (executable_fd < 0)\n        executable_fd = open (buf, O_EXEC, 0);\n    }\n  }\n# endif\n# ifdef __CYGWIN__\n  /* The executable is accessible as /proc/<pid>/exe, at least in\n     Cygwin >= 1.5.  */\n  {\n    char *link;\n\n    link = xreadlink (\"/proc/self/exe\");\n    if (link != NULL)\n      return link;\n    if (executable_fd < 0)\n      executable_fd = open (\"/proc/self/exe\", O_EXEC, 0);\n  }\n# endif\n# if HAVE_MACH_O_DYLD_H && HAVE__NSGETEXECUTABLEPATH\n  /* On Mac OS X 10.2 or newer, the function\n       int _NSGetExecutablePath (char *buf, uint32_t *bufsize);\n     can be used to retrieve the executable's full path.  */\n  char location[4096];\n  unsigned int length = sizeof (location);\n  if (_NSGetExecutablePath (location, &length) == 0\n      && location[0] == '/')\n    return canonicalize_file_name (location);\n# endif\n  /* Guess the executable's full path.  We assume the executable has been\n     called via execlp() or execvp() with properly set up argv[0].  The\n     login(1) convention to add a '-' prefix to argv[0] is not supported.  */\n  {\n    bool has_slash = false;\n    {\n      const char *p;\n      for (p = argv0; *p; p++)\n        if (*p == '/')\n          {\n            has_slash = true;\n            break;\n          }\n    }\n    if (!has_slash)\n      {\n        /* exec searches paths without slashes in the directory list given\n           by $PATH.  */\n        const char *path = getenv (\"PATH\");\n\n        if (path != NULL)\n          {\n            const char *p;\n            const char *p_next;\n\n            for (p = path; *p; p = p_next)\n              {\n                const char *q;\n                size_t p_len;\n                char *concat_name;\n\n                for (q = p; *q; q++)\n                  if (*q == ':')\n                    break;\n                p_len = q - p;\n                p_next = (*q == '\\0' ? q : q + 1);\n\n                /* We have a path item at p, of length p_len.\n                   Now concatenate the path item and argv0.  */\n                concat_name = (char *) xmalloc (p_len + strlen (argv0) + 2);\n# ifdef NO_XMALLOC\n                if (concat_name == NULL)\n                  return NULL;\n# endif\n                if (p_len == 0)\n                  /* An empty PATH element designates the current directory.  */\n                  strcpy (concat_name, argv0);\n                else\n                  {\n                    memcpy (concat_name, p, p_len);\n                    concat_name[p_len] = '/';\n                    strcpy (concat_name + p_len + 1, argv0);\n                  }\n                if (maybe_executable (concat_name))\n                  return canonicalize_file_name (concat_name);\n                free (concat_name);\n              }\n          }\n        /* Not found in the PATH, assume the current directory.  */\n      }\n    /* exec treats paths containing slashes as relative to the current\n       directory.  */\n    if (maybe_executable (argv0))\n      return canonicalize_file_name (argv0);\n  }\n  /* No way to find the executable.  */\n  return NULL;\n#endif\n}",
      "lines": 152,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfind_executable (const char *argv0)",
        "*"
      ]
    },
    "prepare_relocate": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static void\nprepare_relocate (const char *orig_installprefix, const char *orig_installdir,\n                  const char *argv0)\n{\n  char *curr_prefix;\n\n  /* Determine the full pathname of the current executable.  */\n  executable_fullname = find_executable (argv0);\n\n  /* Determine the current installation prefix from it.  */\n  curr_prefix = compute_curr_prefix (orig_installprefix, orig_installdir,\n                                     executable_fullname);\n  if (curr_prefix != NULL)\n    {\n      /* Now pass this prefix to all copies of the relocate.c source file.  */\n      set_relocation_prefix (orig_installprefix, curr_prefix);\n\n      free (curr_prefix);\n    }\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_program_name_and_installdir": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "void\nset_program_name_and_installdir (const char *argv0,\n                                 const char *orig_installprefix,\n                                 const char *orig_installdir)\n{\n  const char *argv0_stripped = argv0;\n\n  /* Relocatable programs are renamed to .bin by install-reloc.  Or, more\n     generally, their suffix is changed from $exeext to .bin$exeext.\n     Remove the \".bin\" here.  */\n  {\n    size_t argv0_len = strlen (argv0);\n    const size_t exeext_len = sizeof (EXEEXT) - sizeof (\"\");\n    if (argv0_len > 4 + exeext_len)\n      if (memcmp (argv0 + argv0_len - exeext_len - 4, \".bin\", 4) == 0)\n        {\n          if (sizeof (EXEEXT) > sizeof (\"\"))\n            {\n              /* Compare using an inlined copy of c_strncasecmp(), because\n                 the filenames may have undergone a case conversion since\n                 they were packaged.  In other words, EXEEXT may be \".exe\"\n                 on one system and \".EXE\" on another.  */\n              static const char exeext[] = EXEEXT;\n              const char *s1 = argv0 + argv0_len - exeext_len;\n              const char *s2 = exeext;\n              for (; *s1 != '\\0'; s1++, s2++)\n                {\n                  unsigned char c1 = *s1;\n                  unsigned char c2 = *s2;\n                  if ((c1 >= 'A' && c1 <= 'Z' ? c1 - 'A' + 'a' : c1)\n                      != (c2 >= 'A' && c2 <= 'Z' ? c2 - 'A' + 'a' : c2))\n                    goto done_stripping;\n                }\n            }\n          /* Remove \".bin\" before EXEEXT or its equivalent.  */\n          {\n            char *shorter = (char *) xmalloc (argv0_len - 4 + 1);\n#ifdef NO_XMALLOC\n            if (shorter != NULL)\n#endif\n              {\n                memcpy (shorter, argv0, argv0_len - exeext_len - 4);\n                if (sizeof (EXEEXT) > sizeof (\"\"))\n                  memcpy (shorter + argv0_len - exeext_len - 4,\n                          argv0 + argv0_len - exeext_len - 4,\n                          exeext_len);\n                shorter[argv0_len - 4] = '\\0';\n                argv0_stripped = shorter;\n              }\n          }\n         done_stripping: ;\n      }\n  }\n\n  set_program_name (argv0_stripped);\n\n  prepare_relocate (orig_installprefix, orig_installdir, argv0);\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "get_full_program_name": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "char *\nget_full_program_name (void)\n{\n  return executable_fullname;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "*\nget_full_program_name (void)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/read.c": {
    "read_nothrow": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        5
      ],
      "content": "static ssize_t\nread_nothrow (int fd, void *buf, size_t count)\n{\n  ssize_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = read (fd, buf, count);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "rpl_read": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "ssize_t\nrpl_read (int fd, void *buf, size_t count)\n{\n  ssize_t ret = read_nothrow (fd, buf, count);\n\n# if GNULIB_NONBLOCKING\n  if (ret < 0\n      && GetLastError () == ERROR_NO_DATA)\n    {\n      HANDLE h = (HANDLE) _get_osfhandle (fd);\n      if (GetFileType (h) == FILE_TYPE_PIPE)\n        {\n          /* h is a pipe or socket.  */\n          DWORD state;\n          if (GetNamedPipeHandleState (h, &state, NULL, NULL, NULL, NULL, 0)\n              && (state & PIPE_NOWAIT) != 0)\n            /* h is a pipe in non-blocking mode.\n               Change errno from EINVAL to EAGAIN.  */\n            errno = EAGAIN;\n        }\n    }\n# endif\n\n  return ret;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/relocatable.c": {
    "set_this_relocation_prefix": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static void\nset_this_relocation_prefix (const char *orig_prefix_arg,\n                            const char *curr_prefix_arg)\n{\n  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL\n      /* Optimization: if orig_prefix and curr_prefix are equal, the\n         relocation is a nop.  */\n      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)\n    {\n      /* Duplicate the argument strings.  */\n      char *memory;\n\n      orig_prefix_len = strlen (orig_prefix_arg);\n      curr_prefix_len = strlen (curr_prefix_arg);\n      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (memory != NULL)\n#endif\n        {\n          memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);\n          orig_prefix = memory;\n          memory += orig_prefix_len + 1;\n          memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);\n          curr_prefix = memory;\n          return;\n        }\n    }\n  orig_prefix = NULL;\n  curr_prefix = NULL;\n  /* Don't worry about wasted memory here - this function is usually only\n     called once.  */\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_relocation_prefix": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\nset_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)\n{\n  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n\n  /* Now notify all dependent libraries.  */\n#if DEPENDS_ON_LIBCHARSET\n  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109\n  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix\n  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);\n#endif\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "compute_curr_prefix": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "char *\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)\n{\n  char *curr_installdir;\n  const char *rel_installdir;\n\n  if (curr_pathname == NULL)\n    return NULL;\n\n  /* Determine the relative installation directory, relative to the prefix.\n     This is simply the difference between orig_installprefix and\n     orig_installdir.  */\n  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))\n      != 0)\n    /* Shouldn't happen - nothing should be installed outside $(prefix).  */\n    return NULL;\n  rel_installdir = orig_installdir + strlen (orig_installprefix);\n\n  /* Determine the current installation directory.  */\n  {\n    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);\n    const char *p = curr_pathname + strlen (curr_pathname);\n    char *q;\n\n    while (p > p_base)\n      {\n        p--;\n        if (ISSLASH (*p))\n          break;\n      }\n\n    q = (char *) xmalloc (p - curr_pathname + 1);\n#ifdef NO_XMALLOC\n    if (q == NULL)\n      return NULL;\n#endif\n    memcpy (q, curr_pathname, p - curr_pathname);\n    q[p - curr_pathname] = '\\0';\n    curr_installdir = q;\n  }\n\n  /* Compute the current installation prefix by removing the trailing\n     rel_installdir from it.  */\n  {\n    const char *rp = rel_installdir + strlen (rel_installdir);\n    const char *cp = curr_installdir + strlen (curr_installdir);\n    const char *cp_base =\n      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);\n\n    while (rp > rel_installdir && cp > cp_base)\n      {\n        bool same = false;\n        const char *rpi = rp;\n        const char *cpi = cp;\n\n        while (rpi > rel_installdir && cpi > cp_base)\n          {\n            rpi--;\n            cpi--;\n            if (ISSLASH (*rpi) || ISSLASH (*cpi))\n              {\n                if (ISSLASH (*rpi) && ISSLASH (*cpi))\n                  same = true;\n                break;\n              }\n            /* Do case-insensitive comparison if the file system is always or\n               often case-insensitive.  It's better to accept the comparison\n               if the difference is only in case, rather than to fail.  */\n#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__\n            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */\n            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)\n                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))\n              break;\n#else\n            if (*rpi != *cpi)\n              break;\n#endif\n          }\n        if (!same)\n          break;\n        /* The last pathname component was the same.  opi and cpi now point\n           to the slash before it.  */\n        rp = rpi;\n        cp = cpi;\n      }\n\n    if (rp > rel_installdir)\n      {\n        /* Unexpected: The curr_installdir does not end with rel_installdir.  */\n        free (curr_installdir);\n        return NULL;\n      }\n\n    {\n      size_t curr_prefix_len = cp - curr_installdir;\n      char *curr_prefix;\n\n      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);\n#ifdef NO_XMALLOC\n      if (curr_prefix == NULL)\n        {\n          free (curr_installdir);\n          return NULL;\n        }\n#endif\n      memcpy (curr_prefix, curr_installdir, curr_prefix_len);\n      curr_prefix[curr_prefix_len] = '\\0';\n\n      free (curr_installdir);\n\n      return curr_prefix;\n    }\n  }\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "char",
        "*\ncompute_curr_prefix (const char *orig_installprefix,\n                     const char *orig_installdir,\n                     const char *curr_pathname)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "BOOL WINAPI\nDllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)\n{\n  (void) reserved;\n\n  if (event == DLL_PROCESS_ATTACH)\n    {\n      /* The DLL is being loaded into an application's address range.  */\n      static char location[MAX_PATH];\n\n      if (!GetModuleFileName (module_handle, location, sizeof (location)))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      if (!IS_PATH_WITH_DIR (location))\n        /* Shouldn't happen.  */\n        return FALSE;\n\n      shared_library_fullname = strdup (location);\n    }\n\n  return TRUE;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    },
    "_DLL_InitTerm": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "unsigned long _System\n_DLL_InitTerm (unsigned long hModule, unsigned long ulFlag)\n{\n  static char location[CCHMAXPATH];\n\n  switch (ulFlag)\n    {\n      case 0:\n        if (_CRT_init () == -1)\n          return 0;\n\n        __ctordtorInit();\n\n        /* See http://cyberkinetica.homeunix.net/os2tk45/cp1/1247_L2H_DosQueryModuleNameSy.html\n           for specification of DosQueryModuleName(). */\n        if (DosQueryModuleName (hModule, sizeof (location), location))\n          return 0;\n\n        _fnslashify (location);\n        shared_library_fullname = strdup (location);\n        break;\n\n      case 1:\n        __ctordtorTerm();\n\n        _CRT_term ();\n        break;\n    }\n\n  return 1;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "unsigned long _System",
        "unsigned",
        "long",
        "_System"
      ]
    },
    "find_shared_library_fullname": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static void\nfind_shared_library_fullname ()\n{\n#if (defined __linux__ && (__GLIBC__ >= 2 || defined __UCLIBC__)) || defined __CYGWIN__\n  /* Linux has /proc/self/maps. glibc 2 and uClibc have the getline()\n     function.\n     Cygwin >= 1.5 has /proc/self/maps and the getline() function too.\n     But it is costly: ca. 0.3 ms on Linux, 3 ms on Cygwin 1.5, and 5 ms on\n     Cygwin 1.7.  */\n  FILE *fp;\n\n  /* Open the current process' maps file.  It describes one VMA per line.  */\n  fp = fopen (\"/proc/self/maps\", \"r\");\n  if (fp)\n    {\n      unsigned long address = (unsigned long) &find_shared_library_fullname;\n      for (;;)\n        {\n          unsigned long start, end;\n          int c;\n\n          if (fscanf (fp, \"%lx-%lx\", &start, &end) != 2)\n            break;\n          if (address >= start && address <= end - 1)\n            {\n              /* Found it.  Now see if this line contains a filename.  */\n              while (c = getc (fp), c != EOF && c != '\\n' && c != '/')\n                continue;\n              if (c == '/')\n                {\n                  size_t size;\n                  int len;\n\n                  ungetc (c, fp);\n                  shared_library_fullname = NULL; size = 0;\n                  len = getline (&shared_library_fullname, &size, fp);\n                  if (len >= 0)\n                    {\n                      /* Success: filled shared_library_fullname.  */\n                      if (len > 0 && shared_library_fullname[len - 1] == '\\n')\n                        shared_library_fullname[len - 1] = '\\0';\n                    }\n                }\n              break;\n            }\n          while (c = getc (fp), c != EOF && c != '\\n')\n            continue;\n        }\n      fclose (fp);\n    }\n#endif\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_shared_library_fullname": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static char *\nget_shared_library_fullname ()\n{\n#if (!((defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__) \\\n     && !defined __EMX__)\n  static bool tried_find_shared_library_fullname;\n  if (!tried_find_shared_library_fullname)\n    {\n      find_shared_library_fullname ();\n      tried_find_shared_library_fullname = true;\n    }\n#endif\n  return shared_library_fullname;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_shared_library_fullname ()",
        "*"
      ]
    },
    "relocate": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "const char *\nrelocate (const char *pathname)\n{\n#if defined PIC && defined INSTALLDIR && ENABLE_COSTLY_RELOCATABLE\n  static int initialized;\n\n  /* Initialization code for a shared library.  */\n  if (!initialized)\n    {\n      /* At this point, orig_prefix and curr_prefix likely have already been\n         set through the main program's set_program_name_and_installdir\n         function.  This is sufficient in the case that the library has\n         initially been installed in the same orig_prefix.  But we can do\n         better, to also cover the cases that 1. it has been installed\n         in a different prefix before being moved to orig_prefix and (later)\n         to curr_prefix, 2. unlike the program, it has not moved away from\n         orig_prefix.  */\n      const char *orig_installprefix = INSTALLPREFIX;\n      const char *orig_installdir = INSTALLDIR;\n      char *curr_prefix_better;\n\n      curr_prefix_better =\n        compute_curr_prefix (orig_installprefix, orig_installdir,\n                             get_shared_library_fullname ());\n\n      set_relocation_prefix (orig_installprefix,\n                             curr_prefix_better != NULL\n                             ? curr_prefix_better\n                             : curr_prefix);\n\n      if (curr_prefix_better != NULL)\n        free (curr_prefix_better);\n\n      initialized = 1;\n    }\n#endif\n\n  /* Note: It is not necessary to perform case insensitive comparison here,\n     even for DOS-like file systems, because the pathname argument was\n     typically created from the same Makefile variable as orig_prefix came\n     from.  */\n  if (orig_prefix != NULL && curr_prefix != NULL\n      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)\n    {\n      if (pathname[orig_prefix_len] == '\\0')\n        {\n          /* pathname equals orig_prefix.  */\n          char *result = (char *) xmalloc (strlen (curr_prefix) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, curr_prefix);\n              return result;\n            }\n        }\n      else if (ISSLASH (pathname[orig_prefix_len]))\n        {\n          /* pathname starts with orig_prefix.  */\n          const char *pathname_tail = &pathname[orig_prefix_len];\n          char *result =\n            (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);\n\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              memcpy (result, curr_prefix, curr_prefix_len);\n              strcpy (result + curr_prefix_len, pathname_tail);\n              return result;\n            }\n        }\n    }\n\n#ifdef __EMX__\n# ifdef __KLIBC__\n#  undef strncmp\n\n  if (pathname && strncmp (pathname, \"/@unixroot\", 10) == 0\n      && (pathname[10] == '\\0' || pathname[10] == '/' || pathname[10] == '\\\\'))\n    {\n      /* kLIBC itself processes /@unixroot prefix */\n\n      return pathname;\n    }\n  else\n# endif\n  if (pathname && ISSLASH (pathname[0]))\n    {\n      const char *unixroot = getenv (\"UNIXROOT\");\n\n      if (unixroot && HAS_DEVICE (unixroot) && !unixroot[2])\n        {\n          char *result = (char *) xmalloc (2 + strlen (pathname) + 1);\n#ifdef NO_XMALLOC\n          if (result != NULL)\n#endif\n            {\n              strcpy (result, unixroot);\n              strcpy (result + 2, pathname);\n              return result;\n            }\n        }\n    }\n#endif\n\n  /* Nothing to relocate.  */\n  return pathname;\n}",
      "lines": 110,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrelocate (const char *pathname)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/relocatable.h": {},
  "libiconv/libiconv-1.15/srclib/relocwrapper.c": {
    "add_dotbin": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static char *\nadd_dotbin (const char *filename)\n{\n  size_t filename_len = strlen (filename);\n  char *result = (char *) malloc (filename_len + 4 + 1);\n\n  if (result != NULL)\n    {\n      if (sizeof (EXEEXT) > sizeof (\"\"))\n        {\n          /* EXEEXT handling.  */\n          const size_t exeext_len = sizeof (EXEEXT) - sizeof (\"\");\n          static const char exeext[] = EXEEXT;\n          if (filename_len > exeext_len)\n            {\n              /* Compare using an inlined copy of c_strncasecmp(), because\n                 the filenames may have undergone a case conversion since\n                 they were packaged.  In other words, EXEEXT may be \".exe\"\n                 on one system and \".EXE\" on another.  */\n              const char *s1 = filename + filename_len - exeext_len;\n              const char *s2 = exeext;\n              for (; *s1 != '\\0'; s1++, s2++)\n                {\n                  unsigned char c1 = *s1;\n                  unsigned char c2 = *s2;\n                  if (c_tolower (c1) != c_tolower (c2))\n                    goto simple_append;\n                }\n              /* Insert \".bin\" before EXEEXT or its equivalent.  */\n              memcpy (result, filename, filename_len - exeext_len);\n              memcpy (result + filename_len - exeext_len, \".bin\", 4);\n              memcpy (result + filename_len - exeext_len + 4,\n                      filename + filename_len - exeext_len,\n                      exeext_len + 1);\n              return result;\n            }\n        }\n     simple_append:\n      /* Simply append \".bin\".  */\n      memcpy (result, filename, filename_len);\n      memcpy (result + filename_len, \".bin\", 4 + 1);\n      return result;\n    }\n  else\n    {\n      fprintf (stderr, \"%s: %s\\n\", program_name, \"memory exhausted\");\n      exit (1);\n    }\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nadd_dotbin (const char *filename)",
        "*"
      ]
    },
    "relocate_libdirs": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "static void\nrelocate_libdirs ()\n{\n  size_t i;\n\n  for (i = 0; i < sizeof (libdirs) / sizeof (libdirs[0]) - 1; i++)\n    libdirs[i] = relocate (libdirs[i]);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "activate_libdirs": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static void\nactivate_libdirs ()\n{\n  const char *old_value;\n  size_t total;\n  size_t i;\n  char *value;\n  char *p;\n\n  old_value = getenv (LIBPATHVAR);\n  if (old_value == NULL)\n    old_value = \"\";\n\n  total = 0;\n  for (i = 0; i < sizeof (libdirs) / sizeof (libdirs[0]) - 1; i++)\n    total += strlen (libdirs[i]) + 1;\n  total += strlen (old_value) + 1;\n\n  value = (char *) malloc (total);\n  if (value == NULL)\n    {\n      fprintf (stderr, \"%s: %s\\n\", program_name, \"memory exhausted\");\n      exit (1);\n    }\n  p = value;\n  for (i = 0; i < sizeof (libdirs) / sizeof (libdirs[0]) - 1; i++)\n    {\n      size_t len = strlen (libdirs[i]);\n      memcpy (p, libdirs[i], len);\n      p += len;\n      *p++ = ':';\n    }\n  if (old_value[0] != '\\0')\n    strcpy (p, old_value);\n  else\n    p[-1] = '\\0';\n\n  if (setenv (LIBPATHVAR, value, 1) < 0)\n    {\n      fprintf (stderr, \"%s: %s\\n\", program_name, \"memory exhausted\");\n      exit (1);\n    }\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *full_program_name;\n\n  /* Set the program name and perform preparations for\n     get_full_program_name() and relocate().  */\n  set_program_name_and_installdir (argv[0], INSTALLPREFIX, INSTALLDIR);\n\n  /* Get the full program path.  (Important if accessed through a symlink.)  */\n  full_program_name = get_full_program_name ();\n  if (full_program_name == NULL)\n    full_program_name = argv[0];\n\n  /* Invoke the real program, with suffix \".bin\".  */\n  argv[0] = add_dotbin (full_program_name);\n  relocate_libdirs ();\n  activate_libdirs ();\n  execv (argv[0], argv);\n  fprintf (stderr, \"%s: could not execute %s: %s\\n\",\n           program_name, argv[0], strerror (errno));\n  exit (127);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/safe-read.c": {
    "safe_rw": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "size_t\nsafe_rw (int fd, void const *buf, size_t count)\n{\n  /* Work around a bug in Tru64 5.1.  Attempting to read more than\n     INT_MAX bytes fails with errno == EINVAL.  See\n     <http://lists.gnu.org/archive/html/bug-gnu-utils/2002-04/msg00010.html>.\n     When decreasing COUNT, keep it block-aligned.  */\n  enum { BUGGY_READ_MAXIMUM = INT_MAX & ~8191 };\n\n  for (;;)\n    {\n      ssize_t result = rw (fd, buf, count);\n\n      if (0 <= result)\n        return result;\n      else if (IS_EINTR (errno))\n        continue;\n      else if (errno == EINVAL && BUGGY_READ_MAXIMUM < count)\n        count = BUGGY_READ_MAXIMUM;\n      else\n        return result;\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/safe-read.h": {},
  "libiconv/libiconv-1.15/srclib/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/signal.in.h": {},
  "libiconv/libiconv-1.15/srclib/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/stdbool.in.h": {},
  "libiconv/libiconv-1.15/srclib/stddef.in.h": {},
  "libiconv/libiconv-1.15/srclib/stdint.in.h": {},
  "libiconv/libiconv-1.15/srclib/stdio-write.c": {
    "printf": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nprintf (const char *format, ...)\n{\n  int retval;\n  va_list args;\n\n  va_start (args, format);\n  retval = vfprintf (stdout, format, args);\n  va_end (args);\n\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "fprintf": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nfprintf (FILE *stream, const char *format, ...)\n{\n  int retval;\n  va_list args;\n\n  va_start (args, format);\n  retval = vfprintf (stream, format, args);\n  va_end (args);\n\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "vprintf": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\nvprintf (const char *format, va_list args)\n{\n  return vfprintf (stdout, format, args);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "putchar": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "int\nputchar (int c)\n{\n  return fputc (c, stdout);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/stdio.in.h": {},
  "libiconv/libiconv-1.15/srclib/stdlib.in.h": {},
  "libiconv/libiconv-1.15/srclib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/strerror-override.h": {},
  "libiconv/libiconv-1.15/srclib/strerror.c": {},
  "libiconv/libiconv-1.15/srclib/string.in.h": {},
  "libiconv/libiconv-1.15/srclib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/sys_time.in.h": {
    "GNULIB_NAMESPACE": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "namespace GNULIB_NAMESPACE {\n  typedef ::timeval\n#undef timeval\n    timeval;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    }
  },
  "libiconv/libiconv-1.15/srclib/sys_types.in.h": {},
  "libiconv/libiconv-1.15/srclib/time.in.h": {},
  "libiconv/libiconv-1.15/srclib/unistd.c": {},
  "libiconv/libiconv-1.15/srclib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/unitypes.in.h": {},
  "libiconv/libiconv-1.15/srclib/uniwidth.in.h": {},
  "libiconv/libiconv-1.15/srclib/unlocked-io.h": {},
  "libiconv/libiconv-1.15/srclib/verify.h": {},
  "libiconv/libiconv-1.15/srclib/xalloc-oversized.h": {},
  "libiconv/libiconv-1.15/srclib/xalloc.h": {
    "xrealloc": {
      "start_point": [
        51,
        9
      ],
      "end_point": [
        54,
        3
      ],
      "content": "T * xrealloc (T * ptr, size_t size)\n  {\n    return (T *) xrealloc ((void *) ptr, size);\n  }",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "T",
        "* xrealloc (T * ptr, size_t size)",
        "*"
      ]
    },
    "xnboundedmalloc": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static inline void *\nxnboundedmalloc (size_t n, size_t bound, size_t s)\n{\n  if (n > bound)\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "*\nxnboundedmalloc (size_t n, size_t bound, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        125,
        9
      ],
      "end_point": [
        128,
        3
      ],
      "content": "T * xmemdup (const T * p, size_t n)\n  {\n    return (T *) xmemdup ((const void *) p, n);\n  }",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "T",
        "* xmemdup (const T * p, size_t n)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/xmalloc.c": {
    "xalloc_die": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void\nxalloc_die ()\n{\n  error (xmalloc_exit_failure, 0, _(\"memory exhausted\"));\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does terminate, call exit. */\n  exit (EXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fixup_null_alloc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void *\nfixup_null_alloc (size_t n)\n{\n  void *p;\n\n  p = NULL;\n  if (n == 0)\n    p = malloc ((size_t) 1);\n  if (p == NULL)\n    xalloc_die ();\n  return p;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nfixup_null_alloc (size_t n)",
        "*"
      ]
    },
    "xmalloc": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p;\n\n  p = malloc (n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xnmalloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void *\nxnmalloc (size_t nmemb, size_t size)\n{\n  size_t n;\n  void *p;\n\n  if (xalloc_oversized (nmemb, size))\n    xalloc_die ();\n  n = nmemb * size;\n  p = malloc (n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxnmalloc (size_t nmemb, size_t size)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void *\nxzalloc (size_t size)\n{\n  void *p;\n\n  p = xmalloc (size);\n  memset (p, 0, size);\n  return p;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxzalloc (size_t size)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n\n  p = calloc (n, s);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (p == NULL)\n    return xmalloc (n);\n  p = realloc (p, n);\n  if (p == NULL)\n    p = fixup_null_alloc (n);\n  return p;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/xreadlink.c": {
    "xreadlink": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "char *\nxreadlink (char const *filename)\n{\n  char *result = areadlink (filename);\n  if (result == NULL && errno == ENOMEM)\n    xalloc_die ();\n  return result;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxreadlink (char const *filename)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/xreadlink.h": {},
  "libiconv/libiconv-1.15/srclib/xstrdup.c": {
    "xmemdup": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "void *\nxmemdup (const void *p, size_t n)\n{\n  void *q = xmalloc (n);\n  memcpy (q, p, n);\n  return q;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmemdup (const void *p, size_t n)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "char *\nxstrdup (const char *string)\n{\n  return strcpy (XNMALLOC (strlen (string) + 1, char), string);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxstrdup (const char *string)",
        "*"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/uniwidth/cjk.h": {
    "is_cjk_encoding": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nis_cjk_encoding (const char *encoding)\n{\n  if (0\n      /* Legacy Japanese encodings */\n      || STREQ_OPT (encoding, \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0)\n      /* Legacy Chinese encodings */\n      || STREQ_OPT (encoding, \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n      || STREQ_OPT (encoding, \"GBK\", 'G', 'B', 'K', 0, 0, 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0)\n      || STREQ_OPT (encoding, \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0)\n      /* Legacy Korean encodings */\n      || STREQ_OPT (encoding, \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n      || STREQ_OPT (encoding, \"CP949\", 'C', 'P', '9', '4', '9', 0, 0, 0, 0)\n      || STREQ_OPT (encoding, \"JOHAB\", 'J', 'O', 'H', 'A', 'B', 0, 0, 0, 0))\n    return 1;\n  return 0;\n}",
      "lines": 18,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/srclib/uniwidth/width.c": {
    "uc_width": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "int\nuc_width (ucs4_t uc, const char *encoding)\n{\n  /* Test for non-spacing or control character.  */\n  if ((uc >> 9) < 248)\n    {\n      int ind = nonspacing_table_ind[uc >> 9];\n      if (ind >= 0)\n        if ((nonspacing_table_data[64*ind + ((uc >> 3) & 63)] >> (uc & 7)) & 1)\n          {\n            if (uc > 0 && uc < 0xa0)\n              return -1;\n            else\n              return 0;\n          }\n    }\n  else if ((uc >> 9) == (0xe0000 >> 9))\n    {\n      if (uc >= 0xe0100)\n        {\n          if (uc <= 0xe01ef)\n            return 0;\n        }\n      else\n        {\n          if (uc >= 0xe0020 ? uc <= 0xe007f : uc == 0xe0001)\n            return 0;\n        }\n    }\n  /* Test for double-width character.\n   * Generated from \"grep '^[^;]\\{4,5\\};[WF]' EastAsianWidth.txt\"\n   * and            \"grep '^[^;]\\{4,5\\};[^WF]' EastAsianWidth.txt\"\n   */\n  if (uc >= 0x1100\n      && ((uc < 0x1160) /* Hangul Jamo */\n          || (uc >= 0x2329 && uc < 0x232b) /* Angle Brackets */\n          || (uc >= 0x2e80 && uc < 0xa4d0  /* CJK ... Yi */\n              && !(uc == 0x303f) && !(uc >= 0x4dc0 && uc < 0x4e00))\n          || (uc >= 0xac00 && uc < 0xd7a4) /* Hangul Syllables */\n          || (uc >= 0xf900 && uc < 0xfb00) /* CJK Compatibility Ideographs */\n          || (uc >= 0xfe10 && uc < 0xfe20) /* Presentation Forms for Vertical */\n          || (uc >= 0xfe30 && uc < 0xfe70) /* CJK Compatibility Forms */\n          || (uc >= 0xff00 && uc < 0xff61) /* Fullwidth Forms */\n          || (uc >= 0xffe0 && uc < 0xffe7) /* Fullwidth Signs */\n          || (uc >= 0x20000 && uc <= 0x2ffff) /* Supplementary Ideographic Plane */\n          || (uc >= 0x30000 && uc <= 0x3ffff) /* Tertiary Ideographic Plane */\n     )   )\n    return 2;\n  /* In ancient CJK encodings, Cyrillic and most other characters are\n     double-width as well.  */\n  if (uc >= 0x00A1 && uc < 0xFF61 && uc != 0x20A9\n      && is_cjk_encoding (encoding))\n    return 2;\n  return 1;\n}",
      "lines": 55,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/gengb18030z.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int main ()\n{\n  int i1, i2, i3, i4, uc;\n\n#if O_BINARY\n  SET_BINARY(fileno(stdout));\n#endif\n\n  uc = 0x10000;\n  for (i1 = 0x90; i1 <= 0xe3; i1++)\n    for (i2 = 0x30; i2 <= 0x39; i2++)\n      for (i3 = 0x81; i3 <= 0xfe; i3++)\n        for (i4 = 0x30; i4 <= 0x39; i4++) {\n          printf(\"0x%02X%02X%02X%02X\\t0x%X\\n\", i1, i2, i3, i4, uc);\n          uc++;\n          if (uc == 0x110000)\n            goto done;\n        }\n done:\n\n  if (ferror(stdout) || fclose(stdout))\n    exit(1);\n  exit(0);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/genutf8.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int main ()\n{\n  int i1, i2, i3;\n\n#if O_BINARY\n  SET_BINARY(fileno(stdout));\n#endif\n\n  /* Range 0x0000..0x007f */\n  for (i1 = 0; i1 < 0x80; i1++)\n    printf(\"0x%02X\\t0x%04X\\n\", i1, i1);\n  /* Range 0x0080..0x07ff */\n  for (i1 = 2; i1 < 32; i1++)\n    for (i2 = 0; i2 < 64; i2++)\n      printf(\"0x%02X%02X\\t0x%04X\\n\", 0xc0+i1,0x80+i2, (i1<<6)+i2);\n  /* Range 0x0800..0xffff, except 0xd800..0xdfff */\n  for (i1 = 0; i1 < 16; i1++)\n    for (i2 = (i1==0 ? 32 : 0); i2 < 64; i2++)\n      for (i3 = 0; i3 < 64; i3++) {\n        int u = (i1<<12)+(i2<<6)+i3;\n        if (!(u >= 0xd800 && u < 0xe000))\n          printf(\"0x%02X%02X%02X\\t0x%04X\\n\", 0xe0+i1,0x80+i2,0x80+i3, u);\n      }\n\n  if (ferror(stdout) || fclose(stdout))\n    exit(1);\n  exit(0);\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/table-from.c": {
    "hexbuf": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static const char* hexbuf (unsigned char buf[], unsigned int buflen)\n{\n  static char msg[50];\n  switch (buflen) {\n    case 1: sprintf(msg,\"0x%02X\",buf[0]); break;\n    case 2: sprintf(msg,\"0x%02X%02X\",buf[0],buf[1]); break;\n    case 3: sprintf(msg,\"0x%02X%02X%02X\",buf[0],buf[1],buf[2]); break;\n    case 4: sprintf(msg,\"0x%02X%02X%02X%02X\",buf[0],buf[1],buf[2],buf[3]); break;\n    default: abort();\n  }\n  return msg;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "* hexbuf (unsigned char buf[], unsigned int buflen)",
        "*"
      ]
    },
    "try": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int try (iconv_t cd, unsigned char buf[], unsigned int buflen, unsigned int* out)\n{\n  const char* inbuf = (const char*) buf;\n  size_t inbytesleft = buflen;\n  char* outbuf = (char*) out;\n  size_t outbytesleft = 3*sizeof(unsigned int);\n  size_t result;\n  iconv(cd,NULL,NULL,NULL,NULL);\n  result = iconv(cd,(ICONV_CONST char**)&inbuf,&inbytesleft,&outbuf,&outbytesleft);\n  if (result != (size_t)(-1))\n    result = iconv(cd,NULL,NULL,&outbuf,&outbytesleft);\n  if (result == (size_t)(-1)) {\n    if (errno == EILSEQ) {\n      return -1;\n    } else if (errno == EINVAL) {\n      return 0;\n    } else {\n      int saved_errno = errno;\n      fprintf(stderr,\"%s: iconv error: \",hexbuf(buf,buflen));\n      errno = saved_errno;\n      perror(\"\");\n      exit(1);\n    }\n  } else if (result > 0) /* ignore conversions with transliteration */ {\n    return -1;\n  } else {\n    if (inbytesleft != 0) {\n      fprintf(stderr,\"%s: inbytes = %ld, outbytes = %ld\\n\",hexbuf(buf,buflen),(long)(buflen-inbytesleft),(long)(3*sizeof(unsigned int)-outbytesleft));\n      exit(1);\n    }\n    return (3*sizeof(unsigned int)-outbytesleft)/sizeof(unsigned int);\n  }\n}",
      "lines": 33,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ucs4_decode": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static const char* ucs4_decode (const unsigned int* out, unsigned int outlen)\n{\n  static char hexbuf[21];\n  char* p = hexbuf;\n  while (outlen > 0) {\n    if (p > hexbuf)\n      *p++ = ' ';\n    sprintf (p, \"0x%04X\", out[0]);\n    out += 1; outlen -= 1;\n    if (bmp_only && strlen(p) > 6)\n      return NULL;\n    p += strlen(p);\n  }\n  return hexbuf;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "* ucs4_decode (const unsigned int* out, unsigned int outlen)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  const char* charset;\n  iconv_t cd;\n  int search_depth;\n\n  if (argc != 2) {\n    fprintf(stderr,\"Usage: table-from charset\\n\");\n    exit(1);\n  }\n  charset = argv[1];\n\n#if O_BINARY\n  SET_BINARY(fileno(stdout));\n#endif\n\n  cd = iconv_open(\"UCS-4-INTERNAL\",charset);\n  if (cd == (iconv_t)(-1)) {\n    perror(\"iconv_open\");\n    exit(1);\n  }\n\n  /* When testing UTF-8, stop at 0x10000, otherwise the output file gets too\n     big. */\n  bmp_only = (strcmp(charset,\"UTF-8\") == 0);\n  search_depth = (strcmp(charset,\"UTF-8\") == 0 ? 3 : 4);\n\n  {\n    unsigned int out[3];\n    unsigned char buf[4];\n    unsigned int i0, i1, i2, i3;\n    int result;\n    for (i0 = 0; i0 < 0x100; i0++) {\n      buf[0] = i0;\n      result = try(cd,buf,1,out);\n      if (result < 0) {\n      } else if (result > 0) {\n        const char* unicode = ucs4_decode(out,result);\n        if (unicode != NULL)\n          printf(\"0x%02X\\t%s\\n\",i0,unicode);\n      } else {\n        for (i1 = 0; i1 < 0x100; i1++) {\n          buf[1] = i1;\n          result = try(cd,buf,2,out);\n          if (result < 0) {\n          } else if (result > 0) {\n            const char* unicode = ucs4_decode(out,result);\n            if (unicode != NULL)\n              printf(\"0x%02X%02X\\t%s\\n\",i0,i1,unicode);\n          } else {\n            for (i2 = 0; i2 < 0x100; i2++) {\n              buf[2] = i2;\n              result = try(cd,buf,3,out);\n              if (result < 0) {\n              } else if (result > 0) {\n                const char* unicode = ucs4_decode(out,result);\n                if (unicode != NULL)\n                  printf(\"0x%02X%02X%02X\\t%s\\n\",i0,i1,i2,unicode);\n              } else if (search_depth > 3) {\n                for (i3 = 0; i3 < 0x100; i3++) {\n                  buf[3] = i3;\n                  result = try(cd,buf,4,out);\n                  if (result < 0) {\n                  } else if (result > 0) {\n                    const char* unicode = ucs4_decode(out,result);\n                    if (unicode != NULL)\n                      printf(\"0x%02X%02X%02X%02X\\t%s\\n\",i0,i1,i2,i3,unicode);\n                  } else {\n                    fprintf(stderr,\"%s: incomplete byte sequence\\n\",hexbuf(buf,4));\n                    exit(1);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (iconv_close(cd) < 0) {\n    perror(\"iconv_close\");\n    exit(1);\n  }\n\n  if (ferror(stdin) || ferror(stdout) || fclose(stdout)) {\n    fprintf(stderr,\"I/O error\\n\");\n    exit(1);\n  }\n\n  exit(0);\n}",
      "lines": 92,
      "depth": 30,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/table-to.c": {
    "main": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int main (int argc, char* argv[])\n{\n  const char* charset;\n  iconv_t cd;\n  int bmp_only;\n\n  if (argc != 2) {\n    fprintf(stderr,\"Usage: table-to charset\\n\");\n    exit(1);\n  }\n  charset = argv[1];\n\n#if O_BINARY\n  SET_BINARY(fileno(stdout));\n#endif\n\n  cd = iconv_open(charset,\"UCS-4-INTERNAL\");\n  if (cd == (iconv_t)(-1)) {\n    perror(\"iconv_open\");\n    exit(1);\n  }\n\n  /* When testing UTF-8, stop at 0x10000, otherwise the output file gets too\n     big. */\n  bmp_only = (strcmp(charset,\"UTF-8\") == 0);\n\n  {\n    unsigned int i;\n    unsigned char buf[10];\n    for (i = 0; i < (bmp_only ? 0x10000 : 0x110000); i++) {\n      unsigned int in = i;\n      const char* inbuf = (const char*) &in;\n      size_t inbytesleft = sizeof(unsigned int);\n      char* outbuf = (char*)buf;\n      size_t outbytesleft = sizeof(buf);\n      size_t result;\n      size_t result2 = 0;\n      iconv(cd,NULL,NULL,NULL,NULL);\n      result = iconv(cd,(ICONV_CONST char**)&inbuf,&inbytesleft,&outbuf,&outbytesleft);\n      if (result != (size_t)(-1))\n        result2 = iconv(cd,NULL,NULL,&outbuf,&outbytesleft);\n      if (result == (size_t)(-1) || result2 == (size_t)(-1)) {\n        if (errno != EILSEQ) {\n          int saved_errno = errno;\n          fprintf(stderr,\"0x%02X: iconv error: \",i);\n          errno = saved_errno;\n          perror(\"\");\n          exit(1);\n        }\n      } else if (result == 0) /* ignore conversions with transliteration */ {\n        if (inbytesleft == 0 && outbytesleft < sizeof(buf)) {\n          unsigned int jmax = sizeof(buf) - outbytesleft;\n          unsigned int j;\n          printf(\"0x\");\n          for (j = 0; j < jmax; j++)\n            printf(\"%02X\",buf[j]);\n          printf(\"\\t0x%04X\\n\",i);\n        } else if (inbytesleft == 0 && i >= 0xe0000 && i < 0xe0080) {\n          /* Language tags may silently be dropped. */\n        } else {\n          fprintf(stderr,\"0x%02X: inbytes = %ld, outbytes = %ld\\n\",i,(long)(sizeof(unsigned int)-inbytesleft),(long)(sizeof(buf)-outbytesleft));\n          exit(1);\n        }\n      }\n    }\n  }\n\n  if (iconv_close(cd) < 0) {\n    perror(\"iconv_close\");\n    exit(1);\n  }\n\n  if (ferror(stdin) || ferror(stdout) || fclose(stdout)) {\n    fprintf(stderr,\"I/O error\\n\");\n    exit(1);\n  }\n\n  exit(0);\n}",
      "lines": 79,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/test-shiftseq.c": {
    "main1": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void main1 (void)\n{\n  static const char input[] = \"+2D/YQNhB\";\n  iconv_t cd;\n  char buf[20];\n\n  const char * inptr;\n  size_t inleft;\n  char * outptr;\n  size_t outleft;\n\n  cd = iconv_open (\"UTF-8\", \"UTF-7\");\n  {\n    size_t r;\n\n    inptr = input;\n    inleft = 9;\n    outptr = buf;\n    outleft = sizeof (buf);\n    r = iconv (cd, (ICONV_CONST char **) &inptr, &inleft, &outptr, &outleft);\n    /*\n    printf (\"r = %d  errno = %d  inconsumed = %d outproduced = %d\\n\",\n            r, errno, inptr - input, outptr - buf);\n    // glibc:\n    //   r = -1  errno = 84  inconsumed = 4 outproduced = 0\n    // libiconv:\n    //   r = -1  errno = 84  inconsumed = 1 outproduced = 0\n    */\n    if (!(r == (size_t)(-1) && errno == EILSEQ\n          && inptr - input == 1 && outptr - buf == 0))\n      abort();\n  }\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main2": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void main2 (void)\n{\n  static const char input[] = \"+2D/YQNhB\";\n  iconv_t cd;\n  char buf[20];\n\n  const char * inptr;\n  size_t inleft;\n  char * outptr;\n  size_t outleft;\n\n  cd = iconv_open (\"UTF-8\", \"UTF-7\");\n  {\n    size_t r;\n\n    inptr = input;\n    inleft = 5;\n    outptr = buf;\n    outleft = sizeof (buf);\n    r = iconv (cd, (ICONV_CONST char **) &inptr, &inleft, &outptr, &outleft);\n    /*\n    printf (\"r = %d  errno = %d  inconsumed = %d outproduced = %d\\n\",\n            r, errno, inptr - input, outptr - buf);\n    // glibc:\n    //   r = -1  errno = 84 (EILSEQ)  inconsumed = 4 outproduced = 0\n    // libiconv:\n    //   r = -1  errno = 22 (EINVAL)  inconsumed = 1 outproduced = 0\n    */\n    if (!(r == (size_t)(-1) && errno == EINVAL\n          && inptr - input == 1 && outptr - buf == 0))\n      abort();\n\n    inleft = input + 20 - inptr;\n    r = iconv (cd, (ICONV_CONST char **) &inptr, &inleft, &outptr, &outleft);\n    /*\n    printf (\"r = %d  errno = %d  inconsumed = %d outproduced = %d\\n\",\n            r, errno, inptr - input, outptr - buf);\n    // glibc:\n    //   r = -1  errno = 84 (EILSEQ)  inconsumed = 4 outproduced = 0\n    // libiconv:\n    //   r = -1  errno = 84 (EILSEQ)  inconsumed = 1 outproduced = 0\n    */\n    if (!(r == (size_t)(-1) && errno == EILSEQ\n          && inptr - input == 1 && outptr - buf == 0))\n      abort();\n  }\n}",
      "lines": 47,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int main ()\n{\n  main1 ();\n  main2 ();\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/test-to-wchar.c": {
    "main": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int main ()\n{\n  iconv_t cd = iconv_open (\"wchar_t\", \"UTF-8\");\n  if (cd == (iconv_t)(-1)) {\n    /* Skip the test on platforms without wchar_t\n      (Solaris 2.6, HP-UX 11.00).  */\n  } else {\n    char inbuf[2] = { 0xc2, 0xa0 };\n    wchar_t outbuf[10];\n\n    char *inptr = inbuf;\n    size_t inbytesleft = 1;\n    char *outptr = (char *) outbuf;\n    size_t outbytesleft = sizeof (outbuf);\n    size_t r = iconv (cd,\n                      (ICONV_CONST char **) &inptr, &inbytesleft,\n                      &outptr, &outbytesleft);\n\n    if (!(r == (size_t)(-1) && errno == EINVAL))\n      abort ();\n  }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tests/uniq-u.c": {
    "xalloc_fail": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static void\nxalloc_fail (void)\n{\n  fprintf (stderr, \"%s: virtual memory exhausted\\n\", program_name);\n  exit (1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xmalloc": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p;\n\n  p = malloc (n);\n  if (p == 0)\n    xalloc_fail ();\n  return p;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  p = realloc (p, n);\n  if (p == 0)\n    xalloc_fail ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "initbuffer": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\ninitbuffer (struct linebuffer *linebuffer)\n{\n  linebuffer->length = 0;\n  linebuffer->size = 200;\n  linebuffer->buffer = (char *) xmalloc (linebuffer->size);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "readline": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static struct linebuffer *\nreadline (struct linebuffer *linebuffer, FILE *stream)\n{\n  int c;\n  char *buffer = linebuffer->buffer;\n  char *p = linebuffer->buffer;\n  char *end = buffer + linebuffer->size - 1; /* Sentinel. */\n\n  if (feof (stream) || ferror (stream))\n    return 0;\n\n  do\n    {\n      c = getc (stream);\n      if (c == EOF)\n        {\n          if (p == buffer)\n            return 0;\n          if (p[-1] == '\\n')\n            break;\n          c = '\\n';\n        }\n      if (p == end)\n        {\n          linebuffer->size *= 2;\n          buffer = (char *) xrealloc (buffer, linebuffer->size);\n          p = p - linebuffer->buffer + buffer;\n          linebuffer->buffer = buffer;\n          end = buffer + linebuffer->size - 1;\n        }\n      *p++ = c;\n    }\n  while (c != '\\n');\n\n  linebuffer->length = p - buffer;\n  return linebuffer;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct linebuffer",
        "struct",
        "linebuffer",
        "*\nreadline (struct linebuffer *linebuffer, FILE *stream)",
        "*"
      ]
    },
    "freebuffer": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nfreebuffer (struct linebuffer *linebuffer)\n{\n  free (linebuffer->buffer);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "different": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static int\ndifferent (const char *old, const char *new, size_t oldlen, size_t newlen)\n{\n  int order;\n\n  order = memcmp (old, new, min (oldlen, newlen));\n\n  if (order == 0)\n    return oldlen - newlen;\n  return order;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "writeline": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\nwriteline (const struct linebuffer *line, FILE *stream, int linecount)\n{\n  if (linecount == 0)\n    fwrite (line->buffer, 1, line->length, stream);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_file": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static void\ncheck_file (const char *infile, const char *outfile)\n{\n  FILE *istream;\n  FILE *ostream;\n  struct linebuffer lb1, lb2;\n  struct linebuffer *thisline, *prevline, *exch;\n  char *prevfield, *thisfield;\n  size_t prevlen, thislen;\n  int match_count = 0;\n\n  if (!strcmp (infile, \"-\"))\n    istream = stdin;\n  else\n    istream = fopen (infile, \"r\");\n  if (istream == NULL)\n    {\n      fprintf (stderr, \"%s: error opening %s\\n\", program_name, infile);\n      exit (1);\n    }\n\n  if (!strcmp (outfile, \"-\"))\n    ostream = stdout;\n  else\n    ostream = fopen (outfile, \"w\");\n  if (ostream == NULL)\n    {\n      fprintf (stderr, \"%s: error opening %s\\n\", program_name, outfile);\n      exit (1);\n    }\n\n  thisline = &lb1;\n  prevline = &lb2;\n\n  initbuffer (thisline);\n  initbuffer (prevline);\n\n  if (readline (prevline, istream) == 0)\n    goto closefiles;\n  prevfield = prevline->buffer;\n  prevlen = prevline->length;\n\n  while (!feof (istream))\n    {\n      int match;\n      if (readline (thisline, istream) == 0)\n        break;\n      thisfield = thisline->buffer;\n      thislen = thisline->length;\n      match = !different (thisfield, prevfield, thislen, prevlen);\n\n      if (match)\n        ++match_count;\n\n      if (!match)\n        {\n          writeline (prevline, ostream, match_count);\n          exch = prevline;\n          prevline = thisline;\n          thisline = exch;\n          prevfield = thisfield;\n          prevlen = thislen;\n          if (!match)\n            match_count = 0;\n        }\n    }\n\n  writeline (prevline, ostream, match_count);\n\n closefiles:\n  if (ferror (istream) || fclose (istream) == EOF)\n    {\n      fprintf (stderr, \"%s: error reading %s\\n\", program_name, infile);\n      exit (1);\n    }\n\n  if (ferror (ostream) || fclose (ostream) == EOF)\n    {\n      fprintf (stderr, \"%s: error writing %s\\n\", program_name, outfile);\n      exit (1);\n    }\n\n  freebuffer (&lb1);\n  freebuffer (&lb2);\n}",
      "lines": 85,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *infile = \"-\";\n  const char *outfile = \"-\";\n  int optind = 1;\n\n  program_name = argv[0];\n\n  if (optind < argc)\n    infile = argv[optind++];\n\n  if (optind < argc)\n    outfile = argv[optind++];\n\n  if (optind < argc)\n    {\n      fprintf (stderr, \"%s: too many arguments\\n\", program_name);\n      exit (1);\n    }\n\n  check_file (infile, outfile);\n\n  exit (0);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tools/8bit_tab_to_h.c": {
    "main": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "int main (int argc, char *argv[])\n{\n  const char* charsetname;\n  const char* c_charsetname;\n  const char* filename;\n  const char* directory;\n  int charset2uni[0x100];\n\n  if (argc != 3 && argc != 4 && argc != 5)\n    exit(1);\n  charsetname = argv[1];\n  c_charsetname = argv[2];\n  if (argc > 3) {\n    filename = argv[3];\n  } else {\n    char* s = (char*) malloc(strlen(c_charsetname)+strlen(\".h\")+1);\n    strcpy(s,c_charsetname); strcat(s,\".h\");\n    filename = s;\n  }\n  directory = (argc > 4 ? argv[4] : \"\");\n\n  fprintf(stderr, \"Creating %s%s\\n\", directory, filename);\n\n  {\n    int i, c;\n    c = getc(stdin);\n    ungetc(c,stdin);\n    if (c == '#') {\n      /* Read a unicode.org style .TXT file. */\n      for (i = 0; i < 0x100; i++)\n        charset2uni[i] = 0xfffd;\n      for (;;) {\n        c = getc(stdin);\n        if (c == EOF)\n          break;\n        if (c == '\\n' || c == ' ' || c == '\\t')\n          continue;\n        if (c == '#') {\n          do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n          continue;\n        }\n        ungetc(c,stdin);\n        if (scanf(\"0x%x\", &i) != 1 || !(i >= 0 && i < 0x100))\n          exit(1);\n        do { c = getc(stdin); } while (c == ' ' || c == '\\t');\n        if (c != EOF)\n          ungetc(c,stdin);\n        if (c == '\\n' || c == '#')\n          continue;\n        if (scanf(\"0x%x\", &charset2uni[i]) != 1)\n          exit(1);\n      }\n    } else {\n      /* Read a table of hexadecimal Unicode values. */\n      for (i = 0; i < 0x100; i++) {\n        if (scanf(\"%x\", &charset2uni[i]) != 1)\n          exit(1);\n        if (charset2uni[i] < 0 || charset2uni[i] == 0xffff)\n          charset2uni[i] = 0xfffd;\n      }\n      if (scanf(\"%x\", &i) != EOF)\n        exit(1);\n    }\n  }\n\n  /* Write the output file. */\n  {\n    FILE* f;\n\n    {\n      char* fname = malloc(strlen(directory)+strlen(filename)+1);\n      strcpy(fname,directory); strcat(fname,filename);\n      f = fopen(fname,\"w\");\n      if (f == NULL)\n        exit(1);\n    }\n\n    fprintf(f, \"/*\\n\");\n    fprintf(f, \" * Copyright (C) 1999-2002 Free Software Foundation, Inc.\\n\");\n    fprintf(f, \" * This file is part of the GNU LIBICONV Library.\\n\");\n    fprintf(f, \" *\\n\");\n    fprintf(f, \" * The GNU LIBICONV Library is free software; you can redistribute it\\n\");\n    fprintf(f, \" * and/or modify it under the terms of the GNU Library General Public\\n\");\n    fprintf(f, \" * License as published by the Free Software Foundation; either version 2\\n\");\n    fprintf(f, \" * of the License, or (at your option) any later version.\\n\");\n    fprintf(f, \" *\\n\");\n    fprintf(f, \" * The GNU LIBICONV Library is distributed in the hope that it will be\\n\");\n    fprintf(f, \" * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n    fprintf(f, \" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\");\n    fprintf(f, \" * Library General Public License for more details.\\n\");\n    fprintf(f, \" *\\n\");\n    fprintf(f, \" * You should have received a copy of the GNU Library General Public\\n\");\n    fprintf(f, \" * License along with the GNU LIBICONV Library; see the file COPYING.LIB.\\n\");\n    fprintf(f, \" * If not, see <http://www.gnu.org/licenses/>.\\n\");\n    fprintf(f, \" */\\n\");\n    fprintf(f, \"\\n\");\n    fprintf(f, \"/*\\n\");\n    fprintf(f, \" * %s\\n\", charsetname);\n    fprintf(f, \" */\\n\");\n    fprintf(f, \"\\n\");\n\n    {\n      int i, i1, i2, i3;\n      int line[16];\n      int tableno;\n      struct { int minline; int maxline; } tables[16];\n      bool some_invalid;\n      bool final_ret_reached;\n\n      for (i1 = 0; i1 < 16; i1++) {\n        bool all_invalid = true;\n        bool all_identity = true;\n        for (i2 = 0; i2 < 16; i2++) {\n          i = 16*i1+i2;\n          if (charset2uni[i] != 0xfffd)\n            all_invalid = false;\n          if (charset2uni[i] != i)\n            all_identity = false;\n        }\n        if (all_invalid)\n          line[i1] = -2;\n        else if (all_identity)\n          line[i1] = -1;\n        else\n          line[i1] = 0;\n      }\n      tableno = 0;\n      for (i1 = 0; i1 < 16; i1++) {\n        if (line[i1] >= 0) {\n          if (i1 > 0 && tableno > 0 && line[i1-1] == tableno-1) {\n            line[i1] = tableno-1;\n            tables[tableno-1].maxline = i1;\n          } else {\n            tableno++;\n            line[i1] = tableno-1;\n            tables[tableno-1].minline = tables[tableno-1].maxline = i1;\n          }\n        }\n      }\n      some_invalid = false;\n      for (i = 0; i < 0x100; i++)\n        if (charset2uni[i] == 0xfffd)\n          some_invalid = true;\n      if (tableno > 0) {\n        int t;\n        for (t = 0; t < tableno; t++) {\n          fprintf(f, \"static const unsigned short %s_2uni\", c_charsetname);\n          if (tableno > 1)\n            fprintf(f, \"_%d\", t+1);\n          fprintf(f, \"[%d] = {\\n\", 16*(tables[t].maxline-tables[t].minline+1));\n          for (i1 = tables[t].minline; i1 <= tables[t].maxline; i1++) {\n            fprintf(f, \"  /* 0x%02x */\\n\", 16*i1);\n            for (i2 = 0; i2 < 2; i2++) {\n              fprintf(f, \" \");\n              for (i3 = 0; i3 < 8; i3++) {\n                i = 16*i1+8*i2+i3;\n                fprintf(f, \" 0x%04x,\", charset2uni[i]);\n              }\n              fprintf(f, \"\\n\");\n            }\n          }\n          fprintf(f, \"};\\n\");\n        }\n        fprintf(f, \"\\n\");\n      }\n      final_ret_reached = false;\n      fprintf(f, \"static int\\n%s_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\\n\", c_charsetname);\n      fprintf(f, \"{\\n\");\n      fprintf(f, \"  unsigned char c = *s;\\n\");\n      if (some_invalid) {\n        for (i1 = 0; i1 < 16;) {\n          int t = line[i1];\n          const char* indent;\n          for (i2 = i1; i2 < 16 && line[i2] == t; i2++);\n          indent = (i1 == 0 && i2 == 16 ? \"  \" : \"    \");\n          if (i1 == 0) {\n            if (i2 == 16) {\n            } else {\n              fprintf(f, \"  if (c < 0x%02x) {\\n\", 16*i2);\n            }\n          } else {\n            if (i2 == 16) {\n              fprintf(f, \"  else {\\n\");\n            } else {\n              fprintf(f, \"  else if (c < 0x%02x) {\\n\", 16*i2);\n            }\n          }\n          if (t == -2) {\n            final_ret_reached = true;\n          } else if (t == -1) {\n            fprintf(f, \"%s*pwc = (ucs4_t) c;\\n\", indent);\n            fprintf(f, \"%sreturn 1;\\n\", indent);\n          } else {\n            fprintf(f, \"%s\", indent);\n            some_invalid = false;\n            for (i = 16*i1; i < 16*i2; i++)\n              if (charset2uni[i] == 0xfffd)\n                some_invalid = true;\n            if (some_invalid)\n              fprintf(f, \"unsigned short wc = \");\n            else\n              fprintf(f, \"*pwc = (ucs4_t) \");\n            fprintf(f, \"%s_2uni\", c_charsetname);\n            if (tableno > 1)\n              fprintf(f, \"_%d\", t+1);\n            fprintf(f, \"[c\");\n            if (tables[t].minline > 0)\n              fprintf(f, \"-0x%02x\", 16*tables[t].minline);\n            fprintf(f, \"];\\n\");\n            if (some_invalid) {\n              fprintf(f, \"%sif (wc != 0xfffd) {\\n\", indent);\n              fprintf(f, \"%s  *pwc = (ucs4_t) wc;\\n\", indent);\n              fprintf(f, \"%s  return 1;\\n\", indent);\n              fprintf(f, \"%s}\\n\", indent);\n              final_ret_reached = true;\n            } else {\n              fprintf(f, \"%sreturn 1;\\n\", indent);\n            }\n          }\n          if (!(i1 == 0 && i2 == 16))\n            fprintf(f, \"  }\\n\");\n          i1 = i2;\n        }\n        if (final_ret_reached)\n          fprintf(f, \"  return RET_ILSEQ;\\n\");\n      } else {\n        for (i1 = 0; i1 < 16;) {\n          int t = line[i1];\n          for (i2 = i1; i2 < 16 && line[i2] == t; i2++);\n          if (i1 == 0) {\n            if (i2 == 16) {\n              fprintf(f, \"  \");\n            } else {\n              fprintf(f, \"  if (c < 0x%02x)\\n    \", 16*i2);\n            }\n          } else {\n            if (i2 == 16) {\n              fprintf(f, \"  else\\n    \");\n            } else {\n              fprintf(f, \"  else if (c < 0x%02x)\\n    \", 16*i2);\n            }\n          }\n          if (t == -1)\n            fprintf(f, \"*pwc = (ucs4_t) c;\\n\");\n          else {\n            fprintf(f, \"*pwc = (ucs4_t) %s_2uni\", c_charsetname);\n            if (tableno > 1)\n              fprintf(f, \"_%d\", t+1);\n            fprintf(f, \"[c\");\n            if (tables[t].minline > 0)\n              fprintf(f, \"-0x%02x\", 16*tables[t].minline);\n            fprintf(f, \"];\\n\");\n          }\n          i1 = i2;\n        }\n        fprintf(f, \"  return 1;\\n\");\n      }\n      fprintf(f, \"}\\n\");\n\n    }\n\n    fprintf(f, \"\\n\");\n\n    {\n      int uni2charset[0x10000];\n      bool pages[0x100];\n      int line[0x2000];\n      int tableno;\n      struct { int minline; int maxline; int usecount; const char* suffix; } tables[0x2000];\n      bool need_c;\n      bool fix_0000;\n      int i, j, p, j1, j2, t;\n\n      for (j = 0; j < 0x10000; j++)\n        uni2charset[j] = 0;\n      for (p = 0; p < 0x100; p++)\n        pages[p] = false;\n      for (i = 0; i < 0x100; i++) {\n        j = charset2uni[i];\n        if (j != 0xfffd) {\n          uni2charset[j] = i;\n          pages[j>>8] = true;\n        }\n      }\n      for (j1 = 0; j1 < 0x2000; j1++) {\n        bool all_invalid = true;\n        bool all_identity = true;\n        for (j2 = 0; j2 < 8; j2++) {\n          j = 8*j1+j2;\n          if (uni2charset[j] != 0)\n            all_invalid = false;\n          if (uni2charset[j] != j)\n            all_identity = false;\n        }\n        if (all_invalid)\n          line[j1] = -2;\n        else if (all_identity)\n          line[j1] = -1;\n        else\n          line[j1] = 0;\n      }\n      tableno = 0;\n      for (j1 = 0; j1 < 0x2000; j1++) {\n        if (line[j1] >= 0) {\n          if (tableno > 0\n              && ((j1 > 0 && line[j1-1] == tableno-1)\n                  || ((tables[tableno-1].maxline >> 5) == (j1 >> 5)\n                      && j1 - tables[tableno-1].maxline <= 8))) {\n            line[j1] = tableno-1;\n            tables[tableno-1].maxline = j1;\n          } else {\n            tableno++;\n            line[j1] = tableno-1;\n            tables[tableno-1].minline = tables[tableno-1].maxline = j1;\n          }\n        }\n      }\n      for (t = 0; t < tableno; t++) {\n        tables[t].usecount = 0;\n        j1 = 8*tables[t].minline;\n        j2 = 8*(tables[t].maxline+1);\n        for (j = j1; j < j2; j++)\n          if (uni2charset[j] != 0)\n            tables[t].usecount++;\n      }\n      for (t = 0, p = -1, i = 0; t < tableno; t++) {\n        if (tables[t].usecount > 1) {\n          char* s;\n          if (p == tables[t].minline >> 5) {\n            s = (char*) malloc(5+1);\n            sprintf(s, \"%02x_%d\", p, ++i);\n          } else {\n            p = tables[t].minline >> 5;\n            s = (char*) malloc(2+1);\n            sprintf(s, \"%02x\", p);\n          }\n          tables[t].suffix = s;\n        } else\n          tables[t].suffix = NULL;\n      }\n      {\n        p = -1;\n        for (t = 0; t < tableno; t++)\n          if (tables[t].usecount > 1) {\n            p = 0;\n            fprintf(f, \"static const unsigned char %s_page%s[%d] = {\\n\", c_charsetname, tables[t].suffix, 8*(tables[t].maxline-tables[t].minline+1));\n            for (j1 = tables[t].minline; j1 <= tables[t].maxline; j1++) {\n              if ((j1 % 0x20) == 0 && j1 > tables[t].minline)\n                fprintf(f, \"  /* 0x%04x */\\n\", 8*j1);\n              fprintf(f, \" \");\n              for (j2 = 0; j2 < 8; j2++) {\n                j = 8*j1+j2;\n                fprintf(f, \" 0x%02x,\", uni2charset[j]);\n              }\n              fprintf(f, \" /* 0x%02x-0x%02x */\\n\", 8*(j1 % 0x20), 8*(j1 % 0x20)+7);\n            }\n            fprintf(f, \"};\\n\");\n          }\n        if (p >= 0)\n          fprintf(f, \"\\n\");\n      }\n      need_c = false;\n      for (j1 = 0; j1 < 0x2000;) {\n        t = line[j1];\n        for (j2 = j1; j2 < 0x2000 && line[j2] == t; j2++);\n        if (t >= 0)\n          j2 = tables[t].maxline+1;\n        if (!(t == -2 || (t == -1 && j1 == 0)))\n          need_c = true;\n        j1 = j2;\n      }\n      fix_0000 = false;\n      fprintf(f, \"static int\\n%s_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\\n\", c_charsetname);\n      fprintf(f, \"{\\n\");\n      if (need_c)\n        fprintf(f, \"  unsigned char c = 0;\\n\");\n      for (j1 = 0; j1 < 0x2000;) {\n        t = line[j1];\n        for (j2 = j1; j2 < 0x2000 && line[j2] == t; j2++);\n        if (t >= 0) {\n          if (j1 != tables[t].minline) abort();\n          if (j2 > tables[t].maxline+1) abort();\n          j2 = tables[t].maxline+1;\n        }\n        if (t == -2) {\n        } else {\n          if (j1 == 0)\n            fprintf(f, \"  \");\n          else\n            fprintf(f, \"  else \");\n          if (t >= 0 && tables[t].usecount == 0) abort();\n          if (t >= 0 && tables[t].usecount == 1) {\n            if (j2 != j1+1) abort();\n            for (j = 8*j1; j < 8*j2; j++)\n              if (uni2charset[j] != 0) {\n                fprintf(f, \"if (wc == 0x%04x)\\n    c = 0x%02x;\\n\", j, uni2charset[j]);\n                break;\n              }\n          } else {\n            if (j1 == 0) {\n              fprintf(f, \"if (wc < 0x%04x)\", 8*j2);\n            } else {\n              fprintf(f, \"if (wc >= 0x%04x && wc < 0x%04x)\", 8*j1, 8*j2);\n            }\n            if (t == -1) {\n              if (j1 == 0)\n                /* If wc == 0, the function must return 1, not -1. */\n                fprintf(f, \" {\\n    *r = wc;\\n    return 1;\\n  }\\n\");\n              else\n                fprintf(f, \"\\n    c = wc;\\n\");\n            } else {\n              fprintf(f, \"\\n    c = %s_page%s[wc\", c_charsetname, tables[t].suffix);\n              if (tables[t].minline > 0)\n                fprintf(f, \"-0x%04x\", 8*j1);\n              fprintf(f, \"];\\n\");\n              if (j1 == 0 && uni2charset[0] == 0)\n                /* If wc == 0, the function must return 1, not -1. */\n                fix_0000 = true;\n            }\n          }\n        }\n        j1 = j2;\n      }\n      if (need_c) {\n        if (fix_0000)\n          fprintf(f, \"  if (c != 0 || wc == 0) {\\n\");\n        else\n          fprintf(f, \"  if (c != 0) {\\n\");\n        fprintf(f, \"    *r = c;\\n\");\n        fprintf(f, \"    return 1;\\n\");\n        fprintf(f, \"  }\\n\");\n      }\n      fprintf(f, \"  return RET_ILUNI;\\n\");\n      fprintf(f, \"}\\n\");\n\n    }\n\n    if (ferror(f) || fclose(f))\n      exit(1);\n  }\n\n#if 0\n\n    int i1, i2, i3, i1_min, i1_max, j1, j2;\n\n  i1_min = 16;\n  i1_max = -1;\n  for (i1 = 0; i1 < 16; i1++)\n    for (i2 = 0; i2 < 16; i2++)\n      if (charset2uni[16*i1+i2] != 0xfffd) {\n        if (i1_min > i1) i1_min = i1;\n        if (i1_max < i1) i1_max = i1;\n      }\n  printf(\"static const unsigned short %s_2uni[%d] = {\\n\",\n         name, 16*(i1_max-i1_min+1));\n  for (i1 = i1_min; i1 <= i1_max; i1++) {\n    printf(\"  /\"\"* 0x%02x *\"\"/\\n\", 16*i1);\n    for (i2 = 0; i2 < 2; i2++) {\n      printf(\"  \");\n      for (i3 = 0; i3 < 8; i3++) {\n        if (i3 > 0) printf(\" \");\n        printf(\"0x%04x,\", charset2uni[16*i1+8*i2+i3]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  printf(\"};\\n\");\n  printf(\"\\n\");\n\n  for (p = 0; p < 0x100; p++)\n    pages[p] = 0;\n  for (i = 0; i < 0x100; i++)\n    if (charset2uni[i] != 0xfffd)\n      pages[charset2uni[i]>>8] = 1;\n  for (p = 0; p < 0x100; p++)\n    if (pages[p]) {\n      int j1_min = 32;\n      int j1_max = -1;\n      for (j1 = 0; j1 < 32; j1++)\n        for (j2 = 0; j2 < 8; j2++)\n          if (uni2charset[256*p+8*j1+j2] != 0) {\n            if (j1_min > j1) j1_min = j1;\n            if (j1_max < j1) j1_max = j1;\n          }\n      printf(\"static const unsigned char %s_page%02x[%d] = {\\n\",\n             name, p, 8*(j1_max-j1_min+1));\n      for (j1 = j1_min; j1 <= j1_max; j1++) {\n        printf(\"  \");\n        for (j2 = 0; j2 < 8; j2++)\n          printf(\"0x%02x, \", uni2charset[256*p+8*j1+j2]);\n        printf(\"/\"\"* 0x%02x-0x%02x *\"\"/\\n\", 8*j1, 8*j1+7);\n      }\n      printf(\"};\\n\");\n    }\n  printf(\"\\n\");\n\n}",
      "lines": 497,
      "depth": 22,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tools/cjk_tab_to_h.c": {
    "output_title": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static void output_title (const char *charsetname)\n{\n  printf(\"/*\\n\");\n  printf(\" * Copyright (C) 1999-2016 Free Software Foundation, Inc.\\n\");\n  printf(\" * This file is part of the GNU LIBICONV Library.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is free software; you can redistribute it\\n\");\n  printf(\" * and/or modify it under the terms of the GNU Library General Public\\n\");\n  printf(\" * License as published by the Free Software Foundation; either version 2\\n\");\n  printf(\" * of the License, or (at your option) any later version.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is distributed in the hope that it will be\\n\");\n  printf(\" * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n  printf(\" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\");\n  printf(\" * Library General Public License for more details.\\n\");\n  printf(\" *\\n\");\n  printf(\" * You should have received a copy of the GNU Library General Public\\n\");\n  printf(\" * License along with the GNU LIBICONV Library; see the file COPYING.LIB.\\n\");\n  printf(\" * If not, see <http://www.gnu.org/licenses/>.\\n\");\n  printf(\" */\\n\");\n  printf(\"\\n\");\n  printf(\"/*\\n\");\n  printf(\" * %s\\n\", charsetname);\n  printf(\" */\\n\");\n  printf(\"\\n\");\n}",
      "lines": 26,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_table": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void read_table (Encoding* enc)\n{\n  int row, col, i, i1, i2, c, j;\n\n  enc->charset2uni = (int**) malloc(enc->rows*sizeof(int*));\n  for (row = 0; row < enc->rows; row++)\n    enc->charset2uni[row] = (int*) malloc(enc->cols*sizeof(int));\n\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++)\n      enc->charset2uni[row][col] = 0xfffd;\n\n  c = getc(stdin);\n  ungetc(c,stdin);\n  if (c == '#') {\n    /* Read a unicode.org style .TXT file. */\n    for (;;) {\n      c = getc(stdin);\n      if (c == EOF)\n        break;\n      if (c == '\\n' || c == ' ' || c == '\\t')\n        continue;\n      if (c == '#') {\n        do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n        continue;\n      }\n      ungetc(c,stdin);\n      if (scanf(\"0x%x\", &j) != 1)\n        exit(1);\n      i1 = j >> 8;\n      i2 = j & 0xff;\n      row = enc->byte_row(i1);\n      col = enc->byte_col(i2);\n      if (row < 0 || col < 0) {\n        fprintf(stderr, \"lost entry for %02x %02x\\n\", i1, i2);\n        exit(1);\n      }\n      if (scanf(\" 0x%x\", &enc->charset2uni[row][col]) != 1)\n        exit(1);\n    }\n  } else {\n    /* Read a table of hexadecimal Unicode values. */\n    for (i1 = 32; i1 < 132; i1++)\n      for (i2 = 32; i2 < 132; i2++) {\n        i = scanf(\"%x\", &j);\n        if (i == EOF)\n          goto read_done;\n        if (i != 1)\n          exit(1);\n        if (j < 0 || j == 0xffff)\n          j = 0xfffd;\n        if (j != 0xfffd) {\n          if (enc->byte_row(i1) < 0 || enc->byte_col(i2) < 0) {\n            fprintf(stderr, \"lost entry at %02x %02x\\n\", i1, i2);\n            exit (1);\n          }\n          enc->charset2uni[enc->byte_row(i1)][enc->byte_col(i2)] = j;\n        }\n      }\n   read_done: ;\n  }\n}",
      "lines": 62,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_charset2uni_large": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static bool is_charset2uni_large (Encoding* enc)\n{\n  int row, col;\n\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++)\n      if (enc->charset2uni[row][col] >= 0x10000)\n        return true;\n  return false;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "compact_large_charset2uni": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static int compact_large_charset2uni (Encoding* enc, unsigned int **urows, unsigned int *urowshift)\n{\n  unsigned int shift;\n\n  for (shift = 8; ; shift--) {\n    int *upages = (int *) malloc((0x110000>>shift) * sizeof(int));\n    int i, row, col, nurows;\n\n    for (i = 0; i < 0x110000>>shift; i++)\n      upages[i] = -1;\n\n    for (row = 0; row < enc->rows; row++)\n      for (col = 0; col < enc->cols; col++)\n        upages[enc->charset2uni[row][col] >> shift] = 0;\n\n    nurows = 0;\n    for (i = 0; i < 0x110000>>shift; i++)\n      if (upages[i] == 0)\n        nurows++;\n\n    /* We want all table entries to fit in an 'unsigned short'. */\n    if (nurows <= 1<<(16-shift)) {\n      int** old_charset2uni;\n\n      *urows = (unsigned int *) malloc(nurows * sizeof(unsigned int));\n      *urowshift = shift;\n\n      nurows = 0;\n      for (i = 0; i < 0x110000>>shift; i++)\n        if (upages[i] == 0) {\n          upages[i] = nurows;\n          (*urows)[nurows] = i;\n          nurows++;\n        }\n\n      old_charset2uni = enc->charset2uni;\n      enc->charset2uni = (int**) malloc(enc->rows*sizeof(int*));\n      for (row = 0; row < enc->rows; row++)\n        enc->charset2uni[row] = (int*) malloc(enc->cols*sizeof(int));\n      for (row = 0; row < enc->rows; row++)\n        for (col = 0; col < enc->cols; col++) {\n          int u = old_charset2uni[row][col];\n          enc->charset2uni[row][col] =\n            (upages[u >> shift] << shift) | (u & ((1 << shift) - 1));\n        }\n      enc->fffd =\n        (upages[0xfffd >> shift] << shift) | (0xfffd & ((1 << shift) - 1));\n\n      return nurows;\n    }\n  }\n  abort();\n}",
      "lines": 53,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_charset2uni_pages": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static void find_charset2uni_pages (Encoding* enc)\n{\n  int row, col;\n\n  enc->charsetpage = (int*) malloc((enc->rows+1)*sizeof(int));\n\n  for (row = 0; row <= enc->rows; row++)\n    enc->charsetpage[row] = 0;\n\n  for (row = 0; row < enc->rows; row++) {\n    int used = 0;\n    for (col = 0; col < enc->cols; col++)\n      if (enc->charset2uni[row][col] != enc->fffd)\n        used = col+1;\n    enc->charsetpage[row] = used;\n  }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_charset2uni_blocks": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static void find_charset2uni_blocks (Encoding* enc)\n{\n  int n, row, lastrow;\n\n  enc->charsetblocks = (Block*) malloc(enc->rows*sizeof(Block));\n\n  n = 0;\n  for (row = 0; row < enc->rows; row++)\n    if (enc->charsetpage[row] > 0 && (row == 0 || enc->charsetpage[row-1] == 0)) {\n      for (lastrow = row; enc->charsetpage[lastrow+1] > 0; lastrow++);\n      enc->charsetblocks[n].start = row * enc->cols;\n      enc->charsetblocks[n].end = lastrow * enc->cols + enc->charsetpage[lastrow];\n      n++;\n    }\n  enc->ncharsetblocks = n;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_charset2uni": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "static void output_charset2uni (const char* name, Encoding* enc)\n{\n  int nurows, row, col, lastrow, col_max, i, i1_min, i1_max;\n  bool is_large;\n  unsigned int* urows;\n  unsigned int urowshift;\n  Encoding tmpenc;\n\n  is_large = is_charset2uni_large(enc);\n  if (is_large) {\n    /* Use a temporary copy of enc. */\n    tmpenc = *enc;\n    enc = &tmpenc;\n    nurows = compact_large_charset2uni(enc,&urows,&urowshift);\n  } else {\n    nurows = 0; urows = NULL; urowshift = 0; enc->fffd = 0xfffd;\n  }\n\n  find_charset2uni_pages(enc);\n\n  find_charset2uni_blocks(enc);\n\n  for (row = 0; row < enc->rows; row++)\n    if (enc->charsetpage[row] > 0) {\n      if (row == 0 || enc->charsetpage[row-1] == 0) {\n        /* Start a new block. */\n        for (lastrow = row; enc->charsetpage[lastrow+1] > 0; lastrow++);\n        printf(\"static const unsigned short %s_2uni_page%02x[%d] = {\\n\",\n               name, enc->row_byte(row),\n               (lastrow-row) * enc->cols + enc->charsetpage[lastrow]);\n      }\n      printf(\"  /\"\"* 0x%02x *\"\"/\\n \", enc->row_byte(row));\n      col_max = (enc->charsetpage[row+1] > 0 ? enc->cols : enc->charsetpage[row]);\n      for (col = 0; col < col_max; col++) {\n        printf(\" 0x%04x,\", enc->charset2uni[row][col]);\n        if ((col % 8) == 7 && (col+1 < col_max)) printf(\"\\n \");\n      }\n      printf(\"\\n\");\n      if (enc->charsetpage[row+1] == 0) {\n        /* End a block. */\n        printf(\"};\\n\");\n      }\n    }\n  printf(\"\\n\");\n\n  if (is_large) {\n    printf(\"static const ucs4_t %s_2uni_upages[%d] = {\\n \", name, nurows);\n    for (i = 0; i < nurows; i++) {\n      printf(\" 0x%05x,\", urows[i] << urowshift);\n      if ((i % 8) == 7 && (i+1 < nurows)) printf(\"\\n \");\n    }\n    printf(\"\\n\");\n    printf(\"};\\n\");\n    printf(\"\\n\");\n  }\n\n  printf(\"static int\\n\");\n  printf(\"%s_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  unsigned char c1 = s[0];\\n\");\n  printf(\"  if (\");\n  for (i = 0; i < enc->ncharsetblocks; i++) {\n    i1_min = enc->row_byte(enc->charsetblocks[i].start / enc->cols);\n    i1_max = enc->row_byte((enc->charsetblocks[i].end-1) / enc->cols);\n    if (i > 0)\n      printf(\" || \");\n    if (i1_min == i1_max)\n      printf(\"(c1 == 0x%02x)\", i1_min);\n    else\n      printf(\"(c1 >= 0x%02x && c1 <= 0x%02x)\", i1_min, i1_max);\n  }\n  printf(\") {\\n\");\n  printf(\"    if (n >= 2) {\\n\");\n  printf(\"      unsigned char c2 = s[1];\\n\");\n  printf(\"      if (\");\n  printf(enc->check_col_expr, \"c2\");\n  printf(\") {\\n\");\n  printf(\"        unsigned int i = %d * (\", enc->cols);\n  printf(enc->byte_row_expr, \"c1\");\n  printf(\") + (\");\n  printf(enc->byte_col_expr, \"c2\");\n  printf(\");\\n\");\n  printf(\"        %s wc = 0xfffd;\\n\", is_large ? \"ucs4_t\" : \"unsigned short\");\n  if (is_large) printf(\"        unsigned short swc;\\n\");\n  for (i = 0; i < enc->ncharsetblocks; i++) {\n    printf(\"        \");\n    if (i > 0)\n      printf(\"} else \");\n    if (i < enc->ncharsetblocks-1)\n      printf(\"if (i < %d) \", enc->charsetblocks[i+1].start);\n    printf(\"{\\n\");\n    printf(\"          if (i < %d)\\n\", enc->charsetblocks[i].end);\n    printf(\"            %s = \", is_large ? \"swc\" : \"wc\");\n    printf(\"%s_2uni_page%02x[i\", name, enc->row_byte(enc->charsetblocks[i].start / enc->cols));\n    if (enc->charsetblocks[i].start > 0)\n      printf(\"-%d\", enc->charsetblocks[i].start);\n    printf(\"]\");\n    if (is_large) printf(\",\\n            wc = %s_2uni_upages[swc>>%d] | (swc & 0x%x)\", name, urowshift, (1 << urowshift) - 1);\n    printf(\";\\n\");\n  }\n  printf(\"        }\\n\");\n  printf(\"        if (wc != 0xfffd) {\\n\");\n  printf(\"          *pwc = %swc;\\n\", is_large ? \"\" : \"(ucs4_t) \");\n  printf(\"          return 2;\\n\");\n  printf(\"        }\\n\");\n  printf(\"      }\\n\");\n  printf(\"      return RET_ILSEQ;\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_TOOFEW(0);\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_ILSEQ;\\n\");\n  printf(\"}\\n\");\n  printf(\"\\n\");\n}",
      "lines": 114,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_charset2uni_noholes_monotonic": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static void output_charset2uni_noholes_monotonic (const char* name, Encoding* enc)\n{\n  int row, col, lastrow, r, col_max, i, i1_min, i1_max;\n\n  /* Choose stepsize so that stepsize*steps_per_row >= enc->cols, and\n     enc->charset2uni[row][col] - enc->charset2uni[row][col/stepsize*stepsize]\n     is always < 0x100. */\n  int steps_per_row = 2;\n  int stepsize = (enc->cols + steps_per_row-1) / steps_per_row;\n\n  find_charset2uni_pages(enc);\n\n  find_charset2uni_blocks(enc);\n\n  for (row = 0; row < enc->rows; row++)\n    if (enc->charsetpage[row] > 0) {\n      if (row == 0 || enc->charsetpage[row-1] == 0) {\n        /* Start a new block. */\n        for (lastrow = row; enc->charsetpage[lastrow+1] > 0; lastrow++);\n        printf(\"static const unsigned short %s_2uni_main_page%02x[%d] = {\\n \",\n               name, enc->row_byte(row),\n               steps_per_row*(lastrow-row+1));\n        for (r = row; r <= lastrow; r++) {\n          for (i = 0; i < steps_per_row; i++)\n            printf(\" 0x%04x,\", enc->charset2uni[r][i*stepsize]);\n          if (((r-row) % 4) == 3 && (r < lastrow)) printf(\"\\n \");\n        }\n        printf(\"\\n\");\n        printf(\"};\\n\");\n        printf(\"static const unsigned char %s_2uni_page%02x[%d] = {\\n\",\n               name, enc->row_byte(row),\n               (lastrow-row) * enc->cols + enc->charsetpage[lastrow]);\n      }\n      printf(\"  /\"\"* 0x%02x *\"\"/\\n \", enc->row_byte(row));\n      col_max = (enc->charsetpage[row+1] > 0 ? enc->cols : enc->charsetpage[row]);\n      for (col = 0; col < col_max; col++) {\n        printf(\" 0x%02x,\", enc->charset2uni[row][col] - enc->charset2uni[row][col/stepsize*stepsize]);\n        if ((col % 8) == 7 && (col+1 < col_max)) printf(\"\\n \");\n      }\n      printf(\"\\n\");\n      if (enc->charsetpage[row+1] == 0) {\n        /* End a block. */\n        printf(\"};\\n\");\n      }\n    }\n  printf(\"\\n\");\n\n  printf(\"static int\\n\");\n  printf(\"%s_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  unsigned char c1 = s[0];\\n\");\n  printf(\"  if (\");\n  for (i = 0; i < enc->ncharsetblocks; i++) {\n    i1_min = enc->row_byte(enc->charsetblocks[i].start / enc->cols);\n    i1_max = enc->row_byte((enc->charsetblocks[i].end-1) / enc->cols);\n    if (i > 0)\n      printf(\" || \");\n    if (i1_min == i1_max)\n      printf(\"(c1 == 0x%02x)\", i1_min);\n    else\n      printf(\"(c1 >= 0x%02x && c1 <= 0x%02x)\", i1_min, i1_max);\n  }\n  printf(\") {\\n\");\n  printf(\"    if (n >= 2) {\\n\");\n  printf(\"      unsigned char c2 = s[1];\\n\");\n  printf(\"      if (\");\n  printf(enc->check_col_expr, \"c2\");\n  printf(\") {\\n\");\n  printf(\"        unsigned int row = \");\n  printf(enc->byte_row_expr, \"c1\");\n  printf(\";\\n\");\n  printf(\"        unsigned int col = \");\n  printf(enc->byte_col_expr, \"c2\");\n  printf(\";\\n\");\n  printf(\"        unsigned int i = %d * row + col;\\n\", enc->cols);\n  printf(\"        unsigned short wc = 0xfffd;\\n\");\n  for (i = 0; i < enc->ncharsetblocks; i++) {\n    printf(\"        \");\n    if (i > 0)\n      printf(\"} else \");\n    if (i < enc->ncharsetblocks-1)\n      printf(\"if (i < %d) \", enc->charsetblocks[i+1].start);\n    printf(\"{\\n\");\n    printf(\"          if (i < %d)\\n\", enc->charsetblocks[i].end);\n    printf(\"            wc = %s_2uni_main_page%02x[%d*\", name, enc->row_byte(enc->charsetblocks[i].start / enc->cols), steps_per_row);\n    if (enc->charsetblocks[i].start > 0)\n      printf(\"(row-%d)\", enc->charsetblocks[i].start / enc->cols);\n    else\n      printf(\"row\");\n    printf(\"+\");\n    if (steps_per_row == 2)\n      printf(\"(col>=%d?1:0)\", stepsize);\n    else\n      printf(\"col/%d\", stepsize);\n    printf(\"] + %s_2uni_page%02x[i\", name, enc->row_byte(enc->charsetblocks[i].start / enc->cols));\n    if (enc->charsetblocks[i].start > 0)\n      printf(\"-%d\", enc->charsetblocks[i].start);\n    printf(\"];\\n\");\n  }\n  printf(\"        }\\n\");\n  printf(\"        if (wc != 0xfffd) {\\n\");\n  printf(\"          *pwc = (ucs4_t) wc;\\n\");\n  printf(\"          return 2;\\n\");\n  printf(\"        }\\n\");\n  printf(\"      }\\n\");\n  printf(\"      return RET_ILSEQ;\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_TOOFEW(0);\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_ILSEQ;\\n\");\n  printf(\"}\\n\");\n  printf(\"\\n\");\n}",
      "lines": 113,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "invert": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static void invert (Encoding* enc)\n{\n  int row, col, j;\n\n  enc->uni2charset = (int*) malloc(0x30000*sizeof(int));\n\n  for (j = 0; j < 0x30000; j++)\n    enc->uni2charset[j] = 0;\n\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++) {\n      j = enc->charset2uni[row][col];\n      if (j != 0xfffd)\n        enc->uni2charset[j] = 0x100 * enc->row_byte(row) + enc->col_byte(col);\n    }\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_uni2charset_dense": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "static void output_uni2charset_dense (const char* name, Encoding* enc)\n{\n  /* Like in 8bit_tab_to_h.c */\n  bool pages[0x300];\n  int line[0x6000];\n  int tableno;\n  struct { int minline; int maxline; int usecount; } tables[0x6000];\n  bool first;\n  int row, col, j, p, j1, j2, t;\n\n  for (p = 0; p < 0x300; p++)\n    pages[p] = false;\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++) {\n      j = enc->charset2uni[row][col];\n      if (j != 0xfffd)\n        pages[j>>8] = true;\n    }\n  for (j1 = 0; j1 < 0x6000; j1++) {\n    bool all_invalid = true;\n    for (j2 = 0; j2 < 8; j2++) {\n      j = 8*j1+j2;\n      if (enc->uni2charset[j] != 0)\n        all_invalid = false;\n    }\n    if (all_invalid)\n      line[j1] = -1;\n    else\n      line[j1] = 0;\n  }\n  tableno = 0;\n  for (j1 = 0; j1 < 0x6000; j1++) {\n    if (line[j1] >= 0) {\n      if (tableno > 0\n          && ((j1 > 0 && line[j1-1] == tableno-1)\n              || ((tables[tableno-1].maxline >> 5) == (j1 >> 5)\n                  && j1 - tables[tableno-1].maxline <= 8))) {\n        line[j1] = tableno-1;\n        tables[tableno-1].maxline = j1;\n      } else {\n        tableno++;\n        line[j1] = tableno-1;\n        tables[tableno-1].minline = tables[tableno-1].maxline = j1;\n      }\n    }\n  }\n  for (t = 0; t < tableno; t++) {\n    tables[t].usecount = 0;\n    j1 = 8*tables[t].minline;\n    j2 = 8*(tables[t].maxline+1);\n    for (j = j1; j < j2; j++)\n      if (enc->uni2charset[j] != 0)\n        tables[t].usecount++;\n  }\n  {\n    p = -1;\n    for (t = 0; t < tableno; t++)\n      if (tables[t].usecount > 1) {\n        p = tables[t].minline >> 5;\n        printf(\"static const unsigned short %s_page%02x[%d] = {\\n\", name, p, 8*(tables[t].maxline-tables[t].minline+1));\n        for (j1 = tables[t].minline; j1 <= tables[t].maxline; j1++) {\n          if ((j1 % 0x20) == 0 && j1 > tables[t].minline)\n            printf(\"  /* 0x%04x */\\n\", 8*j1);\n          printf(\" \");\n          for (j2 = 0; j2 < 8; j2++) {\n            j = 8*j1+j2;\n            printf(\" 0x%04x,\", enc->uni2charset[j]);\n          }\n          printf(\" /*0x%02x-0x%02x*/\\n\", 8*(j1 % 0x20), 8*(j1 % 0x20)+7);\n        }\n        printf(\"};\\n\");\n      }\n    if (p >= 0)\n      printf(\"\\n\");\n  }\n  printf(\"static int\\n%s_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  if (n >= 2) {\\n\");\n  printf(\"    unsigned short c = 0;\\n\");\n  first = true;\n  for (j1 = 0; j1 < 0x6000;) {\n    t = line[j1];\n    for (j2 = j1; j2 < 0x6000 && line[j2] == t; j2++);\n    if (t >= 0) {\n      if (j1 != tables[t].minline) abort();\n      if (j2 > tables[t].maxline+1) abort();\n      j2 = tables[t].maxline+1;\n      if (first)\n        printf(\"    \");\n      else\n        printf(\"    else \");\n      first = false;\n      if (tables[t].usecount == 0) abort();\n      if (tables[t].usecount == 1) {\n        if (j2 != j1+1) abort();\n        for (j = 8*j1; j < 8*j2; j++)\n          if (enc->uni2charset[j] != 0) {\n            printf(\"if (wc == 0x%04x)\\n      c = 0x%02x;\\n\", j, enc->uni2charset[j]);\n            break;\n          }\n      } else {\n        if (j1 == 0) {\n          printf(\"if (wc < 0x%04x)\", 8*j2);\n        } else {\n          printf(\"if (wc >= 0x%04x && wc < 0x%04x)\", 8*j1, 8*j2);\n        }\n        printf(\"\\n      c = %s_page%02x[wc\", name, j1 >> 5);\n        if (tables[t].minline > 0)\n          printf(\"-0x%04x\", 8*j1);\n        printf(\"];\\n\");\n      }\n    }\n    j1 = j2;\n  }\n  printf(\"    if (c != 0) {\\n\");\n  printf(\"      r[0] = (c >> 8); r[1] = (c & 0xff);\\n\");\n  printf(\"      return 2;\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_ILUNI;\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_TOOSMALL;\\n\");\n  printf(\"}\\n\");\n}",
      "lines": 123,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_uni2charset_sparse": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "static void output_uni2charset_sparse (const char* name, Encoding* enc, bool monotonic)\n{\n  bool pages[0x300];\n  Block pageblocks[0x300]; int npageblocks;\n  int indx2charset[0x30000];\n  int summary_indx[0x3000];\n  int summary_used[0x3000];\n  int i, row, col, j, p, j1, j2, indx;\n  bool is_large;\n  /* for monotonic: */\n  int log2_stepsize = (!strcmp(name,\"uhc_2\") ? 6 : 7);\n  int stepsize = 1 << log2_stepsize;\n  int indxsteps;\n\n  /* Fill pages[0x300]. */\n  for (p = 0; p < 0x300; p++)\n    pages[p] = false;\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++) {\n      j = enc->charset2uni[row][col];\n      if (j != 0xfffd)\n        pages[j>>8] = true;\n    }\n\n  /* Determine whether two or three bytes are needed for each character. */\n  is_large = false;\n  for (j = 0; j < 0x30000; j++)\n    if (enc->uni2charset[j] >= 0x10000)\n      is_large = true;\n\n#if 0\n  for (p = 0; p < 0x300; p++)\n    if (pages[p]) {\n      printf(\"static const unsigned short %s_page%02x[256] = {\\n\", name, p);\n      for (j1 = 0; j1 < 32; j1++) {\n        printf(\"  \");\n        for (j2 = 0; j2 < 8; j2++)\n          printf(\"0x%04x, \", enc->uni2charset[256*p+8*j1+j2]);\n        printf(\"/\"\"*0x%02x-0x%02x*\"\"/\\n\", 8*j1, 8*j1+7);\n      }\n      printf(\"};\\n\");\n    }\n  printf(\"\\n\");\n#endif\n\n  /* Fill summary_indx[] and summary_used[]. */\n  indx = 0;\n  for (j1 = 0; j1 < 0x3000; j1++) {\n    summary_indx[j1] = indx;\n    summary_used[j1] = 0;\n    for (j2 = 0; j2 < 16; j2++) {\n      j = 16*j1+j2;\n      if (enc->uni2charset[j] != 0) {\n        indx2charset[indx++] = enc->uni2charset[j];\n        summary_used[j1] |= (1 << j2);\n      }\n    }\n  }\n\n  /* Fill npageblocks and pageblocks[]. */\n  npageblocks = 0;\n  for (p = 0; p < 0x300; ) {\n    if (pages[p] && (p == 0 || !pages[p-1])) {\n      pageblocks[npageblocks].start = 16*p;\n      do p++; while (p < 0x300 && pages[p]);\n      j1 = 16*p;\n      while (summary_used[j1-1] == 0) j1--;\n      pageblocks[npageblocks].end = j1;\n      npageblocks++;\n    } else\n      p++;\n  }\n\n  if (monotonic) {\n    indxsteps = (indx + stepsize-1) / stepsize;\n    printf(\"static const unsigned short %s_2charset_main[%d] = {\\n\", name, indxsteps);\n    for (i = 0; i < indxsteps; ) {\n      if ((i % 8) == 0) printf(\" \");\n      printf(\" 0x%04x,\", indx2charset[i*stepsize]);\n      i++;\n      if ((i % 8) == 0 || i == indxsteps) printf(\"\\n\");\n    }\n    printf(\"};\\n\");\n    printf(\"static const unsigned char %s_2charset[%d] = {\\n\", name, indx);\n    for (i = 0; i < indx; ) {\n      if ((i % 8) == 0) printf(\" \");\n      printf(\" 0x%02x,\", indx2charset[i] - indx2charset[i/stepsize*stepsize]);\n      i++;\n      if ((i % 8) == 0 || i == indx) printf(\"\\n\");\n    }\n    printf(\"};\\n\");\n  } else {\n    if (is_large) {\n      printf(\"static const unsigned char %s_2charset[3*%d] = {\\n\", name, indx);\n      for (i = 0; i < indx; ) {\n        if ((i % 4) == 0) printf(\" \");\n        printf(\" 0x%1x,0x%02x,0x%02x,\", indx2charset[i] >> 16,\n               (indx2charset[i] >> 8) & 0xff, indx2charset[i] & 0xff);\n        i++;\n        if ((i % 4) == 0 || i == indx) printf(\"\\n\");\n      }\n      printf(\"};\\n\");\n    } else {\n      printf(\"static const unsigned short %s_2charset[%d] = {\\n\", name, indx);\n      for (i = 0; i < indx; ) {\n        if ((i % 8) == 0) printf(\" \");\n        printf(\" 0x%04x,\", indx2charset[i]);\n        i++;\n        if ((i % 8) == 0 || i == indx) printf(\"\\n\");\n      }\n      printf(\"};\\n\");\n    }\n  }\n  printf(\"\\n\");\n  for (i = 0; i < npageblocks; i++) {\n    printf(\"static const Summary16 %s_uni2indx_page%02x[%d] = {\\n\", name,\n           pageblocks[i].start/16, pageblocks[i].end-pageblocks[i].start);\n    for (j1 = pageblocks[i].start; j1 < pageblocks[i].end; ) {\n      if (((16*j1) % 0x100) == 0) printf(\"  /\"\"* 0x%04x *\"\"/\\n\", 16*j1);\n      if ((j1 % 4) == 0) printf(\" \");\n      printf(\" { %4d, 0x%04x },\", summary_indx[j1], summary_used[j1]);\n      j1++;\n      if ((j1 % 4) == 0 || j1 == pageblocks[i].end) printf(\"\\n\");\n    }\n    printf(\"};\\n\");\n  }\n  printf(\"\\n\");\n\n  printf(\"static int\\n\");\n  printf(\"%s_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  if (n >= 2) {\\n\");\n  printf(\"    const Summary16 *summary = NULL;\\n\");\n  for (i = 0; i < npageblocks; i++) {\n    printf(\"    \");\n    if (i > 0)\n      printf(\"else \");\n    printf(\"if (wc >= 0x%04x && wc < 0x%04x)\\n\",\n           16*pageblocks[i].start, 16*pageblocks[i].end);\n    printf(\"      summary = &%s_uni2indx_page%02x[(wc>>4)\", name,\n           pageblocks[i].start/16);\n    if (pageblocks[i].start > 0)\n      printf(\"-0x%03x\", pageblocks[i].start);\n    printf(\"];\\n\");\n  }\n  printf(\"    if (summary) {\\n\");\n  printf(\"      unsigned short used = summary->used;\\n\");\n  printf(\"      unsigned int i = wc & 0x0f;\\n\");\n  printf(\"      if (used & ((unsigned short) 1 << i)) {\\n\");\n  if (monotonic || !is_large)\n    printf(\"        unsigned short c;\\n\");\n  printf(\"        /* Keep in 'used' only the bits 0..i-1. */\\n\");\n  printf(\"        used &= ((unsigned short) 1 << i) - 1;\\n\");\n  printf(\"        /* Add 'summary->indx' and the number of bits set in 'used'. */\\n\");\n  printf(\"        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\\n\");\n  printf(\"        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\\n\");\n  printf(\"        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\\n\");\n  printf(\"        used = (used & 0x00ff) + (used >> 8);\\n\");\n  if (monotonic) {\n    printf(\"        used += summary->indx;\\n\");\n    printf(\"        c = %s_2charset_main[used>>%d] + %s_2charset[used];\\n\", name, log2_stepsize, name);\n    printf(\"        r[0] = (c >> 8); r[1] = (c & 0xff);\\n\");\n    printf(\"        return 2;\\n\");\n  } else {\n    if (is_large) {\n      printf(\"        used += summary->indx;\\n\");\n      printf(\"        r[0] = %s_2charset[3*used];\\n\", name);\n      printf(\"        r[1] = %s_2charset[3*used+1];\\n\", name);\n      printf(\"        r[2] = %s_2charset[3*used+2];\\n\", name);\n      printf(\"        return 3;\\n\");\n    } else {\n      printf(\"        c = %s_2charset[summary->indx + used];\\n\", name);\n      printf(\"        r[0] = (c >> 8); r[1] = (c & 0xff);\\n\");\n      printf(\"        return 2;\\n\");\n    }\n  }\n  printf(\"      }\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_ILUNI;\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_TOOSMALL;\\n\");\n  printf(\"}\\n\");\n}",
      "lines": 183,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_normal": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        857,
        57
      ],
      "content": "static int row_byte_normal (int row) { return 0x21+row; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_normal": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        858,
        57
      ],
      "content": "static int col_byte_normal (int col) { return 0x21+col; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_normal": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        859,
        59
      ],
      "content": "static int byte_row_normal (int byte) { return byte-0x21; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_normal": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        860,
        59
      ],
      "content": "static int byte_col_normal (int byte) { return byte-0x21; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_normal": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        880,
        1
      ],
      "content": "static void do_normal (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 94;\n  enc.row_byte = row_byte_normal;\n  enc.col_byte = col_byte_normal;\n  enc.byte_row = byte_row_normal;\n  enc.byte_col = byte_col_normal;\n  enc.check_row_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.check_col_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.byte_row_expr = \"%1$s - 0x21\";\n  enc.byte_col_expr = \"%1$s - 0x21\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_normal_only_charset2uni": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "static void do_normal_only_charset2uni (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 94;\n  enc.row_byte = row_byte_normal;\n  enc.col_byte = col_byte_normal;\n  enc.byte_row = byte_row_normal;\n  enc.byte_col = byte_col_normal;\n  enc.check_row_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.check_col_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.byte_row_expr = \"%1$s - 0x21\";\n  enc.byte_col_expr = \"%1$s - 0x21\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_cns11643": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static int row_byte_cns11643 (int row) {\n  return 0x100 * (row / 94) + (row % 94) + 0x21;\n}",
      "lines": 3,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_cns11643": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static int byte_row_cns11643 (int byte) {\n  return (byte >> 8) * 94 + (byte & 0xff) - 0x21;\n}",
      "lines": 3,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_cns11643_only_uni2charset": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "static void do_cns11643_only_uni2charset (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 16*94;\n  enc.cols = 94;\n  enc.row_byte = row_byte_cns11643;\n  enc.col_byte = col_byte_normal;\n  enc.byte_row = byte_row_cns11643;\n  enc.byte_col = byte_col_normal;\n  enc.check_row_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.check_col_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.byte_row_expr = \"%1$s - 0x21\";\n  enc.byte_col_expr = \"%1$s - 0x21\";\n\n  read_table(&enc);\n  invert(&enc);\n  output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_gbk1": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static int row_byte_gbk1 (int row) {\n  return 0x81+row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_gbk1": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "static int col_byte_gbk1 (int col) {\n  return (col >= 0x3f ? 0x41 : 0x40) + col;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_gbk1": {
      "start_point": [
        943,
        0
      ],
      "end_point": [
        948,
        1
      ],
      "content": "static int byte_row_gbk1 (int byte) {\n  if (byte >= 0x81 && byte < 0xff)\n    return byte-0x81;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_gbk1": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "static int byte_col_gbk1 (int byte) {\n  if (byte >= 0x40 && byte < 0x7f)\n    return byte-0x40;\n  else if (byte >= 0x80 && byte < 0xff)\n    return byte-0x41;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_gbk1": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void do_gbk1 (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 126;\n  enc.cols = 190;\n  enc.row_byte = row_byte_gbk1;\n  enc.col_byte = col_byte_gbk1;\n  enc.byte_row = byte_row_gbk1;\n  enc.byte_col = byte_col_gbk1;\n  enc.check_row_expr = \"%1$s >= 0x81 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0x80 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x81\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x80 ? 0x41 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_dense(name,&enc);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_gbk1_only_charset2uni": {
      "start_point": [
        978,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "static void do_gbk1_only_charset2uni (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 126;\n  enc.cols = 190;\n  enc.row_byte = row_byte_gbk1;\n  enc.col_byte = col_byte_gbk1;\n  enc.byte_row = byte_row_gbk1;\n  enc.byte_col = byte_col_gbk1;\n  enc.check_row_expr = \"%1$s >= 0x81 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0x80 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x81\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x80 ? 0x41 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_gbk2": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static int row_byte_gbk2 (int row) {\n  return 0x81+row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_gbk2": {
      "start_point": [
        1000,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "static int col_byte_gbk2 (int col) {\n  return (col >= 0x3f ? 0x41 : 0x40) + col;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_gbk2": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "static int byte_row_gbk2 (int byte) {\n  if (byte >= 0x81 && byte < 0xff)\n    return byte-0x81;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_gbk2": {
      "start_point": [
        1009,
        0
      ],
      "end_point": [
        1016,
        1
      ],
      "content": "static int byte_col_gbk2 (int byte) {\n  if (byte >= 0x40 && byte < 0x7f)\n    return byte-0x40;\n  else if (byte >= 0x80 && byte < 0xa1)\n    return byte-0x41;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_gbk2_only_charset2uni": {
      "start_point": [
        1018,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "static void do_gbk2_only_charset2uni (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 126;\n  enc.cols = 96;\n  enc.row_byte = row_byte_gbk2;\n  enc.col_byte = col_byte_gbk2;\n  enc.byte_row = byte_row_gbk2;\n  enc.byte_col = byte_col_gbk2;\n  enc.check_row_expr = \"%1$s >= 0x81 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0x80 && %1$s < 0xa1)\";\n  enc.byte_row_expr = \"%1$s - 0x81\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x80 ? 0x41 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_gbk1_only_uni2charset": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "static void do_gbk1_only_uni2charset (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 126;\n  enc.cols = 190;\n  enc.row_byte = row_byte_gbk1;\n  enc.col_byte = col_byte_gbk1;\n  enc.byte_row = byte_row_gbk1;\n  enc.byte_col = byte_col_gbk1;\n  enc.check_row_expr = \"%1$s >= 0x81 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0x80 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x81\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x80 ? 0x41 : 0x40)\";\n\n  read_table(&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_table_ksc5601": {
      "start_point": [
        1061,
        0
      ],
      "end_point": [
        1129,
        1
      ],
      "content": "static void read_table_ksc5601 (Encoding* enc)\n{\n  int row, col, i, i1, i2, c, j;\n\n  enc->charset2uni = (int**) malloc(enc->rows*sizeof(int*));\n  for (row = 0; row < enc->rows; row++)\n    enc->charset2uni[row] = (int*) malloc(enc->cols*sizeof(int));\n\n  for (row = 0; row < enc->rows; row++)\n    for (col = 0; col < enc->cols; col++)\n      enc->charset2uni[row][col] = 0xfffd;\n\n  c = getc(stdin);\n  ungetc(c,stdin);\n  if (c == '#') {\n    /* Read a unicode.org style .TXT file. */\n    for (;;) {\n      c = getc(stdin);\n      if (c == EOF)\n        break;\n      if (c == '\\n' || c == ' ' || c == '\\t')\n        continue;\n      if (c == '#') {\n        do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n        continue;\n      }\n      ungetc(c,stdin);\n      if (scanf(\"0x%x\", &j) != 1)\n        exit(1);\n      i1 = j >> 8;\n      i2 = j & 0xff;\n      if (scanf(\" 0x%x\", &j) != 1)\n        exit(1);\n      /* Take only the range covered by KS C 5601.1987-0 = KS C 5601.1989-0\n         = KS X 1001.1992, ignore the rest. */\n      if (!(i1 >= 128+33 && i1 < 128+127 && i2 >= 128+33 && i2 < 128+127))\n        continue;  /* KSC5601 specific */\n      i1 &= 0x7f;  /* KSC5601 specific */\n      i2 &= 0x7f;  /* KSC5601 specific */\n      row = enc->byte_row(i1);\n      col = enc->byte_col(i2);\n      if (row < 0 || col < 0) {\n        fprintf(stderr, \"lost entry for %02x %02x\\n\", i1, i2);\n        exit(1);\n      }\n      enc->charset2uni[row][col] = j;\n    }\n  } else {\n    /* Read a table of hexadecimal Unicode values. */\n    for (i1 = 33; i1 < 127; i1++)\n      for (i2 = 33; i2 < 127; i2++) {\n        i = scanf(\"%x\", &j);\n        if (i == EOF)\n          goto read_done;\n        if (i != 1)\n          exit(1);\n        if (j < 0 || j == 0xffff)\n          j = 0xfffd;\n        if (j != 0xfffd) {\n          if (enc->byte_row(i1) < 0 || enc->byte_col(i2) < 0) {\n            fprintf(stderr, \"lost entry at %02x %02x\\n\", i1, i2);\n            exit (1);\n          }\n          enc->charset2uni[enc->byte_row(i1)][enc->byte_col(i2)] = j;\n        }\n      }\n   read_done: ;\n  }\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_ksc5601": {
      "start_point": [
        1131,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "static void do_ksc5601 (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 94;\n  enc.row_byte = row_byte_normal;\n  enc.col_byte = col_byte_normal;\n  enc.byte_row = byte_row_normal;\n  enc.byte_col = byte_col_normal;\n  enc.check_row_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.check_col_expr = \"%1$s >= 0x21 && %1$s < 0x7f\";\n  enc.byte_row_expr = \"%1$s - 0x21\";\n  enc.byte_col_expr = \"%1$s - 0x21\";\n\n  read_table_ksc5601(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_uhc_1": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "static int row_byte_uhc_1 (int row) {\n  return 0x81 + row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_uhc_1": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1160,
        1
      ],
      "content": "static int col_byte_uhc_1 (int col) {\n  return (col >= 0x34 ? 0x4d : col >= 0x1a ? 0x47 : 0x41) + col;\n}",
      "lines": 3,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_uhc_1": {
      "start_point": [
        1161,
        0
      ],
      "end_point": [
        1166,
        1
      ],
      "content": "static int byte_row_uhc_1 (int byte) {\n  if (byte >= 0x81 && byte < 0xa1)\n    return byte-0x81;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_uhc_1": {
      "start_point": [
        1167,
        0
      ],
      "end_point": [
        1176,
        1
      ],
      "content": "static int byte_col_uhc_1 (int byte) {\n  if (byte >= 0x41 && byte < 0x5b)\n    return byte-0x41;\n  else if (byte >= 0x61 && byte < 0x7b)\n    return byte-0x47;\n  else if (byte >= 0x81 && byte < 0xff)\n    return byte-0x4d;\n  else\n    return -1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_uhc_1": {
      "start_point": [
        1178,
        0
      ],
      "end_point": [
        1196,
        1
      ],
      "content": "static void do_uhc_1 (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 32;\n  enc.cols = 178;\n  enc.row_byte = row_byte_uhc_1;\n  enc.col_byte = col_byte_uhc_1;\n  enc.byte_row = byte_row_uhc_1;\n  enc.byte_col = byte_col_uhc_1;\n  enc.check_row_expr = \"(%1$s >= 0x81 && %1$s < 0xa1)\";\n  enc.check_col_expr = \"(%1$s >= 0x41 && %1$s < 0x5b) || (%1$s >= 0x61 && %1$s < 0x7b) || (%1$s >= 0x81 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x81\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x81 ? 0x4d : %1$s >= 0x61 ? 0x47 : 0x41)\";\n\n  read_table(&enc);\n  output_charset2uni_noholes_monotonic(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,true);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_uhc_2": {
      "start_point": [
        1200,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "static int row_byte_uhc_2 (int row) {\n  return 0xa1 + row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_uhc_2": {
      "start_point": [
        1203,
        0
      ],
      "end_point": [
        1205,
        1
      ],
      "content": "static int col_byte_uhc_2 (int col) {\n  return (col >= 0x34 ? 0x4d : col >= 0x1a ? 0x47 : 0x41) + col;\n}",
      "lines": 3,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_uhc_2": {
      "start_point": [
        1206,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "static int byte_row_uhc_2 (int byte) {\n  if (byte >= 0xa1 && byte < 0xff)\n    return byte-0xa1;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_uhc_2": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1221,
        1
      ],
      "content": "static int byte_col_uhc_2 (int byte) {\n  if (byte >= 0x41 && byte < 0x5b)\n    return byte-0x41;\n  else if (byte >= 0x61 && byte < 0x7b)\n    return byte-0x47;\n  else if (byte >= 0x81 && byte < 0xa1)\n    return byte-0x4d;\n  else\n    return -1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_uhc_2": {
      "start_point": [
        1223,
        0
      ],
      "end_point": [
        1241,
        1
      ],
      "content": "static void do_uhc_2 (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 84;\n  enc.row_byte = row_byte_uhc_2;\n  enc.col_byte = col_byte_uhc_2;\n  enc.byte_row = byte_row_uhc_2;\n  enc.byte_col = byte_col_uhc_2;\n  enc.check_row_expr = \"(%1$s >= 0xa1 && %1$s < 0xff)\";\n  enc.check_col_expr = \"(%1$s >= 0x41 && %1$s < 0x5b) || (%1$s >= 0x61 && %1$s < 0x7b) || (%1$s >= 0x81 && %1$s < 0xa1)\";\n  enc.byte_row_expr = \"%1$s - 0xa1\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x81 ? 0x4d : %1$s >= 0x61 ? 0x47 : 0x41)\";\n\n  read_table(&enc);\n  output_charset2uni_noholes_monotonic(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,true);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_big5": {
      "start_point": [
        1245,
        0
      ],
      "end_point": [
        1247,
        1
      ],
      "content": "static int row_byte_big5 (int row) {\n  return 0xa1+row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_big5": {
      "start_point": [
        1248,
        0
      ],
      "end_point": [
        1250,
        1
      ],
      "content": "static int col_byte_big5 (int col) {\n  return (col >= 0x3f ? 0x62 : 0x40) + col;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_big5": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1256,
        1
      ],
      "content": "static int byte_row_big5 (int byte) {\n  if (byte >= 0xa1 && byte < 0xff)\n    return byte-0xa1;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_big5": {
      "start_point": [
        1257,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "static int byte_col_big5 (int byte) {\n  if (byte >= 0x40 && byte < 0x7f)\n    return byte-0x40;\n  else if (byte >= 0xa1 && byte < 0xff)\n    return byte-0x62;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_big5": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1284,
        1
      ],
      "content": "static void do_big5 (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 157;\n  enc.row_byte = row_byte_big5;\n  enc.col_byte = col_byte_big5;\n  enc.byte_row = byte_row_big5;\n  enc.byte_col = byte_col_big5;\n  enc.check_row_expr = \"%1$s >= 0xa1 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0xa1 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0xa1\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0xa1 ? 0x62 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_hkscs": {
      "start_point": [
        1288,
        0
      ],
      "end_point": [
        1290,
        1
      ],
      "content": "static int row_byte_hkscs (int row) {\n  return 0x80+row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_hkscs": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "static int byte_row_hkscs (int byte) {\n  if (byte >= 0x80 && byte < 0xff)\n    return byte-0x80;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_hkscs": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1316,
        1
      ],
      "content": "static void do_hkscs (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 128;\n  enc.cols = 157;\n  enc.row_byte = row_byte_hkscs;\n  enc.col_byte = col_byte_big5;\n  enc.byte_row = byte_row_hkscs;\n  enc.byte_col = byte_col_big5;\n  enc.check_row_expr = \"%1$s >= 0x80 && %1$s < 0xff\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0xa1 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x80\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0xa1 ? 0x62 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_johab_hangul": {
      "start_point": [
        1320,
        0
      ],
      "end_point": [
        1322,
        1
      ],
      "content": "static int row_byte_johab_hangul (int row) {\n  return 0x84+row;\n}",
      "lines": 3,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_johab_hangul": {
      "start_point": [
        1323,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "static int col_byte_johab_hangul (int col) {\n  return (col >= 0x3e ? 0x43 : 0x41) + col;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_johab_hangul": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1331,
        1
      ],
      "content": "static int byte_row_johab_hangul (int byte) {\n  if (byte >= 0x84 && byte < 0xd4)\n    return byte-0x84;\n  else\n    return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_johab_hangul": {
      "start_point": [
        1332,
        0
      ],
      "end_point": [
        1339,
        1
      ],
      "content": "static int byte_col_johab_hangul (int byte) {\n  if (byte >= 0x41 && byte < 0x7f)\n    return byte-0x41;\n  else if (byte >= 0x81 && byte < 0xff)\n    return byte-0x43;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_johab_hangul": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1359,
        1
      ],
      "content": "static void do_johab_hangul (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 80;\n  enc.cols = 188;\n  enc.row_byte = row_byte_johab_hangul;\n  enc.col_byte = col_byte_johab_hangul;\n  enc.byte_row = byte_row_johab_hangul;\n  enc.byte_col = byte_col_johab_hangul;\n  enc.check_row_expr = \"%1$s >= 0x84 && %1$s < 0xd4\";\n  enc.check_col_expr = \"(%1$s >= 0x41 && %1$s < 0x7f) || (%1$s >= 0x81 && %1$s < 0xff)\";\n  enc.byte_row_expr = \"%1$s - 0x84\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x81 ? 0x43 : 0x41)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_dense(name,&enc);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_byte_sjis": {
      "start_point": [
        1363,
        0
      ],
      "end_point": [
        1365,
        1
      ],
      "content": "static int row_byte_sjis (int row) {\n  return (row >= 0x1f ? 0xc1 : 0x81) + row;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "col_byte_sjis": {
      "start_point": [
        1366,
        0
      ],
      "end_point": [
        1368,
        1
      ],
      "content": "static int col_byte_sjis (int col) {\n  return (col >= 0x3f ? 0x41 : 0x40) + col;\n}",
      "lines": 3,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_row_sjis": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1376,
        1
      ],
      "content": "static int byte_row_sjis (int byte) {\n  if (byte >= 0x81 && byte < 0xa0)\n    return byte-0x81;\n  else if (byte >= 0xe0)\n    return byte-0xc1;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "byte_col_sjis": {
      "start_point": [
        1377,
        0
      ],
      "end_point": [
        1384,
        1
      ],
      "content": "static int byte_col_sjis (int byte) {\n  if (byte >= 0x40 && byte < 0x7f)\n    return byte-0x40;\n  else if (byte >= 0x80 && byte < 0xfd)\n    return byte-0x41;\n  else\n    return -1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "do_sjis": {
      "start_point": [
        1386,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "static void do_sjis (const char* name)\n{\n  Encoding enc;\n\n  enc.rows = 94;\n  enc.cols = 188;\n  enc.row_byte = row_byte_sjis;\n  enc.col_byte = col_byte_sjis;\n  enc.byte_row = byte_row_sjis;\n  enc.byte_col = byte_col_sjis;\n  enc.check_row_expr = \"(%1$s >= 0x81 && %1$s < 0xa0) || (%1$s >= 0xe0)\";\n  enc.check_col_expr = \"(%1$s >= 0x40 && %1$s < 0x7f) || (%1$s >= 0x80 && %1$s < 0xfd)\";\n  enc.byte_row_expr = \"%1$s - (%1$s >= 0xe0 ? 0xc1 : 0x81)\";\n  enc.byte_col_expr = \"%1$s - (%1$s >= 0x80 ? 0x41 : 0x40)\";\n\n  read_table(&enc);\n  output_charset2uni(name,&enc);\n  invert(&enc); output_uni2charset_sparse(name,&enc,false);\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_gb18030uni": {
      "start_point": [
        1408,
        0
      ],
      "end_point": [
        1642,
        1
      ],
      "content": "static void do_gb18030uni (const char* name)\n{\n  int c;\n  unsigned int bytes;\n  int i1, i2, i3, i4, i, j, k;\n  int charset2uni[4*10*126*10];\n  int uni2charset[0x10000];\n  struct { int low; int high; int diff; int total; } ranges[256];\n  int ranges_count, ranges_total;\n\n  for (i = 0; i < 4*10*126*10; i++)\n    charset2uni[i] = 0;\n  for (j = 0; j < 0x10000; j++)\n    uni2charset[j] = 0;\n\n  /* Read a unicode.org style .TXT file. */\n  for (;;) {\n    c = getc(stdin);\n    if (c == EOF)\n      break;\n    if (c == '\\n' || c == ' ' || c == '\\t')\n      continue;\n    if (c == '#') {\n      do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n      continue;\n    }\n    ungetc(c,stdin);\n    if (scanf(\"0x%x\", &bytes) != 1)\n      exit(1);\n    i1 = (bytes >> 24) & 0xff;\n    i2 = (bytes >> 16) & 0xff;\n    i3 = (bytes >> 8) & 0xff;\n    i4 = bytes & 0xff;\n    if (!(i1 >= 0x81 && i1 <= 0x84\n          && i2 >= 0x30 && i2 <= 0x39\n          && i3 >= 0x81 && i3 <= 0xfe\n          && i4 >= 0x30 && i4 <= 0x39)) {\n      fprintf(stderr, \"lost entry for %02x %02x %02x %02x\\n\", i1, i2, i3, i4);\n      exit(1);\n    }\n    i = (((i1-0x81) * 10 + (i2-0x30)) * 126 + (i3-0x81)) * 10 + (i4-0x30);\n    if (scanf(\" 0x%x\", &j) != 1)\n      exit(1);\n    if (!(j >= 0 && j < 0x10000))\n      exit(1);\n    charset2uni[i] = j;\n    uni2charset[j] = i;\n  }\n\n  /* Verify that the mapping i -> j is monotonically increasing and\n     of the form\n        low[k] <= i <= high[k]  =>  j = diff[k] + i\n     with a set of disjoint intervals (low[k], high[k]). */\n  ranges_count = 0;\n  for (i = 0; i < 4*10*126*10; i++)\n    if (charset2uni[i] != 0) {\n      int diff;\n      j = charset2uni[i];\n      diff = j - i;\n      if (ranges_count > 0) {\n        if (!(i > ranges[ranges_count-1].high))\n          exit(1);\n        if (!(j > ranges[ranges_count-1].high + ranges[ranges_count-1].diff))\n          exit(1);\n        /* Additional property: The diffs are also increasing. */\n        if (!(diff >= ranges[ranges_count-1].diff))\n          exit(1);\n      }\n      if (ranges_count > 0 && diff == ranges[ranges_count-1].diff)\n        ranges[ranges_count-1].high = i;\n      else {\n        if (ranges_count == 256)\n          exit(1);\n        ranges[ranges_count].low = i;\n        ranges[ranges_count].high = i;\n        ranges[ranges_count].diff = diff;\n        ranges_count++;\n      }\n    }\n\n  /* Determine size of bitmap. */\n  ranges_total = 0;\n  for (k = 0; k < ranges_count; k++) {\n    ranges[k].total = ranges_total;\n    ranges_total += ranges[k].high - ranges[k].low + 1;\n  }\n\n  printf(\"static const unsigned short %s_charset2uni_ranges[%d] = {\\n\", name, 2*ranges_count);\n  for (k = 0; k < ranges_count; k++) {\n    printf(\"  0x%04x, 0x%04x\", ranges[k].low, ranges[k].high);\n    if (k+1 < ranges_count) printf(\",\");\n    if ((k % 4) == 3 && k+1 < ranges_count) printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  printf(\"};\\n\");\n\n  printf(\"\\n\");\n\n  printf(\"static const unsigned short %s_uni2charset_ranges[%d] = {\\n\", name, 2*ranges_count);\n  for (k = 0; k < ranges_count; k++) {\n    printf(\"  0x%04x, 0x%04x\", ranges[k].low + ranges[k].diff, ranges[k].high + ranges[k].diff);\n    if (k+1 < ranges_count) printf(\",\");\n    if ((k % 4) == 3 && k+1 < ranges_count) printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  printf(\"};\\n\");\n\n  printf(\"\\n\");\n\n  printf(\"static const struct { unsigned short diff; unsigned short bitmap_offset; } %s_ranges[%d] = {\\n \", name, ranges_count);\n  for (k = 0; k < ranges_count; k++) {\n    printf(\" { %5d, 0x%04x }\", ranges[k].diff, ranges[k].total);\n    if (k+1 < ranges_count) printf(\",\");\n    if ((k % 4) == 3 && k+1 < ranges_count) printf(\"\\n \");\n  }\n  printf(\"\\n\");\n  printf(\"};\\n\");\n\n  printf(\"\\n\");\n\n  printf(\"static const unsigned char %s_bitmap[%d] = {\\n \", name, (ranges_total + 7) / 8);\n  {\n    int accu = 0;\n    for (k = 0; k < ranges_count; k++) {\n      for (i = ranges[k].total; i <= ranges[k].total + (ranges[k].high - ranges[k].low);) {\n        if (charset2uni[i - ranges[k].total + ranges[k].low] != 0)\n          accu |= (1 << (i % 8));\n        i++;\n        if ((i % 8) == 0) {\n          printf(\" 0x%02x\", accu);\n          if ((i / 8) < (ranges_total + 7) / 8) printf(\",\");\n          if (((i / 8) % 12) == 0)\n            printf(\"\\n \");\n          accu = 0;\n        }\n      }\n      if (i != (k+1 < ranges_count ? ranges[k+1].total : ranges_total)) abort();\n    }\n    if ((ranges_total % 8) != 0)\n      printf(\" 0x%02x\", accu);\n    printf(\"\\n\");\n  }\n  printf(\"};\\n\");\n\n  printf(\"\\n\");\n\n  printf(\"static int\\n\");\n  printf(\"%s_mbtowc (conv_t conv, ucs4_t *pwc, const unsigned char *s, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  unsigned char c1 = s[0];\\n\");\n  printf(\"  if (c1 >= 0x81 && c1 <= 0x84) {\\n\");\n  printf(\"    if (n >= 2) {\\n\");\n  printf(\"      unsigned char c2 = s[1];\\n\");\n  printf(\"      if (c2 >= 0x30 && c2 <= 0x39) {\\n\");\n  printf(\"        if (n >= 3) {\\n\");\n  printf(\"          unsigned char c3 = s[2];\\n\");\n  printf(\"          if (c3 >= 0x81 && c3 <= 0xfe) {\\n\");\n  printf(\"            if (n >= 4) {\\n\");\n  printf(\"              unsigned char c4 = s[3];\\n\");\n  printf(\"              if (c4 >= 0x30 && c4 <= 0x39) {\\n\");\n  printf(\"                unsigned int i = (((c1 - 0x81) * 10 + (c2 - 0x30)) * 126 + (c3 - 0x81)) * 10 + (c4 - 0x30);\\n\");\n  printf(\"                if (i >= %d && i <= %d) {\\n\", ranges[0].low, ranges[ranges_count-1].high);\n  printf(\"                  unsigned int k1 = 0;\\n\");\n  printf(\"                  unsigned int k2 = %d;\\n\", ranges_count-1);\n  printf(\"                  while (k1 < k2) {\\n\");\n  printf(\"                    unsigned int k = (k1 + k2) / 2;\\n\");\n  printf(\"                    if (i <= %s_charset2uni_ranges[2*k+1])\\n\", name);\n  printf(\"                      k2 = k;\\n\");\n  printf(\"                    else if (i >= %s_charset2uni_ranges[2*k+2])\\n\", name);\n  printf(\"                      k1 = k + 1;\\n\");\n  printf(\"                    else\\n\");\n  printf(\"                      return RET_ILSEQ;\\n\");\n  printf(\"                  }\\n\");\n  printf(\"                  {\\n\");\n  printf(\"                    unsigned int bitmap_index = i - %s_charset2uni_ranges[2*k1] + %s_ranges[k1].bitmap_offset;\\n\", name, name);\n  printf(\"                    if ((%s_bitmap[bitmap_index >> 3] >> (bitmap_index & 7)) & 1) {\\n\", name);\n  printf(\"                      unsigned int diff = %s_ranges[k1].diff;\\n\", name);\n  printf(\"                      *pwc = (ucs4_t) (i + diff);\\n\");\n  printf(\"                      return 4;\\n\");\n  printf(\"                    }\\n\");\n  printf(\"                  }\\n\");\n  printf(\"                }\\n\");\n  printf(\"              }\\n\");\n  printf(\"              return RET_ILSEQ;\\n\");\n  printf(\"            }\\n\");\n  printf(\"            return RET_TOOFEW(0);\\n\");\n  printf(\"          }\\n\");\n  printf(\"          return RET_ILSEQ;\\n\");\n  printf(\"        }\\n\");\n  printf(\"        return RET_TOOFEW(0);\\n\");\n  printf(\"      }\\n\");\n  printf(\"      return RET_ILSEQ;\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_TOOFEW(0);\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_ILSEQ;\\n\");\n  printf(\"}\\n\");\n\n  printf(\"\\n\");\n\n  printf(\"static int\\n\");\n  printf(\"%s_wctomb (conv_t conv, unsigned char *r, ucs4_t wc, size_t n)\\n\", name);\n  printf(\"{\\n\");\n  printf(\"  if (n >= 4) {\\n\");\n  printf(\"    unsigned int i = wc;\\n\");\n  printf(\"    if (i >= 0x%04x && i <= 0x%04x) {\\n\", ranges[0].low + ranges[0].diff, ranges[ranges_count-1].high + ranges[ranges_count-1].diff);\n  printf(\"      unsigned int k1 = 0;\\n\");\n  printf(\"      unsigned int k2 = %d;\\n\", ranges_count-1);\n  printf(\"      while (k1 < k2) {\\n\");\n  printf(\"        unsigned int k = (k1 + k2) / 2;\\n\");\n  printf(\"        if (i <= %s_uni2charset_ranges[2*k+1])\\n\", name);\n  printf(\"          k2 = k;\\n\");\n  printf(\"        else if (i >= %s_uni2charset_ranges[2*k+2])\\n\", name);\n  printf(\"          k1 = k + 1;\\n\");\n  printf(\"        else\\n\");\n  printf(\"          return RET_ILUNI;\\n\");\n  printf(\"      }\\n\");\n  printf(\"      {\\n\");\n  printf(\"        unsigned int bitmap_index = i - %s_uni2charset_ranges[2*k1] + %s_ranges[k1].bitmap_offset;\\n\", name, name);\n  printf(\"        if ((%s_bitmap[bitmap_index >> 3] >> (bitmap_index & 7)) & 1) {\\n\", name);\n  printf(\"          unsigned int diff = %s_ranges[k1].diff;\\n\", name);\n  printf(\"          i -= diff;\\n\");\n  printf(\"          r[3] = (i %% 10) + 0x30; i = i / 10;\\n\");\n  printf(\"          r[2] = (i %% 126) + 0x81; i = i / 126;\\n\");\n  printf(\"          r[1] = (i %% 10) + 0x30; i = i / 10;\\n\");\n  printf(\"          r[0] = i + 0x81;\\n\");\n  printf(\"          return 4;\\n\");\n  printf(\"        }\\n\");\n  printf(\"      }\\n\");\n  printf(\"    }\\n\");\n  printf(\"    return RET_ILUNI;\\n\");\n  printf(\"  }\\n\");\n  printf(\"  return RET_TOOSMALL;\\n\");\n  printf(\"}\\n\");\n}",
      "lines": 235,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_jisx0213": {
      "start_point": [
        1646,
        0
      ],
      "end_point": [
        2086,
        1
      ],
      "content": "static void do_jisx0213 (const char* name)\n{\n  printf(\"#ifndef _JISX0213_H\\n\");\n  printf(\"#define _JISX0213_H\\n\");\n  printf(\"\\n\");\n  printf(\"/* JISX0213 plane 1 (= ISO-IR-233) characters are in the range\\n\");\n  printf(\"   0x{21..7E}{21..7E}.\\n\");\n  printf(\"   JISX0213 plane 2 (= ISO-IR-229) characters are in the range\\n\");\n  printf(\"   0x{21,23..25,28,2C..2F,6E..7E}{21..7E}.\\n\");\n  printf(\"   Together this makes 120 rows of 94 characters.\\n\");\n  printf(\"*/\\n\");\n  printf(\"\\n\");\n  {\n#define row_convert(row) \\\n      ((row) >= 0x121 && (row) <= 0x17E ? row-289 : /* 0..93 */    \\\n       (row) == 0x221                   ? row-451 : /* 94 */       \\\n       (row) >= 0x223 && (row) <= 0x225 ? row-452 : /* 95..97 */   \\\n       (row) == 0x228                   ? row-454 : /* 98 */       \\\n       (row) >= 0x22C && (row) <= 0x22F ? row-457 : /* 99..102 */  \\\n       (row) >= 0x26E && (row) <= 0x27E ? row-519 : /* 103..119 */ \\\n       -1)\n    unsigned int table[120][94];\n    int pagemin[0x1100];\n    int pagemax[0x1100];\n    int pageidx[0x1100];\n    unsigned int pagestart[0x1100];\n    unsigned int pagestart_len = 0;\n    {\n      unsigned int rowc, colc;\n      for (rowc = 0; rowc < 120; rowc++)\n        for (colc = 0; colc < 94; colc++)\n          table[rowc][colc] = 0;\n    }\n    {\n      unsigned int page;\n      for (page = 0; page < 0x1100; page++)\n        pagemin[page] = -1;\n      for (page = 0; page < 0x1100; page++)\n        pagemax[page] = -1;\n      for (page = 0; page < 0x1100; page++)\n        pageidx[page] = -1;\n    }\n    printf(\"static const unsigned short jisx0213_to_ucs_combining[][2] = {\\n\");\n    {\n      int private_use = 0x0001;\n      for (;;) {\n        char line[30];\n        unsigned int row, col;\n        unsigned int ucs;\n        memset(line,0,sizeof(line));\n        if (scanf(\"%[^\\n]\\n\",line) < 1)\n          break;\n        assert(line[0]=='0');\n        assert(line[1]=='x');\n        assert(isxdigit(line[2]));\n        assert(isxdigit(line[3]));\n        assert(isxdigit(line[4]));\n        assert(isxdigit(line[5]));\n        assert(isxdigit(line[6]));\n        assert(line[7]=='\\t');\n        line[7] = '\\0';\n        col = strtoul(&line[5],NULL,16);\n        line[5] = '\\0';\n        row = strtoul(&line[2],NULL,16);\n        if (line[20] != '\\0' && line[21] == '\\0') {\n          unsigned int u1, u2;\n          assert(line[8]=='0');\n          assert(line[9]=='x');\n          assert(isxdigit(line[10]));\n          assert(isxdigit(line[11]));\n          assert(isxdigit(line[12]));\n          assert(isxdigit(line[13]));\n          assert(line[14]==' ');\n          assert(line[15]=='0');\n          assert(line[16]=='x');\n          assert(isxdigit(line[17]));\n          assert(isxdigit(line[18]));\n          assert(isxdigit(line[19]));\n          assert(isxdigit(line[20]));\n          u2 = strtoul(&line[17],NULL,16);\n          line[14] = '\\0';\n          u1 = strtoul(&line[10],NULL,16);\n          printf(\"  { 0x%04x, 0x%04x },\\n\", u1, u2);\n          ucs = private_use++;\n        } else {\n          assert(line[8]=='0');\n          assert(line[9]=='x');\n          assert(isxdigit(line[10]));\n          assert(isxdigit(line[11]));\n          assert(isxdigit(line[12]));\n          assert(isxdigit(line[13]));\n          ucs = strtoul(&line[10],NULL,16);\n        }\n        assert((unsigned int) row_convert(row) < 120);\n        assert((unsigned int) (col-0x21) < 94);\n        table[row_convert(row)][col-0x21] = ucs;\n      }\n    }\n    printf(\"};\\n\");\n    printf(\"\\n\");\n    {\n      unsigned int rowc, colc;\n      for (rowc = 0; rowc < 120; rowc++) {\n        for (colc = 0; colc < 94; colc++) {\n          unsigned int value = table[rowc][colc];\n          unsigned int page = value >> 8;\n          unsigned int rest = value & 0xff;\n          if (pagemin[page] < 0 || pagemin[page] > rest) pagemin[page] = rest;\n          if (pagemax[page] < 0 || pagemax[page] < rest) pagemax[page] = rest;\n        }\n      }\n    }\n    {\n      unsigned int index = 0;\n      unsigned int i;\n      for (i = 0; i < 0x1100; ) {\n        if (pagemin[i] >= 0) {\n          if (pagemin[i+1] >= 0 && pagemin[i] >= 0x80 && pagemax[i+1] < 0x80) {\n            /* Combine two pages into a single one. */\n            assert(pagestart_len < sizeof(pagestart)/sizeof(pagestart[0]));\n            pagestart[pagestart_len++] = (i<<8)+0x80;\n            pageidx[i] = index;\n            pageidx[i+1] = index;\n            index++;\n            i += 2;\n          } else {\n            /* A single page. */\n            assert(pagestart_len < sizeof(pagestart)/sizeof(pagestart[0]));\n            pagestart[pagestart_len++] = i<<8;\n            pageidx[i] = index;\n            index++;\n            i += 1;\n          }\n        } else\n          i++;\n      }\n    }\n    printf(\"static const unsigned short jisx0213_to_ucs_main[120 * 94] = {\\n\");\n    {\n      unsigned int row;\n      for (row = 0; row < 0x300; row++) {\n        unsigned int rowc = row_convert(row);\n        if (rowc != (unsigned int) (-1)) {\n          printf(\"  /* 0x%X21..0x%X7E */\\n\",row,row);\n          {\n            unsigned int count = 0;\n            unsigned int colc;\n            for (colc = 0; colc < 94; colc++) {\n              if ((count % 8) == 0) printf(\" \");\n              {\n                unsigned int value = table[rowc][colc];\n                unsigned int page = value >> 8;\n                unsigned int index = pageidx[page];\n                assert(value-pagestart[index] < 0x100);\n                printf(\" 0x%04x,\",(index<<8)|(value-pagestart[index]));\n              }\n              count++;\n              if ((count % 8) == 0) printf(\"\\n\");\n            }\n          }\n          printf(\"\\n\");\n        }\n      }\n    }\n    printf(\"};\\n\");\n    printf(\"\\n\");\n    printf(\"static const ucs4_t jisx0213_to_ucs_pagestart[] = {\\n\");\n    {\n      unsigned int count = 0;\n      unsigned int i;\n      for (i = 0; i < pagestart_len; i++) {\n        char buf[10];\n        if ((count % 8) == 0) printf(\" \");\n        printf(\" \");\n        sprintf(buf,\"0x%04x\",pagestart[i]);\n        if (strlen(buf) < 7) printf(\"%*s\",(int)(7-strlen(buf)),\"\");\n        printf(\"%s,\",buf);\n        count++;\n        if ((count % 8) == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"\\n\");\n    printf(\"};\\n\");\n#undef row_convert\n  }\n  rewind(stdin);\n  printf(\"\\n\");\n  {\n    int table[0x110000];\n    bool pages[0x4400];\n    int maxpage = -1;\n    unsigned int combining_prefixes[100];\n    unsigned int combining_prefixes_len = 0;\n    {\n      unsigned int i;\n      for (i = 0; i < 0x110000; i++)\n        table[i] = -1;\n      for (i = 0; i < 0x4400; i++)\n        pages[i] = false;\n    }\n    for (;;) {\n      char line[30];\n      unsigned int plane, row, col;\n      memset(line,0,sizeof(line));\n      if (scanf(\"%[^\\n]\\n\",line) < 1)\n        break;\n      assert(line[0]=='0');\n      assert(line[1]=='x');\n      assert(isxdigit(line[2]));\n      assert(isxdigit(line[3]));\n      assert(isxdigit(line[4]));\n      assert(isxdigit(line[5]));\n      assert(isxdigit(line[6]));\n      assert(line[7]=='\\t');\n      line[7] = '\\0';\n      col = strtoul(&line[5],NULL,16);\n      line[5] = '\\0';\n      row = strtoul(&line[3],NULL,16);\n      line[3] = '\\0';\n      plane = strtoul(&line[2],NULL,16) - 1;\n      if (line[20] != '\\0' && line[21] == '\\0') {\n        unsigned int u1, u2;\n        assert(line[8]=='0');\n        assert(line[9]=='x');\n        assert(isxdigit(line[10]));\n        assert(isxdigit(line[11]));\n        assert(isxdigit(line[12]));\n        assert(isxdigit(line[13]));\n        assert(line[14]==' ');\n        assert(line[15]=='0');\n        assert(line[16]=='x');\n        assert(isxdigit(line[17]));\n        assert(isxdigit(line[18]));\n        assert(isxdigit(line[19]));\n        assert(isxdigit(line[20]));\n        u2 = strtoul(&line[17],NULL,16);\n        line[14] = '\\0';\n        u1 = strtoul(&line[10],NULL,16);\n        assert(u2 == 0x02E5 || u2 == 0x02E9 || u2 == 0x0300 || u2 == 0x0301\n               || u2 == 0x309A);\n        assert(combining_prefixes_len < sizeof(combining_prefixes)/sizeof(combining_prefixes[0]));\n        combining_prefixes[combining_prefixes_len++] = u1;\n      } else {\n        unsigned int ucs;\n        assert(line[8]=='0');\n        assert(line[9]=='x');\n        assert(isxdigit(line[10]));\n        assert(isxdigit(line[11]));\n        assert(isxdigit(line[12]));\n        assert(isxdigit(line[13]));\n        ucs = strtoul(&line[10],NULL,16);\n        /* Add an entry. */\n        assert(plane <= 1);\n        assert(row <= 0x7f);\n        assert(col <= 0x7f);\n        table[ucs] = (plane << 15) | (row << 8) | col;\n        pages[ucs>>6] = true;\n        if (maxpage < 0 || (ucs>>6) > maxpage) maxpage = ucs>>6;\n      }\n    }\n    {\n      unsigned int i;\n      for (i = 0; i < combining_prefixes_len; i++) {\n        unsigned int u1 = combining_prefixes[i];\n        assert(table[u1] >= 0);\n        table[u1] |= 0x0080;\n      }\n    }\n    printf(\"static const short jisx0213_from_ucs_level1[%d] = {\\n\",maxpage+1);\n    {\n      unsigned int index = 0;\n      unsigned int i;\n      for (i = 0; i <= maxpage; i++) {\n        if ((i % 8) == 0) printf(\" \");\n        if (pages[i]) {\n          printf(\" %3u,\",index);\n          index++;\n        } else {\n          printf(\" %3d,\",-1);\n        }\n        if (((i+1) % 8) == 0) printf(\"\\n\");\n      }\n    }\n    printf(\"\\n\");\n    printf(\"};\\n\");\n    printf(\"\\n\");\n    #if 0 /* Dense array */\n    printf(\"static const unsigned short jisx0213_from_ucs_level2[] = {\\n\");\n    {\n      unsigned int i;\n      for (i = 0; i <= maxpage; i++) {\n        if (pages[i]) {\n          printf(\"  /* 0x%04X */\\n\",i<<6);\n          {\n            unsigned int j;\n            for (j = 0; j < 0x40; ) {\n              unsigned int ucs = (i<<6)+j;\n              int value = table[ucs];\n              if (value < 0) value = 0;\n              if ((j % 8) == 0) printf(\" \");\n              printf(\" 0x%04x,\",value);\n              j++;\n              if ((j % 8) == 0) printf(\"\\n\");\n            }\n          }\n        }\n      }\n    }\n    printf(\"};\\n\");\n    #else /* Sparse array */\n    {\n      int summary_indx[0x11000];\n      int summary_used[0x11000];\n      unsigned int i, k, indx;\n      printf(\"static const unsigned short jisx0213_from_ucs_level2_data[] = {\\n\");\n      /* Fill summary_indx[] and summary_used[]. */\n      indx = 0;\n      for (i = 0, k = 0; i <= maxpage; i++) {\n        if (pages[i]) {\n          unsigned int j1, j2;\n          unsigned int count = 0;\n          printf(\"  /* 0x%04X */\\n\",i<<6);\n          for (j1 = 0; j1 < 4; j1++) {\n            summary_indx[4*k+j1] = indx;\n            summary_used[4*k+j1] = 0;\n            for (j2 = 0; j2 < 16; j2++) {\n              unsigned int j = 16*j1+j2;\n              unsigned int ucs = (i<<6)+j;\n              int value = table[ucs];\n              if (value < 0) value = 0;\n              if (value > 0) {\n                summary_used[4*k+j1] |= (1 << j2);\n                if ((count % 8) == 0) printf(\" \");\n                printf(\" 0x%04x,\",value);\n                count++;\n                if ((count % 8) == 0) printf(\"\\n\");\n                indx++;\n              }\n            }\n          }\n          if ((count % 8) > 0)\n            printf(\"\\n\");\n          k++;\n        }\n      }\n      printf(\"};\\n\");\n      printf(\"\\n\");\n      printf(\"static const Summary16 jisx0213_from_ucs_level2_2indx[] = {\\n\");\n      for (i = 0, k = 0; i <= maxpage; i++) {\n        if (pages[i]) {\n          unsigned int j1;\n          printf(\"  /* 0x%04X */\\n\",i<<6);\n          printf(\" \");\n          for (j1 = 0; j1 < 4; j1++) {\n            printf(\" { %4d, 0x%04x },\", summary_indx[4*k+j1], summary_used[4*k+j1]);\n          }\n          printf(\"\\n\");\n          k++;\n        }\n      }\n      printf(\"};\\n\");\n    }\n    #endif\n    printf(\"\\n\");\n  }\n  printf(\"#ifdef __GNUC__\\n\");\n  printf(\"__inline\\n\");\n  printf(\"#else\\n\");\n  printf(\"#ifdef __cplusplus\\n\");\n  printf(\"inline\\n\");\n  printf(\"#endif\\n\");\n  printf(\"#endif\\n\");\n  printf(\"static ucs4_t jisx0213_to_ucs4 (unsigned int row, unsigned int col)\\n\");\n  printf(\"{\\n\");\n  printf(\"  ucs4_t val;\\n\");\n  printf(\"\\n\");\n  printf(\"  if (row >= 0x121 && row <= 0x17e)\\n\");\n  printf(\"    row -= 289;\\n\");\n  printf(\"  else if (row == 0x221)\\n\");\n  printf(\"    row -= 451;\\n\");\n  printf(\"  else if (row >= 0x223 && row <= 0x225)\\n\");\n  printf(\"    row -= 452;\\n\");\n  printf(\"  else if (row == 0x228)\\n\");\n  printf(\"    row -= 454;\\n\");\n  printf(\"  else if (row >= 0x22c && row <= 0x22f)\\n\");\n  printf(\"    row -= 457;\\n\");\n  printf(\"  else if (row >= 0x26e && row <= 0x27e)\\n\");\n  printf(\"    row -= 519;\\n\");\n  printf(\"  else\\n\");\n  printf(\"    return 0x0000;\\n\");\n  printf(\"\\n\");\n  printf(\"  if (col >= 0x21 && col <= 0x7e)\\n\");\n  printf(\"    col -= 0x21;\\n\");\n  printf(\"  else\\n\");\n  printf(\"    return 0x0000;\\n\");\n  printf(\"\\n\");\n  printf(\"  val = jisx0213_to_ucs_main[row * 94 + col];\\n\");\n  printf(\"  val = jisx0213_to_ucs_pagestart[val >> 8] + (val & 0xff);\\n\");\n  printf(\"  if (val == 0xfffd)\\n\");\n  printf(\"    val = 0x0000;\\n\");\n  printf(\"  return val;\\n\");\n  printf(\"}\\n\");\n  printf(\"\\n\");\n  printf(\"#ifdef __GNUC__\\n\");\n  printf(\"__inline\\n\");\n  printf(\"#else\\n\");\n  printf(\"#ifdef __cplusplus\\n\");\n  printf(\"inline\\n\");\n  printf(\"#endif\\n\");\n  printf(\"#endif\\n\");\n  printf(\"static unsigned short ucs4_to_jisx0213 (ucs4_t ucs)\\n\");\n  printf(\"{\\n\");\n  printf(\"  if (ucs < (sizeof(jisx0213_from_ucs_level1)/sizeof(jisx0213_from_ucs_level1[0])) << 6) {\\n\");\n  printf(\"    int index1 = jisx0213_from_ucs_level1[ucs >> 6];\\n\");\n  printf(\"    if (index1 >= 0)\");\n  #if 0 /* Dense array */\n  printf(\"\\n\");\n  printf(\"      return jisx0213_from_ucs_level2[(index1 << 6) + (ucs & 0x3f)];\\n\");\n  #else /* Sparse array */\n  printf(\" {\\n\");\n  printf(\"      const Summary16 *summary = &jisx0213_from_ucs_level2_2indx[((index1 << 6) + (ucs & 0x3f)) >> 4];\\n\");\n  printf(\"      unsigned short used = summary->used;\\n\");\n  printf(\"      unsigned int i = ucs & 0x0f;\\n\");\n  printf(\"      if (used & ((unsigned short) 1 << i)) {\\n\");\n  printf(\"        /* Keep in 'used' only the bits 0..i-1. */\\n\");\n  printf(\"        used &= ((unsigned short) 1 << i) - 1;\\n\");\n  printf(\"        /* Add 'summary->indx' and the number of bits set in 'used'. */\\n\");\n  printf(\"        used = (used & 0x5555) + ((used & 0xaaaa) >> 1);\\n\");\n  printf(\"        used = (used & 0x3333) + ((used & 0xcccc) >> 2);\\n\");\n  printf(\"        used = (used & 0x0f0f) + ((used & 0xf0f0) >> 4);\\n\");\n  printf(\"        used = (used & 0x00ff) + (used >> 8);\\n\");\n  printf(\"        return jisx0213_from_ucs_level2_data[summary->indx + used];\\n\");\n  printf(\"      };\\n\");\n  printf(\"    };\\n\");\n  #endif\n  printf(\"  }\\n\");\n  printf(\"  return 0x0000;\\n\");\n  printf(\"}\\n\");\n  printf(\"\\n\");\n  printf(\"#endif /* _JISX0213_H */\\n\");\n}",
      "lines": 441,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        2090,
        0
      ],
      "end_point": [
        2145,
        1
      ],
      "content": "int main (int argc, char *argv[])\n{\n  const char* charsetname;\n  const char* name;\n\n  if (argc != 3)\n    exit(1);\n  charsetname = argv[1];\n  name = argv[2];\n\n  output_title(charsetname);\n\n  if (!strcmp(name,\"gb2312\")\n      || !strcmp(name,\"isoir165ext\") || !strcmp(name,\"gb12345ext\")\n      || !strcmp(name,\"jisx0208\") || !strcmp(name,\"jisx0212\"))\n    do_normal(name);\n  else if (!strcmp(name,\"cns11643_1\") || !strcmp(name,\"cns11643_2\")\n           || !strcmp(name,\"cns11643_3\") || !strcmp(name,\"cns11643_4a\")\n           || !strcmp(name,\"cns11643_4b\") || !strcmp(name,\"cns11643_5\")\n           || !strcmp(name,\"cns11643_6\") || !strcmp(name,\"cns11643_7\")\n           || !strcmp(name,\"cns11643_15\"))\n    do_normal_only_charset2uni(name);\n  else if (!strcmp(name,\"cns11643_inv\"))\n    do_cns11643_only_uni2charset(name);\n  else if (!strcmp(name,\"gbkext1\"))\n    do_gbk1_only_charset2uni(name);\n  else if (!strcmp(name,\"gbkext2\"))\n    do_gbk2_only_charset2uni(name);\n  else if (!strcmp(name,\"gbkext_inv\"))\n    do_gbk1_only_uni2charset(name);\n  else if (!strcmp(name,\"cp936ext\") || !strcmp(name,\"gb18030ext\"))\n    do_gbk1(name);\n  else if (!strcmp(name,\"ksc5601\"))\n    do_ksc5601(name);\n  else if (!strcmp(name,\"uhc_1\"))\n    do_uhc_1(name);\n  else if (!strcmp(name,\"uhc_2\"))\n    do_uhc_2(name);\n  else if (!strcmp(name,\"big5\") || !strcmp(name,\"cp950ext\"))\n    do_big5(name);\n  else if (!strcmp(name,\"hkscs1999\") || !strcmp(name,\"hkscs2001\")\n           || !strcmp(name,\"hkscs2004\") || !strcmp(name,\"hkscs2008\"))\n    do_hkscs(name);\n  else if (!strcmp(name,\"johab_hangul\"))\n    do_johab_hangul(name);\n  else if (!strcmp(name,\"cp932ext\"))\n    do_sjis(name);\n  else if (!strcmp(name,\"gb18030uni\"))\n    do_gb18030uni(name);\n  else if (!strcmp(name,\"jisx0213\"))\n    do_jisx0213(name);\n  else\n    exit(1);\n\n  return 0;\n}",
      "lines": 56,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/tools/cjk_variants.c": {
    "main": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int main (int argc, char *argv[])\n{\n  int variants[MAX_PER_ENTRY*ENTRIES];\n  int uni2index[0x10000];\n  int index;\n\n  if (argc != 1)\n    exit(1);\n\n  printf(\"/*\\n\");\n  printf(\" * Copyright (C) 1999-2002 Free Software Foundation, Inc.\\n\");\n  printf(\" * This file is part of the GNU LIBICONV Library.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is free software; you can redistribute it\\n\");\n  printf(\" * and/or modify it under the terms of the GNU Library General Public\\n\");\n  printf(\" * License as published by the Free Software Foundation; either version 2\\n\");\n  printf(\" * of the License, or (at your option) any later version.\\n\");\n  printf(\" *\\n\");\n  printf(\" * The GNU LIBICONV Library is distributed in the hope that it will be\\n\");\n  printf(\" * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n  printf(\" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\");\n  printf(\" * Library General Public License for more details.\\n\");\n  printf(\" *\\n\");\n  printf(\" * You should have received a copy of the GNU Library General Public\\n\");\n  printf(\" * License along with the GNU LIBICONV Library; see the file COPYING.LIB.\\n\");\n  printf(\" * If not, see <http://www.gnu.org/licenses/>.\\n\");\n  printf(\" */\\n\");\n  printf(\"\\n\");\n  printf(\"/*\\n\");\n  printf(\" * CJK variants table\\n\");\n  printf(\" */\\n\");\n  printf(\"\\n\");\n  {\n    int c;\n    int j;\n    for (j = 0; j < 0x10000; j++)\n      uni2index[j] = -1;\n    index = 0;\n    for (;;) {\n      c = getc(stdin);\n      if (c == EOF)\n        break;\n      if (c == '#') {\n        do { c = getc(stdin); } while (!(c == EOF || c == '\\n'));\n        continue;\n      }\n      ungetc(c,stdin);\n      if (scanf(\"%x\",&j) != 1)\n        exit(1);\n      c = getc(stdin);\n      if (c != '\\t')\n        exit(1);\n      uni2index[j] = index;\n      for (;;) {\n        int i;\n        if (scanf(\"%x\",&i) != 1)\n          exit(1);\n        if (!(i >= 0x3000 && i < 0x3000+0x8000))\n          exit(1);\n        variants[index++] = i-0x3000;\n        c = getc(stdin);\n        if (c != ' ')\n          break;\n      }\n      variants[index-1] |= 0x8000; /* end of list marker */\n      if (c != '\\n')\n        exit(1);\n    }\n  }\n  printf(\"static const unsigned short cjk_variants[%d] = {\",index);\n  {\n    int i;\n    for (i = 0; i < index; i++) {\n      if ((i % 8) == 0)\n        printf(\"\\n \");\n      printf(\" 0x%04x,\",variants[i]);\n    }\n    printf(\"\\n};\\n\");\n  }\n  printf(\"\\n\");\n  printf(\"static const short cjk_variants_indx[0x5200] = {\\n\");\n  {\n    int j;\n    for (j = 0x4e00; j < 0xa000; j++) {\n      if ((j % 0x100) == 0)\n        printf(\"  /* 0x%04x */\\n\", j);\n      if ((j % 8) == 0)\n        printf(\" \");\n      printf(\" %5d,\",uni2index[j]);\n      if ((j % 8) == 7)\n        printf(\"\\n\");\n    }\n    printf(\"};\\n\");\n  }\n  printf(\"\\n\");\n\n  return 0;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "libiconv/libiconv-1.15/woe32dll/export.h": {},
  "libiconv/libiconv-1.15/woe32dll/iconv-exports.c": {}
}