{
  "inetutils/inetutils-1.9.4/build-aux/snippet/arg-nonnull.h": {},
  "inetutils/inetutils-1.9.4/build-aux/snippet/c++defs.h": {},
  "inetutils/inetutils-1.9.4/build-aux/snippet/unused-parameter.h": {},
  "inetutils/inetutils-1.9.4/build-aux/snippet/warn-on-use.h": {},
  "inetutils/inetutils-1.9.4/build-aux/snippet/_Noreturn.h": {},
  "inetutils/inetutils-1.9.4/ftp/cmds.c": {
    "all_lower": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static int\nall_lower (char *str)\n{\n  while (*str)\n    if (isupper (*str++))\n      return 0;\n  return 1;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "all_upper": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\nall_upper (char *str)\n{\n  while (*str)\n    if (islower (*str++))\n      return 0;\n  return 1;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "strdown": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static char *\nstrdown (char *str)\n{\n  char *p;\n  for (p = str; *p; p++)\n    if (isupper (*p))\n      *p = tolower (*p);\n  return str;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nstrdown (char *str)",
        "*"
      ]
    },
    "another": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "int\nanother (int *pargc, char ***pargv, const char *prompt)\n{\n  char *arg = NULL;\n  char *buffer, *new;\n  size_t size = 0, len = strlen (line);\n  int ret;\n\n  buffer = (char *) malloc (sizeof (char) * (strlen (prompt) + 4));\n  if (!buffer)\n    intr (0);\n\n  sprintf (buffer, \"(%s) \", prompt);\n\n#if HAVE_READLINE\n  if (usereadline)\n    arg = readline (buffer);\n  else\n#endif /* HAVE_READLINE */\n    {\n      char *nl;\n\n      fprintf (stdout, \"%s\", buffer);\n      fflush (stdout);\n\n      if (getline (&arg, &size, stdin) <= 0)\n\t{\n\t  free (buffer);\n\t  free (arg);\n\t  intr (0);\n\t}\n\n      nl = strchr (arg, '\\n');\n      if (nl)\n\t*nl = '\\0';\n    }\n\n  free (buffer);\n\n#if HAVE_READLINE\n  if (usereadline && arg && *arg)\n    add_history (arg);\n#endif /* HAVE_READLINE */\n\n  if (!arg)\n    intr (0);\n  else if (!*arg)\n    {\n      free (arg);\n      return 0;\n    }\n\n  new = realloc (line, sizeof (char) *\n\t\t       ((linelen ? linelen : len) + strlen (arg) + 2));\n  if (!new)\n    {\n      free (arg);\n      intr (0);\n    }\n\n  line = new;\n  linelen = sizeof (char) *\n\t    ((linelen ? linelen : len) + strlen (arg) + 2);\n  line[len++] = ' ';\n  strcpy (&line[len], arg);\n  free (arg);\n\n  makeargv ();\n  ret = margc > *pargc;\n  *pargc = margc;\n  *pargv = margv;\n  return (ret);\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "setpeer": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\nsetpeer (int argc, char **argv)\n{\n  char *host = NULL;\n  int port;\n\n  if (connected && command (\"NOOP\") != COMPLETE)\n    disconnect (0, 0);\n  else if (connected)\n    {\n      printf (\"Already connected to %s, use close first.\\n\", hostname);\n      code = -1;\n      return;\n    }\n\n  if (argc < 2)\n    {\n      if (hostname)\n\t{\n          host = hostname;\n          argc = 2;\n        }\n      else\n        another (&argc, &argv, \"to\");\n    }\n\n  if (argc < 2 || argc > 3)\n    {\n      printf (\"usage: %s host-name [port]\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n\n  if (!host)\n    host = argv[1];\n\n  if (argc == 3)\n    {\n      if (isdigit(argv[2][0]) || argv[2][0] == '-')\n\tport = atoi (argv[2]);\n      else\n\t{\n\t  struct servent *sp;\n\n\t  sp = getservbyname (argv[2], \"tcp\");\n\t  port = (sp) ? ntohs (sp->s_port) : 0;\n\t}\n\n      if (port <= 0 || port > 65535)\n\t{\n\t  printf (\"%s: bad port -- %s\\n\", argv[1], argv[2]);\n\t  printf (\"usage: %s host-name [port]\\n\", argv[0]);\n\t  code = -1;\n\t  return;\n\t}\n    }\n  else\n    {\n      struct servent *sp;\n\n      sp = getservbyname (\"ftp\", \"tcp\");\n      port = (sp) ? ntohs (sp->s_port) : DEFPORT;\n    }\n\n  /* After hookup(), the global variable `hostname' contains\n   * the canonical host name corresponding to the alias name\n   * contained in HOST.  The return value of hookup() is not\n   * NULL only if the server has answered our call.  The value\n   * of HOST should be preserved for reporting inside login(),\n   * which also detects a correct stanza of the netrc file.\n   */\n  if (hookup (host, port))\n    {\n      int overbose;\n\n      connected = 1;\n      /*\n       * Set up defaults for FTP.\n       */\n      strcpy (typename, \"ascii\"), type = TYPE_A;\n      curtype = TYPE_A;\n      strcpy (formname, \"non-print\"), form = FORM_N;\n      strcpy (modename, \"stream\"), mode = MODE_S;\n      strcpy (structname, \"file\"), stru = STRU_F;\n      strcpy (bytename, \"8\"), bytesize = 8;\n      if (autologin)\n\tlogin (host);\n\n#if (defined unix || defined __unix || defined __unix__) && NBBY == 8\n/*\n * this ifdef is to keep someone form \"porting\" this to an incompatible\n * system and not checking this out. This way they have to think about it.\n */\n      overbose = verbose;\n      if (debug == 0)\n\tverbose = -1;\n      if (command (\"SYST\") == COMPLETE && overbose)\n\t{\n\t  char *cp, c;\n\t  cp = strchr (reply_string + 4, ' ');\n\t  if (cp == NULL)\n\t    cp = strchr (reply_string + 4, '\\r');\n\t  if (cp)\n\t    {\n\t      if (cp[-1] == '.')\n\t\tcp--;\n\t      c = *cp;\n\t      *cp = '\\0';\n\t    }\n\n\t  printf (\"Remote system type is %s.\\n\", reply_string + 4);\n\t  if (cp)\n\t    *cp = c;\n\t}\n      if (!strncmp (reply_string, \"215 UNIX Type: L8\", 17))\n\t{\n\t  if (proxy)\n\t    unix_proxy = 1;\n\t  else\n\t    unix_server = 1;\n\t  /*\n\t   * Set type to 0 (not specified by user),\n\t   * meaning binary by default, but don't bother\n\t   * telling server.  We can use binary\n\t   * for text files unless changed by the user.\n\t   */\n\t  type = 0;\n\t  strcpy (typename, \"binary\");\n\t  if (overbose)\n\t    printf (\"Using %s mode to transfer files.\\n\", typename);\n\t}\n      else\n\t{\n\t  if (proxy)\n\t    unix_proxy = 0;\n\t  else\n\t    unix_server = 0;\n\t  if (overbose && !strncmp (reply_string, \"215 TOPS20\", 10))\n\t    printf\n\t      (\"Remember to set tenex mode when transferring binary files from this machine.\\n\");\n\t}\n      verbose = overbose;\n#endif /* (unix || __unix || __unix__) && (NBBY == 8) */\n    }\n}",
      "lines": 145,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "settype": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "void\nsettype (int argc, char **argv)\n{\n  struct types *p;\n  int comret;\n\n  if (argc > 2)\n    {\n      char *sep;\n\n      printf (\"usage: %s [\", argv[0]);\n      sep = \" \";\n      for (p = types; p->t_name; p++)\n\t{\n\t  printf (\"%s%s\", sep, p->t_name);\n\t  sep = \" | \";\n\t}\n      printf (\" ]\\n\");\n      code = -1;\n      return;\n    }\n  if (argc < 2)\n    {\n      printf (\"Using %s mode to transfer files.\\n\", typename);\n      code = 0;\n      return;\n    }\n  for (p = types; p->t_name; p++)\n    if (strcmp (argv[1], p->t_name) == 0)\n      break;\n  if (p->t_name == 0)\n    {\n      printf (\"%s: unknown mode\\n\", argv[1]);\n      code = -1;\n      return;\n    }\n  if ((p->t_arg != NULL) && (*(p->t_arg) != '\\0'))\n    comret = command (\"TYPE %s %s\", p->t_mode, p->t_arg);\n  else\n    comret = command (\"TYPE %s\", p->t_mode);\n  if (comret == COMPLETE)\n    {\n      strcpy (typename, p->t_name);\n      curtype = type = p->t_type;\n    }\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "changetype": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "void\nchangetype (int newtype, int show)\n{\n  struct types *p;\n  int comret, oldverbose = verbose;\n\n  if (newtype == 0)\n    newtype = TYPE_I;\n  if (newtype == curtype)\n    return;\n  if (debug == 0 && show == 0)\n    verbose = 0;\n  for (p = types; p->t_name; p++)\n    if (newtype == p->t_type)\n      break;\n  if (p->t_name == 0)\n    {\n      printf (\"ftp: internal error: unknown type %d\\n\", newtype);\n      return;\n    }\n  if (newtype == TYPE_L && bytename[0] != '\\0')\n    comret = command (\"TYPE %s %s\", p->t_mode, bytename);\n  else\n    comret = command (\"TYPE %s\", p->t_mode);\n  if (comret == COMPLETE)\n    curtype = newtype;\n  verbose = oldverbose;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "setbinary": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "void\nsetbinary (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  stype[1] = \"binary\";\n  settype (2, stype);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setascii": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "void\nsetascii (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  stype[1] = \"ascii\";\n  settype (2, stype);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "settenex": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "void\nsettenex (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  stype[1] = \"tenex\";\n  settype (2, stype);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setftmode": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "void\nsetftmode (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  printf (\"We only support %s mode, sorry.\\n\", modename);\n  code = -1;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setform": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "void\nsetform (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  printf (\"We only support %s format, sorry.\\n\", formname);\n  code = -1;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setstruct": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "void\nsetstruct (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  printf (\"We only support %s structure, sorry.\\n\", structname);\n  code = -1;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "put": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        605,
        1
      ],
      "content": "void\nput (int argc, char **argv)\n{\n  char *cmd, *local, *remote;\n  int loc = 0;\n\n  if (argc == 2)\n    {\n      argc++;\n      argv[2] = argv[1];\n      loc++;\n    }\n  if (argc < 2 && !another (&argc, &argv, \"local-file\"))\n    goto usage;\n  if (argc < 3 && !another (&argc, &argv, \"remote-file\"))\n    {\n    usage:\n      printf (\"usage: %s local-file remote-file\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n\n  local = globulize (argv[1]);\n  if (!local)\n    {\n      code = -1;\n      return;\n    }\n\n  /*\n   * If \"globulize\" modifies argv[1], and argv[2] is a copy of\n   * the old argv[1], make it a copy of the new argv[1].\n   */\n  if (loc)\n    remote = strdup (local);\n  else\n    remote = strdup (argv[2]);\n\n  cmd = (argv[0][0] == 'a') ? \"APPE\" : ((sunique) ? \"STOU\" : \"STOR\");\n  if (loc && ntflag)\n    {\n      char *new = dotrans (remote);\n      free (remote);\n      remote = new;\n    }\n  if (loc && mapflag)\n    {\n      char *new = domap (remote);\n      if (new != remote)\n\t{\n\t  free (remote);\n\t  remote = new;\n\t}\n    }\n  sendrequest (cmd, local, remote,\n\t       strcmp (argv[1], local) != 0 || strcmp (argv[2], remote) != 0);\n  free (local);\n  free (remote);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mput": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "void\nmput (int argc, char **argv)\n{\n  int i;\n  sighandler_t oldintr;\n  int ointer;\n\n  if (argc < 2 && !another (&argc, &argv, \"local-files\"))\n    {\n      printf (\"usage: %s local-files\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  mname = argv[0];\n  mflag = 1;\n  oldintr = signal (SIGINT, mabort);\n  setjmp (jabort);\n  if (proxy)\n    {\n      char *cp;\n\n      while ((cp = remglob (argv, 0)) != NULL)\n\t{\n\t  if (*cp == 0)\n\t    mflag = 0;\n\t  if (mflag && confirm (argv[0], cp))\n\t    {\n\t      char *tp = cp;\n\n\t      if (mcase)\n\t\t{\n\t\t  if (all_upper (tp))\n\t\t    tp = strdown (strdup (tp));\n\t\t}\n\t      if (ntflag)\n\t\t{\n\t\t  char *new = dotrans (tp);\n\t\t  if (tp != cp)\n\t\t    free (tp);\n\t\t  tp = new;\n\t\t}\n\t      if (mapflag)\n\t\t{\n\t\t  char *new = domap (tp);\n\t\t  if (new != tp)\n\t\t    {\n\t\t      if (tp != cp)\n\t\t\tfree (tp);\n\t\t      tp = new;\n\t\t    }\n\t\t}\n\t      sendrequest ((sunique) ? \"STOU\" : \"STOR\",\n\t\t\t   cp, tp, cp != tp || !interactive);\n\t      if (!mflag && fromatty)\n\t\t{\n\t\t  ointer = interactive;\n\t\t  interactive = 1;\n\t\t  if (confirm (\"Continue with\", \"mput\"))\n\t\t    {\n\t\t      mflag++;\n\t\t    }\n\t\t  interactive = ointer;\n\t\t}\n\n\t      if (tp != cp)\n\t\tfree (tp);\n\t    }\n\n\t  free (cp);\n\t}\n      signal (SIGINT, oldintr);\n      mflag = 0;\n      return;\n    }\n  for (i = 1; i < argc; i++)\n    {\n      char **cpp;\n      glob_t gl;\n      int flags;\n\n      if (!doglob)\n\t{\n\t  if (mflag && confirm (argv[0], argv[i]))\n\t    {\n\t      char *tp = argv[i];\n\t      if (ntflag)\n\t\ttp = dotrans (tp);\n\t      if (mapflag)\n\t\t{\n\t\t  char *new = domap (tp);\n\t\t  if (new != tp)\n\t\t    {\n\t\t      if (tp != argv[i])\n\t\t\tfree (tp);\n\t\t      tp = new;\n\t\t    }\n\t\t}\n\t      sendrequest ((sunique) ? \"STOU\" : \"STOR\",\n\t\t\t   argv[i], tp, tp != argv[i] || !interactive);\n\t      if (!mflag && fromatty)\n\t\t{\n\t\t  ointer = interactive;\n\t\t  interactive = 1;\n\t\t  if (confirm (\"Continue with\", \"mput\"))\n\t\t    {\n\t\t      mflag++;\n\t\t    }\n\t\t  interactive = ointer;\n\t\t}\n\t      if (tp != argv[i])\n\t\tfree (tp);\n\t    }\n\t  continue;\n\t}\n\n      memset (&gl, 0, sizeof (gl));\n      flags = GLOB_NOCHECK;\n#ifdef GLOB_BRACE\n      flags |= GLOB_BRACE;\n#endif\n#ifdef GLOB_TILDE\n      flags |= GLOB_TILDE;\n#endif\n#ifdef GLOB_QUOTE\n      flags |= GLOB_QUOTE;\n#endif\n      if (glob (argv[i], flags, NULL, &gl) || gl.gl_pathc == 0)\n\t{\n\t  error (0, 0, \"%s: not found\", argv[i]);\n\t  globfree (&gl);\n\t  continue;\n\t}\n      for (cpp = gl.gl_pathv; cpp && *cpp != NULL; cpp++)\n\t{\n\t  if (mflag && confirm (argv[0], *cpp))\n\t    {\n\t      char *tp = *cpp;\n\t      if (ntflag)\n\t\ttp = dotrans (tp);\n\t      if (mapflag)\n\t\t{\n\t\t  char *new = domap (tp);\n\t\t  if (new != tp)\n\t\t    {\n\t\t      if (tp != *cpp)\n\t\t\tfree (tp);\n\t\t      tp = new;\n\t\t    }\n\t\t}\n\t      sendrequest ((sunique) ? \"STOU\" : \"STOR\",\n\t\t\t   *cpp, tp, *cpp != tp || !interactive);\n\t      if (!mflag && fromatty)\n\t\t{\n\t\t  ointer = interactive;\n\t\t  interactive = 1;\n\t\t  if (confirm (\"Continue with\", \"mput\"))\n\t\t    {\n\t\t      mflag++;\n\t\t    }\n\t\t  interactive = ointer;\n\t\t}\n\t      if (tp != *cpp)\n\t\tfree (tp);\n\t    }\n\t}\n      globfree (&gl);\n    }\n  signal (SIGINT, oldintr);\n  mflag = 0;\n}",
      "lines": 170,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "reget": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        786,
        1
      ],
      "content": "void\nreget (int argc, char **argv)\n{\n\n  getit (argc, argv, 1, \"r+w\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "get": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "void\nget (int argc, char **argv)\n{\n\n  getit (argc, argv, 0, restart_point ? \"r+w\" : \"w\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "getit": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "int\ngetit (int argc, char **argv, int restartit, char *mode)\n{\n  int loc = 0;\n  char *local;\n\n  if (argc == 2)\n    {\n      argc++;\n      argv[2] = argv[1];\n      loc++;\n    }\n  if (argc < 2 && !another (&argc, &argv, \"remote-file\"))\n    goto usage;\n  if (argc < 3 && !another (&argc, &argv, \"local-file\"))\n    {\n    usage:\n      printf (\"usage: %s remote-file [ local-file ]\\n\", argv[0]);\n      code = -1;\n      return (0);\n    }\n\n  local = globulize (argv[2]);\n  if (!local)\n    {\n      code = -1;\n      return (0);\n    }\n  if (loc && mcase && all_upper (local))\n    strdown (local);\n  if (loc && ntflag)\n    {\n      char *new = dotrans (local);\n      free (local);\n      local = new;\n    }\n  if (loc && mapflag)\n    {\n      char *new = domap (local);\n      if (new != local)\n\t{\n\t  free (local);\n\t  local = new;\n\t}\n    }\n  if (restartit)\n    {\n      struct stat stbuf;\n      int ret;\n\n      ret = stat (local, &stbuf);\n      if (restartit == 1)\n\t{\n\t  if (ret < 0)\n\t    {\n\t      error (0, errno, \"local: %s\", local);\n\t      free (local);\n\t      return (0);\n\t    }\n\t  restart_point = stbuf.st_size;\n\t}\n      else\n\t{\n\t  if (ret == 0)\n\t    {\n\t      int overbose;\n\n\t      overbose = verbose;\n\t      if (debug == 0)\n\t\tverbose = -1;\n\t      if (command (\"MDTM %s\", argv[1]) == COMPLETE)\n\t\t{\n\t\t  int yy, mo, day, hour, min, sec;\n\t\t  struct tm *tm;\n\t\t  verbose = overbose;\n\t\t  sscanf (reply_string,\n\t\t\t  \"%*s %04d%02d%02d%02d%02d%02d\",\n\t\t\t  &yy, &mo, &day, &hour, &min, &sec);\n\t\t  tm = gmtime (&stbuf.st_mtime);\n\t\t  tm->tm_mon++;\n\t\t  if (tm->tm_year + 1900 > yy)\n\t\t    {\n\t\t      free (local);\n\t\t      return (1);\n\t\t    }\n\t\t  if ((tm->tm_year + 1900 == yy &&\n\t\t       tm->tm_mon > mo) ||\n\t\t      (tm->tm_mon == mo &&\n\t\t       tm->tm_mday > day) ||\n\t\t      (tm->tm_mday == day &&\n\t\t       tm->tm_hour > hour) ||\n\t\t      (tm->tm_hour == hour &&\n\t\t       tm->tm_min > min) ||\n\t\t      (tm->tm_min == min && tm->tm_sec > sec))\n\t\t    {\n\t\t      free (local);\n\t\t      return (1);\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  printf (\"%s\\n\", reply_string);\n\t\t  verbose = overbose;\n\t\t  free (local);\n\t\t  return (0);\n\t\t}\n\t    }\n\t}\n    }\n\n  recvrequest (\"RETR\", local, argv[1], mode, strcmp (local, argv[2]) != 0);\n  restart_point = 0;\n  free (local);\n  return (0);\n}",
      "lines": 115,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "mabort": {
      "start_point": [
        914,
        0
      ],
      "end_point": [
        934,
        1
      ],
      "content": "void\nmabort (int signo _GL_UNUSED_PARAMETER)\n{\n  int ointer;\n\n  printf (\"\\n\");\n  fflush (stdout);\n  if (mflag && fromatty)\n    {\n      ointer = interactive;\n      interactive = 1;\n      if (confirm (\"Continue with\", mname))\n\t{\n\t  interactive = ointer;\n\t  longjmp (jabort, 0);\n\t}\n      interactive = ointer;\n    }\n  mflag = 0;\n  longjmp (jabort, 0);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mget": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "void\nmget (int argc, char **argv)\n{\n  sighandler_t oldintr;\n  int ointer;\n  char *cp, *tp;\n\n  if (argc < 2 && !another (&argc, &argv, \"remote-files\"))\n    {\n      printf (\"usage: %s remote-files\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  mname = argv[0];\n  mflag = 1;\n  oldintr = signal (SIGINT, mabort);\n  setjmp (jabort);\n  while ((cp = remglob (argv, proxy)) != NULL)\n    {\n      if (*cp == '\\0')\n\t{\n\t  mflag = 0;\n\t  continue;\n\t}\n      if (mflag && confirm (argv[0], cp))\n\t{\n\t  tp = cp;\n\t  if (mcase && !all_lower (tp))\n\t    tp = strdown (strdup (tp));\n\t  if (ntflag)\n\t    {\n\t      char *new = dotrans (tp);\n\t      if (tp != cp)\n\t\tfree (tp);\n\t      tp = new;\n\t    }\n\t  if (mapflag)\n\t    {\n\t      char *new = domap (tp);\n\t      if (new != tp)\n\t\t{\n\t\t  if (tp != cp)\n\t\t    free (tp);\n\t\t  tp = new;\n\t\t}\n\t    }\n\t  recvrequest (\"RETR\", tp, cp, \"w\", tp != cp || !interactive);\n\t  if (!mflag && fromatty)\n\t    {\n\t      ointer = interactive;\n\t      interactive = 1;\n\t      if (confirm (\"Continue with\", \"mget\"))\n\t\t{\n\t\t  mflag++;\n\t\t}\n\t      interactive = ointer;\n\t    }\n\t  if (tp != cp)\n\t    free (tp);\n\t}\n      free (cp);\n    }\n  signal (SIGINT, oldintr);\n  mflag = 0;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "remglob": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1116,
        1
      ],
      "content": "char *\nremglob (char **argv, int doswitch)\n{\n  static FILE *ftemp = NULL;\n  static char **args;\n  int buf_len = 0;\n  char *buf = 0;\n  int sofar = 0;\n  int oldverbose, oldhash;\n  int fd;\n  char *cp, *mode;\n\n  if (!mflag)\n    {\n      if (!doglob)\n\t{\n\t  args = NULL;\n\t}\n      else\n\t{\n\t  if (ftemp)\n\t    {\n\t      fclose (ftemp);\n\t      ftemp = NULL;\n\t    }\n\t}\n      return (NULL);\n    }\n  if (!doglob)\n    {\n      if (args == NULL)\n\targs = argv;\n      if ((cp = *++args) == NULL)\n\targs = NULL;\n      return cp ? 0 : strdup (cp);\n    }\n  if (ftemp == NULL)\n    {\n      char temp[sizeof PATH_TMP + sizeof \"XXXXXX\"];\n\n      strcpy (temp, PATH_TMP);\n      strcat (temp, \"XXXXXX\");\n#ifdef HAVE_MKSTEMP\n      fd = mkstemp (temp);\n#else\n      if (mktemp (temp) != NULL)\n\tfd = open (temp, O_CREAT | O_EXCL | O_RDWR, 0600);\n      else\n\tfd = -1;\n#endif\n      if (fd < 0)\n\t{\n\t  printf (\"unable to create temporary file %s: %s\\n\", temp,\n\t\t  strerror (errno));\n\t  return (NULL);\n\t}\n      close (fd);\n\n      oldverbose = verbose, verbose = 0;\n      oldhash = hash, hash = 0;\n      if (doswitch)\n\t{\n\t  pswitch (!proxy);\n\t}\n      for (mode = \"w\"; *++argv != NULL; mode = \"a\")\n\trecvrequest (\"NLST\", temp, *argv, mode, 0);\n      if (doswitch)\n\t{\n\t  pswitch (!proxy);\n\t}\n      verbose = oldverbose;\n      hash = oldhash;\n      ftemp = fopen (temp, \"r\");\n      unlink (temp);\n      if (ftemp == NULL)\n\t{\n\t  printf (\"can't find list of remote files, oops\\n\");\n\t  return (NULL);\n\t}\n    }\n\n  buf_len = 100;\t\t/* Any old size */\n  buf = malloc (buf_len + 1);\n\n  sofar = 0;\n  for (;;)\n    {\n      if (!buf)\n\t{\n\t  printf (\"malloc failure\\n\");\n\t  return 0;\n\t}\n      if (!fgets (buf + sofar, buf_len - sofar, ftemp))\n\t{\n\t  fclose (ftemp);\n\t  ftemp = NULL;\n\t  free (buf);\n\t  return 0;\n\t}\n\n      sofar = strlen (buf);\n      if (buf[sofar - 1] == '\\n')\n\t{\n\t  buf[sofar - 1] = '\\0';\n\t  return buf;\n\t}\n\n      /* Make more room and read some more... */\n      buf_len += buf_len;\n      buf = realloc (buf, buf_len);\n    }\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "char",
        "*\nremglob (char **argv, int doswitch)",
        "*"
      ]
    },
    "onoff": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "char *\nonoff (int bool)\n{\n  return (bool ? \"on\" : \"off\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nonoff (int bool)",
        "*"
      ]
    },
    "status": {
      "start_point": [
        1127,
        0
      ],
      "end_point": [
        1187,
        1
      ],
      "content": "void\nstatus (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  int i;\n\n  if (connected)\n    printf (\"Connected to %s.\\n\", hostname);\n  else\n    printf (\"Not connected.\\n\");\n  printf (\"Connection addressing: %s\\n\",\n\t  (usefamily == AF_UNSPEC) ? \"any\"\n\t    : (usefamily == AF_INET6) ? \"IPv6\" : \"IPv4\");\n  if (!proxy)\n    {\n      pswitch (1);\n      if (connected)\n\t{\n\t  printf (\"Connected for proxy commands to %s.\\n\", hostname);\n\t}\n      else\n\t{\n\t  printf (\"No proxy connection.\\n\");\n\t}\n      pswitch (0);\n    }\n  printf (\"Mode: %s; Type: %s; Form: %s; Structure: %s\\n\",\n\t  modename, typename, formname, structname);\n  printf (\"Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\\n\",\n\t  onoff (verbose), onoff (bell), onoff (interactive), onoff (doglob));\n  printf (\"Store unique: %s; Receive unique: %s\\n\", onoff (sunique),\n\t  onoff (runique));\n  printf (\"Case: %s; CR stripping: %s\\n\", onoff (mcase), onoff (crflag));\n  if (ntflag)\n    {\n      printf (\"Ntrans: (in) %s (out) %s\\n\", ntin, ntout);\n    }\n  else\n    {\n      printf (\"Ntrans: off\\n\");\n    }\n  if (mapflag)\n    {\n      printf (\"Nmap: (in) %s (out) %s\\n\", mapin, mapout);\n    }\n  else\n    {\n      printf (\"Nmap: off\\n\");\n    }\n  printf (\"Hash mark printing: %s; Use of PORT cmds: %s\\n\",\n\t  onoff (hash), onoff (sendport));\n  printf (\"Use of EPRT/EPSV for IPv4: %s\\n\", onoff (doepsv4));\n  if (macnum > 0)\n    {\n      printf (\"Macros:\\n\");\n      for (i = 0; i < macnum; i++)\n\t{\n\t  printf (\"\\t%s\\n\", macros[i].mac_name);\n\t}\n    }\n  code = 0;\n}",
      "lines": 61,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "setbell": {
      "start_point": [
        1192,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "void\nsetbell (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  bell = !bell;\n  printf (\"Bell mode %s.\\n\", onoff (bell));\n  code = bell;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "settrace": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "void\nsettrace (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  trace = !trace;\n  printf (\"Packet tracing %s.\\n\", onoff (trace));\n  code = trace;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sethash": {
      "start_point": [
        1223,
        0
      ],
      "end_point": [
        1266,
        1
      ],
      "content": "void\nsethash (int argc _GL_UNUSED_PARAMETER, char **argv)\n{\n  char *p = argv[1];\n\n  /* P is NULL when no argument was passed with `hash'.  */\n  while (p && isdigit (*p))\n    p++;\n\n  if (argv[1] != NULL)\n    sscanf (argv[1], \"%d\", &hashbytes);\n\n  /* Apply a multiplier only if a numerical part exists.  */\n  if (argv[1] && isdigit (*argv[1]))\n    {\n      hash = 1;\t\t\t/* Enforce markers.  */\n\n      switch (*p)\n\t{\n\tcase 'g':\n\tcase 'G':\n\t  hashbytes *= 1024;\t/* Cascaded multiplication!  */\n\tcase 'm':\n\tcase 'M':\n\t  hashbytes *= 1024;\n\tcase 'k':\n\tcase 'K':\n\t  hashbytes *= 1024;\n\t}\n    }\n\n  if (hashbytes <= 0)\n    hashbytes = 1024;\n\n  if (!argv[1])\t\t\t/* Toggle when argument is absent.  */\n    hash = !hash;\n\n  printf (\"Hash mark printing %s\", onoff (hash));\n  if (hash)\n    printf (\" (%d bytes/hash mark)\", hashbytes);\n  printf (\".\\n\");\n\n  code = hash;\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "setverbose": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1278,
        1
      ],
      "content": "void\nsetverbose (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  verbose = !verbose;\n  printf (\"Verbose mode %s.\\n\", onoff (verbose));\n  code = verbose;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setipany": {
      "start_point": [
        1283,
        0
      ],
      "end_point": [
        1289,
        1
      ],
      "content": "void\nsetipany (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  usefamily = AF_UNSPEC;\n  printf (\"Selecting addresses: %s.\\n\", \"any\");\n  code = usefamily;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setipv4": {
      "start_point": [
        1294,
        0
      ],
      "end_point": [
        1300,
        1
      ],
      "content": "void\nsetipv4 (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  usefamily = AF_INET;\n  printf (\"Selecting addresses: %s.\\n\", \"IPv4\");\n  code = usefamily;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setipv6": {
      "start_point": [
        1305,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "void\nsetipv6 (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  usefamily = AF_INET6;\n  printf (\"Selecting addresses: %s.\\n\", \"IPv6\");\n  code = usefamily;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setepsv4": {
      "start_point": [
        1316,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "void\nsetepsv4 (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  doepsv4 = !doepsv4;\n  printf (\"Use of EPRT/EPSV for IPv4: %s.\\n\", onoff (doepsv4));\n  code = doepsv4;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setport": {
      "start_point": [
        1328,
        0
      ],
      "end_point": [
        1335,
        1
      ],
      "content": "void\nsetport (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  sendport = !sendport;\n  printf (\"Use of PORT cmds %s.\\n\", onoff (sendport));\n  code = sendport;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setprompt": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1348,
        1
      ],
      "content": "void\nsetprompt (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  interactive = !interactive;\n  printf (\"Interactive mode %s.\\n\", onoff (interactive));\n  code = interactive;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setglob": {
      "start_point": [
        1354,
        0
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "void\nsetglob (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  doglob = !doglob;\n  printf (\"Globbing %s.\\n\", onoff (doglob));\n  code = doglob;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setdebug": {
      "start_point": [
        1367,
        0
      ],
      "end_point": [
        1391,
        1
      ],
      "content": "void\nsetdebug (int argc, char **argv)\n{\n  int val;\n\n  if (argc > 1)\n    {\n      val = atoi (argv[1]);\n      if (val < 0)\n\t{\n\t  printf (\"%s: bad debugging value.\\n\", argv[1]);\n\t  code = -1;\n\t  return;\n\t}\n    }\n  else\n    val = !debug;\n  debug = val;\n  if (debug)\n    options |= SO_DEBUG;\n  else\n    options &= ~SO_DEBUG;\n  printf (\"Debugging %s (debug=%d).\\n\", onoff (debug), debug);\n  code = debug > 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "cd": {
      "start_point": [
        1397,
        0
      ],
      "end_point": [
        1413,
        1
      ],
      "content": "void\ncd (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"remote-directory\"))\n    {\n      printf (\"usage: %s remote-directory\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  if (command (\"CWD %s\", argv[1]) == ERROR && code == 500)\n    {\n      if (verbose)\n\tprintf (\"CWD command not recognized, trying XCWD\\n\");\n      command (\"XCWD %s\", argv[1]);\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "lcd": {
      "start_point": [
        1419,
        0
      ],
      "end_point": [
        1459,
        1
      ],
      "content": "void\nlcd (int argc, char **argv)\n{\n  char *dir;\n\n  if (argc < 2)\n    argc++, argv[1] = home;\n  if (argc != 2)\n    {\n      printf (\"usage: %s local-directory\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n\n  dir = globulize (argv[1]);\n  if (!dir)\n    {\n      code = -1;\n      return;\n    }\n\n  if (chdir (dir) < 0)\n    {\n      error (0, errno, \"dir: %s\", dir);\n      free (dir);\n      code = -1;\n      return;\n    }\n\n  free (dir);\n\n  dir = xgetcwd ();\n  if (dir)\n    {\n      printf (\"Local directory now %s\\n\", dir);\n      free (dir);\n    }\n  else\n    error (0, errno, \"getcwd\");\n  code = 0;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "delete": {
      "start_point": [
        1464,
        0
      ],
      "end_point": [
        1475,
        1
      ],
      "content": "void\ndelete (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"remote-file\"))\n    {\n      printf (\"usage: %s remote-file\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  command (\"DELE %s\", argv[1]);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mdelete": {
      "start_point": [
        1480,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "void\nmdelete (int argc, char **argv)\n{\n  sighandler_t oldintr;\n  int ointer;\n  char *cp;\n\n  if (argc < 2 && !another (&argc, &argv, \"remote-files\"))\n    {\n      printf (\"usage: %s remote-files\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  mname = argv[0];\n  mflag = 1;\n  oldintr = signal (SIGINT, mabort);\n  setjmp (jabort);\n  while ((cp = remglob (argv, 0)) != NULL)\n    {\n      if (*cp == '\\0')\n\t{\n\t  mflag = 0;\n\t  continue;\n\t}\n      if (mflag && confirm (argv[0], cp))\n\t{\n\t  command (\"DELE %s\", cp);\n\t  if (!mflag && fromatty)\n\t    {\n\t      ointer = interactive;\n\t      interactive = 1;\n\t      if (confirm (\"Continue with\", \"mdelete\"))\n\t\t{\n\t\t  mflag++;\n\t\t}\n\t      interactive = ointer;\n\t    }\n\t}\n      free (cp);\n    }\n  signal (SIGINT, oldintr);\n  mflag = 0;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "renamefile": {
      "start_point": [
        1527,
        0
      ],
      "end_point": [
        1542,
        1
      ],
      "content": "void\nrenamefile (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"from-name\"))\n    goto usage;\n  if (argc < 3 && !another (&argc, &argv, \"to-name\"))\n    {\n    usage:\n      printf (\"%s from-name to-name\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  if (command (\"RNFR %s\", argv[1]) == CONTINUE)\n    command (\"RNTO %s\", argv[2]);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ls": {
      "start_point": [
        1548,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "void\nls (int argc, char **argv)\n{\n  char *cmd, *dest;\n\n  if (argc < 2)\n    argc++, argv[1] = NULL;\n  if (argc < 3)\n    argc++, argv[2] = \"-\";\n  if (argc > 3)\n    {\n      printf (\"usage: %s remote-directory local-file\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  cmd = argv[0][0] == 'n' ? \"NLST\" : \"LIST\";\n\n  if (strcmp (argv[2], \"-\") != 0)\n    {\n      dest = globulize (argv[2]);\n      if (!dest)\n\t{\n\t  code = -1;\n\t  return;\n\t}\n      if (*dest != '|' && !confirm (\"output to local-file:\", dest))\n\t{\n\t  code = -1;\n\t  goto out;\n\t}\n    }\n  else\n    dest = 0;\n\n  recvrequest (cmd, dest ? dest : \"-\", argv[1], \"w\", 0);\nout:\n  free (dest);\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mls": {
      "start_point": [
        1591,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "void\nmls (int argc, char **argv)\n{\n  sighandler_t oldintr;\n  int ointer, i;\n  char *cmd, mode[1], *dest;\n\n  if (argc < 2 && !another (&argc, &argv, \"remote-files\"))\n    goto usage;\n  if (argc < 3 && !another (&argc, &argv, \"local-file\"))\n    {\n    usage:\n      printf (\"usage: %s remote-files local-file\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n\n  dest = argv[argc - 1];\n  argv[argc - 1] = NULL;\n  if (strcmp (dest, \"-\") && *dest != '|')\n    {\n      dest = globulize (dest);\n      if (!dest)\n\t{\n\t  code = -1;\n\t  return;\n\t}\n      if (!confirm (\"output to local-file:\", dest))\n\t{\n\t  code = -1;\n\t  free (dest);\n\t  return;\n\t}\n    }\n  else\n    dest = strdup (dest);\n\n  cmd = argv[0][1] == 'l' ? \"NLST\" : \"LIST\";\n  mname = argv[0];\n  mflag = 1;\n  oldintr = signal (SIGINT, mabort);\n  setjmp (jabort);\n  for (i = 1; mflag && i < argc - 1; ++i)\n    {\n      *mode = (i == 1) ? 'w' : 'a';\n      recvrequest (cmd, dest, argv[i], mode, 0);\n      if (!mflag && fromatty)\n\t{\n\t  ointer = interactive;\n\t  interactive = 1;\n\t  if (confirm (\"Continue with\", argv[0]))\n\t    {\n\t      mflag++;\n\t    }\n\t  interactive = ointer;\n\t}\n    }\n\n  signal (SIGINT, oldintr);\n  mflag = 0;\n  free (dest);\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "shell": {
      "start_point": [
        1657,
        0
      ],
      "end_point": [
        1715,
        1
      ],
      "content": "void\nshell (int argc, char **argv _GL_UNUSED_PARAMETER)\n{\n  pid_t pid;\n  sighandler_t old1, old2;\n  char shellnam[40], *shell, *namep;\n\n  old1 = signal (SIGINT, SIG_IGN);\n  old2 = signal (SIGQUIT, SIG_IGN);\n  if ((pid = fork ()) == 0)\n    {\n      for (pid = 3; pid < 20; pid++)\n\tclose (pid);\n      signal (SIGINT, SIG_DFL);\n      signal (SIGQUIT, SIG_DFL);\n      shell = getenv (\"SHELL\");\n      if (shell == NULL)\n\tshell = PATH_BSHELL;\n      namep = strrchr (shell, '/');\n      if (namep == NULL)\n\tnamep = shell;\t\t/* No slash in this name.  */\n      else\n\tnamep++;\t\t/* Skip the slash character.  */\n      strcpy (shellnam, \"-\");\n      strncat (shellnam, namep, sizeof (shellnam) - 2);\n      if (strcmp (namep, \"sh\") != 0)\n\tshellnam[0] = '+';\n      if (debug)\n\t{\n\t  printf (\"%s\\n\", shell);\n\t  fflush (stdout);\n\t}\n      if (argc > 1)\n\t{\n\t  execl (shell, shellnam, \"-c\", altarg, (char *) 0);\n\t}\n      else\n\t{\n\t  execl (shell, shellnam, (char *) 0);\n\t}\n      error (0, errno, \"shell\");\n      code = -1;\n      exit (EXIT_FAILURE);\n    }\n  if (pid > 0)\n    while (wait (0) != pid)\n      ;\n  signal (SIGINT, old1);\n  signal (SIGQUIT, old2);\n  if (pid == -1)\n    {\n      error (0, errno, \"Try again later\");\n      code = -1;\n    }\n  else\n    {\n      code = 0;\n    }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "user": {
      "start_point": [
        1720,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "void\nuser (int argc, char **argv)\n{\n  char acct[80];\n  int n, aflag = 0;\n\n  if (argc < 2)\n    another (&argc, &argv, \"username\");\n  if (argc < 2 || argc > 4)\n    {\n      printf (\"usage: %s username [password] [account]\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  n = command (\"USER %s\", argv[1]);\n  if (n == CONTINUE)\n    {\n      /* Is this a case of challenge-response?\n       * RFC 2228 stipulates code 336 for this.\n       * Suppress message in verbose mode, since\n       * it has already been displayed.\n       */\n      if (code == 336 && !verbose)\n\tprintf (\"%s\\n\", reply_string + strlen (\"336 \"));\n      /* In addition, any password given on the\n       * command line is irrelevant, so ignore it.\n       */\n      if (argc < 3 || code == 336)\n\targv[2] = getpass (\"Password: \");\n      if (argc < 3)\n\targc++;\n      n = command (\"PASS %s\", argv[2]);\n      if (argv[2])\n\tmemset (argv[2], 0, strlen (argv[2]));\n    }\n  if (n == CONTINUE)\n    {\n      if (argc < 4)\n\t{\n\t  printf (\"Account: \");\n\t  fflush (stdout);\n\t  if (fgets (acct, sizeof (acct) - 1, stdin))\n\t    acct[strlen (acct) - 1] = '\\0';\t/* Erase newline.  */\n\t  else\n\t    acct[0] = '\\0';\t\t\t/* Set empty name.  */\n\t  argv[3] = acct;\n\t  argc++;\n\t}\n      n = command (\"ACCT %s\", argv[3]);\n      aflag++;\n    }\n  if (n != COMPLETE)\n    {\n      fprintf (stdout, \"Login failed.\\n\");\n      return;\n    }\n  if (!aflag && argc == 4)\n    {\n      command (\"ACCT %s\", argv[3]);\n    }\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "pwd": {
      "start_point": [
        1785,
        0
      ],
      "end_point": [
        1800,
        1
      ],
      "content": "void\npwd (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  int oldverbose = verbose;\n\n  /*\n   * If we aren't verbose, this doesn't do anything!\n   */\n  verbose = 1;\n  if (command (\"PWD\") == ERROR && code == 500)\n    {\n      printf (\"PWD command not recognized, trying XPWD\\n\");\n      command (\"XPWD\");\n    }\n  verbose = oldverbose;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "lpwd": {
      "start_point": [
        1805,
        0
      ],
      "end_point": [
        1819,
        1
      ],
      "content": "void\nlpwd (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  char *dir = xgetcwd ();\n\n  if (dir)\n    {\n      printf (\"Local directory is %s\\n\", dir);\n      free (dir);\n    }\n  else\n    error (0, errno, \"getcwd\");\n\n  code = 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "makedir": {
      "start_point": [
        1824,
        0
      ],
      "end_point": [
        1840,
        1
      ],
      "content": "void\nmakedir (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"directory-name\"))\n    {\n      printf (\"usage: %s directory-name\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  if (command (\"MKD %s\", argv[1]) == ERROR && code == 500)\n    {\n      if (verbose)\n\tprintf (\"MKD command not recognized, trying XMKD\\n\");\n      command (\"XMKD %s\", argv[1]);\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "removedir": {
      "start_point": [
        1845,
        0
      ],
      "end_point": [
        1861,
        1
      ],
      "content": "void\nremovedir (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"directory-name\"))\n    {\n      printf (\"usage: %s directory-name\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  if (command (\"RMD %s\", argv[1]) == ERROR && code == 500)\n    {\n      if (verbose)\n\tprintf (\"RMD command not recognized, trying XRMD\\n\");\n      command (\"XRMD %s\", argv[1]);\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quote": {
      "start_point": [
        1866,
        0
      ],
      "end_point": [
        1877,
        1
      ],
      "content": "void\nquote (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"command line to send\"))\n    {\n      printf (\"usage: %s line-to-send\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  quote1 (\"\", argc, argv);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "site": {
      "start_point": [
        1884,
        0
      ],
      "end_point": [
        1895,
        1
      ],
      "content": "void\nsite (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"arguments to SITE command\"))\n    {\n      printf (\"usage: %s line-to-send\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  quote1 (\"SITE \", argc, argv);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quote1": {
      "start_point": [
        1901,
        0
      ],
      "end_point": [
        1923,
        1
      ],
      "content": "void\nquote1 (char *initial, int argc, char **argv)\n{\n  int i, len;\n  char buf[BUFSIZ];\t\t/* must be >= sizeof(line) */\n\n  strcpy (buf, initial);\n  if (argc > 1)\n    {\n      len = strlen (buf);\n      len += strlen (strcpy (&buf[len], argv[1]));\n      for (i = 2; i < argc; i++)\n\t{\n\t  buf[len++] = ' ';\n\t  len += strlen (strcpy (&buf[len], argv[i]));\n\t}\n    }\n  if (command (buf) == PRELIM)\n    {\n      while (getreply (0) == PRELIM)\n\tcontinue;\n    }\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "do_chmod": {
      "start_point": [
        1925,
        0
      ],
      "end_point": [
        1939,
        1
      ],
      "content": "void\ndo_chmod (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"mode\"))\n    goto usage;\n  if (argc < 3 && !another (&argc, &argv, \"file-name\"))\n    {\n    usage:\n      printf (\"usage: %s mode file-name\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  command (\"SITE CHMOD %s %s\", argv[1], argv[2]);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "do_umask": {
      "start_point": [
        1941,
        0
      ],
      "end_point": [
        1949,
        1
      ],
      "content": "void\ndo_umask (int argc, char **argv)\n{\n  int oldverbose = verbose;\n\n  verbose = 1;\n  command (argc == 1 ? \"SITE UMASK\" : \"SITE UMASK %s\", argv[1]);\n  verbose = oldverbose;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "site_idle": {
      "start_point": [
        1951,
        0
      ],
      "end_point": [
        1959,
        1
      ],
      "content": "void\nsite_idle (int argc, char **argv)\n{\n  int oldverbose = verbose;\n\n  verbose = 1;\n  command (argc == 1 ? \"SITE IDLE\" : \"SITE IDLE %s\", argv[1]);\n  verbose = oldverbose;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rmthelp": {
      "start_point": [
        1964,
        0
      ],
      "end_point": [
        1972,
        1
      ],
      "content": "void\nrmthelp (int argc, char **argv)\n{\n  int oldverbose = verbose;\n\n  verbose = 1;\n  command (argc == 1 ? \"HELP\" : \"HELP %s\", argv[1]);\n  verbose = oldverbose;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "quit": {
      "start_point": [
        1977,
        0
      ],
      "end_point": [
        1989,
        1
      ],
      "content": "void\nquit (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  if (connected)\n    disconnect (0, 0);\n  pswitch (1);\n  if (connected)\n    {\n      disconnect (0, 0);\n    }\n  exit (EXIT_SUCCESS);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "disconnect": {
      "start_point": [
        1994,
        0
      ],
      "end_point": [
        2012,
        1
      ],
      "content": "void\ndisconnect (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  if (!connected)\n    return;\n  command (\"QUIT\");\n  if (cout)\n    {\n      fclose (cout);\n    }\n  cout = NULL;\n  connected = 0;\n  data = -1;\n  if (!proxy)\n    {\n      macnum = 0;\n    }\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "confirm": {
      "start_point": [
        2014,
        0
      ],
      "end_point": [
        2026,
        1
      ],
      "content": "int\nconfirm (char *cmd, char *file)\n{\n  char input[BUFSIZ];\n\n  if (!interactive)\n    return (1);\n  printf (\"%s %s? \", cmd, file);\n  fflush (stdout);\n  if (fgets (input, sizeof input, stdin) == NULL)\n    return (0);\n  return (*input != 'n' && *input != 'N');\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fatal": {
      "start_point": [
        2028,
        0
      ],
      "end_point": [
        2033,
        1
      ],
      "content": "void\nfatal (char *msg)\n{\n\n  error (EXIT_FAILURE, 0, \"%s\", msg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "globulize": {
      "start_point": [
        2041,
        0
      ],
      "end_point": [
        2067,
        1
      ],
      "content": "char *\nglobulize (char *cp)\n{\n  glob_t gl;\n  int flags;\n\n  if (!doglob)\n    return strdup (cp);\n\n  flags = GLOB_BRACE | GLOB_NOCHECK | GLOB_TILDE;\n#ifdef GLOB_QUOTE\n  flags |= GLOB_QUOTE;\n#endif\n\n  memset (&gl, 0, sizeof (gl));\n  if (glob (cp, flags, NULL, &gl) || gl.gl_pathc == 0)\n    {\n      error (0, 0, \"%s: not found\", cp);\n      globfree (&gl);\n      return (0);\n    }\n\n  cp = strdup (gl.gl_pathv[0]);\n  globfree (&gl);\n\n  return cp;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "char",
        "*\nglobulize (char *cp)",
        "*"
      ]
    },
    "account": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2095,
        1
      ],
      "content": "void\naccount (int argc, char **argv)\n{\n  char acct[50], *ap;\n\n  if (argc > 1)\n    {\n      ++argv;\n      --argc;\n      strncpy (acct, *argv, sizeof (acct) - 1);\n      acct[sizeof (acct) - 1] = '\\0';\n      while (argc > 1)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  strncat (acct, *argv, (sizeof (acct) - 1) - strlen (acct));\n\t}\n      ap = acct;\n    }\n  else\n    {\n      ap = getpass (\"Account:\");\n    }\n  command (\"ACCT %s\", ap);\n  if (ap)\n    memset (ap, 0, strlen (ap));\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "proxabort": {
      "start_point": [
        2099,
        0
      ],
      "end_point": [
        2117,
        1
      ],
      "content": "void\nproxabort (int sig _GL_UNUSED_PARAMETER)\n{\n\n  if (!proxy)\n    {\n      pswitch (1);\n    }\n  if (connected)\n    {\n      proxflag = 1;\n    }\n  else\n    {\n      proxflag = 0;\n    }\n  pswitch (0);\n  longjmp (abortprox, 1);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "doproxy": {
      "start_point": [
        2119,
        0
      ],
      "end_point": [
        2180,
        1
      ],
      "content": "void\ndoproxy (int argc, char **argv)\n{\n  struct cmd *c;\n  sighandler_t oldintr;\n\n  if (argc < 2 && !another (&argc, &argv, \"command\"))\n    {\n      printf (\"usage: %s command\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  c = getcmd (argv[1]);\n  if (c == (struct cmd *) -1)\n    {\n      printf (\"?Ambiguous command\\n\");\n      fflush (stdout);\n      code = -1;\n      return;\n    }\n  if (c == 0)\n    {\n      printf (\"?Invalid command\\n\");\n      fflush (stdout);\n      code = -1;\n      return;\n    }\n  if (!c->c_proxy)\n    {\n      printf (\"?Invalid proxy command\\n\");\n      fflush (stdout);\n      code = -1;\n      return;\n    }\n  if (setjmp (abortprox))\n    {\n      code = -1;\n      return;\n    }\n  oldintr = signal (SIGINT, proxabort);\n  pswitch (1);\n  if (c->c_conn && !connected)\n    {\n      printf (\"Not connected\\n\");\n      fflush (stdout);\n      pswitch (0);\n      signal (SIGINT, oldintr);\n      code = -1;\n      return;\n    }\n  (*c->c_handler) (argc - 1, argv + 1);\n  if (connected)\n    {\n      proxflag = 1;\n    }\n  else\n    {\n      proxflag = 0;\n    }\n  pswitch (0);\n  signal (SIGINT, oldintr);\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "setcase": {
      "start_point": [
        2182,
        0
      ],
      "end_point": [
        2189,
        1
      ],
      "content": "void\nsetcase (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  mcase = !mcase;\n  printf (\"Case mapping %s.\\n\", onoff (mcase));\n  code = mcase;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setcr": {
      "start_point": [
        2191,
        0
      ],
      "end_point": [
        2198,
        1
      ],
      "content": "void\nsetcr (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  crflag = !crflag;\n  printf (\"Carriage Return stripping %s.\\n\", onoff (crflag));\n  code = crflag;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setntrans": {
      "start_point": [
        2200,
        0
      ],
      "end_point": [
        2221,
        1
      ],
      "content": "void\nsetntrans (int argc, char **argv)\n{\n  if (argc == 1)\n    {\n      ntflag = 0;\n      printf (\"Ntrans off.\\n\");\n      code = ntflag;\n      return;\n    }\n  ntflag++;\n  code = ntflag;\n  strncpy (ntin, argv[1], sizeof (ntin) - 1);\n  ntin[sizeof (ntin) - 1] = '\\0';\n  if (argc == 2)\n    {\n      ntout[0] = '\\0';\n      return;\n    }\n  strncpy (ntout, argv[2], sizeof (ntout) - 1);\n  ntout[sizeof (ntout) - 1] = '\\0';\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dotrans": {
      "start_point": [
        2226,
        0
      ],
      "end_point": [
        2257,
        1
      ],
      "content": "char *\ndotrans (char *name)\n{\n  char *new = xmalloc (strlen (name) + 1);\n  char *cp1, *cp2 = new;\n  size_t i, ostop, found;\n\n  for (ostop = 0; *(ntout + ostop) && ostop < sizeof (ntout) - 1; ostop++)\n    continue;\n  for (cp1 = name; *cp1; cp1++)\n    {\n      found = 0;\n      for (i = 0; *(ntin + i) && i < sizeof (ntin) - 1; i++)\n\t{\n\t  if (*cp1 == *(ntin + i))\n\t    {\n\t      found++;\n\t      if (i < ostop)\n\t\t{\n\t\t  *cp2++ = *(ntout + i);\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (!found)\n\t{\n\t  *cp2++ = *cp1;\n\t}\n    }\n  *cp2 = '\\0';\n  return (new);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "char",
        "*\ndotrans (char *name)",
        "*"
      ]
    },
    "setpassive": {
      "start_point": [
        2259,
        0
      ],
      "end_point": [
        2266,
        1
      ],
      "content": "void\nsetpassive (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  passivemode = !passivemode;\n  printf (\"Passive mode %s.\\n\", onoff (passivemode));\n  code = passivemode;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setnmap": {
      "start_point": [
        2268,
        0
      ],
      "end_point": [
        2305,
        1
      ],
      "content": "void\nsetnmap (int argc, char **argv)\n{\n  char *cp;\n\n  if (argc == 1)\n    {\n      mapflag = 0;\n      printf (\"Nmap off.\\n\");\n      code = mapflag;\n      return;\n    }\n  if (argc < 3 && !another (&argc, &argv, \"mapout\"))\n    {\n      printf (\"Usage: %s [mapin mapout]\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  mapflag = 1;\n  code = 1;\n  cp = strchr (altarg, ' ');\n  if (proxy)\n    {\n      while (*++cp == ' ')\n\tcontinue;\n      altarg = cp;\n      cp = strchr (altarg, ' ');\n    }\n  *cp = '\\0';\n\n  free (mapin);\n  mapin = strdup (altarg);\n\n  while (*++cp == ' ')\n    continue;\n  free (mapout);\n  mapout = strdup (cp);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "cp_subst": {
      "start_point": [
        2307,
        0
      ],
      "end_point": [
        2344,
        1
      ],
      "content": "static int\ncp_subst (char **from_p, char **to_p, int *toks, char **tp, char **te, char *tok0, char **buf_p, int *buf_len_p)\n{\n  int toknum;\n  char *src;\n  size_t src_len;\n\n  if (*++(*from_p) == '0')\n    {\n      src = tok0;\n      src_len = strlen (tok0);\n    }\n  else if (toks[toknum = **from_p - '1'])\n    {\n      src = tp[toknum];\n      src_len = te[toknum] - src;\n    }\n  else\n    return 0;\n\n  if (src_len > strlen (\"$2\"))\n    {\n      /* This substitution will be longer than the original text.\n       * Allocate a larger buffer and update the cursor, pointing\n       * within the new memory area.\n       */\n      size_t offset = *to_p - *buf_p;\n\n      *buf_len_p += src_len - strlen (\"$2\");\n      *buf_p = realloc (*buf_p, *buf_len_p);\n      *to_p = *buf_p + offset;\n    }\n\n  while (src_len--)\n    *(*to_p)++ = *src++;\n\n  return 1;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "domap": {
      "start_point": [
        2350,
        0
      ],
      "end_point": [
        2515,
        1
      ],
      "content": "char *\ndomap (char *name)\n{\n  /* The string `mapout' will have its tokens expanded,\n   * but is essentially the minimal output string.\n   * Some brackets and some alternate strings might\n   * need to be suppressed.\n   */\n  int buf_len = strlen (mapout) + 1;\n  char *buf = xmalloc (buf_len);\n  char *cp1 = name, *cp2 = mapin;\n  char *tp[9], *te[9];\n  int i, toks[9], toknum = 0, match = 1;\n\n  for (i = 0; i < 9; ++i)\n    {\n      toks[i] = 0;\n    }\n\n  /* Tokenize the input pattern against incoming file name.\n   */\n  while (match && *cp1 && *cp2)\n    {\n      switch (*cp2)\n\t{\n\tcase '\\\\':\n\t  if (*++cp2 != *cp1)\n\t    {\n\t      match = 0;\n\t    }\n\t  break;\n\tcase '$':\n\t  if (*(cp2 + 1) >= '1' && (*cp2 + 1) <= '9')\n\t    {\n\t      if (*cp1 != *(++cp2 + 1))\t/* Break at delimiter.  */\n\t\t{\n\t\t  toks[toknum = *cp2 - '1']++;\n\t\t  tp[toknum] = cp1;\n\t\t  while (*++cp1 && *(cp2 + 1) != *cp1)\n\t\t    ;\n\t\t  te[toknum] = cp1;\n\t\t}\n\t      cp2++;\n\t      break;\n\t    }\n\t  /* Fall through, as '$' must be used verbatim.  */\n\tdefault:\n\t  if (*cp2 != *cp1)\n\t    {\n\t      match = 0;\n\t    }\n\t  break;\n\t}\n      if (match && *cp1)\n\t{\n\t  cp1++;\n\t}\n      if (match && *cp2)\n\t{\n\t  cp2++;\n\t}\n    }\n  if (!match && *cp1)\t\t/* last token mismatch */\n    {\n      toks[toknum] = 0;\n    }\n\n  /* Back substitute tokens into output template\n   * string `mapout'.  All fixed characters were\n   * already accounted for in presetting BUF_LEN.\n   */\n  cp1 = buf;\n  *cp1 = '\\0';\n  cp2 = mapout;\n  while (*cp2)\n    {\n      match = 0;\n      switch (*cp2)\n\t{\n\tcase '\\\\':\n\t  if (*(cp2 + 1))\n\t    {\n\t      *cp1++ = *++cp2;\n\t    }\n\t  break;\n\tcase '[':\n\tLOOP:\n\t  if (*++cp2 == '$' && isdigit (*(cp2 + 1)))\n\t    {\n\t      if (cp_subst (&cp2, &cp1, toks, tp, te, name, &buf, &buf_len))\n\t\tmatch = 1;\n\t    }\n\t  else\n\t    {\n\t      while (*cp2 && *cp2 != ',' && *cp2 != ']')\n\t\t{\n\t\t  if (*cp2 == '\\\\')\n\t\t    {\n\t\t      cp2++;\n\t\t    }\n\t\t  else if (*cp2 == '$' && isdigit (*(cp2 + 1)))\n                    {\n                      if (cp_subst (&cp2,\n                                    &cp1, toks, tp, te, name, &buf, &buf_len))\n                        match = 1;\n                    }\n                  else if (*cp2)\n\t\t    *cp1++ = *cp2++;\n\t\t}\n\t      if (!*cp2)\n\t\t{\n\t\t  printf (\"nmap: unbalanced brackets\\n\");\n\t\t  return (name);\n\t\t}\n\t      match = 1;\n\t      cp2--;\n\t    }\n\t  if (match)\n\t    {\n\t      /* Skip over all alternate text.  */\n\t      while (*++cp2 && *cp2 != ']')\n\t\t{\n\t\t  if (*cp2 == '\\\\' && *(cp2 + 1))\n\t\t    {\n\t\t      cp2++;\n\t\t    }\n\t\t}\n\t      if (!*cp2)\n\t\t{\n\t\t  printf (\"nmap: unbalanced brackets\\n\");\n\t\t  return (name);\n\t\t}\n\t      break;\n\t    }\n\t  switch (*++cp2)\n\t    {\n\t    case ',':\n\t      goto LOOP;\n\t    case ']':\n\t      break;\n\t    default:\n\t      cp2--;\n\t      goto LOOP;\n\t    }\n\t  break;\n\tcase '$':\n\t  if (isdigit (*(cp2 + 1)))\n\t    {\n\t      if (cp_subst (&cp2, &cp1, toks, tp, te, name, &buf, &buf_len))\n\t\tmatch = 1;\n\t      break;\n\t    }\n\t  /* intentional fall through */\n\tdefault:\n\t  *cp1++ = *cp2;\n\t  break;\n\t}\n      cp2++;\n    }\n  *cp1 = '\\0';\n\n  if (!*buf)\n    strcpy (buf, name);\n\n  return buf;\n}",
      "lines": 166,
      "depth": 22,
      "decorators": [
        "char",
        "*\ndomap (char *name)",
        "*"
      ]
    },
    "setsunique": {
      "start_point": [
        2517,
        0
      ],
      "end_point": [
        2524,
        1
      ],
      "content": "void\nsetsunique (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  sunique = !sunique;\n  printf (\"Store unique %s.\\n\", onoff (sunique));\n  code = sunique;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setrunique": {
      "start_point": [
        2526,
        0
      ],
      "end_point": [
        2533,
        1
      ],
      "content": "void\nsetrunique (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  runique = !runique;\n  printf (\"Receive unique %s.\\n\", onoff (runique));\n  code = runique;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "cdup": {
      "start_point": [
        2536,
        0
      ],
      "end_point": [
        2546,
        1
      ],
      "content": "void\ncdup (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  if (command (\"CDUP\") == ERROR && code == 500)\n    {\n      if (verbose)\n\tprintf (\"CDUP command not recognized, trying XCUP\\n\");\n      command (\"XCUP\");\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "restart": {
      "start_point": [
        2549,
        0
      ],
      "end_point": [
        2561,
        1
      ],
      "content": "void\nrestart (int argc, char **argv)\n{\n\n  if (argc != 2)\n    printf (\"restart: offset not specified\\n\");\n  else\n    {\n      restart_point = atoll (argv[1]);\n      printf (\"restarting at %jd. %s\\n\", (intmax_t) restart_point,\n\t      \"execute get, put or append to initiate transfer\");\n    }\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "syst": {
      "start_point": [
        2564,
        0
      ],
      "end_point": [
        2569,
        1
      ],
      "content": "void\nsyst (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n\n  command (\"SYST\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "macdef": {
      "start_point": [
        2571,
        0
      ],
      "end_point": [
        2641,
        1
      ],
      "content": "void\nmacdef (int argc, char **argv)\n{\n  char *tmp;\n  int c;\n\n  if (macnum == 16)\n    {\n      printf (\"Limit of 16 macros have already been defined\\n\");\n      code = -1;\n      return;\n    }\n  if (argc < 2 && !another (&argc, &argv, \"macro name\"))\n    {\n      printf (\"Usage: %s macro_name\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  if (interactive)\n    {\n      printf (\"Enter macro line by line, terminating it with a null line\\n\");\n    }\n  strncpy (macros[macnum].mac_name, argv[1],\n\t   sizeof (macros[macnum].mac_name) - 1);\n  if (macnum == 0)\n    {\n      macros[macnum].mac_start = macbuf;\n    }\n  else\n    {\n      macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;\n    }\n  tmp = macros[macnum].mac_start;\n  while (tmp < macbuf + sizeof (macbuf))\n    {\n      if ((c = getchar ()) == EOF)\n\t{\n\t  printf (\"macdef:end of file encountered\\n\");\n\t  code = -1;\n\t  return;\n\t}\n      if ((*tmp = c) == '\\n')\n\t{\n\t  if (tmp == macros[macnum].mac_start)\n\t    {\n\t      macros[macnum++].mac_end = tmp;\n\t      code = 0;\n\t      return;\n\t    }\n\t  if (*(tmp - 1) == '\\0')\n\t    {\n\t      macros[macnum++].mac_end = tmp - 1;\n\t      code = 0;\n\t      return;\n\t    }\n\t  *tmp = '\\0';\n\t}\n      tmp++;\n    }\n  while (1)\n    {\n      while ((c = getchar ()) != '\\n' && c != EOF)\n\t/* LOOP */ ;\n      if (c == EOF || getchar () == '\\n')\n\t{\n\t  printf (\"Macro not defined - 4k buffer exceeded\\n\");\n\t  code = -1;\n\t  return;\n\t}\n    }\n}",
      "lines": 71,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sizecmd": {
      "start_point": [
        2646,
        0
      ],
      "end_point": [
        2657,
        1
      ],
      "content": "void\nsizecmd (int argc, char **argv)\n{\n\n  if (argc < 2 && !another (&argc, &argv, \"filename\"))\n    {\n      printf (\"usage: %s filename\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  command (\"SIZE %s\", argv[1]);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "modtime": {
      "start_point": [
        2662,
        0
      ],
      "end_point": [
        2688,
        1
      ],
      "content": "void\nmodtime (int argc, char **argv)\n{\n  int overbose;\n\n  if (argc < 2 && !another (&argc, &argv, \"filename\"))\n    {\n      printf (\"usage: %s filename\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  overbose = verbose;\n  if (debug == 0)\n    verbose = -1;\n  if (command (\"MDTM %s\", argv[1]) == COMPLETE)\n    {\n      int yy, mo, day, hour, min, sec;\n      sscanf (reply_string, \"%*s %04d%02d%02d%02d%02d%02d\", &yy, &mo,\n\t      &day, &hour, &min, &sec);\n      /* might want to print this in local time */\n      printf (\"%s\\t%02d/%02d/%04d %02d:%02d:%02d GMT\\n\", argv[1],\n\t      mo, day, yy, hour, min, sec);\n    }\n  else\n    printf (\"%s\\n\", reply_string);\n  verbose = overbose;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rmtstatus": {
      "start_point": [
        2693,
        0
      ],
      "end_point": [
        2698,
        1
      ],
      "content": "void\nrmtstatus (int argc, char **argv)\n{\n\n  command (argc > 1 ? \"STAT %s\" : \"STAT\", argv[1]);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "newer": {
      "start_point": [
        2703,
        0
      ],
      "end_point": [
        2710,
        1
      ],
      "content": "void\nnewer (int argc, char **argv)\n{\n\n  if (getit (argc, argv, -1, \"w\"))\n    printf (\"Local file \\\"%s\\\" is newer than remote file \\\"%s\\\"\\n\",\n\t    argv[2], argv[1]);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftp/cmdtab.c": {
    "getcmd": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "struct cmd *\ngetcmd (char *name)\n{\n  char *p, *q;\n  struct cmd *c, *found;\n  int nmatches, longest;\n\n  longest = 0;\n  nmatches = 0;\n  found = 0;\n  for (c = cmdtab; (p = c->c_name); c++)\n    {\n      for (q = name; *q == *p++; q++)\n\tif (*q == 0)\t\t/* exact match? */\n\t  return c;\n      if (!*q)\n\t{\t\t\t/* the name was a prefix */\n\t  if (q - name > longest)\n\t    {\n\t      longest = q - name;\n\t      nmatches = 1;\n\t      found = c;\n\t    }\n\t  else if (q - name == longest)\n\t    nmatches++;\n\t}\n    }\n  if (nmatches > 1)\n    return (struct cmd *) -1;\n  return found;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "struct cmd",
        "struct",
        "cmd",
        "*\ngetcmd (char *name)",
        "*"
      ]
    },
    "help": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\nhelp (int argc, char *argv[])\n{\n  struct cmd *c;\n\n  if (argc == 1)\n    {\n      int i, j, w, k;\n      int columns, width = 0, lines;\n\n      printf (\"Commands may be abbreviated.  Commands are:\\n\\n\");\n      for (c = cmdtab; c < &cmdtab[NCMDS]; c++)\n\t{\n\t  int len = strlen (c->c_name);\n\n\t  if (len > width)\n\t    width = len;\n\t}\n      width = (width + 8) & ~7;\n      columns = 80 / width;\n      if (columns == 0)\n\tcolumns = 1;\n      lines = (NCMDS + columns - 1) / columns;\n      for (i = 0; i < lines; i++)\n\t{\n\t  for (j = 0; j < columns; j++)\n\t    {\n\t      c = cmdtab + j * lines + i;\n\t      if (c->c_name && (!proxy || c->c_proxy))\n\t\t{\n\t\t  printf (\"%s\", c->c_name);\n\t\t}\n\t      else if (c->c_name)\n\t\t{\n\t\t  for (k = 0; k < (int) strlen (c->c_name); k++)\n\t\t    putchar (' ');\n\t\t}\n\t      if (c + lines >= &cmdtab[NCMDS])\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  break;\n\t\t}\n\t      w = strlen (c->c_name);\n\t      while (w < width)\n\t\t{\n\t\t  w = (w + 8) & ~7;\n\t\t  putchar ('\\t');\n\t\t}\n\t    }\n\t}\n      return;\n    }\n\n  while (--argc > 0)\n    {\n      char *arg;\n      arg = *++argv;\n      c = getcmd (arg);\n      if (c == (struct cmd *) -1)\n\tprintf (\"?Ambiguous help command %s\\n\", arg);\n      else if (c == (struct cmd *) 0)\n\tprintf (\"?Invalid help command %s\\n\", arg);\n      else\n\tprintf (\"%-*s\\t%s\\n\", HELPINDENT, c->c_name, c->c_help);\n    }\n}",
      "lines": 66,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftp/domacro.c": {
    "lengthen": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\nlengthen (char **start, char **track, size_t *size, size_t add)\n{\n  char *new;\n  size_t offset = (size_t) (*track - *start);\n\n  if (*track < *start)\n    return EXIT_FAILURE;\t/* Sanity check.  */\n\n  if (offset + add < *size)\n    return EXIT_SUCCESS;\t/* Sufficient allocation.  */\n\n  new = realloc (*start, *size + add);\n  if (!new)\n    return EXIT_FAILURE;\t/* Parameters are unchanged here.  */\n\n  *start = new;\n  *size += add;\n  *track = *start + offset;\n\n  return EXIT_SUCCESS;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "domacro": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\ndomacro (int argc, char *argv[])\n{\n  int i, j, count = 2, loopflg = 0, allocflg = 0;\n  char *cp1, *cp2;\n  char *line2;\t\t/* Saved original of `line'.  */\n  size_t line2len;\t/* Its allocated length.  */\n  struct cmd *c;\n\n  if (argc < 2 && !another (&argc, &argv, \"macro name\"))\n    {\n      printf (\"Usage: %s macro_name.\\n\", argv[0]);\n      code = -1;\n      return;\n    }\n  for (i = 0; i < macnum; ++i)\n    {\n      if (!strncmp (argv[1], macros[i].mac_name,\n\t\t    sizeof (macros[i].mac_name)))\n\t{\n\t  break;\n\t}\n    }\n  if (i == macnum)\n    {\n      printf (\"'%s' macro not found.\\n\", argv[1]);\n      code = -1;\n      return;\n    }\n\n  line2 = line;\n  line2len = linelen;\n\n  /* Generate a replacement for `line' to be used during\n   * macro evaluation.  There might appear some intr(),\n   * so care must be taken before changing `line'.\n   * The original is available as LINE2.\n   *\n   * Initially allocate an amount sufficient for\n   * storing a copy of the original `line', which\n   * is repeatedly reused once for each text line\n   * of the stored macro definition.\n   */\n  cp2 = malloc (strlen (line2) + 2);\n  if (!cp2)\n    {\n      printf (\"System refused resources for macro '%s'.\\n\", argv[1]);\n      line = line2;\n      linelen = line2len;\n      code = -1;\n      return;\n    }\n\n  linelen = strlen (line2) + 2;\n  line = cp2;\n  *line = '\\0';\n\n  do\n    {\n      cp1 = macros[i].mac_start;\n      while (cp1 != macros[i].mac_end)\n\t{\n\t  /* Skip initial white space on each line of input.  */\n\t  while (isspace (*cp1))\n\t    {\n\t      cp1++;\n\t    }\n\t  /* Translate a line of text from macro definition\n\t   * and put it in `line'.  This global variable is\n\t   * referenced by some parsing functions, so the\n\t   * translation target cannot be changed easily.\n\t   */\n\t  cp2 = line;\n\t  while (*cp1 != '\\0')\n\t    {\n\t      /* Usually two characters suffice.\n\t       * This covers the default case below.\n\t       */\n\t      if (lengthen (&line, &cp2, &linelen, 2))\n\t\t{\n\t\t  allocflg = 1;\n\t\t  goto end_exec;\n\t\t}\n\t      switch (*cp1)\n\t\t{\n\t\tcase '\\\\':\t\t/* Escaping character.  */\n\t\t  *cp2++ = *++cp1;\n\t\t  break;\n\t\tcase '$':\t\t/* Substitution.  */\n\t\t  if (isdigit (*(cp1 + 1)))\n\t\t    {\n\t\t      /* Argument expansion.  */\n\t\t      j = 0;\n\t\t      while (isdigit (*++cp1))\n\t\t\tj = 10 * j + *cp1 - '0';\n\t\t      cp1--;\n\t\t      if (argc - 2 >= j)\n\t\t\t{\n\t\t\t  if (lengthen (&line, &cp2, &linelen,\n\t\t\t\t\tstrlen (argv[j + 1]) + 2))\n\t\t\t    {\n\t\t\t      allocflg = 1;\n\t\t\t      goto end_exec;\n\t\t\t    }\n\t\t\t  strcpy (cp2, argv[j + 1]);\n\t\t\t  cp2 += strlen (argv[j + 1]);\n\t\t\t}\n\t\t      break;\n\t\t    }\n\t\t  if (*(cp1 + 1) == 'i')\n\t\t    {\n\t\t      /* The loop counter \"$i\" was detected.  */\n\t\t      loopflg = 1;\n\t\t      cp1++;\t\t/* Back to last used char.  */\n\t\t      if (count < argc)\n\t\t\t{\n\t\t\t  if (lengthen (&line, &cp2, &linelen,\n\t\t\t\t\tstrlen (argv[count]) + 2))\n\t\t\t    {\n\t\t\t      allocflg = 1;\n\t\t\t      goto end_exec;\n\t\t\t    }\n\t\t\t  strcpy (cp2, argv[count]);\n\t\t\t  cp2 += strlen (argv[count]);\n\t\t\t}\n\t\t      break;\n\t\t    }\n\t\t  /* Intentional fall through, since no acceptable\n\t\t   * use of '$' was detected.  Present input is the\n\t\t   * dollar sign.\n\t\t   */\n\t\tdefault:\n\t\t  *cp2++ = *cp1;\t/* Copy present character.  */\n\t\t  break;\n\t\t}\n\t      /* Advance to next usable character.  */\n\t      if (*cp1 != '\\0')\n\t\tcp1++;\n\t    }\n\t  *cp2 = '\\0';\n\t  makeargv ();\n\t  if (margv[0] == NULL)\n\t    return;\n\t  c = getcmd (margv[0]);\n\n\t  if (c == (struct cmd *) -1)\n\t    {\n\t      printf (\"?Ambiguous command: '%s'.\\n\", margv[0]);\n\t      code = -1;\n\t      loopflg = 0;\n\t      break;\n\t    }\n\t  else if (c == 0)\n\t    {\n\t      printf (\"?Invalid command: '%s'.\\n\", margv[0]);\n\t      code = -1;\n\t      loopflg = 0;\n\t      break;\n\t    }\n\t  else if (c->c_conn && !connected)\n\t    {\n\t      printf (\"Not connected, needed for '%s'.\\n\", margv[0]);\n\t      code = -1;\n\t      loopflg = 0;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      if (verbose)\n\t\tprintf (\"%s\\n\", line);\n\t      (*c->c_handler) (margc, margv);\n\t      if (bell && c->c_bell)\n\t\tputchar ('\\007');\n\n\t      /* The arguments set at the time of invoking\n\t       * the macro must be recovered, to be used\n\t       * in parsing next line of macro definition.\n\t       */\n\t      strcpy (line, line2);\t/* Known to fit.  */\n\t      makeargv ();\t\t/* Get the arguments.  */\n\t      argc = margc;\n\t      argv = margv;\n\t    }\n\t  if (cp1 != macros[i].mac_end)\n\t    cp1++;\n\t}\n    }\n  while (loopflg && ++count < argc);\n\nend_exec:\n  if (allocflg)\n    {\n      printf (\"Memory allocation failed for macro '%s'.\\n\", argv[1]);\n      code = -1;\n    }\n  free (line);\n  line = line2;\n  linelen = line2len;\n}",
      "lines": 199,
      "depth": 25,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftp/extern.h": {},
  "inetutils/inetutils-1.9.4/ftp/ftp.c": {
    "hookup": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "char *\nhookup (char *host, int port)\n{\n  struct addrinfo hints, *ai = NULL, *res = NULL;\n  struct timeval timeout;\n  int status, again = 0;\n  int s, tos;\n  socklen_t len;\n  static char hostnamebuf[80];\n  char *rhost;\n\n#ifdef HAVE_IDN\n  status = idna_to_ascii_lz (host, &rhost, 0);\n  if (status)\n    {\n      error (0, 0, \"%s: %s\", host, idna_strerror (status));\n      code = -1;\n      return ((char *) 0);\n    }\n#else /* !HAVE_IDN */\n  rhost = strdup (host);\n#endif\n\n  snprintf (portstr, sizeof (portstr) - 1, \"%u\", port);\n  memset (&hisctladdr, 0, sizeof (hisctladdr));\n  memset (&hints, 0, sizeof (hints));\n\n  hints.ai_family = usefamily;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_CANONNAME;\n#ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n#endif\n#ifdef AI_CANONIDN\n  hints.ai_flags |= AI_CANONIDN;\n#endif\n\n  status = getaddrinfo (rhost, portstr, &hints, &res);\n  if (status)\n    {\n      error (0, 0, \"%s: %s\", rhost, gai_strerror (status));\n      code = -1;\n      free (rhost);\n      return ((char *) 0);\n    }\n\n  if (res->ai_canonname)\n    strncpy (hostnamebuf, res->ai_canonname, sizeof (hostnamebuf));\n  else\n    strncpy (hostnamebuf, rhost, sizeof (hostnamebuf));\n\n  hostname = hostnamebuf;\n  free (rhost);\n\n  for (ai = res; ai != NULL; ai = ai->ai_next, ++again)\n    {\n      if (again)\n        {\n\t  getnameinfo (ai->ai_addr, ai->ai_addrlen, ia, sizeof (ia),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n\t  error (0, 0, \"Trying %s ...\", ia);\n\t}\n\n      s = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (s < 0)\n\tcontinue;\n\n      timeout.tv_sec = FTP_CONNECT_TIMEOUT;\n      timeout.tv_usec = 0;\n      if (setsockopt (s, SOL_SOCKET, SO_SNDTIMEO, &timeout,\n\t\t\tsizeof (timeout)) < 0 && debug)\n\terror (0, errno, \"setsockopt (SO_SNDTIMEO)\");\n\n      if (connect (s, ai->ai_addr, ai->ai_addrlen) < 0)\n\t{\n\t  int oerrno = (errno != EINPROGRESS) ? errno : ETIMEDOUT;\n\n\t  getnameinfo (ai->ai_addr, ai->ai_addrlen, ia, sizeof (ia),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n\t  error (0, oerrno, \"connect to address %s\", ia);\n\t  close (s);\n\t  s = -1;\n\t  continue;\n\t}\n\n      /* A standing connection is found: register the address.  */\n      timeout.tv_sec = 0;\n      timeout.tv_usec = 0;\n      (void) setsockopt (s, SOL_SOCKET, SO_SNDTIMEO, &timeout,\n\t\t\t  sizeof (timeout));\n\n      ctladdrlen = ai->ai_addrlen;\n      memmove ((caddr_t) &hisctladdr, ai->ai_addr, ai->ai_addrlen);\n      break;\n    } /* for (ai = ai->ai_next) */\n\n  if (res)\n    freeaddrinfo (res);\n\n  if (ai == NULL)\n    {\n      error (0, 0, \"no response from host\");\n      code = -1;\n      goto bad;\n    }\n\n  len = sizeof (myctladdr);\n  if (getsockname (s, (struct sockaddr *) &myctladdr, &len) < 0)\n    {\n      error (0, errno, \"getsockname\");\n      code = -1;\n      goto bad;\n    }\n\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_LOWDELAY\n  tos = IPTOS_LOWDELAY;\n  if (myctladdr.ss_family == AF_INET &&\n\tsetsockopt (s, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof (int)) < 0)\n    error (0, errno, \"setsockopt TOS (ignored)\");\n#endif\n\n  cin = fdopen (s, \"r\");\n  /* dup(s) is for sake of stdio implementations who do not\n     allow two fdopen's on the same file-descriptor */\n  cout = fdopen (dup (s), \"w\");\n  if (cin == NULL || cout == NULL)\n    {\n      error (0, 0, \"fdopen failed.\");\n      if (cin)\n\tfclose (cin);\n      if (cout)\n\tfclose (cout);\n      code = -1;\n      goto bad;\n    }\n  if (verbose)\n    printf (\"Connected to %s.\\n\", hostname);\n  if (getreply (0) > 2)\n    {\t\t\t\t/* read startup message from server */\n      if (cin)\n\tfclose (cin);\n      if (cout)\n\tfclose (cout);\n      code = -1;\n      goto bad;\n    }\n\n#ifdef SO_OOBINLINE\n  {\n    int on = 1;\n\n    if (setsockopt (s, SOL_SOCKET, SO_OOBINLINE, (char *) &on, sizeof (on))\n\t< 0 && debug)\n      {\n\terror (0, errno, \"setsockopt\");\n      }\n  }\n#endif /* SO_OOBINLINE */\n\n  return (hostname);\nbad:\n  close (s);\n  return ((char *) 0);\n}",
      "lines": 164,
      "depth": 14,
      "decorators": [
        "char",
        "*\nhookup (char *host, int port)",
        "*"
      ]
    },
    "login": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "int\nlogin (char *host)\n{\n  char tmp[80];\n  char *user, *pass, *acct;\n  int n, aflag = 0;\n\n  user = pass = acct = 0;\n  if (remote_userpass (host, &user, &pass, &acct) < 0)\n    {\n      code = -1;\n      return (0);\n    }\n  while (user == NULL)\n    {\n      char *myname = getlogin ();\n\n      if (myname == NULL)\n\t{\n\t  struct passwd *pp = getpwuid (getuid ());\n\n\t  if (pp != NULL)\n\t    myname = pp->pw_name;\n\t}\n      if (myname)\n\tprintf (\"Name (%s:%s): \", host, myname);\n      else\n\tprintf (\"Name (%s): \", host);\n      if (fgets (tmp, sizeof (tmp) - 1, stdin))\n\t{\n\t  /* If the user presses return immediately, we get \"\\n\".\n\t   * In all other cases, the assignment is a no-op,\n\t   * and is always well defined thanks to fgets().\n\t   */\n\t  tmp[strlen (tmp) - 1] = '\\0';\n\t}\n      else\n\t*tmp = '\\0';\t\t/* Ctrl-D received.  */\n      if (*tmp == '\\0')\n\tuser = myname;\n      else\n\tuser = tmp;\n    }\n  n = command (\"USER %s\", user);\n  if (n == CONTINUE)\n    {\n      /* Is this a case of challenge-response?\n       * RFC 2228 stipulates code 336 for this.\n       * Suppress the message in verbose mode,\n       * since it has already been displayed.\n       */\n      if (code == 336 && !verbose)\n\tprintf (\"%s\\n\", reply_string + strlen (\"336 \"));\n      /* In addition, any password given on the\n       * command line is irrelevant, so ignore it.\n       */\n      if (pass == NULL || code == 336)\n\tpass = getpass (\"Password: \");\n      n = command (\"PASS %s\", pass);\n      if (pass)\n\tmemset (pass, 0, strlen (pass));\n    }\n  if (n == CONTINUE)\n    {\n      aflag++;\n      acct = getpass (\"Account: \");\n      n = command (\"ACCT %s\", acct);\n      if (acct)\n\tmemset (acct, 0, strlen (acct));\n    }\n  if (n != COMPLETE)\n    {\n      error (0, 0, \"Login failed.\");\n      return (0);\n    }\n  if (!aflag && acct != NULL)\n    {\n      command (\"ACCT %s\", acct);\n      memset (acct, 0, strlen (acct));\n    }\n  if (proxy)\n    return (1);\n  for (n = 0; n < macnum; ++n)\n    {\n      if (!strcmp (\"init\", macros[n].mac_name))\n\t{\n\t  free (line);\n\t  line = calloc (MAXLINE, sizeof (*line));\n\t  linelen = MAXLINE;\n\t  if (!line)\n\t    quit (0, 0);\n\n\t  /* Simulate input of the macro 'init'.  */\n\t  strcpy (line, \"$init\");\n\t  makeargv ();\n\t  domacro (margc, margv);\n\t  break;\n\t}\n    }\n  return (1);\n}",
      "lines": 101,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "cmdabort": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void\ncmdabort (int sig _GL_UNUSED_PARAMETER)\n{\n\n  printf (\"\\n\");\n  fflush (stdout);\n  abrtflag++;\n  if (ptflag)\n    longjmp (ptabort, 1);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "command": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "int\ncommand (const char *fmt, ...)\n{\n  va_list ap;\n  int r;\n  sighandler_t oldintr;\n\n  abrtflag = 0;\n  if (debug)\n    {\n      printf (\"---> \");\n      va_start (ap, fmt);\n      if (strncmp (\"PASS \", fmt, 5) == 0)\n\tprintf (\"PASS XXXX\");\n      else if (strncmp (\"ACCT \", fmt, 5) == 0)\n\tprintf (\"ACCT XXXX\");\n      else\n\tvfprintf (stdout, fmt, ap);\n      va_end (ap);\n      printf (\"\\n\");\n      fflush (stdout);\n    }\n  if (cout == NULL)\n    {\n      error (0, 0, \"No control connection for command\");\n      code = -1;\n      return (0);\n    }\n  oldintr = signal (SIGINT, cmdabort);\n  /* Under weird circumstances, we get a SIGPIPE from fflush().  */\n  signal (SIGPIPE, SIG_IGN);\n  va_start (ap, fmt);\n  vfprintf (cout, fmt, ap);\n  va_end (ap);\n  fprintf (cout, \"\\r\\n\");\n  fflush (cout);\n  cpend = 1;\n  r = getreply (!strcmp (fmt, \"QUIT\"));\n  if (abrtflag && oldintr != SIG_IGN)\n    (*oldintr) (SIGINT);\n  signal (SIGINT, oldintr);\n  signal (SIGPIPE, SIG_DFL);\n  return (r);\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "getreply": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "int\ngetreply (int expecteof)\n{\n  int c, n;\n  int dig;\n  int originalcode = 0, continuation = 0;\n  sighandler_t oldintr;\n  int pflag = 0;\n  char *cp, *pt = pasv;\n\n  oldintr = signal (SIGINT, cmdabort);\n  for (;;)\n    {\n      dig = n = code = 0;\n      cp = reply_string;\n      while ((c = getc (cin)) != '\\n')\n\t{\n\t  if (c == IAC)\n\t    {\t\t\t/* handle telnet commands */\n\t      switch (c = getc (cin))\n\t\t{\n\t\tcase WILL:\n\t\tcase WONT:\n\t\t  c = getc (cin);\n\t\t  fprintf (cout, \"%c%c%c\", IAC, DONT, c);\n\t\t  fflush (cout);\n\t\t  break;\n\t\tcase DO:\n\t\tcase DONT:\n\t\t  c = getc (cin);\n\t\t  fprintf (cout, \"%c%c%c\", IAC, WONT, c);\n\t\t  fflush (cout);\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t      continue;\n\t    }\n\t  dig++;\n\t  if (c == EOF)\n\t    {\n\t      if (expecteof)\n\t\t{\n\t\t  signal (SIGINT, oldintr);\n\t\t  code = 221;\n\t\t  return (0);\n\t\t}\n\t      lostpeer (0);\n\t      if (verbose)\n\t\t{\n\t\t  printf\n\t\t    (\"421 Service not available, remote server has closed connection\\n\");\n\t\t  fflush (stdout);\n\t\t}\n\t      code = 421;\n\t      return (TRANSIENT);\n\t    }\n\t  if (c != '\\r' && (verbose > 0 ||\n\t\t\t    (verbose > -1 && n == ERROR && dig > 4)))\n\t    {\n\t      if (proxflag && (dig == 1 || (dig == 5 && verbose == 0)))\n\t\tprintf (\"%s:\", hostname);\n\t      putchar (c);\n\t    }\n\t  if (dig < 4 && isdigit (c))\n\t    code = code * 10 + (c - '0');\n\t  if (!pflag && (code == 227 || code == 228 || code == 229)) /* PASV || LPSV || EPSV */\n\t    pflag = 1;\n\t  if (dig > 4 && pflag == 1 && isdigit (c))\n\t    pflag = 2;\n\t  if (pflag == 2)\n\t    {\n\t      if (c != '\\r' && c != ')')\n\t\t*pt++ = c;\n\t      else\n\t\t{\n\t\t  *pt = '\\0';\n\t\t  pflag = 3;\n\t\t}\n\t    }\n\t  if (dig == 4 && c == '-')\n\t    {\n\t      if (continuation)\n\t\tcode = 0;\n\t      continuation++;\n\t    }\n\t  if (n == 0)\n\t    n = c - '0';\t/* Extract ARPA's reply code.  */\n\t  if (cp < &reply_string[sizeof (reply_string) - 1])\n\t    *cp++ = c;\n\t}\n      if (verbose > 0 || (verbose > -1 && n == ERROR))\n\t{\n\t  putchar (c);\n\t  fflush (stdout);\n\t}\n      if (continuation && code != originalcode)\n\t{\n\t  if (originalcode == 0)\n\t    originalcode = code;\n\t  continue;\n\t}\n      *cp = '\\0';\n      if (n != PRELIM)\n\tcpend = 0;\n      signal (SIGINT, oldintr);\n      if (code == 421 || originalcode == 421)\n\tlostpeer (0);\n      if (abrtflag && oldintr != cmdabort && oldintr != SIG_IGN)\n\t(*oldintr) (SIGINT);\n      return n;\n    }\n}",
      "lines": 113,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "empty": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "int\nempty (fd_set *mask, int sec)\n{\n  struct timeval t;\n\n  t.tv_sec = (long) sec;\n  t.tv_usec = 0;\n  return (select (32, mask, (fd_set *) 0, (fd_set *) 0, &t));\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "abortsend": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        586,
        1
      ],
      "content": "void\nabortsend (int sig _GL_UNUSED_PARAMETER)\n{\n\n  mflag = 0;\n  abrtflag = 0;\n  printf (\"\\nsend aborted\\nwaiting for remote to finish abort\\n\");\n  fflush (stdout);\n  longjmp (sendabort, 1);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sendrequest": {
      "start_point": [
        588,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "void\nsendrequest (char *cmd, char *local, char *remote, int printnames)\n{\n  struct stat st;\n  struct timeval start, stop;\n  int c, d;\n  FILE *fin, *dout = 0, *popen (const char *, const char *);\n  int (*closefunc) (FILE *);\n  sighandler_t oldintr, oldintp;\n  long long bytes = 0, local_hashbytes = hashbytes;\n  char *lmode, *bufp;\n  int blksize = BUFSIZ;\n  static int bufsize = 0;\n  static char *buf;\n\n  if (verbose && printnames)\n    {\n      if (local && *local != '-')\n\tprintf (\"local: %s \", local);\n      if (remote)\n\tprintf (\"remote: %s\\n\", remote);\n    }\n  if (proxy)\n    {\n      proxtrans (cmd, local, remote);\n      return;\n    }\n  if (curtype != type)\n    changetype (type, 0);\n  closefunc = NULL;\n  oldintr = NULL;\n  oldintp = NULL;\n  lmode = \"w\";\n  if (setjmp (sendabort))\n    {\n      while (cpend)\n\t{\n\t  getreply (0);\n\t}\n      if (data >= 0)\n\t{\n\t  close (data);\n\t  data = -1;\n\t}\n      if (oldintr)\n\tsignal (SIGINT, oldintr);\n      if (oldintp)\n\tsignal (SIGPIPE, oldintp);\n      code = -1;\n      return;\n    }\n  oldintr = signal (SIGINT, abortsend);\n  if (strcmp (local, \"-\") == 0)\n    fin = stdin;\n  else if (*local == '|')\n    {\n      oldintp = signal (SIGPIPE, SIG_IGN);\n      fin = popen (local + 1, \"r\");\n      if (fin == NULL)\n\t{\n\t  error (0, errno, \"%s\", local + 1);\n\t  signal (SIGINT, oldintr);\n\t  signal (SIGPIPE, oldintp);\n\t  code = -1;\n\t  return;\n\t}\n      closefunc = pclose;\n    }\n  else\n    {\n      fin = fopen (local, \"r\");\n      if (fin == NULL)\n\t{\n\t  error (0, errno, \"local: %s\", local);\n\t  signal (SIGINT, oldintr);\n\t  code = -1;\n\t  return;\n\t}\n      closefunc = fclose;\n      if (fstat (fileno (fin), &st) < 0 || (st.st_mode & S_IFMT) != S_IFREG)\n\t{\n\t  fprintf (stdout, \"%s: not a plain file.\\n\", local);\n\t  signal (SIGINT, oldintr);\n\t  fclose (fin);\n\t  code = -1;\n\t  return;\n\t}\n\tblksize = st.st_blksize;\n    }\n  if (initconn ())\n    {\n      signal (SIGINT, oldintr);\n      if (oldintp)\n\tsignal (SIGPIPE, oldintp);\n      code = -1;\n      if (closefunc != NULL)\n\t(*closefunc) (fin);\n      return;\n    }\n  if (setjmp (sendabort))\n    goto abort;\n\n  if (restart_point &&\n      (strcmp (cmd, \"STOR\") == 0 || strcmp (cmd, \"APPE\") == 0))\n    {\n      off_t rc;\n\n      switch (curtype)\n\t{\n\tcase TYPE_A:\n\t  rc = fseeko (fin, restart_point, SEEK_SET);\n\t  break;\n\tcase TYPE_I:\n\tcase TYPE_L:\n\t  rc = lseek (fileno (fin), restart_point, SEEK_SET);\n\t  break;\n\t}\n      if (rc < 0)\n\t{\n\t  (void) command (\"ABOR\");\n\t  getreply (0);\n\t  error (0, errno, \"local: %s\", local);\n\t  restart_point = 0;\n\t  if (closefunc != NULL)\n\t    (*closefunc) (fin);\n\t  return;\n\t}\n      if (command (\"REST %jd\", (intmax_t) restart_point) != CONTINUE)\n\t{\n\t  restart_point = 0;\n\t  if (closefunc != NULL)\n\t    (*closefunc) (fin);\n\t  return;\n\t}\n      restart_point = 0;\n      lmode = \"r+w\";\n    }\n  if (remote)\n    {\n      if (command (\"%s %s\", cmd, remote) != PRELIM)\n\t{\n\t  signal (SIGINT, oldintr);\n\t  if (oldintp)\n\t    signal (SIGPIPE, oldintp);\n\t  if (closefunc != NULL)\n\t    (*closefunc) (fin);\n\t  return;\n\t}\n    }\n  else if (command (\"%s\", cmd) != PRELIM)\n    {\n      signal (SIGINT, oldintr);\n      if (oldintp)\n\tsignal (SIGPIPE, oldintp);\n      if (closefunc != NULL)\n\t(*closefunc) (fin);\n      return;\n    }\n  dout = dataconn (lmode);\n  if (dout == NULL)\n    goto abort;\n\n  if (blksize > bufsize)\n    {\n      free (buf);\n      buf = malloc ((unsigned) blksize);\n      if (buf == NULL)\n\t{\n\t  error (0, errno, \"malloc\");\n\t  bufsize = 0;\n\t  goto abort;\n\t}\n      bufsize = blksize;\n    }\n\n  gettimeofday (&start, (struct timezone *) 0);\n  oldintp = signal (SIGPIPE, SIG_IGN);\n  switch (curtype)\n    {\n\n    case TYPE_I:\n    case TYPE_L:\n      errno = d = 0;\n      while ((c = read (fileno (fin), buf, bufsize)) > 0)\n\t{\n\t  bytes += c;\n\t  for (bufp = buf; c > 0; c -= d, bufp += d)\n\t    if ((d = write (fileno (dout), bufp, c)) <= 0)\n\t      break;\n\t  if (hash)\n\t    {\n\t      while (bytes >= local_hashbytes)\n\t\t{\n\t\t  putchar ('#');\n\t\t  local_hashbytes += hashbytes;\n\t\t}\n\t      fflush (stdout);\n\t    }\n\t}\n      if (hash && bytes > 0)\n\t{\n\t  if (bytes < local_hashbytes)\n\t    putchar ('#');\n\t  putchar ('\\n');\n\t  fflush (stdout);\n\t}\n      if (c < 0)\n\terror (0, errno, \"local: %s\", local);\n      if (d < 0)\n\t{\n\t  if (errno != EPIPE)\n\t    error (0, errno, \"netout\");\n\t  bytes = -1;\n\t}\n      break;\n\n    case TYPE_A:\n      while ((c = getc (fin)) != EOF)\n\t{\n\t  if (c == '\\n')\n\t    {\n\t      while (hash && (bytes >= local_hashbytes))\n\t\t{\n\t\t  putchar ('#');\n\t\t  fflush (stdout);\n\t\t  local_hashbytes += hashbytes;\n\t\t}\n\t      if (ferror (dout))\n\t\tbreak;\n\t      putc ('\\r', dout);\n\t      bytes++;\n\t    }\n\t  putc (c, dout);\n\t  bytes++;\n\t  /*              if (c == '\\r') {                                */\n\t  /*                      putc('\\0', dout);  // this violates rfc */\n\t  /*                      bytes++;                                */\n\t  /*              }                                               */\n\t}\n      if (hash)\n\t{\n\t  if (bytes < local_hashbytes)\n\t    putchar ('#');\n\t  putchar ('\\n');\n\t  fflush (stdout);\n\t}\n      if (ferror (fin))\n\terror (0, errno, \"local: %s\", local);\n      if (ferror (dout))\n\t{\n\t  if (errno != EPIPE)\n\t    error (0, errno, \"netout\");\n\t  bytes = -1;\n\t}\n      break;\n    }\n  if (closefunc != NULL)\n    (*closefunc) (fin);\n  fclose (dout);\n  gettimeofday (&stop, (struct timezone *) 0);\n  getreply (0);\n  signal (SIGINT, oldintr);\n  if (oldintp)\n    signal (SIGPIPE, oldintp);\n  if (bytes > 0)\n    ptransfer (\"sent\", bytes, &start, &stop);\n  return;\nabort:\n  signal (SIGINT, oldintr);\n  if (oldintp)\n    signal (SIGPIPE, oldintp);\n  if (!cpend)\n    {\n      code = -1;\n      return;\n    }\n  if (data >= 0)\n    {\n      close (data);\n      data = -1;\n    }\n  if (dout)\n    fclose (dout);\n  getreply (0);\n  code = -1;\n  if (closefunc != NULL && fin != NULL)\n    (*closefunc) (fin);\n  gettimeofday (&stop, (struct timezone *) 0);\n  if (bytes > 0)\n    ptransfer (\"sent\", bytes, &start, &stop);\n}",
      "lines": 291,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "abortrecv": {
      "start_point": [
        882,
        0
      ],
      "end_point": [
        891,
        1
      ],
      "content": "void\nabortrecv (int sig _GL_UNUSED_PARAMETER)\n{\n\n  mflag = 0;\n  abrtflag = 0;\n  printf (\"\\nreceive aborted\\nwaiting for remote to finish abort\\n\");\n  fflush (stdout);\n  longjmp (recvabort, 1);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "recvrequest": {
      "start_point": [
        893,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "void\nrecvrequest (char *cmd, char *local, char *remote, char *lmode, int printnames)\n{\n  FILE *fout, *din = 0;\n  int (*closefunc) (FILE *);\n  sighandler_t oldintr, oldintp;\n  int c, d, is_retr, tcrflag, bare_lfs = 0;\n  int blksize = BUFSIZ;\n  static int bufsize = 0;\n  static char *buf;\n  long long bytes = 0, local_hashbytes = hashbytes;\n  struct timeval start, stop;\n\n  is_retr = strcmp (cmd, \"RETR\") == 0;\n  if (is_retr && verbose && printnames)\n    {\n      if (local && *local != '-')\n\tprintf (\"local: %s \", local);\n      if (remote)\n\tprintf (\"remote: %s\\n\", remote);\n    }\n  if (proxy && is_retr)\n    {\n      proxtrans (cmd, local, remote);\n      return;\n    }\n  closefunc = NULL;\n  oldintr = NULL;\n  oldintp = NULL;\n  tcrflag = !crflag && is_retr;\n  if (setjmp (recvabort))\n    {\n      while (cpend)\n\t{\n\t  getreply (0);\n\t}\n      if (data >= 0)\n\t{\n\t  close (data);\n\t  data = -1;\n\t}\n      if (oldintr)\n\tsignal (SIGINT, oldintr);\n      code = -1;\n      return;\n    }\n  oldintr = signal (SIGINT, abortrecv);\n  if (strcmp (local, \"-\") && *local != '|')\n    {\n      if (runique && (local = gunique (local)) == NULL)\n\t{\n\t  signal (SIGINT, oldintr);\n\t  code = -1;\n\t  return;\n\t}\n    }\n  if (!is_retr)\n    {\n      if (curtype != TYPE_A)\n\tchangetype (TYPE_A, 0);\n    }\n  else if (curtype != type)\n    changetype (type, 0);\n  if (initconn ())\n    {\n      signal (SIGINT, oldintr);\n      code = -1;\n      return;\n    }\n  if (setjmp (recvabort))\n    goto abort;\n  if (is_retr && restart_point &&\n      command (\"REST %jd\", (intmax_t) restart_point) != CONTINUE)\n    return;\n  if (remote)\n    {\n      if (command (\"%s %s\", cmd, remote) != PRELIM)\n\t{\n\t  signal (SIGINT, oldintr);\n\t  return;\n\t}\n    }\n  else\n    {\n      if (command (\"%s\", cmd) != PRELIM)\n\t{\n\t  signal (SIGINT, oldintr);\n\t  return;\n\t}\n    }\n  din = dataconn (\"r\");\n  if (din == NULL)\n    goto abort;\n\n  if (strcmp (local, \"-\") == 0)\n    fout = stdout;\n  else if (*local == '|')\n    {\n      oldintp = signal (SIGPIPE, SIG_IGN);\n      fout = popen (local + 1, \"w\");\n      if (fout == NULL)\n\t{\n\t  error (0, errno, \"%s\", local + 1);\n\t  goto abort;\n\t}\n      closefunc = pclose;\n    }\n  else\n    {\n      struct stat st;\n\n      fout = fopen (local, lmode);\n      if (fout == NULL || fstat (fileno (fout), &st) < 0)\n\t{\n\t  error (0, errno, \"local: %s\", local);\n\t  goto abort;\n\t}\n      closefunc = fclose;\n      blksize = st.st_blksize;\n    }\n\n  if (blksize > bufsize)\n    {\n      free (buf);\n      buf = malloc ((unsigned) blksize);\n      if (buf == NULL)\n\t{\n\t  error (0, errno, \"malloc\");\n\t  bufsize = 0;\n\t  goto abort;\n\t}\n      bufsize = blksize;\n    }\n\n  gettimeofday (&start, (struct timezone *) 0);\n  switch (curtype)\n    {\n\n    case TYPE_I:\n    case TYPE_L:\n      if (restart_point && lseek (fileno (fout), restart_point, SEEK_SET) < 0)\n\t{\n\t  error (0, errno, \"local: %s\", local);\n\t  if (closefunc != NULL)\n\t    (*closefunc) (fout);\n\t  return;\n\t}\n      errno = d = 0;\n      while ((c = read (fileno (din), buf, bufsize)) > 0)\n\t{\n\t  if ((d = write (fileno (fout), buf, c)) != c)\n\t    break;\n\t  bytes += c;\n\t  if (hash)\n\t    {\n\t      while (bytes >= local_hashbytes)\n\t\t{\n\t\t  putchar ('#');\n\t\t  local_hashbytes += hashbytes;\n\t\t}\n\t      fflush (stdout);\n\t    }\n\t}\n\n      if (hash && bytes > 0)\n\t{\n\t  if (bytes < local_hashbytes)\n\t    putchar ('#');\n\t  putchar ('\\n');\n\t  fflush (stdout);\n\t}\n      if (c < 0)\n\t{\n\t  if (errno != EPIPE)\n\t    error (0, errno, \"netin\");\n\t  bytes = -1;\n\t}\n      if (d < c)\n\t{\n\t  if (d < 0)\n\t    error (0, errno, \"local: %s\", local);\n\t  else\n\t    error (0, 0, \"%s: short write\", local);\n\t}\n      break;\n\n    case TYPE_A:\n      if (restart_point)\n\t{\n\t  off_t i, n;\n\t  int ch;\n\n\t  errno = 0;\n\n\t  if (fseeko (fout, 0L, SEEK_SET) < 0)\n\t    goto done;\n\t  n = restart_point;\n\t  for (i = 0; i++ < n;)\n\t    {\n\t      if ((ch = getc (fout)) == EOF)\n\t\tgoto done;\n\t      if (ch == '\\n')\n\t\ti++;\n\t    }\n\t  if (fseeko (fout, 0L, SEEK_CUR) < 0)\n\t    {\n\t    done:\n\t      /* Cancel server's action quickly.  */\n\t      (void) command (\"ABOR\");\n\t      getreply (0);\n\n\t      /* Explain our failure.  */\n\t      if (ch == EOF)\n\t\tprintf (\"Action not taken: offset %jd is outside of %s.\\n\",\n\t\t       restart_point, local);\n\t      else\n\t\terror (0, errno, \"local: %s\", local);\n\n\t      if (closefunc != NULL)\n\t\t(*closefunc) (fout);\n\t      return;\n\t    }\n\t}\n      while ((c = getc (din)) != EOF)\n\t{\n\t  if (c == '\\n')\n\t    bare_lfs++;\n\t  while (c == '\\r')\n\t    {\n\t      while (hash && (bytes >= local_hashbytes))\n\t\t{\n\t\t  putchar ('#');\n\t\t  fflush (stdout);\n\t\t  local_hashbytes += hashbytes;\n\t\t}\n\t      bytes++;\n\t      if ((c = getc (din)) != '\\n' || tcrflag)\n\t\t{\n\t\t  if (ferror (fout))\n\t\t    goto break2;\n\t\t  putc ('\\r', fout);\n\t\t  if (c == '\\0')\n\t\t    {\n\t\t      bytes++;\n\t\t      goto contin2;\n\t\t    }\n\t\t  if (c == EOF)\n\t\t    goto contin2;\n\t\t}\n\t    }\n\t  putc (c, fout);\n\t  bytes++;\n\tcontin2:;\n\t}\n    break2:\n      if (bare_lfs)\n\t{\n\t  printf (\"WARNING! %d bare linefeeds received in ASCII mode\\n\",\n\t\t  bare_lfs);\n\t  printf (\"File may not have transferred correctly.\\n\");\n\t}\n      if (hash)\n\t{\n\t  if (bytes < local_hashbytes)\n\t    putchar ('#');\n\t  putchar ('\\n');\n\t  fflush (stdout);\n\t}\n      if (ferror (din))\n\t{\n\t  if (errno != EPIPE)\n\t    error (0, errno, \"netin\");\n\t  bytes = -1;\n\t}\n      if (ferror (fout))\n\terror (0, errno, \"local: %s\", local);\n      break;\n    }\n  if (closefunc != NULL)\n    (*closefunc) (fout);\n  signal (SIGINT, oldintr);\n  if (oldintp)\n    signal (SIGPIPE, oldintp);\n  fclose (din);\n  gettimeofday (&stop, (struct timezone *) 0);\n  getreply (0);\n  if (bytes > 0 && is_retr)\n    ptransfer (\"received\", bytes, &start, &stop);\n  return;\nabort:\n\n/* abort using RFC959 recommended IP,SYNC sequence  */\n\n  if (oldintp)\n    signal (SIGPIPE, oldintr);\n  signal (SIGINT, SIG_IGN);\n  if (!cpend)\n    {\n      code = -1;\n      signal (SIGINT, oldintr);\n      return;\n    }\n\n  abort_remote (din);\n  code = -1;\n  if (data >= 0)\n    {\n      close (data);\n      data = -1;\n    }\n  if (closefunc != NULL && fout != NULL)\n    (*closefunc) (fout);\n  if (din)\n    fclose (din);\n  gettimeofday (&stop, (struct timezone *) 0);\n  if (bytes > 0)\n    ptransfer (\"received\", bytes, &start, &stop);\n  signal (SIGINT, oldintr);\n}",
      "lines": 319,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "initconn": {
      "start_point": [
        1217,
        0
      ],
      "end_point": [
        1550,
        1
      ],
      "content": "int\ninitconn (void)\n{\n  char *p = NULL, *a = NULL;\n  int result, tmpno = 0;\n  int good_epsv = 0, good_lpsv = 0, j;\n  socklen_t len;\n  int on = 1;\n  uint32_t a0, a1, a2, a3, p0, p1, port;\n  uint32_t af, hal, h[16], pal; /* RFC 1639: LPSV resonse.  */\n  struct sockaddr_in *data_addr_sa4 = (struct sockaddr_in *) &data_addr;\n  struct sockaddr_in6 *data_addr_sa6 = (struct sockaddr_in6 *) &data_addr;\n\n  if (passivemode)\n    {\n      data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n      if (data < 0)\n\t{\n\t  perror (\"ftp: socket\");\n\t  return (1);\n\t}\n      if ((options & SO_DEBUG) &&\n\t  setsockopt (data, SOL_SOCKET, SO_DEBUG, (char *) &on,\n\t\t      sizeof (on)) < 0)\n\tif (errno != EACCES)\t/* Ignore insufficient permission.  */\n\t  error (0, errno, \"setsockopt DEBUG (ignored)\");\n\n      /* Be contemporary:\n       *   first try EPSV,\n       *   then fall back to PASV/LPSV.\n       */\n      switch (myctladdr.ss_family)\n        {\n\t  case AF_INET:\n\t    if (doepsv4 && command (\"EPSV\") == COMPLETE)\n\t      {\n\t        good_epsv = 1;\n\t        break;\n\t      }\n\t    if (doepsv4)\n\t      {\n\t\t/* When arriving here, EPSV failed. Prevent new attempts.  */\n\t\tdoepsv4 = 0;\n\t      }\n\t    if (command (\"PASV\") == COMPLETE)\n\t\tbreak;\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t  case AF_INET6:\n\t    if (command (\"EPSV\") == COMPLETE)\n\t      {\n\t\tgood_epsv = 1;\n\t\tbreak;\n\t      }\n\t    if (command (\"LPSV\") == COMPLETE)\n\t      {\n\t\tgood_lpsv = 1;\n\t\tbreak;\n\t      }\n\t    printf (\"Passive mode refused.\\n\");\n\t    goto bad;\n\t    break;\n\t}\n\n      if (good_epsv)\n\t{\n\t  /* EPSV: IPv4 or IPv6\n\t   *\n\t   * Expected response (perl): pasv =~ '%u|'\n\t   * This communicates a port number.\n\t   */\n\t  if (sscanf (pasv, \"%u|\", &port) != 1)\n\t    {\n\t      printf (\"Extended passive mode scan failure. \"\n\t\t\t\"Should not happen!\\n\");\n\t      (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t      goto bad;\n\t    }\n\t  data_addr = hisctladdr;\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\tdata_addr_sa4->sin_port = htons (port);\n\t\tbreak;\n\t      case AF_INET6:\n\t\tdata_addr_sa6->sin6_port = htons (port);\n\t\tbreak;\n\t    }\n\t} /* EPSV */\n      else if (good_lpsv)\n\t{\n\t  /* LPSV: IPv4 or IPv6\n\t   *\n\t   * At this point we have got a string of comma\n\t   * separated, one-byte unsigned integer values.\n\t   * Length and interpretation depends on address\n\t   * family.\n\t   */\n\n\t  if (myctladdr.ss_family == AF_INET)\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,\" /* hal, h[4] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &pal, &p0, &p1) != 9)\n\t\t  || (/* Strong checking */ af != 4 || hal != 4 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 4; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa4->sin_addr.s_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t}\n\t    } /* LPSV IPv4 */\n\t  else /* IPv6 */\n\t    {\n\t      if ((sscanf (pasv, \"%u,\" /* af */\n\t\t\t\t\"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* hal, h[16] */\n\t\t\t\t\"%u,%u,%u\", /* pal, p0, p1 */\n\t\t\t\t&af, &hal, &h[0], &h[1], &h[2], &h[3], &h[4], &h[5], &h[6], &h[7],\n\t\t\t\t&h[8], &h[9], &h[10], &h[11], &h[12], &h[13], &h[14], &h[15],\n\t\t\t\t&pal, &p0, &p1) != 21)\n\t\t  || (/* Strong checking */ af != 6 || hal != 16 || pal != 2) )\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      for (j = 0; j < 16; ++j)\n\t\th[j] &= 0xff; /* Mask only the significant bits.  */\n\n\t      data_addr.ss_family = AF_INET6;\n\t      data_addr_sa6->sin6_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\n\t\t{\n\t\t  uint32_t *pu32 = (uint32_t *) &data_addr_sa6->sin6_addr.s6_addr;\n\t\t  pu32[0] = htonl ( (h[0] << 24) | (h[1] << 16) | (h[2] << 8) | h[3]);\n\t\t  pu32[1] = htonl ( (h[4] << 24) | (h[5] << 16) | (h[6] << 8) | h[7]);\n\t\t  pu32[2] = htonl ( (h[8] << 24) | (h[9] << 16) | (h[10] << 8) | h[11]);\n\t\t  pu32[3] = htonl ( (h[12] << 24) | (h[13] << 16) | (h[14] << 8) | h[15]);\n\t\t}\n\t    } /* LPSV IPv6 */\n\t}\n      else /* !EPSV && !LPSV */\n\t{ /* PASV */\n\t  if (myctladdr.ss_family == AF_INET)\n\t    { /* PASV */\n\t      if (sscanf (pasv, \"%u,%u,%u,%u,%u,%u\",\n\t\t\t  &a0, &a1, &a2, &a3, &p0, &p1) != 6)\n\t\t{\n\t\t  printf (\"Passive mode address scan failure. \"\n\t\t\t  \"Shouldn't happen!\\n\");\n\t\t  (void) command (\"ABOR\");\t/* Cancel any open connection.  */\n\t\t  goto bad;\n\t\t}\n\t      data_addr.ss_family = AF_INET;\n\t      data_addr_sa4->sin_addr.s_addr =\n\t\t  htonl ( (a0 << 24) | ((a1 & 0xff) << 16)\n\t\t\t | ((a2 & 0xff) << 8) | (a3 & 0xff) );\n\t      data_addr_sa4->sin_port =\n\t\t  htons (((p0 & 0xff) << 8) | (p1 & 0xff));\n\t    } /* PASV */\n\t  else\n\t    {\n\t      /* Catch all impossible cases.  */\n\t      printf (\"Passive mode address scan failure. Shouldn't happen!\\n\");\n\t      goto bad;\n\t    }\n\t} /* PASV */\n\n      if (connect (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n\t{\n\t  perror (\"ftp: connect\");\n\t  goto bad;\n\t}\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n      on = IPTOS_THROUGHPUT;\n      if (data_addr.ss_family == AF_INET &&\n\t   setsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on,\n\t\t      sizeof (int)) < 0)\n\tperror (\"ftp: setsockopt TOS (ignored)\");\n#endif\n      return (0);\n    }\n\nnoport:\n  data_addr = myctladdr;\n  if (sendport)\n    /* Let the system pick a port.  */\n    switch (myctladdr.ss_family)\n      {\n\tcase AF_INET:\n\t  data_addr_sa4->sin_port = 0;\n\t  break;\n\tcase AF_INET6:\n\t  data_addr_sa6->sin6_port = 0;\n\t  break;\n      }\n\n  if (data != -1)\n    close (data);\n  data = socket (myctladdr.ss_family, SOCK_STREAM, 0);\n  if (data < 0)\n    {\n      error (0, errno, \"socket\");\n      if (tmpno)\n\tsendport = 1;\n      return (1);\n    }\n  if (!sendport)\n    if (setsockopt (data, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof (on))\n\t< 0)\n      {\n\terror (0, errno, \"setsockopt (reuse address)\");\n\tgoto bad;\n      }\n  if (bind (data, (struct sockaddr *) &data_addr, ctladdrlen) < 0)\n    {\n      error (0, errno, \"bind\");\n      goto bad;\n    }\n  if (options & SO_DEBUG\n      && setsockopt (data, SOL_SOCKET, SO_DEBUG,\n\t\t     (char *) &on, sizeof (on)) < 0)\n    if (errno != EACCES)\t/* Ignore insufficient permission.  */\n      error (0, errno, \"setsockopt DEBUG (ignored)\");\n  len = sizeof (data_addr);\n  if (getsockname (data, (struct sockaddr *) &data_addr, &len) < 0)\n    {\n      error (0, errno, \"getsockname\");\n      goto bad;\n    }\n  if (listen (data, 1) < 0)\n    error (0, errno, \"listen\");\n  if (sendport)\n    {\n#define UC(b)\t(((int)b)&0xff)\n      /* Preferences:\n       *   IPv4: EPRT, PORT, LPRT\n       *   IPv6: EPRT, LPRT\n       */\n      result = ERROR;\t/* For success detection.  */\n      if (data_addr.ss_family != AF_INET || doepsv4)\n\t{\n\t  /* Use EPRT mode.  */\n\t  getnameinfo ((struct sockaddr *) &data_addr, ctladdrlen,\n\t\t\tia, sizeof (ia), portstr, sizeof (portstr),\n\t\t\tNI_NUMERICHOST | NI_NUMERICSERV);\n\t  result = command (\"EPRT |%d|%s|%s|\",\n\t\t\t    (data_addr.ss_family == AF_INET) ? 1 : 2,\n\t\t\t    ia, portstr);\n\t}\n\n      if (data_addr.ss_family == AF_INET && doepsv4 && result != COMPLETE)\n\t/* Do not try EPRT with IPv4 again.  It fails for this host.  */\n\tdoepsv4 = 0;\n\n      if (data_addr.ss_family == AF_INET && result != COMPLETE)\n\t{\n\t  /* PORT for IPv4; possibly EPRT has failed.  */\n\t  a = (char *) &data_addr_sa4->sin_addr;\n\t  p = (char *) &data_addr_sa4->sin_port;\n\t  result = command (\"PORT %d,%d,%d,%d,%d,%d\",\n\t\t\t    UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t\t\t    UC (p[0]), UC (p[1]));\n\t}\n\n      if (result != COMPLETE)\n\t{\n\t  /* Fall back to LPRT.  */\n\t  uint8_t *h, *p;\n\n\t  switch (data_addr.ss_family)\n\t    {\n\t      case AF_INET:\n\t\th = (uint8_t *) &data_addr_sa4->sin_addr;\n\t\tp = (uint8_t *) &data_addr_sa4->sin_port;\n\t\tresult = command (\"LPRT 4,4,%u,%u,%u,%u,2,%u,%u\",\n\t\t\t\t  h[0], h[1], h[2], h[3], p[0], p[1]);\n\t\tbreak;\n\t      case AF_INET6:\n\t\th = (uint8_t *) &data_addr_sa6->sin6_addr;\n\t\tp = (uint8_t *) &data_addr_sa6->sin6_port;\n\t\tresult = command (\"LPRT 6,16,\" /* af, hal */\n\t\t\t\t  \"%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,\" /* h[16] */\n\t\t\t\t  \"2,%u,%u\", /* pal, p[2] */\n\t\t\t\t  h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7],\n\t\t\t\t  h[8], h[9], h[10], h[11], h[12], h[13], h[14], h[15],\n\t\t\t\t  p[0], p[1]);\n\t\tbreak;\n\t    }\n\t}\n\n      if (result == ERROR && sendport == -1)\n\t{\n\t  sendport = 0;\n\t  tmpno = 1;\n\t  goto noport;\n\t}\n      return (result != COMPLETE);\n    }\n  if (tmpno)\n    sendport = 1;\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  on = IPTOS_THROUGHPUT;\n  if (data_addr.ss_family == AF_INET &&\n\tsetsockopt (data, IPPROTO_IP, IP_TOS, (char *) &on, sizeof (int)) < 0)\n    error (0, errno, \"setsockopt TOS (ignored)\");\n#endif\n  return (0);\nbad:\n  close (data), data = -1;\n  if (tmpno)\n    sendport = 1;\n  return (1);\n}",
      "lines": 334,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "dataconn": {
      "start_point": [
        1552,
        0
      ],
      "end_point": [
        1578,
        1
      ],
      "content": "FILE *\ndataconn (char *lmode)\n{\n  struct sockaddr_storage from;\n  int s, tos;\n  socklen_t fromlen = sizeof (from);\n\n  if (passivemode)\n    return (fdopen (data, lmode));\n\n  s = accept (data, (struct sockaddr *) &from, &fromlen);\n  if (s < 0)\n    {\n      error (0, errno, \"accept\");\n      close (data), data = -1;\n      return (NULL);\n    }\n  close (data);\n  data = s;\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  tos = IPTOS_THROUGHPUT;\n  if (from.ss_family == AF_INET &&\n\tsetsockopt (s, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof (int)) < 0)\n    error (0, errno, \"setsockopt TOS (ignored)\");\n#endif\n  return (fdopen (data, lmode));\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "FILE",
        "*\ndataconn (char *lmode)",
        "*"
      ]
    },
    "ptransfer": {
      "start_point": [
        1580,
        0
      ],
      "end_point": [
        1603,
        1
      ],
      "content": "void\nptransfer (char *direction, long long int bytes,\n\t   struct timeval *t0, struct timeval *t1)\n{\n  struct timeval td;\n  float s, bs;\n\n  if (verbose)\n    {\n      tvsub (&td, t1, t0);\n      s = td.tv_sec + (td.tv_usec / 1000000.);\n#define nz(x)\t((x) == 0 ? 1 : (x))\n      bs = bytes / nz (s);\n\n      printf (\"%lld bytes %s in %.3g seconds\", bytes, direction, s);\n\n      if (bs > 1048576.0)\n\tprintf (\" (%.3g Mbytes/s)\\n\", bs / 1048576.0);\n      else if (bs > 1024.0)\n\tprintf (\" (%.3g kbytes/s)\\n\", bs / 1024.0);\n      else\n\tprintf (\" (%.3g bytes/s)\\n\", bs);\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tvsub": {
      "start_point": [
        1618,
        0
      ],
      "end_point": [
        1626,
        1
      ],
      "content": "void\ntvsub (struct timeval *tdiff, struct timeval *t1, struct timeval *t0)\n{\n\n  tdiff->tv_sec = t1->tv_sec - t0->tv_sec;\n  tdiff->tv_usec = t1->tv_usec - t0->tv_usec;\n  if (tdiff->tv_usec < 0)\n    tdiff->tv_sec--, tdiff->tv_usec += 1000000;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "psabort": {
      "start_point": [
        1628,
        0
      ],
      "end_point": [
        1633,
        1
      ],
      "content": "void\npsabort (int sig _GL_UNUSED_PARAMETER)\n{\n\n  abrtflag++;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "pswitch": {
      "start_point": [
        1635,
        0
      ],
      "end_point": [
        1739,
        1
      ],
      "content": "void\npswitch (int flag)\n{\n  sighandler_t oldintr;\n  static struct comvars\n  {\n    int connect;\n    char *name;\n    struct sockaddr_storage mctl;\n    struct sockaddr_storage hctl;\n    FILE *in;\n    FILE *out;\n    int tpe;\n    int curtpe;\n    int cpnd;\n    int sunqe;\n    int runqe;\n    int mcse;\n    int ntflg;\n    char nti[sizeof (ntin)];\n    char nto[sizeof (ntout)];\n    int mapflg;\n    char *mi;\n    char *mo;\n  } proxstruct =\n  {\n  0}, tmpstruct =\n  {\n  0};\n  struct comvars *ip, *op;\n\n  abrtflag = 0;\n  oldintr = signal (SIGINT, psabort);\n  if (flag)\n    {\n      if (proxy)\n\treturn;\n      ip = &tmpstruct;\n      op = &proxstruct;\n      proxy++;\n    }\n  else\n    {\n      if (!proxy)\n\treturn;\n      ip = &proxstruct;\n      op = &tmpstruct;\n      proxy = 0;\n    }\n  ip->connect = connected;\n  connected = op->connect;\n\n  free (ip->name);\n  ip->name = hostname;\n  hostname = op->name;\n  op->name = 0;\n\n  ip->hctl = hisctladdr;\n  hisctladdr = op->hctl;\n  ip->mctl = myctladdr;\n  myctladdr = op->mctl;\n  ip->in = cin;\n  cin = op->in;\n  ip->out = cout;\n  cout = op->out;\n  ip->tpe = type;\n  type = op->tpe;\n  ip->curtpe = curtype;\n  curtype = op->curtpe;\n  ip->cpnd = cpend;\n  cpend = op->cpnd;\n  ip->sunqe = sunique;\n  sunique = op->sunqe;\n  ip->runqe = runique;\n  runique = op->runqe;\n  ip->mcse = mcase;\n  mcase = op->mcse;\n  ip->ntflg = ntflag;\n  ntflag = op->ntflg;\n  strncpy (ip->nti, ntin, sizeof (ntin) - 1);\n  (ip->nti)[strlen (ip->nti)] = '\\0';\n  strcpy (ntin, op->nti);\n  strncpy (ip->nto, ntout, sizeof (ntout) - 1);\n  (ip->nto)[strlen (ip->nto)] = '\\0';\n  strcpy (ntout, op->nto);\n  ip->mapflg = mapflag;\n  mapflag = op->mapflg;\n\n  free (ip->mi);\n  ip->mi = mapin;\n  mapin = op->mi;\n  op->mi = 0;\n\n  free (ip->mo);\n  ip->mo = mapout;\n  mapout = op->mo;\n  op->mo = 0;\n\n  signal (SIGINT, oldintr);\n  if (abrtflag)\n    {\n      abrtflag = 0;\n      (*oldintr) (SIGINT);\n    }\n}",
      "lines": 105,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "abortpt": {
      "start_point": [
        1741,
        0
      ],
      "end_point": [
        1751,
        1
      ],
      "content": "void\nabortpt (int sig _GL_UNUSED_PARAMETER)\n{\n\n  printf (\"\\n\");\n  fflush (stdout);\n  ptabflg++;\n  mflag = 0;\n  abrtflag = 0;\n  longjmp (ptabort, 1);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "proxtrans": {
      "start_point": [
        1753,
        0
      ],
      "end_point": [
        1881,
        1
      ],
      "content": "void\nproxtrans (char *cmd, char *local, char *remote)\n{\n  sighandler_t oldintr;\n  int secndflag = 0, prox_type, nfnd;\n  char *cmd2;\n  fd_set mask;\n\n  if (strcmp (cmd, \"RETR\"))\n    cmd2 = \"RETR\";\n  else\n    cmd2 = runique ? \"STOU\" : \"STOR\";\n  if ((prox_type = type) == 0)\n    {\n      if (unix_server && unix_proxy)\n\tprox_type = TYPE_I;\n      else\n\tprox_type = TYPE_A;\n    }\n  if (curtype != prox_type)\n    changetype (prox_type, 1);\n  if (command (\"PASV\") != COMPLETE)\n    {\n      printf (\"proxy server does not support third party transfers.\\n\");\n      return;\n    }\n  pswitch (0);\n  if (!connected)\n    {\n      printf (\"No primary connection\\n\");\n      pswitch (1);\n      code = -1;\n      return;\n    }\n  if (curtype != prox_type)\n    changetype (prox_type, 1);\n  if (command (\"PORT %s\", pasv) != COMPLETE)\n    {\n      pswitch (1);\n      return;\n    }\n  if (setjmp (ptabort))\n    goto abort;\n  oldintr = signal (SIGINT, abortpt);\n  if (command (\"%s %s\", cmd, remote) != PRELIM)\n    {\n      signal (SIGINT, oldintr);\n      pswitch (1);\n      return;\n    }\n  sleep (2);\n  pswitch (1);\n  secndflag++;\n  if (command (\"%s %s\", cmd2, local) != PRELIM)\n    goto abort;\n  ptflag++;\n  getreply (0);\n  pswitch (0);\n  getreply (0);\n  signal (SIGINT, oldintr);\n  pswitch (1);\n  ptflag = 0;\n  printf (\"local: %s remote: %s\\n\", local, remote);\n  return;\nabort:\n  signal (SIGINT, SIG_IGN);\n  ptflag = 0;\n  if (strcmp (cmd, \"RETR\") && !proxy)\n    pswitch (1);\n  else if (!strcmp (cmd, \"RETR\") && proxy)\n    pswitch (0);\n  if (!cpend && !secndflag)\n    {\t\t\t\t/* only here if cmd = \"STOR\" (proxy=1) */\n      if (command (\"%s %s\", cmd2, local) != PRELIM)\n\t{\n\t  pswitch (0);\n\t  if (cpend)\n\t    abort_remote ((FILE *) NULL);\n\t}\n      pswitch (1);\n      if (ptabflg)\n\tcode = -1;\n      signal (SIGINT, oldintr);\n      return;\n    }\n  if (cpend)\n    abort_remote ((FILE *) NULL);\n  pswitch (!proxy);\n  if (!cpend && !secndflag)\n    {\t\t\t\t/* only if cmd = \"RETR\" (proxy=1) */\n      if (command (\"%s %s\", cmd2, local) != PRELIM)\n\t{\n\t  pswitch (0);\n\t  if (cpend)\n\t    abort_remote ((FILE *) NULL);\n\t  pswitch (1);\n\t  if (ptabflg)\n\t    code = -1;\n\t  signal (SIGINT, oldintr);\n\t  return;\n\t}\n    }\n  if (cpend)\n    abort_remote ((FILE *) NULL);\n  pswitch (!proxy);\n  if (cpend)\n    {\n      FD_ZERO (&mask);\n      FD_SET (fileno (cin), &mask);\n      if ((nfnd = empty (&mask, 10)) <= 0)\n\t{\n\t  if (nfnd < 0)\n\t    {\n\t      error (0, errno, \"abort\");\n\t    }\n\t  if (ptabflg)\n\t    code = -1;\n\t  lostpeer (0);\n\t}\n      getreply (0);\n      getreply (0);\n    }\n  if (proxy)\n    pswitch (0);\n  pswitch (1);\n  if (ptabflg)\n    code = -1;\n  signal (SIGINT, oldintr);\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "reset": {
      "start_point": [
        1883,
        0
      ],
      "end_point": [
        1904,
        1
      ],
      "content": "void\nreset (int argc _GL_UNUSED_PARAMETER, char **argv _GL_UNUSED_PARAMETER)\n{\n  fd_set mask;\n  int nfnd = 1;\n\n  FD_ZERO (&mask);\n  while (nfnd > 0)\n    {\n      FD_SET (fileno (cin), &mask);\n      if ((nfnd = empty (&mask, 0)) < 0)\n\t{\n\t  error (0, errno, \"reset\");\n\t  code = -1;\n\t  lostpeer (0);\n\t}\n      else if (nfnd)\n\t{\n\t  getreply (0);\n\t}\n    }\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "gunique": {
      "start_point": [
        1906,
        0
      ],
      "end_point": [
        1959,
        1
      ],
      "content": "char *\ngunique (char *local)\n{\n  static char *new = 0;\n  char *cp;\n  int count = 0;\n  char ext = '1';\n\n  free (new);\n  new = malloc (strlen (local) + 1 + 3 + 1);\t/* '.' + 100 + '\\0' */\n  if (!new)\n    {\n      printf (\"gunique: malloc failed.\\n\");\n      return 0;\n    }\n  strcpy (new, local);\n\n  cp = new + strlen (new);\n  *cp++ = '.';\n  for (;;)\n    {\n      struct stat st;\n\n      if (++count == 100)\n\t{\n\t  printf (\"runique: can't find unique file name.\\n\");\n\t  return ((char *) 0);\n\t}\n      *cp++ = ext;\n      *cp = '\\0';\n      if (ext == '9')\n\text = '0';\n      else\n\text++;\n\n      if (stat (new, &st) != 0)\n        {\n          if (errno == ENOENT)\n            return new;\n          else\n            return 0;\n        }\n\n      if (ext != '0')\n\tcp--;\n      else if (*(cp - 2) == '.')\n\t*(cp - 1) = '1';\n      else\n\t{\n\t  *(cp - 2) = *(cp - 2) + 1;\n\t  cp--;\n\t}\n    }\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "char",
        "*\ngunique (char *local)",
        "*"
      ]
    },
    "abort_remote": {
      "start_point": [
        1961,
        0
      ],
      "end_point": [
        2004,
        1
      ],
      "content": "void\nabort_remote (FILE *din)\n{\n  char buf[BUFSIZ];\n  int nfnd;\n  fd_set mask;\n\n  /*\n   * send IAC in urgent mode instead of DM because 4.3BSD places oob mark\n   * after urgent byte rather than before as is protocol now\n   */\n  sprintf (buf, \"%c%c%c\", IAC, IP, IAC);\n  if (send (fileno (cout), buf, 3, MSG_OOB) != 3)\n    error (0, errno, \"abort\");\n  fprintf (cout, \"%cABOR\\r\\n\", DM);\n  fflush (cout);\n  FD_ZERO (&mask);\n  FD_SET (fileno (cin), &mask);\n  if (din)\n    {\n      FD_SET (fileno (din), &mask);\n    }\n  if ((nfnd = empty (&mask, 10)) <= 0)\n    {\n      if (nfnd < 0)\n\t{\n\t  error (0, errno, \"abort\");\n\t}\n      if (ptabflg)\n\tcode = -1;\n      lostpeer (0);\n    }\n  if (din && FD_ISSET (fileno (din), &mask))\n    {\n      while (read (fileno (din), buf, sizeof (buf)) > 0)\n\t/* LOOP */ ;\n    }\n  if (getreply (0) == ERROR && code == 552)\n    {\n      /* 552 needed for nic style abort */\n      getreply (0);\n    }\n  getreply (0);\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftp/ftp_var.h": {},
  "inetutils/inetutils-1.9.4/ftp/main.c": {
    "parse_opt": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'd':\t\t/* Enable debug mode.  */\n      options |= SO_DEBUG;\n      debug++;\n      break;\n\n    case 'e':\n      usereadline = 0;\t/* No editing.  */\n      break;\n\n    case 'g':\t\t/* No glob.  */\n      doglob = 0;\n      break;\n\n    case 'i':\t\t/* No prompt.  */\n      interactive = 0;\n      break;\n\n    case 'n':\t\t/* No automatic login.  */\n      autologin = 0;\n      break;\n\n    case 't':\t\t/* Enable packet tracing.  */\n      trace++;\n      break;\n\n    case 'v':\t\t/* Verbose.  */\n      verbose++;\n      break;\n\n    case OPT_PROMPT:\t\t/* Print command line prompt.  */\n      prompt = arg ? arg : DEFAULT_PROMPT;\n      break;\n\n    case 'p':\t\t/* Enable passive transfer mode.  */\n      passivemode = 1;\n      break;\n\n    case 'A':\t/* Enable active transfer mode.  */\n      passivemode = 0;\n      break;\n\n    case '4':\n      usefamily = AF_INET;\n      break;\n\n    case '6':\n      usefamily = AF_INET6;\n      break;\n\n    case 'N':\n      netrc = arg;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 64,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int top;\n  int index;\n  struct passwd *pw = NULL;\n  char *cp;\n\n  set_program_name (argv[0]);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n\n  doglob = 1;\n  interactive = 1;\n  autologin = 1;\n  passivemode = 0;\t\t/* passive mode not active */\n  doepsv4 = 0;\t\t\t/* use EPRT/EPSV for IPv4 */\n  usefamily = AF_UNSPEC;\t/* allow any address family */\n  usereadline = 1;\t\t/* normally using readline */\n\n  line = NULL;\t\t\t/* reset global input */\n  linelen = 0;\n  argbuf = NULL;\n  netrc = NULL;\n\n  /* Invoked as `pftp'?  Then set passive mode.  */\n  cp = strrchr (argv[0], '/');\n  if (cp)\n    cp++;\n  else\n    cp = argv[0];\n  if (!strcmp (\"pftp\", cp))\n    passivemode = 1;\n\n  /* Parse command line */\n  iu_argp_init (\"ftp\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  argc -= index;\n  argv += index;\n\n  fromatty = isatty (fileno (stdin));\n  if (fromatty)\n    {\n      verbose++;\n      if (!prompt)\n\tprompt = DEFAULT_PROMPT;\n    }\n  else\n    usereadline = 0;\n\n  cpend = 0;\t\t\t/* no pending replies */\n  proxy = 0;\t\t\t/* proxy not active */\n  crflag = 1;\t\t\t/* strip c.r. on ascii gets */\n  sendport = -1;\t\t/* not using ports */\n  /*\n   * Set up the home directory in case we're globbing.\n   */\n  cp = getlogin ();\n  if (cp != NULL)\n    pw = getpwnam (cp);\n  if (pw == NULL)\n    pw = getpwuid (getuid ());\n  if (pw != NULL)\n    {\n      char *buf = malloc (strlen (pw->pw_dir) + 1);\n      if (buf)\n\t{\n\t  strcpy (buf, pw->pw_dir);\n\t  home = buf;\n\t}\n    }\n  if (argc > 0)\n    {\n      char *xargv[5];\n\n      if (setjmp (toplevel))\n\texit (EXIT_SUCCESS);\n      signal (SIGINT, intr);\n      signal (SIGPIPE, lostpeer);\n      xargv[0] = program_invocation_name;\n      xargv[1] = argv[0];\n      xargv[2] = argv[1];\n      xargv[3] = argv[2];\n      xargv[4] = NULL;\n      setpeer (argc + 1, xargv);\n    }\n  top = setjmp (toplevel) == 0;\n  if (top)\n    {\n      signal (SIGINT, intr);\n      signal (SIGPIPE, lostpeer);\n    }\n  for (;;)\n    {\n      cmdscanner (top);\n      top = 1;\n    }\n}",
      "lines": 101,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "intr": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nintr (int sig _GL_UNUSED_PARAMETER)\n{\n  longjmp (toplevel, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lostpeer": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "void\nlostpeer (int sig _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    {\n      if (cout != NULL)\n\t{\n\t  shutdown (fileno (cout), 1 + 1);\n\t  fclose (cout);\n\t  cout = NULL;\n\t}\n      if (data >= 0)\n\t{\n\t  shutdown (data, 1 + 1);\n\t  close (data);\n\t  data = -1;\n\t}\n      connected = 0;\n    }\n  pswitch (1);\n  if (connected)\n    {\n      if (cout != NULL)\n\t{\n\t  shutdown (fileno (cout), 1 + 1);\n\t  fclose (cout);\n\t  cout = NULL;\n\t}\n      connected = 0;\n    }\n  proxflag = 0;\n  pswitch (0);\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cmdscanner": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "void\ncmdscanner (int top)\n{\n  struct cmd *c;\n  ssize_t l;\n\n  if (!top)\n    putchar ('\\n');\n  for (;;)\n    {\n      if (line)\n\t{\n\t  free (line);\n\t  line = NULL;\n\t}\n      linelen = 0;\n\n#if HAVE_READLINE\n      if (usereadline)\n\tline = readline (prompt);\t/* malloc'd, no NL */\n      else\n#endif /* HAVE_READLINE */\n\t{\n\t  if (prompt)\n\t    {\n\t      fprintf (stdout, \"%s\", prompt);\n\t      fflush (stdout);\n\t    }\n\n\t  /* `linelen' is updated to allocated amount.  */\n\t  l = getline (&line, &linelen, stdin);\t/* includes NL */\n\t  if ((l > 0) && line)\n\t    {\n\t      char *nl = strchr (line, '\\n');\n\n\t      if (nl)\n\t\t*nl = '\\0';\n\t    }\n\t  else\n\t    {\n\t      /* Allocation takes place even without input.  */\n\t      free (line);\t/* EOF, et cetera */\n\t      line = NULL;\n\t      linelen = 0;\n\t    }\n\n\t  if (!fromatty && prompt)\n\t    fprintf (stdout, \"%s\\n\", line ? line : \"\");\n\t} /* !usereadline ends */\n\n      if (!line)\n\tquit (0, 0);\n\n      l = strlen (line);\n      if (l == 0)\n\tbreak;\n\n#if HAVE_READLINE\n      if (usereadline && line && *line)\n\tadd_history (line);\n#endif /* HAVE_READLINE */\n\n      makeargv ();\n      if (margc == 0)\n\tcontinue;\n\n      c = getcmd (margv[0]);\n      if (c == (struct cmd *) -1)\n\t{\n\t  printf (\"?Ambiguous command\\n\");\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command\\n\");\n\t  continue;\n\t}\n      if (c->c_conn && !connected)\n\t{\n\t  printf (\"Not connected.\\n\");\n\t  continue;\n\t}\n\n      /* Perform the requested action.  */\n      (*c->c_handler) (margc, margv);\n\n      if (bell && c->c_bell)\n\tputchar ('\\007');\n      if (c->c_handler != help)\n\tbreak;\n    }\n  signal (SIGINT, intr);\n  signal (SIGPIPE, lostpeer);\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "makeargv": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "void\nmakeargv (void)\n{\n  char **argp;\n\n  margc = 0;\t\t\t/* No content as of yet.  */\n\n  /* Make sure that `argbuf' is large enough\n   * to contain `line'.  As soon as `line' is\n   * invalidated, so will `argbuf' be.\n   **/\n  free (argbuf);\t\t/* Get rid of previous content.  */\n  argbuf = malloc (strlen (line) + 4);\n  if (!argbuf)\n    {\n      /* `margc' is naught, which hopefully will cover our back.  */\n      printf (\"Allocation failure.  Serious error.\\n\");\n      return;\n    }\n\n  argp = margv;\n  stringbase = line;\t\t/* scan from beginning of buffer */\n  argbase = argbuf;\t\t/* store at beginning of buffer */\n  slrflag = 0;\n  while ((margc < MAXMARGV) && (*argp++ = slurpstring ()))\n    margc++;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "slurpstring": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "static char *\nslurpstring (void)\n{\n  int got_one = 0;\n  char *sb = stringbase;\n  char *ap = argbase;\n  char *tmp = argbase;\t\t/* will return this if token found */\n\n  if (*sb == '!' || *sb == '$')\n    {\t\t\t\t/* recognize ! as a token for shell */\n      switch (slrflag)\t\t/* and $ as token for macro invoke */\n\t{\n\tcase 0:\n\t  slrflag++;\n\t  stringbase++;\n\t  return ((*sb == '!') ? \"!\" : \"$\");\n\n\tcase 1:\n\t  slrflag++;\n\t  altarg = stringbase;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\nS0:\n  switch (*sb)\n    {\n    case '\\0':\n      goto OUT;\n\n    case ' ':\n    case '\\t':\n      sb++;\n      goto S0;\n\n    default:\n      switch (slrflag)\n\t{\n\tcase 0:\n\t  slrflag++;\n\t  break;\n\n\tcase 1:\n\t  slrflag++;\n\t  altarg = sb;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n      goto S1;\n    }\n\nS1:\n  switch (*sb)\n    {\n    case ' ':\n    case '\\t':\n    case '\\0':\n      goto OUT;\t\t\t/* end of token */\n\n    case '\\\\':\n      sb++;\n      goto S2;\t\t\t/* slurp next character */\n\n    case '\"':\n      sb++;\n      goto S3;\t\t\t/* slurp quoted string */\n\n    default:\n      *ap++ = *sb++;\t\t/* add character to token */\n      got_one = 1;\n      goto S1;\n    }\n\nS2:\n  switch (*sb)\n    {\n    case '\\0':\n      goto OUT;\n\n    default:\n      *ap++ = *sb++;\n      got_one = 1;\n      goto S1;\n    }\n\nS3:\n  switch (*sb)\n    {\n    case '\\0':\n      goto OUT;\n\n    case '\"':\n      sb++;\n      goto S1;\n\n    default:\n      *ap++ = *sb++;\n      got_one = 1;\n      goto S3;\n    }\n\nOUT:\n  if (got_one)\n    *ap++ = '\\0';\n  argbase = ap;\t\t\t/* update storage pointer */\n  stringbase = sb;\t\t/* update scan pointer */\n  if (got_one)\n    return (tmp);\n  switch (slrflag)\n    {\n    case 0:\n      slrflag++;\n      break;\n\n    case 1:\n      slrflag++;\n      altarg = (char *) 0;\n      break;\n\n    default:\n      break;\n    }\n  return ((char *) 0);\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nslurpstring (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftp/ruserpass.c": {
    "remote_userpass": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "int\nremote_userpass (char *host, char **aname, char **apass, char **aacct)\n{\n  char *hdir, buf[BUFSIZ], *tmp;\n  char *myname, *mydomain;\n  int t, c, usedefault = 0;\n  size_t i;\n  struct stat stb;\n\n  hdir = getenv (\"HOME\");\n  if (hdir == NULL)\n    hdir = \".\";\n  snprintf (buf, sizeof buf, \"%s/.netrc\", hdir);\n\n  /* The switch `-N/--netrc' would have set this.  */\n  if (!netrc)\n    netrc = getenv (\"NETRC\");\n\n  if (netrc && netrc[0])\n    snprintf (buf, sizeof buf, \"%s\", netrc);\n\n  cfile = fopen (buf, \"r\");\n  if (cfile == NULL)\n    {\n      if (errno != ENOENT)\n\terror (0, errno, \"%s\", buf);\n      return (0);\n    }\n\n  /* The .netrc is now opened and is thus fixed.\n   * Check that it is a regular file, and not a\n   * soft link in particular.\n   */\n  if (lstat (buf, &stb) < 0)\n    {\n      error (0, errno, \"%s\", buf);\n      fclose (cfile);\n      return (-1);\n    }\n\n  if (!S_ISREG (stb.st_mode))\n    {\n      if (S_ISLNK (stb.st_mode))\n\terror (0, 0, \"the .netrc file is symbolic link: %s\", buf);\n      else\n\terror (0, 0, \"the .netrc file is no regular file: %s\", buf);\n\n      fclose (cfile);\n      return (-1);\n    }\n\n  myname = localhost ();\n  if (!myname)\n    myname = xstrdup (\"\");\n\n  mydomain = strchr (myname, '.');\n  if (mydomain == NULL)\n    mydomain = \"\";\n\n next:\n  while ((t = token ()))\n    switch (t)\n      {\n      case DEFAULT:\n\tusedefault = 1;\n\t/* FALL THROUGH */\n\n      case MACHINE:\n\tif (!usedefault)\n\t  {\n\t    if (token () != ID)\n\t      continue;\n\t    /*\n\t     * Allow match either for user's input host name\n\t     * or official hostname.  Also allow match of\n\t     * incompletely-specified host in local domain.  */\n\t    if (strcasecmp (host, tokval) == 0)\n\t      goto match;\n\t    if (strcasecmp (hostname, tokval) == 0)\n\t      goto match;\n\t    tmp = strchr (hostname, '.');\n\t    if (tmp != NULL\n\t\t&& strcasecmp (tmp, mydomain) == 0\n\t\t&& strncasecmp (hostname, tokval, tmp - hostname) == 0\n\t\t&& tokval[tmp - hostname] == '\\0')\n\t      goto match;\n\t    tmp = strchr (host, '.');\n\t    if (tmp != NULL\n\t\t&& strcasecmp (tmp, mydomain) == 0\n\t\t&& strncasecmp (host, tokval, tmp - host) == 0\n\t\t&& tokval[tmp - host] == '\\0')\n\t      goto match;\n\t    continue;\n\t  }\n      match:\n\twhile ((t = token ()) && t != MACHINE && t != DEFAULT)\n\t  switch (t)\n\t    {\n\t    case LOGIN:\n\t      if (token ())\n                {\n                  if (*aname == 0)\n                    {\n                      *aname = xmalloc ((unsigned) strlen (tokval) + 1);\n                      strcpy (*aname, tokval);\n                    }\n                  else\n                    {\n                      if (strcmp (*aname, tokval))\n                        goto next;\n                    }\n                }\n\t      break;\n\t    case PASSWD:\n\t      if ((*aname == NULL || strcmp (*aname, \"anonymous\"))\n\t\t  && fstat (fileno (cfile), &stb) >= 0\n\t\t  && (stb.st_mode & 077) != 0)\n\t\t{\n\t\t  error (0, 0, \"Error: .netrc file is readable by others.\");\n\t\t  error (0, 0,\n\t\t\t \"Remove password or make file unreadable by others.\");\n\t\t  goto bad;\n\t\t}\n\t      if (token () && *apass == 0)\n\t\t{\n\t\t  *apass = xmalloc ((unsigned) strlen (tokval) + 1);\n\t\t  strcpy (*apass, tokval);\n\t\t}\n\t      break;\n\t    case ACCOUNT:\n\t      if (fstat (fileno (cfile), &stb) >= 0\n\t\t  && (stb.st_mode & 077) != 0)\n\t\t{\n\t\t  error (0, 0, \"Error: .netrc file is readable by others.\");\n\t\t  error (0, 0,\n\t\t\t \"Remove account or make file unreadable by others.\");\n\t\t  goto bad;\n\t\t}\n\t      if (token () && *aacct == 0)\n\t\t{\n\t\t  *aacct = xmalloc ((unsigned) strlen (tokval) + 1);\n\t\t  strcpy (*aacct, tokval);\n\t\t}\n\t      break;\n\t    case MACDEF:\n\t      if (proxy)\n\t\tgoto done;\n\n\t      while (((c = getc (cfile)) != EOF && c == ' ') || c == '\\t')\n\t\t;\n\t      if (c == EOF || c == '\\n')\n\t\t{\n\t\t  printf (\"Missing macdef name argument.\\n\");\n\t\t  goto bad;\n\t\t}\n\t      if (macnum == 16)\n\t\t{\n\t\t  printf (\"Limit of 16 macros have already been defined\\n\");\n\t\t  goto bad;\n\t\t}\n\t      tmp = macros[macnum].mac_name;\n\t      *tmp++ = c;\n\t      for (i = 0; i < (sizeof (macros[macnum].mac_name) - 1)\n\t\t\t  && (c = getc (cfile)) != EOF && !isspace (c);\n\t\t   ++i)\n\t\t{\n\t\t  *tmp++ = c;\n\t\t}\n\t      if (c == EOF)\n\t\t{\n\t\t  printf (\"Macro definition missing null line terminator.\\n\");\n\t\t  goto bad;\n\t\t}\n\t      *tmp = '\\0';\n\t      if (c != '\\n')\n\t\t{\n\t\t  while ((c = getc (cfile)) != EOF && c != '\\n');\n\t\t}\n\t      if (c == EOF)\n\t\t{\n\t\t  printf (\"Macro definition missing null line terminator.\\n\");\n\t\t  goto bad;\n\t\t}\n\t      if (macnum == 0)\n\t\t{\n\t\t  macros[macnum].mac_start = macbuf;\n\t\t}\n\t      else\n\t\t{\n\t\t  macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;\n\t\t}\n\t      tmp = macros[macnum].mac_start;\n\t      while (tmp < macbuf + sizeof (macbuf))\n\t\t{\n\t\t  if ((c = getc (cfile)) == EOF)\n\t\t    {\n\t\t      printf\n\t\t\t(\"Macro definition missing null line terminator.\\n\");\n\t\t      goto bad;\n\t\t    }\n\t\t  *tmp = c;\n\t\t  if (*tmp == '\\n')\n\t\t    {\n\t\t      if (*(tmp - 1) == '\\0')\n\t\t\t{\n\t\t\t  macros[macnum++].mac_end = tmp - 1;\n\t\t\t  break;\n\t\t\t}\n\t\t      *tmp = '\\0';\n\t\t    }\n\t\t  tmp++;\n\t\t}\n\t      if (tmp == macbuf + sizeof (macbuf))\n\t\t{\n\t\t  printf (\"4K macro buffer exceeded\\n\");\n\t\t  goto bad;\n\t\t}\n\t      break;\n\t    default:\n\t      error (0, 0, \"Unknown .netrc keyword %s\", tokval);\n\t      break;\n\t    }\n\tgoto done;\n      }\ndone:\n  fclose (cfile);\n  free (myname);\n  return (0);\nbad:\n  fclose (cfile);\n  free (myname);\n  return (-1);\n}",
      "lines": 233,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "token": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static int\ntoken (void)\n{\n  char *cp;\n  int c;\n  struct toktab *t;\n\n  if (feof (cfile) || ferror (cfile))\n    return (0);\n  while ((c = getc (cfile)) != EOF &&\n\t (c == '\\n' || c == '\\t' || c == ' ' || c == ','))\n    continue;\n  if (c == EOF)\n    return (0);\n  cp = tokval;\n  if (c == '\"')\n    {\n      while ((c = getc (cfile)) != EOF && c != '\"')\n\t{\n\t  if (c == '\\\\')\n\t    c = getc (cfile);\n\t  *cp++ = c;\n\t}\n    }\n  else\n    {\n      *cp++ = c;\n      while ((c = getc (cfile)) != EOF\n\t     && c != '\\n' && c != '\\t' && c != ' ' && c != ',')\n\t{\n\t  if (c == '\\\\')\n\t    c = getc (cfile);\n\t  *cp++ = c;\n\t}\n    }\n  *cp = 0;\n  if (tokval[0] == 0)\n    return (0);\n  for (t = toktab; t->tokstr; t++)\n    if (!strcmp (t->tokstr, tokval))\n      return (t->tval);\n  return (ID);\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/auth.c": {
    "auth_user": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int\nauth_user (const char *name, struct credentials *pcred)\n{\n  int err = 0;\t\t/* Never remove initialisation!  */\n\n  pcred->guest = 0;\n  pcred->expired = AUTH_EXPIRED_NOT;\n\n  switch (pcred->auth_type)\n    {\n#ifdef WITH_LINUX_PAM\n    case AUTH_TYPE_PAM:\n      err = pam_user (name, pcred);\n      break;\n#endif\n#ifdef WITH_KERBEROS\n    case AUTH_TYPE_KERBEROS:\n      err = -1;\n      break;\n#endif\n#ifdef WITH_KERBEROS5\n    case AUTH_TYPE_KERBEROS5:\n      err = -1;\n      break;\n#endif\n#ifdef WITH_OPIE\n    case AUTH_TYPE_OPIE:\n      err = -1;\n      break;\n#endif\n    case AUTH_TYPE_PASSWD:\n    default:\n      {\n\tsize_t len;\n\tfree (pcred->message);\n\tlen = (size_t) (64 + strlen (name));\n\tpcred->message = malloc (len);\n\tif (pcred->message == NULL)\n\t  return -1;\n\n\t/* Check for anonymous log in.\n\t *\n\t * This code simulates part of `pam_ftp.so'\n\t * for PAM variants that are not Linux-PAM,\n\t * in addition to perform the original\n\t * default authentication checks.\n\t */\n\tif (strcmp (name, \"ftp\") == 0 || strcmp (name, \"anonymous\") == 0)\n\t  {\n\t    if (checkuser (PATH_FTPUSERS, \"ftp\")\n\t\t|| checkuser (PATH_FTPUSERS, \"anonymous\"))\n\t      {\n\t\tsnprintf (pcred->message, len, \"User %s access denied.\",\n\t\t\t  name);\n\t\terr = 1;\n\t      }\n\t    else if (sgetcred (\"ftp\", pcred) == 0)\n\t      {\n\t\tpcred->guest = 1;\n\t\tstrcpy (pcred->message,\n\t\t\t\"Guest login ok, type your name as password.\");\n\t      }\n\t    else\n\t      {\n\t\tsnprintf (pcred->message, len, \"User %s unknown.\", name);\n\t\terr = 1;\n\t      }\n\t    return err;\n\t  }\n\n\tif (sgetcred (name, pcred) == 0)\n\t  {\n\t    const char *cp;\n\t    const char *shell;\n\n\t    /* Check if the shell is allowed */\n\t    shell = pcred->shell;\n\t    if (shell == NULL || *shell == 0)\n\t      shell = PATH_BSHELL;\n\t    setusershell ();\n\t    while ((cp = getusershell ()) != NULL)\n\t      if (strcmp (cp, shell) == 0)\n\t\tbreak;\n\t    endusershell ();\n\n\t    if (cp == NULL || checkuser (PATH_FTPUSERS, name))\n\t      {\n\t\tsprintf (pcred->message, \"User %s access denied.\", name);\n\t\treturn 1;\n\t      }\n\t  }\n\telse\n\t  {\n\t    free (pcred->message);\n\t    pcred->message = NULL;\n\t    return 1;\n\t  }\n\tsnprintf (pcred->message, len,\n\t\t  \"Password required for %s.\", pcred->name);\n\terr = 0;\n      }\n    }\n\n  if (err == 0)\n    {\n      pcred->dochroot = checkuser (PATH_FTPCHROOT, pcred->name);\n\n#if defined WITH_PAM && !defined WITH_LINUX_PAM\n      if (pcred->auth_type == AUTH_TYPE_PAM)\n\terr = pam_user (name, pcred);\n#endif /* WITH_PAM && !WITH_LINUX_PAM */\n    }\n\n  return err;\n}",
      "lines": 115,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "auth_pass": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "int\nauth_pass (const char *passwd, struct credentials *pcred)\n{\n  switch (pcred->auth_type)\n    {\n#ifdef WITH_PAM\n    case AUTH_TYPE_PAM:\n      return pam_pass (passwd, pcred);\n#endif\n#ifdef WITH_KERBEROS\n    case AUTH_TYPE_KERBEROS:\n      return -1;\n#endif\n#ifdef WITH_KERBEROS5\n    case AUTH_TYPE_KERBEROS5:\n      return -1;\n#endif\n#ifdef WITH_OPIE\n    case AUTH_TYPE_OPIE:\n      return -1;\n#endif\n    case AUTH_TYPE_PASSWD:\n    default:\n      {\n\tchar *xpasswd;\n\tchar *salt = pcred->passwd;\n\t/* Try to authenticate the user.  */\n\tif (pcred->passwd == NULL || *pcred->passwd == '\\0')\n\t  return 1;\t\t/* Failed. */\n\txpasswd = crypt (passwd, salt);\n\treturn (!xpasswd || strcmp (xpasswd, pcred->passwd) != 0);\n      }\n    }\t\t\t\t/* switch (auth_type) */\n  return -1;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sgetcred": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int\nsgetcred (const char *name, struct credentials *pcred)\n{\n  struct passwd *p;\n\n  p = getpwnam (name);\n  if (p == NULL)\n    return 1;\n\n  free (pcred->name);\n  free (pcred->passwd);\n  free (pcred->homedir);\n  free (pcred->rootdir);\n  free (pcred->shell);\n\n#if defined HAVE_GETSPNAM && defined HAVE_SHADOW_H\n  if (p->pw_passwd == NULL || strlen (p->pw_passwd) == 1)\n    {\n      struct spwd *spw;\n\n      setspent ();\n      spw = getspnam (p->pw_name);\n      if (spw != NULL)\n\t{\n\t  time_t now;\n\t  long today;\n\t  now = time ((time_t *) 0);\n\t  today = now / (60 * 60 * 24);\n\n\t  if (spw->sp_expire > 0 && spw->sp_expire < today)\n\t    {\n\t      p->pw_passwd = NULL;\n\t      pcred->expired |= AUTH_EXPIRED_ACCT;\n\t    }\n\t  if (spw->sp_max > 0 && spw->sp_lstchg > 0\n\t\t   && (spw->sp_lstchg + spw->sp_max < today))\n\t    {\n\t      p->pw_passwd = NULL;\n\t      pcred->expired |= AUTH_EXPIRED_PASS;\n\t    }\n\n\t  if (pcred->expired == AUTH_EXPIRED_NOT)\n\t    p->pw_passwd = spw->sp_pwdp;\n\t}\n      endspent ();\n    }\n#elif defined HAVE_STRUCT_PASSWD_PW_EXPIRE\t/* !HAVE_SHADOW_H */\n  /* BSD systems provide pw_expire as epoch time,\n   * and the password is exposed in pw_passwd for\n   * a caller with euid 0.\n   *\n   * NetBSD allows -1 for 'pw_change', meaning that immediate\n   * change is required.  Let us deny access in that case..\n   */\n  if (p->pw_expire > 0\n# ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n      || p->pw_change\n# endif\n     )\n    {\n      time_t now = time ((time_t *) 0);\n\n      if (p->pw_expire > 0 && difftime (p->pw_expire, now) < 0)\n\t{\n\t  p->pw_passwd = NULL;\n\t  pcred->expired |= AUTH_EXPIRED_ACCT;\n\t}\n# ifdef HAVE_STRUCT_PASSWD_PW_CHANGE\n      if (p->pw_change && difftime (p->pw_change, now) < 0)\n\t{\n\t  p->pw_passwd = NULL;\n\t  pcred->expired |= AUTH_EXPIRED_PASS;\n\t}\n# endif\n    }\n#endif /* !HAVE_STRUCT_PASSWD_PW_EXPIRE */\n\n  pcred->uid = p->pw_uid;\n  pcred->gid = p->pw_gid;\n  pcred->name = sgetsave (p->pw_name);\n  pcred->passwd = sgetsave (p->pw_passwd);\n  pcred->rootdir = sgetsave (p->pw_dir);\n  pcred->homedir = sgetsave (\"/\");\n  pcred->shell = sgetsave (p->pw_shell);\n\n  return 0;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/conf.c": {
    "display_file": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\ndisplay_file (const char *name, int code)\n{\n  char *cp, line[LINE_MAX];\n  FILE *fp = fopen (name, \"r\");\n  if (fp != NULL)\n    {\n      while (fgets (line, sizeof (line), fp) != NULL)\n\t{\n\t  cp = strchr (line, '\\n');\n\t  if (cp != NULL)\n\t    *cp = '\\0';\n\t  lreply (code, \"%s\", line);\n\t}\n      fflush (stdout);\n      fclose (fp);\n      return 0;\n    }\n  return errno;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "checkuser": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\ncheckuser (const char *filename, const char *name)\n{\n  FILE *fp;\n  int found = 0, ngroups = 0;\n  char *p, line[BUFSIZ];\n  gid_t *groups = NULL;\n  struct passwd *pwd = NULL;\n\n  fp = fopen (filename, \"r\");\n  if (fp != NULL)\n    {\n      while (fgets (line, sizeof (line), fp) != NULL)\n\t{\n\t  /* Properly terminate input.  */\n\t  p = strchr (line, '\\n');\n\t  if (p != NULL)\n\t    *p = '\\0';\n\n\t  /* Disregard initial blank characters.  */\n\t  p = line;\n\t  while (isblank (*p))\n\t    p++;\n\n\t  /* Skip comments, and empty lines.  */\n\t  if (*p == '#' || *p == 0)\n\t    continue;\n\n\t  /* Wildcard entry, a single '@'.  */\n\t  if (p[0] == '@' && (p[1] == 0 || isblank (p[1])))\n\t    {\n\t      found = 1;\n\t      break;\n\t    }\n\n\t  /* Group entries begin with '@' and are non-trivial.  */\n\t  if (p[0] == '@' && p[1] && !isblank (p[1]))\n\t    {\n\t      /* The group list is generated only if needed,\n\t       * and only once.\n\t       */\n\t      if (!groups)\n\t\t{\n\t\t  pwd = getpwnam (name);\n\t\t  if (pwd)\n\t\t    ngroups = mgetgroups (name, pwd->pw_gid, &groups);\n\t\t}\n\n\t      /* Check for group membership.  */\n\t      if ((ngroups > 0) && groups && pwd)\n\t\t{\n\t\t  struct group *grp;\n\t\t  char *gname;\n\n\t\t  /* Identify valid group name.  */\n\t\t  gname = ++p;\n\t\t  while (*p && (isalnum (*p) || *p == '_' || *p == '-'))\n\t\t    p++;\n\n\t\t  *p = '\\0';\t/* Group name ends here.  */\n\n\t\t  grp = getgrnam (gname);\n\t\t  if (grp)\n\t\t    {\n\t\t      int j;\n\n\t\t      for (j = 0; j < ngroups; j++)\n\t\t\tif (groups[j] == grp->gr_gid)\n\t\t\t  {\n\t\t\t    found = 1;\n\t\t\t    break;\n\t\t\t  }\n\t\t    }\n\t\t}\n\t      continue;\t/* No match, or failure.  */\n\t    }\n\n\t  /* User name ends at the first blank character.  */\n\t  if (strncmp (p, name, strlen (name)) == 0\n\t      && (p[strlen (name)] == 0\n\t\t  || isblank (p[strlen (name)])))\n\t    {\n\t      found = 1;\n\t      break;\n\t    }\n\t}\n      free (groups);\n      fclose (fp);\n    }\n  return (found);\n}",
      "lines": 91,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/extern.h": {},
  "inetutils/inetutils-1.9.4/ftpd/ftpcmd.c": {
    "yy_symbol_value_print": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static void\nyy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  FILE *yyo = yyoutput;\n  YYUSE (yyo);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yytype < YYNTOKENS)\n    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);\n# endif\n  YYUSE (yytype);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_symbol_print": {
      "start_point": [
        1033,
        0
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "static void\nyy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)\n{\n  YYFPRINTF (yyoutput, \"%s %s (\",\n             yytype < YYNTOKENS ? \"token\" : \"nterm\", yytname[yytype]);\n\n  yy_symbol_value_print (yyoutput, yytype, yyvaluep);\n  YYFPRINTF (yyoutput, \")\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_stack_print": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static void\nyy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)\n{\n  YYFPRINTF (stderr, \"Stack now\");\n  for (; yybottom <= yytop; yybottom++)\n    {\n      int yybot = *yybottom;\n      YYFPRINTF (stderr, \" %d\", yybot);\n    }\n  YYFPRINTF (stderr, \"\\n\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_reduce_print": {
      "start_point": [
        1071,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "static void\nyy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  /* The symbols being reduced.  */\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              );\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yystrlen": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1139,
        1
      ],
      "content": "static YYSIZE_T\nyystrlen (const char *yystr)\n{\n  YYSIZE_T yylen;\n  for (yylen = 0; yystr[yylen]; yylen++)\n    continue;\n  return yylen;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yystpcpy": {
      "start_point": [
        1149,
        0
      ],
      "end_point": [
        1159,
        1
      ],
      "content": "static char *\nyystpcpy (char *yydest, const char *yysrc)\n{\n  char *yyd = yydest;\n  const char *yys = yysrc;\n\n  while ((*yyd++ = *yys++) != '\\0')\n    continue;\n\n  return yyd - 1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nyystpcpy (char *yydest, const char *yysrc)",
        "*"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1171,
        0
      ],
      "end_point": [
        1208,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n        switch (*++yyp)\n          {\n          case '\\'':\n          case ',':\n            goto do_not_strip_quotes;\n\n          case '\\\\':\n            if (*++yyp != '\\\\')\n              goto do_not_strip_quotes;\n            /* Fall through.  */\n          default:\n            if (yyres)\n              yyres[yyn] = *yyp;\n            yyn++;\n            break;\n\n          case '\"':\n            if (yyres)\n              yyres[yyn] = '\\0';\n            return yyn;\n          }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = YY_NULLPTR;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                {\n                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);\n                  if (! (yysize <= yysize1\n                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                    return 2;\n                  yysize = yysize1;\n                }\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  {\n    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);\n    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n      return 2;\n    yysize = yysize1;\n  }\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 126,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yydestruct": {
      "start_point": [
        1351,
        0
      ],
      "end_point": [
        1362,
        1
      ],
      "content": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n{\n  YYUSE (yyvaluep);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YYUSE (yytype);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyparse": {
      "start_point": [
        1380,
        0
      ],
      "end_point": [
        3172,
        1
      ],
      "content": "int\nyyparse (void)\n{\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 3:\n#line 189 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tfree (fromname);\n\t\t\tfromname = (char *) 0;\n\t\t\trestart_point = (off_t) 0;\n\t\t}\n#line 1624 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 199 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tuser ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1633 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 204 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tpass ((yyvsp[-1].s));\n\t\t\tmemset ((yyvsp[-1].s), 0, strlen ((yyvsp[-1].s)));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1643 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 210 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if ((yyvsp[-1].i)\n\t\t\t\t&& ((his_addr.ss_family == AF_INET\n\t\t\t\t     && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t&((struct sockaddr_in *) &data_dest)->sin_addr,\n\t\t\t\t\t\tsizeof (struct in_addr))\n\t\t\t\t\t== 0\n\t\t\t\t     && ntohs (((struct sockaddr_in *) &data_dest)->sin_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t    ||\n\t\t\t\t    (his_addr.ss_family == AF_INET6\n\t\t\t\t     && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t\t&((struct sockaddr_in6 *) &data_dest)->sin6_addr,\n\t\t\t\t\t\tsizeof (struct in6_addr))\n\t\t\t\t\t== 0\n\t\t\t\t     && ntohs (((struct sockaddr_in6 *) &data_dest)->sin6_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t   )\n\t\t\t       )\n\t\t\t      {\n\t\t\t\tusedefault = 0;\n\t\t\t\tif (pdata >= 0)\n\t\t\t\t  {\n\t\t\t\t    close (pdata);\n\t\t\t\t    pdata = -1;\n\t\t\t\t  }\n\t\t\t\treply (200, \"PORT command successful.\");\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tusedefault = 1;\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\treply (500, \"Illegal PORT Command\");\n\t\t\t      }\n\t\t\t  }\n\t\t}\n#line 1686 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 249 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  passive (PASSIVE_PASV, AF_INET);\n\t\t}\n#line 1695 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 254 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tswitch (cmd_type)\n\t\t\t  {\n\t\t\t  case TYPE_A:\n\t\t\t    if (cmd_form == FORM_N)\n\t\t\t      {\n\t\t\t\treply (200, \"Type set to A.\");\n\t\t\t\ttype = cmd_type;\n\t\t\t\tform = cmd_form;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (504, \"Form must be N.\");\n\t\t\t    break;\n\n\t\t\t  case TYPE_E:\n\t\t\t    reply (504, \"Type E not implemented.\");\n\t\t\t    break;\n\n\t\t\t  case TYPE_I:\n\t\t\t    reply (200, \"Type set to I.\");\n\t\t\t    type = cmd_type;\n\t\t\t    break;\n\n\t\t\t  case TYPE_L:\n#if defined NBBY && NBBY == 8\n\t\t\t    if (cmd_bytesz == 8)\n\t\t\t      {\n\t\t\t\treply (200, \"Type set to L (byte size 8).\");\n\t\t\t\ttype = cmd_type;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (504, \"Byte size must be 8.\");\n#else /* NBBY == 8 */\n\t\t\t  UNIMPLEMENTED for NBBY != 8\n#endif /* NBBY == 8 */\n\t\t\t  }\n\t\t}\n#line 1737 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 292 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tswitch ((yyvsp[-1].i))\n\t\t\t  {\n\t\t\t  case STRU_F:\n\t\t\t    reply (200, \"STRU F ok.\");\n\t\t\t    break;\n\n\t\t\t  default:\n\t\t\t    reply (504, \"Unimplemented STRU type.\");\n\t\t\t  }\n\t\t}\n#line 1753 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 304 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tswitch ((yyvsp[-1].i))\n\t\t\t  {\n\t\t\t  case MODE_S:\n\t\t\t    reply (200, \"MODE S ok.\");\n\t\t\t    break;\n\n\t\t\t  default:\n\t\t\t    reply (502, \"Unimplemented MODE type.\");\n\t\t\t  }\n\t\t}\n#line 1769 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 316 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (202, \"ALLO command ignored.\");\n\t\t}\n#line 1777 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 320 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (202, \"ALLO command ignored.\");\n\t\t}\n#line 1785 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 324 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  retrieve ((char *) 0, (yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1795 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 330 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  store ((yyvsp[-1].s), \"w\", 0);\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1805 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 16:\n#line 336 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  store ((yyvsp[-1].s), \"a\", 0);\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1815 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 342 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  send_file_list (\".\");\n\t\t}\n#line 1824 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 347 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  send_file_list ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1834 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 353 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  retrieve (\"/bin/ls -lgA\", \"\");\n\t\t}\n#line 1843 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 358 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  retrieve (\"/bin/ls -lgA %s\", (yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1853 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 364 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  statfilecmd ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1863 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 370 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tstatcmd ();\n\t\t}\n#line 1871 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 374 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  delete ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1881 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 380 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if (fromname)\n\t\t\t      {\n\t\t\t\trenamecmd (fromname, (yyvsp[-1].s));\n\t\t\t\tfree (fromname);\n\t\t\t\tfromname = (char *) 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (503, \"Bad sequence of commands.\");\n\t\t\t  }\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1900 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 395 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (225, \"ABOR command successful.\");\n\t\t}\n#line 1908 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 399 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  cwd (cred.homedir);\n\t\t}\n#line 1917 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 404 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  cwd ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1927 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 410 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\thelp (cmdtab, (char *) 0);\n\t\t}\n#line 1935 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 414 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tchar *cp = (yyvsp[-1].s);\n\n\t\t\tif (strncasecmp (cp, \"SITE\", 4) == 0)\n\t\t\t  {\n\t\t\t    cp = (yyvsp[-1].s) + 4;\n\t\t\t    if (*cp == ' ')\n\t\t\t      cp++;\n\t\t\t    if (*cp)\n\t\t\t      help (sitetab, cp);\n\t\t\t    else\n\t\t\t      help (sitetab, (char *) 0);\n\t\t\t  }\n\t\t\telse\n\t\t\t  help (cmdtab, (yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1957 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 30:\n#line 432 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (200, \"NOOP command successful.\");\n\t\t}\n#line 1965 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 31:\n#line 436 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  makedir ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1975 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 442 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  removedir ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 1985 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 448 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  pwd ();\n\t\t}\n#line 1994 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 453 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  cwd (\"..\");\n\t\t}\n#line 2003 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 458 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  {\n\t\t\t    char **name;\n\n\t\t\t    lreply (211, \"Supported extensions:\");\n\t\t\t    for (name = extlist; *name; name++)\n\t\t\t      printf (\" %s\\r\\n\", *name);\n\t\t\t    reply (211, \"End\");\n\t\t\t  }\n\t\t}\n#line 2019 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 36:\n#line 471 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    reply (501, \"Not accepting arguments.\");\n\t\t\t    free ((yyvsp[-1].s));\n\t\t\t  }\n\t\t}\n#line 2031 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 483 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  {\n\t\t\t    reply (501, \"Must have an argument.\");\n\t\t\t  }\n\t\t}\n#line 2042 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 490 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    reply (501, \"No options are available.\");\n\t\t\t    free ((yyvsp[-1].s));\n\t\t\t  }\n\t\t}\n#line 2054 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 498 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\thelp (sitetab, (char *) 0);\n\t\t}\n#line 2062 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 40:\n#line 502 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\thelp (sitetab, (yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 2071 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 41:\n#line 507 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint oldmask;\n\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  {\n\t\t\t    oldmask = umask (0);\n\t\t\t    umask (oldmask);\n\t\t\t    reply (200, \"Current UMASK is %03o\", oldmask);\n\t\t\t  }\n\t\t}\n#line 2086 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 518 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint oldmask;\n\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if (((yyvsp[-1].i) == -1) || ((yyvsp[-1].i) > 0777))\n\t\t\t      reply (501, \"Bad UMASK value\");\n\t\t\t    else\n\t\t\t      {\n\t\t\t\toldmask = umask ((yyvsp[-1].i));\n\t\t\t\treply (200, \"UMASK set to %03o (was %03o)\",\n\t\t\t\t      (yyvsp[-1].i), oldmask);\n\t\t\t      }\n\t\t\t  }\n\t\t}\n#line 2106 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 534 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-5].i) && ((yyvsp[-1].s) != NULL))\n\t\t\t  {\n\t\t\t    if ((yyvsp[-3].i) > 0777)\n\t\t\t      reply (501,\n\t\t\t\t     \"CHMOD: Mode value must be between 0 and 0777\");\n\t\t\t    else if (chmod ((yyvsp[-1].s), (yyvsp[-3].i)) < 0)\n\t\t\t      perror_reply (550, (yyvsp[-1].s));\n\t\t\t    else\n\t\t\t      reply (200, \"CHMOD command successful.\");\n\t\t\t  }\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 2124 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 548 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (200,\n\t\t\t       \"Current IDLE time limit is %d seconds; max %d\",\n\t\t\t       timeout, maxtimeout);\n\t\t}\n#line 2134 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 554 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if ((yyvsp[-1].i) < 30 || (yyvsp[-1].i) > maxtimeout)\n\t\t\t      reply (501,\n\t\t\t\t     \"Maximum IDLE time must be between 30 and %d seconds\",\n\t\t\t\t     maxtimeout);\n\t\t\t    else\n\t\t\t      {\n\t\t\t\ttimeout = (yyvsp[-1].i);\n\t\t\t\talarm ((unsigned) timeout);\n\t\t\t\treply (200,\n\t\t\t\t       \"Maximum IDLE time set to %d seconds\",\n\t\t\t\t       timeout);\n\t\t\t      }\n\t\t\t  }\n\t\t}\n#line 2156 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 572 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  store ((yyvsp[-1].s), \"w\", 1);\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 2166 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 578 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t        const char *sys_type; /* Official rfc-defined os type.  */\n\t\t\tchar *version = 0; /* A more specific type. */\n\n#ifdef HAVE_UNAME\n\t\t\tstruct utsname u;\n\n\t\t\tif (uname (&u) >= 0)\n\t\t\t  {\n\t\t\t    version = malloc (strlen (u.sysname) + 1\n\t\t\t\t\t      + strlen (u.release) + 1);\n\t\t\t    if (version)\n\t\t\t      sprintf (version, \"%s %s\", u.sysname, u.release);\n\t\t\t  }\n#else /* !HAVE_UNAME */\n# ifdef BSD\n\t\t\tversion = \"BSD\";\n# endif /* BSD */\n#endif /* !HAVE_UNAME */\n\n#if defined unix || defined __unix || defined __unix__\n\t\t\tsys_type = \"UNIX\";\n#else\n\t\t\tsys_type = \"UNKNOWN\";\n#endif\n\n\t\t\tif (!no_version && version)\n\t\t\t  reply (215, \"%s Type: L%d Version: %s\",\n\t\t\t\t sys_type, NBBY, version);\n\t\t\telse\n\t\t\t  reply (215, \"%s Type: L%d\", sys_type, NBBY);\n\n#ifdef HAVE_UNAME\n\t\t\tfree (version);\n#endif\n\t\t}\n#line 2207 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 622 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  sizecmd ((yyvsp[-1].s));\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 2217 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 637 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s) != NULL)\n\t\t\t  {\n\t\t\t    struct stat stbuf;\n\n\t\t\t    if (stat ((yyvsp[-1].s), &stbuf) < 0)\n\t\t\t      reply (550, \"%s: %s\", (yyvsp[-1].s), strerror (errno));\n\t\t\t    else if (!S_ISREG (stbuf.st_mode))\n\t\t\t      reply (550, \"%s: not a plain file.\", (yyvsp[-1].s));\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tstruct tm *t;\n\n\t\t\t\tt = gmtime (&stbuf.st_mtime);\n\t\t\t\treply (213,\n\t\t\t\t       \"%04d%02d%02d%02d%02d%02d\",\n\t\t\t\t       1900 + t->tm_year, t->tm_mon+1,\n\t\t\t\t       t->tm_mday, t->tm_hour,\n\t\t\t\t       t->tm_min, t->tm_sec);\n\t\t\t      }\n\t\t\t  }\n\t\t\tfree ((yyvsp[-1].s));\n\t\t}\n#line 2245 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 665 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tusedefault = 0;\n\t\t\tif (pdata >= 0)\n\t\t\t  {\n\t\t\t    close (pdata);\n\t\t\t    pdata = -1;\n\t\t\t  }\n\t\t\t/* A first sanity check.  */\n\t\t\tif ((yyvsp[-9].i)\t\t\t\t/* valid login */\n\t\t\t    && ((yyvsp[-6].i) > 0)\t\t\t/* valid protocols */\n\t\t\t    && ((yyvsp[-7].i) > 32 && (yyvsp[-7].i) < 127)\t/* legal first delimiter */\n\t\t\t\t\t\t\t/* identical delimiters */\n\t\t\t    && ((yyvsp[-7].i) == (yyvsp[-5].i) && (yyvsp[-7].i) == (yyvsp[-3].i) && (yyvsp[-7].i) == (yyvsp[-1].i)))\n\t\t\t  {\n\t\t\t    /* We only accept connections using\n\t\t\t     * the same address family as is\n\t\t\t     * currently in use, unless we\n\t\t\t     * detect IPv4-mapped-to-IPv6.\n\t\t\t     */\n\t\t\t    if (his_addr.ss_family == (yyvsp[-6].i)\n\t\t\t\t|| ((yyvsp[-6].i) == AF_INET6\n\t\t\t\t    && his_addr.ss_family == AF_INET)\n\t\t\t\t|| ((yyvsp[-6].i) == AF_INET\n\t\t\t\t    && his_addr.ss_family == AF_INET6))\n\t\t\t      {\n\t\t\t\tint err;\n\t\t\t\tchar p[8];\n\t\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t\tmemset (&hints, 0, sizeof (hints));\n\t\t\t\tsnprintf (p, sizeof (p), \"%jd\", (yyvsp[-2].i) & 0xffff);\n\t\t\t\thints.ai_family = (yyvsp[-6].i);\n\t\t\t\thints.ai_socktype = SOCK_STREAM;\n\t\t\t\thints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t\terr = getaddrinfo ((yyvsp[-4].s), p, &hints, &res);\n\t\t\t\tif (err)\n\t\t\t\t  reply (500, \"Illegal EPRT Command\");\n\t\t\t\telse if (/* sanity check */\n\t\t\t\t\t (his_addr.ss_family == AF_INET\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t     &((struct sockaddr_in *) res->ai_addr)->sin_addr,\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in *) res->ai_addr)->sin_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t\t     &((struct sockaddr_in6 *) res->ai_addr)->sin6_addr,\n\t\t\t\t\t\t     sizeof (struct in6_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in6 *) res->ai_addr)->sin6_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET\n\t\t\t\t\t  && res->ai_family == AF_INET6\n\t\t\t\t\t  && IN6_IS_ADDR_V4MAPPED (&((struct sockaddr_in6 *) res->ai_addr)->sin6_addr)\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t     &((struct in_addr *) &((struct sockaddr_in6 *) res->ai_addr)->sin6_addr)[3],\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in6 *) res->ai_addr)->sin6_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t\t  && res->ai_family == AF_INET\n\t\t\t\t\t  && IN6_IS_ADDR_V4MAPPED (&((struct sockaddr_in6 *) &his_addr)->sin6_addr)\n\t\t\t\t\t  && memcmp (&((struct in_addr *) &((struct sockaddr_in6 *) &his_addr)->sin6_addr)[3],\n\t\t\t\t\t\t     &((struct sockaddr_in *) res->ai_addr)->sin_addr,\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in *) res->ai_addr)->sin_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t)\n\t\t\t\t  {\n\t\t\t\t    /* In the case of IPv4 mapped as IPv6,\n\t\t\t\t     * the addresses were proven to coincide,\n\t\t\t\t     * only the extraction remains.\n\t\t\t\t     * Since non-mapped is the standard,\n\t\t\t\t     * test that situation first.\n\t\t\t\t     */\n\t\t\t\t    if (his_addr.ss_family == res->ai_family)\n\t\t\t\t      {\n\t\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\t\tres->ai_addrlen);\n\t\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\t      }\n\t\t\t\t    else if (his_addr.ss_family == AF_INET\n\t\t\t\t\t     && res->ai_family == AF_INET6)\n\t\t\t\t      {\n\t\t\t\t\t/* `his_addr' contains the reduced\n\t\t\t\t\t * IPv4 address.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy (&data_dest, &his_addr,\n\t\t\t\t\t\tsizeof (struct sockaddr_in));\n\t\t\t\t\tdata_dest_len =\n\t\t\t\t\t  sizeof (struct sockaddr_in);\n\t\t\t\t\t((struct sockaddr_in *) &data_dest)->sin_port =\n\t\t\t\t\t  ((struct sockaddr_in6 *) res->ai_addr)->sin6_port;\n\t\t\t\t      }\n\t\t\t\t    else\n\t\t\t\t      {\n\t\t\t\t\t/* `res->ai_addr' contains the reduced\n\t\t\t\t\t * IPv4 address, but the connection\n\t\t\t\t\t * stands on `his_addr', which is\n\t\t\t\t\t * an IPv4-to-IPv6-mapped address.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy (&data_dest, &his_addr,\n\t\t\t\t\t\tsizeof (struct sockaddr_in6));\n\t\t\t\t\tdata_dest_len =\n\t\t\t\t\t  sizeof (struct sockaddr_in6);\n\t\t\t\t\t((struct sockaddr_in6 *) &data_dest)->sin6_port =\n\t\t\t\t\t  ((struct sockaddr_in *) res->ai_addr)->sin_port;\n\t\t\t\t      }\n\n\t\t\t\t    freeaddrinfo (res);\n\t\t\t\t    reply (200, \"EPRT command successful.\");\n\t\t\t\t  }\n\t\t\t\telse\n\t\t\t\t  {\n\t\t\t\t    /* failed identity check */\n\t\t\t\t    if (res)\n\t\t\t\t      freeaddrinfo (res);\n\t\t\t\t    reply (500, \"Illegal EPRT Command\");\n\t\t\t\t  }\n\t\t\t      }\n\t\t\t    else\n\t\t\t      /* Not fit for established connection.  */\n\t\t\t      reply (522,\n\t\t\t\t     \"Network protocol not supported, use (%d)\",\n\t\t\t\t     ((yyvsp[-6].i) == 1) ? 2 : 1);\n\t\t\t  }\n\t\t\telse if ((yyvsp[-9].i) && ((yyvsp[-6].i) <= 0))\n\t\t\t    reply (522,\n\t\t\t\t   \"Network protocol not supported, use (1,2)\");\n\t\t\telse if ((yyvsp[-9].i))\n\t\t\t  /* Incorrect delimiters detected,\n\t\t\t   * the other conditions are met.\n\t\t\t   */\n\t\t\t  reply (500, \"Illegal EPRT Command\");\n\t\t}\n#line 2396 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 816 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  passive (PASSIVE_EPSV, AF_UNSPEC);\n\t\t}\n#line 2405 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 821 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if ((yyvsp[-1].i) > 0)\n\t\t\t      passive (PASSIVE_EPSV, (yyvsp[-1].i));\n\t\t\t    else\n\t\t\t      reply (522,\n\t\t\t\t     \"Network protocol not supported, use (1,2)\");\n\t\t\t  }\n\t\t}\n#line 2420 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 836 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-3].i))\n\t\t\t  {\n\t\t\t    if ((yyvsp[-1].i) &&\n\t\t\t\t((his_addr.ss_family == AF_INET\n\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t     &((struct sockaddr_in *) &data_dest)->sin_addr,\n\t\t\t\t\t     sizeof (struct in_addr)) == 0\n\t\t\t\t  && ntohs (((struct sockaddr_in *) &data_dest)->sin_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t ||\n\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t  && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t     &((struct sockaddr_in6 *) &data_dest)->sin6_addr,\n\t\t\t\t\t     sizeof (struct in6_addr)) == 0\n\t\t\t\t  && ntohs (((struct sockaddr_in6 *) &data_dest)->sin6_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t)\n\t\t\t       )\n\t\t\t      {\n\t\t\t\tusedefault = 0;\n\t\t\t\tif (pdata >= 0)\n\t\t\t\t  {\n\t\t\t\t    close (pdata);\n\t\t\t\t    pdata = -1;\n\t\t\t\t  }\n\t\t\t\t  reply (200, \"LPRT command successful.\");\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tusedefault = 1;\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\treply (500, \"Illegal LPRT Command\");\n\t\t\t      }\n\t\t\t  } /* check_login */\n\t\t}\n#line 2461 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 877 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif ((yyvsp[-1].i))\n\t\t\t  passive (PASSIVE_LPSV, 0 /* not used */);\n\t\t}\n#line 2470 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 883 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\treply (221, \"Goodbye.\");\n\t\t\tdologout (0);\n\t\t}\n#line 2479 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 888 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tyyerrok;\n\t\t}\n#line 2487 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 894 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\trestart_point = (off_t) 0;\n\t\t\tif ((yyvsp[-3].i) && (yyvsp[-1].s))\n\t\t\t  {\n\t\t\t    free (fromname);\n\t\t\t    fromname = renamefrom ((yyvsp[-1].s));\n\t\t\t  }\n\t\t\tif (fromname == (char *) 0 && (yyvsp[-1].s))\n\t\t\t  free ((yyvsp[-1].s));\n\t\t}\n#line 2502 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 909 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t        free (fromname);\n\t\t\tfromname = (char *) 0;\n\t\t\trestart_point = (yyvsp[-1].i);\n\t\t\treply (350, \"Restarting at %jd. %s\",\n\t\t\t       (intmax_t) restart_point,\n\t\t\t       \"Send STORE or RETRIEVE to initiate transfer.\");\n\t\t}\n#line 2515 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 925 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.s) = (char *) calloc (1, sizeof (char));\n\t\t}\n#line 2523 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 937 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t/* Rewrite as valid address family.  */\n\t\t\tif ((yyvsp[0].i) == 1)\n\t\t\t  (yyval.i) = AF_INET;\n\t\t\telse if ((yyvsp[0].i) == 2)\n\t\t\t  (yyval.i) = AF_INET6;\n\t\t\telse\n\t\t\t  (yyval.i) = -1;\t/* Invalid protocol.  */\n\t\t}\n#line 2537 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 959 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\tsnprintf (a, sizeof (a), \"%jd.%jd.%jd.%jd\",\n\t\t\t\t  (yyvsp[-10].i) & 0xff, (yyvsp[-8].i) & 0xff,\n\t\t\t\t  (yyvsp[-6].i) & 0xff, (yyvsp[-4].i) & 0xff);\n\t\t\tsnprintf (p, sizeof (p), \"%jd\",\n\t\t\t\t  (((yyvsp[-2].i) & 0xff) << 8) + ((yyvsp[0].i) & 0xff));\n\t\t\tmemset (&hints, 0, sizeof (hints));\n\t\t\thints.ai_family = his_addr.ss_family;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\t\t\thints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\tif (his_addr.ss_family == AF_INET6)\n\t\t\t  {\n\t\t\t    /* IPv4 mapped to IPv6.  */\n\t\t\t    hints.ai_family = AF_INET6;\n#ifdef AI_V4MAPPED\n\t\t\t    hints.ai_flags |= AI_V4MAPPED;\n#endif\n\t\t\t    snprintf (a, sizeof (a),\n\t\t\t\t      \"::ffff:%jd.%jd.%jd.%jd\",\n\t\t\t\t      (yyvsp[-10].i) & 0xff, (yyvsp[-8].i) & 0xff,\n\t\t\t\t      (yyvsp[-6].i) & 0xff, (yyvsp[-4].i) & 0xff);\n\t\t\t  }\n\n\t\t\terr = getaddrinfo (a, p, &hints, &res);\n\t\t\tif (err)\n\t\t\t  {\n\t\t\t    reply (550, \"Address failure: %s,%s\", a, p);\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    (yyval.i) = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    memcpy (&data_dest, res->ai_addr, res->ai_addrlen);\n\t\t\t    data_dest_len = res->ai_addrlen;\n\t\t\t    freeaddrinfo (res);\n\t\t\t    (yyval.i) = 1;\n\t\t\t  }\n\t\t}\n#line 2586 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 1009 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t/* Well formed input for IPv4?  */\n\t\t\tif ((yyvsp[-16].i) != 4 || (yyvsp[-14].i) != 4 || (yyvsp[-4].i) != 2\n\t\t\t    || (yyvsp[-12].i) < 0 || (yyvsp[-12].i) > 255 || (yyvsp[-10].i) < 0 || (yyvsp[-10].i) > 255\n\t\t\t    || (yyvsp[-8].i) < 0 || (yyvsp[-8].i) > 255 || (yyvsp[-6].i) < 0 || (yyvsp[-6].i) > 255\n\t\t\t    || (yyvsp[-2].i) < 0 || (yyvsp[-2].i) > 255\n\t\t\t    || (yyvsp[0].i) < 0 || (yyvsp[0].i) > 255)\n\t\t\t  {\n\t\t\t    reply (500, \"Invalid address.\");\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    (yyval.i) = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    snprintf (a, sizeof (a), \"%jd.%jd.%jd.%jd\",\n\t\t\t\t      (yyvsp[-12].i), (yyvsp[-10].i), (yyvsp[-8].i), (yyvsp[-6].i));\n\t\t\t    snprintf (p, sizeof (p), \"%jd\", ((yyvsp[-2].i) << 8) + (yyvsp[0].i));\n\n\t\t\t    memset (&hints, 0, sizeof (hints));\n\t\t\t    hints.ai_family = his_addr.ss_family;\n\t\t\t    hints.ai_socktype = SOCK_STREAM;\n\t\t\t    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t    if (his_addr.ss_family == AF_INET6)\n\t\t\t      {\n\t\t\t\t/* IPv4 mapped to IPv6.  */\n\t\t\t\thints.ai_family = AF_INET6;\n#ifdef AI_V4MAPPED\n\t\t\t\thints.ai_flags |= AI_V4MAPPED;\n#endif\n\t\t\t\tsnprintf (a, sizeof (a),\n\t\t\t\t\t  \"::ffff:%jd.%jd.%jd.%jd\",\n\t\t\t\t\t  (yyvsp[-12].i), (yyvsp[-10].i), (yyvsp[-8].i), (yyvsp[-6].i));\n\t\t\t      }\n\n\t\t\t    err = getaddrinfo (a, p, &hints, &res);\n\t\t\t    if (err)\n\t\t\t      {\n\t\t\t\treply (550, \"LPRT address failure: %s,%s\",\n\t\t\t\t       a, p);\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\tdata_dest_len = 0;\n\t\t\t\t(yyval.i) = 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\tres->ai_addrlen);\n\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t(yyval.i) = 1;\n\t\t\t      }\n\t\t\t  }\n\t\t}\n#line 2650 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 68:\n#line 1074 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t/* Well formed input for IPv6?  */\n\t\t\tif ((yyvsp[-40].i) != 6 || (yyvsp[-38].i) != 16 || (yyvsp[-4].i) != 2\n\t\t\t    || (yyvsp[-36].i) < 0 || (yyvsp[-36].i) > 255 || (yyvsp[-34].i) < 0 || (yyvsp[-34].i) > 255\n\t\t\t    || (yyvsp[-32].i) < 0 || (yyvsp[-32].i) > 255 || (yyvsp[-30].i) < 0 || (yyvsp[-30].i) > 255\n\t\t\t    || (yyvsp[-28].i) < 0 || (yyvsp[-28].i) > 255 || (yyvsp[-26].i) < 0 || (yyvsp[-26].i) > 255\n\t\t\t    || (yyvsp[-24].i) < 0 || (yyvsp[-24].i) > 255 || (yyvsp[-22].i) < 0 || (yyvsp[-22].i) > 255\n\t\t\t    || (yyvsp[-20].i) < 0 || (yyvsp[-20].i) > 255 || (yyvsp[-18].i) < 0 || (yyvsp[-18].i) > 255\n\t\t\t    || (yyvsp[-16].i) < 0 || (yyvsp[-16].i) > 255 || (yyvsp[-14].i) < 0 || (yyvsp[-14].i) > 255\n\t\t\t    || (yyvsp[-12].i) < 0 || (yyvsp[-12].i) > 255 || (yyvsp[-10].i) < 0 || (yyvsp[-10].i) > 255\n\t\t\t    || (yyvsp[-8].i) < 0 || (yyvsp[-8].i) > 255 || (yyvsp[-6].i) < 0 || (yyvsp[-6].i) > 255\n\t\t\t    || (yyvsp[-2].i) < 0 || (yyvsp[-2].i) > 255 || (yyvsp[0].i) < 0 || (yyvsp[0].i) > 255)\n\t\t\t  {\n\t\t\t    reply (500, \"Invalid address.\");\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    (yyval.i) = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    snprintf (a, sizeof (a),\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx\",\n\t\t\t\t      (yyvsp[-36].i), (yyvsp[-34].i), (yyvsp[-32].i), (yyvsp[-30].i),\n\t\t\t\t      (yyvsp[-28].i), (yyvsp[-26].i), (yyvsp[-24].i), (yyvsp[-22].i),\n\t\t\t\t      (yyvsp[-20].i), (yyvsp[-18].i), (yyvsp[-16].i), (yyvsp[-14].i),\n\t\t\t\t      (yyvsp[-12].i), (yyvsp[-10].i), (yyvsp[-8].i), (yyvsp[-6].i));\n\t\t\t    snprintf (p, sizeof (p), \"%jd\",\n\t\t\t\t      ((yyvsp[-2].i) << 8) + (yyvsp[0].i));\n\n\t\t\t    memset (&hints, 0, sizeof (hints));\n\t\t\t    hints.ai_family = his_addr.ss_family;\n\t\t\t    hints.ai_socktype = SOCK_STREAM;\n\t\t\t    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t    err = getaddrinfo (a, p, &hints, &res);\n\t\t\t    if (err)\n\t\t\t      {\n\t\t\t\treply (550, \"LPRT address failure: %s,%s\",\n\t\t\t\t       a, p);\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\tdata_dest_len = 0;\n\t\t\t\t(yyval.i) = 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\tres->ai_addrlen);\n\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t(yyval.i) = 1;\n\t\t\t      }\n\t\t\t  }\n\t\t}\n#line 2715 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 69:\n#line 1138 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = FORM_N;\n\t\t}\n#line 2723 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 70:\n#line 1142 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = FORM_T;\n\t\t}\n#line 2731 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 71:\n#line 1146 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = FORM_C;\n\t\t}\n#line 2739 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 72:\n#line 1153 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_A;\n\t\t\tcmd_form = FORM_N;\n\t\t}\n#line 2748 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 73:\n#line 1158 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_A;\n\t\t\tcmd_form = (yyvsp[0].i);\n\t\t}\n#line 2757 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 74:\n#line 1163 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_E;\n\t\t\tcmd_form = FORM_N;\n\t\t}\n#line 2766 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 75:\n#line 1168 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_E;\n\t\t\tcmd_form = (yyvsp[0].i);\n\t\t}\n#line 2775 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 76:\n#line 1173 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_I;\n\t\t}\n#line 2783 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 77:\n#line 1177 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_L;\n\t\t\tcmd_bytesz = NBBY;\n\t\t}\n#line 2792 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 78:\n#line 1182 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_L;\n\t\t\tcmd_bytesz = (yyvsp[0].i);\n\t\t}\n#line 2801 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 79:\n#line 1188 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tcmd_type = TYPE_L;\n\t\t\tcmd_bytesz = (yyvsp[0].i);\n\t\t}\n#line 2810 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 80:\n#line 1196 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = STRU_F;\n\t\t}\n#line 2818 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 81:\n#line 1200 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = STRU_R;\n\t\t}\n#line 2826 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 82:\n#line 1204 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = STRU_P;\n\t\t}\n#line 2834 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 83:\n#line 1211 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = MODE_S;\n\t\t}\n#line 2842 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 84:\n#line 1215 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = MODE_B;\n\t\t}\n#line 2850 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 85:\n#line 1219 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t(yyval.i) = MODE_C;\n\t\t}\n#line 2858 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 86:\n#line 1226 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\t/*\n\t\t\t * Problem: this production is used for all pathname\n\t\t\t * processing, but only gives a 550 error reply.\n\t\t\t * This is a valid reply in some cases but not in others.\n\t\t\t */\n\t\t\tif (cred.logged_in && (yyvsp[0].s) && *(yyvsp[0].s) == '~')\n\t\t\t  {\n\t\t\t    glob_t gl;\n\t\t\t    int flags = GLOB_NOCHECK;\n\n#ifdef GLOB_BRACE\n\t\t\t    flags |= GLOB_BRACE;\n#endif\n#ifdef GLOB_QUOTE\n\t\t\t    flags |= GLOB_QUOTE;\n#endif\n#ifdef GLOB_TILDE\n\t\t\t    flags |= GLOB_TILDE;\n#endif\n\n\t\t\t    memset (&gl, 0, sizeof (gl));\n\t\t\t    if (glob ((yyvsp[0].s), flags, NULL, &gl)\n\t\t\t\t|| gl.gl_pathc == 0)\n\t\t\t      {\n\t\t\t\treply (550, \"not found\");\n\t\t\t\t(yyval.s) = NULL;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      (yyval.s) = strdup (gl.gl_pathv[0]);\n\n\t\t\t    globfree (&gl);\n\t\t\t    free ((yyvsp[0].s));\n\t\t\t  }\n\t\t\telse\n\t\t\t  (yyval.s) = (yyvsp[0].s);\n\t\t}\n#line 2900 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 88:\n#line 1271 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tint ret, dec, multby, digit;\n\n\t\t\t/*\n\t\t\t * Convert a number that was read as decimal number\n\t\t\t * to what it would be if it had been read as octal.\n\t\t\t */\n\t\t\tdec = (yyvsp[0].i);\n\t\t\tmultby = 1;\n\t\t\tret = 0;\n\t\t\twhile (dec)\n\t\t\t  {\n\t\t\t    digit = dec % 10;\n\t\t\t    if (digit > 7)\n\t\t\t      {\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t      }\n\t\t\t    ret += digit * multby;\n\t\t\t    multby *= 8;\n\t\t\t    dec /= 10;\n\t\t\t  }\n\t\t\t(yyval.i) = ret;\n\t\t}\n#line 2929 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n  case 89:\n#line 1299 \"ftpcmd.y\" /* yacc.c:1646  */\n    {\n\t\t\tif (cred.logged_in)\n\t\t\t  (yyval.i) = 1;\n\t\t\telse\n\t\t\t  {\n\t\t\t    reply (530, \"Please login with USER and PASS.\");\n\t\t\t    (yyval.i) = 0;\n\t\t\t  }\n\t\t}\n#line 2943 \"ftpcmd.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2947 \"ftpcmd.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\\n                                        yyssp, yytoken)\n      {\n        char const *yymsgp = YY_(\"syntax error\");\n        int yysyntax_error_status;\n        yysyntax_error_status = YYSYNTAX_ERROR;\n        if (yysyntax_error_status == 0)\n          yymsgp = yymsg;\n        else if (yysyntax_error_status == 1)\n          {\n            if (yymsg != yymsgbuf)\n              YYSTACK_FREE (yymsg);\n            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);\n            if (!yymsg)\n              {\n                yymsg = yymsgbuf;\n                yymsg_alloc = sizeof yymsgbuf;\n                yysyntax_error_status = 2;\n              }\n            else\n              {\n                yysyntax_error_status = YYSYNTAX_ERROR;\n                yymsgp = yymsg;\n              }\n          }\n        yyerror (yymsgp);\n        if (yysyntax_error_status == 2)\n          goto yyexhaustedlab;\n      }\n# undef YYSYNTAX_ERROR\n#endif\n    }\n\n\n\n  if (yyerrstatus == 3)\n    {\n      /* If just tried and failed to reuse lookahead token after an\n         error, discard it.  */\n\n      if (yychar <= YYEOF)\n        {\n          /* Return failure if at end of input.  */\n          if (yychar == YYEOF)\n            YYABORT;\n        }\n      else\n        {\n          yydestruct (\"Error: discarding\",\n                      yytoken, &yylval);\n          yychar = YYEMPTY;\n        }\n    }\n\n  /* Else will try to reuse lookahead token after shifting the error\n     token.  */\n  goto yyerrlab1;\n\n\n/*---------------------------------------------------.\n| yyerrorlab -- error raised explicitly by YYERROR.  |\n`---------------------------------------------------*/\nyyerrorlab:\n\n  /* Pacify compilers like GCC when the user code never invokes\n     YYERROR and the label yyerrorlab therefore never appears in user\n     code.  */\n  if (/*CONSTCOND*/ 0)\n     goto yyerrorlab;\n\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYERROR.  */\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n  yystate = *yyssp;\n  goto yyerrlab1;\n\n\n/*-------------------------------------------------------------.\n| yyerrlab1 -- common code for both syntax error and YYERROR.  |\n`-------------------------------------------------------------*/\nyyerrlab1:\n  yyerrstatus = 3;      /* Each real token shifted decrements this.  */\n\n  for (;;)\n    {\n      yyn = yypact[yystate];\n      if (!yypact_value_is_default (yyn))\n        {\n          yyn += YYTERROR;\n          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)\n            {\n              yyn = yytable[yyn];\n              if (0 < yyn)\n                break;\n            }\n        }\n\n      /* Pop the current state because it cannot handle the error token.  */\n      if (yyssp == yyss)\n        YYABORT;\n\n\n      yydestruct (\"Error: popping\",\n                  yystos[yystate], yyvsp);\n      YYPOPSTACK (1);\n      yystate = *yyssp;\n      YY_STACK_PRINT (yyss, yyssp);\n    }\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n\n  /* Shift the error token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);\n\n  yystate = yyn;\n  goto yynewstate;\n\n\n/*-------------------------------------.\n| yyacceptlab -- YYACCEPT comes here.  |\n`-------------------------------------*/\nyyacceptlab:\n  yyresult = 0;\n  goto yyreturn;\n\n/*-----------------------------------.\n| yyabortlab -- YYABORT comes here.  |\n`-----------------------------------*/\nyyabortlab:\n  yyresult = 1;\n  goto yyreturn;\n\n#if !defined yyoverflow || YYERROR_VERBOSE\n/*-------------------------------------------------.\n| yyexhaustedlab -- memory exhaustion comes here.  |\n`-------------------------------------------------*/\nyyexhaustedlab:\n  yyerror (YY_(\"memory exhausted\"));\n  yyresult = 2;\n  /* Fall through.  */\n#endif\n\nyyreturn:\n  if (yychar != YYEMPTY)\n    {\n      /* Make sure we have latest lookahead translation.  See comments at\n         user semantic actions for why this is necessary.  */\n      yytoken = YYTRANSLATE (yychar);\n      yydestruct (\"Cleanup: discarding lookahead\",\n                  yytoken, &yylval);\n    }\n  /* Do not reclaim the symbols of the rule whose action triggered\n     this YYABORT or YYACCEPT.  */\n  YYPOPSTACK (yylen);\n  YY_STACK_PRINT (yyss, yyssp);\n  while (yyssp != yyss)\n    {\n      yydestruct (\"Cleanup: popping\",\n                  yystos[*yyssp], yyvsp);\n      YYPOPSTACK (1);\n    }\n#ifndef yyoverflow\n  if (yyss != yyssa)\n    YYSTACK_FREE (yyss);\n#endif\n#if YYERROR_VERBOSE\n  if (yymsg != yymsgbuf)\n    YYSTACK_FREE (yymsg);\n#endif\n  return yyresult;\n}",
      "lines": 1793,
      "depth": 50,
      "decorators": [
        "int"
      ]
    },
    "lookup": {
      "start_point": [
        3279,
        0
      ],
      "end_point": [
        3286,
        1
      ],
      "content": "static struct tab *\nlookup (struct tab *p, char *cmd)\n{\n  for (; p->name != NULL; p++)\n    if (strcmp (cmd, p->name) == 0)\n      return (p);\n  return (0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct tab",
        "struct",
        "tab",
        "*\nlookup (struct tab *p, char *cmd)",
        "*"
      ]
    },
    "telnet_fgets": {
      "start_point": [
        3293,
        0
      ],
      "end_point": [
        3387,
        1
      ],
      "content": "char *\ntelnet_fgets (char *s, int n, FILE *iop)\n{\n  int c;\n  register char *cs;\n\n  cs = s;\n/* tmpline may contain saved command from urgent mode interruption */\n  for (c = 0; tmpline[c] != '\\0' && --n > 0; ++c)\n    {\n      *cs++ = tmpline[c];\n      if (tmpline[c] == '\\n')\n\t{\n\t  *cs++ = '\\0';\n\t  if (debug)\n\t    syslog (LOG_DEBUG, \"command: %s\", s);\n\t  tmpline[0] = '\\0';\n\t  return (s);\n\t}\n\n      if (c == 0)\n\ttmpline[0] = '\\0';\n    }\n\n  while ((c = getc (iop)) != EOF)\n    {\n      c &= 0377;\n      if (c == IAC)\n\t{\n\t  c = getc (iop);\n\t  if (c != EOF)\n\t    {\n\t      c &= 0377;\n\t      switch (c)\n\t\t{\n\t\tcase WILL:\n\t\tcase WONT:\n\t\t  c = getc (iop);\n\t\t  printf (\"%c%c%c\", IAC, DONT, 0377 & c);\n\t\t  fflush (stdout);\n\t\t  continue;\n\n\t\tcase DO:\n\t\tcase DONT:\n\t\t  c = getc (iop);\n\t\t  printf (\"%c%c%c\", IAC, WONT, 0377 & c);\n\t\t  fflush (stdout);\n\t\t  continue;\n\n\t\tcase IAC:\n\t\t  break;\n\n\t\tdefault:\n\t\t  continue;\t/* ignore command */\n\t\t}\n\t    }\n\t}\n\n      *cs++ = c;\n      if (--n <= 0 || c == '\\n')\n\tbreak;\n    }\n\n  if (c == EOF && cs == s)\n    return (NULL);\n\n  *cs++ = '\\0';\n\n  if (debug)\n    {\n      if (!cred.guest && strncasecmp (\"pass \", s, 5) == 0)\n\t{\n\t  /* Don't syslog passwords.  */\n\t  syslog (LOG_DEBUG, \"command: %.5s ???\", s);\n\t}\n      else\n\t{\n\t  register char *cp;\n\t  register int len;\n\n\t  /* Don't syslog trailing CR-LF.  */\n\t  len = strlen (s);\n\t  cp = s + len - 1;\n\n\t  while (cp >= s && (*cp == '\\n' || *cp == '\\r'))\n\t    {\n\t      --cp;\n\t      --len;\n\t    }\n\n\t  syslog (LOG_DEBUG, \"command: %.*s\", len, s);\n\t}\n    }\n  return (s);\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "char",
        "*\ntelnet_fgets (char *s, int n, FILE *iop)",
        "*"
      ]
    },
    "toolong": {
      "start_point": [
        3389,
        0
      ],
      "end_point": [
        3399,
        1
      ],
      "content": "void\ntoolong (int signo)\n{\n  (void) signo;\n  reply (421, \"Timeout (%d seconds): closing control connection.\",\n\t timeout);\n  if (logging)\n    syslog (LOG_INFO, \"User %s timed out after %d seconds\",\n\t    (cred.name ? cred.name : \"unknown\"), timeout);\n  dologout (1);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yylex": {
      "start_point": [
        3401,
        0
      ],
      "end_point": [
        3722,
        1
      ],
      "content": "static int\nyylex (void)\n{\n  static int cpos, state;\n  char *cp, *cp2;\n  struct tab *p;\n  int n;\n  char c;\n\n  for (;;)\n    {\n      switch (state)\n\t{\n\tcase CMD:\n\t  signal (SIGALRM, toolong);\n\t  alarm ((unsigned) timeout);\n\t  if (telnet_fgets (cbuf, sizeof (cbuf)-1, stdin) == NULL)\n\t    {\n\t      reply (221, \"You could at least say goodbye.\");\n\t      dologout (0);\n\t    }\n\t  alarm (0);\n\n#ifdef HAVE_SETPROCTITLE\n\t  if (strncasecmp (cbuf, \"PASS\", 4) != 0)\n\t    setproctitle (\"%s: %s\", proctitle, cbuf);\n#endif /* HAVE_SETPROCTITLE */\n\n\t  cp = strchr (cbuf, '\\r');\n\t  if (cp)\n\t    {\n\t      *cp++ = '\\n';\n\t      *cp = '\\0';\n\t    }\n\n\t  cp = strpbrk (cbuf, \" \\n\");\n\t  if (cp)\n\t    cpos = cp - cbuf;\n\n\t  if (cpos == 0)\n\t    cpos = 4;\n\n\t  c = cbuf[cpos];\n\t  cbuf[cpos] = '\\0';\n\t  upper (cbuf);\n\t  p = lookup (cmdtab, cbuf);\n\t  cbuf[cpos] = c;\n\n\t  if (p != 0)\n\t    {\n\t      if (p->implemented == 0)\n\t\t{\n\t\t  nack (p->name);\n\t\t  longjmp (errcatch, 0);\n\t\t  /* NOTREACHED */\n\t\t}\n\t      state = p->state;\n\t      yylval.s = (char*) p->name;\n\t      return (p->token);\n\t    }\n\t  break;\t/* Command not known.  */\n\n\tcase SITECMD:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      return (SP);\n\t    }\n\t  cp = &cbuf[cpos];\n\n\t  cp2 = strpbrk (cp, \" \\n\");\n\t  if (cp2)\n\t    cpos = cp2 - cbuf;\n\n\t  c = cbuf[cpos];\n\t  cbuf[cpos] = '\\0';\n\t  upper (cp);\n\t  p = lookup (sitetab, cp);\n\t  cbuf[cpos] = c;\n\n\t  if (p != 0)\n\t    {\n\t      if (p->implemented == 0)\n\t\t{\n\t\t  state = CMD;\n\t\t  nack (p->name);\n\t\t  longjmp (errcatch, 0);\n\t\t  /* NOTREACHED */\n\t\t}\n\n\t      state = p->state;\n\t      yylval.s = (char*) p->name;\n\t      return (p->token);\n\t    }\n\t  state = CMD;\n\t  break;\t/* Command not known.  */\n\n\tcase OSTR:\n\t  if (cbuf[cpos] == '\\n')\n\t    {\n\t      state = CMD;\n\t      return (CRLF);\n\t    }\n\n\tcase STR1:\n\tcase ZSTR1:\n\tdostr1:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      if (state == OSTR)\n\t\tstate = STR2;\n\t      else\n\t\t++state;\n\n\t      return (SP);\n\t    }\n\t  /* Intentional continuation.  */\n\n\tcase ZSTR2:\n\t  if (cbuf[cpos] == '\\n')\n\t    {\n\t      state = CMD;\n\t      return (CRLF);\n\t    }\n\n\tcase STR2:\n\t  cp = &cbuf[cpos];\n\t  n = strlen (cp);\n\t  cpos += n - 1;\n\t  /*\n\t   * Make sure the string is nonempty and newline terminated.\n\t   */\n\t  if (n > 1 && cbuf[cpos] == '\\n')\n\t    {\n\t      cbuf[cpos] = '\\0';\n\t      yylval.s = copy (cp);\n\t      cbuf[cpos] = '\\n';\n\t      state = ARGS;\n\t      return (STRING);\n\t    }\n\t  break;\t/* Empty string, missing NL.  */\n\n\tcase NSTR:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      return (SP);\n\t    }\n\t  if (isdigit (cbuf[cpos]))\n\t    {\n\t      cp = &cbuf[cpos];\n\t      while (isdigit (cbuf[++cpos]))\n\t\t;\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      yylval.i = atoi (cp);\n\t      cbuf[cpos] = c;\n\t      state = STR1;\n\t      return (NUMBER);\n\t    }\n\t  state = STR1;\n\t  goto dostr1;\n\n\tcase DLIST:\n\t  /* Either numerical strings or\n\t   * address strings for IPv4 and IPv6.\n\t   * The consist of hexadecimal chars,\n\t   * colon and periods.  A period can\n\t   * not begin a valid address.  */\n\t  if (isxdigit (cbuf[cpos]) || cbuf[cpos] == ':')\n\t    {\n\t      int is_num = 1;\t/* Only to turn off.  */\n\n\t      cp = &cbuf[cpos];\n\t      while (isxdigit (cbuf[cpos])\n\t\t     || cbuf[cpos] == ':'\n\t\t     || cbuf[cpos] == '.')\n\t\t{\n\t\t  if (!isdigit (cbuf[cpos]))\n\t\t    is_num = 0;\n\t\t  cpos++;\n\t\t}\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      if (is_num)\n\t\t{\n\t\t  yylval.i = atoi (cp);\n\t\t  cbuf[cpos] = c;\n\t\t  return (NUMBER);\n\t\t}\n\t      else\n\t\t{\n\t\t  yylval.s = copy (cp);\n\t\t  cbuf[cpos] = c;\n\t\t  return (STRING);\n\t\t}\n\t    }\n\n\t  c = cbuf[cpos++];\n\t  switch (c)\n\t    {\n\t    case ' ':\n\t      return (SP);\n\n\t    case '\\n':\n\t      state = CMD;\n\t      return (CRLF);\n\n\t    default:\n\t      yylval.i = c;\n\t      return (CHAR);\n\t    }\n\t  break;\t/* Not reachable.  */\n\n\tcase ARGS:\n\t  if (isdigit (cbuf[cpos]))\n\t    {\n\t      cp = &cbuf[cpos];\n\t      while (isdigit (cbuf[++cpos]))\n\t\t;\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      yylval.i = strtoimax (cp, NULL, 10);\t/* off_t */\n\t      cbuf[cpos] = c;\n\t      return (NUMBER);\n\t    }\n\n\t  switch (cbuf[cpos++])\n\t    {\n\t    case '\\n':\n\t      state = CMD;\n\t      return (CRLF);\n\n\t    case ' ':\n\t      return (SP);\n\n\t    case ',':\n\t      return (COMMA);\n\n\t    case 'A':\n\t    case 'a':\n\t      return (A);\n\n\t    case 'B':\n\t    case 'b':\n\t      return (B);\n\n\t    case 'C':\n\t    case 'c':\n\t      return (C);\n\n\t    case 'E':\n\t    case 'e':\n\t      return (E);\n\n\t    case 'F':\n\t    case 'f':\n\t      return (F);\n\n\t    case 'I':\n\t    case 'i':\n\t      return (I);\n\n\t    case 'L':\n\t    case 'l':\n\t      return (L);\n\n\t    case 'N':\n\t    case 'n':\n\t      return (N);\n\n\t    case 'P':\n\t    case 'p':\n\t      return (P);\n\n\t    case 'R':\n\t    case 'r':\n\t      return (R);\n\n\t    case 'S':\n\t    case 's':\n\t      return (S);\n\n\t    case 'T':\n\t    case 't':\n\t      return (T);\n\t    }\n\t  break;\t/* No number, not in [\\n ,aAbBcCeEfFiIlLnNpPrRsSttT] */\n\n\tdefault:\n\t  fatal (\"Unknown state in scanner.\");\n\t}\n\n      /*\n       * Analysis: Cases when this point is reached.\n       *\n       *  CMD:      command not known\n       *  SITECMD:  site command not known (state changed to CMD)\n       *\n       *  OSTR, STR1, ZSTR1, STR2, ZSTR2, NSTR:\n       *            empty string or string without NL\n       *\n       *  ARGS:     not a number, not a special character\n       */\n\n      /*\n       * Issue a new error message only if the parser has not\n       * yet reported a complaint.  Without this precaution\n       * two messages would be directed to the client, thus\n       * upsetting all following exchange.\n       */\n      if (!yynerrs)\n\tyyerror (\"command not recognized\");\n\n      state = CMD;\n      longjmp (errcatch, 0);\n    } /* for (;;) */\n}",
      "lines": 322,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "upper": {
      "start_point": [
        3724,
        0
      ],
      "end_point": [
        3733,
        1
      ],
      "content": "void\nupper (char *s)\n{\n  while (*s != '\\0')\n    {\n      if (islower (*s))\n\t*s = toupper (*s);\n      s++;\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "copy": {
      "start_point": [
        3735,
        0
      ],
      "end_point": [
        3746,
        1
      ],
      "content": "static char *\ncopy (char *s)\n{\n  char *p;\n\n  p = malloc (strlen (s) + 1);\n  if (p == NULL)\n    fatal (\"Ran out of memory.\");\n\n  strcpy (p, s);\n  return (p);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncopy (char *s)",
        "*"
      ]
    },
    "help": {
      "start_point": [
        3748,
        0
      ],
      "end_point": [
        3826,
        1
      ],
      "content": "static void\nhelp (struct tab *ctab, char *s)\n{\n  struct tab *c;\n  int width, NCMDS;\n  const char *help_type;\n\n  if (ctab == sitetab)\n    help_type = \"SITE \";\n  else\n    help_type = \"\";\n\n  width = 0, NCMDS = 0;\n  for (c = ctab; c->name != NULL; c++)\n    {\n      int len = strlen (c->name);\n\n      if (len > width)\n\twidth = len;\n\n      NCMDS++;\n    }\n\n  width = (width + 8) &~ 7;\n\n  if (s == 0)\n    {\n      int i, j, w;\n      int columns, lines;\n\n      lreply (214, \"The following %scommands are recognized %s.\",\n\t      help_type, \"(* =>'s unimplemented)\");\n\n      columns = 76 / width;\n      if (columns == 0)\n\tcolumns = 1;\n\n      lines = (NCMDS + columns - 1) / columns;\n\n      for (i = 0; i < lines; i++)\n\t{\n\t  printf (\"   \");\n\t  for (j = 0; j < columns; j++)\n\t    {\n\t      c = ctab + j * lines + i;\n\t      printf (\"%s%c\", c->name, c->implemented ? ' ' : '*');\n\n\t      if (c + lines >= &ctab[NCMDS])\n\t\tbreak;\n\n\t      w = strlen (c->name) + 1;\n\t      while (w < width)\n\t\t{\n\t\t  putchar (' ');\n\t\t  w++;\n\t\t}\n\t    }\n\t  printf (\"\\r\\n\");\n\t}\n      fflush (stdout);\n      reply (214, \"Direct comments to ftp-bugs@%s.\", hostname);\n      return;\n    }\n\n  upper (s);\n\n  c = lookup (ctab, s);\n  if (c == (struct tab *) 0)\n    {\n      reply (502, \"Unknown command %s.\", s);\n      return;\n    }\n\n  if (c->implemented)\n    reply (214, \"Syntax: %s%s %s\", help_type, c->name, c->help);\n  else\n    reply (214, \"%s%-*s\\t%s; unimplemented.\", help_type,\n\t   width, c->name, c->help);\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sizecmd": {
      "start_point": [
        3828,
        0
      ],
      "end_point": [
        3882,
        1
      ],
      "content": "static void\nsizecmd (char *filename)\n{\n  switch (type)\n    {\n    case TYPE_L:\n    case TYPE_I:\n      {\n\tstruct stat stbuf;\n\n\tif (stat (filename, &stbuf) < 0 || !S_ISREG (stbuf.st_mode))\n\t  reply (550, \"%s: not a plain file.\", filename);\n\telse\n\t  reply (213, \"%ju\", (uintmax_t) stbuf.st_size);\n\tbreak;\n      }\n\n    case TYPE_A:\n      {\n\tFILE *fin;\n\tint c;\n\toff_t count;\n\tstruct stat stbuf;\n\n\tfin = fopen (filename, \"r\");\n\tif (fin == NULL)\n\t  {\n\t    perror_reply (550, filename);\n\t    return;\n\t  }\n\n\tif (fstat (fileno (fin), &stbuf) < 0 || !S_ISREG (stbuf.st_mode))\n\t  {\n\t    reply (550, \"%s: not a plain file.\", filename);\n\t    fclose (fin);\n\t    return;\n\t  }\n\n\tcount = 0;\n\twhile ((c = getc (fin)) != EOF)\n\t  {\n\t    if (c == '\\n')\t/* will get expanded to \\r\\n */\n\t      count++;\n\t    count++;\n\t  }\n\tfclose (fin);\n\n\treply (213, \"%jd\", (intmax_t) count);\n\tbreak;\n      }\n\n    default:\n      reply (504, \"SIZE not implemented for Type %c.\", \"?AEIL\"[type]);\n    }\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        3884,
        0
      ],
      "end_point": [
        3894,
        1
      ],
      "content": "static void\nyyerror (const char *s)\n{\n  char *cp;\n\n  cp = strchr (cbuf, '\\n');\n  if (cp != NULL)\n    *cp = '\\0';\n\n  reply (500, \"'%s': %s\", cbuf, (s ? s : \"command not understood.\"));\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/ftpcmd.y": {
    "CHMOD": {
      "start_point": [
        175,
        22
      ],
      "end_point": [
        192,
        3
      ],
      "content": "octal_number byte_size\n%type\t<i> struct_code mode_code type_code form_code\n%type\t<s> pathstring pathname password username\n%type\t<i> host_port net_proto tcp_port long_host_port\n%type\t<s> net_addr\n\n%start\tcmd_list\n\n%%\n\ncmd_list\n\t: /* empty */\n\t| cmd_list cmd\n\t\t{\n\t\t\tfree (fromname);\n\t\t\tfromname = (char *) 0;\n\t\t\trestart_point = (off_t) 0;\n\t\t}",
      "lines": 18,
      "depth": 8,
      "decorators": null
    },
    "rcmd": {
      "start_point": [
        197,
        8
      ],
      "end_point": [
        201,
        3
      ],
      "content": "SP username CRLF\n\t\t{\n\t\t\tuser ($3);\n\t\t\tfree ($3);\n\t\t}",
      "lines": 5,
      "depth": 5,
      "decorators": null
    },
    "SP": [
      {
        "start_point": [
          202,
          11
        ],
        "end_point": [
          207,
          3
        ],
        "content": "password CRLF\n\t\t{\n\t\t\tpass ($3);\n\t\t\tmemset ($3, 0, strlen ($3));\n\t\t\tfree ($3);\n\t\t}",
        "lines": 6,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          252,
          11
        ],
        "end_point": [
          289,
          3
        ],
        "content": "type_code CRLF\n\t\t{\n\t\t\tswitch (cmd_type)\n\t\t\t  {\n\t\t\t  case TYPE_A:\n\t\t\t    if (cmd_form == FORM_N)\n\t\t\t      {\n\t\t\t\treply (200, \"Type set to A.\");\n\t\t\t\ttype = cmd_type;\n\t\t\t\tform = cmd_form;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (504, \"Form must be N.\");\n\t\t\t    break;\n\n\t\t\t  case TYPE_E:\n\t\t\t    reply (504, \"Type E not implemented.\");\n\t\t\t    break;\n\n\t\t\t  case TYPE_I:\n\t\t\t    reply (200, \"Type set to I.\");\n\t\t\t    type = cmd_type;\n\t\t\t    break;\n\n\t\t\t  case TYPE_L:\n#if defined NBBY && NBBY == 8\n\t\t\t    if (cmd_bytesz == 8)\n\t\t\t      {\n\t\t\t\treply (200, \"Type set to L (byte size 8).\");\n\t\t\t\ttype = cmd_type;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (504, \"Byte size must be 8.\");\n#else /* NBBY == 8 */\n\t\t\t  UNIMPLEMENTED for NBBY != 8\n#endif /* NBBY == 8 */\n\t\t\t  }\n\t\t}",
        "lines": 38,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          290,
          11
        ],
        "end_point": [
          301,
          3
        ],
        "content": "struct_code CRLF\n\t\t{\n\t\t\tswitch ($3)\n\t\t\t  {\n\t\t\t  case STRU_F:\n\t\t\t    reply (200, \"STRU F ok.\");\n\t\t\t    break;\n\n\t\t\t  default:\n\t\t\t    reply (504, \"Unimplemented STRU type.\");\n\t\t\t  }\n\t\t}",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          302,
          11
        ],
        "end_point": [
          313,
          3
        ],
        "content": "mode_code CRLF\n\t\t{\n\t\t\tswitch ($3)\n\t\t\t  {\n\t\t\t  case MODE_S:\n\t\t\t    reply (200, \"MODE S ok.\");\n\t\t\t    break;\n\n\t\t\t  default:\n\t\t\t    reply (502, \"Unimplemented MODE type.\");\n\t\t\t  }\n\t\t}",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          314,
          11
        ],
        "end_point": [
          317,
          3
        ],
        "content": "NUMBER CRLF\n\t\t{\n\t\t\treply (202, \"ALLO command ignored.\");\n\t\t}",
        "lines": 4,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          318,
          26
        ],
        "end_point": [
          321,
          3
        ],
        "content": "NUMBER CRLF\n\t\t{\n\t\t\treply (202, \"ALLO command ignored.\");\n\t\t}",
        "lines": 4,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          412,
          11
        ],
        "end_point": [
          429,
          3
        ],
        "content": "STRING CRLF\n\t\t{\n\t\t\tchar *cp = $3;\n\n\t\t\tif (strncasecmp (cp, \"SITE\", 4) == 0)\n\t\t\t  {\n\t\t\t    cp = $3 + 4;\n\t\t\t    if (*cp == ' ')\n\t\t\t      cp++;\n\t\t\t    if (*cp)\n\t\t\t      help (sitetab, cp);\n\t\t\t    else\n\t\t\t      help (sitetab, (char *) 0);\n\t\t\t  }\n\t\t\telse\n\t\t\t  help (cmdtab, $3);\n\t\t\tfree ($3);\n\t\t}",
        "lines": 18,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          430,
          3
        ],
        "end_point": [
          433,
          3
        ],
        "content": "NOOP CRLF\n\t\t{\n\t\t\treply (200, \"NOOP command successful.\");\n\t\t}",
        "lines": 4,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          496,
          11
        ],
        "end_point": [
          499,
          3
        ],
        "content": "HELP CRLF\n\t\t{\n\t\t\thelp (sitetab, (char *) 0);\n\t\t}",
        "lines": 4,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          500,
          19
        ],
        "end_point": [
          504,
          3
        ],
        "content": "STRING CRLF\n\t\t{\n\t\t\thelp (sitetab, $5);\n\t\t\tfree ($5);\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          505,
          11
        ],
        "end_point": [
          515,
          3
        ],
        "content": "UMASK check_login CRLF\n\t\t{\n\t\t\tint oldmask;\n\n\t\t\tif ($4)\n\t\t\t  {\n\t\t\t    oldmask = umask (0);\n\t\t\t    umask (oldmask);\n\t\t\t    reply (200, \"Current UMASK is %03o\", oldmask);\n\t\t\t  }\n\t\t}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          546,
          11
        ],
        "end_point": [
          551,
          3
        ],
        "content": "IDLE CRLF\n\t\t{\n\t\t\treply (200,\n\t\t\t       \"Current IDLE time limit is %d seconds; max %d\",\n\t\t\t       timeout, maxtimeout);\n\t\t}",
        "lines": 6,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          892,
          23
        ],
        "end_point": [
          902,
          3
        ],
        "content": "pathname CRLF\n\t\t{\n\t\t\trestart_point = (off_t) 0;\n\t\t\tif ($2 && $4)\n\t\t\t  {\n\t\t\t    free (fromname);\n\t\t\t    fromname = renamefrom ($4);\n\t\t\t  }\n\t\t\tif (fromname == (char *) 0 && $4)\n\t\t\t  free ($4);\n\t\t}",
        "lines": 11,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          907,
          11
        ],
        "end_point": [
          915,
          3
        ],
        "content": "byte_size CRLF\n\t\t{\n\t\t        free (fromname);\n\t\t\tfromname = (char *) 0;\n\t\t\trestart_point = $3;\n\t\t\treply (350, \"Restarting at %jd. %s\",\n\t\t\t       (intmax_t) restart_point,\n\t\t\t       \"Send STORE or RETRIEVE to initiate transfer.\");\n\t\t}",
        "lines": 9,
        "depth": 8,
        "decorators": null
      }
    ],
    "check_login": [
      {
        "start_point": [
          208,
          20
        ],
        "end_point": [
          246,
          3
        ],
        "content": "SP host_port CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    if ($4\n\t\t\t\t&& ((his_addr.ss_family == AF_INET\n\t\t\t\t     && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t&((struct sockaddr_in *) &data_dest)->sin_addr,\n\t\t\t\t\t\tsizeof (struct in_addr))\n\t\t\t\t\t== 0\n\t\t\t\t     && ntohs (((struct sockaddr_in *) &data_dest)->sin_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t    ||\n\t\t\t\t    (his_addr.ss_family == AF_INET6\n\t\t\t\t     && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t\t&((struct sockaddr_in6 *) &data_dest)->sin6_addr,\n\t\t\t\t\t\tsizeof (struct in6_addr))\n\t\t\t\t\t== 0\n\t\t\t\t     && ntohs (((struct sockaddr_in6 *) &data_dest)->sin6_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t   )\n\t\t\t       )\n\t\t\t      {\n\t\t\t\tusedefault = 0;\n\t\t\t\tif (pdata >= 0)\n\t\t\t\t  {\n\t\t\t\t    close (pdata);\n\t\t\t\t    pdata = -1;\n\t\t\t\t  }\n\t\t\t\treply (200, \"PORT command successful.\");\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tusedefault = 1;\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\treply (500, \"Illegal PORT Command\");\n\t\t\t      }\n\t\t\t  }\n\t\t}",
        "lines": 39,
        "depth": 22,
        "decorators": null
      },
      {
        "start_point": [
          247,
          3
        ],
        "end_point": [
          251,
          3
        ],
        "content": "PASV check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  passive (PASSIVE_PASV, AF_INET);\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          322,
          20
        ],
        "end_point": [
          327,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  retrieve ((char *) 0, $4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          328,
          20
        ],
        "end_point": [
          333,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  store ($4, \"w\", 0);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          334,
          20
        ],
        "end_point": [
          339,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  store ($4, \"a\", 0);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          340,
          3
        ],
        "end_point": [
          344,
          3
        ],
        "content": "NLST check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  send_file_list (\".\");\n\t\t}",
        "lines": 5,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          345,
          20
        ],
        "end_point": [
          350,
          3
        ],
        "content": "SP STRING CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  send_file_list ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          351,
          3
        ],
        "end_point": [
          355,
          3
        ],
        "content": "LIST check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  retrieve (\"/bin/ls -lgA\", \"\");\n\t\t}",
        "lines": 5,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          356,
          20
        ],
        "end_point": [
          361,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  retrieve (\"/bin/ls -lgA %s\", $4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          362,
          20
        ],
        "end_point": [
          367,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  statfilecmd ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          368,
          3
        ],
        "end_point": [
          371,
          3
        ],
        "content": "STAT CRLF\n\t\t{\n\t\t\tstatcmd ();\n\t\t}",
        "lines": 4,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          372,
          20
        ],
        "end_point": [
          377,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  delete ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          378,
          20
        ],
        "end_point": [
          392,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    if (fromname)\n\t\t\t      {\n\t\t\t\trenamecmd (fromname, $4);\n\t\t\t\tfree (fromname);\n\t\t\t\tfromname = (char *) 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      reply (503, \"Bad sequence of commands.\");\n\t\t\t  }\n\t\t\tfree ($4);\n\t\t}",
        "lines": 15,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          393,
          3
        ],
        "end_point": [
          396,
          3
        ],
        "content": "ABOR CRLF\n\t\t{\n\t\t\treply (225, \"ABOR command successful.\");\n\t\t}",
        "lines": 4,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          397,
          3
        ],
        "end_point": [
          401,
          3
        ],
        "content": "CWD check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  cwd (cred.homedir);\n\t\t}",
        "lines": 5,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          402,
          19
        ],
        "end_point": [
          407,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  cwd ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          408,
          3
        ],
        "end_point": [
          411,
          3
        ],
        "content": "HELP CRLF\n\t\t{\n\t\t\thelp (cmdtab, (char *) 0);\n\t\t}",
        "lines": 4,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          434,
          19
        ],
        "end_point": [
          439,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  makedir ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          440,
          19
        ],
        "end_point": [
          445,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  removedir ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          446,
          3
        ],
        "end_point": [
          450,
          3
        ],
        "content": "PWD check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  pwd ();\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          451,
          3
        ],
        "end_point": [
          455,
          3
        ],
        "content": "CDUP check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  cwd (\"..\");\n\t\t}",
        "lines": 5,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          456,
          3
        ],
        "end_point": [
          467,
          3
        ],
        "content": "FEAT check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    char **name;\n\n\t\t\t    lreply (211, \"Supported extensions:\");\n\t\t\t    for (name = extlist; *name; name++)\n\t\t\t      printf (\" %s\\r\\n\", *name);\n\t\t\t    reply (211, \"End\");\n\t\t\t  }\n\t\t}",
        "lines": 12,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          469,
          20
        ],
        "end_point": [
          476,
          3
        ],
        "content": "SP STRING CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    reply (501, \"Not accepting arguments.\");\n\t\t\t    free ($4);\n\t\t\t  }\n\t\t}",
        "lines": 8,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          481,
          3
        ],
        "end_point": [
          487,
          3
        ],
        "content": "OPTS check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    reply (501, \"Must have an argument.\");\n\t\t\t  }\n\t\t}",
        "lines": 7,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          488,
          20
        ],
        "end_point": [
          495,
          3
        ],
        "content": "SP STRING CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    reply (501, \"No options are available.\");\n\t\t\t    free ($4);\n\t\t\t  }\n\t\t}",
        "lines": 8,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          516,
          29
        ],
        "end_point": [
          531,
          3
        ],
        "content": "SP octal_number CRLF\n\t\t{\n\t\t\tint oldmask;\n\n\t\t\tif ($4)\n\t\t\t  {\n\t\t\t    if (($6 == -1) || ($6 > 0777))\n\t\t\t      reply (501, \"Bad UMASK value\");\n\t\t\t    else\n\t\t\t      {\n\t\t\t\toldmask = umask ($6);\n\t\t\t\treply (200, \"UMASK set to %03o (was %03o)\",\n\t\t\t\t      $6, oldmask);\n\t\t\t      }\n\t\t\t  }\n\t\t}",
        "lines": 16,
        "depth": 12,
        "decorators": null
      },
      {
        "start_point": [
          552,
          28
        ],
        "end_point": [
          569,
          3
        ],
        "content": "SP NUMBER CRLF\n\t\t{\n\t\t\tif ($4)\n\t\t\t  {\n\t\t\t    if ($6 < 30 || $6 > maxtimeout)\n\t\t\t      reply (501,\n\t\t\t\t     \"Maximum IDLE time must be between 30 and %d seconds\",\n\t\t\t\t     maxtimeout);\n\t\t\t    else\n\t\t\t      {\n\t\t\t\ttimeout = $6;\n\t\t\t\talarm ((unsigned) timeout);\n\t\t\t\treply (200,\n\t\t\t\t       \"Maximum IDLE time set to %d seconds\",\n\t\t\t\t       timeout);\n\t\t\t      }\n\t\t\t  }\n\t\t}",
        "lines": 18,
        "depth": 13,
        "decorators": null
      },
      {
        "start_point": [
          570,
          20
        ],
        "end_point": [
          575,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  store ($4, \"w\", 1);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          576,
          3
        ],
        "end_point": [
          612,
          3
        ],
        "content": "SYST CRLF\n\t\t{\n\t\t        const char *sys_type; /* Official rfc-defined os type.  */\n\t\t\tchar *version = 0; /* A more specific type. */\n\n#ifdef HAVE_UNAME\n\t\t\tstruct utsname u;\n\n\t\t\tif (uname (&u) >= 0)\n\t\t\t  {\n\t\t\t    version = malloc (strlen (u.sysname) + 1\n\t\t\t\t\t      + strlen (u.release) + 1);\n\t\t\t    if (version)\n\t\t\t      sprintf (version, \"%s %s\", u.sysname, u.release);\n\t\t\t  }\n#else /* !HAVE_UNAME */\n# ifdef BSD\n\t\t\tversion = \"BSD\";\n# endif /* BSD */\n#endif /* !HAVE_UNAME */\n\n#if defined unix || defined __unix || defined __unix__\n\t\t\tsys_type = \"UNIX\";\n#else\n\t\t\tsys_type = \"UNKNOWN\";\n#endif\n\n\t\t\tif (!no_version && version)\n\t\t\t  reply (215, \"%s Type: L%d Version: %s\",\n\t\t\t\t sys_type, NBBY, version);\n\t\t\telse\n\t\t\t  reply (215, \"%s Type: L%d\", sys_type, NBBY);\n\n#ifdef HAVE_UNAME\n\t\t\tfree (version);\n#endif\n\t\t}",
        "lines": 37,
        "depth": 16,
        "decorators": null
      },
      {
        "start_point": [
          620,
          20
        ],
        "end_point": [
          625,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  sizecmd ($4);\n\t\t\tfree ($4);\n\t\t}",
        "lines": 6,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          635,
          20
        ],
        "end_point": [
          658,
          3
        ],
        "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($2 && $4 != NULL)\n\t\t\t  {\n\t\t\t    struct stat stbuf;\n\n\t\t\t    if (stat ($4, &stbuf) < 0)\n\t\t\t      reply (550, \"%s: %s\", $4, strerror (errno));\n\t\t\t    else if (!S_ISREG (stbuf.st_mode))\n\t\t\t      reply (550, \"%s: not a plain file.\", $4);\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tstruct tm *t;\n\n\t\t\t\tt = gmtime (&stbuf.st_mtime);\n\t\t\t\treply (213,\n\t\t\t\t       \"%04d%02d%02d%02d%02d%02d\",\n\t\t\t\t       1900 + t->tm_year, t->tm_mon+1,\n\t\t\t\t       t->tm_mday, t->tm_hour,\n\t\t\t\t       t->tm_min, t->tm_sec);\n\t\t\t      }\n\t\t\t  }\n\t\t\tfree ($4);\n\t\t}",
        "lines": 24,
        "depth": 14,
        "decorators": null
      },
      {
        "start_point": [
          819,
          20
        ],
        "end_point": [
          829,
          3
        ],
        "content": "SP net_proto CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    if ($4 > 0)\n\t\t\t      passive (PASSIVE_EPSV, $4);\n\t\t\t    else\n\t\t\t      reply (522,\n\t\t\t\t     \"Network protocol not supported, use (1,2)\");\n\t\t\t  }\n\t\t}",
        "lines": 11,
        "depth": 10,
        "decorators": null
      },
      {
        "start_point": [
          834,
          20
        ],
        "end_point": [
          870,
          3
        ],
        "content": "SP long_host_port CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  {\n\t\t\t    if ($4 &&\n\t\t\t\t((his_addr.ss_family == AF_INET\n\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t     &((struct sockaddr_in *) &data_dest)->sin_addr,\n\t\t\t\t\t     sizeof (struct in_addr)) == 0\n\t\t\t\t  && ntohs (((struct sockaddr_in *) &data_dest)->sin_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t ||\n\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t  && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t     &((struct sockaddr_in6 *) &data_dest)->sin6_addr,\n\t\t\t\t\t     sizeof (struct in6_addr)) == 0\n\t\t\t\t  && ntohs (((struct sockaddr_in6 *) &data_dest)->sin6_port)\n\t\t\t\t\t> IPPORT_RESERVED)\n\t\t\t\t)\n\t\t\t       )\n\t\t\t      {\n\t\t\t\tusedefault = 0;\n\t\t\t\tif (pdata >= 0)\n\t\t\t\t  {\n\t\t\t\t    close (pdata);\n\t\t\t\t    pdata = -1;\n\t\t\t\t  }\n\t\t\t\t  reply (200, \"LPRT command successful.\");\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tusedefault = 1;\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\treply (500, \"Illegal LPRT Command\");\n\t\t\t      }\n\t\t\t  } /* check_login */\n\t\t}",
        "lines": 37,
        "depth": 22,
        "decorators": null
      },
      {
        "start_point": [
          875,
          3
        ],
        "end_point": [
          879,
          3
        ],
        "content": "LPSV check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  passive (PASSIVE_LPSV, 0 /* not used */);\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          881,
          3
        ],
        "end_point": [
          885,
          3
        ],
        "content": "QUIT CRLF\n\t\t{\n\t\t\treply (221, \"Goodbye.\");\n\t\t\tdologout (0);\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          886,
          3
        ],
        "end_point": [
          889,
          3
        ],
        "content": "error CRLF\n\t\t{\n\t\t\tyyerrok;\n\t\t}",
        "lines": 4,
        "depth": 4,
        "decorators": null
      }
    ],
    "octal_number": {
      "start_point": [
        532,
        45
      ],
      "end_point": [
        545,
        3
      ],
      "content": "SP pathname CRLF\n\t\t{\n\t\t\tif ($4 && ($8 != NULL))\n\t\t\t  {\n\t\t\t    if ($6 > 0777)\n\t\t\t      reply (501,\n\t\t\t\t     \"CHMOD: Mode value must be between 0 and 0777\");\n\t\t\t    else if (chmod ($8, $6) < 0)\n\t\t\t      perror_reply (550, $8);\n\t\t\t    else\n\t\t\t      reply (200, \"CHMOD command successful.\");\n\t\t\t  }\n\t\t\tfree ($8);\n\t\t}",
      "lines": 14,
      "depth": 12,
      "decorators": null
    },
    "CHAR": [
      {
        "start_point": [
          663,
          57
        ],
        "end_point": [
          809,
          3
        ],
        "content": "tcp_port CHAR CRLF\n\t\t{\n\t\t\tusedefault = 0;\n\t\t\tif (pdata >= 0)\n\t\t\t  {\n\t\t\t    close (pdata);\n\t\t\t    pdata = -1;\n\t\t\t  }\n\t\t\t/* A first sanity check.  */\n\t\t\tif ($2\t\t\t\t/* valid login */\n\t\t\t    && ($5 > 0)\t\t\t/* valid protocols */\n\t\t\t    && ($4 > 32 && $4 < 127)\t/* legal first delimiter */\n\t\t\t\t\t\t\t/* identical delimiters */\n\t\t\t    && ($4 == $6 && $4 == $8 && $4 == $10))\n\t\t\t  {\n\t\t\t    /* We only accept connections using\n\t\t\t     * the same address family as is\n\t\t\t     * currently in use, unless we\n\t\t\t     * detect IPv4-mapped-to-IPv6.\n\t\t\t     */\n\t\t\t    if (his_addr.ss_family == $5\n\t\t\t\t|| ($5 == AF_INET6\n\t\t\t\t    && his_addr.ss_family == AF_INET)\n\t\t\t\t|| ($5 == AF_INET\n\t\t\t\t    && his_addr.ss_family == AF_INET6))\n\t\t\t      {\n\t\t\t\tint err;\n\t\t\t\tchar p[8];\n\t\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t\tmemset (&hints, 0, sizeof (hints));\n\t\t\t\tsnprintf (p, sizeof (p), \"%jd\", $9 & 0xffff);\n\t\t\t\thints.ai_family = $5;\n\t\t\t\thints.ai_socktype = SOCK_STREAM;\n\t\t\t\thints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t\terr = getaddrinfo ($7, p, &hints, &res);\n\t\t\t\tif (err)\n\t\t\t\t  reply (500, \"Illegal EPRT Command\");\n\t\t\t\telse if (/* sanity check */\n\t\t\t\t\t (his_addr.ss_family == AF_INET\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t     &((struct sockaddr_in *) res->ai_addr)->sin_addr,\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in *) res->ai_addr)->sin_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in6 *) &his_addr)->sin6_addr,\n\t\t\t\t\t\t     &((struct sockaddr_in6 *) res->ai_addr)->sin6_addr,\n\t\t\t\t\t\t     sizeof (struct in6_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in6 *) res->ai_addr)->sin6_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET\n\t\t\t\t\t  && res->ai_family == AF_INET6\n\t\t\t\t\t  && IN6_IS_ADDR_V4MAPPED (&((struct sockaddr_in6 *) res->ai_addr)->sin6_addr)\n\t\t\t\t\t  && memcmp (&((struct sockaddr_in *) &his_addr)->sin_addr,\n\t\t\t\t\t\t     &((struct in_addr *) &((struct sockaddr_in6 *) res->ai_addr)->sin6_addr)[3],\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in6 *) res->ai_addr)->sin6_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t ||\n\t\t\t\t\t (his_addr.ss_family == AF_INET6\n\t\t\t\t\t  && res->ai_family == AF_INET\n\t\t\t\t\t  && IN6_IS_ADDR_V4MAPPED (&((struct sockaddr_in6 *) &his_addr)->sin6_addr)\n\t\t\t\t\t  && memcmp (&((struct in_addr *) &((struct sockaddr_in6 *) &his_addr)->sin6_addr)[3],\n\t\t\t\t\t\t     &((struct sockaddr_in *) res->ai_addr)->sin_addr,\n\t\t\t\t\t\t     sizeof (struct in_addr))\n\t\t\t\t\t     == 0\n\t\t\t\t\t  && ntohs (((struct sockaddr_in *) res->ai_addr)->sin_port)\n\t\t\t\t\t     > IPPORT_RESERVED\n\t\t\t\t\t )\n\t\t\t\t\t)\n\t\t\t\t  {\n\t\t\t\t    /* In the case of IPv4 mapped as IPv6,\n\t\t\t\t     * the addresses were proven to coincide,\n\t\t\t\t     * only the extraction remains.\n\t\t\t\t     * Since non-mapped is the standard,\n\t\t\t\t     * test that situation first.\n\t\t\t\t     */\n\t\t\t\t    if (his_addr.ss_family == res->ai_family)\n\t\t\t\t      {\n\t\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\t\tres->ai_addrlen);\n\t\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\t      }\n\t\t\t\t    else if (his_addr.ss_family == AF_INET\n\t\t\t\t\t     && res->ai_family == AF_INET6)\n\t\t\t\t      {\n\t\t\t\t\t/* `his_addr' contains the reduced\n\t\t\t\t\t * IPv4 address.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy (&data_dest, &his_addr,\n\t\t\t\t\t\tsizeof (struct sockaddr_in));\n\t\t\t\t\tdata_dest_len =\n\t\t\t\t\t  sizeof (struct sockaddr_in);\n\t\t\t\t\t((struct sockaddr_in *) &data_dest)->sin_port =\n\t\t\t\t\t  ((struct sockaddr_in6 *) res->ai_addr)->sin6_port;\n\t\t\t\t      }\n\t\t\t\t    else\n\t\t\t\t      {\n\t\t\t\t\t/* `res->ai_addr' contains the reduced\n\t\t\t\t\t * IPv4 address, but the connection\n\t\t\t\t\t * stands on `his_addr', which is\n\t\t\t\t\t * an IPv4-to-IPv6-mapped address.\n\t\t\t\t\t */\n\t\t\t\t\tmemcpy (&data_dest, &his_addr,\n\t\t\t\t\t\tsizeof (struct sockaddr_in6));\n\t\t\t\t\tdata_dest_len =\n\t\t\t\t\t  sizeof (struct sockaddr_in6);\n\t\t\t\t\t((struct sockaddr_in6 *) &data_dest)->sin6_port =\n\t\t\t\t\t  ((struct sockaddr_in *) res->ai_addr)->sin_port;\n\t\t\t\t      }\n\n\t\t\t\t    freeaddrinfo (res);\n\t\t\t\t    reply (200, \"EPRT command successful.\");\n\t\t\t\t  }\n\t\t\t\telse\n\t\t\t\t  {\n\t\t\t\t    /* failed identity check */\n\t\t\t\t    if (res)\n\t\t\t\t      freeaddrinfo (res);\n\t\t\t\t    reply (500, \"Illegal EPRT Command\");\n\t\t\t\t  }\n\t\t\t      }\n\t\t\t    else\n\t\t\t      /* Not fit for established connection.  */\n\t\t\t      reply (522,\n\t\t\t\t     \"Network protocol not supported, use (%d)\",\n\t\t\t\t     ($5 == 1) ? 2 : 1);\n\t\t\t  }\n\t\t\telse if ($2 && ($5 <= 0))\n\t\t\t    reply (522,\n\t\t\t\t   \"Network protocol not supported, use (1,2)\");\n\t\t\telse if ($2)\n\t\t\t  /* Incorrect delimiters detected,\n\t\t\t   * the other conditions are met.\n\t\t\t   */\n\t\t\t  reply (500, \"Illegal EPRT Command\");\n\t\t}",
        "lines": 147,
        "depth": 28,
        "decorators": null
      },
      {
        "start_point": [
          814,
          3
        ],
        "end_point": [
          818,
          3
        ],
        "content": "EPSV check_login CRLF\n\t\t{\n\t\t\tif ($2)\n\t\t\t  passive (PASSIVE_EPSV, AF_UNSPEC);\n\t\t}",
        "lines": 5,
        "depth": 7,
        "decorators": null
      }
    ],
    "NUMBER": [
      {
        "start_point": [
          957,
          9
        ],
        "end_point": [
          1001,
          3
        ],
        "content": "COMMA NUMBER\n\t\t{\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\tsnprintf (a, sizeof (a), \"%jd.%jd.%jd.%jd\",\n\t\t\t\t  $1 & 0xff, $3 & 0xff,\n\t\t\t\t  $5 & 0xff, $7 & 0xff);\n\t\t\tsnprintf (p, sizeof (p), \"%jd\",\n\t\t\t\t  (($9 & 0xff) << 8) + ($11 & 0xff));\n\t\t\tmemset (&hints, 0, sizeof (hints));\n\t\t\thints.ai_family = his_addr.ss_family;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\t\t\thints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\tif (his_addr.ss_family == AF_INET6)\n\t\t\t  {\n\t\t\t    /* IPv4 mapped to IPv6.  */\n\t\t\t    hints.ai_family = AF_INET6;\n#ifdef AI_V4MAPPED\n\t\t\t    hints.ai_flags |= AI_V4MAPPED;\n#endif\n\t\t\t    snprintf (a, sizeof (a),\n\t\t\t\t      \"::ffff:%jd.%jd.%jd.%jd\",\n\t\t\t\t      $1 & 0xff, $3 & 0xff,\n\t\t\t\t      $5 & 0xff, $7 & 0xff);\n\t\t\t  }\n\n\t\t\terr = getaddrinfo (a, p, &hints, &res);\n\t\t\tif (err)\n\t\t\t  {\n\t\t\t    reply (550, \"Address failure: %s,%s\", a, p);\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    $$ = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    memcpy (&data_dest, res->ai_addr, res->ai_addrlen);\n\t\t\t    data_dest_len = res->ai_addrlen;\n\t\t\t    freeaddrinfo (res);\n\t\t\t    $$ = 1;\n\t\t\t  }\n\t\t}",
        "lines": 45,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          1007,
          22
        ],
        "end_point": [
          1066,
          3
        ],
        "content": "COMMA NUMBER /* pal, p */\n\t\t{\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t/* Well formed input for IPv4?  */\n\t\t\tif ($1 != 4 || $3 != 4 || $13 != 2\n\t\t\t    || $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255\n\t\t\t    || $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255\n\t\t\t    || $15 < 0 || $15 > 255\n\t\t\t    || $17 < 0 || $17 > 255)\n\t\t\t  {\n\t\t\t    reply (500, \"Invalid address.\");\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    $$ = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    snprintf (a, sizeof (a), \"%jd.%jd.%jd.%jd\",\n\t\t\t\t      $5, $7, $9, $11);\n\t\t\t    snprintf (p, sizeof (p), \"%jd\", ($15 << 8) + $17);\n\n\t\t\t    memset (&hints, 0, sizeof (hints));\n\t\t\t    hints.ai_family = his_addr.ss_family;\n\t\t\t    hints.ai_socktype = SOCK_STREAM;\n\t\t\t    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t    if (his_addr.ss_family == AF_INET6)\n\t\t\t      {\n\t\t\t\t/* IPv4 mapped to IPv6.  */\n\t\t\t\thints.ai_family = AF_INET6;\n#ifdef AI_V4MAPPED\n\t\t\t\thints.ai_flags |= AI_V4MAPPED;\n#endif\n\t\t\t\tsnprintf (a, sizeof (a),\n\t\t\t\t\t  \"::ffff:%jd.%jd.%jd.%jd\",\n\t\t\t\t\t  $5, $7, $9, $11);\n\t\t\t      }\n\n\t\t\t    err = getaddrinfo (a, p, &hints, &res);\n\t\t\t    if (err)\n\t\t\t      {\n\t\t\t\treply (550, \"LPRT address failure: %s,%s\",\n\t\t\t\t       a, p);\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\tdata_dest_len = 0;\n\t\t\t\t$$ = 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\tres->ai_addrlen);\n\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t$$ = 1;\n\t\t\t      }\n\t\t\t  }\n\t\t}",
        "lines": 60,
        "depth": 20,
        "decorators": null
      }
    ],
    "COMMA": [
      {
        "start_point": [
          1072,
          15
        ],
        "end_point": [
          1132,
          3
        ],
        "content": "NUMBER COMMA NUMBER /* pal, p */\n\t\t{\n\t\t\tint err;\n\t\t\tchar a[INET6_ADDRSTRLEN], p[8];\n\t\t\tstruct addrinfo hints, *res;\n\n\t\t\t/* Well formed input for IPv6?  */\n\t\t\tif ($1 != 6 || $3 != 16 || $37 != 2\n\t\t\t    || $5 < 0 || $5 > 255 || $7 < 0 || $7 > 255\n\t\t\t    || $9 < 0 || $9 > 255 || $11 < 0 || $11 > 255\n\t\t\t    || $13 < 0 || $13 > 255 || $15 < 0 || $15 > 255\n\t\t\t    || $17 < 0 || $17 > 255 || $19 < 0 || $19 > 255\n\t\t\t    || $21 < 0 || $21 > 255 || $23 < 0 || $23 > 255\n\t\t\t    || $25 < 0 || $25 > 255 || $27 < 0 || $27 > 255\n\t\t\t    || $29 < 0 || $29 > 255 || $31 < 0 || $31 > 255\n\t\t\t    || $33 < 0 || $33 > 255 || $35 < 0 || $35 > 255\n\t\t\t    || $39 < 0 || $39 > 255 || $41 < 0 || $41 > 255)\n\t\t\t  {\n\t\t\t    reply (500, \"Invalid address.\");\n\t\t\t    memset (&data_dest, 0, sizeof (data_dest));\n\t\t\t    data_dest_len = 0;\n\t\t\t    $$ = 0;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    snprintf (a, sizeof (a),\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx:\"\n\t\t\t\t     \"%02jx%02jx:%02jx%02jx\",\n\t\t\t\t      $5, $7, $9, $11,\n\t\t\t\t      $13, $15, $17, $19,\n\t\t\t\t      $21, $23, $25, $27,\n\t\t\t\t      $29, $31, $33, $35);\n\t\t\t    snprintf (p, sizeof (p), \"%jd\",\n\t\t\t\t      ($39 << 8) + $41);\n\n\t\t\t    memset (&hints, 0, sizeof (hints));\n\t\t\t    hints.ai_family = his_addr.ss_family;\n\t\t\t    hints.ai_socktype = SOCK_STREAM;\n\t\t\t    hints.ai_flags = AI_NUMERICHOST | AI_NUMERICSERV;\n\n\t\t\t    err = getaddrinfo (a, p, &hints, &res);\n\t\t\t    if (err)\n\t\t\t      {\n\t\t\t\treply (550, \"LPRT address failure: %s,%s\",\n\t\t\t\t       a, p);\n\t\t\t\tmemset (&data_dest, 0, sizeof (data_dest));\n\t\t\t\tdata_dest_len = 0;\n\t\t\t\t$$ = 0;\n\t\t\t      }\n\t\t\t    else\n\t\t\t      {\n\t\t\t\tmemcpy (&data_dest, res->ai_addr,\n\t\t\t\t\tres->ai_addrlen);\n\t\t\t\tdata_dest_len = res->ai_addrlen;\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t$$ = 1;\n\t\t\t      }\n\t\t\t  }\n\t\t}",
        "lines": 61,
        "depth": 44,
        "decorators": null
      },
      {
        "start_point": [
          1156,
          3
        ],
        "end_point": [
          1160,
          3
        ],
        "content": "A SP form_code\n\t\t{\n\t\t\tcmd_type = TYPE_A;\n\t\t\tcmd_form = $3;\n\t\t}",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1166,
          3
        ],
        "end_point": [
          1170,
          3
        ],
        "content": "E SP form_code\n\t\t{\n\t\t\tcmd_type = TYPE_E;\n\t\t\tcmd_form = $3;\n\t\t}",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1180,
          3
        ],
        "end_point": [
          1184,
          3
        ],
        "content": "L SP byte_size\n\t\t{\n\t\t\tcmd_type = TYPE_L;\n\t\t\tcmd_bytesz = $3;\n\t\t}",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          1186,
          3
        ],
        "end_point": [
          1190,
          3
        ],
        "content": "L byte_size\n\t\t{\n\t\t\tcmd_type = TYPE_L;\n\t\t\tcmd_bytesz = $2;\n\t\t}",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "lookup": {
      "start_point": [
        1414,
        0
      ],
      "end_point": [
        1421,
        1
      ],
      "content": "static struct tab *\nlookup (struct tab *p, char *cmd)\n{\n  for (; p->name != NULL; p++)\n    if (strcmp (cmd, p->name) == 0)\n      return (p);\n  return (0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct tab",
        "struct",
        "tab",
        "*\nlookup (struct tab *p, char *cmd)",
        "*"
      ]
    },
    "telnet_fgets": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "char *\ntelnet_fgets (char *s, int n, FILE *iop)\n{\n  int c;\n  register char *cs;\n\n  cs = s;\n/* tmpline may contain saved command from urgent mode interruption */\n  for (c = 0; tmpline[c] != '\\0' && --n > 0; ++c)\n    {\n      *cs++ = tmpline[c];\n      if (tmpline[c] == '\\n')\n\t{\n\t  *cs++ = '\\0';\n\t  if (debug)\n\t    syslog (LOG_DEBUG, \"command: %s\", s);\n\t  tmpline[0] = '\\0';\n\t  return (s);\n\t}\n\n      if (c == 0)\n\ttmpline[0] = '\\0';\n    }\n\n  while ((c = getc (iop)) != EOF)\n    {\n      c &= 0377;\n      if (c == IAC)\n\t{\n\t  c = getc (iop);\n\t  if (c != EOF)\n\t    {\n\t      c &= 0377;\n\t      switch (c)\n\t\t{\n\t\tcase WILL:\n\t\tcase WONT:\n\t\t  c = getc (iop);\n\t\t  printf (\"%c%c%c\", IAC, DONT, 0377 & c);\n\t\t  fflush (stdout);\n\t\t  continue;\n\n\t\tcase DO:\n\t\tcase DONT:\n\t\t  c = getc (iop);\n\t\t  printf (\"%c%c%c\", IAC, WONT, 0377 & c);\n\t\t  fflush (stdout);\n\t\t  continue;\n\n\t\tcase IAC:\n\t\t  break;\n\n\t\tdefault:\n\t\t  continue;\t/* ignore command */\n\t\t}\n\t    }\n\t}\n\n      *cs++ = c;\n      if (--n <= 0 || c == '\\n')\n\tbreak;\n    }\n\n  if (c == EOF && cs == s)\n    return (NULL);\n\n  *cs++ = '\\0';\n\n  if (debug)\n    {\n      if (!cred.guest && strncasecmp (\"pass \", s, 5) == 0)\n\t{\n\t  /* Don't syslog passwords.  */\n\t  syslog (LOG_DEBUG, \"command: %.5s ???\", s);\n\t}\n      else\n\t{\n\t  register char *cp;\n\t  register int len;\n\n\t  /* Don't syslog trailing CR-LF.  */\n\t  len = strlen (s);\n\t  cp = s + len - 1;\n\n\t  while (cp >= s && (*cp == '\\n' || *cp == '\\r'))\n\t    {\n\t      --cp;\n\t      --len;\n\t    }\n\n\t  syslog (LOG_DEBUG, \"command: %.*s\", len, s);\n\t}\n    }\n  return (s);\n}",
      "lines": 95,
      "depth": 16,
      "decorators": [
        "char",
        "*\ntelnet_fgets (char *s, int n, FILE *iop)",
        "*"
      ]
    },
    "toolong": {
      "start_point": [
        1524,
        0
      ],
      "end_point": [
        1534,
        1
      ],
      "content": "void\ntoolong (int signo)\n{\n  (void) signo;\n  reply (421, \"Timeout (%d seconds): closing control connection.\",\n\t timeout);\n  if (logging)\n    syslog (LOG_INFO, \"User %s timed out after %d seconds\",\n\t    (cred.name ? cred.name : \"unknown\"), timeout);\n  dologout (1);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yylex": {
      "start_point": [
        1536,
        0
      ],
      "end_point": [
        1857,
        1
      ],
      "content": "static int\nyylex (void)\n{\n  static int cpos, state;\n  char *cp, *cp2;\n  struct tab *p;\n  int n;\n  char c;\n\n  for (;;)\n    {\n      switch (state)\n\t{\n\tcase CMD:\n\t  signal (SIGALRM, toolong);\n\t  alarm ((unsigned) timeout);\n\t  if (telnet_fgets (cbuf, sizeof (cbuf)-1, stdin) == NULL)\n\t    {\n\t      reply (221, \"You could at least say goodbye.\");\n\t      dologout (0);\n\t    }\n\t  alarm (0);\n\n#ifdef HAVE_SETPROCTITLE\n\t  if (strncasecmp (cbuf, \"PASS\", 4) != 0)\n\t    setproctitle (\"%s: %s\", proctitle, cbuf);\n#endif /* HAVE_SETPROCTITLE */\n\n\t  cp = strchr (cbuf, '\\r');\n\t  if (cp)\n\t    {\n\t      *cp++ = '\\n';\n\t      *cp = '\\0';\n\t    }\n\n\t  cp = strpbrk (cbuf, \" \\n\");\n\t  if (cp)\n\t    cpos = cp - cbuf;\n\n\t  if (cpos == 0)\n\t    cpos = 4;\n\n\t  c = cbuf[cpos];\n\t  cbuf[cpos] = '\\0';\n\t  upper (cbuf);\n\t  p = lookup (cmdtab, cbuf);\n\t  cbuf[cpos] = c;\n\n\t  if (p != 0)\n\t    {\n\t      if (p->implemented == 0)\n\t\t{\n\t\t  nack (p->name);\n\t\t  longjmp (errcatch, 0);\n\t\t  /* NOTREACHED */\n\t\t}\n\t      state = p->state;\n\t      yylval.s = (char*) p->name;\n\t      return (p->token);\n\t    }\n\t  break;\t/* Command not known.  */\n\n\tcase SITECMD:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      return (SP);\n\t    }\n\t  cp = &cbuf[cpos];\n\n\t  cp2 = strpbrk (cp, \" \\n\");\n\t  if (cp2)\n\t    cpos = cp2 - cbuf;\n\n\t  c = cbuf[cpos];\n\t  cbuf[cpos] = '\\0';\n\t  upper (cp);\n\t  p = lookup (sitetab, cp);\n\t  cbuf[cpos] = c;\n\n\t  if (p != 0)\n\t    {\n\t      if (p->implemented == 0)\n\t\t{\n\t\t  state = CMD;\n\t\t  nack (p->name);\n\t\t  longjmp (errcatch, 0);\n\t\t  /* NOTREACHED */\n\t\t}\n\n\t      state = p->state;\n\t      yylval.s = (char*) p->name;\n\t      return (p->token);\n\t    }\n\t  state = CMD;\n\t  break;\t/* Command not known.  */\n\n\tcase OSTR:\n\t  if (cbuf[cpos] == '\\n')\n\t    {\n\t      state = CMD;\n\t      return (CRLF);\n\t    }\n\n\tcase STR1:\n\tcase ZSTR1:\n\tdostr1:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      if (state == OSTR)\n\t\tstate = STR2;\n\t      else\n\t\t++state;\n\n\t      return (SP);\n\t    }\n\t  /* Intentional continuation.  */\n\n\tcase ZSTR2:\n\t  if (cbuf[cpos] == '\\n')\n\t    {\n\t      state = CMD;\n\t      return (CRLF);\n\t    }\n\n\tcase STR2:\n\t  cp = &cbuf[cpos];\n\t  n = strlen (cp);\n\t  cpos += n - 1;\n\t  /*\n\t   * Make sure the string is nonempty and newline terminated.\n\t   */\n\t  if (n > 1 && cbuf[cpos] == '\\n')\n\t    {\n\t      cbuf[cpos] = '\\0';\n\t      yylval.s = copy (cp);\n\t      cbuf[cpos] = '\\n';\n\t      state = ARGS;\n\t      return (STRING);\n\t    }\n\t  break;\t/* Empty string, missing NL.  */\n\n\tcase NSTR:\n\t  if (cbuf[cpos] == ' ')\n\t    {\n\t      cpos++;\n\t      return (SP);\n\t    }\n\t  if (isdigit (cbuf[cpos]))\n\t    {\n\t      cp = &cbuf[cpos];\n\t      while (isdigit (cbuf[++cpos]))\n\t\t;\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      yylval.i = atoi (cp);\n\t      cbuf[cpos] = c;\n\t      state = STR1;\n\t      return (NUMBER);\n\t    }\n\t  state = STR1;\n\t  goto dostr1;\n\n\tcase DLIST:\n\t  /* Either numerical strings or\n\t   * address strings for IPv4 and IPv6.\n\t   * The consist of hexadecimal chars,\n\t   * colon and periods.  A period can\n\t   * not begin a valid address.  */\n\t  if (isxdigit (cbuf[cpos]) || cbuf[cpos] == ':')\n\t    {\n\t      int is_num = 1;\t/* Only to turn off.  */\n\n\t      cp = &cbuf[cpos];\n\t      while (isxdigit (cbuf[cpos])\n\t\t     || cbuf[cpos] == ':'\n\t\t     || cbuf[cpos] == '.')\n\t\t{\n\t\t  if (!isdigit (cbuf[cpos]))\n\t\t    is_num = 0;\n\t\t  cpos++;\n\t\t}\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      if (is_num)\n\t\t{\n\t\t  yylval.i = atoi (cp);\n\t\t  cbuf[cpos] = c;\n\t\t  return (NUMBER);\n\t\t}\n\t      else\n\t\t{\n\t\t  yylval.s = copy (cp);\n\t\t  cbuf[cpos] = c;\n\t\t  return (STRING);\n\t\t}\n\t    }\n\n\t  c = cbuf[cpos++];\n\t  switch (c)\n\t    {\n\t    case ' ':\n\t      return (SP);\n\n\t    case '\\n':\n\t      state = CMD;\n\t      return (CRLF);\n\n\t    default:\n\t      yylval.i = c;\n\t      return (CHAR);\n\t    }\n\t  break;\t/* Not reachable.  */\n\n\tcase ARGS:\n\t  if (isdigit (cbuf[cpos]))\n\t    {\n\t      cp = &cbuf[cpos];\n\t      while (isdigit (cbuf[++cpos]))\n\t\t;\n\n\t      c = cbuf[cpos];\n\t      cbuf[cpos] = '\\0';\n\t      yylval.i = strtoimax (cp, NULL, 10);\t/* off_t */\n\t      cbuf[cpos] = c;\n\t      return (NUMBER);\n\t    }\n\n\t  switch (cbuf[cpos++])\n\t    {\n\t    case '\\n':\n\t      state = CMD;\n\t      return (CRLF);\n\n\t    case ' ':\n\t      return (SP);\n\n\t    case ',':\n\t      return (COMMA);\n\n\t    case 'A':\n\t    case 'a':\n\t      return (A);\n\n\t    case 'B':\n\t    case 'b':\n\t      return (B);\n\n\t    case 'C':\n\t    case 'c':\n\t      return (C);\n\n\t    case 'E':\n\t    case 'e':\n\t      return (E);\n\n\t    case 'F':\n\t    case 'f':\n\t      return (F);\n\n\t    case 'I':\n\t    case 'i':\n\t      return (I);\n\n\t    case 'L':\n\t    case 'l':\n\t      return (L);\n\n\t    case 'N':\n\t    case 'n':\n\t      return (N);\n\n\t    case 'P':\n\t    case 'p':\n\t      return (P);\n\n\t    case 'R':\n\t    case 'r':\n\t      return (R);\n\n\t    case 'S':\n\t    case 's':\n\t      return (S);\n\n\t    case 'T':\n\t    case 't':\n\t      return (T);\n\t    }\n\t  break;\t/* No number, not in [\\n ,aAbBcCeEfFiIlLnNpPrRsSttT] */\n\n\tdefault:\n\t  fatal (\"Unknown state in scanner.\");\n\t}\n\n      /*\n       * Analysis: Cases when this point is reached.\n       *\n       *  CMD:      command not known\n       *  SITECMD:  site command not known (state changed to CMD)\n       *\n       *  OSTR, STR1, ZSTR1, STR2, ZSTR2, NSTR:\n       *            empty string or string without NL\n       *\n       *  ARGS:     not a number, not a special character\n       */\n\n      /*\n       * Issue a new error message only if the parser has not\n       * yet reported a complaint.  Without this precaution\n       * two messages would be directed to the client, thus\n       * upsetting all following exchange.\n       */\n      if (!yynerrs)\n\tyyerror (\"command not recognized\");\n\n      state = CMD;\n      longjmp (errcatch, 0);\n    } /* for (;;) */\n}",
      "lines": 322,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "upper": {
      "start_point": [
        1859,
        0
      ],
      "end_point": [
        1868,
        1
      ],
      "content": "void\nupper (char *s)\n{\n  while (*s != '\\0')\n    {\n      if (islower (*s))\n\t*s = toupper (*s);\n      s++;\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "copy": {
      "start_point": [
        1870,
        0
      ],
      "end_point": [
        1881,
        1
      ],
      "content": "static char *\ncopy (char *s)\n{\n  char *p;\n\n  p = malloc (strlen (s) + 1);\n  if (p == NULL)\n    fatal (\"Ran out of memory.\");\n\n  strcpy (p, s);\n  return (p);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncopy (char *s)",
        "*"
      ]
    },
    "help": {
      "start_point": [
        1883,
        0
      ],
      "end_point": [
        1961,
        1
      ],
      "content": "static void\nhelp (struct tab *ctab, char *s)\n{\n  struct tab *c;\n  int width, NCMDS;\n  const char *help_type;\n\n  if (ctab == sitetab)\n    help_type = \"SITE \";\n  else\n    help_type = \"\";\n\n  width = 0, NCMDS = 0;\n  for (c = ctab; c->name != NULL; c++)\n    {\n      int len = strlen (c->name);\n\n      if (len > width)\n\twidth = len;\n\n      NCMDS++;\n    }\n\n  width = (width + 8) &~ 7;\n\n  if (s == 0)\n    {\n      int i, j, w;\n      int columns, lines;\n\n      lreply (214, \"The following %scommands are recognized %s.\",\n\t      help_type, \"(* =>'s unimplemented)\");\n\n      columns = 76 / width;\n      if (columns == 0)\n\tcolumns = 1;\n\n      lines = (NCMDS + columns - 1) / columns;\n\n      for (i = 0; i < lines; i++)\n\t{\n\t  printf (\"   \");\n\t  for (j = 0; j < columns; j++)\n\t    {\n\t      c = ctab + j * lines + i;\n\t      printf (\"%s%c\", c->name, c->implemented ? ' ' : '*');\n\n\t      if (c + lines >= &ctab[NCMDS])\n\t\tbreak;\n\n\t      w = strlen (c->name) + 1;\n\t      while (w < width)\n\t\t{\n\t\t  putchar (' ');\n\t\t  w++;\n\t\t}\n\t    }\n\t  printf (\"\\r\\n\");\n\t}\n      fflush (stdout);\n      reply (214, \"Direct comments to ftp-bugs@%s.\", hostname);\n      return;\n    }\n\n  upper (s);\n\n  c = lookup (ctab, s);\n  if (c == (struct tab *) 0)\n    {\n      reply (502, \"Unknown command %s.\", s);\n      return;\n    }\n\n  if (c->implemented)\n    reply (214, \"Syntax: %s%s %s\", help_type, c->name, c->help);\n  else\n    reply (214, \"%s%-*s\\t%s; unimplemented.\", help_type,\n\t   width, c->name, c->help);\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sizecmd": {
      "start_point": [
        1963,
        0
      ],
      "end_point": [
        2017,
        1
      ],
      "content": "static void\nsizecmd (char *filename)\n{\n  switch (type)\n    {\n    case TYPE_L:\n    case TYPE_I:\n      {\n\tstruct stat stbuf;\n\n\tif (stat (filename, &stbuf) < 0 || !S_ISREG (stbuf.st_mode))\n\t  reply (550, \"%s: not a plain file.\", filename);\n\telse\n\t  reply (213, \"%ju\", (uintmax_t) stbuf.st_size);\n\tbreak;\n      }\n\n    case TYPE_A:\n      {\n\tFILE *fin;\n\tint c;\n\toff_t count;\n\tstruct stat stbuf;\n\n\tfin = fopen (filename, \"r\");\n\tif (fin == NULL)\n\t  {\n\t    perror_reply (550, filename);\n\t    return;\n\t  }\n\n\tif (fstat (fileno (fin), &stbuf) < 0 || !S_ISREG (stbuf.st_mode))\n\t  {\n\t    reply (550, \"%s: not a plain file.\", filename);\n\t    fclose (fin);\n\t    return;\n\t  }\n\n\tcount = 0;\n\twhile ((c = getc (fin)) != EOF)\n\t  {\n\t    if (c == '\\n')\t/* will get expanded to \\r\\n */\n\t      count++;\n\t    count++;\n\t  }\n\tfclose (fin);\n\n\treply (213, \"%jd\", (intmax_t) count);\n\tbreak;\n      }\n\n    default:\n      reply (504, \"SIZE not implemented for Type %c.\", \"?AEIL\"[type]);\n    }\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yyerror": {
      "start_point": [
        2019,
        0
      ],
      "end_point": [
        2029,
        1
      ],
      "content": "static void\nyyerror (const char *s)\n{\n  char *cp;\n\n  cp = strchr (cbuf, '\\n');\n  if (cp != NULL)\n    *cp = '\\0';\n\n  reply (500, \"'%s': %s\", cbuf, (s ? s : \"command not understood.\"));\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/ftpd.c": {
    "off_to_str": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static char *\noff_to_str (off_t off)\n{\n  static char bufs[NUM_SIMUL_OFF_TO_STRS][80];\n  static char (*next_buf)[80] = bufs;\n\n  if (next_buf >= (bufs + NUM_SIMUL_OFF_TO_STRS))\n    next_buf = bufs;\n\n  if (sizeof (off) > sizeof (long))\n    sprintf (*next_buf, \"%lld\", (long long int) off);\n  else if (sizeof (off) == sizeof (long))\n    sprintf (*next_buf, \"%ld\", (long) off);\n  else\n    sprintf (*next_buf, \"%d\", (int) off);\n\n  return *next_buf++;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\noff_to_str (off_t off)",
        "*"
      ]
    },
    "parse_opt": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '4':\n      /* Active in daemon mode only.  */\n      usefamily = AF_INET;\n      break;\n\n    case '6':\n      /* Active in daemon mode only.  */\n      usefamily = AF_INET6;\n      break;\n\n    case 'A':\n      /* Anonymous ftp only.  */\n      anon_only = 1;\n      break;\n\n    case 'a':\n      if (strcasecmp (arg, \"default\") == 0)\n\tcred.auth_type = AUTH_TYPE_PASSWD;\n#ifdef WITH_PAM\n      else if (strcasecmp (arg, \"pam\") == 0)\n\tcred.auth_type = AUTH_TYPE_PAM;\n#endif\n#ifdef WITH_KERBEROS\n      else if (strcasecmp (arg, \"kerberos\") == 0)\n\tcred.auth_type = AUTH_TYPE_KERBEROS;\n#endif\n#ifdef WITH_KERBEROS5\n      else if (strcasecmp (arg, \"kerberos5\") == 0)\n\tcred.auth_type = AUTH_TYPE_KERBEROS5;\n#endif\n#ifdef WITH_OPIE\n      else if (strcasecmp (arg, \"opie\") == 0)\n\tcred.auth_type = AUTH_TYPE_OPIE;\n#endif\n      break;\n\n    case 'D':\n      /* Run ftpd as daemon.  */\n      daemon_mode = 1;\n      break;\n\n    case 'd':\n      /* Enable debug mode.  */\n      debug = 1;\n      break;\n\n    case 'l':\n      /* Increase logging level.  */\n      logging++;\t\t/* > 1 == Extra logging.  */\n      break;\n\n    case 'p':\n      /* Override pid file */\n      pid_file = arg;\n      break;\n\n    case 'q':\n      /* Don't include version number in banner.  */\n      no_version = 1;\n      break;\n\n    case 't':\n      /* Set default timeout value.  */\n      timeout = atoi (arg);\n      if (maxtimeout < timeout)\n\tmaxtimeout = timeout;\n      break;\n\n    case 'T':\t\t/* Maximum timeout allowed.  */\n      maxtimeout = atoi (arg);\n      if (timeout > maxtimeout)\n\ttimeout = maxtimeout;\n      break;\n\n    case 'u':\t\t/* Set umask.  */\n      {\n\tlong val = 0;\n\n\tval = strtol (arg, &arg, 8);\n\tif (*arg != '\\0' || val < 0)\n\t  argp_error (state, \"bad value for -u\");\n\telse\n\t  defumask = val;\n\tbreak;\n      }\n\n    case OPT_NONRFC2577:\n      rfc2577 = 0;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 101,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "int\nmain (int argc, char *argv[], char **envp)\n{\n  int index;\n\n  set_program_name (argv[0]);\n\n#ifdef HAVE_TZSET\n  tzset ();\t\t\t/* In case no timezone database in ~ftp.  */\n#endif\n\n#ifdef HAVE_INITSETPROCTITLE\n  /* Save start and extent of argv for setproctitle.  */\n  initsetproctitle (argc, argv, envp);\n#else /* !HAVE_INITSETPROCTITLE */\n  (void) envp;\t\t/* Silence warnings.  */\n#endif\n\n  /* Parse the command line */\n  iu_argp_init (\"ftpd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  /* Bail out, wrong usage */\n  if (argc - index != 0)\n    error (EXIT_FAILURE, 0, \"surplus arguments; try `%s --help' for more info\",\n\t   program_name);\n\n  /* LOG_NDELAY sets up the logging connection immediately,\n     necessary for anonymous ftp's that chroot and can't do it later.  */\n  openlog (\"ftpd\", LOG_PID | LOG_NDELAY, LOG_FTP);\n  freopen (PATH_DEVNULL, \"w\", stderr);\n\n  /* If not running via inetd, we detach and dup(fd, 0), dup(fd, 1) the\n     fd = accept(). tcpd is check if compile with the support  */\n  if (daemon_mode)\n    {\n#ifndef HAVE_FORK\n      /* Shift out the daemon option in subforks  */\n      int i;\n      for (i = 0; i < argc; ++i)\n\tif (strcmp (argv[i], \"-D\") == 0)\n\t  {\n\t    int j;\n\t    for (j = i; j < argc; ++j)\n\t      argv[j] = argv[j + 1];\n\t    argv[--argc] = NULL;\n\t  }\n#endif\n      his_addrlen = sizeof (his_addr);\n      if (server_mode (pid_file, (struct sockaddr *) &his_addr,\n\t\t\t&his_addrlen, argv) < 0)\n\texit (EXIT_FAILURE);\n    }\n  else\n    {\n      his_addrlen = sizeof (his_addr);\n      if (getpeername (STDIN_FILENO, (struct sockaddr *) &his_addr,\n\t\t       &his_addrlen) < 0)\n\t{\n\t  syslog (LOG_ERR, \"getpeername (%s): %m\", program_name);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n\n  signal (SIGHUP, sigquit);\n  signal (SIGINT, sigquit);\n  signal (SIGQUIT, sigquit);\n  signal (SIGTERM, sigquit);\n  signal (SIGPIPE, lostconn);\n  signal (SIGCHLD, SIG_IGN);\n  if (signal (SIGURG, myoob) == SIG_ERR)\n    syslog (LOG_ERR, \"signal: %m\");\n\n  /* Get info on the ctrl connection.  */\n  {\n    ctrl_addrlen = sizeof (ctrl_addr);\n    if (getsockname (STDIN_FILENO, (struct sockaddr *) &ctrl_addr,\n\t\t     &ctrl_addrlen) < 0)\n      {\n\tsyslog (LOG_ERR, \"getsockname (%s): %m\", program_name);\n\texit (EXIT_FAILURE);\n      }\n  }\n\n#if defined IP_TOS && defined IPTOS_LOWDELAY && defined IPPROTO_IP\n  /* To  minimize delays for interactive traffic.  */\n  if (ctrl_addr.ss_family == AF_INET)\n    {\n      int tos = IPTOS_LOWDELAY;\n      if (setsockopt (STDIN_FILENO, IPPROTO_IP, IP_TOS,\n\t\t    (char *) &tos, sizeof (int)) < 0)\n\tsyslog (LOG_WARNING, \"setsockopt (IP_TOS): %m\");\n    }\n#endif\n\n#ifdef SO_OOBINLINE\n  /* Try to handle urgent data inline.  */\n  {\n    int on = 1;\n    if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_OOBINLINE,\n\t\t    (char *) &on, sizeof (on)) < 0)\n      syslog (LOG_ERR, \"setsockopt: %m\");\n  }\n#endif\n\n#ifdef SO_KEEPALIVE\n  /* Set keepalives on the socket to detect dropped connections.  */\n  {\n    int keepalive = 1;\n    if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,\n\t\t    (char *) &keepalive, sizeof (keepalive)) < 0)\n      syslog (LOG_WARNING, \"setsockopt (SO_KEEPALIVE): %m\");\n  }\n#endif\n\n#ifdef\tF_SETOWN\n  if (fcntl (STDIN_FILENO, F_SETOWN, getpid ()) == -1)\n    syslog (LOG_ERR, \"fcntl F_SETOWN: %m\");\n#endif\n\n  dolog ((struct sockaddr *) &his_addr, his_addrlen, &cred);\n\n  /* Deal with login disable.  */\n  if (display_file (PATH_NOLOGIN, 530) == 0)\n    {\n      reply (530, \"System not available.\");\n      exit (EXIT_SUCCESS);\n    }\n\n  hostname = localhost ();\n  if (!hostname)\n    perror_reply (550, \"Local resource failure: malloc\");\n\n  /* Display a Welcome message if it exists.\n     N.B. a reply(220,) must follow as continuation.  */\n  display_file (PATH_FTPWELCOME, 220);\n\n  /* Tell them we're ready to roll.  */\n  if (!no_version)\n    reply (220, \"%s FTP server (%s %s) ready.\",\n\t   hostname, PACKAGE_NAME, PACKAGE_VERSION);\n  else\n    reply (220, \"%s FTP server ready.\", hostname);\n\n  /* Set the jump, if we have an error parsing,\n     come here and start fresh.  */\n  setjmp (errcatch);\n\n  /* Roll.  */\n  for (;;)\n    yyparse ();\n}",
      "lines": 152,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "curdir": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "static char *\ncurdir (void)\n{\n  static char *path = 0;\n\n  free (path);\n  path = xgetcwd ();\n  if (!path)\n    return (char *) \"\";\n  if (path[1] != '\\0')\t\t/* special case for root dir. */\n    {\n      char *tmp = realloc (path, strlen (path) + 2);\t/* '/' + '\\0' */\n      if (!tmp)\n\t{\n\t  free (path);\n\t  return (char *) \"\";\n\t}\n      strcat (tmp, \"/\");\n      path = tmp;\n    }\n  /* For guest account, skip / since it's chrooted */\n  return (cred.guest ? path + 1 : path);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ncurdir (void)",
        "*"
      ]
    },
    "sigquit": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "static void\nsigquit (int signo)\n{\n  syslog (LOG_ERR, \"got signal %s\", strsignal (signo));\n  dologout (-1);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lostconn": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "static void\nlostconn (int signo _GL_UNUSED_PARAMETER)\n{\n  if (debug)\n    syslog (LOG_DEBUG, \"lost connection\");\n  dologout (-1);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sgetsave": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "char *\nsgetsave (const char *s)\n{\n  char *string;\n  size_t len;\n\n  if (s == NULL)\n    s = \"\";\n\n  len = strlen (s) + 1;\n  string = malloc (len);\n  if (string == NULL)\n    {\n      perror_reply (421, \"Local resource failure: malloc\");\n      dologout (1);\n    }\n  /*  (void) strcpy (string, s); */\n  memcpy (string, s, len);\n  return string;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsgetsave (const char *s)",
        "*"
      ]
    },
    "complete_login": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "static void\ncomplete_login (struct credentials *pcred)\n{\n  char *cwd;\n\n  if (setegid ((gid_t) pcred->gid) < 0)\n    {\n      reply (550, \"Can't set gid.\");\n      goto bad;\n    }\n\n#ifdef HAVE_INITGROUPS\n  initgroups (pcred->name, pcred->gid);\n#endif\n\n  /* open wtmp before chroot */\n  snprintf (ttyline, sizeof (ttyline), \"ftp%d\", (int) getpid ());\n  logwtmp_keep_open (ttyline, pcred->name, pcred->remotehost);\n\n  if (pcred->guest)\n    {\n      /* We MUST do a chdir () after the chroot. Otherwise\n         the old current directory will be accessible as \".\"\n         outside the new root!  */\n      if (chroot (pcred->rootdir) < 0 || chdir (pcred->homedir) < 0)\n\t{\n\t  reply (550, \"Can't set guest privileges.\");\n\t  goto bad;\n\t}\n    }\n  else if (pcred->dochroot)\n    {\n      if (chroot (pcred->rootdir) < 0 || chdir (pcred->homedir) < 0)\n\t{\n\t  reply (550, \"Can't change root.\");\n\t  goto bad;\n\t}\n    }\n\n  if (seteuid ((uid_t) pcred->uid) < 0)\n    {\n      reply (550, \"Can't set uid.\");\n      goto bad;\n    }\n\n  if (!pcred->guest && !pcred->dochroot)\t/* Remaining case.  */\n    {\n      if (chdir (pcred->rootdir) < 0)\n\t{\n\t  if (chdir (\"/\") < 0)\n\t    {\n\t      reply (530, \"User %s: can't change directory to %s.\",\n\t\t     pcred->name, pcred->homedir);\n\t      goto bad;\n\t    }\n\n\t  lreply (230, \"No directory! Logging in with home=/\");\n\t}\n    }\n\n  cwd = xgetcwd ();\n  if (cwd)\n    {\n      setenv (\"HOME\", cwd, 1);\n      free (cwd);\n    }\n\n  /* Display a login message, if it exists.\n     N.B. a reply(230,) must follow after this message.  */\n  display_file (PATH_FTPLOGINMESG, 230);\n\n  if (pcred->guest)\n    {\n      reply (230, \"Guest login ok, access restrictions apply.\");\n#ifdef HAVE_SETPROCTITLE\n      snprintf (proctitle, sizeof (proctitle), \"%s: anonymous\",\n\t\tpcred->remotehost);\n      setproctitle (\"%s\", proctitle);\n#endif /* HAVE_SETPROCTITLE */\n      if (logging)\n\tsyslog (LOG_INFO, \"ANONYMOUS FTP LOGIN FROM %s\", pcred->remotehost);\n    }\n  else\n    {\n      reply (230, \"User %s logged in.\", pcred->name);\n#ifdef HAVE_SETPROCTITLE\n      snprintf (proctitle, sizeof (proctitle),\n\t\t\"%s: %s\", pcred->remotehost, pcred->name);\n      setproctitle (\"%s\", proctitle);\n#endif /* HAVE_SETPROCTITLE */\n      if (logging)\n\tsyslog (LOG_INFO, \"FTP LOGIN FROM %s as %s\",\n\t\tpcred->remotehost, pcred->name);\n    }\n  umask (defumask);\n  return;\nbad:\n  /* Forget all about it... */\n  end_login (pcred);\t/* Resets pcred->logged_in.  */\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "user": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        854,
        1
      ],
      "content": "void\nuser (const char *name)\n{\n  int ret;\n\n  if (cred.logged_in)\n    {\n      if (cred.guest || cred.dochroot)\n\t{\n\t  reply (530, \"Can't change user from guest login.\");\n\t  return;\n\t}\n      end_login (&cred);\n    }\n\n  /* Non zero means failed.  */\n  ret = auth_user (name, &cred);\n  if (!rfc2577 && ret != 0)\n    {\n      /* If they gave us a reason.  */\n      if (cred.message)\n\t{\n\t  reply (530, \"%s\", cred.message);\n\t  free (cred.message);\n\t  cred.message = NULL;\n\t}\n      else\n\treply (530, \"User %s access denied.\", name);\n      if (logging)\n\tsyslog (LOG_NOTICE, \"FTP LOGIN REFUSED FROM %s, %s\",\n\t\tcred.remotehost, name);\n      return;\n    }\n  else if (rfc2577 && ret != 0)\n    cred.delayed_reject = 1;\n  else\n    cred.delayed_reject = 0;\n\n  /* Only messages for anonymous guests are accepted.  */\n  if (rfc2577 && !cred.guest && cred.message)\n    {\n      free (cred.message);\n      cred.message = NULL;\n    }\n\n  /* If the server is set to serve anonymous service only\n     the request have to come from a guest or a chrooted.  */\n  if (anon_only && !cred.guest && !cred.dochroot)\n    {\n      reply (530, \"Sorry, only anonymous ftp allowed\");\n      return;\n    }\n\n  if (logging)\n    {\n      strncpy (curname, name, sizeof (curname) - 1);\n      curname[sizeof (curname) - 1] = '\\0';\t/* Make sure null terminated.  */\n    }\n\n  if (cred.message)\n    {\n      /* Stacked PAM modules for authentication may have\n       * produced a multiline message at this point.\n       * The FTP protocol does not cope well with this,\n       * so we transfer only the very last line, which\n       * should reflect the active authentication mechanism.\n       */\n      char *msg = strrchr (cred.message, '\\n');\n\n      if (msg)\n\tmsg++;\t\t/* Step over separator.  */\n      else\n\tmsg = cred.message;\n\n      reply (331, \"%s\", msg);\n      free (cred.message);\n      cred.message = NULL;\n    }\n  else\n    reply (331, \"Password required for %s.\", name);\n\n  askpasswd = 1;\n\n  /* Delay before reading passwd after first failed\n     attempt to slow down passwd-guessing programs.  */\n  if (login_attempts)\n    sleep ((unsigned) login_attempts);\n}",
      "lines": 88,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "end_login": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "static void\nend_login (struct credentials *pcred)\n{\n  char *remotehost = pcred->remotehost;\n  int atype = pcred->auth_type;\n\n  seteuid ((uid_t) 0);\n  if (pcred->logged_in)\n    {\n      logwtmp_keep_open (ttyline, \"\", \"\");\n#ifdef WITH_PAM\n      pam_end_login (pcred);\n#endif\n    }\n\n  free (pcred->name);\n  if (pcred->passwd)\n    {\n      memset (pcred->passwd, 0, strlen (pcred->passwd));\n      free (pcred->passwd);\n    }\n  free (pcred->homedir);\n  free (pcred->rootdir);\n  free (pcred->shell);\n  if (pcred->pass)\t\t/* Properly erase old password.  */\n    {\n      memset (pcred->pass, 0, strlen (pcred->pass));\n      free (pcred->pass);\n    }\n  free (pcred->message);\n  memset (pcred, 0, sizeof (*pcred));\n  pcred->remotehost = remotehost;\n  pcred->auth_type = atype;\n  pcred->logged_in = 0;\n  pcred->delayed_reject = 0;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pass": {
      "start_point": [
        895,
        0
      ],
      "end_point": [
        962,
        1
      ],
      "content": "void\npass (const char *passwd)\n{\n  if (cred.logged_in || askpasswd == 0)\n    {\n      reply (503, \"Login with USER first.\");\n      return;\n    }\n  askpasswd = 0;\n\n  if (!cred.guest)\t\t/* \"ftp\" is the only account allowed no password.  */\n    {\n      /* Try to authenticate the user.  Failed if != 0.  */\n      if (auth_pass (passwd, &cred) != 0 || cred.delayed_reject)\n\t{\n\t  /* Any particular reason?  */\n\t  if (rfc2577)\n\t    {\n\t      if (cred.message)\n\t\t{\n\t\t  free (cred.message);\n\t\t  cred.message = NULL;\n\t\t}\n\t      reply (530, \"Login incorrect.\");\n\t    }\n\t  else if (cred.message)\n\t    {\n\t      reply (530, \"%s\", cred.message);\n\t      free (cred.message);\n\t      cred.message = NULL;\n\t    }\n\t  else if (cred.expired & AUTH_EXPIRED_ACCT)\n\t    reply (530, \"Account is expired.\");\n\t  else if (cred.expired & AUTH_EXPIRED_PASS)\n\t    reply (530, \"Password has expired.\");\n\t  else\n\t    reply (530, \"Login incorrect.\");\n\n\t  if (logging)\n\t    syslog (LOG_NOTICE, \"FTP LOGIN FAILED FROM %s, %s\",\n\t\t    cred.remotehost, curname);\n\t  if (login_attempts++ >= 5)\n\t    {\n\t      syslog (LOG_NOTICE, \"repeated login failures from %s\",\n\t\t      cred.remotehost);\n\t      reply (421,\n\t\t     \"Service not available, closing control connection.\");\n\t      exit (EXIT_SUCCESS);\n\t    }\n\t  return;\n\t}\n      if (cred.message)\n\t{\n\t  /* At least PAM might have committed additional messages.\n\t   * Reply code 230 is used, since at this point the client\n\t   * has been accepted.  */\n\t  lreply_multiline (230, cred.message);\n\t  free (cred.message);\n\t  cred.message = NULL;\n\t}\n    }\n  cred.logged_in = 1;\t\t/* Everything seems to be allright.  */\n  complete_login (&cred);\n  if (cred.logged_in)\n    login_attempts = 0;\t\t/* This time successful.  */\n  else\n    ++login_attempts;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "retrieve": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        1053,
        1
      ],
      "content": "void\nretrieve (const char *cmd, const char *name)\n{\n  FILE *fin, *dout;\n  struct stat st;\n  int (*closefunc) (FILE *);\n  size_t buffer_size = BUFSIZ;\t/* Dynamic buffer.  */\n\n  if (cmd == 0)\n    {\n      fin = fopen (name, \"r\"), closefunc = fclose;\n      st.st_size = 0;\n    }\n  else\n    {\n      char line[BUFSIZ];\n\n      snprintf (line, sizeof line, cmd, name);\n      name = line;\n      fin = ftpd_popen (line, \"r\"), closefunc = ftpd_pclose;\n      st.st_size = -1;\n    }\n\n  if (fin == NULL)\n    {\n      if (errno != 0)\n\t{\n\t  perror_reply (550, name);\n\t  if (cmd == 0)\n\t    {\n\t      LOGCMD (\"get\", name);\n\t    }\n\t}\n      return;\n    }\n  byte_count = -1;\n  if (cmd == 0 && (fstat (fileno (fin), &st) < 0 || !S_ISREG (st.st_mode)))\n    {\n      reply (550, \"%s: not a plain file.\", name);\n      goto done;\n    }\n  else if (cmd == 0)\n    buffer_size = st.st_blksize;\t/* Depends on file system.  */\n\n  if (restart_point)\n    {\n      if (type == TYPE_A)\n\t{\n\t  off_t i, n;\n\t  int c;\n\n\t  n = restart_point;\n\t  i = 0;\n\t  while (i++ < n)\n\t    {\n\t      c = getc (fin);\n\t      if (c == EOF)\n\t\t{\n\t\t  /* Error code 554 was introduced in RFC 1123.  */\n\t\t  reply (554,\n\t\t\t \"Action not taken: invalid REST value %jd for %s.\",\n\t\t\t restart_point, name);\n\t\t  goto done;\n\t\t}\n\t      if (c == '\\n')\n\t\ti++;\n\t    }\n\t}\n      else if (lseek (fileno (fin), restart_point, SEEK_SET) < 0)\n\t{\n\t  if (errno == EINVAL)\n\t    reply (554, \"Action not taken: invalid REST value %jd for %s.\",\n\t\t   restart_point, name);\n\t  else\n\t    perror_reply (550, name);\n\t  goto done;\n\t}\n    }\n  dout = dataconn (name, st.st_size, \"w\");\n  if (dout == NULL)\n    goto done;\n  send_data (fin, dout, buffer_size);\n  fclose (dout);\n  data = -1;\n  pdata = -1;\ndone:\n  if (cmd == 0)\n    LOGBYTES (\"get\", name, byte_count);\n  (*closefunc) (fin);\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "store": {
      "start_point": [
        1055,
        0
      ],
      "end_point": [
        1144,
        1
      ],
      "content": "void\nstore (const char *name, const char *mode, int unique)\n{\n  FILE *fout, *din;\n  struct stat st;\n  int (*closefunc) (FILE *);\n\n  if (unique && stat (name, &st) == 0)\n    {\n      const char *name_unique = gunique (name);\n\n      if (name_unique)\n        name = name_unique;\n      else\n        {\n          LOGCMD (*mode == 'w' ? \"put\" : \"append\", name);\n          return;\n        }\n    }\n\n  if (restart_point)\n    mode = \"r+\";\n  fout = fopen (name, mode);\n  closefunc = fclose;\n  if (fout == NULL || fstat (fileno (fout), &st) < 0)\n    {\n      perror_reply (553, name);\n      LOGCMD (*mode == 'w' ? \"put\" : \"append\", name);\n      return;\n    }\n  byte_count = -1;\n  if (restart_point)\n    {\n      if (type == TYPE_A)\n\t{\n\t  off_t i, n;\n\t  int c;\n\n\t  n = restart_point;\n\t  i = 0;\n\t  while (i++ < n)\n\t    {\n\t      c = getc (fout);\n\t      if (c == EOF)\n\t\t{\n\t\t  /* Error code 554 was introduced in RFC 1123.  */\n\t\t  reply (554,\n\t\t\t \"Action not taken: invalid REST value %jd for %s.\",\n\t\t\t restart_point, name);\n\t\t  goto done;\n\t\t}\n\t      if (c == '\\n')\n\t\ti++;\n\t    }\n\t  /* We must do this seek to \"current\" position\n\t     because we are changing from reading to\n\t     writing.  */\n\t  if (fseeko (fout, 0L, SEEK_CUR) < 0)\n\t    {\n\t      perror_reply (550, name);\n\t      goto done;\n\t    }\n\t}\n      else if (lseek (fileno (fout), restart_point, SEEK_SET) < 0)\n\t{\n\t  if (errno == EINVAL)\n\t    reply (554, \"Action not taken: invalid REST value %jd for %s.\",\n\t\t   restart_point, name);\n\t  else\n\t    perror_reply (550, name);\n\t  goto done;\n\t}\n    }\n  din = dataconn (name, (off_t) - 1, \"r\");\n  if (din == NULL)\n    goto done;\n  if (receive_data (din, fout, st.st_blksize) == 0)\n    {\n      if (unique)\n\treply (226, \"Transfer complete (unique file name:%s).\", name);\n      else\n\treply (226, \"Transfer complete.\");\n    }\n  fclose (din);\n  data = -1;\n  pdata = -1;\ndone:\n  LOGBYTES (*mode == 'w' ? \"put\" : \"append\", name, byte_count);\n  (*closefunc) (fout);\n}",
      "lines": 90,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "getdatasock": {
      "start_point": [
        1146,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "static FILE *\ngetdatasock (const char *mode)\n{\n  int s, t, tries;\n\n  if (data >= 0)\n    return fdopen (data, mode);\n  seteuid ((uid_t) 0);\n  s = socket (ctrl_addr.ss_family, SOCK_STREAM, 0);\n  if (s < 0)\n    goto bad;\n\n  /* Enables local reuse address.  */\n  {\n    int on = 1;\n    if (setsockopt (s, SOL_SOCKET, SO_REUSEADDR,\n\t\t    (char *) &on, sizeof (on)) < 0)\n      goto bad;\n  }\n\n  /* Anchor socket to avoid multi-homing problems.  */\n  memcpy (&data_source, &ctrl_addr, sizeof (data_source));\n  data_source_len = ctrl_addrlen;\n\n  /* Erase port number, suggesting bind() to allocate a new port.  */\n  switch (data_source.ss_family)\n    {\n    case AF_INET6:\n      ((struct sockaddr_in6 *) &data_source)->sin6_port = 0;\n      break;\n    case AF_INET:\n      ((struct sockaddr_in *) &data_source)->sin_port = 0;\n      break;\n    default:\n      break;\t/* Do nothing; should not happen!  */\n    }\n\n  for (tries = 1;; tries++)\n    {\n      if (bind (s, (struct sockaddr *) &data_source, data_source_len) >= 0)\n\tbreak;\n      if (errno != EADDRINUSE || tries > 10)\n\tgoto bad;\n      sleep (tries);\n    }\n  if (seteuid ((uid_t) cred.uid) != 0)\n    _exit (EXIT_FAILURE);\n\n#if defined IP_TOS && defined IPTOS_THROUGHPUT && defined IPPROTO_IP\n  if (ctrl_addr.ss_family == AF_INET)\n    {\n      int on = IPTOS_THROUGHPUT;\n      if (setsockopt (s, IPPROTO_IP, IP_TOS, (char *) &on, sizeof (int)) < 0)\n\tsyslog (LOG_WARNING, \"setsockopt (IP_TOS): %m\");\n    }\n#endif\n\n  return (fdopen (s, mode));\nbad:\n  /* Return the real value of errno (close may change it) */\n  t = errno;\n  if (seteuid ((uid_t) cred.uid) != 0)\n    _exit (EXIT_FAILURE);\n  close (s);\n  errno = t;\n  return NULL;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\ngetdatasock (const char *mode)",
        "*"
      ]
    },
    "dataconn": {
      "start_point": [
        1214,
        0
      ],
      "end_point": [
        1308,
        1
      ],
      "content": "static FILE *\ndataconn (const char *name, off_t size, const char *mode)\n{\n  char sizebuf[32];\n  FILE *file;\n  int retry = 0;\n\n  file_size = size;\n  byte_count = 0;\n  if (size != (off_t) - 1)\n    snprintf (sizebuf, sizeof (sizebuf), \" (%s bytes)\", off_to_str (size));\n  else\n    *sizebuf = '\\0';\n  if (pdata >= 0)\n    {\n      struct sockaddr_storage from;\n      int s;\n      socklen_t fromlen = sizeof (from);\n\n      signal (SIGALRM, toolong);\n      alarm ((unsigned) timeout);\n      s = accept (pdata, (struct sockaddr *) &from, &fromlen);\n      alarm (0);\n      if (s < 0)\n\t{\n\t  reply (425, \"Can't open data connection.\");\n\t  close (pdata);\n\t  pdata = -1;\n\t  return NULL;\n\t}\n      close (pdata);\n      pdata = s;\n#if defined IP_TOS && defined IPTOS_THROUGHPUT && defined IPPROTO_IP\n      /* Optimize throughput.  */\n      if (from.ss_family == AF_INET)\n\t{\n\t  int tos = IPTOS_THROUGHPUT;\n\t  setsockopt (s, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof (int));\n\t}\n#endif\n#ifdef SO_KEEPALIVE\n      /* Set keepalives on the socket to detect dropped conns.  */\n      {\n\tint keepalive = 1;\n\tsetsockopt (s, SOL_SOCKET, SO_KEEPALIVE,\n\t\t    (char *) &keepalive, sizeof (int));\n      }\n#endif\n      reply (150, \"Opening %s mode data connection for '%s'%s.\",\n\t     type == TYPE_A ? \"ASCII\" : \"BINARY\", name, sizebuf);\n      return fdopen (pdata, mode);\n    }\n  if (data >= 0)\n    {\n      reply (125, \"Using existing data connection for '%s'%s.\",\n\t     name, sizebuf);\n      usedefault = 1;\n      return fdopen (data, mode);\n    }\n  if (usedefault)\n    {\n      memcpy (&data_dest, &his_addr, sizeof (data_dest));\n      data_dest_len = his_addrlen;\n    }\n  usedefault = 1;\n  file = getdatasock (mode);\n  if (file == NULL)\n    {\n      int oerrno = errno;\n      (void) getnameinfo ((struct sockaddr *) &data_source, data_source_len,\n\t\t\t  addrstr, sizeof (addrstr),\n\t\t\t  portstr, sizeof (portstr),\n\t\t\t  NI_NUMERICSERV);\n      reply (425, \"Can't create data socket (%s,%s): %s.\",\n\t     addrstr, portstr, strerror (oerrno));\n      return NULL;\n    }\n  data = fileno (file);\n  while (connect (data, (struct sockaddr *) &data_dest, data_dest_len) < 0)\n    {\n      if (errno == EADDRINUSE && retry < swaitmax)\n\t{\n\t  sleep ((unsigned) swaitint);\n\t  retry += swaitint;\n\t  continue;\n\t}\n      perror_reply (425, \"Can't build data connection\");\n      fclose (file);\n      data = -1;\n      return NULL;\n    }\n  reply (150, \"Opening %s mode data connection for '%s'%s.\",\n\t type == TYPE_A ? \"ASCII\" : \"BINARY\", name, sizebuf);\n  return file;\n}",
      "lines": 95,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\ndataconn (const char *name, off_t size, const char *mode)",
        "*"
      ]
    },
    "send_data": {
      "start_point": [
        1316,
        0
      ],
      "end_point": [
        1476,
        1
      ],
      "content": "static void\nsend_data (FILE * instr, FILE * outstr, off_t blksize)\n{\n  int c, cnt, filefd, netfd;\n  char *buf = MAP_FAILED, *bp;\n  off_t curpos;\n  off_t len, filesize;\n\n  transflag++;\n  if (setjmp (urgcatch))\n    {\n      transflag = 0;\n      return;\n    }\n\n  netfd = fileno (outstr);\n  filefd = fileno (instr);\n#ifdef HAVE_MMAP\n  /* Last argument in mmap() must be page aligned,\n   * at least for Solaris and Linux, so use mmap()\n   * only with null offset retrievals.\n   */\n  if (file_size > 0 && file_size < IU_MMAP_SIZE && restart_point == 0)\n    {\n      curpos = lseek (filefd, 0, SEEK_CUR);\n      if (debug)\n\tsyslog (LOG_DEBUG, \"Position is %jd. Attempting mmap call.\",\n\t\tcurpos);\n      if (curpos >= 0)\n\t{\n\t  filesize = file_size - curpos;\n\t  buf = mmap (0, filesize, PROT_READ, MAP_SHARED, filefd, curpos);\n\t}\n    }\n#endif\n\n  switch (type)\n    {\n\n    case TYPE_A:\n#ifdef HAVE_MMAP\n      if (file_size > 0 && curpos >= 0 && buf != MAP_FAILED)\n\t{\n\t  if (debug)\n\t    syslog (LOG_DEBUG, \"Reading file as ascii in mmap mode.\");\n\t  len = 0;\n\t  while (len < filesize)\n\t    {\n\t      byte_count++;\n\t      if (buf[len] == '\\n')\n\t\t{\n\t\t  if (ferror (outstr))\n\t\t    break;\n\t\t  putc ('\\r', outstr);\n\t\t}\n\t      putc (buf[len], outstr);\n\t      len++;\n\t    }\n\t  fflush (outstr);\n\t  transflag = 0;\n\t  munmap (buf, filesize);\n\t  if (ferror (outstr))\n\t    goto data_err;\n\t  reply (226, \"Transfer complete.\");\n\t  return;\n\t}\n#endif\n      if (debug)\n\tsyslog (LOG_DEBUG, \"Reading file as ascii in byte mode.\");\n      while ((c = getc (instr)) != EOF)\n\t{\n\t  byte_count++;\n\t  if (c == '\\n')\n\t    {\n\t      if (ferror (outstr))\n\t\tgoto data_err;\n\t      putc ('\\r', outstr);\n\t    }\n\t  putc (c, outstr);\n\t}\n      fflush (outstr);\n      transflag = 0;\n      if (ferror (instr))\n\tgoto file_err;\n      if (ferror (outstr))\n\tgoto data_err;\n      reply (226, \"Transfer complete.\");\n      return;\n\n    case TYPE_I:\n    case TYPE_L:\n#ifdef HAVE_MMAP\n      if (file_size > 0 && curpos >= 0 && buf != MAP_FAILED)\n\t{\n\t  if (debug)\n\t    syslog (LOG_DEBUG, \"Reading file as image in mmap mode.\");\n\t  bp = buf;\n\t  len = filesize;\n\t  do\n\t    {\n\t      cnt = write (netfd, bp, len);\n\t      len -= cnt;\n\t      bp += cnt;\n\t      if (cnt > 0)\n\t\tbyte_count += cnt;\n\t    }\n\t  while (cnt > 0 && len > 0);\n\t  transflag = 0;\n\t  munmap (buf, (size_t) filesize);\n\t  if (cnt < 0)\n\t    goto data_err;\n\t  reply (226, \"Transfer complete.\");\n\t  return;\n\t}\n#endif\n      if (debug)\n\t{\n\t  syslog (LOG_DEBUG, \"Reading file as image in block mode.\");\n\t  curpos = lseek (filefd, 0, SEEK_CUR);\n\t  if (curpos < 0)\n\t    syslog (LOG_DEBUG, \"Input file: %m\");\n\t  else\n\t    syslog (LOG_DEBUG, \"Starting at position %jd.\", curpos);\n\t}\n\n      buf = malloc ((u_int) blksize);\n      if (buf == NULL)\n\t{\n\t  transflag = 0;\n\t  perror_reply (451, \"Local resource failure: malloc\");\n\t  return;\n\t}\n      while ((cnt = read (filefd, buf, (u_int) blksize)) > 0 &&\n\t     write (netfd, buf, cnt) == cnt)\n\tbyte_count += cnt;\n\n      transflag = 0;\n      free (buf);\n      if (cnt != 0)\n\t{\n\t  if (cnt < 0)\n\t    goto file_err;\n\t  goto data_err;\n\t}\n      reply (226, \"Transfer complete.\");\n      return;\n    default:\n      transflag = 0;\n      reply (550, \"Unimplemented TYPE %d in send_data\", type);\n      return;\n    }\n\ndata_err:\n  transflag = 0;\n  perror_reply (426, \"Data connection\");\n  return;\n\nfile_err:\n  transflag = 0;\n  perror_reply (551, \"Error on input file\");\n}",
      "lines": 161,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "receive_data": {
      "start_point": [
        1482,
        0
      ],
      "end_point": [
        1576,
        1
      ],
      "content": "static int\nreceive_data (FILE * instr, FILE * outstr, off_t blksize)\n{\n  int c;\n  int cnt, bare_lfs = 0;\n  char *buf;\n\n  transflag++;\n  if (setjmp (urgcatch))\n    {\n      transflag = 0;\n      return -1;\n    }\n  switch (type)\n    {\n    case TYPE_I:\n    case TYPE_L:\n      buf = malloc ((u_int) blksize);\n      if (buf == NULL)\n\t{\n\t  transflag = 0;\n\t  perror_reply (451, \"Local resource failure: malloc\");\n\t  return -1;\n\t}\n\n      while ((cnt = read (fileno (instr), buf, blksize)) > 0)\n\t{\n\t  if (write (fileno (outstr), buf, cnt) != cnt)\n\t    {\n\t      free (buf);\n\t      goto file_err;\n\t    }\n\t  byte_count += cnt;\n\t}\n      free (buf);\n      if (cnt < 0)\n\tgoto data_err;\n      transflag = 0;\n      return 0;\n\n    case TYPE_E:\n      reply (553, \"TYPE E not implemented.\");\n      transflag = 0;\n      return -1;\n\n    case TYPE_A:\n      while ((c = getc (instr)) != EOF)\n\t{\n\t  byte_count++;\n\t  if (c == '\\n')\n\t    bare_lfs++;\n\t  while (c == '\\r')\n\t    {\n\t      if (ferror (outstr))\n\t\tgoto data_err;\n\t      c = getc (instr);\n\t      if (c != '\\n')\n\t\t{\n\t\t  putc ('\\r', outstr);\n\t\t  if (c == '\\0' || c == EOF)\n\t\t    goto contin2;\n\t\t}\n\t    }\n\t  putc (c, outstr);\n\tcontin2:;\n\t}\n      fflush (outstr);\n      if (ferror (instr))\n\tgoto data_err;\n      if (ferror (outstr))\n\tgoto file_err;\n      transflag = 0;\n      if (bare_lfs)\n\t{\n\t  lreply (226, \"WARNING! %d bare linefeeds received in ASCII mode\",\n\t\t  bare_lfs);\n\t  printf (\"   File may not have transferred correctly.\\r\\n\");\n\t}\n      return (0);\n    default:\n      reply (550, \"Unimplemented TYPE %d in receive_data\", type);\n      transflag = 0;\n      return -1;\n    }\n\ndata_err:\n  transflag = 0;\n  perror_reply (426, \"Data Connection\");\n  return -1;\n\nfile_err:\n  transflag = 0;\n  perror_reply (452, \"Error writing file\");\n  return -1;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "statfilecmd": {
      "start_point": [
        1578,
        0
      ],
      "end_point": [
        1610,
        1
      ],
      "content": "void\nstatfilecmd (const char *filename)\n{\n  FILE *fin;\n  int c;\n  char line[LINE_MAX];\n\n  snprintf (line, sizeof (line), \"/bin/ls -lgA %s\", filename);\n  fin = ftpd_popen (line, \"r\");\n  lreply (211, \"status of %s:\", filename);\n  while ((c = getc (fin)) != EOF)\n    {\n      if (c == '\\n')\n\t{\n\t  if (ferror (stdout))\n\t    {\n\t      perror_reply (421, \"control connection\");\n\t      ftpd_pclose (fin);\n\t      dologout (1);\n\t    }\n\t  if (ferror (fin))\n\t    {\n\t      perror_reply (551, filename);\n\t      ftpd_pclose (fin);\n\t      return;\n\t    }\n\t  putc ('\\r', stdout);\n\t}\n      putc (c, stdout);\n    }\n  ftpd_pclose (fin);\n  reply (211, \"End of Status\");\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "statcmd": {
      "start_point": [
        1612,
        0
      ],
      "end_point": [
        1677,
        1
      ],
      "content": "void\nstatcmd (void)\n{\n  struct sockaddr_storage *sin;\n  unsigned char *a, *p;\n\n  lreply (211, \"%s FTP server status:\", hostname);\n  if (!no_version)\n    printf (\"     ftpd (%s) %s\\r\\n\", PACKAGE_NAME, PACKAGE_VERSION);\n  printf (\"     Connected to %s\", cred.remotehost);\n  (void) getnameinfo ((struct sockaddr *) &his_addr, his_addrlen,\n\t\t      addrstr, sizeof (addrstr), NULL, 0, NI_NUMERICHOST);\n  if (!isdigit (cred.remotehost[0]))\n    printf (\" (%s)\", addrstr);\n  printf (\"\\r\\n\");\n  printf (\"     Session timeout is %d seconds\\r\\n\", timeout);\n  if (cred.logged_in)\n    {\n      if (cred.guest)\n\tprintf (\"     Logged in anonymously\\r\\n\");\n      else\n\tprintf (\"     Logged in as %s\\r\\n\", cred.name);\n    }\n  else if (askpasswd)\n    printf (\"     Waiting for password\\r\\n\");\n  else\n    printf (\"     Waiting for user name\\r\\n\");\n  printf (\"     TYPE: %s\", typenames[type]);\n  if (type == TYPE_A || type == TYPE_E)\n    printf (\", FORM: %s\", formnames[form]);\n  if (type == TYPE_L)\n#ifdef CHAR_BIT\n    printf (\" %d\", CHAR_BIT);\n#else\n# if NBBY == 8\n    printf (\" %d\", NBBY);\n# else\n    printf (\" %d\", bytesize);\t/* need definition! */\n# endif\n#endif\n  printf (\"; STRUcture: %s; transfer MODE: %s\\r\\n\",\n\t  strunames[stru], modenames[stru_mode]);\n  if (data != -1)\n    printf (\"     Data connection open\\r\\n\");\n  else if (pdata != -1)\n    {\n      printf (\"     in Passive mode\");\n      sin = &pasv_addr;\n      goto printaddr;\n    }\n  else if (usedefault == 0)\n    {\n      printf (\"     PORT\");\n      sin = &data_dest;\n    printaddr:\n      a = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_addr;\n      p = (unsigned char *) & ((struct sockaddr_in *) sin)->sin_port;\n#define UC(b) (((int) b) & 0xff)\n      printf (\" (%d,%d,%d,%d,%d,%d)\\r\\n\", UC (a[0]),\n\t      UC (a[1]), UC (a[2]), UC (a[3]), UC (p[0]), UC (p[1]));\n#undef UC\n    }\n  else\n    printf (\"     No data connection\\r\\n\");\n  reply (211, \"End of status\");\n}",
      "lines": 66,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "fatal": {
      "start_point": [
        1679,
        0
      ],
      "end_point": [
        1685,
        1
      ],
      "content": "void\nfatal (const char *s)\n{\n  reply (451, \"Error in server: %s\\n\", s);\n  reply (221, \"Closing connection due to server error.\");\n  dologout (0);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "reply": {
      "start_point": [
        1687,
        0
      ],
      "end_point": [
        1704,
        1
      ],
      "content": "void\nreply (int n, const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  printf (\"%d \", n);\n  vprintf (fmt, ap);\n  va_end (ap);\n  printf (\"\\r\\n\");\n  fflush (stdout);\n  if (debug)\n    {\n      syslog (LOG_DEBUG, \"<--- %d \", n);\n      va_start (ap, fmt);\n      vsyslog (LOG_DEBUG, fmt, ap);\n      va_end (ap);\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lreply": {
      "start_point": [
        1706,
        0
      ],
      "end_point": [
        1723,
        1
      ],
      "content": "void\nlreply (int n, const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  printf (\"%d- \", n);\n  vprintf (fmt, ap);\n  va_end (ap);\n  printf (\"\\r\\n\");\n  fflush (stdout);\n  if (debug)\n    {\n      syslog (LOG_DEBUG, \"<--- %d- \", n);\n      va_start (ap, fmt);\n      vsyslog (LOG_DEBUG, fmt, ap);\n      va_end (ap);\n    }\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lreply_multiline": {
      "start_point": [
        1729,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "void\nlreply_multiline (int n, const char *text)\n{\n  char *line;\n\n  line = strdup (text);\n  if (line == NULL)\n    return;\n  else\n    {\n      int stop = 0;\n      char *p1 = line, *p2;\n\n      do\n\t{\n\t  p2 = strchrnul (p1, '\\n');\n\t  stop = (*p2 == '\\0');\t\t/* End of input string?  */\n\t  *p2 = '\\0';\n\t  printf (\"%d- \", n);\n\t  printf (\"%s\\r\\n\", p1);\n\t  if (debug)\n\t    {\n\t      syslog (LOG_DEBUG, \"<--- %d- \", n);\n\t      syslog (LOG_DEBUG, \"%s\", p1);\n\t    }\n\t  p1 = ++p2;\t\t\t/* P1 is used within bounds.  */\n\t}\n      while (!stop);\n      free (line);\n    }\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "ack": {
      "start_point": [
        1761,
        0
      ],
      "end_point": [
        1765,
        1
      ],
      "content": "static void\nack (const char *s)\n{\n  reply (250, \"%s command successful.\", s);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nack": {
      "start_point": [
        1767,
        0
      ],
      "end_point": [
        1771,
        1
      ],
      "content": "void\nnack (const char *s)\n{\n  reply (502, \"%s command not implemented.\", s);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "delete": {
      "start_point": [
        1773,
        0
      ],
      "end_point": [
        1800,
        1
      ],
      "content": "void\ndelete (const char *name)\n{\n  struct stat st;\n\n  LOGCMD (\"delete\", name);\n  if (stat (name, &st) < 0)\n    {\n      perror_reply (550, name);\n      return;\n    }\n  if (S_ISDIR (st.st_mode))\n    {\n      if (rmdir (name) < 0)\n\t{\n\t  perror_reply (550, name);\n\t  return;\n\t}\n      goto done;\n    }\n  if (unlink (name) < 0)\n    {\n      perror_reply (550, name);\n      return;\n    }\ndone:\n  ack (\"DELE\");\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "cwd": {
      "start_point": [
        1802,
        0
      ],
      "end_point": [
        1809,
        1
      ],
      "content": "void\ncwd (const char *path)\n{\n  if (chdir (path) < 0)\n    perror_reply (550, path);\n  else\n    ack (\"CWD\");\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "makedir": {
      "start_point": [
        1811,
        0
      ],
      "end_point": [
        1834,
        1
      ],
      "content": "void\nmakedir (const char *name)\n{\n  LOGCMD (\"mkdir\", name);\n  if (mkdir (name, 0777) < 0)\n    perror_reply (550, name);\n  else if (name[0] == '/')\n    reply (257, \"\\\"%s\\\" new directory created.\", name);\n  else\n    {\n      /* We have to figure out what our current directory is so that we can\n         give an absolute name in the reply.  */\n      char *current = xgetcwd ();\n      if (current)\n\t{\n\t  if (current[1] == '\\0')\n\t    current[0] = '\\0';\n\t  reply (257, \"\\\"%s/%s\\\" new directory created.\", current, name);\n\t  free (current);\n\t}\n      else\n\treply (257, \"(unknown absolute name) new directory created.\");\n    }\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "removedir": {
      "start_point": [
        1836,
        0
      ],
      "end_point": [
        1844,
        1
      ],
      "content": "void\nremovedir (const char *name)\n{\n  LOGCMD (\"rmdir\", name);\n  if (rmdir (name) < 0)\n    perror_reply (550, name);\n  else\n    ack (\"RMD\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "pwd": {
      "start_point": [
        1846,
        0
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "void\npwd (void)\n{\n  char *path = xgetcwd ();\n\n  if (path)\n    {\n      reply (257, \"\\\"%s\\\" is current directory.\", path);\n      free (path);\n    }\n  else\n    reply (550, \"%s.\", strerror (errno));\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "renamefrom": {
      "start_point": [
        1860,
        0
      ],
      "end_point": [
        1872,
        1
      ],
      "content": "char *\nrenamefrom (const char *name)\n{\n  struct stat st;\n\n  if (stat (name, &st) < 0)\n    {\n      perror_reply (550, name);\n      return ((char *) 0);\n    }\n  reply (350, \"File exists, ready for destination name\");\n  return (char *) (name);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrenamefrom (const char *name)",
        "*"
      ]
    },
    "renamecmd": {
      "start_point": [
        1874,
        0
      ],
      "end_point": [
        1882,
        1
      ],
      "content": "void\nrenamecmd (const char *from, const char *to)\n{\n  LOGCMD2 (\"rename\", from, to);\n  if (rename (from, to) < 0)\n    perror_reply (550, \"rename\");\n  else\n    ack (\"RNTO\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dolog": {
      "start_point": [
        1884,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "static void\ndolog (struct sockaddr *sa, socklen_t salen, struct credentials *pcred)\n{\n  (void) getnameinfo (sa, salen, addrstr, sizeof (addrstr), NULL, 0, 0);\n\n  free (pcred->remotehost);\n  pcred->remotehost = sgetsave (addrstr);\n\n#ifdef HAVE_SETPROCTITLE\n  snprintf (proctitle, sizeof (proctitle), \"%s: connected\",\n\t    pcred->remotehost);\n  setproctitle (\"%s\", proctitle);\n#endif /* HAVE_SETPROCTITLE */\n\n  if (logging)\n    syslog (LOG_INFO, \"connection from %s\", pcred->remotehost);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dologout": {
      "start_point": [
        1904,
        0
      ],
      "end_point": [
        1915,
        1
      ],
      "content": "void\ndologout (int status)\n{\n  /* Race condition with SIGURG: If SIGURG is received\n     here, it will jump back has root in the main loop.\n     David Greenman:dg@root.com.  */\n  transflag = 0;\n  end_login (&cred);\n\n  /* Beware of flushing buffers after a SIGPIPE.  */\n  _exit (status);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "myoob": {
      "start_point": [
        1917,
        0
      ],
      "end_point": [
        1947,
        1
      ],
      "content": "static void\nmyoob (int signo _GL_UNUSED_PARAMETER)\n{\n  char *cp;\n\n  /* only process if transfer occurring */\n  if (!transflag)\n    return;\n  cp = tmpline;\n  if (telnet_fgets (cp, 7, stdin) == NULL)\n    {\n      reply (221, \"You could at least say goodbye.\");\n      dologout (0);\n    }\n  upper (cp);\n  if (strcmp (cp, \"ABOR\\r\\n\") == 0)\n    {\n      tmpline[0] = '\\0';\n      reply (426, \"Transfer aborted. Data connection closed.\");\n      reply (226, \"Abort successful\");\n      longjmp (urgcatch, 1);\n    }\n  if (strcmp (cp, \"STAT\\r\\n\") == 0)\n    {\n      if (file_size != (off_t) - 1)\n\treply (213, \"Status: %s of %s bytes transferred\",\n\t       off_to_str (byte_count), off_to_str (file_size));\n      else\n\treply (213, \"Status: %s bytes transferred\", off_to_str (byte_count));\n    }\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "passive": {
      "start_point": [
        1953,
        0
      ],
      "end_point": [
        2061,
        1
      ],
      "content": "void\npassive (int epsv, int af)\n{\n  char *p, *a;\n  int try_af;\n\n  /* EPSV might ask for a particular address family.  */\n  if (epsv == PASSIVE_EPSV && af > 0)\n    try_af = af;\n  else\n    try_af = ctrl_addr.ss_family;\n\n  pdata = socket (try_af, SOCK_STREAM, 0);\n  if (pdata < 0)\n    {\n      perror_reply (425, \"Can't open passive connection\");\n      return;\n    }\n  memcpy (&pasv_addr, &ctrl_addr, sizeof (pasv_addr));\n  pasv_addrlen = ctrl_addrlen;\n\n  /* Erase the port number.  */\n  if (pasv_addr.ss_family == AF_INET6)\n    ((struct sockaddr_in6 *) &pasv_addr)->sin6_port = 0;\n  else\t/* !AF_INET6 */\n    ((struct sockaddr_in *) &pasv_addr)->sin_port = 0;\n\n  seteuid ((uid_t) 0);\n  if (bind (pdata, (struct sockaddr *) &pasv_addr, pasv_addrlen) < 0)\n    {\n      if (seteuid ((uid_t) cred.uid))\n\t_exit (EXIT_FAILURE);\n      goto pasv_error;\n    }\n  if (seteuid ((uid_t) cred.uid))\n    _exit (EXIT_FAILURE);\n  pasv_addrlen = sizeof (pasv_addr);\n  if (getsockname (pdata, (struct sockaddr *) &pasv_addr, &pasv_addrlen) < 0)\n    goto pasv_error;\n  if (listen (pdata, 1) < 0)\n    goto pasv_error;\n\n  if (epsv == PASSIVE_EPSV)\n    {\n      /* EPSV for IPv4 and IPv6.  */\n      reply (229, \"Entering Extended Passive Mode (|||%u|)\",\n\t     ntohs((pasv_addr.ss_family == AF_INET)\n\t\t    ? ((struct sockaddr_in *) &pasv_addr)->sin_port\n\t\t    : ((struct sockaddr_in6 *) &pasv_addr)->sin6_port));\n      return;\n    }\n  else /* !EPSV */\n    {\n      /* PASV for IPv4, or LPSV for IPv4 or IPv6.\n       *\n       * Some systems, like OpenSolaris, prefer to return\n       * an IPv4-mapped-IPv6 address, which must be processed\n       * for printout.  */\n\n#define UC(b) (((int) b) & 0xff)\n\n      if (pasv_addr.ss_family == AF_INET6\n\t  && IN6_IS_ADDR_V4MAPPED (&((struct sockaddr_in6 *) &pasv_addr)->sin6_addr))\n\t{\n\t  a = (char *) &((struct sockaddr_in6 *) &pasv_addr)->sin6_addr;\n\t  a += 3 * sizeof (struct in_addr);\t/* Skip padding up to IPv4 content.  */\n\t  p = (char *) &((struct sockaddr_in6 *) &pasv_addr)->sin6_port;\n\t}\n      else if (pasv_addr.ss_family == AF_INET6)\n\t{\n\t  /* LPSV for IPv6, not mapped. */\n\t  a = (char *) &((struct sockaddr_in6 *) &pasv_addr)->sin6_addr;\n\t  p = (char *) &((struct sockaddr_in6 *) &pasv_addr)->sin6_port;\n\n\t  reply (228, \"Entering Long Passive Mode \"\n\t\t \"(6,16,%d,%d,%d,%d,%d,%d,%d,%d\"\t/* a[0..7] */\n\t\t \",%d,%d,%d,%d,%d,%d,%d,%d\"\t/* a[8..15] */\n\t\t \",2,%d,%d)\",\t/* p0, p1 */\n\t\t UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t\t UC (a[4]), UC (a[5]), UC (a[6]), UC (a[7]),\n\t\t UC (a[8]), UC (a[9]), UC (a[10]), UC (a[11]),\n\t\t UC (a[12]), UC (a[13]), UC (a[14]), UC (a[15]),\n\t\t UC (p[0]), UC (p[1]));\n\t  return;\n\t}\n      else\n\t{\n\t  a = (char *) &((struct sockaddr_in *) &pasv_addr)->sin_addr;\n\t  p = (char *) &((struct sockaddr_in *) &pasv_addr)->sin_port;\n\t}\n\n      if (epsv == PASSIVE_LPSV)\n\treply (228, \"Entering Long Passive Mode \"\n\t       \"(4,4,%d,%d,%d,%d,2,%d,%d)\",\n\t       UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t       UC (p[0]), UC (p[1]));\n      else\n\treply (227, \"Entering Passive Mode (%d,%d,%d,%d,%d,%d)\",\n\t       UC (a[0]), UC (a[1]), UC (a[2]), UC (a[3]),\n\t       UC (p[0]), UC (p[1]));\n      return;\n    }\n\npasv_error:\n  close (pdata);\n  pdata = -1;\n  perror_reply (425, \"Can't open passive connection\");\n  return;\n}",
      "lines": 109,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "gunique": {
      "start_point": [
        2066,
        0
      ],
      "end_point": [
        2102,
        1
      ],
      "content": "static char *\ngunique (const char *local)\n{\n  static char *string = 0;\n  struct stat st;\n  int count;\n  char *cp;\n\n  cp = strrchr (local, '/');\n  if (cp)\n    *cp = '\\0';\n  if (stat (cp ? local : \".\", &st) < 0)\n    {\n      perror_reply (553, cp ? local : \".\");\n      return ((char *) 0);\n    }\n  if (cp)\n    *cp = '/';\n\n  free (string);\n  string = malloc (strlen (local) + 5);\t/* '.' + DIG + DIG + '\\0' */\n  if (string)\n    {\n      strcpy (string, local);\n      cp = string + strlen (string);\n      *cp++ = '.';\n      for (count = 1; count < 100; count++)\n\t{\n\t  sprintf (cp, \"%d\", count);\n\t  if (stat (string, &st) < 0)\n\t    return string;\n\t}\n    }\n\n  reply (452, \"Unique file name cannot be created.\");\n  return NULL;\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ngunique (const char *local)",
        "*"
      ]
    },
    "perror_reply": {
      "start_point": [
        2107,
        0
      ],
      "end_point": [
        2111,
        1
      ],
      "content": "void\nperror_reply (int code, const char *string)\n{\n  reply (code, \"%s: %s.\", string, strerror (errno));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "send_file_list": {
      "start_point": [
        2118,
        0
      ],
      "end_point": [
        2269,
        1
      ],
      "content": "void\nsend_file_list (const char *whichf)\n{\n  struct stat st;\n  DIR *dirp = NULL;\n  struct dirent *dir;\n  FILE *dout = NULL;\n  char **dirlist, *dirname;\n  int simple = 0;\n  int freeglob = 0;\n  glob_t gl;\n  char *p = NULL;\n\n  if (strpbrk (whichf, \"~{[*?\") != NULL)\n    {\n      int flags = GLOB_NOCHECK;\n\n#ifdef GLOB_BRACE\n      flags |= GLOB_BRACE;\n#endif\n#ifdef GLOB_QUOTE\n      flags |= GLOB_QUOTE;\n#endif\n#ifdef GLOB_TILDE\n      flags |= GLOB_TILDE;\n#endif\n\n      memset (&gl, 0, sizeof (gl));\n      freeglob = 1;\n      if (glob (whichf, flags, 0, &gl))\n\t{\n\t  reply (550, \"not found\");\n\t  goto out;\n\t}\n      else if (gl.gl_pathc == 0)\n\t{\n\t  errno = ENOENT;\n\t  perror_reply (550, whichf);\n\t  goto out;\n\t}\n      dirlist = gl.gl_pathv;\n    }\n  else\n    {\n      p = strdup (whichf);\n      onefile[0] = p;\n      dirlist = onefile;\n      simple = 1;\n    }\n\n  if (setjmp (urgcatch))\n    {\n      transflag = 0;\n      goto out;\n    }\n  while ((dirname = *dirlist++))\n    {\n      if (stat (dirname, &st) < 0)\n\t{\n\t  /* If user typed \"ls -l\", etc, and the client\n\t     used NLST, do what the user meant.  */\n\t  if (dirname[0] == '-' && *dirlist == NULL && transflag == 0)\n\t    {\n\t      retrieve (\"/bin/ls %s\", dirname);\n\t      goto out;\n\t    }\n\t  perror_reply (550, whichf);\n\t  if (dout != NULL)\n\t    {\n\t      fclose (dout);\n\t      transflag = 0;\n\t      data = -1;\n\t      pdata = -1;\n\t    }\n\t  goto out;\n\t}\n\n      if (S_ISREG (st.st_mode))\n\t{\n\t  if (dout == NULL)\n\t    {\n\t      dout = dataconn (\"file list\", (off_t) - 1, \"w\");\n\t      if (dout == NULL)\n\t\tgoto out;\n\t      transflag++;\n\t    }\n\t  fprintf (dout, \"%s%s\\n\", dirname, type == TYPE_A ? \"\\r\" : \"\");\n\t  byte_count += strlen (dirname) + 1;\n\t  continue;\n\t}\n      else if (!S_ISDIR (st.st_mode))\n\tcontinue;\n\n      dirp = opendir (dirname);\n      if (dirp == NULL)\n\tcontinue;\n\n      while ((dir = readdir (dirp)) != NULL)\n\t{\n\t  char *nbuf;\n\n\t  if (dir->d_name[0] == '.' && dir->d_name[1] == '\\0')\n\t    continue;\n\t  if (dir->d_name[0] == '.' && dir->d_name[1] == '.' &&\n\t      dir->d_name[2] == '\\0')\n\t    continue;\n\n\t  nbuf = alloca (strlen (dirname) + 1 + strlen (dir->d_name) + 1);\n\t  sprintf (nbuf, \"%s/%s\", dirname, dir->d_name);\n\n\t  /* We have to do a stat to insure it's\n\t     not a directory or special file.  */\n\t  if (simple || (stat (nbuf, &st) == 0 && S_ISREG (st.st_mode)))\n\t    {\n\t      if (dout == NULL)\n\t\t{\n\t\t  dout = dataconn (\"file list\", (off_t) - 1, \"w\");\n\t\t  if (dout == NULL)\n\t\t    goto out;\n\t\t  transflag++;\n\t\t}\n\t      if (nbuf[0] == '.' && nbuf[1] == '/')\n\t\tfprintf (dout, \"%s%s\\n\", &nbuf[2],\n\t\t\t type == TYPE_A ? \"\\r\" : \"\");\n\t      else\n\t\tfprintf (dout, \"%s%s\\n\", nbuf, type == TYPE_A ? \"\\r\" : \"\");\n\t      byte_count += strlen (nbuf) + 1;\n\t    }\n\t}\n      closedir (dirp);\n    }\n\n  if (dout == NULL)\n    reply (550, \"No files found.\");\n  else if (ferror (dout) != 0)\n    perror_reply (550, \"Data connection\");\n  else\n    reply (226, \"Transfer complete.\");\n\n  transflag = 0;\n  if (dout != NULL)\n    fclose (dout);\n  data = -1;\n  pdata = -1;\nout:\n  free (p);\n  if (freeglob)\n    {\n      freeglob = 0;\n      globfree (&gl);\n    }\n}",
      "lines": 152,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/pam.c": {
    "PAM_conv": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nPAM_conv (int num_msg, const struct pam_message **msg,\n\t  struct pam_response **resp, void *appdata_ptr)\n{\n  struct pam_response *repl = NULL;\n  int retval, count = 0, replies = 0;\n  int size = sizeof (struct pam_response);\n  struct credentials *pcred = (struct credentials *) appdata_ptr;\n\n# define GET_MEM \\\n        if (!(repl = realloc (repl, size))) \\\n                return PAM_BUF_ERR; \\\n        size += sizeof (struct pam_response)\n\n  retval = PAM_SUCCESS;\n\n  for (count = 0; count < num_msg; count++)\n    {\n      int savemsg = 0;\n\n      switch (msg[count]->msg_style)\n\t{\n\tcase PAM_PROMPT_ECHO_ON:\n\t  GET_MEM;\n\t  repl[replies].resp_retcode = PAM_SUCCESS;\n\t  repl[replies].resp = sgetsave (pcred->name);\n\t  replies++;\n\t  break;\n\tcase PAM_PROMPT_ECHO_OFF:\n\t  GET_MEM;\n\t  if (pcred->pass == NULL)\n\t    {\n\t      savemsg = 1;\n# ifdef PAM_CONV_AGAIN\n\t      retval = PAM_CONV_AGAIN;\t\t/* Linux-PAM */\n# elif !defined WITH_LINUX_PAM\n\t      /*\n\t       * Simulate PAM_CONV_AGAIN.\n\t       * The alternate value PAM_TRY_AGAIN is not\n\t       * an expected return value here, so it will\n\t       * leave an audit trail.  */\n\t      retval = PAM_CRED_INSUFFICIENT;\n# else /* !PAM_CONV_AGAIN && !WITH_LINUX_PAM */\n\t      retval = PAM_CONV_ERR;\n# endif\n\t    }\n\t  else\n\t    {\n\t      repl[replies].resp_retcode = PAM_SUCCESS;\n\t      repl[replies].resp = sgetsave (pcred->pass);\n\t      replies++;\n\t    }\n\t  break;\n\tcase PAM_TEXT_INFO:\n\t  savemsg = 1;\n\t  break;\n\tcase PAM_ERROR_MSG:\n\tdefault:\n\t  /* Must be an error of some sort... */\n\t  savemsg = 1;\n\t  retval = PAM_CONV_ERR;\n\t}\n\n      if (savemsg)\n\t{\n\t  /* FIXME:  This is a serious problem.  If the PAM message\n\t     is multilines, the reply _must_ be formated correctly.\n\t     The way to do this would be to consider \\n as a boundary then\n\t     in the ftpd.c:user() or ftpd.c:pass() check for it and send\n\t     a lreply().  But I'm not sure the RFCs allow mutilines replies\n\t     for a passwd challenge.  Many clients will simply break.  */\n\t  /* XXX: Attempted solution; collect all messages, appended\n\t   * one after the other, separated by \"\\n\".  Then print all\n\t   * of them in one single run.  This will circumvent the hard\n\t   * coded protocol convention of not allowing continuation\n\t   * massage to carry a deviating reply code relative to the\n\t   * final message.\n\t   */\n\t  if (pcred->message)\t/* XXX: make sure we split newlines correctly */\n\t    {\n\t      size_t len = strlen (pcred->message);\n\t      char *s = realloc (pcred->message, len\n\t\t\t\t + strlen (msg[count]->msg) + 2);\n\t      if (s == NULL)\n\t\t{\n\t\t  free (pcred->message);\n\t\t  pcred->message = NULL;\n\t\t}\n\t      else\n\t\t{\n\t\t  pcred->message = s;\n\t\t  strcat (pcred->message, \"\\n\");\n\t\t  strcat (pcred->message, msg[count]->msg);\n\t\t}\n\t    }\n\t  else\n\t    pcred->message = sgetsave (msg[count]->msg);\n\n\t  if (pcred->message == NULL)\n\t    retval = PAM_CONV_ERR;\n\t  else\n\t    {\n\t      char *sp;\n\t      /* Remove trailing space only.  */\n\t      sp = pcred->message + strlen (pcred->message);\n\t      while (sp > pcred->message && strchr (\" \\t\\n\", *--sp))\n\t\t*sp = '\\0';\n\t    }\n\t}\n\n      /* In case of error, drop responses and return */\n      if (retval)\n\t{\n\t  /* FIXME: drop_reply is not standard, need to clean this.  */\n\t  //_pam_drop_reply (repl, replies);\n\t  free (repl);\n\t  return retval;\n\t}\n    }\n  if (repl)\n    *resp = repl;\n  return PAM_SUCCESS;\n}",
      "lines": 123,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pam_doit": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static int\npam_doit (struct credentials *pcred)\n{\n  char *username;\n  int error;\n\n  error = pam_authenticate (pamh, 0);\n\n  /* Probably being called with empty passwd.  */\n  if (0\n# ifdef PAM_CONV_AGAIN\n      || error == PAM_CONV_AGAIN\n# endif\n# ifdef PAM_INCOMPLETE\n      || error == PAM_INCOMPLETE\n# endif\n# ifndef WITH_LINUX_PAM\n      /*\n       * In absence of `pam_ftp.so', catch the simulated,\n       * incomplete state reported by our PAM_conv().\n       */\n      || (error == PAM_CRED_INSUFFICIENT && pcred->pass == NULL)\n# endif /* !WITH_LINUX_PAM */\n     )\n    {\n      /* Avoid overly terse passwd messages and let the people\n         upstairs do something sane.  */\n      if (pcred->message && !strcasecmp (pcred->message, \"password:\"))\n\t{\n\t  free (pcred->message);\n\t  pcred->message = NULL;\n\t}\n      return PAM_SUCCESS;\n    }\n\n  if (error == PAM_SUCCESS)\t/* Alright, we got it */\n    {\n      error = pam_acct_mgmt (pamh, 0);\n      if (error == PAM_SUCCESS)\n\terror = pam_setcred (pamh, PAM_ESTABLISH_CRED);\n      if (error == PAM_SUCCESS)\n\terror = pam_open_session (pamh, 0);\n      if (error == PAM_SUCCESS)\n\terror = pam_get_item (pamh, PAM_USER, (const void **) &username);\n      if (error == PAM_SUCCESS)\n\t{\n\t  if (sgetcred (username, pcred) != 0)\n\t    error = PAM_AUTH_ERR;\n\t  else\n\t    {\n\t      if (strcasecmp (username, \"ftp\") == 0)\n\t\tpcred->guest = 1;\n\t    }\n\t}\n    }\n  if (error != PAM_SUCCESS)\n    {\n      pam_end (pamh, error);\n      pamh = NULL;\n    }\n\n  return (error != PAM_SUCCESS);\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pam_user": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "int\npam_user (const char *username, struct credentials *pcred)\n{\n  int error;\n  char tty_name[strlen (TTY_FORMAT) + strlen (\"9999999\")];\n\n  if (pamh != NULL)\n    {\n      pam_end (pamh, PAM_ABORT);\n      pamh = NULL;\n    }\n\n  free (pcred->name);\n  pcred->name = strdup (username);\n  free (pcred->message);\n  pcred->message = NULL;\n\n  (void) snprintf (tty_name, sizeof (tty_name), TTY_FORMAT, (int) getpid());\n\n  /* Arrange our creditive.  */\n  PAM_conversation.appdata_ptr = (void *) pcred;\n\n  error = pam_start (\"ftp\", pcred->name, &PAM_conversation, &pamh);\n  if (error == PAM_SUCCESS)\n    error = pam_set_item (pamh, PAM_RHOST, pcred->remotehost);\n  if (error == PAM_SUCCESS)\n    error = pam_set_item (pamh, PAM_TTY, tty_name);\n  if (error != PAM_SUCCESS)\n    {\n      pam_end (pamh, error);\n      pamh = 0;\n    }\n\n  if (pamh)\n    error = pam_doit (pcred);\n\n  return (error != PAM_SUCCESS);\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "pam_pass": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "int\npam_pass (const char *passwd, struct credentials *pcred)\n{\n  int error = PAM_AUTH_ERR;\n  if (pamh)\n    {\n      pcred->pass = (char *) passwd;\n      error = pam_doit (pcred);\n      pcred->pass = NULL;\n    }\n  return error != PAM_SUCCESS;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "pam_end_login": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "void\npam_end_login (struct credentials * pcred _GL_UNUSED_PARAMETER)\n{\n  int error;\n\n  if (pamh)\n    {\n      error = pam_close_session (pamh, PAM_SILENT);\n      if (logging && error != PAM_SUCCESS)\n\tsyslog (LOG_ERR, \"pam_session: %s\", pam_strerror (pamh, error));\n\n      error = pam_setcred (pamh, PAM_SILENT | PAM_DELETE_CRED);\n      if (logging && error != PAM_SUCCESS)\n\tsyslog (LOG_ERR, \"pam_setcred: %s\", pam_strerror (pamh, error));\n\n      error = pam_end (pamh, error);\n      if (logging && error != PAM_SUCCESS)\n\tsyslog (LOG_ERR, \"pam_end: %s\", pam_strerror (pamh, error));\n\n      pamh = NULL;\n    }\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/popen.c": {
    "ftpd_pclose": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "int\nftpd_pclose (FILE * iop)\n{\n  struct file_pid *fpid = file_pids, *prev_fpid = 0;\n  int status;\n#ifdef HAVE_SIGACTION\n  sigset_t sigs, osigs;\n#else\n  int omask;\n#endif\n  pid_t pid;\n\n  /*\n   * pclose returns -1 if stream is not associated with a\n   * `popened' command, or, if already `pclosed'.\n   */\n  while (fpid && fpid->file != iop)\n    {\n      prev_fpid = fpid;\n      fpid = fpid->next;\n    }\n  if (!fpid)\n    return -1;\n\n  if (prev_fpid)\n    prev_fpid->next = fpid->next;\n  else\n    file_pids = fpid->next;\n\n  fclose (iop);\n#ifdef HAVE_SIGACTION\n  sigemptyset (&sigs);\n  sigaddset (&sigs, SIGINT);\n  sigaddset (&sigs, SIGQUIT);\n  sigaddset (&sigs, SIGHUP);\n  sigprocmask (SIG_BLOCK, &sigs, &osigs);\n#else\n  omask = sigblock (sigmask (SIGINT) | sigmask (SIGQUIT) | sigmask (SIGHUP));\n#endif\n  while ((pid = waitpid (fpid->pid, &status, 0)) < 0 && errno == EINTR)\n    continue;\n\n  free (fpid);\n\n#ifdef HAVE_SIGACTION\n  sigprocmask (SIG_SETMASK, &osigs, 0);\n#else\n  sigsetmask (omask);\n#endif\n  if (pid < 0)\n    return (pid);\n  if (WIFEXITED (status))\n    return (WEXITSTATUS (status));\n  return (1);\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ftpd/server_mode.c": {
    "check_host": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static int\ncheck_host (struct sockaddr *sa, socklen_t len)\n{\n  int err;\n  char addr[INET6_ADDRSTRLEN];\n  char name[NI_MAXHOST];\n\n  if (sa->sa_family != AF_INET\n      && sa->sa_family != AF_INET6)\n    return 1;\n\n  (void) getnameinfo(sa, len, addr, sizeof (addr), NULL, 0, NI_NUMERICHOST);\n  err = getnameinfo(sa, len, name, sizeof (name), NULL, 0, NI_NAMEREQD);\n  if (!err)\n    {\n      if (!hosts_ctl (\"ftpd\", name, addr, STRING_UNKNOWN))\n\t{\n\t  syslog (deny_severity, \"tcpwrappers rejected: %s [%s]\",\n\t\t  name, addr);\n\t  return 0;\n\t}\n    }\n  else\n    {\n      if (!hosts_ctl (\"ftpd\", STRING_UNKNOWN, addr, STRING_UNKNOWN))\n\t{\n\t  syslog (deny_severity, \"tcpwrappers rejected: [%s]\", addr);\n\t  return 0;\n\t}\n    }\n  return (1);\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "reapchild": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\nreapchild (int signo _GL_UNUSED_PARAMETER)\n{\n  int save_errno = errno;\n\n  while (waitpid (-1, NULL, WNOHANG) > 0)\n    ;\n  errno = save_errno;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "server_mode": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "int\nserver_mode (const char *pidfile, struct sockaddr *phis_addr,\n\t     socklen_t *phis_addrlen, char *argv[])\n{\n  int ctl_sock, fd;\n  struct servent *sv;\n  int port, err;\n  char portstr[8];\n  socklen_t saved_addrlen = *phis_addrlen;\n  struct addrinfo hints, *res, *ai;\n\n  /* Become a daemon.  */\n  if (daemon (1, 1) < 0)\n    {\n      syslog (LOG_ERR, \"failed to become a daemon\");\n      return -1;\n    }\n  signal (SIGCHLD, reapchild);\n\n  /* Get port for ftp/tcp.  */\n  sv = getservbyname (\"ftp\", \"tcp\");\n  port = (sv == NULL) ? DEFPORT : ntohs (sv->s_port);\n  snprintf (portstr, sizeof (portstr), \"%u\", port);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  /* If an undetermined address family is passed,\n   * we build a dual stacked listener from an AF_INET6\n   * socket by unsetting the sockopt IPV6_V6ONLY.\n   * Otherwise the resolver often prefers AF_INET.\n   */\n  hints.ai_family = (usefamily != AF_UNSPEC) ? usefamily : AF_INET6;\n\n  err = getaddrinfo (NULL, portstr, &hints, &res);\n  if (err)\n    {\n      syslog (LOG_ERR, \"control socket: %s\", gai_strerror (err));\n      return -1;\n    }\n  /* Attempt to open socket, bind and start listen.  */\n  for (ai = res; ai; ai = ai->ai_next)\n    {\n      ctl_sock = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (ctl_sock < 0)\n\tcontinue;\n\n      /* Enable local address reuse.  */\n      {\n\tint on = 1;\n\tif (setsockopt (ctl_sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t(char *) &on, sizeof (on)) < 0)\n\t  syslog (LOG_ERR, \"control setsockopt: %m\");\n      }\n\n      /* Upgrade to dual stacked socket.  */\n      if (usefamily == AF_UNSPEC && ai->ai_family == AF_INET6)\n\t{\n\t  int off = 0;\n\t  if (setsockopt (ctl_sock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t  (char *) &off, sizeof (off)) < 0)\n\t    syslog (LOG_DEBUG, \"setsockopt bindv6only: %m\");\n\t}\n\n      if (bind (ctl_sock, ai->ai_addr, ai->ai_addrlen))\n\t{\n\t  close (ctl_sock);\n\t  ctl_sock = -1;\n\t  continue;\n\t}\n\n      if (listen (ctl_sock, 32) < 0)\n\t{\n\t  close (ctl_sock);\n\t  ctl_sock = -1;\n\t  continue;\n\t}\n\n      /* Accept the first choice!  */\n      break;\n    }\n\n  if (res)\n    freeaddrinfo (res);\n\n  if (ai == NULL)\n    {\n      syslog (LOG_ERR, \"control socket: %m\");\n      return -1;\n    }\n\n  /* Stash pid in pidfile.  */\n  {\n    FILE *pid_fp = fopen (pidfile, \"w\");\n    if (pid_fp == NULL)\n      syslog (LOG_ERR, \"can't open %s: %m\", PATH_FTPDPID);\n    else\n      {\n\tfprintf (pid_fp, \"%d\\n\", (int) getpid ());\n\tfchmod (fileno (pid_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tfclose (pid_fp);\n      }\n  }\n\n  /* Loop forever accepting connection requests and forking off\n     children to handle them.  */\n  while (1)\n    {\n      *phis_addrlen = saved_addrlen;\n      fd = accept (ctl_sock, phis_addr, phis_addrlen);\n      if (fork () == 0)\t\t/* child */\n\t{\n\t  dup2 (fd, 0);\n\t  dup2 (fd, 1);\n\t  close (ctl_sock);\n\t  break;\n\t}\n      close (fd);\n    }\n\n#ifdef WITH_WRAP\n  /* In the child.  */\n  if (!check_host (phis_addr, *phis_addrlen))\n    return -1;\n#endif\n\n#ifndef HAVE_FORK\n  _exit (execvp (argv[0], argv));\n#else\n  (void) argv;\t\t/* Silence warnings.  */\n#endif\n\n  return fd;\n}",
      "lines": 135,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/changeif.c": {
    "set_address": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nset_address (int sfd, struct ifreq *ifr, char *address)\n{\n#ifndef SIOCSIFADDR\n  error (0, 0,\n\t   \"don't know how to set an interface address on this system\");\n  return -1;\n#else\n# if HAVE_DECL_GETADDRINFO\n  int rc;\n  char addr[INET_ADDRSTRLEN];\n  struct addrinfo hints, *ai, *res;\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_INET;\n\n  rc = getaddrinfo (address, NULL, &hints, &res);\n  if (rc)\n    {\n      error (0, 0, \"cannot resolve `%s': %s\", address, gai_strerror (rc));\n      return -1;\n    }\n  for (ai = res; ai; ai = ai->ai_next)\n    if (ai->ai_family == AF_INET)\n      break;\n\n  if (ai == NULL)\n    {\n      error (0, 0, \"`%s' refers to an unknown address type\", address);\n      freeaddrinfo (res);\n      return -1;\n    }\n\n  rc = getnameinfo (ai->ai_addr, ai->ai_addrlen,\n\t\t    addr, sizeof (addr), NULL, 0,\n\t\t    NI_NUMERICHOST);\n  freeaddrinfo (res);\n  if (rc)\n    {\n      error (0, 0, \"cannot resolve `%s': %s\", address, gai_strerror (rc));\n      return -1;\n    }\n# else /* !HAVE_DECL_GETADDRINFO */\n  char *addr;\n  struct hostent *host = gethostbyname (address);\n\n  if (!host)\n    {\n      error (0, 0, \"cannot resolve `%s': %s\", address, hstrerror (h_errno));\n      return -1;\n    }\n  if (host->h_addrtype != AF_INET)\n    {\n      error (0, 0, \"`%s' refers to an unknown address type\", address);\n      return -1;\n    }\n\n  addr = inet_ntoa (*((struct in_addr *) host->h_addr));\n# endif /* !HAVE_DECL_GETADDRINFO */\n\n  {\n    SIOCSIF (ADDR, addr)\n    if (verbose)\n      printf (\"Set interface address of `%s' to %s.\\n\",\n\t      ifr->ifr_name, inet_ntoa (sin->sin_addr));\n  }\n  return 0;\n#endif\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "set_netmask": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nset_netmask (int sfd, struct ifreq *ifr, char *netmask)\n{\n#ifndef SIOCSIFNETMASK\n  error (0, 0, \"don't know how to set an interface netmask on this system\");\n  return -1;\n#else\n\n  SIOCSIF (NETMASK, netmask)\n  if (verbose)\n    printf (\"Set interface netmask of `%s' to %s.\\n\",\n\t    ifr->ifr_name, inet_ntoa (sin->sin_addr));\n  return 0;\n#endif\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "set_dstaddr": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\nset_dstaddr (int sfd, struct ifreq *ifr, char *dstaddr)\n{\n#ifndef SIOCSIFDSTADDR\n  error (0, 0,\n         \"don't know how to set an interface peer address on this system\");\n  return -1;\n#else\n  SIOCSIF (DSTADDR, dstaddr)\n  if (verbose)\n    printf (\"Set interface peer address of `%s' to %s.\\n\",\n\t    ifr->ifr_name, inet_ntoa (sin->sin_addr));\n  return 0;\n#endif\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "set_brdaddr": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nset_brdaddr (int sfd, struct ifreq *ifr, char *brdaddr)\n{\n#ifndef SIOCSIFBRDADDR\n  error (0, 0,\n         \"don't know how to set an interface broadcast address on this system\");\n  return -1;\n#else\n  SIOCSIF (BRDADDR, brdaddr)\n  if (verbose)\n    printf (\"Set interface broadcast address of `%s' to %s.\\n\",\n\t    ifr->ifr_name, inet_ntoa (sin->sin_addr));\n  return 0;\n#endif\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "set_mtu": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "int\nset_mtu (int sfd, struct ifreq *ifr, int mtu)\n{\n#ifndef SIOCSIFMTU\n  error (0, 0,\n         \"don't know how to set the interface mtu on this system\");\n  return -1;\n#else\n  int err = 0;\n\n  ifr->ifr_mtu = mtu;\n  err = ioctl (sfd, SIOCSIFMTU, ifr);\n  if (err < 0)\n    {\n      error (0, errno, \"SIOCSIFMTU failed\");\n      return -1;\n    }\n  if (verbose)\n    printf (\"Set mtu value of `%s' to `%i'.\\n\", ifr->ifr_name, ifr->ifr_mtu);\n  return 0;\n#endif\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "set_metric": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\nset_metric (int sfd, struct ifreq *ifr, int metric)\n{\n#ifndef SIOCSIFMETRIC\n  error (0, 0,\n         \"don't know how to set the interface metric on this system\");\n  return -1;\n#else\n  int err = 0;\n\n  ifr->ifr_metric = metric;\n  err = ioctl (sfd, SIOCSIFMETRIC, ifr);\n  if (err < 0)\n    {\n      error (0, errno, \"SIOCSIFMETRIC failed\");\n      return -1;\n    }\n  if (verbose)\n    printf (\"Set metric value of `%s' to `%i'.\\n\",\n\t    ifr->ifr_name, ifr->ifr_metric);\n  return 0;\n#endif\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "set_flags": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "int\nset_flags (int sfd, struct ifreq *ifr, int setflags, int clrflags)\n{\n#if !defined SIOCGIFFLAGS || !defined SIOCSIFFLAGS\n  error (0, 0,\n         \"don't know how to set the interface flags on this system\");\n  return -1;\n#else\n  struct ifreq tifr = *ifr;\n\n  if (ioctl (sfd, SIOCGIFFLAGS, &tifr) < 0)\n    {\n      error (0, errno, \"SIOCGIFFLAGS failed\");\n      return -1;\n    }\n  /* Some systems, notably FreeBSD, use two short integers.  */\n  ifr->ifr_flags = (tifr.ifr_flags | setflags) & ~clrflags & 0xffff;\n\n# ifdef ifr_flagshigh\n  ifr->ifr_flagshigh = (tifr.ifr_flagshigh | (setflags >> 16))\n\t\t       & ~(clrflags >> 16);\n# endif /* ifr_flagshigh */\n\n  if (ioctl (sfd, SIOCSIFFLAGS, ifr) < 0)\n    {\n      error (0, errno, \"SIOCSIFFLAGS failed\");\n      return -1;\n    }\n  return 0;\n#endif\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "configure_if": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int\nconfigure_if (int sfd, struct ifconfig *ifp)\n{\n  int err = 0;\n  struct ifreq ifr;\n\n  memset (&ifr, 0, sizeof (ifr));\n  strncpy (ifr.ifr_name, ifp->name, IFNAMSIZ);\n  ifr.ifr_name[IFNAMSIZ - 1] = '\\0';\n\n  if (ifp->valid & IF_VALID_ADDR)\n    err = set_address (sfd, &ifr, ifp->address);\n  if (!err && ifp->valid & IF_VALID_NETMASK)\n    err = set_netmask (sfd, &ifr, ifp->netmask);\n  if (!err && ifp->valid & IF_VALID_DSTADDR)\n    err = set_dstaddr (sfd, &ifr, ifp->dstaddr);\n  if (!err && ifp->valid & IF_VALID_BRDADDR)\n    err = set_brdaddr (sfd, &ifr, ifp->brdaddr);\n  if (!err && ifp->valid & IF_VALID_MTU)\n    err = set_mtu (sfd, &ifr, ifp->mtu);\n  if (!err && ifp->valid & IF_VALID_METRIC)\n    err = set_metric (sfd, &ifr, ifp->metric);\n  if (!err && ifp->valid & IF_VALID_SYSTEM)\n    err = system_configure (sfd, &ifr, ifp->system);\n  if (!err && (ifp->setflags || ifp->clrflags))\n    err = set_flags (sfd, &ifr, ifp->setflags, ifp->clrflags);\n  if (!err && ifp->valid & IF_VALID_FORMAT)\n    print_interface (sfd, ifp->name, &ifr, ifp->format);\n  return err;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/flags.c": {
    "cmpname": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static int\ncmpname (const void *a, const void *b)\n{\n  return strcmp (*(const char**)a, *(const char**)b);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "if_list_flags": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "char *\nif_list_flags (const char *prefix)\n{\n#define FLAGS_COMMENT \"\\nPrepend 'no' to negate the effect.\"\n  size_t len = 0;\n  struct if_flag *fp;\n  char **fnames;\n  size_t i, fcount;\n  char *str, *p;\n\n  for (fp = if_flags, len = 0, fcount = 0; fp->name; fp++)\n    if (!fp->rev)\n      {\n\tfcount++;\n\tlen += strlen (fp->name) + 1;\n      }\n\n  fcount = sizeof (if_flags) / sizeof (if_flags[0]) - 1;\n  fnames = xmalloc (fcount * sizeof (fnames[0]) + len);\n  p = (char*)(fnames + fcount);\n\n  for (fp = if_flags, i = 0; fp->name; fp++)\n    if (!fp->rev)\n      {\n\tconst char *q;\n\n\tif (fp->mask & IU_IFF_CANTCHANGE)\n\t  continue;\n\n\tfnames[i++] = p;\n\tq = fp->name;\n\tif (strncmp (q, \"NO\", 2) == 0)\n\t  q += 2;\n\tfor (; *q; q++)\n\t  *p++ = tolower (*q);\n\t*p++ = 0;\n      }\n  fcount = i;\n  qsort (fnames, fcount, sizeof (fnames[0]), cmpname);\n\n  len += strlen (\", \") * fcount;\t/* Delimiters  */\n\n  if (prefix)\n    len += strlen (prefix);\n\n  len += strlen (FLAGS_COMMENT);\n\n  str = xmalloc (len + 1);\n  p = str;\n  if (prefix)\n    {\n      strcpy (p, prefix);\n      p += strlen (prefix);\n    }\n\n  for (i = 0; i < fcount; i++)\n    {\n      /* Omit repeated, or alternate names, like \"link2/altphys\".  */\n      if (i && strncmp (fnames[i - 1], fnames[i],\n\t\t\tstrlen (fnames[i - 1])) == 0)\n\tcontinue;\n      strcpy (p, fnames[i]);\n      p += strlen (fnames[i]);\n      if (i + 1 < fcount)\n\t{\n\t  *p++ = ',';\n\t  *p++ = ' ';\n\t}\n    }\n  strcpy (p, FLAGS_COMMENT);\n  p += strlen (FLAGS_COMMENT);\n#undef FLAGS_COMMENT\n  *p = 0;\n  free (fnames);\n  return str;\n}",
      "lines": 76,
      "depth": 15,
      "decorators": [
        "char",
        "*\nif_list_flags (const char *prefix)",
        "*"
      ]
    },
    "if_flagtoname": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "const char *\nif_flagtoname (int flag, const char *avoid)\n{\n  struct if_flag *fp;\n  const char *first_match = NULL;\n  char *start;\n\n  for (fp = if_flags; ; fp++)\n    {\n      if (!fp->name)\n\treturn NULL;\n      if (flag == fp->mask && !fp->rev)\n\tbreak;\n    }\n\n  first_match = fp->name;\n\n  /* We now have found the first match.  Look for a better one.  */\n  if (avoid)\n    do\n      {\n\tstart = strstr (avoid, fp->name);\n\tif (!start || *(start - 1) != ':'\n\t    || *(start + strlen (fp->name)) != ':')\n\t  break;\n\tfp++;\n      }\n    while (fp->name);\n\n  if (fp->name)\n    return fp->name;\n  else\n    return first_match;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nif_flagtoname (int flag, const char *avoid)",
        "*"
      ]
    },
    "if_nametoflag": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "int\nif_nametoflag (const char *name, size_t len, int *prev)\n{\n  struct if_flag *fp;\n  int rev = 0;\n\n  if (len > 1 && name[0] == '-')\n    {\n      name++;\n      len--;\n      rev = 1;\n    }\n  else if (len > 2 && strncasecmp (name, \"NO\", 2) == 0)\n    {\n      name += 2;\n      len -= 2;\n      rev = 1;\n    }\n\n  for (fp = if_flags; fp->name; fp++)\n    {\n      if (strncasecmp (fp->name, name, len) == 0)\n\t{\n\t  *prev = fp->rev ^ rev;\n\t  return fp->mask;\n\t}\n    }\n  return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "if_nameztoflag": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nif_nameztoflag (const char *name, int *prev)\n{\n  return if_nametoflag (name, strlen (name), prev);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "if_format_flags": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "void\nif_format_flags (int flags, char *buf, size_t size)\n{\n  struct if_flag_char *fp;\n  size--;\n  for (fp = flag_char_tab; size && fp->mask; fp++)\n    if (fp->mask & flags)\n      {\n\t*buf++ = fp->ch;\n\tsize--;\n      }\n  *buf = 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_if_flags": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "int\nprint_if_flags (int flags, const char *avoid, char separator)\n{\n  int f = 1;\n  const char *name;\n  int first = 1;\n  int length = 0;\n\n  while (flags && f)\n    {\n      if (f & flags)\n\t{\n\t  name = if_flagtoname (f, avoid);\n\t  if (name)\n\t    {\n\t      if (!first)\n\t\t{\n\t\t  putchar (separator);\n\t\t  length++;\n\t\t}\n\t      length += printf (\"%s\", name);\n\t      flags &= ~f;\n\t      first = 0;\n\t    }\n\t}\n      f = f << 1;\n    }\n  if (flags)\n    {\n      if (!first)\n\t{\n\t  putchar (separator);\n\t  length++;\n\t}\n      length += printf (\"%#x\", flags);\n    }\n  return length;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/flags.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/ifconfig.c": {
    "main": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int err = 0;\n  int sfd;\n  struct ifconfig *ifp;\n  set_program_name (argv[0]);\n  parse_cmdline (argc, argv);\n\n  sfd = socket (AF_INET, SOCK_STREAM, 0);\n  if (sfd < 0)\n    {\n      error (0, errno, \"socket error\");\n      exit (EXIT_FAILURE);\n    }\n\n  for (ifp = ifs; ifp < ifs + nifs; ifp++)\n    {\n      if (list_mode)\n\t{\n\t  /* Protect against mistakes in use of `-i'.  */\n\t  if (!if_nametoindex (ifp->name))\n\t    continue;\n\n\t  /* Use ERR as a marker of previous output.\n\t   * It will never interfere with a call to configure_if().  */\n\t  if (err++)\n\t    putchar (' ');\n\t  printf (\"%s\", ifp->name);\n\t  continue;\n\t}\n\n      err = configure_if (sfd, ifp);\n      if (err)\n\tbreak;\n    }\n\n  if (list_mode && err)\n    putchar ('\\n');\n\n  close (sfd);\n  return err;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/ifconfig.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/options.c": {
    "format_find": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "struct format *\nformat_find (const char *name)\n{\n  struct format *frm;\n\n  for (frm = formats; frm->name; frm++)\n    {\n      if (strcmp (frm->name, name) == 0)\n\treturn frm;\n    }\n  return NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "struct format",
        "struct",
        "format",
        "*\nformat_find (const char *name)",
        "*"
      ]
    },
    "parse_opt_new_ifs": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "struct ifconfig *\nparse_opt_new_ifs (char *name)\n{\n  struct ifconfig *ifp;\n\n  ifs_cmdline = 1;\n  ifs = realloc (ifs, ++nifs * sizeof (struct ifconfig));\n  if (!ifs)\n    error (EXIT_FAILURE, errno,\n\t   \"can't get memory for interface configuration\");\n  ifp = &ifs[nifs - 1];\n  *ifp = ifconfig_initializer;\n  ifp->name = name;\n  return ifp;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "struct ifconfig",
        "struct",
        "ifconfig",
        "*\nparse_opt_new_ifs (char *name)",
        "*"
      ]
    },
    "parse_opt_set_af": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void parse_opt_set_af (struct ifconfig *ifp, char *af)\n{\n  if (!ifp)\n    error (EXIT_FAILURE, 0,\n\t   \"no interface specified for address family `%s'\", af);\n\n  if (!strcasecmp (af, \"inet\"))\n    ifp->af = AF_INET;\n  else\n    error (EXIT_FAILURE, 0,\n\t   \"unknown address family `%s' for interface `%s': is not a number\",\n\t   af, ifp->name);\n  ifp->valid |= IF_VALID_AF;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "parse_opt_set_flag": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void\nparse_opt_set_flag (struct ifconfig *ifp _GL_UNUSED_PARAMETER,\n\t\t    int flag, int rev)\n{\n  if (rev)\n    {\n      pending_clrflags |= flag;\n      pending_setflags &= ~flag;\n    }\n  else\n    {\n      pending_setflags |= flag;\n      pending_clrflags &= ~flag;\n    }\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "parse_opt_flag_list": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "void\nparse_opt_flag_list (struct ifconfig *ifp, const char *name)\n{\n  while (*name)\n    {\n      int mask, rev;\n      char *p = strchr (name, ',');\n      size_t len;\n\n      if (p)\n\tlen = p - name;\n      else\n\tlen = strlen (name);\n\n      if ((mask = if_nametoflag (name, len, &rev)) == 0)\n\terror (EXIT_FAILURE, 0, \"unknown flag %*.*s\",\n\t       (int) len, (int) len, name);\n      parse_opt_set_flag (ifp, mask, rev);\n\n      name += len;\n      if (p)\n\tname++;\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "parse_opt_set_point_to_point": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        411,
        1
      ],
      "content": "void\nparse_opt_set_point_to_point (struct ifconfig *ifp, char *addr)\n{\n  parse_opt_set_dstaddr (ifp, addr);\n  parse_opt_set_flag (ifp, IFF_POINTOPOINT, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "parse_opt_set_default_format": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "void\nparse_opt_set_default_format (const char *format)\n{\n  struct format *frm;\n\n  if (!format)\n    format = system_default_format ? system_default_format : \"default\";\n\n  for (frm = formats; frm->name; frm++)\n    if (!strcmp (format, frm->name)) break;\n  if (frm == NULL || frm->templ == NULL)\n    error (EXIT_FAILURE, 0, \"%s: unknown output format\", format);\n  default_format = frm->templ;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "is_comment_line": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "static int\nis_comment_line (const char *p, size_t len)\n{\n  while (len--)\n    {\n      int c = *p++;\n      switch (c)\n\t{\n\tcase ' ':\n\tcase '\\t':\n\t  continue;\n\n\tcase '#':\n\t  return 1;\n\n\tdefault:\n\t  return 0;\n\t}\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_opt_set_default_format_from_file": {
      "start_point": [
        450,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "void\nparse_opt_set_default_format_from_file (const char *file)\n{\n  static struct obstack stk;\n  FILE *fp;\n  char *buf = NULL;\n  size_t size = 0;\n\n  fp = fopen (file, \"r\");\n  if (!fp)\n    error (EXIT_FAILURE, errno, \"cannot open format file %s\", file);\n\n  obstack_init (&stk);\n  while (getline (&buf, &size, fp) > 0)\n    {\n      size_t len = strlen (buf);\n\n      if (len >= 1 && buf[len-1] == '\\n')\n\tlen--;\n\n      if (len == 0 || is_comment_line (buf, len))\n\tcontinue;\n      obstack_grow (&stk, buf, len);\n    }\n  free (buf);\n  fclose (fp);\n  obstack_1grow (&stk, 0);\n  default_format = obstack_finish (&stk);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "parse_opt_finalize": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "void\nparse_opt_finalize (struct ifconfig *ifp)\n{\n  if (ifp && !ifp->valid)\n    {\n      ifp->valid = IF_VALID_FORMAT;\n      ifp->format = default_format;\n      ifp->setflags |= pending_setflags;\n      ifp->clrflags |= pending_clrflags;\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        576,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  struct ifconfig *ifp = *(struct ifconfig **)state->input;\n\n  switch (key)\n    {\n    case ARGP_KEY_INIT:\n      state->child_inputs[0] = state->input;\n      break;\n\n    case 'i':\t\t/* Interface name.  */\n      parse_opt_finalize (ifp);\n      ifp = parse_opt_new_ifs (arg);\n      *(struct ifconfig **) state->input = ifp;\n      break;\n\n    case 'a':\n      all_option = 1;\n      break;\n\n    case 'A':\t\t/* Interface address.  */\n      parse_opt_set_address (ifp, arg);\n      break;\n\n    case 'm':\t\t/* Interface netmask.  */\n      parse_opt_set_netmask (ifp, arg);\n      break;\n\n    case 'd':\t\t/* Interface dstaddr.  */\n    case 'p':\n      parse_opt_set_point_to_point (ifp, arg);\n      break;\n\n    case 'b':\t\t/* Interface broadcast address.  */\n    case 'B':\n      parse_opt_set_brdaddr (ifp, arg);\n      break;\n\n    case 'F':\n      parse_opt_flag_list (ifp, arg);\n      break;\n\n    case 'M':\t\t/* Interface MTU.  */\n      parse_opt_set_mtu (ifp, arg);\n      break;\n\n    case 's':\n      parse_opt_set_default_format (\"netstat\");\n      break;\n\n    case 'l':\n      list_mode++;\n      break;\n\n    case 'v':\n      verbose++;\n      break;\n\n    case METRIC_OPTION:\t\t/* Interface metric.  */\n      parse_opt_set_metric (ifp, arg);\n      break;\n\n    case FORMAT_OPTION:\t\t/* Output format.  */\n      if (arg && arg[0] == '@')\n\tparse_opt_set_default_format_from_file (arg + 1);\n      else\n\tparse_opt_set_default_format (arg);\n      break;\n\n    case UP_OPTION:\n      parse_opt_set_flag (ifp, IFF_UP | IFF_RUNNING, 0);\n      break;\n\n    case DOWN_OPTION:\n      parse_opt_set_flag (ifp, IFF_UP, 1);\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "default_help_filter": {
      "start_point": [
        578,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "static char *\ndefault_help_filter (int key, const char *text,\n\t\t     void *input _GL_UNUSED_PARAMETER)\n{\n  char *s;\n\n  switch (key)\n    {\n    default:\n      s = (char*) text;\n      break;\n\n    case ARGP_KEY_HELP_EXTRA:\n      s = if_list_flags (\"Known flags are: \");\n    }\n  return s;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ndefault_help_filter (int key, const char *text,\n\t\t     void *input _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "cmp_if_name": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\ncmp_if_name (const void *a, const void *b)\n{\n  const struct ifconfig *ifa = a;\n  const struct ifconfig *ifb = b;\n\n  return strcmp (ifa->name, ifb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_cmdline": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "void\nparse_cmdline (int argc, char *argv[])\n{\n  int index;\n  struct ifconfig *ifp = ifs;\n\n  parse_opt_set_default_format (NULL);\n  iu_argp_init (\"ifconfig\", program_authors);\n  argp_children[0] = system_argp_child;\n  argp.children = argp_children;\n  argp.args_doc = system_help;\n  argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &index, &ifp);\n\n  parse_opt_finalize (ifp);\n\n  if (index < argc)\n    {\n      if (!system_parse_opt_rest (&ifp, argc - index, &argv[index]))\n\terror (EXIT_FAILURE, 0, \"invalid arguments\");\n      parse_opt_finalize (ifp);\n    }\n  if (!ifs)\n    {\n      /* No interfaces specified.  Get a list of all interfaces.  */\n      struct if_nameindex *ifnx, *ifnxp;\n\n      ifnx = ifnxp = system_if_nameindex ();\n      if (!ifnx)\n\terror (EXIT_FAILURE, 0, \"could not get list of interfaces\");\n      while (ifnxp->if_index != 0 || ifnxp->if_name != NULL)\n\t{\n\t  struct ifconfig *ifp;\n\n\t  ifs = realloc (ifs, ++nifs * sizeof (struct ifconfig));\n\t  if (!ifs)\n\t    error (EXIT_FAILURE, errno,\n\t\t   \"can't get memory for interface configuration\");\n\t  ifp = &ifs[nifs - 1];\n\t  *ifp = ifconfig_initializer;\n\t  ifp->name = ifnxp->if_name;\n\t  ifp->valid = IF_VALID_FORMAT;\n\t  ifp->format = default_format;\n\t  ifnxp++;\n\t}\n      /* XXX: We never do if_freenameindex (ifnx), because we are\n\t keeping the names for later instead using strdup\n\t (if->if_name) here.  */\n\n      qsort (ifs, nifs, sizeof (ifs[0]), cmp_if_name);\n    }\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/options.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/printif.c": {
    "put_char": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nput_char (format_data_t form _GL_UNUSED_PARAMETER, char c)\n{\n  switch (c)\n    {\n    case '\\n':\n      *column = 0;\n      break;\n    case '\\t':\n      *column = ((*column / TAB_STOP) + 1) * TAB_STOP;\n      break;\n    default:\n      (*column)++;\n    }\n  putc (c, ostream);\n  had_output = 1;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "put_string": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nput_string (format_data_t form, const char *s)\n{\n  while (*s != '\\0')\n    put_char (form, *(s++));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "put_int": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "void\nput_int (format_data_t form _GL_UNUSED_PARAMETER,\n\t int argc, char *argv[], int nr)\n{\n  char *fmt;\n  if (argc > 0)\n    {\n      char *p = argv[0];\n\n      if (*p != '%')\n\tfmt = \"%i\";\n      else\n\t{\n\t  p++;\n\n\t  if (*p == '#')\n\t    p++;\n\n\t  while (isdigit (*p))\n\t    p++;\n\n\t  if ((*p == 'h' || *p == 'H') && p[1])\n\t    ++p; /* Half length modifier, go to type specifier.  */\n\n\t  switch (*p)\n\t    {\n\t    default:\n\t    case 'i':\n\t    case 'd':\n\t    case 'D':\n\t      *p = 'i';\n\t      break;\n\t    case 'x':\n\t    case 'h':\n\t      *p = 'x';\n\t      break;\n\t    case 'X':\n\t    case 'H':\n\t      *p = 'X';\n\t      break;\n\t    case 'o':\n\t    case 'O':\n\t      *p = 'o';\n\t      break;\n\t    }\n\t  p++;\n\t  *p = '\\0';\n\t  fmt = argv[0];\n\t}\n    }\n  else\n    fmt = \"%i\";\n\n  *column += printf (fmt, nr);\n  had_output = 1;\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "put_ulong": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void\nput_ulong (format_data_t form _GL_UNUSED_PARAMETER,\n\t   int argc, char *argv[], unsigned long value)\n{\n  char *fmt;\n  if (argc > 0)\n    {\n      char *p = argv[0];\n\n      if (*p != '%')\n\tfmt = \"%lu\";\n      else\n\t{\n\t  p++;\n\n\t  while (isdigit (*p))\n\t    p++;\n\n\t  if (*p == '#')\n\t    p++;\n\n\t  if (*p == 'l')\n\t    p++;\n\n\t  switch (*p)\n\t    {\n\t    default:\n\t    case 'i':\n\t    case 'd':\n\t    case 'D':\n\t      *p = 'i';\n\t      break;\n\t    case 'x':\n\t    case 'h':\n\t      *p = 'x';\n\t      break;\n\t    case 'X':\n\t    case 'H':\n\t      *p = 'X';\n\t      break;\n\t    case 'o':\n\t    case 'O':\n\t      *p = 'o';\n\t      break;\n\t    }\n\t  p++;\n\t  *p = '\\0';\n\t  fmt = argv[0];\n\t}\n    }\n  else\n    fmt = \"%lu\";\n\n  *column += printf (fmt, value);\n  had_output = 1;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "select_arg": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\nselect_arg (format_data_t form, int argc, char *argv[], int nr)\n{\n  if (nr < argc)\n    {\n      form->format = argv[nr];\n      print_interfaceX (form, 0);\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "put_addr": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "void\nput_addr (format_data_t form, int argc, char *argv[], struct sockaddr *sa)\n{\n  struct sockaddr_in *sin = (struct sockaddr_in *) sa;\n  char *addr = inet_ntoa (sin->sin_addr);\n  long byte[4];\n  char *p = strchr (addr, '.');\n\n  *p = '\\0';\n  byte[0] = strtol (addr, NULL, 0);\n  addr = p + 1;\n  p = strchr (addr, '.');\n  *p = '\\0';\n  byte[1] = strtol (addr, NULL, 0);\n  addr = p + 1;\n  p = strchr (addr, '.');\n  *p = '\\0';\n  byte[2] = strtol (addr, NULL, 0);\n  byte[3] = strtol (p + 1, NULL, 0);\n\n  addr = inet_ntoa (sin->sin_addr);\n\n  if (argc > 0)\n    {\n      long i = strtol (argv[0], NULL, 0);\n      if (i >= 0 && i <= 3)\n\tput_int (form, argc - 1, &argv[1], byte[i]);\n    }\n  else\n    put_string (form, addr);\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "put_flags": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "void\nput_flags (format_data_t form, int argc, char *argv[], int flags)\n{\n  unsigned int f = 1;\n  const char *name;\n  int first = 1;\n  unsigned int uflags = (unsigned int) flags;\n\n  while (uflags && f)\n    {\n      if (f & uflags)\n\t{\n\t  name = if_flagtoname (f, NULL);\n\t  if (name)\n\t    {\n\t      if (!first)\n\t\t{\n\t\t  if (argc > 0)\n\t\t    put_string (form, argv[0]);\n\t\t  else\n\t\t    put_char (form, ' ');\n\t\t}\n\t      put_string (form, name);\n\t      uflags &= ~f;\n\t      first = 0;\n\t    }\n\t}\n      f = f << 1;\n    }\n  if (uflags)\n    {\n      if (!first)\n\t{\n\t  if (argc > 0)\n\t    put_string (form, argv[0]);\n\t  else\n\t    put_char (form, ' ');\n\t}\n      put_int (form, argc - 1, &argv[1], uflags);\n    }\n}",
      "lines": 41,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "put_flags_short": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "void\nput_flags_short (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t char *argv[] _GL_UNUSED_PARAMETER, int flags)\n{\n  char buf[IF_FORMAT_FLAGS_BUFSIZE];\n  if_format_flags (flags, buf, sizeof buf);\n  put_string (form, buf);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "format_handler": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "void\nformat_handler (const char *name, format_data_t form, int argc, char *argv[])\n{\n  struct format_handle *fh;\n\n  for (fh = format_handles; fh->name; fh++)\n    {\n      if (!strcmp (fh->name, name))\n\t{\n\t  if (fh->handler)\n\t    (fh->handler) (form, argc, argv);\n\t  return;\n\t}\n    }\n\n  *column += printf (\"(\");\n  put_string (form, name);\n  *column += printf (\" unknown)\");\n  had_output = 1;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "fh_nothing": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "void\nfh_nothing (format_data_t form _GL_UNUSED_PARAMETER,\n\t    int argc _GL_UNUSED_PARAMETER,\n\t    char *argv[] _GL_UNUSED_PARAMETER)\n{\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_format_query": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "void\nfh_format_query (format_data_t form, int argc, char *argv[])\n{\n  if (argc < 1)\n    return;\n  select_arg (form, argc, argv, format_find (argv[0]) ? 1 : 2);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_docstr": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "void\nfh_docstr (format_data_t form, int argc, char *argv[])\n{\n  const char *name;\n  struct format *frm;\n\n  name = (argc == 0) ? form->name : argv[0];\n  frm = format_find (name);\n  if (!frm)\n    error (EXIT_FAILURE, errno, \"unknown format: `%s'\", name);\n  put_string (form, frm->docstr);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_defn": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "void\nfh_defn (format_data_t form, int argc, char *argv[])\n{\n  const char *name;\n  struct format *frm;\n\n  name = (argc == 0) ? form->name : argv[0];\n\n  frm = format_find (name);\n  if (!frm)\n    error (EXIT_FAILURE, errno, \"unknown format: `%s'\", name);\n  put_string (form, frm->templ);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_foreachformat": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "void\nfh_foreachformat (format_data_t form, int argc, char *argv[])\n{\n  struct format *frm;\n  const char *save_name;\n\n  if (argc == 0)\n    return;\n\n  save_name = form->name;\n  for (frm = formats; frm->name; frm++)\n    {\n      form->name = frm->name;\n      form->format = argv[0];\n      print_interfaceX (form, 0);\n    }\n  form->name = save_name;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_newline": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void\nfh_newline (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t    char *argv[] _GL_UNUSED_PARAMETER)\n{\n  put_char (form, '\\n');\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_tabulator": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "void\nfh_tabulator (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t      char *argv[] _GL_UNUSED_PARAMETER)\n{\n  put_char (form, '\\t');\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_rep": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void\nfh_rep (format_data_t form, int argc, char *argv[])\n{\n  unsigned int count;\n  char *p;\n\n  if (argc < 2)\n    return;\n  count = strtoul (argv[0], &p, 10);\n  if (*p)\n    error (EXIT_FAILURE, 0, \"invalid repeat count\");\n  while (count--)\n    {\n      form->format = argv[1];\n      print_interfaceX (form, 0);\n    }\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_first": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void\nfh_first (format_data_t form, int argc, char *argv[])\n{\n  select_arg (form, argc, argv, form->first ? 0 : 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_ifdisplay_query": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void\nfh_ifdisplay_query (format_data_t form, int argc, char *argv[])\n{\n  int n;\n\n#ifdef SIOCGIFFLAGS\n  /* Request for all, or for a specified interface?  */\n  n = all_option || ifs_cmdline;\n  if (!n)\n    {\n      /* Otherwise, only interfaces in state `UP' are displayed.  */\n      int rev = 0;\n      int f = if_nameztoflag (\"UP\", &rev);\n\n      n = f && ioctl (form->sfd, SIOCGIFFLAGS, form->ifr) == 0;\n      if (n) {\n\tunsigned int uflags = (unsigned short) form->ifr->ifr_flags;\n\n# ifdef ifr_flagshigh\n\tuflags |= (unsigned short) form->ifr->ifr_flagshigh << 16;\n# endif /* ifr_flagshigh */\n\n\tn = n && (f & uflags);\n      };\n    }\n#else\n  n = 1;\t/* Display all of them.  */\n#endif\n  select_arg (form, argc, argv, !n);\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "fh_verbose_query": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "void\nfh_verbose_query (format_data_t form, int argc, char *argv[])\n{\n  select_arg (form, argc, argv, verbose ? 0 : 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fh_tab": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "void\nfh_tab (format_data_t form, int argc, char *argv[])\n{\n  long goal = 0;\n\n  errno = 0;\n  if (argc >= 1)\n    goal = strtol (argv[0], NULL, 0);\n  if (goal <= 0)\n    goal = ((*column / TAB_STOP) + 1) * TAB_STOP;\n\n  while (*column < goal)\n    put_char (form, ' ');\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "fh_join": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "void\nfh_join (format_data_t form, int argc, char *argv[])\n{\n  int had_output_saved = had_output;\n  int count = 0;\n\n  if (argc < 2)\n    return;\n\n  /* Suppress delimiter before first argument.  */\n  had_output = 0;\n\n  while (++count < argc)\n    {\n      if (had_output)\n\t{\n\t  put_string (form, argv[0]);\n\t  had_output = 0;\n\t  had_output_saved = 1;\n\t}\n      form->format = argv[count];\n      print_interfaceX (form, 0);\n    }\n  had_output = had_output_saved;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_exists_query": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "void\nfh_exists_query (format_data_t form, int argc, char *argv[])\n{\n  if (argc > 0)\n    {\n      struct format_handle *fh;\n      int sel = 2; /* assume 2nd arg by default */\n\n      for (fh = format_handles; fh->name; fh++)\n\t{\n\t  if (!strcmp (fh->name, argv[0]))\n\t    {\n\t      sel = 1; /* select 1st argument */\n\t      break;\n\t    }\n\t}\n      select_arg (form, argc, argv, sel);\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fh_format": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "void\nfh_format (format_data_t form, int argc, char *argv[])\n{\n  int i;\n\n  for (i = 0; i < argc; i++)\n    {\n      struct format *frm = format_find (argv[i]);\n\n      if (frm)\n\t{\n\t  /* XXX: Avoid infinite recursion by appending name to a list\n\t     during the next call (but removing it afterwards, and\n\t     checking in this function if the name is in the list\n\t     already.  */\n\t  form->format = frm->templ;\n\t  print_interfaceX (form, 0);\n\t  break;\n\t}\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_error": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "void\nfh_error (format_data_t form, int argc, char *argv[])\n{\n  int i;\n  FILE *s = ostream;\n  int *c = column;\n\n  ostream = stderr;\n  column = &column_stderr;\n  for (i = 0; i < argc; i++)\n    select_arg (form, argc, argv, i);\n  ostream = s;\n  column = c;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fh_progname": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "void\nfh_progname (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t     char *argv[] _GL_UNUSED_PARAMETER)\n{\n  put_string (form, program_name);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_exit": {
      "start_point": [
        621,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "void\nfh_exit (format_data_t form _GL_UNUSED_PARAMETER,\n\t int argc, char *argv[])\n{\n  int err = 0;\n\n  if (argc > 0)\n    err = strtoul (argv[0], NULL, 0);\n\n  exit (err);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fh_name": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "void\nfh_name (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t char *argv[] _GL_UNUSED_PARAMETER)\n{\n  put_string (form, form->name);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_index_query": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "void\nfh_index_query (format_data_t form, int argc, char *argv[])\n{\n  select_arg (form, argc, argv, (if_nametoindex (form->name) == 0) ? 1 : 0);\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "fh_index": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "void\nfh_index (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n  int indx = if_nametoindex (form->name);\n\n  if (indx == 0)\n    error (EXIT_FAILURE, errno,\n\t   \"No index number found for interface `%s'\",\n\t   form->name);\n  *column += printf (\"%i\", indx);\n  had_output = 1;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_addr_query": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "void\nfh_addr_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFADDR\n  if (ioctl (form->sfd, SIOCGIFADDR, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_addr": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "void\nfh_addr (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFADDR\n  if (ioctl (form->sfd, SIOCGIFADDR, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFADDR failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_addr (form, argc, argv, &form->ifr->ifr_addr);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_netmask_query": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "void\nfh_netmask_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFNETMASK\n  if (ioctl (form->sfd, SIOCGIFNETMASK, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_netmask": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "void\nfh_netmask (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFNETMASK\n  if (ioctl (form->sfd, SIOCGIFNETMASK, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFNETMASK failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_addr (form, argc, argv, &form->ifr->ifr_netmask);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_brdaddr_query": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        740,
        1
      ],
      "content": "void\nfh_brdaddr_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFBRDADDR\n# ifdef SIOCGIFFLAGS\n  int f;\n  int rev;\n  unsigned int uflags = (unsigned short) form->ifr->ifr_flags;\n\n# ifdef ifr_flagshigh\n  uflags |= (unsigned short) form->ifr->ifr_flagshigh << 16;\n# endif /* ifr_flagshigh */\n\n  if (0 == (f = if_nameztoflag (\"BROADCAST\", &rev))\n      || (ioctl (form->sfd, SIOCGIFFLAGS, form->ifr) < 0)\n      || ((f & uflags) == 0))\n    {\n      select_arg (form, argc, argv, 1);\n      return;\n    }\n# endif\n  if (ioctl (form->sfd, SIOCGIFBRDADDR, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "fh_brdaddr": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "void\nfh_brdaddr (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFBRDADDR\n  if (ioctl (form->sfd, SIOCGIFBRDADDR, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFBRDADDR failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_addr (form, argc, argv, &form->ifr->ifr_broadaddr);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_dstaddr_query": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        784,
        1
      ],
      "content": "void\nfh_dstaddr_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFDSTADDR\n# ifdef SIOCGIFFLAGS\n  int f;\n  int rev;\n  unsigned int uflags = (unsigned short) form->ifr->ifr_flags;\n\n#  ifdef ifr_flagshigh\n  uflags |= (unsigned short) form->ifr->ifr_flagshigh << 16;\n#  endif /* ifr_flagshigh */\n\n  if (0 == (f = if_nameztoflag (\"POINTOPOINT\", &rev))\n      || (ioctl (form->sfd, SIOCGIFFLAGS, form->ifr) < 0)\n      || ((f & uflags) == 0))\n    {\n      select_arg (form, argc, argv, 1);\n      return;\n    }\n# endif\n  if (ioctl (form->sfd, SIOCGIFDSTADDR, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "fh_dstaddr": {
      "start_point": [
        786,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "void\nfh_dstaddr (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFDSTADDR\n  if (ioctl (form->sfd, SIOCGIFDSTADDR, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFDSTADDR failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_addr (form, argc, argv, &form->ifr->ifr_dstaddr);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_mtu_query": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        811,
        1
      ],
      "content": "void\nfh_mtu_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMTU\n  if (ioctl (form->sfd, SIOCGIFMTU, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_mtu": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "void\nfh_mtu (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMTU\n  if (ioctl (form->sfd, SIOCGIFMTU, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFMTU failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_int (form, argc, argv, form->ifr->ifr_mtu);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_metric_query": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "void\nfh_metric_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMETRIC\n  if (ioctl (form->sfd, SIOCGIFMETRIC, form->ifr) >= 0\n      && form->ifr->ifr_metric > 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fh_metric": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "void\nfh_metric (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMETRIC\n  if (ioctl (form->sfd, SIOCGIFMETRIC, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFMETRIC failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_int (form, argc, argv, form->ifr->ifr_metric);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_flags_query": {
      "start_point": [
        860,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "void\nfh_flags_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFFLAGS\n  if (ioctl (form->sfd, SIOCGIFFLAGS, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_flags": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "void\nfh_flags (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFFLAGS\n  if (ioctl (form->sfd, SIOCGIFFLAGS, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFFLAGS failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    {\n      unsigned int uflags = (unsigned short) form->ifr->ifr_flags;\n\n# ifdef ifr_flagshigh\n      uflags |= (unsigned short) form->ifr->ifr_flagshigh << 16;\n# endif /* ifr_flagshigh */\n\n      if (argc >= 1)\n\t{\n\t  if (!strcmp (argv[0], \"number\"))\n\t    put_int (form, argc - 1, &argv[1], uflags);\n\t  else if (!strcmp (argv[0], \"short\"))\n\t    put_flags_short (form, argc - 1, &argv[1], uflags);\n\t  else if (!strcmp (argv[0], \"string\"))\n\t    put_flags (form, argc - 1, &argv[1], uflags);\n\t}\n      else\n\tput_flags (form, argc, argv, uflags);\n    }\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 33,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "fh_media_query": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "void\nfh_media_query (format_data_t form, int argc, char *argv[])\n{\n  /* Must be overridden by a system dependent implementation.  */\n\n  /* Claim it to be absent.  */\n  select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fh_media": {
      "start_point": [
        914,
        0
      ],
      "end_point": [
        920,
        1
      ],
      "content": "void\nfh_media (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n  /* Must be overridden by a system dependent implementation.  */\n  put_string (form, \"(not known)\");\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_status_query": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        929,
        1
      ],
      "content": "void\nfh_status_query (format_data_t form, int argc, char *argv[])\n{\n  /* Must be overridden by a system dependent implementation.  */\n\n  /* Claim it to be absent.  */\n  select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fh_status": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "void\nfh_status (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t   char *argv[] _GL_UNUSED_PARAMETER)\n{\n  /* Must be overridden by a system dependent implementation.  */\n  put_string (form, \"(not known)\");\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_map_query": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "void\nfh_map_query (format_data_t form, int argc, char *argv[])\n{\n# ifdef SIOCGIFMAP\n  if (ioctl (form->sfd, SIOCGIFMAP, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n# endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_irq_query": {
      "start_point": [
        952,
        0
      ],
      "end_point": [
        959,
        1
      ],
      "content": "void\nfh_irq_query (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.irq)\n    select_arg (form, argc, argv, 0);\n  else\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_irq": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "void\nfh_irq (format_data_t form, int argc, char *argv[])\n{\n  put_int (form, argc, argv, form->ifr->ifr_map.irq);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fh_baseaddr_query": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "void\nfh_baseaddr_query (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.base_addr >= 0x100)\n    select_arg (form, argc, argv, 0);\n  else\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fh_baseaddr": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        983,
        1
      ],
      "content": "void\nfh_baseaddr (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.base_addr >= 0x100)\n    put_int (form, argc, argv, form->ifr->ifr_map.base_addr);\n  else\n    put_string (form, \"(not available)\");\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_memstart_query": {
      "start_point": [
        985,
        0
      ],
      "end_point": [
        992,
        1
      ],
      "content": "void\nfh_memstart_query (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.mem_start)\n    select_arg (form, argc, argv, 0);\n  else\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_memstart": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "void\nfh_memstart (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.mem_start)\n    put_ulong (form, argc, argv, form->ifr->ifr_map.mem_start);\n  else\n    put_string (form, \"(not available)\");\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_memend_query": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "void\nfh_memend_query (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.mem_end)\n    select_arg (form, argc, argv, 0);\n  else\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_memend": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "void\nfh_memend (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.mem_end)\n    put_ulong (form, argc, argv, form->ifr->ifr_map.mem_end);\n  else\n    put_string (form, \"(not available)\");\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fh_dma_query": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1028,
        1
      ],
      "content": "void\nfh_dma_query (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.dma)\n    select_arg (form, argc, argv, 0);\n  else\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fh_dma": {
      "start_point": [
        1030,
        0
      ],
      "end_point": [
        1037,
        1
      ],
      "content": "void\nfh_dma (format_data_t form, int argc, char *argv[])\n{\n  if (form->ifr->ifr_map.dma)\n    put_int (form, argc, argv, form->ifr->ifr_map.dma);\n  else\n    put_string (form, \"(not available)\");\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_interfaceX": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "void\nprint_interfaceX (format_data_t form, int quiet)\n{\n  const char *p = form->format;\n  const char *q;\n\n  form->depth++;\n\n  while (!(*p == '\\0' || (form->depth > 1 && *p == '}')))\n    {\n      /* Echo until end of string or '$'.  */\n      while (!(*p == '$' || *p == '\\0' || (form->depth > 1 && *p == '}')))\n\t{\n\t  quiet || (put_char (form, *p), 0);\n\t  p++;\n\t}\n\n      if (*p != '$')\n\tbreak;\n\n      /* Look at next character.  If it is a '$' or '}', print that\n\t and skip the '$'.  If it is something else than '{', print\n\t both.  Otherwise enter substitution mode.  */\n      switch (*(++p))\n\t{\n\tdefault:\n\t  quiet || (put_char (form, '$'), 0);\n\t  /* Fallthrough. */\n\n\tcase '$':\n\tcase '}':\n\t  quiet || (put_char (form, *p), 0);\n\t  p++;\n\t  continue;\n\t  /* Not reached.  */\n\n\tcase '{':\n\t  p++;\n\t  break;\n\t}\n\n      /* P points to character following '{' now.  */\n      q = strchr (p, '}');\n      if (!q)\n\t{\n\t  /* Without a following '}', no substitution at all can occure,\n\t     so just dump the string that is missing.  */\n\t  p -= 2;\n\t  put_string (form, p);\n\t  p = strchr (p, '\\0');\n\t  continue;\n\t}\n      else\n\t{\n\t  char *id;\n\t  id = alloca (q - p + 1);\n\t  memcpy (id, p, q - p);\n\t  id[q - p] = '\\0';\n\t  p = q + 1;\n\n\t  /* We have now in ID the content of the first field, and\n\t     in P the following string.  Now take the arguments. */\n\t  if (quiet)\n\t    {\n\t      /* Just consume all arguments.  */\n\t      form->format = p;\n\n\t      while (*(form->format) == '{')\n\t\t{\n\t\t  form->format++;\n\t\t  print_interfaceX (form, 1);\n\t\t  if (*(form->format) == '}')\n\t\t    form->format++;\n\t\t}\n\n\t      p = form->format;\n\t    }\n\t  else\n\t    {\n\t      int argc = 0;\n\t      char **argv;\n\t      argv = alloca (strlen (q) / 2);\n\n\t      while (*p == '{')\n\t\t{\n\t\t  p++;\n\t\t  form->format = p;\n\t\t  print_interfaceX (form, 1);\n\t\t  q = form->format;\n\t\t  argv[argc] = xmalloc (q - p + 1);\n\t\t  memcpy (argv[argc], p, q - p);\n\t\t  argv[argc][q - p] = '\\0';\n\t\t  if (*q == '}')\n\t\t    q++;\n\t\t  p = q;\n\t\t  argc++;\n\t\t}\n\n\t      format_handler (id, form, argc, argv);\n\n\t      /* Clean up.  */\n\t      form->format = p;\n\t      while (--argc >= 0)\n\t\tfree (argv[argc]);\n\t    }\n\t}\n    }\n\n  form->format = p;\n  form->depth--;\n}",
      "lines": 111,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "print_interface": {
      "start_point": [
        1153,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "void\nprint_interface (int sfd, const char *name, struct ifreq *ifr,\n\t\t const char *format)\n{\n  struct format_data form;\n  static int first_passed_already;\n\n  if (!ostream)\n    ostream = stdout;\n\n  if (!first_passed_already)\n    first_passed_already = form.first = 1;\n  else\n    form.first = 0;\n\n  form.name = name;\n  form.ifr = ifr;\n  form.format = format;\n  form.sfd = sfd;\n  form.depth = 0;\n\n  print_interfaceX (&form, 0);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/printif.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system.c": {},
  "inetutils/inetutils-1.9.4/ifconfig/system.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system/bsd.c": {
    "system_parse_opt": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nsystem_parse_opt (struct ifconfig **ifp _GL_UNUSED_PARAMETER,\n\t\t  char option _GL_UNUSED_PARAMETER,\n\t\t  char *optarg _GL_UNUSED_PARAMETER)\n{\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "system_parse_opt_rest": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\nsystem_parse_opt_rest (struct ifconfig **ifp, int argc, char *argv[])\n{\n  int i = 0, mask, rev;\n  enum\n  {\n    EXPECT_NOTHING,\n    EXPECT_COMMAND,\n    EXPECT_AF,\n    EXPECT_BROADCAST,\n    EXPECT_NETMASK,\n    EXPECT_METRIC,\n    EXPECT_MTU\n  } expect = EXPECT_COMMAND;\n\n  *ifp = parse_opt_new_ifs (argv[0]);\n\n  while (++i < argc)\n    {\n      switch (expect)\n\t{\n\tcase EXPECT_BROADCAST:\n\t  parse_opt_set_brdaddr (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_NETMASK:\n\t  parse_opt_set_netmask (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_MTU:\n\t  parse_opt_set_mtu (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_METRIC:\n\t  parse_opt_set_metric (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_COMMAND:\n\t  expect = EXPECT_AF;\t\t/* Applicable at creation.  */\n\t  if (!strcmp (argv[i], \"create\"))\n\t    {\n\t      error (0, 0, \"interface creation is not supported\");\n\t      return 0;\n\t    }\n\t  else if (!strcmp (argv[i], \"destroy\"))\n\t    {\n\t      error (0, 0, \"interface destruction is not supported\");\n\t      return 0;\n\t    }\n\t  break;\n\n\tcase EXPECT_AF:\n\tcase EXPECT_NOTHING:\n\t  break;\n\t}\n\n      if (expect == EXPECT_AF)\t/* Address selection is single shot.  */\n\t{\n\t  expect = EXPECT_NOTHING;\n\t  if (!strcmp (argv[i], \"inet\"))\n\t    continue;\n\t  else if (!strcmp (argv[i], \"inet6\"))\n\t    {\n\t      error (0, 0, \"%s is not a supported address family\", argv[i]);\n\t      return 0;\n\t    }\n\t}\n\n      if (expect != EXPECT_NOTHING)\n\texpect = EXPECT_NOTHING;\n      else if (!strcmp (argv[i], \"broadcast\"))\n\texpect = EXPECT_BROADCAST;\n      else if (!strcmp (argv[i], \"netmask\"))\n\texpect = EXPECT_NETMASK;\n      else if (!strcmp (argv[i], \"metric\"))\n\texpect = EXPECT_METRIC;\n      else if (!strcmp (argv[i], \"mtu\"))\n\texpect = EXPECT_MTU;\n      else if (!strcmp (argv[i], \"up\"))\n\tparse_opt_set_flag (*ifp, IFF_UP | IFF_RUNNING, 0);\n      else if (!strcmp (argv[i], \"down\"))\n\tparse_opt_set_flag (*ifp, IFF_UP, 1);\n      else if (((mask = if_nameztoflag (argv[i], &rev))\n\t\t& ~IU_IFF_CANTCHANGE) != 0)\n\tparse_opt_set_flag (*ifp, mask, rev);\n      else\n\t{\n\t  /* Also alias, -alias.  */\n\t  if (!((*ifp)->valid & IF_VALID_ADDR))\n\t    parse_opt_set_address (*ifp, argv[i]);\n\t  else if (!((*ifp)->valid & IF_VALID_DSTADDR))\n\t    parse_opt_set_dstaddr (*ifp, argv[i]);\n\t}\n    }\n\n  switch (expect)\n    {\n    case EXPECT_BROADCAST:\n      error (0, 0, \"option `broadcast' requires an argument\");\n      break;\n\n    case EXPECT_NETMASK:\n      error (0, 0, \"option `netmask' requires an argument\");\n      break;\n\n    case EXPECT_METRIC:\n      error (0, 0, \"option `metric' requires an argument\");\n      break;\n\n    case EXPECT_MTU:\n      error (0, 0, \"option `mtu' requires an argument\");\n      break;\n\n    case EXPECT_AF:\t\t/* dummy */\n    case EXPECT_COMMAND:\t/* dummy */\n    case EXPECT_NOTHING:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 120,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "system_configure": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nsystem_configure (int sfd _GL_UNUSED_PARAMETER,\n\t\t  struct ifreq *ifr _GL_UNUSED_PARAMETER,\n\t\t  struct system_ifconfig *ifs _GL_UNUSED_PARAMETER)\n{\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "system_fh_brdaddr_query": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "void\nsystem_fh_brdaddr_query (format_data_t form, int argc, char *argv[])\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    select_arg (form, argc, argv, 1);\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  if (fp->ifa_addr->sa_family != AF_INET ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  if (fp->ifa_netmask)\n\t    missing = 0;\n\t  break;\n\t}\n      select_arg (form, argc, argv, missing);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_brdaddr": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void\nsystem_fh_brdaddr (format_data_t form, int argc, char *argv[])\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    put_string (form, \"(unknown)\");\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  if (fp->ifa_addr->sa_family != AF_INET ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  if (fp->ifa_broadaddr)\n\t    {\n\t      missing = 0;\n\t      put_addr (form, argc, argv, fp->ifa_broadaddr);\n\t    }\n\t  break;\n\t}\n      if (missing)\n\tput_string (form, \"(unknown)\");\n    }\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwaddr_query": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\nsystem_fh_hwaddr_query (format_data_t form, int argc, char *argv[])\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    select_arg (form, argc, argv, 1);\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  struct sockaddr_dl *dl;\n\n\t  if (fp->ifa_addr->sa_family != AF_LINK ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  dl = (struct sockaddr_dl *) fp->ifa_addr;\n\t  if (dl && (dl->sdl_len > 0) &&\n\t      dl->sdl_type == IFT_ETHER)\t/* XXX: More cases?  */\n\t    missing = 0;\n\t  break;\n\t}\n      select_arg (form, argc, argv, missing);\n    }\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwaddr": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nsystem_fh_hwaddr (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    put_string (form, \"(hwaddr unknown)\");\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  struct sockaddr_dl *dl;\n\n\t  if (fp->ifa_addr->sa_family != AF_LINK ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  dl = (struct sockaddr_dl *) fp->ifa_addr;\n\t  if (dl && (dl->sdl_len > 0) &&\n\t      dl->sdl_type == IFT_ETHER)\t/* XXX: More cases?  */\n\t    {\n\t      missing = 0;\n\t      put_string (form, ether_ntoa ((struct ether_addr *) LLADDR (dl)));\n\t    }\n\t  break;\n\t}\n      if (missing)\n\tput_string (form, \"(hwaddr unknown)\");\n    }\n}",
      "lines": 33,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwtype_query": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "void\nsystem_fh_hwtype_query (format_data_t form, int argc, char *argv[])\n{\n  system_fh_hwaddr_query (form, argc, argv);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwtype": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nsystem_fh_hwtype (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    put_string (form, \"(hwtype unknown)\");\n  else\n    {\n      int found = 0;\n      struct ifaddrs *fp;\n      struct sockaddr_dl *dl = NULL;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  if (fp->ifa_addr->sa_family != AF_LINK ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  dl = (struct sockaddr_dl *) fp->ifa_addr;\n\t  if (dl && (dl->sdl_len > 0) &&\n\t      dl->sdl_type == IFT_ETHER)\t/* XXX: More cases?  */\n\t    {\n\t      found = 1;\n\t      put_string (form, ETHERNAME);\n\t    }\n\t  break;\n\t}\n      if (!found)\n\tput_string (form, \"(unknown hwtype)\");\n    }\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_media_query": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "void\nsystem_fh_media_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMEDIA\n  memset (&ifm, 0, sizeof (ifm));\n  strncpy (ifm.ifm_name, form->ifr->ifr_name, sizeof (ifm.ifm_name));\n\n  if (ioctl (form->sfd, SIOCGIFMEDIA, &ifm) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif /* SIOCGIFMEDIA */\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "system_fh_media": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "void\nsystem_fh_media (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t char *argv[] _GL_UNUSED_PARAMETER)\n{\n#ifdef SIOCGIFMEDIA\n  memset (&ifm, 0, sizeof (ifm));\n  strncpy (ifm.ifm_name, form->ifr->ifr_name, sizeof (ifm.ifm_name));\n  if (ioctl (form->sfd, SIOCGIFMEDIA, &ifm) >= 0)\n    {\n      const char *medium = NULL, *options = NULL;\n      const char *subtype = NULL, *active_subtype = NULL;\n      const struct ifmedia_description *item;\n\n      /* Determine media type of adapter.  */\n      for (item = media_descr; item->ifmt_word; item++)\n\tif (item->ifmt_word == IFM_TYPE (ifm.ifm_current))\n\t  {\n\t    medium = item->ifmt_string;\n\t    break;\n\t  }\n\n#ifdef IFM_SUBTYPE_DESCRIPTIONS\n      for (item = subtype_descr; item->ifmt_word || item->ifmt_string; item++)\n\t{\n\t  if (item->ifmt_word == IFM_SUBTYPE (ifm.ifm_current) && !subtype)\n\t    subtype = item->ifmt_string;\n\n\t  if (item->ifmt_word == (ifm.ifm_active & (IFM_NMASK | IFM_TMASK))\n\t      && !active_subtype)\n\t    active_subtype = item->ifmt_string;\n\t}\n#else /* !IFM_SUBTYPE_DESCRIPTIONS */\n      /* Systems like FreeBSD with sub-types split\n       * into shared and media specific structures.\n       *\n       * Sub-type specific media labels.\n       */\n      switch (IFM_TYPE (ifm.ifm_current))\n\t{\n\tcase IFM_ETHER:\n\t  for (item = ethernet_descr; item->ifmt_word; item++)\n\t    {\n\t      /* Configured sub-type.  */\n\t      if (item->ifmt_word == IFM_SUBTYPE (ifm.ifm_current))\n\t\tsubtype = item->ifmt_string;\n\n\t      /* Active subtype.  */\n\t      if (item->ifmt_word == IFM_SUBTYPE (ifm.ifm_active))\n\t\tactive_subtype = item->ifmt_string;\n\t    }\n\t  ;\n\tdefault:\n\t  ;\n\t}\n\n      /* Shared media sub-types.  Only works if the previous\n       * loops did not assign any string value.\n       *\n       * One valid instance of 'ifmt_word' is naught,\n       * so loop condition needs care.\n       */\n      for (item = subtype_shared_descr; item->ifmt_word || item->ifmt_string; item++)\n\t{\n\t  if (item->ifmt_word == IFM_SUBTYPE (ifm.ifm_current))\n\t    subtype = item->ifmt_string;\n\n\t  if (item->ifmt_word == IFM_SUBTYPE (ifm.ifm_active))\n\t    active_subtype = item->ifmt_string;\n\t}\n#endif /* !IFM_SUBTYPE_DESCRIPTIONS */\n\n      /* Negotiated mode of operation.  */\n      for (item = option_descr; item->ifmt_word; item++)\n\tif (item->ifmt_word == (ifm.ifm_active & IFM_GMASK) && !options)\n\t  options = item->ifmt_string;\n\n      /* Print the gathered information.  */\n      if (options)\n        printf (\"%s %s (%s <%s>)\", medium, subtype, active_subtype, options);\n      else\n        printf (\"%s %s (%s)\", medium, subtype,\n\t\tactive_subtype ? active_subtype : \"none\");\n\n      had_output++;\n    }\n  else\n#endif /* SIOCGIFMEDIA */\n    put_string (form, \"(not known)\");\n}",
      "lines": 89,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "system_fh_netmask_query": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "void\nsystem_fh_netmask_query (format_data_t form, int argc, char *argv[])\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    select_arg (form, argc, argv, 1);\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  if (fp->ifa_addr->sa_family != AF_INET ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  if (fp->ifa_netmask)\n\t    missing = 0;\n\t  break;\n\t}\n      select_arg (form, argc, argv, missing);\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_netmask": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "void\nsystem_fh_netmask (format_data_t form, int argc, char *argv[])\n{\n  ESTABLISH_IFADDRS\n  if (!ifp)\n    put_string (form, \"(unknown)\");\n  else\n    {\n      int missing = 1;\n      struct ifaddrs *fp;\n\n      for (fp = ifp; fp; fp = fp->ifa_next)\n\t{\n\t  if (fp->ifa_addr->sa_family != AF_INET ||\n\t      strcmp (fp->ifa_name, form->ifr->ifr_name))\n\t    continue;\n\n\t  if (fp->ifa_netmask)\n\t    {\n\t      missing = 0;\n\t      put_addr (form, argc, argv, fp->ifa_netmask);\n\t    }\n\t  break;\n\t}\n      if (missing)\n\tput_string (form, \"(netmask unknown)\");\n    }\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_status_query": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "void\nsystem_fh_status_query (format_data_t form, int argc, char *argv[])\n{\n  system_fh_media_query (form, argc, argv);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "system_fh_status": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "void\nsystem_fh_status (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMEDIA\n  memset (&ifm, 0, sizeof (ifm));\n  strncpy (ifm.ifm_name, form->ifr->ifr_name, sizeof (ifm.ifm_name));\n  if (ioctl (form->sfd, SIOCGIFMEDIA, &ifm) >= 0)\n    {\n#ifdef IFM_STATUS_DESCRIPTIONS\n      const struct ifmedia_status_description *item;\n\n      for (item = status_descr; item->ifms_type; item++)\n\tif (item->ifms_type == IFM_TYPE (ifm.ifm_current))\n\t  break;\n\n      if (item->ifms_type)\n\tput_string (form, IFM_STATUS_DESC (item, ifm.ifm_status));\n      else\n\tput_int (form, argc, argv, ifm.ifm_status);\n#else /* !IFM_STATUS_DESCRIPTIONS */\n      if (ifm.ifm_status & IFM_ACTIVE)\n\tput_string (form, \"active\");\n      else\n\tput_string (form, \"no carrier\");\n#endif /* IFM_STATUS_DESCRIPTIONS */\n    }\n  else\n#endif /* SIOCGIFMEDIA */\n    put_string (form, \"(not known)\");\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/system/bsd.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system/generic.c": {
    "system_parse_opt": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nsystem_parse_opt (struct ifconfig **ifp, char option, char *optarg)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "system_parse_opt_rest": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nsystem_parse_opt_rest (struct ifconfig **ifp, int argc, char *argv[])\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "system_configure": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nsystem_configure (int sfd, struct ifreq *ifr, struct system_ifconfig *ifs)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/system/generic.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system/linux.c": {
    "print_hwaddr_ether": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\nprint_hwaddr_ether (format_data_t form _GL_UNUSED_PARAMETER,\n\t\t    unsigned char *data)\n{\n  *column += printf (\"%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t     data[0], data[1], data[2], data[3], data[4], data[5]);\n  had_output = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_hwaddr_arcnet": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void\nprint_hwaddr_arcnet (format_data_t form _GL_UNUSED_PARAMETER,\n\t\t     unsigned char *data)\n{\n  *column += printf (\"%02X\", data[0]);\n  had_output = 1;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_hwaddr_dlci": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void\nprint_hwaddr_dlci (format_data_t form _GL_UNUSED_PARAMETER,\n\t\t   unsigned char *data)\n{\n  *column += printf (\"%i\", *((short *) data));\n  had_output = 1;\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_hwaddr_ax25": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\nprint_hwaddr_ax25 (format_data_t form, unsigned char *data)\n{\n  int i = 0;\n  while (i < 6 && (data[i] >> 1) != ' ')\n    {\n      put_char (form, (data[i] >> 1));\n      i++;\n    }\n  i = (data[6] & 0x1E) >> 1;\n  if (i)\n    {\n      *column += printf (\"-%i\", i);\n      had_output = 1;\n    }\n#undef mangle\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_hwaddr_irda": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nprint_hwaddr_irda (format_data_t form _GL_UNUSED_PARAMETER,\n\t\t   unsigned char *data)\n{\n  *column += printf (\"%02X:%02X:%02X:%02X\",\n\t\t     data[3], data[2], data[1], data[0]);\n  had_output = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_hwaddr_rose": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nprint_hwaddr_rose (format_data_t form _GL_UNUSED_PARAMETER,\n\t\t   unsigned char *data)\n{\n  *column += printf (\"%02X%02X%02X%02X%02X\",\n\t\t     data[0], data[1], data[2], data[3], data[4]);\n  had_output = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arphrd_findvalue": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "struct arphrd_symbol *\narphrd_findvalue (int value)\n{\n  struct arphrd_symbol *arp = arphrd_symbols;\n  while (arp->name != NULL)\n    {\n      if (arp->value == value)\n\tbreak;\n      arp++;\n    }\n  if (arp->name)\n    return arp;\n  else\n    return NULL;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "struct arphrd_symbol",
        "struct",
        "arphrd_symbol",
        "*\narphrd_findvalue (int value)",
        "*"
      ]
    },
    "procnet_parse_fields_v1": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static int\nprocnet_parse_fields_v1 (char *buf, struct pnd_stats *stats)\n{\n  int n = sscanf (buf,\n\t\t  \"%llu %lu %lu %lu %lu %llu %lu %lu %lu %lu %lu\",\n\t\t  &stats->rx_packets,\n\t\t  &stats->rx_errors,\n\t\t  &stats->rx_dropped,\n\t\t  &stats->rx_fifo_errors,\n\t\t  &stats->rx_frame_errors,\n\t\t  &stats->tx_packets,\n\t\t  &stats->tx_errors,\n\t\t  &stats->tx_dropped,\n\t\t  &stats->tx_fifo_errors,\n\t\t  &stats->collisions,\n\t\t  &stats->tx_carrier_errors);\n  stats->rx_bytes = 0;\n  stats->tx_bytes = 0;\n  stats->rx_multicast = 0;\n  return n == 11;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "procnet_parse_fields_v2": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static int\nprocnet_parse_fields_v2 (char *buf, struct pnd_stats *stats)\n{\n  int n = sscanf (buf,\n\t\t  \"%llu %llu %lu %lu %lu %lu %llu %llu %lu %lu %lu %lu %lu\",\n\t\t  &stats->rx_bytes,\n\t\t  &stats->rx_packets,\n\t\t  &stats->rx_errors,\n\t\t  &stats->rx_dropped,\n\t\t  &stats->rx_fifo_errors,\n\t\t  &stats->rx_frame_errors,\n\t\t  &stats->tx_bytes,\n\t\t  &stats->tx_packets,\n\t\t  &stats->tx_errors,\n\t\t  &stats->tx_dropped,\n\t\t  &stats->tx_fifo_errors,\n\t\t  &stats->collisions,\n\t\t  &stats->tx_carrier_errors);\n  stats->rx_multicast = 0;\n  return n == 13;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "procnet_parse_fields_v3": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static int\nprocnet_parse_fields_v3 (char *buf, struct pnd_stats *stats)\n{\n  int n = sscanf (buf,\n\t\t  \"%llu %llu %lu %lu %lu %lu %lu %lu %llu %llu %lu %lu %lu %lu %lu %lu\",\n\t\t  &stats->rx_bytes,\n\t\t  &stats->rx_packets,\n\t\t  &stats->rx_errors,\n\t\t  &stats->rx_dropped,\n\t\t  &stats->rx_fifo_errors,\n\t\t  &stats->rx_frame_errors,\n\t\t  &stats->rx_compressed,\n\t\t  &stats->rx_multicast,\n\t\t  &stats->tx_bytes,\n\t\t  &stats->tx_packets,\n\t\t  &stats->tx_errors,\n\t\t  &stats->tx_dropped,\n\t\t  &stats->tx_fifo_errors,\n\t\t  &stats->collisions,\n\t\t  &stats->tx_carrier_errors,\n\t\t  &stats->tx_compressed);\n  return n == 16;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pnd_version": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static int\npnd_version (char *buf)\n{\n  if (strstr (buf, \"compressed\"))\n    return 2;\n  if (strstr(buf, \"bytes\"))\n    return 1;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pnd_read": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "static void\npnd_read ()\n{\n  FILE *fp;\n  char *buf = NULL;\n  size_t bufsize = 0;\n  int v;\n\n  fp = fopen (PATH_PROCNET_DEV, \"r\");\n  if (!fp)\n    {\n      error (0, errno, \"cannot open %s\", PATH_PROCNET_DEV);\n      return;\n    }\n\n  /* Skip header lines */\n  if (getline (&buf, &bufsize, fp) < 0\n      || getline (&buf, &bufsize, fp) < 0)\n    {\n      error (0, errno, \"malformed %s\", PATH_PROCNET_DEV);\n      fclose (fp);\n      free (buf);\n      return;\n    }\n\n  v = pnd_version (buf);\n\n  while (getline (&buf, &bufsize, fp) > 0)\n    {\n      struct pnd_stats *stats = xzalloc (sizeof (*stats));\n      char *p = buf, *q;\n      size_t len;\n\n      while (*p\n\t     && isascii (*(unsigned char*) p) && isspace (*(unsigned char*) p))\n\tp++;\n      q = strchr (p, ':');\n      if (!q)\n\t{\n\t  error (0, errno, \"malformed %s\", PATH_PROCNET_DEV);\n\t  free (stats);\n\t  break;\n\t}\n      len = q - p;\n      stats->name = xmalloc (len + 1);\n      memcpy (stats->name, p, len);\n      stats->name[len] = 0;\n      if (pnd_parser[v] (q + 1, stats) == 0)\n\t{\n\t  error (0, errno, \"malformed %s\", PATH_PROCNET_DEV);\n\t  free (stats);\n\t  break;\n\t}\n      stats->next = NULL;\n      if (stats_tail)\n\tstats_tail->next = stats;\n      else\n\tstats_head = stats;\n      stats_tail = stats;\n    }\n\n  fclose (fp);\n  free (buf);\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pnd_stats_locate": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "struct pnd_stats *\npnd_stats_locate (const char *name)\n{\n  struct pnd_stats *stats;\n  if (!pnd_stats_init)\n    {\n      pnd_read ();\n      pnd_stats_init = 1;\n    }\n  for (stats = stats_head; stats; stats = stats->next)\n    if (strcmp (stats->name, name) == 0)\n      break;\n  return stats;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "struct pnd_stats",
        "struct",
        "pnd_stats",
        "*\npnd_stats_locate (const char *name)",
        "*"
      ]
    },
    "system_fh_ifstat_query": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void\nsystem_fh_ifstat_query (format_data_t form, int argc, char *argv[])\n{\n  select_arg (form, argc, argv,\n\t      pnd_stats_locate (form->ifr->ifr_name) ? 0 : 1);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwaddr_query": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "_IU_DECLARE (tx_window_errors)\n\nvoid\nsystem_fh_hwaddr_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFHWADDR\n  struct arphrd_symbol *arp;\n\n  if (ioctl (form->sfd, SIOCGIFHWADDR, form->ifr) < 0)\n    select_arg (form, argc, argv, 1);\n\n  arp = arphrd_findvalue (form->ifr->ifr_hwaddr.sa_family);\n  select_arg (form, argc, argv, (arp && arp->print_hwaddr) ? 0 : 1);\n#else\n  select_arg (form, argc, argv, 1);\n#endif\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "_IU_DECLARE (tx_window_errors)",
        "_IU_DECLARE",
        "(",
        "tx_window_errors",
        "tx_window_errors",
        ")",
        "void",
        "void"
      ]
    },
    "system_fh_hwaddr": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "void\nsystem_fh_hwaddr (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n#ifdef SIOCGIFHWADDR\n  if (ioctl (form->sfd, SIOCGIFHWADDR, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFHWADDR failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    {\n      struct arphrd_symbol *arp;\n\n      arp = arphrd_findvalue (form->ifr->ifr_hwaddr.sa_family);\n      if (arp && arp->print_hwaddr)\n\tarp->print_hwaddr (form,\n\t\t\t   (unsigned char *) form->ifr->ifr_hwaddr.sa_data);\n      else\n\tput_string (form, \"(hwaddr unknown)\");\n    }\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwtype_query": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "void\nsystem_fh_hwtype_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFHWADDR\n  if (ioctl (form->sfd, SIOCGIFHWADDR, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "system_fh_hwtype": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "void\nsystem_fh_hwtype (format_data_t form, int argc _GL_UNUSED_PARAMETER,\n\t\t  char *argv[] _GL_UNUSED_PARAMETER)\n{\n#ifdef SIOCGIFHWADDR\n  if (ioctl (form->sfd, SIOCGIFHWADDR, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFHWADDR failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    {\n      struct arphrd_symbol *arp;\n\n      arp = arphrd_findvalue (form->ifr->ifr_hwaddr.sa_family);\n      if (arp)\n\tput_string (form, arp->title);\n      else\n\tput_string (form, \"(hwtype unknown)\");\n    }\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_metric_query": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "void\nsystem_fh_metric_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMETRIC\n  if (ioctl (form->sfd, SIOCGIFMETRIC, form->ifr) >= 0)\n    select_arg (form, argc, argv, 0);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "system_fh_metric": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "void\nsystem_fh_metric (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFMETRIC\n  if (ioctl (form->sfd, SIOCGIFMETRIC, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFMETRIC failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_int (form, argc, argv,\n\t     form->ifr->ifr_metric ? form->ifr->ifr_metric : 1);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "system_fh_txqlen_query": {
      "start_point": [
        644,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "void\nsystem_fh_txqlen_query (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFTXQLEN\n  if (ioctl (form->sfd, SIOCGIFTXQLEN, form->ifr) >= 0)\n    select_arg (form, argc, argv, (form->ifr->ifr_qlen >= 0) ? 0 : 1);\n  else\n#endif\n    select_arg (form, argc, argv, 1);\n}",
      "lines": 10,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "system_fh_txqlen": {
      "start_point": [
        655,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "void\nsystem_fh_txqlen (format_data_t form, int argc, char *argv[])\n{\n#ifdef SIOCGIFTXQLEN\n  if (ioctl (form->sfd, SIOCGIFTXQLEN, form->ifr) < 0)\n    error (EXIT_FAILURE, errno,\n\t   \"SIOCGIFTXQLEN failed for interface `%s'\",\n\t   form->ifr->ifr_name);\n  else\n    put_int (form, argc, argv, form->ifr->ifr_qlen);\n#else\n  *column += printf (\"(not available)\");\n  had_output = 1;\n#endif\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "system_parse_opt_set_txqlen": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "void\nsystem_parse_opt_set_txqlen (struct ifconfig *ifp, char *arg)\n{\n  char *end;\n\n  if (!ifp)\n    error (EXIT_FAILURE, 0,\n\t   \"no interface specified for txqlen `%s'\", arg);\n\n  if (!(ifp->valid & IF_VALID_SYSTEM))\n    {\n      ifp->system = malloc (sizeof (struct system_ifconfig));\n      if (!ifp->system)\n\terror (EXIT_FAILURE, errno,\n\t       \"can't get memory for system interface configuration\");\n      ifp->system->valid = 0;\n      ifp->valid |= IF_VALID_SYSTEM;\n    }\n  if (ifp->system->valid & IF_VALID_TXQLEN)\n    error (EXIT_FAILURE, 0,\n\t   \"only one txqlen allowed for interface `%s'\",\n\t   ifp->name);\n  ifp->system->txqlen = strtol (arg, &end, 0);\n  if (*arg == '\\0' || *end != '\\0')\n    error (EXIT_FAILURE, 0,\n\t   \"txqlen value `%s' for interface `%s' is not a number\",\n\t   arg, ifp->name);\n  ifp->system->valid |= IF_VALID_TXQLEN;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "linux_argp_parser": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "static error_t\nlinux_argp_parser (int key, char *arg, struct argp_state *state)\n{\n  struct ifconfig *ifp = *(struct ifconfig **)state->input;\n  switch (key)\n    {\n    case 'T':\t\t\t/* txqlen */\n      system_parse_opt_set_txqlen (ifp, arg);\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "system_parse_opt": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "int\nsystem_parse_opt (struct ifconfig **ifpp, char option, char *arg)\n{\n  struct ifconfig *ifp = *ifpp;\n\n  switch (option)\n    {\n    case 'T':\t\t\t/* txqlen */\n      system_parse_opt_set_txqlen (ifp, arg);\n      break;\n\n    default:\n      return 0;\n    }\n  return 1;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "system_parse_opt_rest": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "int\nsystem_parse_opt_rest (struct ifconfig **ifp, int argc, char *argv[])\n{\n  int i = 0;\n  enum\n  {\n    EXPECT_AF,\n    EXPECT_NOTHING,\n    EXPECT_BROADCAST,\n    EXPECT_DSTADDR,\n    EXPECT_NETMASK,\n    EXPECT_MTU,\n    EXPECT_METRIC,\n    EXPECT_TXQLEN,\n  } expect = EXPECT_AF;\n  int mask, rev;\n\n  *ifp = parse_opt_new_ifs (argv[0]);\n\n  while (++i < argc)\n    {\n      switch (expect)\n\t{\n\tcase EXPECT_BROADCAST:\n\t  parse_opt_set_brdaddr (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_DSTADDR:\n\t  parse_opt_set_point_to_point (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_NETMASK:\n\t  parse_opt_set_netmask (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_MTU:\n\t  parse_opt_set_mtu (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_METRIC:\n\t  parse_opt_set_metric (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_TXQLEN:\n\t  system_parse_opt_set_txqlen (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_AF:\n\t  expect = EXPECT_NOTHING;\n\t  if (!strcmp (argv[i], \"inet\"))\n\t    continue;\n\t  else if (!strcmp (argv[i], \"inet6\"))\n\t    {\n\t      error (0, 0, \"%s is not a supported address family\", argv[i]);\n\t      return 0;\n\t    }\n\t  break;\n\n\tcase EXPECT_NOTHING:\n\t  break;\n\t}\n\n      if (expect != EXPECT_NOTHING)\n\texpect = EXPECT_NOTHING;\n      else if (!strcmp (argv[i], \"broadcast\"))\n\texpect = EXPECT_BROADCAST;\n      else if (!strcmp (argv[i], \"dstaddr\")\n\t       || !strcmp (argv[i], \"pointopoint\"))\n\texpect = EXPECT_DSTADDR;\n      else if (!strcmp (argv[i], \"netmask\"))\n\texpect = EXPECT_NETMASK;\n      else if (!strcmp (argv[i], \"metric\"))\n\texpect = EXPECT_METRIC;\n      else if (!strcmp (argv[i], \"mtu\"))\n\texpect = EXPECT_MTU;\n      else if (!strcmp (argv[i], \"txqueuelen\"))\n\texpect = EXPECT_TXQLEN;\n      else if (!strcmp (argv[i], \"up\"))\n\tparse_opt_set_flag (*ifp, IFF_UP | IFF_RUNNING, 0);\n      else if (!strcmp (argv[i], \"down\"))\n\tparse_opt_set_flag (*ifp, IFF_UP, 1);\n      else if (((mask = if_nameztoflag (argv[i], &rev))\n\t\t& ~IU_IFF_CANTCHANGE) != 0)\n\tparse_opt_set_flag (*ifp, mask, rev);\n      else\n\tparse_opt_set_address (*ifp, argv[i]);\n    }\n\n  switch (expect)\n    {\n    case EXPECT_BROADCAST:\n      error (0, 0, \"option `broadcast' requires an argument\");\n      break;\n\n    case EXPECT_DSTADDR:\n      error (0, 0, \"option `pointopoint' (`dstaddr') requires an argument\");\n      break;\n\n    case EXPECT_NETMASK:\n      error (0, 0, \"option `netmask' requires an argument\");\n      break;\n\n    case EXPECT_METRIC:\n      error (0, 0, \"option `metric' requires an argument\");\n      break;\n\n    case EXPECT_MTU:\n      error (0, 0, \"option `mtu' requires an argument\");\n      break;\n\n    case EXPECT_TXQLEN:\n      error (0, 0, \"option `txqueuelen' requires an argument\");\n      break;\n\n    case EXPECT_AF:\n    case EXPECT_NOTHING:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 120,
      "depth": 24,
      "decorators": [
        "int"
      ]
    },
    "system_configure": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        902,
        1
      ],
      "content": "int\nsystem_configure (int sfd, struct ifreq *ifr, struct system_ifconfig *ifs)\n{\n  if (ifs->valid & IF_VALID_TXQLEN)\n    {\n#ifndef SIOCSIFTXQLEN\n      error (0, 0, \"don't know how to set the txqlen on this system\");\n      return -1;\n#else\n      int err = 0;\n\n      ifr->ifr_qlen = ifs->txqlen;\n      err = ioctl (sfd, SIOCSIFTXQLEN, ifr);\n      if (err < 0)\n\terror (0, errno, \"SIOCSIFTXQLEN failed\");\n      if (verbose)\n\tprintf (\"Set txqlen value of `%s' to `%i'.\\n\",\n\t\tifr->ifr_name, ifr->ifr_qlen);\n#endif\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "linux_if_nameindex": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        979,
        1
      ],
      "content": "static struct if_nameindex *\nlinux_if_nameindex (void)\n{\n  char *content, *it;\n  size_t length, index;\n  struct if_nameindex *idx = NULL;\n  int fd;\n\n  fd = socket (AF_INET, SOCK_DGRAM, 0);\n  if (fd < 0)\n    return NULL;\n\n  content = read_file (PATH_PROCNET_DEV, &length);\n  if (content == NULL)\n    return NULL;\n\n  /* Count how many interfaces we have.  */\n  {\n    size_t n = 0;\n    it = content;\n    do\n      {\n        it = memchr (it + 1, ':', length - (it - content));\n        n++;\n      }\n    while (it);\n\n    idx = malloc (n * sizeof (*idx));\n    if (idx == NULL)\n      {\n        int saved_errno = errno;\n        close (fd);\n        free (content);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n\n  for (it = memchr (content, ':', length), index = 0; it;\n       it = memchr (it, ':', length - (it - content)), index++)\n    {\n      char *start = it - 1;\n      *it = '\\0';\n\n      while (*start != ' ' && *start != '\\n')\n        start--;\n\n      idx[index].if_name = strdup (start + 1);\n      idx[index].if_index = index + 1;\n\n# if defined SIOCGIFINDEX\n      {\n        struct ifreq cur;\n        strcpy (cur.ifr_name, idx[index].if_name);\n        cur.ifr_index = -1;\n        if (ioctl (fd, SIOCGIFINDEX, &cur) >= 0)\n          idx[index].if_index = cur.ifr_index;\n      }\n# endif\n\n      if (idx[index].if_name == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          free (content);\n          errno = saved_errno;\n          return NULL;\n        }\n    }\n\n  idx[index].if_index = 0;\n  idx[index].if_name = NULL;\n\n  free (content);\n  return idx;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct if_nameindex",
        "struct",
        "if_nameindex",
        "*\nlinux_if_nameindex (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/system/linux.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system/qnx.c": {
    "system_parse_opt": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nsystem_parse_opt (struct ifconfig **ifp, char option, char *optarg)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "system_parse_opt_rest": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nsystem_parse_opt_rest (struct ifconfig **ifp, int argc, char *argv[])\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "system_configure": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\nsystem_configure (int sfd, struct ifreq *ifr, struct system_ifconfig *ifs)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/system/qnx.h": {},
  "inetutils/inetutils-1.9.4/ifconfig/system/solaris.c": {
    "system_parse_opt": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nsystem_parse_opt (struct ifconfig **ifp _GL_UNUSED_PARAMETER,\n\t\t  char option _GL_UNUSED_PARAMETER,\n\t\t  char *optarg _GL_UNUSED_PARAMETER)\n{\n  return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "system_parse_opt_rest": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "int\nsystem_parse_opt_rest (struct ifconfig **ifp, int argc, char *argv[])\n{\n  int i = 0, mask, rev;\n  enum\n  {\n    EXPECT_NOTHING,\n    EXPECT_AF,\n    EXPECT_BROADCAST,\n    EXPECT_NETMASK,\n    EXPECT_METRIC,\n    EXPECT_MTU\n  } expect = EXPECT_AF;\n\n  *ifp = parse_opt_new_ifs (argv[0]);\n\n  while (++i < argc)\n    {\n      switch (expect)\n\t{\n\tcase EXPECT_BROADCAST:\n\t  parse_opt_set_brdaddr (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_NETMASK:\n\t  parse_opt_set_netmask (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_MTU:\n\t  parse_opt_set_mtu (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_METRIC:\n\t  parse_opt_set_metric (*ifp, argv[i]);\n\t  break;\n\n\tcase EXPECT_AF:\n\t  expect = EXPECT_NOTHING;\n\t  if (!strcmp (argv[i], \"inet\"))\n\t    continue;\n\t  else if (!strcmp (argv[i], \"inet6\"))\n\t    {\n\t      error (0, 0, \"%s is not a supported address family\", argv[i]);\n\t      return 0;\n\t    }\n\t  break;\n\n\tcase EXPECT_NOTHING:\n\t  break;\n\t}\n\n      if (expect != EXPECT_NOTHING)\n\texpect = EXPECT_NOTHING;\n      else if (!strcmp (argv[i], \"broadcast\"))\n\texpect = EXPECT_BROADCAST;\n      else if (!strcmp (argv[i], \"netmask\"))\n\texpect = EXPECT_NETMASK;\n      else if (!strcmp (argv[i], \"metric\"))\n\texpect = EXPECT_METRIC;\n      else if (!strcmp (argv[i], \"mtu\"))\n\texpect = EXPECT_MTU;\n      else if (!strcmp (argv[i], \"up\"))\n\tparse_opt_set_flag (*ifp, IFF_UP | IFF_RUNNING, 0);\n      else if (!strcmp (argv[i], \"down\"))\n\tparse_opt_set_flag (*ifp, IFF_UP, 1);\n      else if (((mask = if_nameztoflag (argv[i], &rev))\n\t\t& ~IU_IFF_CANTCHANGE) != 0)\n\tparse_opt_set_flag (*ifp, mask, rev);\n      else\n\t{\n\t  /* Also auto-revarp, plumb, unplumb.  */\n\t  if (!((*ifp)->valid & IF_VALID_ADDR))\n\t    parse_opt_set_address (*ifp, argv[i]);\n\t  else if (!((*ifp)->valid & IF_VALID_DSTADDR))\n\t    parse_opt_set_dstaddr (*ifp, argv[i]);\n\t}\n    }\n\n  switch (expect)\n    {\n    case EXPECT_BROADCAST:\n      error (0, 0, \"option `broadcast' requires an argument\");\n      break;\n\n    case EXPECT_NETMASK:\n      error (0, 0, \"option `netmask' requires an argument\");\n      break;\n\n    case EXPECT_METRIC:\n      error (0, 0, \"option `metric' requires an argument\");\n      break;\n\n    case EXPECT_MTU:\n      error (0, 0, \"option `mtu' requires an argument\");\n      break;\n\n    case EXPECT_AF:\n    case EXPECT_NOTHING:\n      return 1;\n    }\n  return 0;\n}",
      "lines": 102,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "system_configure": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsystem_configure (int sfd, struct ifreq *ifr, struct system_ifconfig *ifs)\n{\n#ifdef IF_VALID_TXQLEN\n  if (ifs->valid & IF_VALID_TXQLEN)\n    {\n# ifndef SIOCSIFTXQLEN\n      error (0, 0, \"don't know how to set the txqlen on this system\");\n      return -1;\n# else /* SIOCSIFTXQLEN */\n      int err = 0;\n\n      ifr->ifr_qlen = ifs->txqlen;\n      err = ioctl (sfd, SIOCSIFTXQLEN, ifr);\n      if (err < 0)\n\terror (0, errno, \"SIOCSIFTXQLEN failed\");\n      if (verbose)\n\tprintf (\"Set txqlen value of `%s' to `%i'.\\n\",\n\t\tifr->ifr_name, ifr->ifr_qlen);\n# endif /* SIOCSIFTXQLEN */\n    }\n#else /* !IF_VALID_TXQLEN */\n  (void) sfd;\n  (void) ifr;\n  (void) ifs;\n#endif /* !IF_VALID_TXQLEN */\n  return 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ifconfig/system/solaris.h": {},
  "inetutils/inetutils-1.9.4/lib/alignof.h": {},
  "inetutils/inetutils-1.9.4/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/alloca.in.h": {},
  "inetutils/inetutils-1.9.4/lib/anytostr.c": {
    "__attribute_warn_unused_result__": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char * __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)\n{\n  char *p = buf + INT_STRLEN_BOUND (inttype);\n  *p = 0;\n\n  if (i < 0)\n    {\n      do\n        *--p = '0' - i % 10;\n      while ((i /= 10) != 0);\n\n      *--p = '-';\n    }\n  else\n    {\n      do\n        *--p = '0' + i % 10;\n      while ((i /= 10) != 0);\n    }\n\n  return p;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "* __attribute_warn_unused_result__\nanytostr (inttype i, char *buf)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-ba.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-eexst.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-fmtstream.c": {
    "__argp_make_fmtstream": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "argp_fmtstream_t\n__argp_make_fmtstream (FILE *stream,\n                       size_t lmargin, size_t rmargin, ssize_t wmargin)\n{\n  argp_fmtstream_t fs;\n\n  fs = (struct argp_fmtstream *) malloc (sizeof (struct argp_fmtstream));\n  if (fs != NULL)\n    {\n      fs->stream = stream;\n\n      fs->lmargin = lmargin;\n      fs->rmargin = rmargin;\n      fs->wmargin = wmargin;\n      fs->point_col = 0;\n      fs->point_offs = 0;\n\n      fs->buf = (char *) malloc (INIT_BUF_SIZE);\n      if (! fs->buf)\n        {\n          free (fs);\n          fs = 0;\n        }\n      else\n        {\n          fs->p = fs->buf;\n          fs->end = fs->buf + INIT_BUF_SIZE;\n        }\n    }\n\n  return fs;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "argp_fmtstream_t"
      ]
    },
    "__argp_fmtstream_free": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\n__argp_fmtstream_free (argp_fmtstream_t fs)\n{\n  __argp_fmtstream_update (fs);\n  if (fs->p > fs->buf)\n    {\n#ifdef USE_IN_LIBIO\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n#else\n      fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n    }\n  free (fs->buf);\n  free (fs);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_update": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void\n__argp_fmtstream_update (argp_fmtstream_t fs)\n{\n  char *buf, *nl;\n  size_t len;\n\n  /* Scan the buffer for newlines.  */\n  buf = fs->buf + fs->point_offs;\n  while (buf < fs->p)\n    {\n      size_t r;\n\n      if (fs->point_col == 0 && fs->lmargin != 0)\n        {\n          /* We are starting a new line.  Print spaces to the left margin.  */\n          const size_t pad = fs->lmargin;\n          if (fs->p + pad < fs->end)\n            {\n              /* We can fit in them in the buffer by moving the\n                 buffer text up and filling in the beginning.  */\n              memmove (buf + pad, buf, fs->p - buf);\n              fs->p += pad; /* Compensate for bigger buffer. */\n              memset (buf, ' ', pad); /* Fill in the spaces.  */\n              buf += pad; /* Don't bother searching them.  */\n            }\n          else\n            {\n              /* No buffer space for spaces.  Must flush.  */\n              size_t i;\n              for (i = 0; i < pad; i++)\n                {\n#ifdef USE_IN_LIBIO\n                  if (_IO_fwide (fs->stream, 0) > 0)\n                    putwc_unlocked (L' ', fs->stream);\n                  else\n#endif\n                    putc_unlocked (' ', fs->stream);\n                }\n            }\n          fs->point_col = pad;\n        }\n\n      len = fs->p - buf;\n      nl = memchr (buf, '\\n', len);\n\n      if (fs->point_col < 0)\n        fs->point_col = 0;\n\n      if (!nl)\n        {\n          /* The buffer ends in a partial line.  */\n\n          if (fs->point_col + len < fs->rmargin)\n            {\n              /* The remaining buffer text is a partial line and fits\n                 within the maximum line width.  Advance point for the\n                 characters to be written and stop scanning.  */\n              fs->point_col += len;\n              break;\n            }\n          else\n            /* Set the end-of-line pointer for the code below to\n               the end of the buffer.  */\n            nl = fs->p;\n        }\n      else if (fs->point_col + (nl - buf) < (ssize_t) fs->rmargin)\n        {\n          /* The buffer contains a full line that fits within the maximum\n             line width.  Reset point and scan the next line.  */\n          fs->point_col = 0;\n          buf = nl + 1;\n          continue;\n        }\n\n      /* This line is too long.  */\n      r = fs->rmargin - 1;\n\n      if (fs->wmargin < 0)\n        {\n          /* Truncate the line by overwriting the excess with the\n             newline and anything after it in the buffer.  */\n          if (nl < fs->p)\n            {\n              memmove (buf + (r - fs->point_col), nl, fs->p - nl);\n              fs->p -= buf + (r - fs->point_col) - nl;\n              /* Reset point for the next line and start scanning it.  */\n              fs->point_col = 0;\n              buf += r + 1; /* Skip full line plus \\n. */\n            }\n          else\n            {\n              /* The buffer ends with a partial line that is beyond the\n                 maximum line width.  Advance point for the characters\n                 written, and discard those past the max from the buffer.  */\n              fs->point_col += len;\n              fs->p -= fs->point_col - r;\n              break;\n            }\n        }\n      else\n        {\n          /* Do word wrap.  Go to the column just past the maximum line\n             width and scan back for the beginning of the word there.\n             Then insert a line break.  */\n\n          char *p, *nextline;\n          int i;\n\n          p = buf + (r + 1 - fs->point_col);\n          while (p >= buf && !isblank ((unsigned char) *p))\n            --p;\n          nextline = p + 1;     /* This will begin the next line.  */\n\n          if (nextline > buf)\n            {\n              /* Swallow separating blanks.  */\n              if (p >= buf)\n                do\n                  --p;\n                while (p >= buf && isblank ((unsigned char) *p));\n              nl = p + 1;       /* The newline will replace the first blank. */\n            }\n          else\n            {\n              /* A single word that is greater than the maximum line width.\n                 Oh well.  Put it on an overlong line by itself.  */\n              p = buf + (r + 1 - fs->point_col);\n              /* Find the end of the long word.  */\n              if (p < nl)\n                do\n                  ++p;\n                while (p < nl && !isblank ((unsigned char) *p));\n              if (p == nl)\n                {\n                  /* It already ends a line.  No fussing required.  */\n                  fs->point_col = 0;\n                  buf = nl + 1;\n                  continue;\n                }\n              /* We will move the newline to replace the first blank.  */\n              nl = p;\n              /* Swallow separating blanks.  */\n              do\n                ++p;\n              while (isblank ((unsigned char) *p));\n              /* The next line will start here.  */\n              nextline = p;\n            }\n\n          /* Note: There are a bunch of tests below for\n             NEXTLINE == BUF + LEN + 1; this case is where NL happens to fall\n             at the end of the buffer, and NEXTLINE is in fact empty (and so\n             we need not be careful to maintain its contents).  */\n\n          if ((nextline == buf + len + 1\n               ? fs->end - nl < fs->wmargin + 1\n               : nextline - (nl + 1) < fs->wmargin)\n              && fs->p > nextline)\n            {\n              /* The margin needs more blanks than we removed.  */\n              if (fs->end - fs->p > fs->wmargin + 1)\n                /* Make some space for them.  */\n                {\n                  size_t mv = fs->p - nextline;\n                  memmove (nl + 1 + fs->wmargin, nextline, mv);\n                  nextline = nl + 1 + fs->wmargin;\n                  len = nextline + mv - buf;\n                  *nl++ = '\\n';\n                }\n              else\n                /* Output the first line so we can use the space.  */\n                {\n#ifdef _LIBC\n                  __fxprintf (fs->stream, \"%.*s\\n\",\n                              (int) (nl - fs->buf), fs->buf);\n#else\n                  if (nl > fs->buf)\n                    fwrite_unlocked (fs->buf, 1, nl - fs->buf, fs->stream);\n                  putc_unlocked ('\\n', fs->stream);\n#endif\n\n                  len += buf - fs->buf;\n                  nl = buf = fs->buf;\n                }\n            }\n          else\n            /* We can fit the newline and blanks in before\n               the next word.  */\n            *nl++ = '\\n';\n\n          if (nextline - nl >= fs->wmargin\n              || (nextline == buf + len + 1 && fs->end - nextline >= fs->wmargin))\n            /* Add blanks up to the wrap margin column.  */\n            for (i = 0; i < fs->wmargin; ++i)\n              *nl++ = ' ';\n          else\n            for (i = 0; i < fs->wmargin; ++i)\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (fs->stream, 0) > 0)\n                putwc_unlocked (L' ', fs->stream);\n              else\n#endif\n                putc_unlocked (' ', fs->stream);\n\n          /* Copy the tail of the original buffer into the current buffer\n             position.  */\n          if (nl < nextline)\n            memmove (nl, nextline, buf + len - nextline);\n          len -= nextline - buf;\n\n          /* Continue the scan on the remaining lines in the buffer.  */\n          buf = nl;\n\n          /* Restore bufp to include all the remaining text.  */\n          fs->p = nl + len;\n\n          /* Reset the counter of what has been output this line.  If wmargin\n             is 0, we want to avoid the lmargin getting added, so we set\n             point_col to a magic value of -1 in that case.  */\n          fs->point_col = fs->wmargin ? fs->wmargin : -1;\n        }\n    }\n\n  /* Remember that we've scanned as far as the end of the buffer.  */\n  fs->point_offs = fs->p - fs->buf;\n}",
      "lines": 226,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "__argp_fmtstream_ensure": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "int\n__argp_fmtstream_ensure (struct argp_fmtstream *fs, size_t amount)\n{\n  if ((size_t) (fs->end - fs->p) < amount)\n    {\n      ssize_t wrote;\n\n      /* Flush FS's buffer.  */\n      __argp_fmtstream_update (fs);\n\n#ifdef _LIBC\n      __fxprintf (fs->stream, \"%.*s\", (int) (fs->p - fs->buf), fs->buf);\n      wrote = fs->p - fs->buf;\n#else\n      wrote = fwrite_unlocked (fs->buf, 1, fs->p - fs->buf, fs->stream);\n#endif\n      if (wrote == fs->p - fs->buf)\n        {\n          fs->p = fs->buf;\n          fs->point_offs = 0;\n        }\n      else\n        {\n          fs->p -= wrote;\n          fs->point_offs -= wrote;\n          memmove (fs->buf, fs->buf + wrote, fs->p - fs->buf);\n          return 0;\n        }\n\n      if ((size_t) (fs->end - fs->buf) < amount)\n        /* Gotta grow the buffer.  */\n        {\n          size_t old_size = fs->end - fs->buf;\n          size_t new_size = old_size + amount;\n          char *new_buf;\n\n          if (new_size < old_size || ! (new_buf = realloc (fs->buf, new_size)))\n            {\n              __set_errno (ENOMEM);\n              return 0;\n            }\n\n          fs->buf = new_buf;\n          fs->end = new_buf + new_size;\n          fs->p = fs->buf;\n        }\n    }\n\n  return 1;\n}",
      "lines": 50,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "__argp_fmtstream_printf": {
      "start_point": [
        400,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "ssize_t\n__argp_fmtstream_printf (struct argp_fmtstream *fs, const char *fmt, ...)\n{\n  int out;\n  size_t avail;\n  size_t size_guess = PRINTF_SIZE_GUESS; /* How much space to reserve. */\n\n  do\n    {\n      va_list args;\n\n      if (! __argp_fmtstream_ensure (fs, size_guess))\n        return -1;\n\n      va_start (args, fmt);\n      avail = fs->end - fs->p;\n      out = __vsnprintf (fs->p, avail, fmt, args);\n      va_end (args);\n      if ((size_t) out >= avail)\n        size_guess = out + 1;\n    }\n  while ((size_t) out >= avail);\n\n  fs->p += out;\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-fmtstream.h": {
    "__argp_fmtstream_write": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_write (argp_fmtstream_t __fs,\n                        const char *__str, size_t __len)\n{\n  if (__fs->p + __len <= __fs->end || __argp_fmtstream_ensure (__fs, __len))\n    {\n      memcpy (__fs->p, __str, __len);\n      __fs->p += __len;\n      return __len;\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_puts": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_puts (argp_fmtstream_t __fs, const char *__str)\n{\n  size_t __len = strlen (__str);\n  if (__len)\n    {\n      size_t __wrote = __argp_fmtstream_write (__fs, __str, __len);\n      return __wrote == __len ? 0 : -1;\n    }\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_putc": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "ARGP_FS_EI int\n__argp_fmtstream_putc (argp_fmtstream_t __fs, int __ch)\n{\n  if (__fs->p < __fs->end || __argp_fmtstream_ensure (__fs, 1))\n    return *__fs->p++ = __ch;\n  else\n    return EOF;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "ARGP_FS_EI",
        "int",
        "int"
      ]
    },
    "__argp_fmtstream_set_lmargin": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_lmargin (argp_fmtstream_t __fs, size_t __lmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->lmargin;\n  __fs->lmargin = __lmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_rmargin": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_rmargin (argp_fmtstream_t __fs, size_t __rmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->rmargin;\n  __fs->rmargin = __rmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_set_wmargin": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_set_wmargin (argp_fmtstream_t __fs, size_t __wmargin)\n{\n  size_t __old;\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  __old = __fs->wmargin;\n  __fs->wmargin = __wmargin;\n  return __old;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    },
    "__argp_fmtstream_point": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "ARGP_FS_EI size_t\n__argp_fmtstream_point (argp_fmtstream_t __fs)\n{\n  if ((size_t) (__fs->p - __fs->buf) > __fs->point_offs)\n    __argp_fmtstream_update (__fs);\n  return __fs->point_col >= 0 ? __fs->point_col : 0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "ARGP_FS_EI",
        "size_t",
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-fs-xinl.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-help.c": {
    "validate_uparams": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nvalidate_uparams (const struct argp_state *state, struct uparams *upptr)\n{\n  const struct uparam_name *up;\n\n  for (up = uparam_names; up->name; up++)\n    {\n      if (up->is_bool\n          || up->uparams_offs == offsetof (struct uparams, rmargin))\n        continue;\n      if (*(int *)((char *)upptr + up->uparams_offs) >= upptr->rmargin)\n        {\n          __argp_failure (state, 0, 0,\n                          dgettext (state->root_argp->argp_domain,\n                                    \"\\\nARGP_HELP_FMT: %s value is less than or equal to %s\"),\n                          \"rmargin\", up->name);\n          return;\n        }\n    }\n  uparams = *upptr;\n  uparams.valid = 1;\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fill_in_uparams": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static void\nfill_in_uparams (const struct argp_state *state)\n{\n  const char *var = getenv (\"ARGP_HELP_FMT\");\n  struct uparams new_params = uparams;\n\n#define SKIPWS(p) do { while (isspace ((unsigned char) *p)) p++; } while (0);\n\n  if (var)\n    {\n      /* Parse var. */\n      while (*var)\n        {\n          SKIPWS (var);\n\n          if (isalpha ((unsigned char) *var))\n            {\n              size_t var_len;\n              const struct uparam_name *un;\n              int unspec = 0, val = 0;\n              const char *arg = var;\n\n              while (isalnum ((unsigned char) *arg) || *arg == '-' || *arg == '_')\n                arg++;\n              var_len = arg - var;\n\n              SKIPWS (arg);\n\n              if (*arg == '\\0' || *arg == ',')\n                unspec = 1;\n              else if (*arg == '=')\n                {\n                  arg++;\n                  SKIPWS (arg);\n                }\n\n              if (unspec)\n                {\n                  if (var[0] == 'n' && var[1] == 'o' && var[2] == '-')\n                    {\n                      val = 0;\n                      var += 3;\n                      var_len -= 3;\n                    }\n                  else\n                    val = 1;\n                }\n              else if (isdigit ((unsigned char) *arg))\n                {\n                  val = atoi (arg);\n                  while (isdigit ((unsigned char) *arg))\n                    arg++;\n                  SKIPWS (arg);\n                }\n\n              for (un = uparam_names; un->name; un++)\n                if (strlen (un->name) == var_len\n                    && strncmp (var, un->name, var_len) == 0)\n                  {\n                    if (unspec && !un->is_bool)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter requires a value\"),\n                                      (int) var_len, var);\n                    else if (val < 0)\n                      __argp_failure (state, 0, 0,\n                                      dgettext (state->root_argp->argp_domain,\n                                                \"\\\n%.*s: ARGP_HELP_FMT parameter must be positive\"),\n                                      (int) var_len, var);\n                    else\n                      *(int *)((char *)&new_params + un->uparams_offs) = val;\n                    break;\n                  }\n              if (! un->name)\n                __argp_failure (state, 0, 0,\n                                dgettext (state->root_argp->argp_domain, \"\\\n%.*s: Unknown ARGP_HELP_FMT parameter\"),\n                                (int) var_len, var);\n\n              var = arg;\n              if (*var == ',')\n                var++;\n            }\n          else if (*var)\n            {\n              __argp_failure (state, 0, 0,\n                              dgettext (state->root_argp->argp_domain,\n                                        \"Garbage in ARGP_HELP_FMT: %s\"), var);\n              break;\n            }\n        }\n      validate_uparams (state, &new_params);\n    }\n}",
      "lines": 96,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_char": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static int\nfind_char (char ch, char *beg, char *end)\n{\n  while (beg < end)\n    if (*beg == ch)\n      return 1;\n    else\n      beg++;\n  return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "make_hol": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "static struct hol *\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  char *so;\n  const struct argp_option *o;\n  const struct argp_option *opts = argp->options;\n  struct hol_entry *entry;\n  unsigned num_short_options = 0;\n  struct hol *hol = malloc (sizeof (struct hol));\n\n  assert (hol);\n\n  hol->num_entries = 0;\n  hol->clusters = 0;\n\n  if (opts)\n    {\n      int cur_group = 0;\n\n      /* The first option must not be an alias.  */\n      assert (! oalias (opts));\n\n      /* Calculate the space needed.  */\n      for (o = opts; ! oend (o); o++)\n        {\n          if (! oalias (o))\n            hol->num_entries++;\n          if (oshort (o))\n            num_short_options++;        /* This is an upper bound.  */\n        }\n\n      hol->entries = malloc (sizeof (struct hol_entry) * hol->num_entries);\n      hol->short_options = malloc (num_short_options + 1);\n\n      assert (hol->entries && hol->short_options);\n      if (SIZE_MAX <= UINT_MAX)\n        assert (hol->num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n      /* Fill in the entries.  */\n      so = hol->short_options;\n      for (o = opts, entry = hol->entries; ! oend (o); entry++)\n        {\n          entry->opt = o;\n          entry->num = 0;\n          entry->short_options = so;\n          entry->group = cur_group =\n            o->group\n            ? o->group\n            : ((!o->name && !o->key)\n               ? cur_group + 1\n               : cur_group);\n          entry->cluster = cluster;\n          entry->argp = argp;\n\n          do\n            {\n              entry->num++;\n              if (oshort (o) && ! find_char (o->key, hol->short_options, so))\n                /* O has a valid short option which hasn't already been used.*/\n                *so++ = o->key;\n              o++;\n            }\n          while (! oend (o) && oalias (o));\n        }\n      *so = '\\0';               /* null terminated so we can find the length */\n    }\n\n  return hol;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nmake_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "hol_add_cluster": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "static struct hol_cluster *\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)\n{\n  struct hol_cluster *cl = malloc (sizeof (struct hol_cluster));\n  if (cl)\n    {\n      cl->group = group;\n      cl->header = header;\n\n      cl->index = index;\n      cl->parent = parent;\n      cl->argp = argp;\n      cl->depth = parent ? parent->depth + 1 : 0;\n\n      cl->next = hol->clusters;\n      hol->clusters = cl;\n    }\n  return cl;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_add_cluster (struct hol *hol, int group, const char *header, int index,\n                 struct hol_cluster *parent, const struct argp *argp)",
        "*"
      ]
    },
    "hol_free": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "static void\nhol_free (struct hol *hol)\n{\n  struct hol_cluster *cl = hol->clusters;\n\n  while (cl)\n    {\n      struct hol_cluster *next = cl->next;\n      free (cl);\n      cl = next;\n    }\n\n  if (hol->num_entries > 0)\n    {\n      free (hol->entries);\n      free (hol->short_options);\n    }\n\n  free (hol);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_short_iterate": {
      "start_point": [
        547,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static int\nhol_entry_short_iterate (const struct hol_entry *entry,\n                         int (*func)(const struct argp_option *opt,\n                                     const struct argp_option *real,\n                                     const char *domain, void *cookie),\n                         const char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n  char *so = entry->short_options;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (oshort (opt) && *so == opt->key)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n        so++;\n      }\n\n  return val;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "always_inline": {
      "start_point": [
        580,
        30
      ],
      "end_point": [
        596,
        1
      ],
      "content": "char *domain, void *cookie)\n{\n  unsigned nopts;\n  int val = 0;\n  const struct argp_option *opt, *real = entry->opt;\n\n  for (opt = real, nopts = entry->num; nopts > 0 && !val; opt++, nopts--)\n    if (opt->name)\n      {\n        if (!oalias (opt))\n          real = opt;\n        if (ovisible (opt))\n          val = (*func)(opt, real, domain, cookie);\n      }\n\n  return val;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": null
    },
    "until_short": {
      "start_point": [
        599,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static int\nuntil_short (const struct argp_option *opt, const struct argp_option *real,\n             const char *domain, void *cookie)\n{\n  return oshort (opt) ? opt->key : 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_first_short": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "static char\nhol_entry_first_short (const struct hol_entry *entry)\n{\n  return hol_entry_short_iterate (entry, until_short,\n                                  entry->argp->argp_domain, 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "hol_entry_first_long": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static const char *\nhol_entry_first_long (const struct hol_entry *entry)\n{\n  const struct argp_option *opt;\n  unsigned num;\n  for (opt = entry->opt, num = entry->num; num > 0; opt++, num--)\n    if (opt->name && ovisible (opt))\n      return opt->name;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nhol_entry_first_long (const struct hol_entry *entry)",
        "*"
      ]
    },
    "hol_find_entry": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "static struct hol_entry *\nhol_find_entry (struct hol *hol, const char *name)\n{\n  struct hol_entry *entry = hol->entries;\n  unsigned num_entries = hol->num_entries;\n\n  while (num_entries-- > 0)\n    {\n      const struct argp_option *opt = entry->opt;\n      unsigned num_opts = entry->num;\n\n      while (num_opts-- > 0)\n        if (opt->name && ovisible (opt) && strcmp (opt->name, name) == 0)\n          return entry;\n        else\n          opt++;\n\n      entry++;\n    }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct hol_entry",
        "struct",
        "hol_entry",
        "*\nhol_find_entry (struct hol *hol, const char *name)",
        "*"
      ]
    },
    "hol_set_group": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        659,
        1
      ],
      "content": "static void\nhol_set_group (struct hol *hol, const char *name, int group)\n{\n  struct hol_entry *entry = hol_find_entry (hol, name);\n  if (entry)\n    entry->group = group;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "group_cmp": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "static int\ngroup_cmp (int group1, int group2, int eq)\n{\n  if (group1 == group2)\n    return eq;\n  else if ((group1 < 0 && group2 < 0) || (group1 >= 0 && group2 >= 0))\n    return group1 - group2;\n  else\n    return group2 - group1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_cmp": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "static int\nhol_cluster_cmp (const struct hol_cluster *cl1, const struct hol_cluster *cl2)\n{\n  /* If one cluster is deeper than the other, use its ancestor at the same\n     level, so that finding the common ancestor is straightforward.\n\n     clN->depth > 0 means that clN->parent != NULL (see hol_add_cluster) */\n  while (cl1->depth > cl2->depth)\n    cl1 = cl1->parent;\n  while (cl2->depth > cl1->depth)\n    cl2 = cl2->parent;\n\n  /* Now reduce both clusters to their ancestors at the point where both have\n     a common parent; these can be directly compared.  */\n  while (cl1->parent != cl2->parent)\n    cl1 = cl1->parent, cl2 = cl2->parent;\n\n  return group_cmp (cl1->group, cl2->group, cl2->index - cl1->index);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_cluster_base": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "static struct hol_cluster *\nhol_cluster_base (struct hol_cluster *cl)\n{\n  while (cl->parent)\n    cl = cl->parent;\n  return cl;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct hol_cluster",
        "struct",
        "hol_cluster",
        "*\nhol_cluster_base (struct hol_cluster *cl)",
        "*"
      ]
    },
    "hol_cluster_is_child": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static int\nhol_cluster_is_child (const struct hol_cluster *cl1,\n                      const struct hol_cluster *cl2)\n{\n  while (cl1 && cl1 != cl2)\n    cl1 = cl1->parent;\n  return cl1 == cl2;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "canon_doc_option": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "static int\ncanon_doc_option (const char **name)\n{\n  int non_opt;\n\n  if (!*name)\n    non_opt = 1;\n  else\n    {\n      /* Skip initial whitespace.  */\n      while (isspace ((unsigned char) **name))\n        (*name)++;\n      /* Decide whether this looks like an option (leading '-') or not.  */\n      non_opt = (**name != '-');\n      /* Skip until part of name used for sorting.  */\n      while (**name && !isalnum ((unsigned char) **name))\n        (*name)++;\n    }\n  return non_opt;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_cmp": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        818,
        1
      ],
      "content": "static int\nhol_entry_cmp (const struct hol_entry *entry1,\n               const struct hol_entry *entry2)\n{\n  /* The group numbers by which the entries should be ordered; if either is\n     in a cluster, then this is just the group within the cluster.  */\n  int group1 = entry1->group, group2 = entry2->group;\n  int rc;\n\n  if (entry1->cluster != entry2->cluster)\n    {\n      /* The entries are not within the same cluster, so we can't compare them\n         directly, we have to use the appropriate clustering level too.  */\n      if (! entry1->cluster)\n        /* ENTRY1 is at the \"base level\", not in a cluster, so we have to\n           compare it's group number with that of the base cluster in which\n           ENTRY2 resides.  Note that if they're in the same group, the\n           clustered option always comes laster.  */\n        return group_cmp (group1, hol_cluster_base (entry2->cluster)->group, -1);\n      else if (! entry2->cluster)\n        /* Likewise, but ENTRY2's not in a cluster.  */\n        return group_cmp (hol_cluster_base (entry1->cluster)->group, group2, 1);\n      else\n        /* Both entries are in clusters, we can just compare the clusters.  */\n        return (rc = hol_cluster_cmp (entry1->cluster, entry2->cluster)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n    }\n  else if (group1 == group2)\n    /* The entries are both in the same cluster and group, so compare them\n       alphabetically.  */\n    {\n      int short1 = hol_entry_first_short (entry1);\n      int short2 = hol_entry_first_short (entry2);\n      int doc1 = odoc (entry1->opt);\n      int doc2 = odoc (entry2->opt);\n      const char *long1 = hol_entry_first_long (entry1);\n      const char *long2 = hol_entry_first_long (entry2);\n\n      if (doc1)\n        doc1 = canon_doc_option (&long1);\n      if (doc2)\n        doc2 = canon_doc_option (&long2);\n\n      if (doc1 != doc2)\n        /* \"documentation\" options always follow normal options (or\n           documentation options that *look* like normal options).  */\n        return doc1 - doc2;\n      else if (!short1 && !short2 && long1 && long2)\n        /* Only long options.  */\n        return (rc = __strcasecmp (long1, long2)) ?\n               rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n      else\n        /* Compare short/short, long/short, short/long, using the first\n           character of long options.  Entries without *any* valid\n           options (such as options with OPTION_HIDDEN set) will be put\n           first, but as they're not displayed, it doesn't matter where\n           they are.  */\n        {\n          unsigned char first1 = short1 ? short1 : long1 ? *long1 : 0;\n          unsigned char first2 = short2 ? short2 : long2 ? *long2 : 0;\n          /* Use tolower, not _tolower, since only the former is\n             guaranteed to work on something already lower case.  */\n          int lower_cmp = tolower (first1) - tolower (first2);\n          /* Compare ignoring case, except when the options are both the\n             same letter, in which case lower-case always comes first.  */\n          return lower_cmp ? lower_cmp :\n                 (rc = first2 - first1) ?\n                 rc : HOL_ENTRY_PTRCMP (entry1, entry2);\n        }\n    }\n  else\n    /* Within the same cluster, but not the same group, so just compare\n       groups.  */\n    return group_cmp (group1, group2, HOL_ENTRY_PTRCMP (entry1, entry2));\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_entry_qcmp": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static int\nhol_entry_qcmp (const void *entry1_v, const void *entry2_v)\n{\n  return hol_entry_cmp (entry1_v, entry2_v);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_sort": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "static void\nhol_sort (struct hol *hol)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned i;\n      struct hol_entry *e;\n      for (i = 0, e = hol->entries; i < hol->num_entries; i++, e++)\n        e->ord = i;\n      qsort (hol->entries, hol->num_entries, sizeof (struct hol_entry),\n             hol_entry_qcmp);\n    }\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_append": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        936,
        1
      ],
      "content": "static void\nhol_append (struct hol *hol, struct hol *more)\n{\n  struct hol_cluster **cl_end = &hol->clusters;\n\n  /* Steal MORE's cluster list, and add it to the end of HOL's.  */\n  while (*cl_end)\n    cl_end = &(*cl_end)->next;\n  *cl_end = more->clusters;\n  more->clusters = 0;\n\n  /* Merge entries.  */\n  if (more->num_entries > 0)\n    {\n      if (hol->num_entries == 0)\n        {\n          hol->num_entries = more->num_entries;\n          hol->entries = more->entries;\n          hol->short_options = more->short_options;\n          more->num_entries = 0;        /* Mark MORE's fields as invalid.  */\n        }\n      else\n        /* Append the entries in MORE to those in HOL, taking care to only add\n           non-shadowed SHORT_OPTIONS values.  */\n        {\n          unsigned left;\n          char *so, *more_so;\n          struct hol_entry *e;\n          unsigned num_entries = hol->num_entries + more->num_entries;\n          struct hol_entry *entries =\n            malloc (num_entries * sizeof (struct hol_entry));\n          unsigned hol_so_len = strlen (hol->short_options);\n          char *short_options =\n            malloc (hol_so_len + strlen (more->short_options) + 1);\n\n          assert (entries && short_options);\n          if (SIZE_MAX <= UINT_MAX)\n            assert (num_entries <= SIZE_MAX / sizeof (struct hol_entry));\n\n          __mempcpy (__mempcpy (entries, hol->entries,\n                                hol->num_entries * sizeof (struct hol_entry)),\n                     more->entries,\n                     more->num_entries * sizeof (struct hol_entry));\n\n          __mempcpy (short_options, hol->short_options, hol_so_len);\n\n          /* Fix up the short options pointers from HOL.  */\n          for (e = entries, left = hol->num_entries; left > 0; e++, left--)\n            e->short_options =\n              short_options + (e->short_options - hol->short_options);\n\n          /* Now add the short options from MORE, fixing up its entries\n             too.  */\n          so = short_options + hol_so_len;\n          more_so = more->short_options;\n          for (left = more->num_entries; left > 0; e++, left--)\n            {\n              int opts_left;\n              const struct argp_option *opt;\n\n              e->short_options = so;\n\n              for (opts_left = e->num, opt = e->opt; opts_left; opt++, opts_left--)\n                {\n                  int ch = *more_so;\n                  if (oshort (opt) && ch == opt->key)\n                    /* The next short option in MORE_SO, CH, is from OPT.  */\n                    {\n                      if (! find_char (ch, short_options,\n                                       short_options + hol_so_len))\n                        /* The short option CH isn't shadowed by HOL's options,\n                           so add it to the sum.  */\n                        *so++ = ch;\n                      more_so++;\n                    }\n                }\n            }\n\n          *so = '\\0';\n\n          free (hol->entries);\n          free (hol->short_options);\n\n          hol->entries = entries;\n          hol->num_entries = num_entries;\n          hol->short_options = short_options;\n        }\n    }\n\n  hol_free (more);\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indent_to": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void\nindent_to (argp_fmtstream_t stream, unsigned col)\n{\n  int needed = col - __argp_fmtstream_point (stream);\n  while (needed-- > 0)\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "space": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        957,
        1
      ],
      "content": "static void\nspace (argp_fmtstream_t stream, size_t ensure)\n{\n  if (__argp_fmtstream_point (stream) + ensure\n      >= __argp_fmtstream_rmargin (stream))\n    __argp_fmtstream_putc (stream, '\\n');\n  else\n    __argp_fmtstream_putc (stream, ' ');\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "arg": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        975,
        1
      ],
      "content": "static void\narg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,\n     const char *domain, argp_fmtstream_t stream)\n{\n  if (real->arg)\n    {\n      if (real->flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, opt_fmt,\n                                 dgettext (domain, real->arg));\n      else\n        __argp_fmtstream_printf (stream, req_fmt,\n                                 dgettext (domain, real->arg));\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "filter_doc": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static const char *\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)\n{\n  if (argp->help_filter)\n    /* We must apply a user filter to this output.  */\n    {\n      void *input = __argp_input (argp, state);\n      return (*argp->help_filter) (key, doc, input);\n    }\n  else\n    /* No filter.  */\n    return doc;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nfilter_doc (const char *doc, int key, const struct argp *argp,\n            const struct argp_state *state)",
        "*"
      ]
    },
    "print_header": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1058,
        1
      ],
      "content": "static void\nprint_header (const char *str, const struct argp *argp,\n              struct pentry_state *pest)\n{\n  const char *tstr = dgettext (argp->argp_domain, str);\n  const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_HEADER, argp, pest->state);\n\n  if (fstr)\n    {\n      if (*fstr)\n        {\n          if (pest->hhstate->prev_entry)\n            /* Precede with a blank line.  */\n            __argp_fmtstream_putc (pest->stream, '\\n');\n          indent_to (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_lmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_set_wmargin (pest->stream, uparams.header_col);\n          __argp_fmtstream_puts (pest->stream, fstr);\n          __argp_fmtstream_set_lmargin (pest->stream, 0);\n          __argp_fmtstream_putc (pest->stream, '\\n');\n        }\n\n      pest->hhstate->sep_groups = 1; /* Separate subsequent groups. */\n    }\n\n  if (fstr != tstr)\n    free ((char *) fstr);\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "comma": {
      "start_point": [
        1064,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "static void\ncomma (unsigned col, struct pentry_state *pest)\n{\n  if (pest->first)\n    {\n      const struct hol_entry *pe = pest->hhstate->prev_entry;\n      const struct hol_cluster *cl = pest->entry->cluster;\n\n      if (pest->hhstate->sep_groups && pe && pest->entry->group != pe->group)\n        __argp_fmtstream_putc (pest->stream, '\\n');\n\n      if (cl && cl->header && *cl->header\n          && (!pe\n              || (pe->cluster != cl\n                  && !hol_cluster_is_child (pe->cluster, cl))))\n        /* If we're changing clusters, then this must be the start of the\n           ENTRY's cluster unless that is an ancestor of the previous one\n           (in which case we had just popped into a sub-cluster for a bit).\n           If so, then print the cluster's header line.  */\n        {\n          int old_wm = __argp_fmtstream_wmargin (pest->stream);\n          print_header (cl->header, cl->argp, pest);\n          __argp_fmtstream_set_wmargin (pest->stream, old_wm);\n        }\n\n      pest->first = 0;\n    }\n  else\n    __argp_fmtstream_puts (pest->stream, \", \");\n\n  indent_to (pest->stream, col);\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_entry_help": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1231,
        1
      ],
      "content": "static void\nhol_entry_help (struct hol_entry *entry, const struct argp_state *state,\n                argp_fmtstream_t stream, struct hol_help_state *hhstate)\n{\n  unsigned num;\n  const struct argp_option *real = entry->opt, *opt;\n  char *so = entry->short_options;\n  int have_long_opt = 0;        /* We have any long options.  */\n  /* Saved margins.  */\n  int old_lm = __argp_fmtstream_set_lmargin (stream, 0);\n  int old_wm = __argp_fmtstream_wmargin (stream);\n  /* PEST is a state block holding some of our variables that we'd like to\n     share with helper functions.  */\n  struct pentry_state pest;\n\n  pest.entry = entry;\n  pest.stream = stream;\n  pest.hhstate = hhstate;\n  pest.first = 1;\n  pest.state = state;\n\n  if (! odoc (real))\n    for (opt = real, num = entry->num; num > 0; opt++, num--)\n      if (opt->name && ovisible (opt))\n        {\n          have_long_opt = 1;\n          break;\n        }\n\n  /* First emit short options.  */\n  __argp_fmtstream_set_wmargin (stream, uparams.short_opt_col); /* For truly bizarre cases. */\n  for (opt = real, num = entry->num; num > 0; opt++, num--)\n    if (oshort (opt) && opt->key == *so)\n      /* OPT has a valid (non shadowed) short option.  */\n      {\n        if (ovisible (opt))\n          {\n            comma (uparams.short_opt_col, &pest);\n            __argp_fmtstream_putc (stream, '-');\n            __argp_fmtstream_putc (stream, *so);\n            if (!have_long_opt || uparams.dup_args)\n              arg (real, \" %s\", \"[%s]\", state->root_argp->argp_domain, stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n        so++;\n      }\n\n  /* Now, long options.  */\n  if (odoc (real))\n    /* A \"documentation\" option.  */\n    {\n      __argp_fmtstream_set_wmargin (stream, uparams.doc_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && *opt->name && ovisible (opt))\n          {\n            comma (uparams.doc_opt_col, &pest);\n            /* Calling dgettext here isn't quite right, since sorting will\n               have been done on the original; but documentation options\n               should be pretty rare anyway...  */\n            __argp_fmtstream_puts (stream,\n                                   onotrans (opt) ?\n                                             opt->name :\n                                   dgettext (state->root_argp->argp_domain,\n                                             opt->name));\n          }\n    }\n  else\n    /* A real long option.  */\n    {\n      int first_long_opt = 1;\n\n      __argp_fmtstream_set_wmargin (stream, uparams.long_opt_col);\n      for (opt = real, num = entry->num; num > 0; opt++, num--)\n        if (opt->name && ovisible (opt))\n          {\n            comma (uparams.long_opt_col, &pest);\n            __argp_fmtstream_printf (stream, \"--%s\", opt->name);\n            if (first_long_opt || uparams.dup_args)\n              arg (real, \"=%s\", \"[=%s]\", state->root_argp->argp_domain,\n                   stream);\n            else if (real->arg)\n              hhstate->suppressed_dup_arg = 1;\n          }\n    }\n\n  /* Next, documentation strings.  */\n  __argp_fmtstream_set_lmargin (stream, 0);\n\n  if (pest.first)\n    {\n      /* Didn't print any switches, what's up?  */\n      if (!oshort (real) && !real->name)\n        /* This is a group header, print it nicely.  */\n        print_header (real->doc, entry->argp, &pest);\n      else\n        /* Just a totally shadowed option or null header; print nothing.  */\n        goto cleanup;           /* Just return, after cleaning up.  */\n    }\n  else\n    {\n      const char *tstr = real->doc ? dgettext (state->root_argp->argp_domain,\n                                               real->doc) : 0;\n      const char *fstr = filter_doc (tstr, real->key, entry->argp, state);\n      if (fstr && *fstr)\n        {\n          unsigned int col = __argp_fmtstream_point (stream);\n\n          __argp_fmtstream_set_lmargin (stream, uparams.opt_doc_col);\n          __argp_fmtstream_set_wmargin (stream, uparams.opt_doc_col);\n\n          if (col > (unsigned int) (uparams.opt_doc_col + 3))\n            __argp_fmtstream_putc (stream, '\\n');\n          else if (col >= (unsigned int) uparams.opt_doc_col)\n            __argp_fmtstream_puts (stream, \"   \");\n          else\n            indent_to (stream, uparams.opt_doc_col);\n\n          __argp_fmtstream_puts (stream, fstr);\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n\n      /* Reset the left margin.  */\n      __argp_fmtstream_set_lmargin (stream, 0);\n      __argp_fmtstream_putc (stream, '\\n');\n    }\n\n  hhstate->prev_entry = entry;\n\ncleanup:\n  __argp_fmtstream_set_lmargin (stream, old_lm);\n  __argp_fmtstream_set_wmargin (stream, old_wm);\n}",
      "lines": 134,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hol_help": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1261,
        1
      ],
      "content": "static void\nhol_help (struct hol *hol, const struct argp_state *state,\n          argp_fmtstream_t stream)\n{\n  unsigned num;\n  struct hol_entry *entry;\n  struct hol_help_state hhstate = { 0, 0, 0 };\n\n  for (entry = hol->entries, num = hol->num_entries; num > 0; entry++, num--)\n    hol_entry_help (entry, state, stream, &hhstate);\n\n  if (hhstate.suppressed_dup_arg && uparams.dup_args_note)\n    {\n      const char *tstr = dgettext (state->root_argp->argp_domain, \"\\\nMandatory or optional arguments to long options are also mandatory or \\\noptional for any corresponding short options.\");\n      const char *fstr = filter_doc (tstr, ARGP_KEY_HELP_DUP_ARGS_NOTE,\n                                     state ? state->root_argp : 0, state);\n      if (fstr && *fstr)\n        {\n          __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, fstr);\n          __argp_fmtstream_putc (stream, '\\n');\n        }\n      if (fstr && fstr != tstr)\n        free ((char *) fstr);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_argless_short_opt": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1277,
        1
      ],
      "content": "static int\nadd_argless_short_opt (const struct argp_option *opt,\n                       const struct argp_option *real,\n                       const char *domain, void *cookie)\n{\n  char **snao_end = cookie;\n  if (!(opt->arg || real->arg)\n      && !((opt->flags | real->flags) & OPTION_NO_USAGE))\n    *(*snao_end)++ = opt->key;\n  return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_argful_short_opt": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "static int\nusage_argful_short_opt (const struct argp_option *opt,\n                        const struct argp_option *real,\n                        const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (arg && !(flags & OPTION_NO_USAGE))\n    {\n      arg = dgettext (domain, arg);\n\n      if (flags & OPTION_ARG_OPTIONAL)\n        __argp_fmtstream_printf (stream, \" [-%c[%s]]\", opt->key, arg);\n      else\n        {\n          /* Manually do line wrapping so that it (probably) won't\n             get wrapped at the embedded space.  */\n          space (stream, 6 + strlen (arg));\n          __argp_fmtstream_printf (stream, \"[-%c %s]\", opt->key, arg);\n        }\n    }\n\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage_long_opt": {
      "start_point": [
        1313,
        0
      ],
      "end_point": [
        1340,
        1
      ],
      "content": "static int\nusage_long_opt (const struct argp_option *opt,\n                const struct argp_option *real,\n                const char *domain, void *cookie)\n{\n  argp_fmtstream_t stream = cookie;\n  const char *arg = opt->arg;\n  int flags = opt->flags | real->flags;\n\n  if (! arg)\n    arg = real->arg;\n\n  if (! (flags & OPTION_NO_USAGE) && !odoc (opt))\n    {\n      if (arg)\n        {\n          arg = dgettext (domain, arg);\n          if (flags & OPTION_ARG_OPTIONAL)\n            __argp_fmtstream_printf (stream, \" [--%s[=%s]]\", opt->name, arg);\n          else\n            __argp_fmtstream_printf (stream, \" [--%s=%s]\", opt->name, arg);\n        }\n      else\n        __argp_fmtstream_printf (stream, \" [--%s]\", opt->name);\n    }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hol_usage": {
      "start_point": [
        1343,
        0
      ],
      "end_point": [
        1379,
        1
      ],
      "content": "static void\nhol_usage (struct hol *hol, argp_fmtstream_t stream)\n{\n  if (hol->num_entries > 0)\n    {\n      unsigned nentries;\n      struct hol_entry *entry;\n      char *short_no_arg_opts = alloca (strlen (hol->short_options) + 1);\n      char *snao_end = short_no_arg_opts;\n\n      /* First we put a list of short options without arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, add_argless_short_opt,\n                                 entry->argp->argp_domain, &snao_end);\n      if (snao_end > short_no_arg_opts)\n        {\n          *snao_end++ = 0;\n          __argp_fmtstream_printf (stream, \" [-%s]\", short_no_arg_opts);\n        }\n\n      /* Now a list of short options *with* arguments.  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_short_iterate (entry, usage_argful_short_opt,\n                                 entry->argp->argp_domain, stream);\n\n      /* Finally, a list of long options (whew!).  */\n      for (entry = hol->entries, nentries = hol->num_entries\n           ; nentries > 0\n           ; entry++, nentries--)\n        hol_entry_long_iterate (entry, usage_long_opt,\n                                entry->argp->argp_domain, stream);\n    }\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_hol": {
      "start_point": [
        1383,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static struct hol *\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)\n{\n  const struct argp_child *child = argp->children;\n  struct hol *hol = make_hol (argp, cluster);\n  if (child)\n    while (child->argp)\n      {\n        struct hol_cluster *child_cluster =\n          ((child->group || child->header)\n           /* Put CHILD->argp within its own cluster.  */\n           ? hol_add_cluster (hol, child->group, child->header,\n                              child - argp->children, cluster, argp)\n           /* Just merge it into the parent's cluster.  */\n           : cluster);\n        hol_append (hol, argp_hol (child->argp, child_cluster)) ;\n        child++;\n      }\n  return hol;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct hol",
        "struct",
        "hol",
        "*\nargp_hol (const struct argp *argp, struct hol_cluster *cluster)",
        "*"
      ]
    },
    "argp_args_levels": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1420,
        1
      ],
      "content": "static size_t\nargp_args_levels (const struct argp *argp)\n{\n  size_t levels = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->args_doc && strchr (argp->args_doc, '\\n'))\n    levels++;\n\n  if (child)\n    while (child->argp)\n      levels += argp_args_levels ((child++)->argp);\n\n  return levels;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "argp_args_usage": {
      "start_point": [
        1427,
        0
      ],
      "end_point": [
        1480,
        1
      ],
      "content": "static int\nargp_args_usage (const struct argp *argp, const struct argp_state *state,\n                 char **levels, int advance, argp_fmtstream_t stream)\n{\n  char *our_level = *levels;\n  int multiple = 0;\n  const struct argp_child *child = argp->children;\n  const char *tdoc = dgettext (argp->argp_domain, argp->args_doc), *nl = 0;\n  const char *fdoc = filter_doc (tdoc, ARGP_KEY_HELP_ARGS_DOC, argp, state);\n\n  if (fdoc)\n    {\n      const char *cp = fdoc;\n      nl = __strchrnul (cp, '\\n');\n      if (*nl != '\\0')\n        /* This is a \"multi-level\" args doc; advance to the correct position\n           as determined by our state in LEVELS, and update LEVELS.  */\n        {\n          int i;\n          multiple = 1;\n          for (i = 0; i < *our_level; i++)\n            cp = nl + 1, nl = __strchrnul (cp, '\\n');\n          (*levels)++;\n        }\n\n      /* Manually do line wrapping so that it (probably) won't get wrapped at\n         any embedded spaces.  */\n      space (stream, 1 + nl - cp);\n\n      __argp_fmtstream_write (stream, cp, nl - cp);\n    }\n  if (fdoc && fdoc != tdoc)\n    free ((char *)fdoc);        /* Free user's modified doc string.  */\n\n  if (child)\n    while (child->argp)\n      advance = !argp_args_usage ((child++)->argp, state, levels, advance, stream);\n\n  if (advance && multiple)\n    {\n      /* Need to increment our level.  */\n      if (*nl)\n        /* There's more we can do here.  */\n        {\n          (*our_level)++;\n          advance = 0;          /* Our parent shouldn't advance also. */\n        }\n      else if (*our_level > 0)\n        /* We had multiple levels, but used them up; reset to zero.  */\n        *our_level = 0;\n    }\n\n  return !advance;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argp_doc": {
      "start_point": [
        1489,
        0
      ],
      "end_point": [
        1583,
        1
      ],
      "content": "static int\nargp_doc (const struct argp *argp, const struct argp_state *state,\n          int post, int pre_blank, int first_only,\n          argp_fmtstream_t stream)\n{\n  const char *text;\n  const char *inp_text;\n  size_t inp_text_len = 0;\n  const char *trans_text;\n  void *input = 0;\n  int anything = 0;\n  const struct argp_child *child = argp->children;\n\n  if (argp->doc)\n    {\n      char *vt = strchr (argp->doc, '\\v');\n      if (vt)\n        {\n          if (post)\n            {\n              inp_text = vt + 1;\n              if (! *inp_text)\n                inp_text = 0;\n            }\n          else\n            {\n              inp_text_len = vt - argp->doc;\n              inp_text = inp_text_len ? __strndup (argp->doc, inp_text_len) : 0;\n            }\n        }\n      else\n        inp_text = post ? 0 : argp->doc;\n      trans_text = inp_text ? dgettext (argp->argp_domain, inp_text) : NULL;\n    }\n  else\n    trans_text = inp_text = 0;\n\n  if (argp->help_filter)\n    /* We have to filter the doc strings.  */\n    {\n      input = __argp_input (argp, state);\n      text =\n        (*argp->help_filter) (post\n                              ? ARGP_KEY_HELP_POST_DOC\n                              : ARGP_KEY_HELP_PRE_DOC,\n                              trans_text, input);\n    }\n  else\n    text = (const char *) trans_text;\n\n  if (text)\n    {\n      if (pre_blank)\n        __argp_fmtstream_putc (stream, '\\n');\n\n      __argp_fmtstream_puts (stream, text);\n\n      if (__argp_fmtstream_point (stream) > __argp_fmtstream_lmargin (stream))\n        __argp_fmtstream_putc (stream, '\\n');\n\n      anything = 1;\n    }\n\n  if (text && text != trans_text)\n    free ((char *) text);       /* Free TEXT returned from the help filter.  */\n\n  if (inp_text && inp_text_len)\n    free ((char *) inp_text);   /* We copied INP_TEXT, so free it now.  */\n\n  if (post && argp->help_filter)\n    /* Now see if we have to output an ARGP_KEY_HELP_EXTRA text.  */\n    {\n      text = (*argp->help_filter) (ARGP_KEY_HELP_EXTRA, 0, input);\n      if (text)\n        {\n          if (anything || pre_blank)\n            __argp_fmtstream_putc (stream, '\\n');\n          __argp_fmtstream_puts (stream, text);\n          free ((char *) text);\n          if (__argp_fmtstream_point (stream)\n              > __argp_fmtstream_lmargin (stream))\n            __argp_fmtstream_putc (stream, '\\n');\n          anything = 1;\n        }\n    }\n\n  if (child)\n    while (child->argp && !(first_only && anything))\n      anything |=\n        argp_doc ((child++)->argp, state,\n                  post, anything || pre_blank, first_only,\n                  stream);\n\n  return anything;\n}",
      "lines": 95,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_help": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1728,
        1
      ],
      "content": "static void\n_help (const struct argp *argp, const struct argp_state *state, FILE *stream,\n       unsigned flags, char *name)\n{\n  int anything = 0;             /* Whether we've output anything.  */\n  struct hol *hol = 0;\n  argp_fmtstream_t fs;\n\n  if (! stream)\n    return;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __flockfile (stream);\n#endif\n\n  if (! uparams.valid)\n    fill_in_uparams (state);\n\n  fs = __argp_make_fmtstream (stream, 0, uparams.rmargin, 0);\n  if (! fs)\n    {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n      __funlockfile (stream);\n#endif\n      return;\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE | ARGP_HELP_LONG))\n    {\n      hol = argp_hol (argp, 0);\n\n      /* If present, these options always come last.  */\n      hol_set_group (hol, \"help\", -1);\n      hol_set_group (hol, \"version\", -1);\n\n      hol_sort (hol);\n    }\n\n  if (flags & (ARGP_HELP_USAGE | ARGP_HELP_SHORT_USAGE))\n    /* Print a short \"Usage:\" message.  */\n    {\n      int first_pattern = 1, more_patterns;\n      size_t num_pattern_levels = argp_args_levels (argp);\n      char *pattern_levels = alloca (num_pattern_levels);\n\n      memset (pattern_levels, 0, num_pattern_levels);\n\n      do\n        {\n          int old_lm;\n          int old_wm = __argp_fmtstream_set_wmargin (fs, uparams.usage_indent);\n          char *levels = pattern_levels;\n\n          if (first_pattern)\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"Usage:\"),\n                                     name);\n          else\n            __argp_fmtstream_printf (fs, \"%s %s\",\n                                     dgettext (argp->argp_domain, \"  or: \"),\n                                     name);\n\n          /* We set the lmargin as well as the wmargin, because hol_usage\n             manually wraps options with newline to avoid annoying breaks.  */\n          old_lm = __argp_fmtstream_set_lmargin (fs, uparams.usage_indent);\n\n          if (flags & ARGP_HELP_SHORT_USAGE)\n            /* Just show where the options go.  */\n            {\n              if (hol->num_entries > 0)\n                __argp_fmtstream_puts (fs, dgettext (argp->argp_domain,\n                                                     \" [OPTION...]\"));\n            }\n          else\n            /* Actually print the options.  */\n            {\n              hol_usage (hol, fs);\n              flags |= ARGP_HELP_SHORT_USAGE; /* But only do so once.  */\n            }\n\n          more_patterns = argp_args_usage (argp, state, &levels, 1, fs);\n\n          __argp_fmtstream_set_wmargin (fs, old_wm);\n          __argp_fmtstream_set_lmargin (fs, old_lm);\n\n          __argp_fmtstream_putc (fs, '\\n');\n          anything = 1;\n\n          first_pattern = 0;\n        }\n      while (more_patterns);\n    }\n\n  if (flags & ARGP_HELP_PRE_DOC)\n    anything |= argp_doc (argp, state, 0, 0, 1, fs);\n\n  if (flags & ARGP_HELP_SEE)\n    {\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain, \"\\\nTry '%s --help' or '%s --usage' for more information.\\n\"),\n                               name, name);\n      anything = 1;\n    }\n\n  if (flags & ARGP_HELP_LONG)\n    /* Print a long, detailed help message.  */\n    {\n      /* Print info about all the options.  */\n      if (hol->num_entries > 0)\n        {\n          if (anything)\n            __argp_fmtstream_putc (fs, '\\n');\n          hol_help (hol, state, fs);\n          anything = 1;\n        }\n    }\n\n  if (flags & ARGP_HELP_POST_DOC)\n    /* Print any documentation strings at the end.  */\n    anything |= argp_doc (argp, state, 1, anything, 0, fs);\n\n  if ((flags & ARGP_HELP_BUG_ADDR) && argp_program_bug_address)\n    {\n      if (anything)\n        __argp_fmtstream_putc (fs, '\\n');\n      __argp_fmtstream_printf (fs, dgettext (argp->argp_domain,\n                                             \"Report bugs to %s.\\n\"),\n                               argp_program_bug_address);\n      anything = 1;\n    }\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n  __funlockfile (stream);\n#endif\n\n  if (hol)\n    hol_free (hol);\n\n  __argp_fmtstream_free (fs);\n}",
      "lines": 140,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "__argp_help": {
      "start_point": [
        1732,
        0
      ],
      "end_point": [
        1739,
        1
      ],
      "content": "void __argp_help (const struct argp *argp, FILE *stream,\n                  unsigned flags, char *name)\n{\n  struct argp_state state;\n  memset (&state, 0, sizeof state);\n  state.root_argp = argp;\n  _help (argp, &state, stream, flags, name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "__argp_short_program_name": {
      "start_point": [
        1745,
        0
      ],
      "end_point": [
        1759,
        1
      ],
      "content": "char *\n__argp_short_program_name (void)\n{\n# if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  return __argp_base_name (program_invocation_name);\n# else\n  /* FIXME: What now? Miles suggests that it is better to use NULL,\n     but currently the value is passed on directly to fputs_unlocked,\n     so that requires more changes. */\n# if __GNUC__\n#  warning No reasonable value to return\n# endif /* __GNUC__ */\n  return \"\";\n# endif\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__argp_short_program_name (void)",
        "*"
      ]
    },
    "__argp_state_help": {
      "start_point": [
        1764,
        0
      ],
      "end_point": [
        1783,
        1
      ],
      "content": "void\n__argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)\n{\n  if ((!state || ! (state->flags & ARGP_NO_ERRS)) && stream)\n    {\n      if (state && (state->flags & ARGP_LONG_ONLY))\n        flags |= ARGP_HELP_LONG_ONLY;\n\n      _help (state ? state->root_argp : 0, state, stream, flags,\n             state ? state->name : __argp_short_program_name ());\n\n      if (!state || ! (state->flags & ARGP_NO_EXIT))\n        {\n          if (flags & ARGP_HELP_EXIT_ERR)\n            exit (argp_err_exit_status);\n          if (flags & ARGP_HELP_EXIT_OK)\n            exit (0);\n        }\n  }\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "__argp_error": {
      "start_point": [
        1791,
        0
      ],
      "end_point": [
        1845,
        1
      ],
      "content": "void\n__argp_error (const struct argp_state *state, const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n          va_list ap;\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n          va_start (ap, fmt);\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            {\n              char *buf;\n\n              if (__asprintf (&buf, fmt, ap) < 0)\n                buf = NULL;\n\n              __fwprintf (stream, L\"%s: %s\\n\",\n                          state ? state->name : __argp_short_program_name (),\n                          buf);\n\n              free (buf);\n            }\n          else\n#endif\n            {\n              fputs_unlocked (state\n                              ? state->name : __argp_short_program_name (),\n                              stream);\n              putc_unlocked (':', stream);\n              putc_unlocked (' ', stream);\n\n              vfprintf (stream, fmt, ap);\n\n              putc_unlocked ('\\n', stream);\n            }\n\n          __argp_state_help (state, stream, ARGP_HELP_STD_ERR);\n\n          va_end (ap);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n        }\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "__argp_failure": {
      "start_point": [
        1858,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "void\n__argp_failure (const struct argp_state *state, int status, int errnum,\n                const char *fmt, ...)\n{\n  if (!state || !(state->flags & ARGP_NO_ERRS))\n    {\n      FILE *stream = state ? state->err_stream : stderr;\n\n      if (stream)\n        {\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __flockfile (stream);\n#endif\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            __fwprintf (stream, L\"%s\",\n                        state ? state->name : __argp_short_program_name ());\n          else\n#endif\n            fputs_unlocked (state\n                            ? state->name : __argp_short_program_name (),\n                            stream);\n\n          if (fmt)\n            {\n              va_list ap;\n\n              va_start (ap, fmt);\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                {\n                  char *buf;\n\n                  if (__asprintf (&buf, fmt, ap) < 0)\n                    buf = NULL;\n\n                  __fwprintf (stream, L\": %s\", buf);\n\n                  free (buf);\n                }\n              else\n#endif\n                {\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n\n                  vfprintf (stream, fmt, ap);\n                }\n\n              va_end (ap);\n            }\n\n          if (errnum)\n            {\n              char buf[200];\n\n#ifdef USE_IN_LIBIO\n              if (_IO_fwide (stream, 0) > 0)\n                __fwprintf (stream, L\": %s\",\n                            __strerror_r (errnum, buf, sizeof (buf)));\n              else\n#endif\n                {\n                  char const *s = NULL;\n                  putc_unlocked (':', stream);\n                  putc_unlocked (' ', stream);\n#if _LIBC || (HAVE_DECL_STRERROR_R && STRERROR_R_CHAR_P && !defined strerror_r)\n                  s = __strerror_r (errnum, buf, sizeof buf);\n#elif HAVE_DECL_STRERROR_R\n                  if (__strerror_r (errnum, buf, sizeof buf) == 0)\n                    s = buf;\n#endif\n#if !_LIBC\n                  if (! s && ! (s = strerror (errnum)))\n                    s = dgettext (state->root_argp->argp_domain,\n                                  \"Unknown system error\");\n#endif\n                  fputs (s, stream);\n                }\n            }\n\n#ifdef USE_IN_LIBIO\n          if (_IO_fwide (stream, 0) > 0)\n            putwc_unlocked (L'\\n', stream);\n          else\n#endif\n            putc_unlocked ('\\n', stream);\n\n#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)\n          __funlockfile (stream);\n#endif\n\n          if (status && (!state || !(state->flags & ARGP_NO_EXIT)))\n            exit (status);\n        }\n    }\n}",
      "lines": 98,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-namefrob.h": {},
  "inetutils/inetutils-1.9.4/lib/argp-parse.c": {
    "argp_default_parser": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static error_t\nargp_default_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case '?':\n      __argp_state_help (state, state->out_stream, ARGP_HELP_STD_HELP);\n      break;\n    case OPT_USAGE:\n      __argp_state_help (state, state->out_stream,\n                         ARGP_HELP_USAGE | ARGP_HELP_EXIT_OK);\n      break;\n\n    case OPT_PROGNAME:          /* Set the program name.  */\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_NAME\n      program_invocation_name = arg;\n#endif\n      /* [Note that some systems only have PROGRAM_INVOCATION_SHORT_NAME (aka\n         __PROGNAME), in which case, PROGRAM_INVOCATION_NAME is just defined\n         to be that, so we have to be a bit careful here.]  */\n\n      /* Update what we use for messages.  */\n      state->name = __argp_base_name (arg);\n\n#if defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      program_invocation_short_name = state->name;\n#endif\n\n      if ((state->flags & (ARGP_PARSE_ARGV0 | ARGP_NO_ERRS))\n          == ARGP_PARSE_ARGV0)\n        /* Update what getopt uses too.  */\n        state->argv[0] = arg;\n\n      break;\n\n    case OPT_HANG:\n      _argp_hang = atoi (arg ? arg : \"3600\");\n      while (_argp_hang-- > 0)\n        __sleep (1);\n      break;\n\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "argp_version_parser": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static error_t\nargp_version_parser (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'V':\n      if (argp_program_version_hook)\n        (*argp_program_version_hook) (state->out_stream, state);\n      else if (argp_program_version)\n        fprintf (state->out_stream, \"%s\\n\", argp_program_version);\n      else\n        __argp_error (state, \"%s\",\n                      dgettext (state->root_argp->argp_domain,\n                                \"(PROGRAM ERROR) No version known!?\"));\n      if (! (state->flags & ARGP_NO_EXIT))\n        exit (0);\n      break;\n    default:\n      return EBADKEY;\n    }\n  return 0;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "find_long_option": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static int\nfind_long_option (struct option *long_options, const char *name)\n{\n  struct option *l = long_options;\n  while (l->name != NULL)\n    if (name != NULL && strcmp (l->name, name) == 0)\n      return l - long_options;\n    else\n      l++;\n  if (name == NULL)\n    return l - long_options;\n  else\n    return -1;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_parse": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static error_t\ngroup_parse (struct group *group, struct argp_state *state, int key, char *arg)\n{\n  if (group->parser)\n    {\n      error_t err;\n      state->hook = group->hook;\n      state->input = group->input;\n      state->child_inputs = group->child_inputs;\n      state->arg_num = group->args_processed;\n      err = (*group->parser)(key, arg, state);\n      group->hook = state->hook;\n      return err;\n    }\n  else\n    return EBADKEY;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "convert_options": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static struct group *\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)\n{\n  /* REAL is the most recent non-alias value of OPT.  */\n  const struct argp_option *real = argp->options;\n  const struct argp_child *children = argp->children;\n\n  if (real || argp->parser)\n    {\n      const struct argp_option *opt;\n\n      if (real)\n        for (opt = real; !__option_is_end (opt); opt++)\n          {\n            if (! (opt->flags & OPTION_ALIAS))\n              /* OPT isn't an alias, so we can use values from it.  */\n              real = opt;\n\n            if (! (real->flags & OPTION_DOC))\n              /* A real option (not just documentation).  */\n              {\n                if (__option_is_short (opt))\n                  /* OPT can be used as a short option.  */\n                  {\n                    *cvt->short_end++ = opt->key;\n                    if (real->arg)\n                      {\n                        *cvt->short_end++ = ':';\n                        if (real->flags & OPTION_ARG_OPTIONAL)\n                          *cvt->short_end++ = ':';\n                      }\n                    *cvt->short_end = '\\0'; /* keep 0 terminated */\n                  }\n\n                if (opt->name\n                    && find_long_option (cvt->parser->long_opts, opt->name) < 0)\n                  /* OPT can be used as a long option.  */\n                  {\n                    cvt->long_end->name = opt->name;\n                    cvt->long_end->has_arg =\n                      (real->arg\n                       ? (real->flags & OPTION_ARG_OPTIONAL\n                          ? optional_argument\n                          : required_argument)\n                       : no_argument);\n                    cvt->long_end->flag = 0;\n                    /* we add a disambiguating code to all the user's\n                       values (which is removed before we actually call\n                       the function to parse the value); this means that\n                       the user loses use of the high 8 bits in all his\n                       values (the sign of the lower bits is preserved\n                       however)...  */\n                    cvt->long_end->val =\n                      ((opt->key ? opt->key : real->key) & USER_MASK)\n                      + (((group - cvt->parser->groups) + 1) << USER_BITS);\n\n                    /* Keep the LONG_OPTS list terminated.  */\n                    (++cvt->long_end)->name = NULL;\n                  }\n              }\n            }\n\n      group->parser = argp->parser;\n      group->argp = argp;\n      group->short_end = cvt->short_end;\n      group->args_processed = 0;\n      group->parent = parent;\n      group->parent_index = parent_index;\n      group->input = 0;\n      group->hook = 0;\n      group->child_inputs = 0;\n\n      if (children)\n        /* Assign GROUP's CHILD_INPUTS field some space from\n           CVT->child_inputs_end.*/\n        {\n          unsigned num_children = 0;\n          while (children[num_children].argp)\n            num_children++;\n          group->child_inputs = cvt->child_inputs_end;\n          cvt->child_inputs_end += num_children;\n        }\n\n      parent = group++;\n    }\n  else\n    parent = 0;\n\n  if (children)\n    {\n      unsigned index = 0;\n      while (children->argp)\n        group =\n          convert_options (children++->argp, parent, index++, group, cvt);\n    }\n\n  return group;\n}",
      "lines": 100,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "struct group",
        "struct",
        "group",
        "*\nconvert_options (const struct argp *argp,\n                 struct group *parent, unsigned parent_index,\n                 struct group *group, struct parser_convert_state *cvt)",
        "*"
      ]
    },
    "parser_convert": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "static void\nparser_convert (struct parser *parser, const struct argp *argp, int flags)\n{\n  struct parser_convert_state cvt;\n\n  cvt.parser = parser;\n  cvt.short_end = parser->short_opts;\n  cvt.long_end = parser->long_opts;\n  cvt.child_inputs_end = parser->child_inputs;\n\n  if (flags & ARGP_IN_ORDER)\n    *cvt.short_end++ = '-';\n  else if (flags & ARGP_NO_ARGS)\n    *cvt.short_end++ = '+';\n  *cvt.short_end = '\\0';\n\n  cvt.long_end->name = NULL;\n\n  parser->argp = argp;\n\n  if (argp)\n    parser->egroup = convert_options (argp, 0, 0, parser->groups, &cvt);\n  else\n    parser->egroup = parser->groups; /* No parsers at all! */\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "calc_sizes": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "static void\ncalc_sizes (const struct argp *argp,  struct parser_sizes *szs)\n{\n  const struct argp_child *child = argp->children;\n  const struct argp_option *opt = argp->options;\n\n  if (opt || argp->parser)\n    {\n      szs->num_groups++;\n      if (opt)\n        {\n          int num_opts = 0;\n          while (!__option_is_end (opt++))\n            num_opts++;\n          szs->short_len += num_opts * 3; /* opt + up to 2 ':'s */\n          szs->long_len += num_opts;\n        }\n    }\n\n  if (child)\n    while (child->argp)\n      {\n        calc_sizes ((child++)->argp, szs);\n        szs->num_child_inputs++;\n      }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parser_init": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "static error_t\nparser_init (struct parser *parser, const struct argp *argp,\n             int argc, char **argv, int flags, void *input)\n{\n  error_t err = 0;\n  struct group *group;\n  struct parser_sizes szs;\n  struct _getopt_data opt_data = _GETOPT_DATA_INITIALIZER;\n  char *storage;\n  size_t glen, gsum;\n  size_t clen, csum;\n  size_t llen, lsum;\n  size_t slen, ssum;\n\n  szs.short_len = (flags & ARGP_NO_ARGS) ? 0 : 1;\n  szs.long_len = 0;\n  szs.num_groups = 0;\n  szs.num_child_inputs = 0;\n\n  if (argp)\n    calc_sizes (argp, &szs);\n\n  /* Lengths of the various bits of storage used by PARSER.  */\n  glen = (szs.num_groups + 1) * sizeof (struct group);\n  clen = szs.num_child_inputs * sizeof (void *);\n  llen = (szs.long_len + 1) * sizeof (struct option);\n  slen = szs.short_len + 1;\n\n  /* Sums of previous lengths, properly aligned.  There's no need to\n     align gsum, since struct group is aligned at least as strictly as\n     void * (since it contains a void * member).  And there's no need\n     to align lsum, since struct option is aligned at least as\n     strictly as char.  */\n  gsum = glen;\n  csum = alignto (gsum + clen, alignof (struct option));\n  lsum = csum + llen;\n  ssum = lsum + slen;\n\n  parser->storage = malloc (ssum);\n  if (! parser->storage)\n    return ENOMEM;\n\n  storage = parser->storage;\n  parser->groups = parser->storage;\n  parser->child_inputs = (void **) (storage + gsum);\n  parser->long_opts = (struct option *) (storage + csum);\n  parser->short_opts = storage + lsum;\n  parser->opt_data = opt_data;\n\n  memset (parser->child_inputs, 0, clen);\n  parser_convert (parser, argp, flags);\n\n  memset (&parser->state, 0, sizeof (struct argp_state));\n  parser->state.root_argp = parser->argp;\n  parser->state.argc = argc;\n  parser->state.argv = argv;\n  parser->state.flags = flags;\n  parser->state.err_stream = stderr;\n  parser->state.out_stream = stdout;\n  parser->state.next = 0;       /* Tell getopt to initialize.  */\n  parser->state.pstate = parser;\n\n  parser->try_getopt = 1;\n\n  /* Call each parser for the first time, giving it a chance to propagate\n     values to child parsers.  */\n  if (parser->groups < parser->egroup)\n    parser->groups->input = input;\n  for (group = parser->groups;\n       group < parser->egroup && (!err || err == EBADKEY);\n       group++)\n    {\n      if (group->parent)\n        /* If a child parser, get the initial input value from the parent. */\n        group->input = group->parent->child_inputs[group->parent_index];\n\n      if (!group->parser\n          && group->argp->children && group->argp->children->argp)\n        /* For the special case where no parsing function is supplied for an\n           argp, propagate its input to its first child, if any (this just\n           makes very simple wrapper argps more convenient).  */\n        group->child_inputs[0] = group->input;\n\n      err = group_parse (group, &parser->state, ARGP_KEY_INIT, 0);\n    }\n  if (err == EBADKEY)\n    err = 0;                    /* Some parser didn't understand.  */\n\n  if (err)\n    return err;\n\n  if (parser->state.flags & ARGP_NO_ERRS)\n    {\n      parser->opt_data.opterr = 0;\n      if (parser->state.flags & ARGP_PARSE_ARGV0)\n        /* getopt always skips ARGV[0], so we have to fake it out.  As long\n           as OPTERR is 0, then it shouldn't actually try to access it.  */\n        parser->state.argv--, parser->state.argc++;\n    }\n  else\n    parser->opt_data.opterr = 1;        /* Print error messages.  */\n\n  if (parser->state.argv == argv && argv[0])\n    /* There's an argv[0]; use it for messages.  */\n    parser->state.name = __argp_base_name (argv[0]);\n  else\n    parser->state.name = __argp_short_program_name ();\n\n  return 0;\n}",
      "lines": 110,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_finalize": {
      "start_point": [
        568,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static error_t\nparser_finalize (struct parser *parser,\n                 error_t err, int arg_ebadkey, int *end_index)\n{\n  struct group *group;\n\n  if (err == EBADKEY && arg_ebadkey)\n    /* Suppress errors generated by unparsed arguments.  */\n    err = 0;\n\n  if (! err)\n    {\n      if (parser->state.next == parser->state.argc)\n        /* We successfully parsed all arguments!  Call all the parsers again,\n           just a few more times... */\n        {\n          for (group = parser->groups;\n               group < parser->egroup && (!err || err==EBADKEY);\n               group++)\n            if (group->args_processed == 0)\n              err = group_parse (group, &parser->state, ARGP_KEY_NO_ARGS, 0);\n          for (group = parser->egroup - 1;\n               group >= parser->groups && (!err || err==EBADKEY);\n               group--)\n            err = group_parse (group, &parser->state, ARGP_KEY_END, 0);\n\n          if (err == EBADKEY)\n            err = 0;            /* Some parser didn't understand.  */\n\n          /* Tell the user that all arguments are parsed.  */\n          if (end_index)\n            *end_index = parser->state.next;\n        }\n      else if (end_index)\n        /* Return any remaining arguments to the user.  */\n        *end_index = parser->state.next;\n      else\n        /* No way to return the remaining arguments, they must be bogus. */\n        {\n          if (!(parser->state.flags & ARGP_NO_ERRS)\n              && parser->state.err_stream)\n            fprintf (parser->state.err_stream,\n                     dgettext (parser->argp->argp_domain,\n                               \"%s: Too many arguments\\n\"),\n                     parser->state.name);\n          err = EBADKEY;\n        }\n    }\n\n  /* Okay, we're all done, with either an error or success; call the parsers\n     to indicate which one.  */\n\n  if (err)\n    {\n      /* Maybe print an error message.  */\n      if (err == EBADKEY)\n        /* An appropriate message describing what the error was should have\n           been printed earlier.  */\n        __argp_state_help (&parser->state, parser->state.err_stream,\n                           ARGP_HELP_STD_ERR);\n\n      /* Since we didn't exit, give each parser an error indication.  */\n      for (group = parser->groups; group < parser->egroup; group++)\n        group_parse (group, &parser->state, ARGP_KEY_ERROR, 0);\n    }\n  else\n    /* Notify parsers of success, and propagate back values from parsers.  */\n    {\n      /* We pass over the groups in reverse order so that child groups are\n         given a chance to do there processing before passing back a value to\n         the parent.  */\n      for (group = parser->egroup - 1\n           ; group >= parser->groups && (!err || err == EBADKEY)\n           ; group--)\n        err = group_parse (group, &parser->state, ARGP_KEY_SUCCESS, 0);\n      if (err == EBADKEY)\n        err = 0;                /* Some parser didn't understand.  */\n    }\n\n  /* Call parsers once more, to do any final cleanup.  Errors are ignored.  */\n  for (group = parser->egroup - 1; group >= parser->groups; group--)\n    group_parse (group, &parser->state, ARGP_KEY_FINI, 0);\n\n  if (err == EBADKEY)\n    err = EINVAL;\n\n  free (parser->storage);\n\n  return err;\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_arg": {
      "start_point": [
        664,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "static error_t\nparser_parse_arg (struct parser *parser, char *val)\n{\n  /* Save the starting value of NEXT, first adjusting it so that the arg\n     we're parsing is again the front of the arg vector.  */\n  int index = --parser->state.next;\n  error_t err = EBADKEY;\n  struct group *group;\n  int key = 0;                  /* Which of ARGP_KEY_ARG[S] we used.  */\n\n  /* Try to parse the argument in each parser.  */\n  for (group = parser->groups\n       ; group < parser->egroup && err == EBADKEY\n       ; group++)\n    {\n      parser->state.next++;     /* For ARGP_KEY_ARG, consume the arg.  */\n      key = ARGP_KEY_ARG;\n      err = group_parse (group, &parser->state, key, val);\n\n      if (err == EBADKEY)\n        /* This parser doesn't like ARGP_KEY_ARG; try ARGP_KEY_ARGS instead. */\n        {\n          parser->state.next--; /* For ARGP_KEY_ARGS, put back the arg.  */\n          key = ARGP_KEY_ARGS;\n          err = group_parse (group, &parser->state, key, 0);\n        }\n    }\n\n  if (! err)\n    {\n      if (key == ARGP_KEY_ARGS)\n        /* The default for ARGP_KEY_ARGS is to assume that if NEXT isn't\n           changed by the user, *all* arguments should be considered\n           consumed.  */\n        parser->state.next = parser->state.argc;\n\n      if (parser->state.next > index)\n        /* Remember that we successfully processed a non-option\n           argument -- but only if the user hasn't gotten tricky and set\n           the clock back.  */\n        (--group)->args_processed += (parser->state.next - index);\n      else\n        /* The user wants to reparse some args, give getopt another try.  */\n        parser->try_getopt = 1;\n    }\n\n  return err;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_opt": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static error_t\nparser_parse_opt (struct parser *parser, int opt, char *val)\n{\n  /* The group key encoded in the high bits; 0 for short opts or\n     group_number + 1 for long opts.  */\n  int group_key = opt >> USER_BITS;\n  error_t err = EBADKEY;\n\n  if (group_key == 0)\n    /* A short option.  By comparing OPT's position in SHORT_OPTS to the\n       various starting positions in each group's SHORT_END field, we can\n       determine which group OPT came from.  */\n    {\n      struct group *group;\n      char *short_index = strchr (parser->short_opts, opt);\n\n      if (short_index)\n        for (group = parser->groups; group < parser->egroup; group++)\n          if (group->short_end > short_index)\n            {\n              err = group_parse (group, &parser->state, opt,\n                                 parser->opt_data.optarg);\n              break;\n            }\n    }\n  else\n    /* A long option.  We use shifts instead of masking for extracting\n       the user value in order to preserve the sign.  */\n    err =\n      group_parse (&parser->groups[group_key - 1], &parser->state,\n                   (opt << GROUP_BITS) >> GROUP_BITS,\n                   parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    /* At least currently, an option not recognized is an error in the\n       parser, because we pre-compute which parser is supposed to deal\n       with each option.  */\n    {\n      static const char bad_key_err[] =\n        N_(\"(PROGRAM ERROR) Option should have been recognized!?\");\n      if (group_key == 0)\n        __argp_error (&parser->state, \"-%c: %s\", opt,\n                      dgettext (parser->argp->argp_domain, bad_key_err));\n      else\n        {\n          struct option *long_opt = parser->long_opts;\n          while (long_opt->val != opt && long_opt->name)\n            long_opt++;\n          __argp_error (&parser->state, \"--%s: %s\",\n                        long_opt->name ? long_opt->name : \"???\",\n                        dgettext (parser->argp->argp_domain, bad_key_err));\n        }\n    }\n\n  return err;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "parser_parse_next": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "static error_t\nparser_parse_next (struct parser *parser, int *arg_ebadkey)\n{\n  int opt;\n  error_t err = 0;\n\n  if (parser->state.quoted && parser->state.next < parser->state.quoted)\n    /* The next argument pointer has been moved to before the quoted\n       region, so pretend we never saw the quoting \"--\", and give getopt\n       another chance.  If the user hasn't removed it, getopt will just\n       process it again.  */\n    parser->state.quoted = 0;\n\n  if (parser->try_getopt && !parser->state.quoted)\n    /* Give getopt a chance to parse this.  */\n    {\n      /* Put it back in OPTIND for getopt.  */\n      parser->opt_data.optind = parser->state.next;\n      /* Distinguish KEY_ERR from a real option.  */\n      parser->opt_data.optopt = KEY_END;\n      if (parser->state.flags & ARGP_LONG_ONLY)\n        opt = _getopt_long_only_r (parser->state.argc, parser->state.argv,\n                                   parser->short_opts, parser->long_opts, 0,\n                                   &parser->opt_data);\n      else\n        opt = _getopt_long_r (parser->state.argc, parser->state.argv,\n                              parser->short_opts, parser->long_opts, 0,\n                              &parser->opt_data);\n      /* And see what getopt did.  */\n      parser->state.next = parser->opt_data.optind;\n\n      if (opt == KEY_END)\n        /* Getopt says there are no more options, so stop using\n           getopt; we'll continue if necessary on our own.  */\n        {\n          parser->try_getopt = 0;\n          if (parser->state.next > 1\n              && strcmp (parser->state.argv[parser->state.next - 1], QUOTE)\n                   == 0)\n            /* Not only is this the end of the options, but it's a\n               \"quoted\" region, which may have args that *look* like\n               options, so we definitely shouldn't try to use getopt past\n               here, whatever happens.  */\n            parser->state.quoted = parser->state.next;\n        }\n      else if (opt == KEY_ERR && parser->opt_data.optopt != KEY_END)\n        /* KEY_ERR can have the same value as a valid user short\n           option, but in the case of a real error, getopt sets OPTOPT\n           to the offending character, which can never be KEY_END.  */\n        {\n          *arg_ebadkey = 0;\n          return EBADKEY;\n        }\n    }\n  else\n    opt = KEY_END;\n\n  if (opt == KEY_END)\n    {\n      /* We're past what getopt considers the options.  */\n      if (parser->state.next >= parser->state.argc\n          || (parser->state.flags & ARGP_NO_ARGS))\n        /* Indicate that we're done.  */\n        {\n          *arg_ebadkey = 1;\n          return EBADKEY;\n        }\n      else\n        /* A non-option arg; simulate what getopt might have done.  */\n        {\n          opt = KEY_ARG;\n          parser->opt_data.optarg = parser->state.argv[parser->state.next++];\n        }\n    }\n\n  if (opt == KEY_ARG)\n    /* A non-option argument; try each parser in turn.  */\n    err = parser_parse_arg (parser, parser->opt_data.optarg);\n  else\n    err = parser_parse_opt (parser, opt, parser->opt_data.optarg);\n\n  if (err == EBADKEY)\n    *arg_ebadkey = (opt == KEY_END || opt == KEY_ARG);\n\n  return err;\n}",
      "lines": 86,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "__argp_parse": {
      "start_point": [
        868,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "error_t\n__argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,\n              int *end_index, void *input)\n{\n  error_t err;\n  struct parser parser;\n\n  /* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */\n  int arg_ebadkey = 0;\n\n#ifndef _LIBC\n  if (!(flags & ARGP_PARSE_ARGV0))\n    {\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n      if (!program_invocation_name)\n        program_invocation_name = argv[0];\n#endif\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n      if (!program_invocation_short_name)\n        program_invocation_short_name = __argp_base_name (argv[0]);\n#endif\n    }\n#endif\n\n  if (! (flags & ARGP_NO_HELP))\n    /* Add our own options.  */\n    {\n      struct argp_child *child = alloca (4 * sizeof (struct argp_child));\n      struct argp *top_argp = alloca (sizeof (struct argp));\n\n      /* TOP_ARGP has no options, it just serves to group the user & default\n         argps.  */\n      memset (top_argp, 0, sizeof (*top_argp));\n      top_argp->children = child;\n\n      memset (child, 0, 4 * sizeof (struct argp_child));\n\n      if (argp)\n        (child++)->argp = argp;\n      (child++)->argp = &argp_default_argp;\n      if (argp_program_version || argp_program_version_hook)\n        (child++)->argp = &argp_version_argp;\n      child->argp = 0;\n\n      argp = top_argp;\n    }\n\n  /* Construct a parser for these arguments.  */\n  err = parser_init (&parser, argp, argc, argv, flags, input);\n\n  if (! err)\n    /* Parse! */\n    {\n      while (! err)\n        err = parser_parse_next (&parser, &arg_ebadkey);\n      err = parser_finalize (&parser, err, arg_ebadkey, end_index);\n    }\n\n  return err;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "error_t"
      ]
    },
    "__argp_input": {
      "start_point": [
        935,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "void *\n__argp_input (const struct argp *argp, const struct argp_state *state)\n{\n  if (state)\n    {\n      struct group *group;\n      struct parser *parser = state->pstate;\n\n      for (group = parser->groups; group < parser->egroup; group++)\n        if (group->argp == argp)\n          return group->input;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*\n__argp_input (const struct argp *argp, const struct argp_state *state)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-pin.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-pv.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-pvh.c": {},
  "inetutils/inetutils-1.9.4/lib/argp-version-etc.c": {
    "version_etc_hook": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\nversion_etc_hook (FILE *stream, struct argp_state *state)\n{\n  version_etc_ar (stream, program_canonical_name, PACKAGE_NAME, VERSION,\n                  program_authors);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "argp_version_setup": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\nargp_version_setup (const char *name, const char * const *authors)\n{\n  argp_program_version_hook = version_etc_hook;\n  program_canonical_name = name;\n  program_authors = authors;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/argp-version-etc.h": {},
  "inetutils/inetutils-1.9.4/lib/argp-xinl.c": {},
  "inetutils/inetutils-1.9.4/lib/argp.h": {
    "__argp_usage": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "ARGP_EI void\n__argp_usage (const struct argp_state *__state)\n{\n  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ARGP_EI",
        "void",
        "void"
      ]
    },
    "__NTH": [
      {
        "start_point": [
          621,
          0
        ],
        "end_point": [
          631,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_short (const struct argp_option *__opt))\n{\n  if (__opt->flags & OPTION_DOC)\n    return 0;\n  else\n    {\n      int __key = __opt->key;\n      return __key > 0 && __key <= UCHAR_MAX && isprint (__key);\n    }\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      },
      {
        "start_point": [
          633,
          0
        ],
        "end_point": [
          637,
          1
        ],
        "content": "ARGP_EI int\n__NTH (__option_is_end (const struct argp_option *__opt))\n{\n  return !__opt->key && !__opt->name && !__opt->doc && !__opt->group;\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "ARGP_EI",
          "int",
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/arpa_inet.in.h": {},
  "inetutils/inetutils-1.9.4/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/assure.h": {},
  "inetutils/inetutils-1.9.4/lib/at-func.c": {
    "AT_FUNC_NAME": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "FUNC_RESULT\nAT_FUNC_NAME (int fd, char const *file AT_FUNC_POST_FILE_PARAM_DECLS)\n{\n  VALIDATE_FLAG (flag);\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return CALL_FUNC (file);\n\n#ifdef GNULIB_SUPPORT_ONLY_AT_FDCWD\n  errno = ENOTSUP;\n  return FUNC_FAIL;\n#else\n  {\n  /* Be careful to choose names unlikely to conflict with\n     AT_FUNC_POST_FILE_PARAM_DECLS.  */\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  FUNC_RESULT err;\n\n  {\n    char proc_buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (proc_buf, fd, file);\n    if (proc_file)\n      {\n        FUNC_RESULT proc_result = CALL_FUNC (proc_file);\n        int proc_errno = errno;\n        if (proc_file != proc_buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (FUNC_FAIL != proc_result)\n          return proc_result;\n        if (! EXPECTED_ERRNO (proc_errno))\n          {\n            errno = proc_errno;\n            return proc_result;\n          }\n      }\n  }\n\n  if (save_cwd (&saved_cwd) != 0)\n    openat_save_fail (errno);\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return FUNC_FAIL;\n    }\n\n  if (fchdir (fd) != 0)\n    {\n      saved_errno = errno;\n      free_cwd (&saved_cwd);\n      errno = saved_errno;\n      return FUNC_FAIL;\n    }\n\n  err = CALL_FUNC (file);\n  saved_errno = (err == FUNC_FAIL ? errno : 0);\n\n  if (restore_cwd (&saved_cwd) != 0)\n    openat_restore_fail (errno);\n\n  free_cwd (&saved_cwd);\n\n  if (saved_errno)\n    errno = saved_errno;\n  return err;\n  }\n#endif\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "FUNC_RESULT"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/chdir-long.c": {
    "cdb_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static void\ncdb_init (struct cd_buf *cdb)\n{\n  cdb->fd = AT_FDCWD;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_fchdir": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int\ncdb_fchdir (struct cd_buf const *cdb)\n{\n  return fchdir (cdb->fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cdb_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ncdb_free (struct cd_buf const *cdb)\n{\n  if (0 <= cdb->fd)\n    {\n      bool close_fail = close (cdb->fd);\n      assure (! close_fail);\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cdb_advance_fd": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncdb_advance_fd (struct cd_buf *cdb, char const *dir)\n{\n  int new_fd = openat (cdb->fd, dir,\n                       O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n  if (new_fd < 0)\n    return -1;\n\n  cdb_free (cdb);\n  cdb->fd = new_fd;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_non_slash": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static char * _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)\n{\n  size_t n_slash = strspn (s, \"/\");\n  return (char *) s + n_slash;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "* _GL_ATTRIBUTE_PURE\nfind_non_slash (char const *s)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "chdir_long": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nchdir_long (char *dir)\n{\n  int e = chdir (dir);\n  if (e == 0 || errno != ENAMETOOLONG)\n    return e;\n\n  {\n    size_t len = strlen (dir);\n    char *dir_end = dir + len;\n    struct cd_buf cdb;\n    size_t n_leading_slash;\n\n    cdb_init (&cdb);\n\n    /* If DIR is the empty string, then the chdir above\n       must have failed and set errno to ENOENT.  */\n    assure (0 < len);\n    assure (PATH_MAX <= len);\n\n    /* Count leading slashes.  */\n    n_leading_slash = strspn (dir, \"/\");\n\n    /* Handle any leading slashes as well as any name that matches\n       the regular expression, m!^//hostname[/]*! .  Handling this\n       prefix separately usually results in a single additional\n       cdb_advance_fd call, but it's worthwhile, since it makes the\n       code in the following loop cleaner.  */\n    if (n_leading_slash == 2)\n      {\n        int err;\n        /* Find next slash.\n           We already know that dir[2] is neither a slash nor '\\0'.  */\n        char *slash = memchr (dir + 3, '/', dir_end - (dir + 3));\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n        *slash = '\\0';\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n        dir = find_non_slash (slash + 1);\n      }\n    else if (n_leading_slash)\n      {\n        if (cdb_advance_fd (&cdb, \"/\") != 0)\n          goto Fail;\n        dir += n_leading_slash;\n      }\n\n    assure (*dir != '/');\n    assure (dir <= dir_end);\n\n    while (PATH_MAX <= dir_end - dir)\n      {\n        int err;\n        /* Find a slash that is PATH_MAX or fewer bytes away from dir.\n           I.e. see if there is a slash that will give us a name of\n           length PATH_MAX-1 or less.  */\n        char *slash = memrchr (dir, '/', PATH_MAX);\n        if (slash == NULL)\n          {\n            errno = ENAMETOOLONG;\n            return -1;\n          }\n\n        *slash = '\\0';\n        assure (slash - dir < PATH_MAX);\n        err = cdb_advance_fd (&cdb, dir);\n        *slash = '/';\n        if (err != 0)\n          goto Fail;\n\n        dir = find_non_slash (slash + 1);\n      }\n\n    if (dir < dir_end)\n      {\n        if (cdb_advance_fd (&cdb, dir) != 0)\n          goto Fail;\n      }\n\n    if (cdb_fchdir (&cdb) != 0)\n      goto Fail;\n\n    cdb_free (&cdb);\n    return 0;\n\n   Fail:\n    {\n      int saved_errno = errno;\n      cdb_free (&cdb);\n      errno = saved_errno;\n      return -1;\n    }\n  }\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char *line = NULL;\n  size_t n = 0;\n  int len;\n\n  program_name = argv[0];\n  atexit (close_stdout);\n\n  len = getline (&line, &n, stdin);\n  if (len < 0)\n    {\n      int saved_errno = errno;\n      if (feof (stdin))\n        exit (0);\n\n      error (EXIT_FAILURE, saved_errno,\n             \"reading standard input\");\n    }\n  else if (len == 0)\n    exit (0);\n\n  if (line[len-1] == '\\n')\n    line[len-1] = '\\0';\n\n  if (chdir_long (line) != 0)\n    error (EXIT_FAILURE, errno,\n           \"chdir_long failed: %s\", line);\n\n  if (argc <= 1)\n    {\n      /* Using 'pwd' here makes sense only if it is a robust implementation,\n         like the one in coreutils after the 2004-04-19 changes.  */\n      char const *cmd = \"pwd\";\n      execlp (cmd, (char *) NULL);\n      error (EXIT_FAILURE, errno, \"%s\", cmd);\n    }\n\n  fclose (stdin);\n  fclose (stderr);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/chdir-long.h": {},
  "inetutils/inetutils-1.9.4/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/cloexec.h": {},
  "inetutils/inetutils-1.9.4/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/closedir.c": {
    "closedir": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nclosedir (DIR *dirp)\n{\n# if REPLACE_FCHDIR\n  int fd = dirfd (dirp);\n# endif\n  int retval;\n\n#if HAVE_CLOSEDIR\n# undef closedir\n\n  retval = closedir (dirp);\n\n#else\n\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n  free (dirp);\n\n  retval = 0;\n\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/dirent-private.h": {},
  "inetutils/inetutils-1.9.4/lib/dirent.in.h": {
    "dirfd": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        164,
        58
      ],
      "content": "static inline int (dirfd) (DIR *dp) { return dirfd (dp); }",
      "lines": 1,
      "depth": 6,
      "decorators": null
    }
  },
  "inetutils/inetutils-1.9.4/lib/dirfd.c": {
    "dirfd": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "int\ndirfd (DIR *dir_p)\n{\n  int fd = DIR_TO_FD (dir_p);\n  if (fd == -1)\n    errno = ENOTSUP;\n  return fd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/dirname.h": {},
  "inetutils/inetutils-1.9.4/lib/dosname.h": {},
  "inetutils/inetutils-1.9.4/lib/dup-safer.c": {
    "dup_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\ndup_safer (int fd)\n{\n  return fcntl (fd, F_DUPFD, STDERR_FILENO + 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/dup.c": {
    "dup_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\ndup_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = dup (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrpl_dup (int fd)\n{\n  int result = dup_nothrow (fd);\n#if REPLACE_FCHDIR\n  if (result >= 0)\n    result = _gl_register_dup (fd, result);\n#endif\n  return result;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/errno.in.h": {},
  "inetutils/inetutils-1.9.4/lib/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/error.h": {},
  "inetutils/inetutils-1.9.4/lib/exitfail.c": {},
  "inetutils/inetutils-1.9.4/lib/exitfail.h": {},
  "inetutils/inetutils-1.9.4/lib/fchdir.c": {
    "ensure_dirs_slot": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static bool\nensure_dirs_slot (size_t fd)\n{\n  if (fd < dirs_allocated)\n    free (dirs[fd].name);\n  else\n    {\n      size_t new_allocated;\n      dir_info_t *new_dirs;\n\n      new_allocated = 2 * dirs_allocated + 1;\n      if (new_allocated <= fd)\n        new_allocated = fd + 1;\n      new_dirs =\n        (dirs != NULL\n         ? (dir_info_t *) realloc (dirs, new_allocated * sizeof *dirs)\n         : (dir_info_t *) malloc (new_allocated * sizeof *dirs));\n      if (new_dirs == NULL)\n        return false;\n      memset (new_dirs + dirs_allocated, 0,\n              (new_allocated - dirs_allocated) * sizeof *dirs);\n      dirs = new_dirs;\n      dirs_allocated = new_allocated;\n    }\n  return true;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_name": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static char *\nget_name (char const *dir)\n{\n  char *cwd;\n  char *result;\n  int saved_errno;\n\n  if (IS_ABSOLUTE_FILE_NAME (dir))\n    return strdup (dir);\n\n  /* We often encounter \".\"; treat it as a special case.  */\n  cwd = getcwd (NULL, 0);\n  if (!cwd || (dir[0] == '.' && dir[1] == '\\0'))\n    return cwd;\n\n  result = mfile_name_concat (cwd, dir, NULL);\n  saved_errno = errno;\n  free (cwd);\n  errno = saved_errno;\n  return result;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_name (char const *dir)",
        "*"
      ]
    },
    "_gl_unregister_fd": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\n_gl_unregister_fd (int fd)\n{\n  if (fd >= 0 && fd < dirs_allocated)\n    {\n      free (dirs[fd].name);\n      dirs[fd].name = NULL;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "_gl_register_fd": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_gl_register_fd (int fd, const char *filename)\n{\n  struct stat statbuf;\n\n  assure (0 <= fd);\n  if (REPLACE_OPEN_DIRECTORY\n      || (fstat (fd, &statbuf) == 0 && S_ISDIR (statbuf.st_mode)))\n    {\n      if (!ensure_dirs_slot (fd)\n          || (dirs[fd].name = get_name (filename)) == NULL)\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  return fd;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "_gl_register_dup": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int\n_gl_register_dup (int oldfd, int newfd)\n{\n  assure (0 <= oldfd && 0 <= newfd && oldfd != newfd);\n  if (oldfd < dirs_allocated && dirs[oldfd].name)\n    {\n      /* Duplicated a directory; must ensure newfd is allocated.  */\n      if (!ensure_dirs_slot (newfd)\n          || (dirs[newfd].name = strdup (dirs[oldfd].name)) == NULL)\n        {\n          int saved_errno = errno;\n          close (newfd);\n          errno = saved_errno;\n          newfd = -1;\n        }\n    }\n  else if (newfd < dirs_allocated)\n    {\n      /* Duplicated a non-directory; ensure newfd is cleared.  */\n      free (dirs[newfd].name);\n      dirs[newfd].name = NULL;\n    }\n  return newfd;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "_gl_directory_name": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *\n_gl_directory_name (int fd)\n{\n  if (0 <= fd && fd < dirs_allocated && dirs[fd].name != NULL)\n    return dirs[fd].name;\n  /* At this point, fd is either invalid, or open but not a directory.\n     If dup2 fails, errno is correctly EBADF.  */\n  if (0 <= fd)\n    {\n      if (dup2 (fd, fd) == fd)\n        errno = ENOTDIR;\n    }\n  else\n    errno = EBADF;\n  return NULL;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\n_gl_directory_name (int fd)",
        "*"
      ]
    },
    "fchdir": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\nfchdir (int fd)\n{\n  const char *name = _gl_directory_name (fd);\n  return name ? chdir (name) : -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          switch (GetLastError ())\n            {\n              case ERROR_TOO_MANY_OPEN_FILES:\n                errno = EMFILE;\n                break;\n              case ERROR_INVALID_HANDLE:\n              case ERROR_INVALID_TARGET_HANDLE:\n              case ERROR_DIRECT_ACCESS_HANDLE:\n                errno = EBADF;\n                break;\n              case ERROR_INVALID_PARAMETER:\n              case ERROR_INVALID_FUNCTION:\n              case ERROR_INVALID_ACCESS:\n                errno = EINVAL;\n                break;\n              default:\n                errno = EACCES;\n                break;\n            }\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 114,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fcntl.in.h": {},
  "inetutils/inetutils-1.9.4/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fd-hook.h": {},
  "inetutils/inetutils-1.9.4/lib/fd-safer.c": {
    "fd_safer": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nfd_safer (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      int f = dup_safer (fd);\n      int e = errno;\n      close (fd);\n      errno = e;\n      fd = f;\n    }\n\n  return fd;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fdopendir.c": {
    "fdopendir": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "DIR *\nfdopendir (int fd)\n{\n  DIR *dir = fdopendir_with_dup (fd, -1, NULL);\n\n  if (! REPLACE_FCHDIR && ! dir)\n    {\n      int saved_errno = errno;\n      if (EXPECTED_ERRNO (saved_errno))\n        {\n          struct saved_cwd cwd;\n          if (save_cwd (&cwd) != 0)\n            openat_save_fail (errno);\n          dir = fdopendir_with_dup (fd, -1, &cwd);\n          saved_errno = errno;\n          free_cwd (&cwd);\n          errno = saved_errno;\n        }\n    }\n\n  return dir;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "DIR",
        "*\nfdopendir (int fd)",
        "*"
      ]
    },
    "fdopendir_with_dup": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "static DIR *\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)\n{\n  int dupfd = dup (fd);\n  if (dupfd < 0 && errno == EMFILE)\n    dupfd = older_dupfd;\n  if (dupfd < 0)\n    return NULL;\n  else\n    {\n      DIR *dir;\n      int saved_errno;\n      if (dupfd < fd - 1 && dupfd != older_dupfd)\n        {\n          dir = fdopendir_with_dup (fd, dupfd, cwd);\n          saved_errno = errno;\n        }\n      else\n        {\n          close (fd);\n          dir = fd_clone_opendir (dupfd, cwd);\n          saved_errno = errno;\n          if (! dir)\n            {\n              int fd1 = dup (dupfd);\n              if (fd1 != fd)\n                openat_save_fail (fd1 < 0 ? errno : EBADF);\n            }\n        }\n\n      if (dupfd != older_dupfd)\n        close (dupfd);\n      errno = saved_errno;\n      return dir;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfdopendir_with_dup (int fd, int older_dupfd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "fd_clone_opendir": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static DIR *\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)\n{\n  if (REPLACE_FCHDIR || ! cwd)\n    {\n      DIR *dir = NULL;\n      int saved_errno = EOPNOTSUPP;\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          dir = opendir (proc_file);\n          saved_errno = errno;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n# if REPLACE_FCHDIR\n      if (! dir && EXPECTED_ERRNO (saved_errno))\n        {\n          char const *name = _gl_directory_name (fd);\n          DIR *dp = name ? opendir (name) : NULL;\n\n          /* The caller has done an elaborate dance to arrange for opendir to\n             consume just the right file descriptor.  If dirfd returns -1,\n             though, we're on a system like mingw where opendir does not\n             consume a file descriptor.  Consume it via 'dup' instead.  */\n          if (dp && dirfd (dp) < 0)\n            dup (fd);\n\n          return dp;\n        }\n# endif\n      errno = saved_errno;\n      return dir;\n    }\n  else\n    {\n      if (fchdir (fd) != 0)\n        return NULL;\n      else\n        {\n          DIR *dir = opendir (\".\");\n          int saved_errno = errno;\n          if (restore_cwd (cwd) != 0)\n            openat_restore_fail (errno);\n          errno = saved_errno;\n          return dir;\n        }\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "DIR",
        "*\nfd_clone_opendir (int fd, struct saved_cwd const *cwd)",
        "*"
      ]
    },
    "rpl_fdopendir": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "DIR *\nrpl_fdopendir (int fd)\n{\n  struct stat st;\n  if (fstat (fd, &st))\n    return NULL;\n  if (!S_ISDIR (st.st_mode))\n    {\n      errno = ENOTDIR;\n      return NULL;\n    }\n  return fdopendir (fd);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "DIR",
        "*\nrpl_fdopendir (int fd)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/filemode.c": {
    "ftypelet": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static char\nftypelet (mode_t bits)\n{\n  /* These are the most common, so test for them first.  */\n  if (S_ISREG (bits))\n    return '-';\n  if (S_ISDIR (bits))\n    return 'd';\n\n  /* Other letters standardized by POSIX 1003.1-2004.  */\n  if (S_ISBLK (bits))\n    return 'b';\n  if (S_ISCHR (bits))\n    return 'c';\n  if (S_ISLNK (bits))\n    return 'l';\n  if (S_ISFIFO (bits))\n    return 'p';\n\n  /* Other file types (though not letters) standardized by POSIX.  */\n  if (S_ISSOCK (bits))\n    return 's';\n\n  /* Nonstandard file types.  */\n  if (S_ISCTG (bits))\n    return 'C';\n  if (S_ISDOOR (bits))\n    return 'D';\n  if (S_ISMPB (bits) || S_ISMPC (bits) || S_ISMPX (bits))\n    return 'm';\n  if (S_ISNWK (bits))\n    return 'n';\n  if (S_ISPORT (bits))\n    return 'P';\n  if (S_ISWHT (bits))\n    return 'w';\n\n  return '?';\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "strmode": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nstrmode (mode_t mode, char *str)\n{\n  str[0] = ftypelet (mode);\n  str[1] = mode & S_IRUSR ? 'r' : '-';\n  str[2] = mode & S_IWUSR ? 'w' : '-';\n  str[3] = (mode & S_ISUID\n            ? (mode & S_IXUSR ? 's' : 'S')\n            : (mode & S_IXUSR ? 'x' : '-'));\n  str[4] = mode & S_IRGRP ? 'r' : '-';\n  str[5] = mode & S_IWGRP ? 'w' : '-';\n  str[6] = (mode & S_ISGID\n            ? (mode & S_IXGRP ? 's' : 'S')\n            : (mode & S_IXGRP ? 'x' : '-'));\n  str[7] = mode & S_IROTH ? 'r' : '-';\n  str[8] = mode & S_IWOTH ? 'w' : '-';\n  str[9] = (mode & S_ISVTX\n            ? (mode & S_IXOTH ? 't' : 'T')\n            : (mode & S_IXOTH ? 'x' : '-'));\n  str[10] = ' ';\n  str[11] = '\\0';\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "filemodestring": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nfilemodestring (struct stat const *statp, char *str)\n{\n  strmode (statp->st_mode, str);\n\n  if (S_TYPEISSEM (statp))\n    str[0] = 'F';\n  else if (IS_MIGRATED_FILE (statp))\n    str[0] = 'M';\n  else if (S_TYPEISMQ (statp))\n    str[0] = 'Q';\n  else if (S_TYPEISSHM (statp))\n    str[0] = 'S';\n  else if (S_TYPEISTMO (statp))\n    str[0] = 'T';\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/filemode.h": {},
  "inetutils/inetutils-1.9.4/lib/filename.h": {},
  "inetutils/inetutils-1.9.4/lib/filenamecat-lgpl.c": {
    "longest_relative_suffix": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static char const * _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)\n{\n  for (f += FILE_SYSTEM_PREFIX_LEN (f); ISSLASH (*f); f++)\n    continue;\n  return f;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlongest_relative_suffix (char const *f)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "mfile_name_concat": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "char *\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)\n{\n  char const *dirbase = last_component (dir);\n  size_t dirbaselen = base_len (dirbase);\n  size_t dirlen = dirbase - dir + dirbaselen;\n  size_t needs_separator = (dirbaselen && ! ISSLASH (dirbase[dirbaselen - 1]));\n\n  char const *base = longest_relative_suffix (abase);\n  size_t baselen = strlen (base);\n\n  char *p_concat = malloc (dirlen + needs_separator + baselen + 1);\n  char *p;\n\n  if (p_concat == NULL)\n    return NULL;\n\n  p = mempcpy (p_concat, dir, dirlen);\n  *p = DIRECTORY_SEPARATOR;\n  p += needs_separator;\n\n  if (base_in_result)\n    *base_in_result = p - IS_ABSOLUTE_FILE_NAME (abase);\n\n  p = mempcpy (p, base, baselen);\n  *p = '\\0';\n\n  return p_concat;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\nmfile_name_concat (char const *dir, char const *abase, char **base_in_result)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/filenamecat.h": {},
  "inetutils/inetutils-1.9.4/lib/float+.h": {},
  "inetutils/inetutils-1.9.4/lib/float.c": {},
  "inetutils/inetutils-1.9.4/lib/float.in.h": {},
  "inetutils/inetutils-1.9.4/lib/fnmatch.c": {
    "is_char_class": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static wctype_t\nis_char_class (const wchar_t *wcs)\n{\n  char s[CHAR_CLASS_MAX_LENGTH + 1];\n  char *cp = s;\n\n  do\n    {\n      /* Test for a printable character from the portable character set.  */\n#  ifdef _LIBC\n      if (*wcs < 0x20 || *wcs > 0x7e\n          || *wcs == 0x24 || *wcs == 0x40 || *wcs == 0x60)\n        return (wctype_t) 0;\n#  else\n      switch (*wcs)\n        {\n        case L' ': case L'!': case L'\"': case L'#': case L'%':\n        case L'&': case L'\\'': case L'(': case L')': case L'*':\n        case L'+': case L',': case L'-': case L'.': case L'/':\n        case L'0': case L'1': case L'2': case L'3': case L'4':\n        case L'5': case L'6': case L'7': case L'8': case L'9':\n        case L':': case L';': case L'<': case L'=': case L'>':\n        case L'?':\n        case L'A': case L'B': case L'C': case L'D': case L'E':\n        case L'F': case L'G': case L'H': case L'I': case L'J':\n        case L'K': case L'L': case L'M': case L'N': case L'O':\n        case L'P': case L'Q': case L'R': case L'S': case L'T':\n        case L'U': case L'V': case L'W': case L'X': case L'Y':\n        case L'Z':\n        case L'[': case L'\\\\': case L']': case L'^': case L'_':\n        case L'a': case L'b': case L'c': case L'd': case L'e':\n        case L'f': case L'g': case L'h': case L'i': case L'j':\n        case L'k': case L'l': case L'm': case L'n': case L'o':\n        case L'p': case L'q': case L'r': case L's': case L't':\n        case L'u': case L'v': case L'w': case L'x': case L'y':\n        case L'z': case L'{': case L'|': case L'}': case L'~':\n          break;\n        default:\n          return (wctype_t) 0;\n        }\n#  endif\n\n      /* Avoid overrunning the buffer.  */\n      if (cp == s + CHAR_CLASS_MAX_LENGTH)\n        return (wctype_t) 0;\n\n      *cp++ = (char) *wcs++;\n    }\n  while (*wcs != L'\\0');\n\n  *cp = '\\0';\n\n#  ifdef _LIBC\n  return __wctype (s);\n#  else\n  return wctype (s);\n#  endif\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "wctype_t"
      ]
    },
    "fnmatch": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n# if HANDLE_MULTIBYTE\n#  define ALLOCA_LIMIT 2000\n  if (__builtin_expect (MB_CUR_MAX, 1) != 1)\n    {\n      mbstate_t ps;\n      size_t patsize;\n      size_t strsize;\n      size_t totsize;\n      wchar_t *wpattern;\n      wchar_t *wstring;\n      int res;\n\n      /* Calculate the size needed to convert the strings to\n         wide characters.  */\n      memset (&ps, '\\0', sizeof (ps));\n      patsize = mbsrtowcs (NULL, &pattern, 0, &ps) + 1;\n      if (__builtin_expect (patsize != 0, 1))\n        {\n          assert (mbsinit (&ps));\n          strsize = mbsrtowcs (NULL, &string, 0, &ps) + 1;\n          if (__builtin_expect (strsize != 0, 1))\n            {\n              assert (mbsinit (&ps));\n              totsize = patsize + strsize;\n              if (__builtin_expect (! (patsize <= totsize\n                                       && totsize <= SIZE_MAX / sizeof (wchar_t)),\n                                    0))\n                {\n                  errno = ENOMEM;\n                  return -1;\n                }\n\n              /* Allocate room for the wide characters.  */\n              if (__builtin_expect (totsize < ALLOCA_LIMIT, 1))\n                wpattern = (wchar_t *) alloca (totsize * sizeof (wchar_t));\n              else\n                {\n                  wpattern = malloc (totsize * sizeof (wchar_t));\n                  if (__builtin_expect (! wpattern, 0))\n                    {\n                      errno = ENOMEM;\n                      return -1;\n                    }\n                }\n              wstring = wpattern + patsize;\n\n              /* Convert the strings into wide characters.  */\n              mbsrtowcs (wpattern, &pattern, patsize, &ps);\n              assert (mbsinit (&ps));\n              mbsrtowcs (wstring, &string, strsize, &ps);\n\n              res = internal_fnwmatch (wpattern, wstring, wstring + strsize - 1,\n                                       flags & FNM_PERIOD, flags);\n\n              if (__builtin_expect (! (totsize < ALLOCA_LIMIT), 0))\n                free (wpattern);\n              return res;\n            }\n        }\n    }\n\n# endif /* HANDLE_MULTIBYTE */\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags);\n}",
      "lines": 69,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fnmatch.in.h": {},
  "inetutils/inetutils-1.9.4/lib/fnmatch_loop.c": {
    "internal_function": [
      {
        "start_point": [
          23,
          0
        ],
        "end_point": [
          981,
          1
        ],
        "content": "static int\ninternal_function\nFCT (const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  register const CHAR *p = pattern, *n = string;\n  register UCHAR c;\n#ifdef _LIBC\n# if WIDE_CHAR_VERSION\n  const char *collseq = (const char *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n# else\n  const UCHAR *collseq = (const UCHAR *)\n    _NL_CURRENT(LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n# endif\n#endif\n\n  while ((c = *p++) != L_('\\0'))\n    {\n      bool new_no_leading_period = false;\n      c = FOLD (c);\n\n      switch (c)\n        {\n        case L_('?'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n == string_end)\n            return FNM_NOMATCH;\n          else if (*n == L_('/') && (flags & FNM_FILE_NAME))\n            return FNM_NOMATCH;\n          else if (*n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('\\\\'):\n          if (!(flags & FNM_NOESCAPE))\n            {\n              c = *p++;\n              if (c == L_('\\0'))\n                /* Trailing \\ loses.  */\n                return FNM_NOMATCH;\n              c = FOLD (c);\n            }\n          if (n == string_end || FOLD ((UCHAR) *n) != c)\n            return FNM_NOMATCH;\n          break;\n\n        case L_('*'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period,\n                         flags);\n              if (res != -1)\n                return res;\n            }\n\n          if (n != string_end && *n == L_('.') && no_leading_period)\n            return FNM_NOMATCH;\n\n          for (c = *p++; c == L_('?') || c == L_('*'); c = *p++)\n            {\n              if (*p == L_('(') && (flags & FNM_EXTMATCH) != 0)\n                {\n                  const CHAR *endp = END (p);\n                  if (endp != p)\n                    {\n                      /* This is a pattern.  Skip over it.  */\n                      p = endp;\n                      continue;\n                    }\n                }\n\n              if (c == L_('?'))\n                {\n                  /* A ? needs to match one character.  */\n                  if (n == string_end)\n                    /* There isn't another character; no match.  */\n                    return FNM_NOMATCH;\n                  else if (*n == L_('/')\n                           && __builtin_expect (flags & FNM_FILE_NAME, 0))\n                    /* A slash does not match a wildcard under\n                       FNM_FILE_NAME.  */\n                    return FNM_NOMATCH;\n                  else\n                    /* One character of the string is consumed in matching\n                       this ? wildcard, so *??? won't match if there are\n                       less than three characters.  */\n                    ++n;\n                }\n            }\n\n          if (c == L_('\\0'))\n            /* The wildcard(s) is/are the last element of the pattern.\n               If the name is a file name and contains another slash\n               this means it cannot match, unless the FNM_LEADING_DIR\n               flag is set.  */\n            {\n              int result = (flags & FNM_FILE_NAME) == 0 ? 0 : FNM_NOMATCH;\n\n              if (flags & FNM_FILE_NAME)\n                {\n                  if (flags & FNM_LEADING_DIR)\n                    result = 0;\n                  else\n                    {\n                      if (MEMCHR (n, L_('/'), string_end - n) == NULL)\n                        result = 0;\n                    }\n                }\n\n              return result;\n            }\n          else\n            {\n              const CHAR *endp;\n\n              endp = MEMCHR (n, (flags & FNM_FILE_NAME) ? L_('/') : L_('\\0'),\n                             string_end - n);\n              if (endp == NULL)\n                endp = string_end;\n\n              if (c == L_('[')\n                  || (__builtin_expect (flags & FNM_EXTMATCH, 0) != 0\n                      && (c == L_('@') || c == L_('+') || c == L_('!'))\n                      && *p == L_('(')))\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  bool no_leading_period2 = no_leading_period;\n\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FCT (p, n, string_end, no_leading_period2, flags2)\n                        == 0)\n                      return 0;\n                }\n              else if (c == L_('/') && (flags & FNM_FILE_NAME))\n                {\n                  while (n < string_end && *n != L_('/'))\n                    ++n;\n                  if (n < string_end && *n == L_('/')\n                      && (FCT (p, n + 1, string_end, flags & FNM_PERIOD, flags)\n                          == 0))\n                    return 0;\n                }\n              else\n                {\n                  int flags2 = ((flags & FNM_FILE_NAME)\n                                ? flags : (flags & ~FNM_PERIOD));\n                  int no_leading_period2 = no_leading_period;\n\n                  if (c == L_('\\\\') && !(flags & FNM_NOESCAPE))\n                    c = *p;\n                  c = FOLD (c);\n                  for (--p; n < endp; ++n, no_leading_period2 = false)\n                    if (FOLD ((UCHAR) *n) == c\n                        && (FCT (p, n, string_end, no_leading_period2, flags2)\n                            == 0))\n                      return 0;\n                }\n            }\n\n          /* If we come here no match is possible with the wildcard.  */\n          return FNM_NOMATCH;\n\n        case L_('['):\n          {\n            /* Nonzero if the sense of the character class is inverted.  */\n            const CHAR *p_init = p;\n            const CHAR *n_init = n;\n            register bool not;\n            CHAR cold;\n            UCHAR fn;\n\n            if (posixly_correct == 0)\n              posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n            if (n == string_end)\n              return FNM_NOMATCH;\n\n            if (*n == L_('.') && no_leading_period)\n              return FNM_NOMATCH;\n\n            if (*n == L_('/') && (flags & FNM_FILE_NAME))\n              /* '/' cannot be matched.  */\n              return FNM_NOMATCH;\n\n            not = (*p == L_('!') || (posixly_correct < 0 && *p == L_('^')));\n            if (not)\n              ++p;\n\n            fn = FOLD ((UCHAR) *n);\n\n            c = *p++;\n            for (;;)\n              {\n\t\tbool is_range = false;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = FOLD ((UCHAR) *p);\n                    ++p;\n\n                    goto normal_bracket;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    /* Leave room for the null.  */\n                    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];\n                    size_t c1 = 0;\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wctype_t wt;\n#endif\n                    const CHAR *startp = p;\n\n                    for (;;)\n                      {\n                        if (c1 == CHAR_CLASS_MAX_LENGTH)\n                          /* The name is too long and therefore the pattern\n                             is ill-formed.  */\n                          return FNM_NOMATCH;\n\n                        c = *++p;\n                        if (c == L_(':') && p[1] == L_(']'))\n                          {\n                            p += 2;\n                            break;\n                          }\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            /* This cannot possibly be a character class name.\n                               Match it as a normal range.  */\n                            p = startp;\n                            c = L_('[');\n                            goto normal_bracket;\n                          }\n                        str[c1++] = c;\n                      }\n                    str[c1] = L_('\\0');\n\n#if defined _LIBC || WIDE_CHAR_SUPPORT\n                    wt = IS_CHAR_CLASS (str);\n                    if (wt == 0)\n                      /* Invalid character class name.  */\n                      return FNM_NOMATCH;\n\n# if defined _LIBC && ! WIDE_CHAR_VERSION\n                    /* The following code is glibc specific but does\n                       there a good job in speeding up the code since\n                       we can avoid the btowc() call.  */\n                    if (_ISCTYPE ((UCHAR) *n, wt))\n                      goto matched;\n# else\n                    if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))\n                      goto matched;\n# endif\n#else\n                    if ((STREQ (str, L_(\"alnum\")) && isalnum ((UCHAR) *n))\n                        || (STREQ (str, L_(\"alpha\")) && isalpha ((UCHAR) *n))\n                        || (STREQ (str, L_(\"blank\")) && isblank ((UCHAR) *n))\n                        || (STREQ (str, L_(\"cntrl\")) && iscntrl ((UCHAR) *n))\n                        || (STREQ (str, L_(\"digit\")) && isdigit ((UCHAR) *n))\n                        || (STREQ (str, L_(\"graph\")) && isgraph ((UCHAR) *n))\n                        || (STREQ (str, L_(\"lower\")) && islower ((UCHAR) *n))\n                        || (STREQ (str, L_(\"print\")) && isprint ((UCHAR) *n))\n                        || (STREQ (str, L_(\"punct\")) && ispunct ((UCHAR) *n))\n                        || (STREQ (str, L_(\"space\")) && isspace ((UCHAR) *n))\n                        || (STREQ (str, L_(\"upper\")) && isupper ((UCHAR) *n))\n                        || (STREQ (str, L_(\"xdigit\")) && isxdigit ((UCHAR) *n)))\n                      goto matched;\n#endif\n                    c = *p++;\n                  }\n#ifdef _LIBC\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    UCHAR str[1];\n                    uint32_t nrules =\n                      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                    const CHAR *startp = p;\n\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    str[0] = c;\n\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      {\n                        p = startp;\n                        c = L_('[');\n                        goto normal_bracket;\n                      }\n                    p += 2;\n\n                    if (nrules == 0)\n                      {\n                        if ((UCHAR) *n == str[0])\n                          goto matched;\n                      }\n                    else\n                      {\n                        const int32_t *table;\n# if WIDE_CHAR_VERSION\n                        const int32_t *weights;\n                        const int32_t *extra;\n# else\n                        const unsigned char *weights;\n                        const unsigned char *extra;\n# endif\n                        const int32_t *indirect;\n                        int32_t idx;\n                        const UCHAR *cp = (const UCHAR *) str;\n\n                        /* This #include defines a local function!  */\n# if WIDE_CHAR_VERSION\n#  include <locale/weightwc.h>\n# else\n#  include <locale/weight.h>\n# endif\n\n# if WIDE_CHAR_VERSION\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);\n                        weights = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);\n                        extra = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);\n# else\n                        table = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n                        weights = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n                        extra = (const unsigned char *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n                        indirect = (const int32_t *)\n                          _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n# endif\n\n                        idx = findidx (&cp);\n                        if (idx != 0)\n                          {\n                            /* We found a table entry.  Now see whether the\n                               character we are currently at has the same\n                               equivalence class value.  */\n                            int len = weights[idx & 0xffffff];\n                            int32_t idx2;\n                            const UCHAR *np = (const UCHAR *) n;\n\n                            idx2 = findidx (&np);\n                            if (idx2 != 0\n                                && (idx >> 24) == (idx2 >> 24)\n                                && len == weights[idx2 & 0xffffff])\n                              {\n                                int cnt = 0;\n\n                                idx &= 0xffffff;\n                                idx2 &= 0xffffff;\n\n                                while (cnt < len\n                                       && (weights[idx + 1 + cnt]\n                                           == weights[idx2 + 1 + cnt]))\n                                  ++cnt;\n\n                                if (cnt == len)\n                                  goto matched;\n                              }\n                          }\n                      }\n\n                    c = *p++;\n                  }\n#endif\n                else if (c == L_('\\0'))\n                  {\n                    /* [ unterminated, treat as normal character.  */\n                    p = p_init;\n                    n = n_init;\n                    c = L_('[');\n                    goto normal_match;\n                  }\n                else\n                  {\n#ifdef _LIBC\n                    bool is_seqval = false;\n\n                    if (c == L_('[') && *p == L_('.'))\n                      {\n                        uint32_t nrules =\n                          _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n                        const CHAR *startp = p;\n                        size_t c1 = 0;\n\n                        while (1)\n                          {\n                            c = *++p;\n                            if (c == L_('.') && p[1] == L_(']'))\n                              {\n                                p += 2;\n                                break;\n                              }\n                            if (c == '\\0')\n                              return FNM_NOMATCH;\n                            ++c1;\n                          }\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = *p == L_('-') && p[1] != L_('\\0');\n\n                        if (nrules == 0)\n                          {\n                            /* There are no names defined in the collation\n                               data.  Therefore we only accept the trivial\n                               names consisting of the character itself.  */\n                            if (c1 != 1)\n                              return FNM_NOMATCH;\n\n                            if (!is_range && *n == startp[1])\n                              goto matched;\n\n                            cold = startp[1];\n                            c = *p++;\n                          }\n                        else\n                          {\n                            int32_t table_size;\n                            const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                            char str[c1];\n                            size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                            const unsigned char *extra;\n                            int32_t idx;\n                            int32_t elem;\n                            int32_t second;\n                            int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                            /* We have to convert the name to a single-byte\n                               string.  This is possible since the names\n                               consist of ASCII characters and the internal\n                               representation is UCS4.  */\n                            for (strcnt = 0; strcnt < c1; ++strcnt)\n                              str[strcnt] = startp[1 + strcnt];\n# endif\n\n                            table_size =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_SYMB_HASH_SIZEMB);\n                            symb_table = (const int32_t *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_TABLEMB);\n                            extra = (const unsigned char *)\n                              _NL_CURRENT (LC_COLLATE,\n                                           _NL_COLLATE_SYMB_EXTRAMB);\n\n                            /* Locate the character in the hashing table.  */\n                            hash = elem_hash (str, c1);\n\n                            idx = 0;\n                            elem = hash % table_size;\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                second = hash % (table_size - 2) + 1;\n\n                                do\n                                  {\n                                    /* First compare the hashing value.  */\n                                    if (symb_table[2 * elem] == hash\n                                        && (c1\n                                            == extra[symb_table[2 * elem + 1]])\n                                        && memcmp (str,\n                                                   &extra[symb_table[2 * elem\n                                                                     + 1]\n                                                          + 1], c1) == 0)\n                                      {\n                                        /* Yep, this is the entry.  */\n                                        idx = symb_table[2 * elem + 1];\n                                        idx += 1 + extra[idx];\n                                        break;\n                                      }\n\n                                    /* Next entry.  */\n                                    elem += second;\n                                  }\n                                while (symb_table[2 * elem] != 0);\n                              }\n\n                            if (symb_table[2 * elem] != 0)\n                              {\n                                /* Compare the byte sequence but only if\n                                   this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                int32_t *wextra;\n\n                                idx += 1 + extra[idx];\n                                /* Adjust for the alignment.  */\n                                idx = (idx + 3) & ~3;\n\n                                wextra = (int32_t *) &extra[idx + 4];\n# endif\n\n                                if (! is_range)\n                                  {\n# ifdef WIDE_CHAR_VERSION\n                                    for (c1 = 0;\n                                         (int32_t) c1 < wextra[idx];\n                                         ++c1)\n                                      if (n[c1] != wextra[1 + c1])\n                                        break;\n\n                                    if ((int32_t) c1 == wextra[idx])\n                                      goto matched;\n# else\n                                    for (c1 = 0; c1 < extra[idx]; ++c1)\n                                      if (n[c1] != extra[1 + c1])\n                                        break;\n\n                                    if (c1 == extra[idx])\n                                      goto matched;\n# endif\n                                  }\n\n                                /* Get the collation sequence value.  */\n                                is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                cold = wextra[1 + wextra[idx]];\n# else\n                                /* Adjust for the alignment.  */\n                                idx += 1 + extra[idx];\n                                idx = (idx + 3) & ~4;\n                                cold = *((int32_t *) &extra[idx]);\n# endif\n\n                                c = *p++;\n                              }\n                            else if (c1 == 1)\n                              {\n                                /* No valid character.  Match it as a\n                                   single byte.  */\n                                if (!is_range && *n == str[0])\n                                  goto matched;\n\n                                cold = str[0];\n                                c = *p++;\n                              }\n                            else\n                              return FNM_NOMATCH;\n                          }\n                      }\n                    else\n# undef str\n#endif\n                      {\n                        c = FOLD (c);\n                      normal_bracket:\n\n                        /* We have to handling the symbols differently in\n                           ranges since then the collation sequence is\n                           important.  */\n                        is_range = (*p == L_('-') && p[1] != L_('\\0')\n                                    && p[1] != L_(']'));\n\n                        if (!is_range && c == fn)\n                          goto matched;\n\n#if _LIBC\n                        /* This is needed if we goto normal_bracket; from\n                           outside of is_seqval's scope.  */\n                        is_seqval = false;\n#endif\n\n                        cold = c;\n                        c = *p++;\n                      }\n\n                    if (c == L_('-') && *p != L_(']'))\n                      {\n#if _LIBC\n                        /* We have to find the collation sequence\n                           value for C.  Collation sequence is nothing\n                           we can regularly access.  The sequence\n                           value is defined by the order in which the\n                           definitions of the collation values for the\n                           various characters appear in the source\n                           file.  A strange concept, nowhere\n                           documented.  */\n                        uint32_t fcollseq;\n                        uint32_t lcollseq;\n                        UCHAR cend = *p++;\n\n# ifdef WIDE_CHAR_VERSION\n                        /* Search in the 'names' array for the characters.  */\n                        fcollseq = __collseq_table_lookup (collseq, fn);\n                        if (fcollseq == ~((uint32_t) 0))\n                          /* XXX We don't know anything about the character\n                             we are supposed to match.  This means we are\n                             failing.  */\n                          goto range_not_matched;\n\n                        if (is_seqval)\n                          lcollseq = cold;\n                        else\n                          lcollseq = __collseq_table_lookup (collseq, cold);\n# else\n                        fcollseq = collseq[fn];\n                        lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];\n# endif\n\n                        is_seqval = false;\n                        if (cend == L_('[') && *p == L_('.'))\n                          {\n                            uint32_t nrules =\n                              _NL_CURRENT_WORD (LC_COLLATE,\n                                                _NL_COLLATE_NRULES);\n                            const CHAR *startp = p;\n                            size_t c1 = 0;\n\n                            while (1)\n                              {\n                                c = *++p;\n                                if (c == L_('.') && p[1] == L_(']'))\n                                  {\n                                    p += 2;\n                                    break;\n                                  }\n                                if (c == '\\0')\n                                  return FNM_NOMATCH;\n                                ++c1;\n                              }\n\n                            if (nrules == 0)\n                              {\n                                /* There are no names defined in the\n                                   collation data.  Therefore we only\n                                   accept the trivial names consisting\n                                   of the character itself.  */\n                                if (c1 != 1)\n                                  return FNM_NOMATCH;\n\n                                cend = startp[1];\n                              }\n                            else\n                              {\n                                int32_t table_size;\n                                const int32_t *symb_table;\n# ifdef WIDE_CHAR_VERSION\n                                char str[c1];\n                                size_t strcnt;\n# else\n#  define str (startp + 1)\n# endif\n                                const unsigned char *extra;\n                                int32_t idx;\n                                int32_t elem;\n                                int32_t second;\n                                int32_t hash;\n\n# ifdef WIDE_CHAR_VERSION\n                                /* We have to convert the name to a single-byte\n                                   string.  This is possible since the names\n                                   consist of ASCII characters and the internal\n                                   representation is UCS4.  */\n                                for (strcnt = 0; strcnt < c1; ++strcnt)\n                                  str[strcnt] = startp[1 + strcnt];\n# endif\n\n                                table_size =\n                                  _NL_CURRENT_WORD (LC_COLLATE,\n                                                    _NL_COLLATE_SYMB_HASH_SIZEMB);\n                                symb_table = (const int32_t *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_TABLEMB);\n                                extra = (const unsigned char *)\n                                  _NL_CURRENT (LC_COLLATE,\n                                               _NL_COLLATE_SYMB_EXTRAMB);\n\n                                /* Locate the character in the hashing\n                                   table.  */\n                                hash = elem_hash (str, c1);\n\n                                idx = 0;\n                                elem = hash % table_size;\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    second = hash % (table_size - 2) + 1;\n\n                                    do\n                                      {\n                                        /* First compare the hashing value.  */\n                                        if (symb_table[2 * elem] == hash\n                                            && (c1\n                                                == extra[symb_table[2 * elem + 1]])\n                                            && memcmp (str,\n                                                       &extra[symb_table[2 * elem + 1]\n                                                              + 1], c1) == 0)\n                                          {\n                                            /* Yep, this is the entry.  */\n                                            idx = symb_table[2 * elem + 1];\n                                            idx += 1 + extra[idx];\n                                            break;\n                                          }\n\n                                        /* Next entry.  */\n                                        elem += second;\n                                      }\n                                    while (symb_table[2 * elem] != 0);\n                                  }\n\n                                if (symb_table[2 * elem] != 0)\n                                  {\n                                    /* Compare the byte sequence but only if\n                                       this is not part of a range.  */\n# ifdef WIDE_CHAR_VERSION\n                                    int32_t *wextra;\n\n                                    idx += 1 + extra[idx];\n                                    /* Adjust for the alignment.  */\n                                    idx = (idx + 3) & ~4;\n\n                                    wextra = (int32_t *) &extra[idx + 4];\n# endif\n                                    /* Get the collation sequence value.  */\n                                    is_seqval = true;\n# ifdef WIDE_CHAR_VERSION\n                                    cend = wextra[1 + wextra[idx]];\n# else\n                                    /* Adjust for the alignment.  */\n                                    idx += 1 + extra[idx];\n                                    idx = (idx + 3) & ~4;\n                                    cend = *((int32_t *) &extra[idx]);\n# endif\n                                  }\n                                else if (symb_table[2 * elem] != 0 && c1 == 1)\n                                  {\n                                    cend = str[0];\n                                    c = *p++;\n                                  }\n                                else\n                                  return FNM_NOMATCH;\n                              }\n# undef str\n                          }\n                        else\n                          {\n                            if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                              cend = *p++;\n                            if (cend == L_('\\0'))\n                              return FNM_NOMATCH;\n                            cend = FOLD (cend);\n                          }\n\n                        /* XXX It is not entirely clear to me how to handle\n                           characters which are not mentioned in the\n                           collation specification.  */\n                        if (\n# ifdef WIDE_CHAR_VERSION\n                            lcollseq == 0xffffffff ||\n# endif\n                            lcollseq <= fcollseq)\n                          {\n                            /* We have to look at the upper bound.  */\n                            uint32_t hcollseq;\n\n                            if (is_seqval)\n                              hcollseq = cend;\n                            else\n                              {\n# ifdef WIDE_CHAR_VERSION\n                                hcollseq =\n                                  __collseq_table_lookup (collseq, cend);\n                                if (hcollseq == ~((uint32_t) 0))\n                                  {\n                                    /* Hum, no information about the upper\n                                       bound.  The matching succeeds if the\n                                       lower bound is matched exactly.  */\n                                    if (lcollseq != fcollseq)\n                                      goto range_not_matched;\n\n                                    goto matched;\n                                  }\n# else\n                                hcollseq = collseq[cend];\n# endif\n                              }\n\n                            if (lcollseq <= hcollseq && fcollseq <= hcollseq)\n                              goto matched;\n                          }\n# ifdef WIDE_CHAR_VERSION\n                      range_not_matched:\n# endif\n#else\n                        /* We use a boring value comparison of the character\n                           values.  This is better than comparing using\n                           'strcoll' since the latter would have surprising\n                           and sometimes fatal consequences.  */\n                        UCHAR cend = *p++;\n\n                        if (!(flags & FNM_NOESCAPE) && cend == L_('\\\\'))\n                          cend = *p++;\n                        if (cend == L_('\\0'))\n                          return FNM_NOMATCH;\n\n                        /* It is a range.  */\n                        if (cold <= fn && fn <= cend)\n                          goto matched;\n#endif\n\n                        c = *p++;\n                      }\n                  }\n\n                if (c == L_(']'))\n                  break;\n              }\n\n            if (!not)\n              return FNM_NOMATCH;\n            break;\n\n          matched:\n            /* Skip the rest of the [...] that already matched.  */\n            do\n              {\n              ignore_next:\n                c = *p++;\n\n                if (c == L_('\\0'))\n                  /* [... (unterminated) loses.  */\n                  return FNM_NOMATCH;\n\n                if (!(flags & FNM_NOESCAPE) && c == L_('\\\\'))\n                  {\n                    if (*p == L_('\\0'))\n                      return FNM_NOMATCH;\n                    /* XXX 1003.2d11 is unclear if this is right.  */\n                    ++p;\n                  }\n                else if (c == L_('[') && *p == L_(':'))\n                  {\n                    int c1 = 0;\n                    const CHAR *startp = p;\n\n                    while (1)\n                      {\n                        c = *++p;\n                        if (++c1 == CHAR_CLASS_MAX_LENGTH)\n                          return FNM_NOMATCH;\n\n                        if (*p == L_(':') && p[1] == L_(']'))\n                          break;\n\n                        if (c < L_('a') || c >= L_('z'))\n                          {\n                            p = startp;\n                            goto ignore_next;\n                          }\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('='))\n                  {\n                    c = *++p;\n                    if (c == L_('\\0'))\n                      return FNM_NOMATCH;\n                    c = *++p;\n                    if (c != L_('=') || p[1] != L_(']'))\n                      return FNM_NOMATCH;\n                    p += 2;\n                    c = *p++;\n                  }\n                else if (c == L_('[') && *p == L_('.'))\n                  {\n                    ++p;\n                    while (1)\n                      {\n                        c = *++p;\n                        if (c == '\\0')\n                          return FNM_NOMATCH;\n\n                        if (*p == L_('.') && p[1] == L_(']'))\n                          break;\n                      }\n                    p += 2;\n                    c = *p++;\n                  }\n              }\n            while (c != L_(']'));\n            if (not)\n              return FNM_NOMATCH;\n          }\n          break;\n\n        case L_('+'):\n        case L_('@'):\n        case L_('!'):\n          if (__builtin_expect (flags & FNM_EXTMATCH, 0) && *p == '(')\n            {\n              int res;\n\n              res = EXT (c, p, n, string_end, no_leading_period, flags);\n              if (res != -1)\n                return res;\n            }\n          goto normal_match;\n\n        case L_('/'):\n          if (NO_LEADING_PERIOD (flags))\n            {\n              if (n == string_end || c != (UCHAR) *n)\n                return FNM_NOMATCH;\n\n              new_no_leading_period = true;\n              break;\n            }\n          /* FALLTHROUGH */\n        default:\n        normal_match:\n          if (n == string_end || c != FOLD ((UCHAR) *n))\n            return FNM_NOMATCH;\n        }\n\n      no_leading_period = new_no_leading_period;\n      ++n;\n    }\n\n  if (n == string_end)\n    return 0;\n\n  if ((flags & FNM_LEADING_DIR) && n != string_end && *n == L_('/'))\n    /* The FNM_LEADING_DIR flag says that \"foo*\" matches \"foobar/frobozz\".  */\n    return 0;\n\n  return FNM_NOMATCH;\n}",
        "lines": 959,
        "depth": 36,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          984,
          0
        ],
        "end_point": [
          1020,
          1
        ],
        "content": "static const CHAR *\ninternal_function\nEND (const CHAR *pattern)\n{\n  const CHAR *p = pattern;\n\n  while (1)\n    if (*++p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return pattern;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return pattern;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      p = END (p + 1);\n    else if (*p == L_(')'))\n      break;\n\n  return p + 1;\n}",
        "lines": 37,
        "depth": 18,
        "decorators": [
          "static",
          "static",
          "const",
          "const",
          "CHAR",
          "*\ninternal_function\nEND (const CHAR *pattern)",
          "*"
        ]
      },
      {
        "start_point": [
          1023,
          0
        ],
        "end_point": [
          1203,
          1
        ],
        "content": "static int\ninternal_function\nEXT (INT opt, const CHAR *pattern, const CHAR *string, const CHAR *string_end,\n     bool no_leading_period, int flags)\n{\n  const CHAR *startp;\n  size_t level;\n  struct patternlist\n  {\n    struct patternlist *next;\n    CHAR str[1];\n  } *list = NULL;\n  struct patternlist **lastp = &list;\n  size_t pattern_len = STRLEN (pattern);\n  const CHAR *p;\n  const CHAR *rs;\n  enum { ALLOCA_LIMIT = 8000 };\n\n  /* Parse the pattern.  Store the individual parts in the list.  */\n  level = 0;\n  for (startp = p = pattern + 1; ; ++p)\n    if (*p == L_('\\0'))\n      /* This is an invalid pattern.  */\n      return -1;\n    else if (*p == L_('['))\n      {\n        /* Handle brackets special.  */\n        if (posixly_correct == 0)\n          posixly_correct = getenv (\"POSIXLY_CORRECT\") != NULL ? 1 : -1;\n\n        /* Skip the not sign.  We have to recognize it because of a possibly\n           following ']'.  */\n        if (*++p == L_('!') || (posixly_correct < 0 && *p == L_('^')))\n          ++p;\n        /* A leading ']' is recognized as such.  */\n        if (*p == L_(']'))\n          ++p;\n        /* Skip over all characters of the list.  */\n        while (*p != L_(']'))\n          if (*p++ == L_('\\0'))\n            /* This is no valid pattern.  */\n            return -1;\n      }\n    else if ((*p == L_('?') || *p == L_('*') || *p == L_('+') || *p == L_('@')\n              || *p == L_('!')) && p[1] == L_('('))\n      /* Remember the nesting level.  */\n      ++level;\n    else if (*p == L_(')'))\n      {\n        if (level-- == 0)\n          {\n            /* This means we found the end of the pattern.  */\n#define NEW_PATTERN \\\n            struct patternlist *newp;                                         \\\n            size_t plen;                                                      \\\n            size_t plensize;                                                  \\\n            size_t newpsize;                                                  \\\n                                                                              \\\n            plen = (opt == L_('?') || opt == L_('@')                          \\\n                    ? pattern_len                                             \\\n                    : p - startp + 1UL);                                      \\\n            plensize = plen * sizeof (CHAR);                                  \\\n            newpsize = offsetof (struct patternlist, str) + plensize;         \\\n            if ((size_t) -1 / sizeof (CHAR) < plen                            \\\n                || newpsize < offsetof (struct patternlist, str)              \\\n                || ALLOCA_LIMIT <= newpsize)                                  \\\n              return -1;                                                      \\\n            newp = (struct patternlist *) alloca (newpsize);                  \\\n            *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L_('\\0');    \\\n            newp->next = NULL;                                                \\\n            *lastp = newp;                                                    \\\n            lastp = &newp->next\n            NEW_PATTERN;\n            break;\n          }\n      }\n    else if (*p == L_('|'))\n      {\n        if (level == 0)\n          {\n            NEW_PATTERN;\n            startp = p + 1;\n          }\n      }\n  assert (list != NULL);\n  assert (p[-1] == L_(')'));\n#undef NEW_PATTERN\n\n  switch (opt)\n    {\n    case L_('*'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('+'):\n      do\n        {\n          for (rs = string; rs <= string_end; ++rs)\n            /* First match the prefix with the current pattern with the\n               current pattern.  */\n            if (FCT (list->str, string, rs, no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0\n                /* This was successful.  Now match the rest with the rest\n                   of the pattern.  */\n                && (FCT (p, rs, string_end,\n                         rs == string\n                         ? no_leading_period\n                         : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                         flags & FNM_FILE_NAME\n                         ? flags : flags & ~FNM_PERIOD) == 0\n                    /* This didn't work.  Try the whole pattern.  */\n                    || (rs != string\n                        && FCT (pattern - 1, rs, string_end,\n                                rs == string\n                                ? no_leading_period\n                                : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                                flags & FNM_FILE_NAME\n                                ? flags : flags & ~FNM_PERIOD) == 0)))\n              /* It worked.  Signal success.  */\n              return 0;\n        }\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('?'):\n      if (FCT (p, string, string_end, no_leading_period, flags) == 0)\n        return 0;\n      /* FALLTHROUGH */\n\n    case L_('@'):\n      do\n        /* I cannot believe it but 'strcat' is actually acceptable\n           here.  Match the entire string with the prefix from the\n           pattern list and the rest of the pattern following the\n           pattern list.  */\n        if (FCT (STRCAT (list->str, p), string, string_end,\n                 no_leading_period,\n                 flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n          /* It worked.  Signal success.  */\n          return 0;\n      while ((list = list->next) != NULL);\n\n      /* None of the patterns lead to a match.  */\n      return FNM_NOMATCH;\n\n    case L_('!'):\n      for (rs = string; rs <= string_end; ++rs)\n        {\n          struct patternlist *runp;\n\n          for (runp = list; runp != NULL; runp = runp->next)\n            if (FCT (runp->str, string, rs,  no_leading_period,\n                     flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD) == 0)\n              break;\n\n          /* If none of the patterns matched see whether the rest does.  */\n          if (runp == NULL\n              && (FCT (p, rs, string_end,\n                       rs == string\n                       ? no_leading_period\n                       : rs[-1] == '/' && NO_LEADING_PERIOD (flags),\n                       flags & FNM_FILE_NAME ? flags : flags & ~FNM_PERIOD)\n                  == 0))\n            /* This is successful.  */\n            return 0;\n        }\n\n      /* None of the patterns together with the rest of the pattern\n         lead to a match.  */\n      return FNM_NOMATCH;\n\n    default:\n      assert (! \"Invalid extended matching operator\");\n      break;\n    }\n\n  return -1;\n}",
        "lines": 181,
        "depth": 23,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/fopen-safer.c": {
    "fopen_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "FILE *\nfopen_safer (char const *file, char const *mode)\n{\n  FILE *fp = fopen (file, mode);\n\n  if (fp)\n    {\n      int fd = fileno (fp);\n\n      if (0 <= fd && fd <= STDERR_FILENO)\n        {\n          int f = dup_safer (fd);\n\n          if (f < 0)\n            {\n              int e = errno;\n              fclose (fp);\n              errno = e;\n              return NULL;\n            }\n\n          if (fclose (fp) != 0\n              || ! (fp = fdopen (f, mode)))\n            {\n              int e = errno;\n              close (f);\n              errno = e;\n              return NULL;\n            }\n        }\n    }\n\n  return fp;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "FILE",
        "*\nfopen_safer (char const *file, char const *mode)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fopen.c": {
    "orig_fopen": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static FILE *\norig_fopen (const char *filename, const char *mode)\n{\n  return fopen (filename, mode);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\norig_fopen (const char *filename, const char *mode)",
        "*"
      ]
    },
    "rpl_fopen": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "FILE *\nrpl_fopen (const char *filename, const char *mode)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if FOPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and a mode that requires write access is\n     specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then if a mode that\n     requires write access is specified, fopen() must fail because POSIX\n     <http://www.opengroup.org/susv3/functions/fopen.html> says that it\n     fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n     fopen() must fail since the file does not contain a '.' directory.  */\n  {\n    size_t len = strlen (filename);\n    if (len > 0 && filename[len - 1] == '/')\n      {\n        int fd;\n        struct stat statbuf;\n        FILE *fp;\n\n        if (mode[0] == 'w' || mode[0] == 'a')\n          {\n            errno = EISDIR;\n            return NULL;\n          }\n\n        fd = open (filename, O_RDONLY);\n        if (fd < 0)\n          return NULL;\n\n        if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n          {\n            close (fd);\n            errno = ENOTDIR;\n            return NULL;\n          }\n\n        fp = fdopen (fd, mode);\n        if (fp == NULL)\n          {\n            int saved_errno = errno;\n            close (fd);\n            errno = saved_errno;\n          }\n        return fp;\n      }\n  }\n# endif\n\n  return orig_fopen (filename, mode);\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "FILE",
        "*\nrpl_fopen (const char *filename, const char *mode)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/forkpty.c": {
    "rpl_forkpty": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nrpl_forkpty (int *amaster, char *name, struct termios const *termp,\n         struct winsize const *winp)\n{\n  /* Cast away const, for implementations with weaker prototypes.  */\n  return forkpty (amaster, name, (struct termios *) termp,\n                  (struct winsize *) winp);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "forkpty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nforkpty (int *amaster, char *name,\n         const struct termios *termp, const struct winsize *winp)\n{\n  int master, slave, pid;\n\n  if (openpty (&master, &slave, name, termp, winp) == -1)\n    return -1;\n\n  switch (pid = fork ())\n    {\n    case -1:\n      close (master);\n      close (slave);\n      return -1;\n\n    case 0:\n      /* Child.  */\n      close (master);\n      if (login_tty (slave))\n        _exit (1);\n      return 0;\n\n    default:\n      /* Parent.  */\n      *amaster = master;\n      close (slave);\n      return pid;\n    }\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fseeko.c": {},
  "inetutils/inetutils-1.9.4/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/fstatat.c": {
    "orig_fstatat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static int\norig_fstatat (int fd, char const *filename, struct stat *buf, int flags)\n{\n  return fstatat (fd, filename, buf, flags);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstatat": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrpl_fstatat (int fd, char const *file, struct stat *st, int flag)\n{\n  int result = orig_fstatat (fd, file, st, flag);\n  size_t len;\n\n  if (LSTAT_FOLLOWS_SLASHED_SYMLINK || result != 0)\n    return result;\n  len = strlen (file);\n  if (flag & AT_SYMLINK_NOFOLLOW)\n    {\n      /* Fix lstat behavior.  */\n      if (file[len - 1] != '/' || S_ISDIR (st->st_mode))\n        return 0;\n      if (!S_ISLNK (st->st_mode))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n      result = orig_fstatat (fd, file, st, flag & ~AT_SYMLINK_NOFOLLOW);\n    }\n  /* Fix stat behavior.  */\n  if (result == 0 && !S_ISDIR (st->st_mode) && file[len - 1] == '/')\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "stat_func": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nstat_func (char const *name, struct stat *st)\n{\n  return stat (name, st);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/ftello.c": {},
  "inetutils/inetutils-1.9.4/lib/gai_strerror.c": {
    "rpl_gai_strerror": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const char *\nrpl_gai_strerror (int code)\n{\n  return gai_strerror (code);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrpl_gai_strerror (int code)",
        "*"
      ]
    },
    "gai_strerror": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "const char *\ngai_strerror (int code)\n{\n  size_t i;\n  for (i = 0; i < sizeof (values) / sizeof (values[0]); ++i)\n    if (values[i].code == code)\n      return _(values[i].msg);\n\n  return _(\"Unknown error\");\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngai_strerror (int code)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getaddrinfo.c": {
    "use_win32_p": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\nuse_win32_p (void)\n{\n  static int done = 0;\n  HMODULE h;\n\n  if (done)\n    return getaddrinfo_ptr ? 1 : 0;\n\n  done = 1;\n\n  h = GetModuleHandle (\"ws2_32.dll\");\n\n  if (h)\n    {\n      getaddrinfo_ptr = (getaddrinfo_func) GetProcAddress (h, \"getaddrinfo\");\n      freeaddrinfo_ptr = (freeaddrinfo_func) GetProcAddress (h, \"freeaddrinfo\");\n      getnameinfo_ptr = (getnameinfo_func) GetProcAddress (h, \"getnameinfo\");\n    }\n\n  /* If either is missing, something is odd. */\n  if (!getaddrinfo_ptr || !freeaddrinfo_ptr || !getnameinfo_ptr)\n    {\n      getaddrinfo_ptr = NULL;\n      freeaddrinfo_ptr = NULL;\n      getnameinfo_ptr = NULL;\n      return 0;\n    }\n\n  gl_sockets_startup (SOCKETS_1_1);\n\n  return 1;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "validate_family": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static bool\nvalidate_family (int family)\n{\n  /* FIXME: Support more families. */\n#if HAVE_IPV4\n     if (family == PF_INET)\n       return true;\n#endif\n#if HAVE_IPV6\n     if (family == PF_INET6)\n       return true;\n#endif\n     if (family == PF_UNSPEC)\n       return true;\n     return false;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "getaddrinfo": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "int\ngetaddrinfo (const char *restrict nodename,\n             const char *restrict servname,\n             const struct addrinfo *restrict hints,\n             struct addrinfo **restrict res)\n{\n  struct addrinfo *tmp;\n  int port = 0;\n  struct hostent *he;\n  void *storage;\n  size_t size;\n#if HAVE_IPV6\n  struct v6_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in6 sockaddr_in6;\n  };\n#endif\n#if HAVE_IPV4\n  struct v4_pair {\n    struct addrinfo addrinfo;\n    struct sockaddr_in sockaddr_in;\n  };\n#endif\n\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getaddrinfo_ptr (nodename, servname, hints, res);\n#endif\n\n  if (hints && (hints->ai_flags & ~(AI_CANONNAME|AI_PASSIVE)))\n    /* FIXME: Support more flags. */\n    return EAI_BADFLAGS;\n\n  if (hints && !validate_family (hints->ai_family))\n    return EAI_FAMILY;\n\n  if (hints &&\n      hints->ai_socktype != SOCK_STREAM && hints->ai_socktype != SOCK_DGRAM)\n    /* FIXME: Support other socktype. */\n    return EAI_SOCKTYPE; /* FIXME: Better return code? */\n\n  if (!nodename)\n    {\n      if (!(hints->ai_flags & AI_PASSIVE))\n        return EAI_NONAME;\n\n#ifdef HAVE_IPV6\n      nodename = (hints->ai_family == AF_INET6) ? \"::\" : \"0.0.0.0\";\n#else\n      nodename = \"0.0.0.0\";\n#endif\n    }\n\n  if (servname)\n    {\n      struct servent *se = NULL;\n      const char *proto =\n        (hints && hints->ai_socktype == SOCK_DGRAM) ? \"udp\" : \"tcp\";\n\n      if (hints == NULL || !(hints->ai_flags & AI_NUMERICSERV))\n        /* FIXME: Use getservbyname_r if available. */\n        se = getservbyname (servname, proto);\n\n      if (!se)\n        {\n          char *c;\n          if (!(*servname >= '0' && *servname <= '9'))\n            return EAI_NONAME;\n          port = strtoul (servname, &c, 10);\n          if (*c || port > 0xffff)\n            return EAI_NONAME;\n          port = htons (port);\n        }\n      else\n        port = se->s_port;\n    }\n\n  /* FIXME: Use gethostbyname_r if available. */\n  he = gethostbyname (nodename);\n  if (!he || he->h_addr_list[0] == NULL)\n    return EAI_NONAME;\n\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV6\n    case PF_INET6:\n      size = sizeof (struct v6_pair);\n      break;\n#endif\n\n#if HAVE_IPV4\n    case PF_INET:\n      size = sizeof (struct v4_pair);\n      break;\n#endif\n\n    default:\n      return EAI_NODATA;\n    }\n\n  storage = calloc (1, size);\n  if (!storage)\n    return EAI_MEMORY;\n\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV6\n    case PF_INET6:\n      {\n        struct v6_pair *p = storage;\n        struct sockaddr_in6 *sinp = &p->sockaddr_in6;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin6_port = port;\n\n        if (he->h_length != sizeof (sinp->sin6_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM; /* FIXME: Better return code?  Set errno? */\n          }\n\n        memcpy (&sinp->sin6_addr, he->h_addr_list[0], sizeof sinp->sin6_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n#endif\n\n#if HAVE_IPV4\n    case PF_INET:\n      {\n        struct v4_pair *p = storage;\n        struct sockaddr_in *sinp = &p->sockaddr_in;\n        tmp = &p->addrinfo;\n\n        if (port)\n          sinp->sin_port = port;\n\n        if (he->h_length != sizeof (sinp->sin_addr))\n          {\n            free (storage);\n            return EAI_SYSTEM; /* FIXME: Better return code?  Set errno? */\n          }\n\n        memcpy (&sinp->sin_addr, he->h_addr_list[0], sizeof sinp->sin_addr);\n\n        tmp->ai_addr = (struct sockaddr *) sinp;\n        tmp->ai_addrlen = sizeof *sinp;\n      }\n      break;\n#endif\n\n    default:\n      free (storage);\n      return EAI_NODATA;\n    }\n\n  if (hints && hints->ai_flags & AI_CANONNAME)\n    {\n      const char *cn;\n      if (he->h_name)\n        cn = he->h_name;\n      else\n        cn = nodename;\n\n      tmp->ai_canonname = strdup (cn);\n      if (!tmp->ai_canonname)\n        {\n          free (storage);\n          return EAI_MEMORY;\n        }\n    }\n\n  tmp->ai_protocol = (hints) ? hints->ai_protocol : 0;\n  tmp->ai_socktype = (hints) ? hints->ai_socktype : 0;\n  tmp->ai_addr->sa_family = he->h_addrtype;\n  tmp->ai_family = he->h_addrtype;\n\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n  switch (he->h_addrtype)\n    {\n#if HAVE_IPV4\n    case AF_INET:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in);\n      break;\n#endif\n#if HAVE_IPV6\n    case AF_INET6:\n      tmp->ai_addr->sa_len = sizeof (struct sockaddr_in6);\n      break;\n#endif\n    }\n#endif\n\n  /* FIXME: If more than one address, create linked list of addrinfo's. */\n\n  *res = tmp;\n\n  return 0;\n}",
      "lines": 202,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "freeaddrinfo": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void\nfreeaddrinfo (struct addrinfo *ai)\n{\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    {\n      freeaddrinfo_ptr (ai);\n      return;\n    }\n#endif\n\n  while (ai)\n    {\n      struct addrinfo *cur;\n\n      cur = ai;\n      ai = ai->ai_next;\n\n      free (cur->ai_canonname);\n      free (cur);\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getnameinfo": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "int\ngetnameinfo (const struct sockaddr *restrict sa, socklen_t salen,\n             char *restrict node, socklen_t nodelen,\n             char *restrict service, socklen_t servicelen,\n             int flags)\n{\n#ifdef WINDOWS_NATIVE\n  if (use_win32_p ())\n    return getnameinfo_ptr (sa, salen, node, nodelen,\n                            service, servicelen, flags);\n#endif\n\n  /* FIXME: Support other flags. */\n  if ((node && nodelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (service && servicelen > 0 && !(flags & NI_NUMERICHOST)) ||\n      (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV)))\n    return EAI_BADFLAGS;\n\n  if (sa == NULL || salen < sizeof (sa->sa_family))\n    return EAI_FAMILY;\n\n  switch (sa->sa_family)\n    {\n#if HAVE_IPV4\n    case AF_INET:\n      if (salen < sizeof (struct sockaddr_in))\n        return EAI_FAMILY;\n      break;\n#endif\n#if HAVE_IPV6\n    case AF_INET6:\n      if (salen < sizeof (struct sockaddr_in6))\n        return EAI_FAMILY;\n      break;\n#endif\n    default:\n      return EAI_FAMILY;\n    }\n\n  if (node && nodelen > 0 && flags & NI_NUMERICHOST)\n    {\n      switch (sa->sa_family)\n        {\n#if HAVE_IPV4\n        case AF_INET:\n          if (!inet_ntop (AF_INET,\n                          &(((const struct sockaddr_in *) sa)->sin_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n#endif\n\n#if HAVE_IPV6\n        case AF_INET6:\n          if (!inet_ntop (AF_INET6,\n                          &(((const struct sockaddr_in6 *) sa)->sin6_addr),\n                          node, nodelen))\n            return EAI_SYSTEM;\n          break;\n#endif\n\n        default:\n          return EAI_FAMILY;\n        }\n    }\n\n  if (service && servicelen > 0 && flags & NI_NUMERICSERV)\n    switch (sa->sa_family)\n      {\n#if HAVE_IPV4\n      case AF_INET:\n#endif\n#if HAVE_IPV6\n      case AF_INET6:\n#endif\n        {\n          unsigned short int port\n            = ntohs (((const struct sockaddr_in *) sa)->sin_port);\n          if (servicelen <= snprintf (service, servicelen, \"%u\", port))\n            return EAI_OVERFLOW;\n        }\n        break;\n      }\n\n  return 0;\n}",
      "lines": 86,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getcwd-lgpl.c": {
    "rpl_getcwd": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "char *\nrpl_getcwd (char *buf, size_t size)\n{\n  char *ptr;\n  char *result;\n\n  /* Handle single size operations.  */\n  if (buf)\n    {\n      if (!size)\n        {\n          errno = EINVAL;\n          return NULL;\n        }\n      return getcwd (buf, size);\n    }\n\n  if (size)\n    {\n      buf = malloc (size);\n      if (!buf)\n        {\n          errno = ENOMEM;\n          return NULL;\n        }\n      result = getcwd (buf, size);\n      if (!result)\n        {\n          int saved_errno = errno;\n          free (buf);\n          errno = saved_errno;\n        }\n      return result;\n    }\n\n  /* Flexible sizing requested.  Avoid over-allocation for the common\n     case of a name that fits within a 4k page, minus some space for\n     local variables, to be sure we don't skip over a guard page.  */\n  {\n    char tmp[4032];\n    size = sizeof tmp;\n    ptr = getcwd (tmp, size);\n    if (ptr)\n      {\n        result = strdup (ptr);\n        if (!result)\n          errno = ENOMEM;\n        return result;\n      }\n    if (errno != ERANGE)\n      return NULL;\n  }\n\n  /* My what a large directory name we have.  */\n  do\n    {\n      size <<= 1;\n      ptr = realloc (buf, size);\n      if (ptr == NULL)\n        {\n          free (buf);\n          errno = ENOMEM;\n          return NULL;\n        }\n      buf = ptr;\n      result = getcwd (buf, size);\n    }\n  while (!result && errno == ERANGE);\n\n  if (!result)\n    {\n      int saved_errno = errno;\n      free (buf);\n      errno = saved_errno;\n    }\n  else\n    {\n      /* Trim to fit, if possible.  */\n      result = realloc (buf, strlen (buf) + 1);\n      if (!result)\n        result = buf;\n    }\n  return result;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrpl_getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getcwd.c": {
    "__getcwd": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "char *\n__getcwd (char *buf, size_t size)\n{\n  /* Lengths of big file name components and entire file names, and a\n     deep level of file name nesting.  These numbers are not upper\n     bounds; they are merely large values suitable for initial\n     allocations, designed to be large enough for most real-world\n     uses.  */\n  enum\n    {\n      BIG_FILE_NAME_COMPONENT_LENGTH = 255,\n      BIG_FILE_NAME_LENGTH = MIN (4095, PATH_MAX - 1),\n      DEEP_NESTING = 100\n    };\n\n#if HAVE_OPENAT_SUPPORT\n  int fd = AT_FDCWD;\n  bool fd_needs_closing = false;\n#else\n  char dots[DEEP_NESTING * sizeof \"..\" + BIG_FILE_NAME_COMPONENT_LENGTH + 1];\n  char *dotlist = dots;\n  size_t dotsize = sizeof dots;\n  size_t dotlen = 0;\n#endif\n  DIR *dirstream = NULL;\n  dev_t rootdev, thisdev;\n  ino_t rootino, thisino;\n  char *dir;\n  register char *dirp;\n  struct stat st;\n  size_t allocated = size;\n  size_t used;\n\n#if HAVE_MINIMALLY_WORKING_GETCWD\n  /* If AT_FDCWD is not defined, the algorithm below is O(N**2) and\n     this is much slower than the system getcwd (at least on\n     GNU/Linux).  So trust the system getcwd's results unless they\n     look suspicious.\n\n     Use the system getcwd even if we have openat support, since the\n     system getcwd works even when a parent is unreadable, while the\n     openat-based approach does not.\n\n     But on AIX 5.1..7.1, the system getcwd is not even minimally\n     working: If the current directory name is slightly longer than\n     PATH_MAX, it omits the first directory component and returns\n     this wrong result with errno = 0.  */\n\n# undef getcwd\n  dir = getcwd (buf, size);\n  if (dir || (size && errno == ERANGE))\n    return dir;\n\n  /* Solaris getcwd (NULL, 0) fails with errno == EINVAL, but it has\n     internal magic that lets it work even if an ancestor directory is\n     inaccessible, which is better in many cases.  So in this case try\n     again with a buffer that's almost always big enough.  */\n  if (errno == EINVAL && buf == NULL && size == 0)\n    {\n      char big_buffer[BIG_FILE_NAME_LENGTH + 1];\n      dir = getcwd (big_buffer, sizeof big_buffer);\n      if (dir)\n        return strdup (dir);\n    }\n\n# if HAVE_PARTLY_WORKING_GETCWD\n  /* The system getcwd works, except it sometimes fails when it\n     shouldn't, setting errno to ERANGE, ENAMETOOLONG, or ENOENT.    */\n  if (errno != ERANGE && errno != ENAMETOOLONG && errno != ENOENT)\n    return NULL;\n# endif\n#endif\n\n  if (size == 0)\n    {\n      if (buf != NULL)\n        {\n          __set_errno (EINVAL);\n          return NULL;\n        }\n\n      allocated = BIG_FILE_NAME_LENGTH + 1;\n    }\n\n  if (buf == NULL)\n    {\n      dir = malloc (allocated);\n      if (dir == NULL)\n        return NULL;\n    }\n  else\n    dir = buf;\n\n  dirp = dir + allocated;\n  *--dirp = '\\0';\n\n  if (__lstat (\".\", &st) < 0)\n    goto lose;\n  thisdev = st.st_dev;\n  thisino = st.st_ino;\n\n  if (__lstat (\"/\", &st) < 0)\n    goto lose;\n  rootdev = st.st_dev;\n  rootino = st.st_ino;\n\n  while (!(thisdev == rootdev && thisino == rootino))\n    {\n      struct dirent *d;\n      dev_t dotdev;\n      ino_t dotino;\n      bool mount_point;\n      int parent_status;\n      size_t dirroom;\n      size_t namlen;\n      bool use_d_ino = true;\n\n      /* Look at the parent directory.  */\n#if HAVE_OPENAT_SUPPORT\n      fd = openat (fd, \"..\", O_RDONLY);\n      if (fd < 0)\n        goto lose;\n      fd_needs_closing = true;\n      parent_status = fstat (fd, &st);\n#else\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen++] = '.';\n      dotlist[dotlen] = '\\0';\n      parent_status = __lstat (dotlist, &st);\n#endif\n      if (parent_status != 0)\n        goto lose;\n\n      if (dirstream && __closedir (dirstream) != 0)\n        {\n          dirstream = NULL;\n          goto lose;\n        }\n\n      /* Figure out if this directory is a mount point.  */\n      dotdev = st.st_dev;\n      dotino = st.st_ino;\n      mount_point = dotdev != thisdev;\n\n      /* Search for the last directory.  */\n#if HAVE_OPENAT_SUPPORT\n      dirstream = fdopendir (fd);\n      if (dirstream == NULL)\n        goto lose;\n      fd_needs_closing = false;\n#else\n      dirstream = __opendir (dotlist);\n      if (dirstream == NULL)\n        goto lose;\n      dotlist[dotlen++] = '/';\n#endif\n      for (;;)\n        {\n          /* Clear errno to distinguish EOF from error if readdir returns\n             NULL.  */\n          __set_errno (0);\n          d = __readdir (dirstream);\n\n          /* When we've iterated through all directory entries without finding\n             one with a matching d_ino, rewind the stream and consider each\n             name again, but this time, using lstat.  This is necessary in a\n             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where\n             .., ../.., ../../.., etc. all had the same device number, yet the\n             d_ino values for entries in / did not match those obtained\n             via lstat.  */\n          if (d == NULL && errno == 0 && use_d_ino)\n            {\n              use_d_ino = false;\n              rewinddir (dirstream);\n              d = __readdir (dirstream);\n            }\n\n          if (d == NULL)\n            {\n              if (errno == 0)\n                /* EOF on dirstream, which can mean e.g., that the current\n                   directory has been removed.  */\n                __set_errno (ENOENT);\n              goto lose;\n            }\n          if (d->d_name[0] == '.' &&\n              (d->d_name[1] == '\\0' ||\n               (d->d_name[1] == '.' && d->d_name[2] == '\\0')))\n            continue;\n\n          if (use_d_ino)\n            {\n              bool match = (MATCHING_INO (d, thisino) || mount_point);\n              if (! match)\n                continue;\n            }\n\n          {\n            int entry_status;\n#if HAVE_OPENAT_SUPPORT\n            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);\n#else\n            /* Compute size needed for this file name, or for the file\n               name \"..\" in the same directory, whichever is larger.\n               Room for \"..\" might be needed the next time through\n               the outer loop.  */\n            size_t name_alloc = _D_ALLOC_NAMLEN (d);\n            size_t filesize = dotlen + MAX (sizeof \"..\", name_alloc);\n\n            if (filesize < dotlen)\n              goto memory_exhausted;\n\n            if (dotsize < filesize)\n              {\n                /* My, what a deep directory tree you have, Grandma.  */\n                size_t newsize = MAX (filesize, dotsize * 2);\n                size_t i;\n                if (newsize < dotsize)\n                  goto memory_exhausted;\n                if (dotlist != dots)\n                  free (dotlist);\n                dotlist = malloc (newsize);\n                if (dotlist == NULL)\n                  goto lose;\n                dotsize = newsize;\n\n                i = 0;\n                do\n                  {\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '.';\n                    dotlist[i++] = '/';\n                  }\n                while (i < dotlen);\n              }\n\n            memcpy (dotlist + dotlen, d->d_name, _D_ALLOC_NAMLEN (d));\n            entry_status = __lstat (dotlist, &st);\n#endif\n            /* We don't fail here if we cannot stat() a directory entry.\n               This can happen when (network) file systems fail.  If this\n               entry is in fact the one we are looking for we will find\n               out soon as we reach the end of the directory without\n               having found anything.  */\n            if (entry_status == 0 && S_ISDIR (st.st_mode)\n                && st.st_dev == thisdev && st.st_ino == thisino)\n              break;\n          }\n        }\n\n      dirroom = dirp - dir;\n      namlen = _D_EXACT_NAMLEN (d);\n\n      if (dirroom <= namlen)\n        {\n          if (size != 0)\n            {\n              __set_errno (ERANGE);\n              goto lose;\n            }\n          else\n            {\n              char *tmp;\n              size_t oldsize = allocated;\n\n              allocated += MAX (allocated, namlen);\n              if (allocated < oldsize\n                  || ! (tmp = realloc (dir, allocated)))\n                goto memory_exhausted;\n\n              /* Move current contents up to the end of the buffer.\n                 This is guaranteed to be non-overlapping.  */\n              dirp = memcpy (tmp + allocated - (oldsize - dirroom),\n                             tmp + dirroom,\n                             oldsize - dirroom);\n              dir = tmp;\n            }\n        }\n      dirp -= namlen;\n      memcpy (dirp, d->d_name, namlen);\n      *--dirp = '/';\n\n      thisdev = dotdev;\n      thisino = dotino;\n    }\n\n  if (dirstream && __closedir (dirstream) != 0)\n    {\n      dirstream = NULL;\n      goto lose;\n    }\n\n  if (dirp == &dir[allocated - 1])\n    *--dirp = '/';\n\n#if ! HAVE_OPENAT_SUPPORT\n  if (dotlist != dots)\n    free (dotlist);\n#endif\n\n  used = dir + allocated - dirp;\n  memmove (dir, dirp, used);\n\n  if (size == 0)\n    /* Ensure that the buffer is only as large as necessary.  */\n    buf = realloc (dir, used);\n\n  if (buf == NULL)\n    /* Either buf was NULL all along, or 'realloc' failed but\n       we still have the original string.  */\n    buf = dir;\n\n  return buf;\n\n memory_exhausted:\n  __set_errno (ENOMEM);\n lose:\n  {\n    int save = errno;\n    if (dirstream)\n      __closedir (dirstream);\n#if HAVE_OPENAT_SUPPORT\n    if (fd_needs_closing)\n      close (fd);\n#else\n    if (dotlist != dots)\n      free (dotlist);\n#endif\n    if (buf == NULL)\n      free (dir);\n    __set_errno (save);\n  }\n  return NULL;\n}",
      "lines": 334,
      "depth": 18,
      "decorators": [
        "char",
        "*\n__getcwd (char *buf, size_t size)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getdomainname.c": {},
  "inetutils/inetutils-1.9.4/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
        "lines": 32,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          105,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\ngetdtablesize (void)\n{\n  struct rlimit lim;\n\n  if (getrlimit (RLIMIT_NOFILE, &lim) == 0\n      && 0 <= lim.rlim_cur && lim.rlim_cur <= INT_MAX\n      && lim.rlim_cur != RLIM_INFINITY\n      && lim.rlim_cur != RLIM_SAVED_CUR\n      && lim.rlim_cur != RLIM_SAVED_MAX)\n    return lim.rlim_cur;\n\n  return INT_MAX;\n}",
        "lines": 14,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/getgroups.c": {
    "getgroups": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetgroups (int n _GL_UNUSED, GETGROUPS_T *groups _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_getgroups": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nrpl_getgroups (int n, gid_t *group)\n{\n  int n_groups;\n  GETGROUPS_T *gbuf;\n  int saved_errno;\n\n  if (n < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (n != 0 || !GETGROUPS_ZERO_BUG)\n    {\n      int result;\n      if (sizeof *group == sizeof *gbuf)\n        return getgroups (n, (GETGROUPS_T *) group);\n\n      if (SIZE_MAX / sizeof *gbuf <= n)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      result = getgroups (n, gbuf);\n      if (0 <= result)\n        {\n          n = result;\n          while (n--)\n            group[n] = gbuf[n];\n        }\n      saved_errno = errno;\n      free (gbuf);\n      errno = saved_errno;\n      return result;\n    }\n\n  n = 20;\n  while (1)\n    {\n      /* No need to worry about address arithmetic overflow here,\n         since the ancient systems that we're running on have low\n         limits on the number of secondary groups.  */\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      n_groups = getgroups (n, gbuf);\n      if (n_groups == -1 ? errno != EINVAL : n_groups < n)\n        break;\n      free (gbuf);\n      n *= 2;\n    }\n\n  saved_errno = errno;\n  free (gbuf);\n  errno = saved_errno;\n\n  return n_groups;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/gethostname.c": {
    "gethostname": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\ngethostname (char *name, size_t len)\n{\n#ifdef HAVE_UNAME\n  struct utsname uts;\n\n  if (uname (&uts) == -1)\n    return -1;\n  if (len > sizeof (uts.nodename))\n    {\n      /* More space than we need is available.  */\n      name[sizeof (uts.nodename)] = '\\0';\n      len = sizeof (uts.nodename);\n    }\n  strncpy (name, uts.nodename, len);\n#else\n  strcpy (name, \"\");            /* Hardcode your system name if you want.  */\n#endif\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rpl_gethostname": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nrpl_gethostname (char *name, size_t len)\n{\n  int r;\n\n  if (len > INT_MAX)\n    len = INT_MAX;\n  gl_sockets_startup (SOCKETS_1_1);\n  r = gethostname (name, (int) len);\n  if (r < 0)\n    set_winsock_errno ();\n\n  return r;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getlogin_r.c": {
    "getlogin_r": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\ngetlogin_r (char *name, size_t size)\n{\n#undef getlogin_r\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* Native Windows platform.  */\n  DWORD sz;\n\n  /* When size > 0x7fff, the doc says that GetUserName will fail.\n     Actually, on Windows XP SP3, it succeeds.  But let's be safe,\n     for the sake of older Windows versions.  */\n  if (size > 0x7fff)\n    size = 0x7fff;\n  sz = size;\n  if (!GetUserName (name, &sz))\n    {\n      if (GetLastError () == ERROR_INSUFFICIENT_BUFFER)\n        /* In this case, the doc says that sz contains the required size, but\n           actually, on Windows XP SP3, it contains 2 * the required size.  */\n        return ERANGE;\n      else\n        return ENOENT;\n    }\n  return 0;\n#elif HAVE_GETLOGIN_R\n  /* Platform with a getlogin_r() function.  */\n  int ret = getlogin_r (name, size);\n\n  if (ret == 0 && memchr (name, '\\0', size) == NULL)\n    /* name contains a truncated result.  */\n    return ERANGE;\n  return ret;\n#else\n  /* Platform with a getlogin() function.  */\n  char *n;\n  size_t nlen;\n\n  errno = 0;\n  n = getlogin ();\n  if (!n)\n    /* ENOENT is a reasonable errno value if getlogin returns NULL.  */\n    return (errno != 0 ? errno : ENOENT);\n\n  nlen = strlen (n);\n  if (size <= nlen)\n    return ERANGE;\n  memcpy (name, n, nlen + 1);\n  return 0;\n#endif\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n#ifdef _LIBC\n/* malloc() not used for _LIBC to simplify failure messages.  */\n# define free_option_list(l)\n#else\n# define free_option_list(l)\t\t\t\\\n      while (l != NULL)\t\t\t\t\\\n        {\t\t\t\t\t\\\n          struct option_list *pn = l->next;\t\\\n          free (l);\t\t\t\t\\\n          l = pn;\t\t\t\t\\\n        }\n#endif\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (ambig)\n              ; /* Taking simpler path to handling ambiguities.  */\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n#ifdef _LIBC\n                struct option_list *newp = alloca (sizeof (*newp));\n#else\n                struct option_list *newp = malloc (sizeof (*newp));\n                if (newp == NULL)\n                  {\n                    free_option_list (ambig_list);\n                    ambig_list = NULL;\n                    ambig = 1; /* Use simpler fallback message.  */\n                  }\n                else\n#endif\n                  {\n                    newp->p = p;\n                    newp->next = ambig_list;\n                    ambig_list = newp;\n                  }\n              }\n          }\n\n      if ((ambig || ambig_list) && !exact)\n        {\n          if (print_errors && ambig_list)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          else if (print_errors && ambig)\n            {\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous\\n\"),\n                       argv[0], argv[d->optind]);\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          free_option_list (ambig_list);\n          return '?';\n        }\n\n      free_option_list (ambig_list);\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 811,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1156,
        0
      ],
      "end_point": [
        1175,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1185,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1272,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getopt.in.h": {},
  "inetutils/inetutils-1.9.4/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getopt_int.h": {},
  "inetutils/inetutils-1.9.4/lib/getpass.c": {
    "call_fclose": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\ncall_fclose (void *arg)\n{\n  if (arg != NULL)\n    fclose (arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getpass": [
      {
        "start_point": [
          82,
          0
        ],
        "end_point": [
          171,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  FILE *tty;\n  FILE *in, *out;\n# if HAVE_TCGETATTR\n  struct termios s, t;\n# endif\n  bool tty_changed = false;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n  /* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */\n\n  tty = fopen (\"/dev/tty\", \"w+\");\n  if (tty == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n      /* We do the locking ourselves.  */\n      __fsetlocking (tty, FSETLOCKING_BYCALLER);\n\n      out = in = tty;\n    }\n\n  flockfile (out);\n\n  /* Turn echoing off if it is on now.  */\n# if HAVE_TCGETATTR\n  if (tcgetattr (fileno (in), &t) == 0)\n    {\n      /* Save the old one. */\n      s = t;\n      /* Tricky, tricky. */\n      t.c_lflag &= ~(ECHO | ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &t) == 0);\n    }\n# endif\n\n  /* Write the prompt.  */\n  fputs_unlocked (prompt, out);\n  fflush_unlocked (out);\n\n  /* Read the password.  */\n  nread = getline (&buf, &bufsize, in);\n\n  /* According to the C standard, input may not be followed by output\n     on the same stream without an intervening call to a file\n     positioning function.  Suppose in == out; then without this fseek\n     call, on Solaris, HP-UX, AIX, OSF/1, the previous input gets\n     echoed, whereas on IRIX, the following newline is not output as\n     it should be.  POSIX imposes similar restrictions if fileno (in)\n     == fileno (out).  The POSIX restrictions are tricky and change\n     from POSIX version to POSIX version, so play it safe and invoke\n     fseek even if in != out.  */\n  fseeko (out, 0, SEEK_CUR);\n\n  if (buf != NULL)\n    {\n      if (nread < 0)\n        buf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n        {\n          /* Remove the newline.  */\n          buf[nread - 1] = '\\0';\n          if (tty_changed)\n            {\n              /* Write the newline that was not echoed.  */\n              putc_unlocked ('\\n', out);\n            }\n        }\n    }\n\n  /* Restore the original setting.  */\n# if HAVE_TCSETATTR\n  if (tty_changed)\n    tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &s);\n# endif\n\n  funlockfile (out);\n\n  call_fclose (tty);\n\n  return buf;\n}",
        "lines": 90,
        "depth": 14,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      },
      {
        "start_point": [
          189,
          0
        ],
        "end_point": [
          229,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  char getpassbuf[PASS_MAX + 1];\n  size_t i = 0;\n  int c;\n\n  if (prompt)\n    {\n      fputs (prompt, stderr);\n      fflush (stderr);\n    }\n\n  for (;;)\n    {\n      c = _getch ();\n      if (c == '\\r')\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n      else if (i < PASS_MAX)\n        {\n          getpassbuf[i++] = c;\n        }\n\n      if (i >= PASS_MAX)\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n    }\n\n  if (prompt)\n    {\n      fputs (\"\\r\\n\", stderr);\n      fflush (stderr);\n    }\n\n  return strdup (getpassbuf);\n}",
        "lines": 41,
        "depth": 12,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/getpass.h": {},
  "inetutils/inetutils-1.9.4/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/getugroups.c": {
    "getugroups": [
      {
        "start_point": [
          37,
          0
        ],
        "end_point": [
          45,
          1
        ],
        "content": "int\ngetugroups (int maxcount _GL_UNUSED,\n            gid_t *grouplist _GL_UNUSED,\n            char const *username _GL_UNUSED,\n            gid_t gid _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          59,
          0
        ],
        "end_point": [
          125,
          1
        ],
        "content": "int\ngetugroups (int maxcount, gid_t *grouplist, char const *username,\n            gid_t gid)\n{\n  int count = 0;\n\n  if (gid != (gid_t) -1)\n    {\n      if (maxcount != 0)\n        grouplist[count] = gid;\n      ++count;\n    }\n\n  setgrent ();\n  while (1)\n    {\n      char **cp;\n      struct group *grp;\n\n      errno = 0;\n      grp = getgrent ();\n      if (grp == NULL)\n        break;\n\n      for (cp = grp->gr_mem; *cp; ++cp)\n        {\n          int n;\n\n          if ( ! STREQ (username, *cp))\n            continue;\n\n          /* See if this group number is already on the list.  */\n          for (n = 0; n < count; ++n)\n            if (grouplist && grouplist[n] == grp->gr_gid)\n              break;\n\n          /* If it's a new group number, then try to add it to the list.  */\n          if (n == count)\n            {\n              if (maxcount != 0)\n                {\n                  if (count >= maxcount)\n                    goto done;\n                  grouplist[count] = grp->gr_gid;\n                }\n              if (count == INT_MAX)\n                {\n                  errno = EOVERFLOW;\n                  goto done;\n                }\n              count++;\n            }\n        }\n    }\n\n  if (errno != 0)\n    count = -1;\n\n done:\n  {\n    int saved_errno = errno;\n    endgrent ();\n    errno = saved_errno;\n  }\n\n  return count;\n}",
        "lines": 67,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/getugroups.h": {},
  "inetutils/inetutils-1.9.4/lib/getusershell.c": {
    "getusershell": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "char *\ngetusershell (void)\n{\n  if (default_index > 0)\n    {\n      if (default_shells[default_index])\n        /* Not at the end of the list yet.  */\n        return xstrdup (default_shells[default_index++]);\n      return NULL;\n    }\n\n  if (shellstream == NULL)\n    {\n      shellstream = fopen (SHELLS_FILE, \"r\");\n      if (shellstream == NULL)\n        {\n          /* No shells file.  Use the default list.  */\n          default_index = 1;\n          return xstrdup (default_shells[0]);\n        }\n    }\n\n  while (readname (&line, &line_size, shellstream))\n    {\n      if (*line != '#')\n        return line;\n    }\n  return NULL;                  /* End of file. */\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngetusershell (void)",
        "*"
      ]
    },
    "setusershell": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void\nsetusershell (void)\n{\n  default_index = 0;\n  if (shellstream)\n    rewind (shellstream);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "endusershell": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nendusershell (void)\n{\n  if (shellstream)\n    {\n      fclose (shellstream);\n      shellstream = NULL;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "readname": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static size_t\nreadname (char **name, size_t *size, FILE *stream)\n{\n  int c;\n  size_t name_index = 0;\n\n  /* Skip blank space.  */\n  while ((c = getc (stream)) != EOF && isspace (c))\n    /* Do nothing. */ ;\n\n  for (;;)\n    {\n      if (*size <= name_index)\n        *name = x2nrealloc (*name, size, sizeof **name);\n      if (c == EOF || isspace (c))\n        break;\n      (*name)[name_index++] = c;\n      c = getc (stream);\n    }\n  (*name)[name_index] = '\\0';\n  return name_index;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "main": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (void)\n{\n  char *s;\n\n  while (s = getusershell ())\n    puts (s);\n  exit (0);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/glob-libc.h": {},
  "inetutils/inetutils-1.9.4/lib/glob.c": {
    "next_brace_sub": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "static const char *\nnext_brace_sub (const char *cp, int flags)\n{\n  unsigned int depth = 0;\n  while (*cp != '\\0')\n    if ((flags & GLOB_NOESCAPE) == 0 && *cp == '\\\\')\n      {\n        if (*++cp == '\\0')\n          break;\n        ++cp;\n      }\n    else\n      {\n        if ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n          break;\n\n        if (*cp++ == '{')\n          depth++;\n      }\n\n  return *cp != '\\0' ? cp : NULL;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnext_brace_sub (const char *cp, int flags)",
        "*"
      ]
    },
    "collated_compare": {
      "start_point": [
        1115,
        0
      ],
      "end_point": [
        1128,
        1
      ],
      "content": "static int\ncollated_compare (const void *a, const void *b)\n{\n  char *const *ps1 = a; char *s1 = *ps1;\n  char *const *ps2 = b; char *s2 = *ps2;\n\n  if (s1 == s2)\n    return 0;\n  if (s1 == NULL)\n    return 1;\n  if (s2 == NULL)\n    return -1;\n  return strcoll (s1, s2);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "prefix_array": {
      "start_point": [
        1135,
        0
      ],
      "end_point": [
        1187,
        1
      ],
      "content": "static int\nprefix_array (const char *dirname, char **array, size_t n)\n{\n  register size_t i;\n  size_t dirlen = strlen (dirname);\n#if defined __MSDOS__ || defined WINDOWS32\n  int sep_char = '/';\n# define DIRSEP_CHAR sep_char\n#else\n# define DIRSEP_CHAR '/'\n#endif\n\n  if (dirlen == 1 && dirname[0] == '/')\n    /* DIRNAME is just \"/\", so normal prepending would get us \"//foo\".\n       We want \"/foo\" instead, so don't prepend any chars from DIRNAME.  */\n    dirlen = 0;\n#if defined __MSDOS__ || defined WINDOWS32\n  else if (dirlen > 1)\n    {\n      if (dirname[dirlen - 1] == '/' && dirname[dirlen - 2] == ':')\n        /* DIRNAME is \"d:/\".  Don't prepend the slash from DIRNAME.  */\n        --dirlen;\n      else if (dirname[dirlen - 1] == ':')\n        {\n          /* DIRNAME is \"d:\".  Use ':' instead of '/'.  */\n          --dirlen;\n          sep_char = ':';\n        }\n    }\n#endif\n\n  for (i = 0; i < n; ++i)\n    {\n      size_t eltlen = strlen (array[i]) + 1;\n      char *new = malloc (dirlen + 1 + eltlen);\n      if (new == NULL)\n        {\n          while (i > 0)\n            free (array[--i]);\n          return 1;\n        }\n\n      {\n        char *endp = mempcpy (new, dirname, dirlen);\n        *endp++ = DIRSEP_CHAR;\n        mempcpy (endp, array[i], eltlen);\n      }\n      free (array[i]);\n      array[i] = new;\n    }\n\n  return 0;\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "link_exists2_p": {
      "start_point": [
        1249,
        0
      ],
      "end_point": [
        1273,
        1
      ],
      "content": "static int\n__attribute_noinline__\nlink_exists2_p (const char *dir, size_t dirlen, const char *fname,\n                glob_t *pglob\n# if !defined _LIBC && !HAVE_FSTATAT\n                , int flags\n# endif\n                )\n{\n  size_t fnamelen = strlen (fname);\n  char *fullname = __alloca (dirlen + 1 + fnamelen + 1);\n  struct stat st;\n\n  mempcpy (mempcpy (mempcpy (fullname, dir, dirlen), \"/\", 1),\n           fname, fnamelen + 1);\n\n# if !defined _LIBC && !HAVE_FSTATAT\n  if (__builtin_expect ((flags & GLOB_ALTDIRFUNC) == 0, 1))\n    {\n      struct_stat64 st64;\n      return __stat64 (fullname, &st64) == 0;\n    }\n# endif\n  return (*pglob->gl_stat) (fullname, &st) == 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "__attribute_noinline__",
        "__attribute_noinline__"
      ]
    },
    "link_exists_p": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1293,
        1
      ],
      "content": "static int\nlink_exists_p (int dfd, const char *dir, size_t dirlen, const char *fname,\n               glob_t *pglob, int flags)\n{\n# if defined _LIBC || HAVE_FSTATAT\n  if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))\n    return link_exists2_p (dir, dirlen, fname, pglob);\n  else\n    {\n      /* dfd cannot be -1 here, because dirfd never returns -1 on\n         glibc, or on hosts that have fstatat.  */\n      struct_stat64 st64;\n      return __fxstatat64 (_STAT_VER, dfd, fname, &st64, 0) == 0;\n    }\n# else\n  return link_exists2_p (dir, dirlen, fname, pglob, flags);\n# endif\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glob_in_dir": {
      "start_point": [
        1301,
        0
      ],
      "end_point": [
        1554,
        1
      ],
      "content": "static int\nglob_in_dir (const char *pattern, const char *directory, int flags,\n             int (*errfunc) (const char *, int),\n             glob_t *pglob)\n{\n  size_t dirlen = strlen (directory);\n  void *stream = NULL;\n  struct globnames\n    {\n      struct globnames *next;\n      size_t count;\n      char *name[64];\n    };\n#define INITIAL_COUNT sizeof (init_names.name) / sizeof (init_names.name[0])\n  struct globnames init_names;\n  struct globnames *names = &init_names;\n  struct globnames *names_alloca = &init_names;\n  size_t nfound = 0;\n  size_t allocasize = sizeof (init_names);\n  size_t cur = 0;\n  int meta;\n  int save;\n  int result;\n\n  init_names.next = NULL;\n  init_names.count = INITIAL_COUNT;\n\n  meta = __glob_pattern_type (pattern, !(flags & GLOB_NOESCAPE));\n  if (meta == 0 && (flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n    {\n      /* We need not do any tests.  The PATTERN contains no meta\n         characters and we must not return an error therefore the\n         result will always contain exactly one name.  */\n      flags |= GLOB_NOCHECK;\n    }\n  else if (meta == 0)\n    {\n      /* Since we use the normal file functions we can also use stat()\n         to verify the file is there.  */\n      struct stat st;\n      struct_stat64 st64;\n      size_t patlen = strlen (pattern);\n      char *fullname = __alloca (dirlen + 1 + patlen + 1);\n\n      mempcpy (mempcpy (mempcpy (fullname, directory, dirlen),\n                        \"/\", 1),\n               pattern, patlen + 1);\n      if ((__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)\n           ? (*pglob->gl_stat) (fullname, &st)\n           : __stat64 (fullname, &st64)) == 0)\n        /* We found this file to be existing.  Now tell the rest\n           of the function to copy this name into the result.  */\n        flags |= GLOB_NOCHECK;\n    }\n  else\n    {\n      stream = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)\n                ? (*pglob->gl_opendir) (directory)\n                : opendir (directory));\n      if (stream == NULL)\n        {\n          if (errno != ENOTDIR\n              && ((errfunc != NULL && (*errfunc) (directory, errno))\n                  || (flags & GLOB_ERR)))\n            return GLOB_ABORTED;\n        }\n      else\n        {\n          int dfd = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)\n                     ? -1 : dirfd ((DIR *) stream));\n          int fnm_flags = ((!(flags & GLOB_PERIOD) ? FNM_PERIOD : 0)\n                           | ((flags & GLOB_NOESCAPE) ? FNM_NOESCAPE : 0)\n#if defined _AMIGA || defined VMS\n                           | FNM_CASEFOLD\n#endif\n                           );\n          flags |= GLOB_MAGCHAR;\n\n          while (1)\n            {\n              const char *name;\n              size_t len;\n#if defined _LIBC && !defined COMPILE_GLOB64\n              struct dirent64 *d;\n              union\n                {\n                  struct dirent64 d64;\n                  char room [offsetof (struct dirent64, d_name[0])\n                             + NAME_MAX + 1];\n                }\n              d64buf;\n\n              if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))\n                {\n                  struct dirent *d32 = (*pglob->gl_readdir) (stream);\n                  if (d32 != NULL)\n                    {\n                      CONVERT_DIRENT_DIRENT64 (&d64buf.d64, d32);\n                      d = &d64buf.d64;\n                    }\n                  else\n                    d = NULL;\n                }\n              else\n                d = __readdir64 (stream);\n#else\n              struct dirent *d = (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0)\n                                  ? ((struct dirent *)\n                                     (*pglob->gl_readdir) (stream))\n                                  : __readdir (stream));\n#endif\n              if (d == NULL)\n                break;\n              if (! REAL_DIR_ENTRY (d))\n                continue;\n\n              /* If we shall match only directories use the information\n                 provided by the dirent call if possible.  */\n              if ((flags & GLOB_ONLYDIR) && !DIRENT_MIGHT_BE_DIR (d))\n                continue;\n\n              name = d->d_name;\n\n              if (fnmatch (pattern, name, fnm_flags) == 0)\n                {\n                  /* If the file we found is a symlink we have to\n                     make sure the target file exists.  */\n                  if (!DIRENT_MIGHT_BE_SYMLINK (d)\n                      || link_exists_p (dfd, directory, dirlen, name, pglob,\n                                        flags))\n                    {\n                      if (cur == names->count)\n                        {\n                          struct globnames *newnames;\n                          size_t count = names->count * 2;\n                          size_t size = (sizeof (struct globnames)\n                                         + ((count - INITIAL_COUNT)\n                                            * sizeof (char *)));\n                          allocasize += size;\n                          if (__libc_use_alloca (allocasize))\n                            newnames = names_alloca = __alloca (size);\n                          else if ((newnames = malloc (size))\n                                   == NULL)\n                            goto memory_error;\n                          newnames->count = count;\n                          newnames->next = names;\n                          names = newnames;\n                          cur = 0;\n                        }\n                      len = _D_EXACT_NAMLEN (d);\n                      names->name[cur] = malloc (len + 1);\n                      if (names->name[cur] == NULL)\n                        goto memory_error;\n                      *((char *) mempcpy (names->name[cur++], name, len))\n                        = '\\0';\n                      ++nfound;\n                    }\n                }\n            }\n        }\n    }\n\n  if (nfound == 0 && (flags & GLOB_NOCHECK))\n    {\n      size_t len = strlen (pattern);\n      nfound = 1;\n      names->name[cur] = malloc (len + 1);\n      if (names->name[cur] == NULL)\n        goto memory_error;\n      *((char *) mempcpy (names->name[cur++], pattern, len)) = '\\0';\n    }\n\n  result = GLOB_NOMATCH;\n  if (nfound != 0)\n    {\n      char **new_gl_pathv\n        = realloc (pglob->gl_pathv,\n                   (pglob->gl_pathc + pglob->gl_offs + nfound + 1)\n                   * sizeof (char *));\n      result = 0;\n\n      if (new_gl_pathv == NULL)\n        {\n        memory_error:\n          while (1)\n            {\n              struct globnames *old = names;\n              size_t i;\n              for (i = 0; i < cur; ++i)\n                free (names->name[i]);\n              names = names->next;\n              /* NB: we will not leak memory here if we exit without\n                 freeing the current block assigned to OLD.  At least\n                 the very first block is always allocated on the stack\n                 and this is the block assigned to OLD here.  */\n              if (names == NULL)\n                {\n                  assert (old == &init_names);\n                  break;\n                }\n              cur = names->count;\n              if (old == names_alloca)\n                names_alloca = names;\n              else\n                free (old);\n            }\n          result = GLOB_NOSPACE;\n        }\n      else\n        {\n          while (1)\n            {\n              struct globnames *old = names;\n              size_t i;\n              for (i = 0; i < cur; ++i)\n                new_gl_pathv[pglob->gl_offs + pglob->gl_pathc++]\n                  = names->name[i];\n              names = names->next;\n              /* NB: we will not leak memory here if we exit without\n                 freeing the current block assigned to OLD.  At least\n                 the very first block is always allocated on the stack\n                 and this is the block assigned to OLD here.  */\n              if (names == NULL)\n                {\n                  assert (old == &init_names);\n                  break;\n                }\n              cur = names->count;\n              if (old == names_alloca)\n                names_alloca = names;\n              else\n                free (old);\n            }\n\n          pglob->gl_pathv = new_gl_pathv;\n\n          pglob->gl_pathv[pglob->gl_offs + pglob->gl_pathc] = NULL;\n\n          pglob->gl_flags = flags;\n        }\n    }\n\n  if (stream != NULL)\n    {\n      save = errno;\n      if (__builtin_expect (flags & GLOB_ALTDIRFUNC, 0))\n        (*pglob->gl_closedir) (stream);\n      else\n        closedir (stream);\n      __set_errno (save);\n    }\n\n  return result;\n}",
      "lines": 254,
      "depth": 27,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/glob.in.h": {},
  "inetutils/inetutils-1.9.4/lib/imaxtostr.c": {},
  "inetutils/inetutils-1.9.4/lib/inet_ntop.c": {
    "rpl_inet_ntop": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "const char *\nrpl_inet_ntop (int af, const void *restrict src,\n               char *restrict dst, socklen_t cnt)\n{\n  return inet_ntop (af, src, dst, cnt);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrpl_inet_ntop (int af, const void *restrict src,\n               char *restrict dst, socklen_t cnt)",
        "*"
      ]
    },
    "inet_ntop": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "const char *\ninet_ntop (int af, const void *restrict src,\n           char *restrict dst, socklen_t cnt)\n{\n  switch (af)\n    {\n# if HAVE_IPV4\n    case AF_INET:\n      return (inet_ntop4 (src, dst, cnt));\n# endif\n\n# if HAVE_IPV6\n    case AF_INET6:\n      return (inet_ntop6 (src, dst, cnt));\n# endif\n\n    default:\n      errno = EAFNOSUPPORT;\n      return (NULL);\n    }\n  /* NOTREACHED */\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ninet_ntop (int af, const void *restrict src,\n           char *restrict dst, socklen_t cnt)",
        "*"
      ]
    },
    "inet_ntop4": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static const char *\ninet_ntop4 (const unsigned char *src, char *dst, socklen_t size)\n{\n  char tmp[sizeof \"255.255.255.255\"];\n  int len;\n\n  len = sprintf (tmp, \"%u.%u.%u.%u\", src[0], src[1], src[2], src[3]);\n  if (len < 0)\n    return NULL;\n\n  if (len > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninet_ntop4 (const unsigned char *src, char *dst, socklen_t size)",
        "*"
      ]
    },
    "inet_ntop6": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static const char *\ninet_ntop6 (const unsigned char *src, char *dst, socklen_t size)\n{\n  /*\n   * Note that int32_t and int16_t need only be \"at least\" large enough\n   * to contain a value of the specified size.  On some systems, like\n   * Crays, there is no such thing as an integer variable with 16 bits.\n   * Keep this in mind if you think this function should have been coded\n   * to use pointer overlays.  All the world's not a VAX.\n   */\n  char tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n  struct\n  {\n    int base, len;\n  } best, cur;\n  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n  int i;\n\n  /*\n   * Preprocess:\n   *      Copy the input (bytewise) array into a wordwise array.\n   *      Find the longest run of 0x00's in src[] for :: shorthanding.\n   */\n  memset (words, '\\0', sizeof words);\n  for (i = 0; i < NS_IN6ADDRSZ; i += 2)\n    words[i / 2] = (src[i] << 8) | src[i + 1];\n  best.base = -1;\n  cur.base = -1;\n  IF_LINT(best.len = 0);\n  IF_LINT(cur.len = 0);\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n      if (words[i] == 0)\n        {\n          if (cur.base == -1)\n            cur.base = i, cur.len = 1;\n          else\n            cur.len++;\n        }\n      else\n        {\n          if (cur.base != -1)\n            {\n              if (best.base == -1 || cur.len > best.len)\n                best = cur;\n              cur.base = -1;\n            }\n        }\n    }\n  if (cur.base != -1)\n    {\n      if (best.base == -1 || cur.len > best.len)\n        best = cur;\n    }\n  if (best.base != -1 && best.len < 2)\n    best.base = -1;\n\n  /*\n   * Format the result.\n   */\n  tp = tmp;\n  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n    {\n      /* Are we inside the best run of 0x00's? */\n      if (best.base != -1 && i >= best.base && i < (best.base + best.len))\n        {\n          if (i == best.base)\n            *tp++ = ':';\n          continue;\n        }\n      /* Are we following an initial run of 0x00s or any real hex? */\n      if (i != 0)\n        *tp++ = ':';\n      /* Is this address an encapsulated IPv4? */\n      if (i == 6 && best.base == 0 &&\n          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))\n        {\n          if (!inet_ntop4 (src + 12, tp, sizeof tmp - (tp - tmp)))\n            return (NULL);\n          tp += strlen (tp);\n          break;\n        }\n      {\n        int len = sprintf (tp, \"%x\", words[i]);\n        if (len < 0)\n          return NULL;\n        tp += len;\n      }\n    }\n  /* Was it a trailing run of 0x00's? */\n  if (best.base != -1 && (best.base + best.len) ==\n      (NS_IN6ADDRSZ / NS_INT16SZ))\n    *tp++ = ':';\n  *tp++ = '\\0';\n\n  /*\n   * Check for overflow, copy, and we're done.\n   */\n  if ((socklen_t) (tp - tmp) > size)\n    {\n      errno = ENOSPC;\n      return NULL;\n    }\n\n  return strcpy (dst, tmp);\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ninet_ntop6 (const unsigned char *src, char *dst, socklen_t size)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/intprops.h": {},
  "inetutils/inetutils-1.9.4/lib/inttostr.c": {},
  "inetutils/inetutils-1.9.4/lib/inttostr.h": {},
  "inetutils/inetutils-1.9.4/lib/ioctl.c": {
    "rpl_ioctl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nrpl_ioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *buf;\n  va_list args;\n\n  va_start (args, request);\n  buf = va_arg (args, void *);\n  va_end (args);\n\n  /* Cast 'request' so that when the system's ioctl function takes a 64-bit\n     request argument, the value gets zero-extended, not sign-extended.  */\n  return ioctl (fd, (unsigned int) request, buf);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "primary_ioctl": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nprimary_ioctl (int fd, int request, void *arg)\n{\n  /* We don't support FIONBIO on pipes here.  If you want to make pipe\n     fds non-blocking, use the gnulib 'nonblocking' module, until\n     gnulib implements fcntl F_GETFL / F_SETFL with O_NONBLOCK.  */\n\n  if ((HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE)\n    errno = ENOSYS;\n  else\n    errno = EBADF;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nioctl (int fd, int request, ... /* {void *,char *} arg */)\n{\n  void *arg;\n  va_list args;\n\n  va_start (args, request);\n  arg = va_arg (args, void *);\n  va_end (args);\n\n# if WINDOWS_SOCKETS\n  return execute_all_ioctl_hooks (primary_ioctl, fd, request, arg);\n# else\n  return primary_ioctl (fd, request, arg);\n# endif\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/langinfo.in.h": {},
  "inetutils/inetutils-1.9.4/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__ || defined OS2)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n# if defined OS2\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      /* The list of encodings is taken from \"List of OS/2 Codepages\"\n         by Alex Taylor:\n         <http://altsan.org/os2/toolkits/uls/index.html#codepages>.\n         See also \"IBM Globalization - Code page identifiers\":\n         <http://www-01.ibm.com/software/globalization/cp/cp_cpgid.html>.  */\n      cp = \"CP813\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP878\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP819\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP912\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP913\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP914\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP915\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP916\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP920\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP921\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"CP923\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP954\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP964\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP970\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP1089\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP1208\" \"\\0\" \"UTF-8\" \"\\0\"\n           \"CP1381\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP1386\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP3372\" \"\\0\" \"EUC-JP\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 259,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as\n     a number, but the value doesn't change according to what the\n     'setlocale' call specified.  So we use it as a last resort, in\n     case the string returned by 'setlocale' doesn't specify the\n     codepage.  */\n  char *current_locale = setlocale (LC_ALL, NULL);\n  char *pdot;\n\n  /* If they set different locales for different categories,\n     'setlocale' will return a semi-colon separated list of locale\n     values.  To make sure we use the correct one, we choose LC_CTYPE.  */\n  if (strchr (current_locale, ';'))\n    current_locale = setlocale (LC_CTYPE, NULL);\n\n  pdot = strrchr (current_locale, '.');\n  if (pdot)\n    sprintf (buf, \"CP%s\", pdot + 1);\n  else\n    {\n      /* The Windows API has a function returning the locale's codepage as a\n        number: GetACP().\n        When the output goes to a console window, it needs to be provided in\n        GetOEMCP() encoding if the console is using a raster font, or in\n        GetConsoleOutputCP() encoding if it is using a TrueType font.\n        But in GUI programs and for output sent to files and pipes, GetACP()\n        encoding is the best bet.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n    }\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  codeset = NULL;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* For the POSIX locale, don't use the system's codepage.  */\n      if (strcmp (locale, \"C\") == 0 || strcmp (locale, \"POSIX\") == 0)\n        codeset = \"\";\n    }\n\n  if (codeset == NULL)\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 222,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/localcharset.h": {},
  "inetutils/inetutils-1.9.4/lib/locale.in.h": {},
  "inetutils/inetutils-1.9.4/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/login_tty.c": {
    "login_tty": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nlogin_tty (int slave_fd)\n{\n  int i;\n\n  /* Create a new session.  */\n  setsid ();\n\n  /* Make fd the controlling terminal for the current process.\n     On BSD and OSF/1: There is ioctl TIOCSCTTY for this purpose.\n     On Solaris:\n       A terminal becomes the controlling terminal of a session\n       if it is being open()ed, at a moment when\n         1. it is not already the controlling terminal of some session, and\n         2. the process that open()s it is a session leader that does not have\n            a controlling terminal.\n       We assume condition 1, try to ensure condition 2, and then open() it.\n   */\n  for (i = 0; i < 3; i++)\n    if (i != slave_fd)\n      close (i);\n#ifdef TIOCSCTTY\n  if (ioctl (slave_fd, TIOCSCTTY, NULL) < 0)\n    return -1;\n#else\n  {\n    char *slave_name;\n    int dummy_fd;\n\n    slave_name = ttyname (slave_fd);\n    if (slave_name == NULL)\n      return -1;\n    dummy_fd = open (slave_name, O_RDWR);\n    if (dummy_fd < 0)\n      return -1;\n    close (dummy_fd);\n  }\n#endif\n\n  /* Assign fd to the standard input, standard output, and standard error of\n     the current process.  */\n  for (i = 0; i < 3; i++)\n    if (slave_fd != i)\n      if (dup2 (slave_fd, i) < 0)\n        return -1;\n  if (slave_fd >= 3)\n    close (slave_fd);\n\n  return 0;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/malloca.h": {},
  "inetutils/inetutils-1.9.4/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG || MBRTOWC_EMPTY_INPUT_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_EMPTY_INPUT_BUG\n  if (n == 0)\n    return (size_t) -2;\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/mbsrtowcs-impl.h": {
    "mbsrtowcs": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "size_t\nmbsrtowcs (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &_gl_mbsrtowcs_state;\n  {\n    const char *src = *srcp;\n\n    if (dest != NULL)\n      {\n        wchar_t *destptr = dest;\n\n        for (; len > 0; destptr++, len--)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (destptr, src, src_avail, ps);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input;\n            if (ret == 0)\n              {\n                src = NULL;\n                /* Here mbsinit (ps).  */\n                break;\n              }\n            src += ret;\n          }\n\n        *srcp = src;\n        return destptr - dest;\n      }\n    else\n      {\n        /* Ignore dest and len, don't store *srcp at the end, and\n           don't clobber *ps.  */\n        mbstate_t state = *ps;\n        size_t totalcount = 0;\n\n        for (;; totalcount++)\n          {\n            size_t src_avail;\n            size_t ret;\n\n            /* An optimized variant of\n               src_avail = strnlen1 (src, MB_LEN_MAX);  */\n            if (src[0] == '\\0')\n              src_avail = 1;\n            else if (src[1] == '\\0')\n              src_avail = 2;\n            else if (src[2] == '\\0')\n              src_avail = 3;\n            else if (MB_LEN_MAX <= 4 || src[3] == '\\0')\n              src_avail = 4;\n            else\n              src_avail = 4 + strnlen1 (src + 4, MB_LEN_MAX - 4);\n\n            /* Parse the next multibyte character.  */\n            ret = mbrtowc (NULL, src, src_avail, &state);\n\n            if (ret == (size_t)(-2))\n              /* Encountered a multibyte character that extends past a '\\0' byte\n                 or that is longer than MB_LEN_MAX bytes.  Cannot happen.  */\n              abort ();\n\n            if (ret == (size_t)(-1))\n              goto bad_input2;\n            if (ret == 0)\n              {\n                /* Here mbsinit (&state).  */\n                break;\n              }\n            src += ret;\n          }\n\n        return totalcount;\n      }\n\n   bad_input:\n    *srcp = src;\n   bad_input2:\n    errno = EILSEQ;\n    return (size_t)(-1);\n  }\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mbsrtowcs-state.c": {},
  "inetutils/inetutils-1.9.4/lib/mbsrtowcs.c": {},
  "inetutils/inetutils-1.9.4/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mbtowc.c": {},
  "inetutils/inetutils-1.9.4/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mempcpy.c": {
    "mempcpy": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (char *) memcpy (dest, src, n) + n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nmempcpy (void *dest, const void *src, size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/memrchr.c": {
    "__memrchr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *\n__memrchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the last few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s + n;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n)\n    if (*--char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *--longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        {\n          longword_ptr++;\n          break;\n        }\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  while (n-- > 0)\n    {\n      if (*--char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memrchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mgetgroups.c": {
    "realloc_groupbuf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static gid_t *\nrealloc_groupbuf (gid_t *g, size_t num)\n{\n  if (xalloc_oversized (num, sizeof *g))\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n\n  return realloc (g, num * sizeof *g);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gid_t",
        "*\nrealloc_groupbuf (gid_t *g, size_t num)",
        "*"
      ]
    },
    "mgetgroups": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\nmgetgroups (char const *username, gid_t gid, gid_t **groups)\n{\n  int max_n_groups;\n  int ng;\n  gid_t *g;\n\n#if HAVE_GETGROUPLIST\n  /* We prefer to use getgrouplist if available, because it has better\n     performance characteristics.\n\n     In glibc 2.3.2, getgrouplist is buggy.  If you pass a zero as the\n     length of the output buffer, getgrouplist will still write to the\n     buffer.  Contrary to what some versions of the getgrouplist\n     manpage say, this doesn't happen with nonzero buffer sizes.\n     Therefore our usage here just avoids a zero sized buffer.  */\n  if (username)\n    {\n      enum { N_GROUPS_INIT = 10 };\n      max_n_groups = N_GROUPS_INIT;\n\n      g = realloc_groupbuf (NULL, max_n_groups);\n      if (g == NULL)\n        return -1;\n\n      while (1)\n        {\n          gid_t *h;\n          int last_n_groups = max_n_groups;\n\n          /* getgrouplist updates max_n_groups to num required.  */\n          ng = getgrouplist (username, gid, g, &max_n_groups);\n\n          /* Some systems (like Darwin) have a bug where they\n             never increase max_n_groups.  */\n          if (ng < 0 && last_n_groups == max_n_groups)\n            max_n_groups *= 2;\n\n          if ((h = realloc_groupbuf (g, max_n_groups)) == NULL)\n            {\n              int saved_errno = errno;\n              free (g);\n              errno = saved_errno;\n              return -1;\n            }\n          g = h;\n\n          if (0 <= ng)\n            {\n              *groups = g;\n              /* On success some systems just return 0 from getgrouplist,\n                 so return max_n_groups rather than ng.  */\n              return max_n_groups;\n            }\n        }\n    }\n  /* else no username, so fall through and use getgroups. */\n#endif\n\n  max_n_groups = (username\n                  ? getugroups (0, NULL, username, gid)\n                  : getgroups (0, NULL));\n\n  /* If we failed to count groups because there is no supplemental\n     group support, then return an array containing just GID.\n     Otherwise, we fail for the same reason.  */\n  if (max_n_groups < 0)\n    {\n      if (errno == ENOSYS && (g = realloc_groupbuf (NULL, 1)))\n        {\n          *groups = g;\n          *g = gid;\n          return gid != (gid_t) -1;\n        }\n      return -1;\n    }\n\n  if (max_n_groups == 0 || (!username && gid != (gid_t) -1))\n    max_n_groups++;\n  g = realloc_groupbuf (NULL, max_n_groups);\n  if (g == NULL)\n    return -1;\n\n  ng = (username\n        ? getugroups (max_n_groups, g, username, gid)\n        : getgroups (max_n_groups - (gid != (gid_t) -1),\n                                g + (gid != (gid_t) -1)));\n\n  if (ng < 0)\n    {\n      /* Failure is unexpected, but handle it anyway.  */\n      int saved_errno = errno;\n      free (g);\n      errno = saved_errno;\n      return -1;\n    }\n\n  if (!username && gid != (gid_t) -1)\n    {\n      *g = gid;\n      ng++;\n    }\n  *groups = g;\n\n  /* Reduce the number of duplicates.  On some systems, getgroups\n     returns the effective gid twice: once as the first element, and\n     once in its position within the supplementary groups.  On other\n     systems, getgroups does not return the effective gid at all,\n     which is why we provide a GID argument.  Meanwhile, the GID\n     argument, if provided, is typically any member of the\n     supplementary groups, and not necessarily the effective gid.  So,\n     the most likely duplicates are the first element with an\n     arbitrary other element, or pair-wise duplication between the\n     first and second elements returned by getgroups.  It is possible\n     that this O(n) pass will not remove all duplicates, but it is not\n     worth the effort to slow down to an O(n log n) algorithm that\n     sorts the array in place, nor the extra memory needed for\n     duplicate removal via an O(n) hash-table.  Hence, this function\n     is only documented as guaranteeing no pair-wise duplicates,\n     rather than returning the minimal set.  */\n  if (1 < ng)\n    {\n      gid_t first = *g;\n      gid_t *next;\n      gid_t *groups_end = g + ng;\n\n      for (next = g + 1; next < groups_end; next++)\n        {\n          if (*next == first || *next == *g)\n            ng--;\n          else\n            *++g = *next;\n        }\n    }\n\n  return ng;\n}",
      "lines": 137,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/mgetgroups.h": {},
  "inetutils/inetutils-1.9.4/lib/minmax.h": {},
  "inetutils/inetutils-1.9.4/lib/mkstemp.c": {
    "mkstemp": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmkstemp (char *xtemplate)\n{\n  return __gen_tempname (xtemplate, 0, 0, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/msvc-inval.h": {},
  "inetutils/inetutils-1.9.4/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/msvc-nothrow.h": {},
  "inetutils/inetutils-1.9.4/lib/netdb.in.h": {},
  "inetutils/inetutils-1.9.4/lib/netinet_in.in.h": {},
  "inetutils/inetutils-1.9.4/lib/nl_langinfo.c": {
    "ctype_codeset": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static char *\nctype_codeset (void)\n{\n  static char buf[2 + 10 + 1];\n  size_t buflen = 0;\n  char const *locale = setlocale (LC_CTYPE, NULL);\n  char *codeset = buf;\n  size_t codesetlen;\n  codeset[0] = '\\0';\n\n  if (locale && locale[0])\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      char *dot = strchr (locale, '.');\n\n      if (dot)\n        {\n          /* Look for the possible @... trailer and remove it, if any.  */\n          char *codeset_start = dot + 1;\n          char const *modifier = strchr (codeset_start, '@');\n\n          if (! modifier)\n            codeset = codeset_start;\n          else\n            {\n              codesetlen = modifier - codeset_start;\n              if (codesetlen < sizeof buf)\n                {\n                  codeset = memcpy (buf, codeset_start, codesetlen);\n                  codeset[codesetlen] = '\\0';\n                }\n            }\n        }\n    }\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* If setlocale is successful, it returns the number of the\n     codepage, as a string.  Otherwise, fall back on Windows API\n     GetACP, which returns the locale's codepage as a number (although\n     this doesn't change according to what the 'setlocale' call specified).\n     Either way, prepend \"CP\" to make it a valid codeset name.  */\n  codesetlen = strlen (codeset);\n  if (0 < codesetlen && codesetlen < sizeof buf - 2)\n    memmove (buf + 2, codeset, codesetlen + 1);\n  else\n    sprintf (buf + 2, \"%u\", GetACP ());\n  codeset = memcpy (buf, \"CP\", 2);\n#endif\n  return codeset;\n}",
      "lines": 50,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nctype_codeset (void)",
        "*"
      ]
    },
    "rpl_nl_langinfo": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      return ctype_codeset ();\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  static char nlbuf[100];\n  struct tm tmm = { 0 };\n\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n      {\n        char *codeset = ctype_codeset ();\n        if (*codeset)\n          return codeset;\n      }\n# ifdef __BEOS__\n      return \"UTF-8\";\n# else\n      return \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    case GROUPING:\n      return localeconv () ->grouping;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n    case AM_STR:\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return \"AM\";\n      return nlbuf;\n    case PM_STR:\n      tmm.tm_hour = 12;\n      if (!strftime (nlbuf, sizeof nlbuf, \"%p\", &tmm))\n        return \"PM\";\n      return nlbuf;\n    case DAY_1:\n    case DAY_2:\n    case DAY_3:\n    case DAY_4:\n    case DAY_5:\n    case DAY_6:\n    case DAY_7:\n      {\n        static char const days[][sizeof \"Wednesday\"] = {\n          \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n          \"Friday\", \"Saturday\"\n        };\n        tmm.tm_wday = item - DAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%A\", &tmm))\n          return (char *) days[item - DAY_1];\n        return nlbuf;\n      }\n    case ABDAY_1:\n    case ABDAY_2:\n    case ABDAY_3:\n    case ABDAY_4:\n    case ABDAY_5:\n    case ABDAY_6:\n    case ABDAY_7:\n      {\n        static char const abdays[][sizeof \"Sun\"] = {\n          \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n        };\n        tmm.tm_wday = item - ABDAY_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%a\", &tmm))\n          return (char *) abdays[item - ABDAY_1];\n        return nlbuf;\n      }\n    case MON_1:\n    case MON_2:\n    case MON_3:\n    case MON_4:\n    case MON_5:\n    case MON_6:\n    case MON_7:\n    case MON_8:\n    case MON_9:\n    case MON_10:\n    case MON_11:\n    case MON_12:\n      {\n        static char const months[][sizeof \"September\"] = {\n          \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n          \"September\", \"October\", \"November\", \"December\"\n        };\n        tmm.tm_mon = item - MON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%B\", &tmm))\n          return (char *) months[item - MON_1];\n        return nlbuf;\n      }\n    case ABMON_1:\n    case ABMON_2:\n    case ABMON_3:\n    case ABMON_4:\n    case ABMON_5:\n    case ABMON_6:\n    case ABMON_7:\n    case ABMON_8:\n    case ABMON_9:\n    case ABMON_10:\n    case ABMON_11:\n    case ABMON_12:\n      {\n        static char const abmonths[][sizeof \"Jan\"] = {\n          \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\",\n          \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n        };\n        tmm.tm_mon = item - ABMON_1;\n        if (!strftime (nlbuf, sizeof nlbuf, \"%b\", &tmm))\n          return (char *) abmonths[item - ABMON_1];\n        return nlbuf;\n      }\n    case ERA:\n      return \"\";\n    case ALT_DIGITS:\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category.  */\n    case CRNCYSTR:\n      return localeconv () ->currency_symbol;\n    case INT_CURR_SYMBOL:\n      return localeconv () ->int_curr_symbol;\n    case MON_DECIMAL_POINT:\n      return localeconv () ->mon_decimal_point;\n    case MON_THOUSANDS_SEP:\n      return localeconv () ->mon_thousands_sep;\n    case MON_GROUPING:\n      return localeconv () ->mon_grouping;\n    case POSITIVE_SIGN:\n      return localeconv () ->positive_sign;\n    case NEGATIVE_SIGN:\n      return localeconv () ->negative_sign;\n    case FRAC_DIGITS:\n      return & localeconv () ->frac_digits;\n    case INT_FRAC_DIGITS:\n      return & localeconv () ->int_frac_digits;\n    case P_CS_PRECEDES:\n      return & localeconv () ->p_cs_precedes;\n    case N_CS_PRECEDES:\n      return & localeconv () ->n_cs_precedes;\n    case P_SEP_BY_SPACE:\n      return & localeconv () ->p_sep_by_space;\n    case N_SEP_BY_SPACE:\n      return & localeconv () ->n_sep_by_space;\n    case P_SIGN_POSN:\n      return & localeconv () ->p_sign_posn;\n    case N_SIGN_POSN:\n      return & localeconv () ->n_sign_posn;\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n    default:\n      return \"\";\n    }\n}",
      "lines": 171,
      "depth": 13,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/obstack.c": {
    "call_chunkfun": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void *\ncall_chunkfun (struct obstack *h, size_t size)\n{\n  if (h->use_extra_arg)\n    return h->chunkfun.extra (h->extra_arg, size);\n  else\n    return h->chunkfun.plain (size);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ncall_chunkfun (struct obstack *h, size_t size)",
        "*"
      ]
    },
    "call_freefun": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ncall_freefun (struct obstack *h, void *old_chunk)\n{\n  if (h->use_extra_arg)\n    h->freefun.extra (h->extra_arg, old_chunk);\n  else\n    h->freefun.plain (old_chunk);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_obstack_begin_worker": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static int\n_obstack_begin_worker (struct obstack *h,\n                       _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment)\n{\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n\n  chunk = h->chunk = call_chunkfun (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 40,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_obstack_begin": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                void *(*chunkfun) (size_t),\n                void (*freefun) (void *))\n{\n  h->chunkfun.plain = chunkfun;\n  h->freefun.plain = freefun;\n  h->use_extra_arg = 0;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h,\n                  _OBSTACK_SIZE_T size, _OBSTACK_SIZE_T alignment,\n                  void *(*chunkfun) (void *, size_t),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  h->chunkfun.extra = chunkfun;\n  h->freefun.extra = freefun;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n  return _obstack_begin_worker (h, size, alignment);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, _OBSTACK_SIZE_T length)\n{\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk = 0;\n  size_t obj_size = h->next_free - h->object_base;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  size_t sum1 = obj_size + length;\n  size_t sum2 = sum1 + h->alignment_mask;\n  size_t new_size = sum2 + (obj_size >> 3) + 100;\n  if (new_size < sum2)\n    new_size = sum2;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  if (obj_size <= sum1 && sum1 <= sum2)\n    new_chunk = call_chunkfun (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.  */\n  memcpy (object_base, h->object_base, obj_size);\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (!h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      call_freefun (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_obstack_free": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\n_obstack_free (struct obstack *h, void *obj)\n{\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      call_freefun (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "_OBSTACK_SIZE_T\n_obstack_memory_used (struct obstack *h)\n{\n  struct _obstack_chunk *lp;\n  _OBSTACK_SIZE_T nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "_OBSTACK_SIZE_T"
      ]
    },
    "print_and_abort": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n#  ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n#  else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n#  endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/obstack.h": {},
  "inetutils/inetutils-1.9.4/lib/offtostr.c": {},
  "inetutils/inetutils-1.9.4/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/openat-die.c": {
    "openat_save_fail": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "_Noreturn void\nopenat_save_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"unable to record current working directory\"));\n#endif\n  /* _Noreturn cannot be applied to error, since it returns\n     when its first argument is 0.  To help compilers understand that this\n     function does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    },
    "openat_restore_fail": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "_Noreturn void\nopenat_restore_fail (int errnum)\n{\n#ifndef GNULIB_LIBPOSIX\n  error (exit_failure, errnum,\n         _(\"failed to return to initial working directory\"));\n#endif\n\n  /* As above.  */\n  abort ();\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/openat-priv.h": {},
  "inetutils/inetutils-1.9.4/lib/openat-proc.c": {
    "openat_proc_name": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "char *\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)\n{\n  static int proc_status = 0;\n\n  /* Make sure the caller gets ENOENT when appropriate.  */\n  if (!*file)\n    {\n      buf[0] = '\\0';\n      return buf;\n    }\n\n  if (! proc_status)\n    {\n      /* Set PROC_STATUS to a positive value if /proc/self/fd is\n         reliable, and a negative value otherwise.  Solaris 10\n         /proc/self/fd mishandles \"..\", and any file name might expand\n         to \"..\" after symbolic link expansion, so avoid /proc/self/fd\n         if it mishandles \"..\".  Solaris 10 has openat, but this\n         problem is exhibited on code that built on Solaris 8 and\n         running on Solaris 10.  */\n\n      int proc_self_fd = open (\"/proc/self/fd\",\n                               O_SEARCH | O_DIRECTORY | O_NOCTTY | O_NONBLOCK);\n      if (proc_self_fd < 0)\n        proc_status = -1;\n      else\n        {\n          /* Detect whether /proc/self/fd/%i/../fd exists, where %i is the\n             number of a file descriptor open on /proc/self/fd.  On Linux,\n             that name resolves to /proc/self/fd, which was opened above.\n             However, on Solaris, it may resolve to /proc/self/fd/fd, which\n             cannot exist, since all names in /proc/self/fd are numeric.  */\n          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof \"../fd\" - 1)];\n          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, \"../fd\");\n          proc_status = access (dotdot_buf, F_OK) ? -1 : 1;\n          close (proc_self_fd);\n        }\n    }\n\n  if (proc_status < 0)\n    return NULL;\n  else\n    {\n      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));\n      char *result = buf;\n      if (OPENAT_BUFFER_SIZE < bufsize)\n        {\n          result = malloc (bufsize);\n          if (! result)\n            return NULL;\n        }\n      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);\n      return result;\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "char",
        "*\nopenat_proc_name (char buf[OPENAT_BUFFER_SIZE], int fd, char const *file)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/openat.c": {
    "orig_openat": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static int\norig_openat (int fd, char const *filename, int flags, mode_t mode)\n{\n  return openat (fd, filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_openat": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\nrpl_openat (int dfd, char const *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n# endif\n\n  fd = orig_openat (dfd, filename, flags, mode);\n\n# if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n# endif\n\n  return fd;\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "openat": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nopenat (int fd, char const *file, int flags, ...)\n{\n  mode_t mode = 0;\n\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n  return openat_permissive (fd, file, flags, mode, NULL);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openat_permissive": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\nopenat_permissive (int fd, char const *file, int flags, mode_t mode,\n                   int *cwd_errno)\n{\n  struct saved_cwd saved_cwd;\n  int saved_errno;\n  int err;\n  bool save_ok;\n\n  if (fd == AT_FDCWD || IS_ABSOLUTE_FILE_NAME (file))\n    return open (file, flags, mode);\n\n  {\n    char buf[OPENAT_BUFFER_SIZE];\n    char *proc_file = openat_proc_name (buf, fd, file);\n    if (proc_file)\n      {\n        int open_result = open (proc_file, flags, mode);\n        int open_errno = errno;\n        if (proc_file != buf)\n          free (proc_file);\n        /* If the syscall succeeds, or if it fails with an unexpected\n           errno value, then return right away.  Otherwise, fall through\n           and resort to using save_cwd/restore_cwd.  */\n        if (0 <= open_result || ! EXPECTED_ERRNO (open_errno))\n          {\n            errno = open_errno;\n            return open_result;\n          }\n      }\n  }\n\n  save_ok = (save_cwd (&saved_cwd) == 0);\n  if (! save_ok)\n    {\n      if (! cwd_errno)\n        openat_save_fail (errno);\n      *cwd_errno = errno;\n    }\n  if (0 <= fd && fd == saved_cwd.desc)\n    {\n      /* If saving the working directory collides with the user's\n         requested fd, then the user's fd must have been closed to\n         begin with.  */\n      free_cwd (&saved_cwd);\n      errno = EBADF;\n      return -1;\n    }\n\n  err = fchdir (fd);\n  saved_errno = errno;\n\n  if (! err)\n    {\n      err = open (file, flags, mode);\n      saved_errno = errno;\n      if (save_ok && restore_cwd (&saved_cwd) != 0)\n        {\n          if (! cwd_errno)\n            {\n              /* Don't write a message to just-created fd 2.  */\n              saved_errno = errno;\n              if (err == STDERR_FILENO)\n                close (err);\n              openat_restore_fail (saved_errno);\n            }\n          *cwd_errno = errno;\n        }\n    }\n\n  free_cwd (&saved_cwd);\n  errno = saved_errno;\n  return err;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "openat_needs_fchdir": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "bool\nopenat_needs_fchdir (void)\n{\n  bool needs_fchdir = true;\n  int fd = open (\"/\", O_SEARCH);\n\n  if (0 <= fd)\n    {\n      char buf[OPENAT_BUFFER_SIZE];\n      char *proc_file = openat_proc_name (buf, fd, \".\");\n      if (proc_file)\n        {\n          needs_fchdir = false;\n          if (proc_file != buf)\n            free (proc_file);\n        }\n      close (fd);\n    }\n\n  return needs_fchdir;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/openat.h": {
    "chownat": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchownat": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "FCHOWNAT_INLINE int\nlchownat (int fd, char const *file, uid_t owner, gid_t group)\n{\n  return fchownat (fd, file, owner, group, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHOWNAT_INLINE",
        "int",
        "int"
      ]
    },
    "chmodat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "FCHMODAT_INLINE int\nchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "lchmodat": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "FCHMODAT_INLINE int\nlchmodat (int fd, char const *file, mode_t mode)\n{\n  return fchmodat (fd, file, mode, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "FCHMODAT_INLINE",
        "int",
        "int"
      ]
    },
    "statat": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "STATAT_INLINE int\nstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    },
    "lstatat": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "STATAT_INLINE int\nlstatat (int fd, char const *name, struct stat *st)\n{\n  return fstatat (fd, name, st, AT_SYMLINK_NOFOLLOW);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "STATAT_INLINE",
        "int",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/opendir.c": {
    "opendir": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "DIR *\nopendir (const char *dir_name)\n{\n#if HAVE_OPENDIR\n# undef opendir\n  DIR *dirp;\n\n  dirp = opendir (dir_name);\n  if (dirp == NULL)\n    return NULL;\n\n#else\n\n  char dir_name_mask[MAX_PATH + 1 + 1 + 1];\n  int status;\n  HANDLE current;\n  WIN32_FIND_DATA entry;\n  struct gl_directory *dirp;\n\n  if (dir_name[0] == '\\0')\n    {\n      errno = ENOENT;\n      return NULL;\n    }\n\n  /* Make the dir_name absolute, so that we continue reading the same\n     directory if the current directory changed between this opendir()\n     call and a subsequent rewinddir() call.  */\n  if (!GetFullPathName (dir_name, MAX_PATH, dir_name_mask, NULL))\n    {\n      errno = EINVAL;\n      return NULL;\n    }\n\n  /* Append the mask.\n     \"*\" and \"*.*\" appear to be equivalent.  */\n  {\n    char *p;\n\n    p = dir_name_mask + strlen (dir_name_mask);\n    if (p > dir_name_mask && !ISSLASH (p[-1]))\n      *p++ = '\\\\';\n    *p++ = '*';\n    *p = '\\0';\n  }\n\n  /* Start searching the directory.  */\n  status = -1;\n  current = FindFirstFile (dir_name_mask, &entry);\n  if (current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          status = -2;\n          break;\n        case ERROR_PATH_NOT_FOUND:\n          errno = ENOENT;\n          return NULL;\n        case ERROR_DIRECTORY:\n          errno = ENOTDIR;\n          return NULL;\n        case ERROR_ACCESS_DENIED:\n          errno = EACCES;\n          return NULL;\n        default:\n          errno = EIO;\n          return NULL;\n        }\n    }\n\n  /* Allocate the result.  */\n  dirp =\n    (struct gl_directory *)\n    malloc (offsetof (struct gl_directory, dir_name_mask[0])\n            + strlen (dir_name_mask) + 1);\n  if (dirp == NULL)\n    {\n      if (current != INVALID_HANDLE_VALUE)\n        FindClose (current);\n      errno = ENOMEM;\n      return NULL;\n    }\n  dirp->status = status;\n  dirp->current = current;\n  if (status == -1)\n    memcpy (&dirp->entry, &entry, sizeof (WIN32_FIND_DATA));\n  strcpy (dirp->dir_name_mask, dir_name_mask);\n\n#endif\n\n#if REPLACE_FCHDIR\n  {\n    int fd = dirfd (dirp);\n    if (0 <= fd && _gl_register_fd (fd, dir_name) != fd)\n      {\n        int saved_errno = errno;\n        closedir (dirp);\n        errno = saved_errno;\n        return NULL;\n      }\n  }\n#endif\n\n  return dirp;\n}",
      "lines": 106,
      "depth": 15,
      "decorators": [
        "DIR",
        "*\nopendir (const char *dir_name)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/openpty.c": {
    "rpl_openpty": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nrpl_openpty (int *amaster, int *aslave, char *name,\n             struct termios const *termp, struct winsize const *winp)\n{\n  /* Cast away const, for implementations with weaker prototypes.  */\n  return openpty (amaster, aslave, name, (struct termios *) termp,\n                  (struct winsize *) winp);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "openpty": [
      {
        "start_point": [
          38,
          0
        ],
        "end_point": [
          47,
          1
        ],
        "content": "int\nopenpty (int *amaster _GL_UNUSED, int *aslave _GL_UNUSED,\n         char *name _GL_UNUSED,\n         struct termios const *termp _GL_UNUSED,\n         struct winsize const *winp _GL_UNUSED)\n{\n  /* Mingw lacks pseudo-terminals altogether.  */\n  errno = ENOSYS;\n  return -1;\n}",
        "lines": 10,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          61,
          0
        ],
        "end_point": [
          133,
          1
        ],
        "content": "int\nopenpty (int *amaster, int *aslave, char *name,\n         struct termios const *termp, struct winsize const *winp)\n{\n  int master;\n  char *slave_name;\n  int slave;\n\n# if HAVE__GETPTY /* IRIX */\n\n  slave_name = _getpty (&master, O_RDWR, 0622, 0);\n  if (slave_name == NULL)\n    return -1;\n\n# else /* AIX 5.1, HP-UX 11, Solaris 10, mingw */\n\n  /* This call uses the 'posix_openpt' module.  */\n  master = posix_openpt (O_RDWR | O_NOCTTY);\n  if (master < 0)\n    return -1;\n\n# endif\n\n  /* This call does not require a dependency to the 'grantpt' module,\n     because AIX, HP-UX, IRIX, Solaris all have the grantpt() function.  */\n  if (grantpt (master))\n    goto fail;\n\n  /* This call does not require a dependency to the 'unlockpt' module,\n     because AIX, HP-UX, IRIX, Solaris all have the unlockpt() function.  */\n  if (unlockpt (master))\n    goto fail;\n\n# if !HAVE__GETPTY /* !IRIX */\n  slave_name = ptsname (master);\n  if (slave_name == NULL)\n    goto fail;\n# endif\n\n  slave = open (slave_name, O_RDWR | O_NOCTTY);\n  if (slave == -1)\n    goto fail;\n\n# if defined __sun || defined __hpux /* Solaris, HP-UX */\n  if (ioctl (slave, I_PUSH, \"ptem\") < 0\n      || ioctl (slave, I_PUSH, \"ldterm\") < 0\n#  if defined __sun\n      || ioctl (slave, I_PUSH, \"ttcompat\") < 0\n#  endif\n     )\n    {\n      close (slave);\n      goto fail;\n    }\n# endif\n\n  /* XXX Should we ignore errors here?  */\n  if (termp)\n    tcsetattr (slave, TCSAFLUSH, termp);\n  if (winp)\n    ioctl (slave, TIOCSWINSZ, winp);\n\n  *amaster = master;\n  *aslave = slave;\n  if (name != NULL)\n    strcpy (name, slave_name);\n\n  return 0;\n\n fail:\n  close (master);\n  return -1;\n}",
        "lines": 73,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/pathmax.h": {},
  "inetutils/inetutils-1.9.4/lib/pipe-safer.c": {
    "pipe_safer": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\npipe_safer (int fd[2])\n{\n#if HAVE_PIPE\n  if (pipe (fd) == 0)\n    {\n      int i;\n      for (i = 0; i < 2; i++)\n        {\n          fd[i] = fd_safer (fd[i]);\n          if (fd[i] < 0)\n            {\n              int e = errno;\n              close (fd[1 - i]);\n              errno = e;\n              return -1;\n            }\n        }\n\n      return 0;\n    }\n#else\n  errno = ENOSYS;\n#endif\n\n  return -1;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/poll.c": {
    "IsConsoleHandle": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static BOOL IsConsoleHandle (HANDLE h)\n{\n  DWORD mode;\n  return GetConsoleMode (h, &mode) != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "IsSocketHandle": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_compute_revents": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static int\nwindows_compute_revents (HANDLE h, int *p_sought)\n{\n  int i, ret, happened;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      happened = 0;\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            happened |= *p_sought & (POLLIN | POLLRDNORM);\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        happened |= POLLHUP;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            happened |= *p_sought & (POLLOUT | POLLWRNORM | POLLWRBAND);\n        }\n      return happened;\n\n    case FILE_TYPE_CHAR:\n      ret = WaitForSingleObject (h, 0);\n      if (!IsConsoleHandle (h))\n        return ret == WAIT_OBJECT_0 ? *p_sought & ~(POLLPRI | POLLRDBAND) : 0;\n\n      nbuffer = avail = 0;\n      bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n      if (bRet)\n        {\n          /* Input buffer.  */\n          *p_sought &= POLLIN | POLLRDNORM;\n          if (nbuffer == 0)\n            return POLLHUP;\n          if (!*p_sought)\n            return 0;\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            return POLLHUP;\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              return *p_sought;\n          return 0;\n        }\n      else\n        {\n          /* Screen buffer.  */\n          *p_sought &= POLLOUT | POLLWRNORM | POLLWRBAND;\n          return *p_sought;\n        }\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        return *p_sought & ~(POLLPRI | POLLRDBAND);\n\n      return *p_sought & (POLLOUT | POLLWRNORM | POLLWRBAND);\n    }\n}",
      "lines": 96,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "windows_compute_revents_socket": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\nwindows_compute_revents_socket (SOCKET h, int sought, long lNetworkEvents)\n{\n  int happened = 0;\n\n  if ((lNetworkEvents & (FD_READ | FD_ACCEPT | FD_CLOSE)) == FD_ACCEPT)\n    happened |= (POLLIN | POLLRDNORM) & sought;\n\n  else if (lNetworkEvents & (FD_READ | FD_ACCEPT | FD_CLOSE))\n    {\n      int r, error;\n\n      char data[64];\n      WSASetLastError (0);\n      r = recv (h, data, sizeof (data), MSG_PEEK);\n      error = WSAGetLastError ();\n      WSASetLastError (0);\n\n      if (r > 0 || error == WSAENOTCONN)\n        happened |= (POLLIN | POLLRDNORM) & sought;\n\n      /* Distinguish hung-up sockets from other errors.  */\n      else if (r == 0 || error == WSAESHUTDOWN || error == WSAECONNRESET\n               || error == WSAECONNABORTED || error == WSAENETRESET)\n        happened |= POLLHUP;\n\n      else\n        happened |= POLLERR;\n    }\n\n  if (lNetworkEvents & (FD_WRITE | FD_CONNECT))\n    happened |= (POLLOUT | POLLWRNORM | POLLWRBAND) & sought;\n\n  if (lNetworkEvents & FD_OOB)\n    happened |= (POLLPRI | POLLRDBAND) & sought;\n\n  return happened;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "compute_revents": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "static int\ncompute_revents (int fd, int sought, fd_set *rfds, fd_set *wfds, fd_set *efds)\n{\n  int happened = 0;\n  if (FD_ISSET (fd, rfds))\n    {\n      int r;\n      int socket_errno;\n\n# if defined __MACH__ && defined __APPLE__\n      /* There is a bug in Mac OS X that causes it to ignore MSG_PEEK\n         for some kinds of descriptors.  Detect if this descriptor is a\n         connected socket, a server socket, or something else using a\n         0-byte recv, and use ioctl(2) to detect POLLHUP.  */\n      r = recv (fd, NULL, 0, MSG_PEEK);\n      socket_errno = (r < 0) ? errno : 0;\n      if (r == 0 || socket_errno == ENOTSOCK)\n        ioctl (fd, FIONREAD, &r);\n# else\n      char data[64];\n      r = recv (fd, data, sizeof (data), MSG_PEEK);\n      socket_errno = (r < 0) ? errno : 0;\n# endif\n      if (r == 0)\n        happened |= POLLHUP;\n\n      /* If the event happened on an unconnected server socket,\n         that's fine. */\n      else if (r > 0 || ( /* (r == -1) && */ socket_errno == ENOTCONN))\n        happened |= (POLLIN | POLLRDNORM) & sought;\n\n      /* Distinguish hung-up sockets from other errors.  */\n      else if (socket_errno == ESHUTDOWN || socket_errno == ECONNRESET\n               || socket_errno == ECONNABORTED || socket_errno == ENETRESET)\n        happened |= POLLHUP;\n\n      /* some systems can't use recv() on non-socket, including HP NonStop */\n      else if (socket_errno == ENOTSOCK)\n        happened |= (POLLIN | POLLRDNORM) & sought;\n\n      else\n        happened |= POLLERR;\n    }\n\n  if (FD_ISSET (fd, wfds))\n    happened |= (POLLOUT | POLLWRNORM | POLLWRBAND) & sought;\n\n  if (FD_ISSET (fd, efds))\n    happened |= (POLLPRI | POLLRDBAND) & sought;\n\n  return happened;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "poll": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        593,
        1
      ],
      "content": "int\npoll (struct pollfd *pfd, nfds_t nfd, int timeout)\n{\n#ifndef WINDOWS_NATIVE\n  fd_set rfds, wfds, efds;\n  struct timeval tv;\n  struct timeval *ptv;\n  int maxfd, rc;\n  nfds_t i;\n\n  if (nfd < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Don't check directly for NFD too large.  Any practical use of a\n     too-large NFD is caught by one of the other checks below, and\n     checking directly for getdtablesize is too much of a portability\n     and/or performance and/or correctness hassle.  */\n\n  /* EFAULT is not necessary to implement, but let's do it in the\n     simplest case. */\n  if (!pfd && nfd)\n    {\n      errno = EFAULT;\n      return -1;\n    }\n\n  /* convert timeout number into a timeval structure */\n  if (timeout == 0)\n    {\n      ptv = &tv;\n      ptv->tv_sec = 0;\n      ptv->tv_usec = 0;\n    }\n  else if (timeout > 0)\n    {\n      ptv = &tv;\n      ptv->tv_sec = timeout / 1000;\n      ptv->tv_usec = (timeout % 1000) * 1000;\n    }\n  else if (timeout == INFTIM)\n    /* wait forever */\n    ptv = NULL;\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* create fd sets and determine max fd */\n  maxfd = -1;\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&efds);\n  for (i = 0; i < nfd; i++)\n    {\n      if (pfd[i].fd < 0)\n        continue;\n      if (maxfd < pfd[i].fd)\n        {\n          maxfd = pfd[i].fd;\n          if (FD_SETSIZE <= maxfd)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n        }\n      if (pfd[i].events & (POLLIN | POLLRDNORM))\n        FD_SET (pfd[i].fd, &rfds);\n      /* see select(2): \"the only exceptional condition detectable\n         is out-of-band data received on a socket\", hence we push\n         POLLWRBAND events onto wfds instead of efds. */\n      if (pfd[i].events & (POLLOUT | POLLWRNORM | POLLWRBAND))\n        FD_SET (pfd[i].fd, &wfds);\n      if (pfd[i].events & (POLLPRI | POLLRDBAND))\n        FD_SET (pfd[i].fd, &efds);\n    }\n\n  /* examine fd sets */\n  rc = select (maxfd + 1, &rfds, &wfds, &efds, ptv);\n  if (rc < 0)\n    return rc;\n\n  /* establish results */\n  rc = 0;\n  for (i = 0; i < nfd; i++)\n    {\n      pfd[i].revents = (pfd[i].fd < 0\n                        ? 0\n                        : compute_revents (pfd[i].fd, pfd[i].events,\n                                           &rfds, &wfds, &efds));\n      rc += pfd[i].revents != 0;\n    }\n\n  return rc;\n#else\n  static struct timeval tv0;\n  static HANDLE hEvent;\n  WSANETWORKEVENTS ev;\n  HANDLE h, handle_array[FD_SETSIZE + 2];\n  DWORD ret, wait_timeout, nhandles;\n  fd_set rfds, wfds, xfds;\n  BOOL poll_again;\n  MSG msg;\n  int rc = 0;\n  nfds_t i;\n\n  if (nfd < 0 || timeout < -1)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (!hEvent)\n    hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);\n\nrestart:\n  handle_array[0] = hEvent;\n  nhandles = 1;\n  FD_ZERO (&rfds);\n  FD_ZERO (&wfds);\n  FD_ZERO (&xfds);\n\n  /* Classify socket handles and create fd sets. */\n  for (i = 0; i < nfd; i++)\n    {\n      int sought = pfd[i].events;\n      pfd[i].revents = 0;\n      if (pfd[i].fd < 0)\n        continue;\n      if (!(sought & (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM | POLLWRBAND\n                      | POLLPRI | POLLRDBAND)))\n        continue;\n\n      h = (HANDLE) _get_osfhandle (pfd[i].fd);\n      assure (h != NULL);\n      if (IsSocketHandle (h))\n        {\n          int requested = FD_CLOSE;\n\n          /* see above; socket handles are mapped onto select.  */\n          if (sought & (POLLIN | POLLRDNORM))\n            {\n              requested |= FD_READ | FD_ACCEPT;\n              FD_SET ((SOCKET) h, &rfds);\n            }\n          if (sought & (POLLOUT | POLLWRNORM | POLLWRBAND))\n            {\n              requested |= FD_WRITE | FD_CONNECT;\n              FD_SET ((SOCKET) h, &wfds);\n            }\n          if (sought & (POLLPRI | POLLRDBAND))\n            {\n              requested |= FD_OOB;\n              FD_SET ((SOCKET) h, &xfds);\n            }\n\n          if (requested)\n            WSAEventSelect ((SOCKET) h, hEvent, requested);\n        }\n      else\n        {\n          /* Poll now.  If we get an event, do not poll again.  Also,\n             screen buffer handles are waitable, and they'll block until\n             a character is available.  windows_compute_revents eliminates\n             bits for the \"wrong\" direction. */\n          pfd[i].revents = windows_compute_revents (h, &sought);\n          if (sought)\n            handle_array[nhandles++] = h;\n          if (pfd[i].revents)\n            timeout = 0;\n        }\n    }\n\n  if (select (0, &rfds, &wfds, &xfds, &tv0) > 0)\n    {\n      /* Do MsgWaitForMultipleObjects anyway to dispatch messages, but\n         no need to call select again.  */\n      poll_again = FALSE;\n      wait_timeout = 0;\n    }\n  else\n    {\n      poll_again = TRUE;\n      if (timeout == INFTIM)\n        wait_timeout = INFINITE;\n      else\n        wait_timeout = timeout;\n    }\n\n  for (;;)\n    {\n      ret = MsgWaitForMultipleObjects (nhandles, handle_array, FALSE,\n                                       wait_timeout, QS_ALLINPUT);\n\n      if (ret == WAIT_OBJECT_0 + nhandles)\n        {\n          /* new input of some other kind */\n          BOOL bRet;\n          while ((bRet = PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) != 0)\n            {\n              TranslateMessage (&msg);\n              DispatchMessage (&msg);\n            }\n        }\n      else\n        break;\n    }\n\n  if (poll_again)\n    select (0, &rfds, &wfds, &xfds, &tv0);\n\n  /* Place a sentinel at the end of the array.  */\n  handle_array[nhandles] = NULL;\n  nhandles = 1;\n  for (i = 0; i < nfd; i++)\n    {\n      int happened;\n\n      if (pfd[i].fd < 0)\n        continue;\n      if (!(pfd[i].events & (POLLIN | POLLRDNORM |\n                             POLLOUT | POLLWRNORM | POLLWRBAND)))\n        continue;\n\n      h = (HANDLE) _get_osfhandle (pfd[i].fd);\n      if (h != handle_array[nhandles])\n        {\n          /* It's a socket.  */\n          WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n          WSAEventSelect ((SOCKET) h, 0, 0);\n\n          /* If we're lucky, WSAEnumNetworkEvents already provided a way\n             to distinguish FD_READ and FD_ACCEPT; this saves a recv later.  */\n          if (FD_ISSET ((SOCKET) h, &rfds)\n              && !(ev.lNetworkEvents & (FD_READ | FD_ACCEPT)))\n            ev.lNetworkEvents |= FD_READ | FD_ACCEPT;\n          if (FD_ISSET ((SOCKET) h, &wfds))\n            ev.lNetworkEvents |= FD_WRITE | FD_CONNECT;\n          if (FD_ISSET ((SOCKET) h, &xfds))\n            ev.lNetworkEvents |= FD_OOB;\n\n          happened = windows_compute_revents_socket ((SOCKET) h, pfd[i].events,\n                                                     ev.lNetworkEvents);\n        }\n      else\n        {\n          /* Not a socket.  */\n          int sought = pfd[i].events;\n          happened = windows_compute_revents (h, &sought);\n          nhandles++;\n        }\n\n       if ((pfd[i].revents |= happened) != 0)\n        rc++;\n    }\n\n  if (!rc && timeout == INFTIM)\n    {\n      SleepEx (1, TRUE);\n      goto restart;\n    }\n\n  return rc;\n#endif\n}",
      "lines": 267,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/poll.in.h": {},
  "inetutils/inetutils-1.9.4/lib/posix_openpt.c": {
    "posix_openpt": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nposix_openpt (int flags)\n{\n  int master;\n\n#ifdef _AIX /* AIX */\n\n  master = open (\"/dev/ptc\", flags);\n\n#elif (defined _WIN32 || defined __WIN32__) && !defined __CYGWIN__ /* mingw */\n\n  /* Mingw lacks pseudo-terminals altogether.  */\n  master = -1;\n  errno = ENOSYS;\n\n#elif defined __OpenBSD__\n\n  /* On OpenBSD, master and slave of a pseudo-terminal are allocated together,\n     by opening /dev/ptm and applying the PTMGET ioctl to it.  */\n  int fd;\n  struct ptmget data;\n\n  fd = open (PATH_PTMDEV, O_RDWR);\n  if (fd >= 0)\n    {\n      if (ioctl (fd, PTMGET, &data) >= 0)\n        {\n          master = data.cfd;\n          close (data.sfd);\n          close (fd);\n        }\n      else\n        {\n          int saved_errno = errno;\n          close (fd);\n          errno = saved_errno;\n          master = -1;\n        }\n    }\n  else\n    master = -1;\n\n#else /* Mac OS X, Minix, HP-UX, IRIX, OSF/1, Solaris 9, Cygwin 1.5 */\n\n  /* Most systems that lack posix_openpt() have /dev/ptmx.  */\n  master = open (\"/dev/ptmx\", flags);\n\n  /* If all this does not work, we could try to open, one by one:\n     - On Mac OS X: /dev/pty[p-w][0-9a-f]\n     - On *BSD:     /dev/pty[p-sP-S][0-9a-v]\n     - On Minix:    /dev/pty[p-q][0-9a-f]\n     - On AIX:      /dev/ptyp[0-9a-f]\n     - On HP-UX:    /dev/pty[p-r][0-9a-f]\n     - On OSF/1:    /dev/pty[p-q][0-9a-f]\n     - On Solaris:  /dev/pty[p-r][0-9a-f]\n   */\n\n#endif\n\n  return master;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/printf-args.h": {},
  "inetutils/inetutils-1.9.4/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/printf-parse.h": {},
  "inetutils/inetutils-1.9.4/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/progname.h": {},
  "inetutils/inetutils-1.9.4/lib/pty.in.h": {},
  "inetutils/inetutils-1.9.4/lib/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/read-file.c": {
    "fread_file": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "char *\nfread_file (FILE *stream, size_t *length)\n{\n  char *buf = NULL;\n  size_t alloc = BUFSIZ;\n\n  /* For a regular file, allocate a buffer that has exactly the right\n     size.  This avoids the need to do dynamic reallocations later.  */\n  {\n    struct stat st;\n\n    if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n      {\n        off_t pos = ftello (stream);\n\n        if (pos >= 0 && pos < st.st_size)\n          {\n            off_t alloc_off = st.st_size - pos;\n\n            /* '1' below, accounts for the trailing NUL.  */\n            if (SIZE_MAX - 1 < alloc_off)\n              {\n                errno = ENOMEM;\n                return NULL;\n              }\n\n            alloc = alloc_off + 1;\n          }\n      }\n  }\n\n  if (!(buf = malloc (alloc)))\n    return NULL; /* errno is ENOMEM.  */\n\n  {\n    size_t size = 0; /* number of bytes read so far */\n    int save_errno;\n\n    for (;;)\n      {\n        /* This reads 1 more than the size of a regular file\n           so that we get eof immediately.  */\n        size_t requested = alloc - size;\n        size_t count = fread (buf + size, 1, requested, stream);\n        size += count;\n\n        if (count != requested)\n          {\n            save_errno = errno;\n            if (ferror (stream))\n              break;\n\n            /* Shrink the allocated memory if possible.  */\n            if (size < alloc - 1)\n              {\n                char *smaller_buf = realloc (buf, size + 1);\n                if (smaller_buf != NULL)\n                  buf = smaller_buf;\n              }\n\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n          }\n\n        {\n          char *new_buf;\n\n          if (alloc == SIZE_MAX)\n            {\n              save_errno = ENOMEM;\n              break;\n            }\n\n          if (alloc < SIZE_MAX - alloc / 2)\n            alloc = alloc + alloc / 2;\n          else\n            alloc = SIZE_MAX;\n\n          if (!(new_buf = realloc (buf, alloc)))\n            {\n              save_errno = errno;\n              break;\n            }\n\n          buf = new_buf;\n        }\n      }\n\n    free (buf);\n    errno = save_errno;\n    return NULL;\n  }\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "char",
        "*\nfread_file (FILE *stream, size_t *length)",
        "*"
      ]
    },
    "internal_read_file": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static char *\ninternal_read_file (const char *filename, size_t *length, const char *mode)\n{\n  FILE *stream = fopen (filename, mode);\n  char *out;\n  int save_errno;\n\n  if (!stream)\n    return NULL;\n\n  out = fread_file (stream, length);\n\n  save_errno = errno;\n\n  if (fclose (stream) != 0)\n    {\n      if (out)\n        {\n          save_errno = errno;\n          free (out);\n        }\n      errno = save_errno;\n      return NULL;\n    }\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_read_file (const char *filename, size_t *length, const char *mode)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "char *\nread_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"r\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_file (const char *filename, size_t *length)",
        "*"
      ]
    },
    "read_binary_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "char *\nread_binary_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"rb\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_binary_file (const char *filename, size_t *length)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/read-file.h": {},
  "inetutils/inetutils-1.9.4/lib/readdir.c": {
    "readdir": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "struct dirent *\nreaddir (DIR *dirp)\n{\n  char type;\n  struct dirent *result;\n\n  /* There is no need to add code to produce entries for \".\" and \"..\".\n     According to the POSIX:2008 section \"4.12 Pathname Resolution\"\n     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html>\n     \".\" and \"..\" are syntactic entities.\n     POSIX also says:\n       \"If entries for dot or dot-dot exist, one entry shall be returned\n        for dot and one entry shall be returned for dot-dot; otherwise,\n        they shall not be returned.\"  */\n\n  switch (dirp->status)\n    {\n    case -2:\n      /* End of directory already reached.  */\n      return NULL;\n    case -1:\n      break;\n    case 0:\n      if (!FindNextFile (dirp->current, &dirp->entry))\n        {\n          switch (GetLastError ())\n            {\n            case ERROR_NO_MORE_FILES:\n              dirp->status = -2;\n              return NULL;\n            default:\n              errno = EIO;\n              return NULL;\n            }\n        }\n      break;\n    default:\n      errno = dirp->status;\n      return NULL;\n    }\n\n  dirp->status = 0;\n\n  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n    type = DT_DIR;\n  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\n    type = DT_LNK;\n  else if ((dirp->entry.dwFileAttributes\n            & ~(FILE_ATTRIBUTE_READONLY\n                | FILE_ATTRIBUTE_HIDDEN\n                | FILE_ATTRIBUTE_SYSTEM\n                | FILE_ATTRIBUTE_ARCHIVE\n                | FILE_ATTRIBUTE_NORMAL\n                | FILE_ATTRIBUTE_TEMPORARY\n                | FILE_ATTRIBUTE_SPARSE_FILE\n                | FILE_ATTRIBUTE_COMPRESSED\n                | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED\n                | FILE_ATTRIBUTE_ENCRYPTED)) == 0)\n    /* Devices like COM1, LPT1, NUL would also have the attributes 0x20 but\n       they cannot occur here.  */\n    type = DT_REG;\n  else\n    type = DT_UNKNOWN;\n\n  /* Reuse the memory of dirp->entry for the result.  */\n  result =\n    (struct dirent *)\n    ((char *) dirp->entry.cFileName - offsetof (struct dirent, d_name[0]));\n  result->d_type = type;\n\n  return result;\n}",
      "lines": 72,
      "depth": 21,
      "decorators": [
        "struct dirent",
        "struct",
        "dirent",
        "*\nreaddir (DIR *dirp)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/readutmp.c": {
    "extract_trimmed_name": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "char *\nextract_trimmed_name (const STRUCT_UTMP *ut)\n{\n  char *p, *trimmed_name;\n\n  trimmed_name = xmalloc (sizeof (UT_USER (ut)) + 1);\n  strncpy (trimmed_name, UT_USER (ut), sizeof (UT_USER (ut)));\n  /* Append a trailing NUL.  Some systems pad names shorter than the\n     maximum with spaces, others pad with NULs.  Remove any trailing\n     spaces.  */\n  trimmed_name[sizeof (UT_USER (ut))] = '\\0';\n  for (p = trimmed_name + strlen (trimmed_name);\n       trimmed_name < p && p[-1] == ' ';\n       *--p = '\\0')\n    continue;\n  return trimmed_name;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "char",
        "*\nextract_trimmed_name (const STRUCT_UTMP *ut)",
        "*"
      ]
    },
    "desirable_utmp_entry": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static bool\ndesirable_utmp_entry (STRUCT_UTMP const *u, int options)\n{\n  bool user_proc = IS_USER_PROCESS (u);\n  if ((options & READ_UTMP_USER_PROCESS) && !user_proc)\n    return false;\n  if ((options & READ_UTMP_CHECK_PIDS)\n      && user_proc\n      && 0 < UT_PID (u)\n      && (kill (UT_PID (u), 0) < 0 && errno == ESRCH))\n    return false;\n  return true;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "read_utmp": [
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          118,
          1
        ],
        "content": "int\nread_utmp (char const *file, size_t *n_entries, STRUCT_UTMP **utmp_buf,\n           int options)\n{\n  size_t n_read = 0;\n  size_t n_alloc = 0;\n  STRUCT_UTMP *utmp = NULL;\n  STRUCT_UTMP *u;\n\n  /* Ignore the return value for now.\n     Solaris' utmpname returns 1 upon success -- which is contrary\n     to what the GNU libc version does.  In addition, older GNU libc\n     versions are actually void.   */\n  UTMP_NAME_FUNCTION (file);\n\n  SET_UTMP_ENT ();\n\n  while ((u = GET_UTMP_ENT ()) != NULL)\n    if (desirable_utmp_entry (u, options))\n      {\n        if (n_read == n_alloc)\n          utmp = x2nrealloc (utmp, &n_alloc, sizeof *utmp);\n\n        utmp[n_read++] = *u;\n      }\n\n  END_UTMP_ENT ();\n\n  *n_entries = n_read;\n  *utmp_buf = utmp;\n\n  return 0;\n}",
        "lines": 33,
        "depth": 13,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          122,
          0
        ],
        "end_point": [
          158,
          1
        ],
        "content": "int\nread_utmp (char const *file, size_t *n_entries, STRUCT_UTMP **utmp_buf,\n           int options)\n{\n  size_t n_read = 0;\n  size_t n_alloc = 0;\n  STRUCT_UTMP *utmp = NULL;\n  int saved_errno;\n  FILE *f = fopen (file, \"r\");\n\n  if (! f)\n    return -1;\n\n  for (;;)\n    {\n      if (n_read == n_alloc)\n        utmp = x2nrealloc (utmp, &n_alloc, sizeof *utmp);\n      if (fread (&utmp[n_read], sizeof utmp[n_read], 1, f) == 0)\n        break;\n      n_read += desirable_utmp_entry (&utmp[n_read], options);\n    }\n\n  saved_errno = ferror (f) ? errno : 0;\n  if (fclose (f) != 0)\n    saved_errno = errno;\n  if (saved_errno != 0)\n    {\n      free (utmp);\n      errno = saved_errno;\n      return -1;\n    }\n\n  *n_entries = n_read;\n  *utmp_buf = utmp;\n\n  return 0;\n}",
        "lines": 37,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/readutmp.h": {},
  "inetutils/inetutils-1.9.4/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/regcomp.c": {
    "re_set_fastmap": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regerror": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg,\n\t  char *_Restrict_ errbuf, size_t errbuf_size)\n#endif\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_mem": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        856,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        1000,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1023,
        0
      ],
      "end_point": [
        1101,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1108,
        0
      ],
      "end_point": [
        1182,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1281,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1283,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1316,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1367,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1425,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == REG_MISSING, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1451,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (REG_VALID_INDEX (left));\n\tassert (REG_VALID_INDEX (right));\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == REG_MISSING)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == REG_MISSING, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1619,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return REG_MISSING; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1637,
        0
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != REG_MISSING, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1653,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1677,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != REG_MISSING);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1722,
        0
      ],
      "end_point": [
        1796,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = REG_MISSING;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == REG_MISSING)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1808,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1813,
        0
      ],
      "end_point": [
        2047,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2052,
        0
      ],
      "end_point": [
        2133,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2149,
        0
      ],
      "end_point": [
        2172,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2183,
        0
      ],
      "end_point": [
        2217,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2228,
        0
      ],
      "end_point": [
        2265,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2273,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 216,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2497,
        0
      ],
      "end_point": [
        2535,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2539,
        0
      ],
      "end_point": [
        2683,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == REG_MISSING)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != REG_ERROR, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : REG_ERROR));\n\t}\n      if (BE (start == REG_ERROR || end == REG_ERROR, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != REG_MISSING && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == REG_MISSING ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : REG_MISSING;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      if (BE (elem == NULL, 0))\n        goto parse_dup_op_espace;\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == REG_MISSING ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != REG_MISSING,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != REG_MISSING)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 145,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "start_elem": {
      "start_point": [
        2710,
        23
      ],
      "end_point": [
        2809,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? __btowc (start_ch) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? __btowc (end_ch) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      return REG_ESPACE;\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2842,
        0
      ],
      "end_point": [
        3385,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 544,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2859,
        2
      ],
      "end_point": [
        2879,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2885,
        2
      ],
      "end_point": [
        2944,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2953,
        2
      ],
      "end_point": [
        3026,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3034,
        2
      ],
      "end_point": [
        3090,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3389,
        0
      ],
      "end_point": [
        3423,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3429,
        0
      ],
      "end_point": [
        3468,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3578,
        9
      ],
      "end_point": [
        3652,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3654,
        0
      ],
      "end_point": [
        3760,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else /* not RE_ENABLE_I18N */\n  if (BE (sbcset == NULL, 0))\n#endif /* not RE_ENABLE_I18N */\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  if (non_match)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n    }\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 107,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3768,
        0
      ],
      "end_point": [
        3789,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = REG_MISSING;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn REG_ERROR;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c\n\t      || num == REG_ERROR)\n\t     ? REG_ERROR\n\t     : num == REG_MISSING\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3792,
        0
      ],
      "end_point": [
        3804,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3811,
        0
      ],
      "end_point": [
        3818,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3820,
        0
      ],
      "end_point": [
        3852,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = REG_MISSING;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3857,
        0
      ],
      "end_point": [
        3865,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3869,
        0
      ],
      "end_point": [
        3879,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3884,
        0
      ],
      "end_point": [
        3889,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3897,
        0
      ],
      "end_point": [
        3935,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/regex.c": {},
  "inetutils/inetutils-1.9.4/lib/regex.h": {},
  "inetutils/inetutils-1.9.4/lib/regexec.c": {
    "__compat_regexec": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static regoff_t\nre_search_2_stub (struct re_pattern_buffer *bufp,\n\t\t  const char *string1, Idx length1,\n\t\t  const char *string2, Idx length2,\n\t\t  Idx start, regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len = length1 + length2;\n  char *s = NULL;\n\n  if (BE (length1 < 0 || length2 < 0 || stop < 0 || len < length1, 0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_search_stub": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static regoff_t\nre_search_stub (struct re_pattern_buffer *bufp,\n\t\tconst char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "static unsigned\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "re_search_internal": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_search_internal (const regex_t *preg,\n\t\t    const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop,\n\t\t    size_t nmatch, regmatch_t pmatch[],\n\t\t    int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = REG_MISSING;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != REG_MISSING)\n\t{\n\t  if (BE (match_last == REG_ERROR, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = REG_MISSING;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != REG_MISSING);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 335,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (! REG_VALID_INDEX (match_last))\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1062,
        32
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1104,
        18
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = REG_MISSING;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return REG_ERROR;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return REG_ERROR;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ERROR;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1377,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn REG_ERROR;\n      /* Pick up a valid destination, or return REG_MISSING if none\n\t is found.  */\n      for (dest_node = REG_MISSING, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == REG_MISSING)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn REG_ERROR;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn REG_MISSING;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return REG_MISSING;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ERROR;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return REG_MISSING;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return REG_MISSING;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1380,
        18
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (REG_VALID_INDEX (num));\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1427,
        18
      ],
      "end_point": [
        1531,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (! REG_VALID_INDEX (cur_node), 0))\n\t{\n\t  if (BE (cur_node == REG_ERROR, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1597,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1681,
        18
      ],
      "end_point": [
        1738,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1742,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1768,
        0
      ],
      "end_point": [
        1793,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1795,
        0
      ],
      "end_point": [
        1841,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1844,
        18
      ],
      "end_point": [
        1870,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1919,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : REG_MISSING);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (REG_VALID_NONZERO_INDEX (edst2)\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1957,
        0
      ],
      "end_point": [
        2037,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != REG_MISSING)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2064,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2155,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = REG_MISSING;\n\t  Idx cls_node = REG_MISSING;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (REG_VALID_INDEX (ops_node))\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (REG_VALID_INDEX (cls_node))\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2158,
        18
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == REG_MISSING)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2276,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2288,
        18
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2345,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2424,
        0
      ],
      "end_point": [
        2446,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2455,
        0
      ],
      "end_point": [
        2483,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2489,
        0
      ],
      "end_point": [
        2524,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2528,
        0
      ],
      "end_point": [
        2596,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != REG_MISSING);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2599,
        0
      ],
      "end_point": [
        2705,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != REG_MISSING);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2714,
        18
      ],
      "end_point": [
        2855,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != REG_MISSING)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == REG_MISSING)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2863,
        0
      ],
      "end_point": [
        2882,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2892,
        0
      ],
      "end_point": [
        2907,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return REG_MISSING;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2915,
        18
      ],
      "end_point": [
        3069,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3080,
        18
      ],
      "end_point": [
        3152,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3160,
        0
      ],
      "end_point": [
        3207,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == REG_MISSING)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3214,
        18
      ],
      "end_point": [
        3251,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3259,
        18
      ],
      "end_point": [
        3342,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == REG_MISSING)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3347,
        0
      ],
      "end_point": [
        3578,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (! REG_VALID_NONZERO_INDEX (ndests), 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != REG_MISSING)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3585,
        0
      ],
      "end_point": [
        3767,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return REG_MISSING;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3778,
        0
      ],
      "end_point": [
        4007,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\t  /* This #include defines a local function!  */\n#  include <locale/weight.h>\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (&cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 230,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        4010,
        0
      ],
      "end_point": [
        4067,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4074,
        0
      ],
      "end_point": [
        4120,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4125,
        18
      ],
      "end_point": [
        4183,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4191,
        18
      ],
      "end_point": [
        4219,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = REG_MISSING;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4225,
        0
      ],
      "end_point": [
        4251,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4255,
        0
      ],
      "end_point": [
        4263,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4271,
        18
      ],
      "end_point": [
        4314,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4319,
        0
      ],
      "end_point": [
        4337,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return REG_MISSING;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4343,
        18
      ],
      "end_point": [
        4367,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4372,
        0
      ],
      "end_point": [
        4397,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4399,
        0
      ],
      "end_point": [
        4409,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if defined DEBUG && DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (! REG_VALID_INDEX (idx), 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#if defined DEBUG && DEBUG\n\t  /* It must not happen.  */\n\t  assert (REG_VALID_INDEX (wc_idx));\n#endif\n\t  --wc_idx;\n\t  if (! REG_VALID_INDEX (wc_idx))\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (REG_VALID_INDEX (id) && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n          if (! REG_VALID_INDEX (id) || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (! REG_VALID_INDEX (--i1) || ! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n      else\n\t{\n\t  if (! REG_VALID_INDEX (--i1))\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && REG_VALID_INDEX (id))\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (! REG_VALID_INDEX (--id))\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1269,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1;\n       REG_VALID_INDEX (is) && REG_VALID_INDEX (id); )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (REG_VALID_INDEX (is))\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (! REG_VALID_INDEX (--id))\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1276,
        18
      ],
      "end_point": [
        1321,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1328,
        18
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1352,
        52
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; REG_VALID_INDEX (--i) ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn REG_MISSING;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = REG_MISSING;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1450,
        0
      ],
      "end_point": [
        1459,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1471,
        18
      ],
      "end_point": [
        1506,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1519,
        18
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1609,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1615,
        18
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1665,
        18
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        789,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          841,
          18
        ],
        "end_point": [
          851,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          854,
          18
        ],
        "end_point": [
          860,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          864,
          18
        ],
        "end_point": [
          887,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n#  ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n#   include <locale/weight.h>\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (&p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n#  endif /* _LIBC */\n    return 1;\n}",
        "lines": 24,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/rewinddir.c": {
    "rewinddir": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nrewinddir (DIR *dirp)\n{\n  /* Like in closedir().  */\n  if (dirp->current != INVALID_HANDLE_VALUE)\n    FindClose (dirp->current);\n\n  /* Like in opendir().  */\n  dirp->status = -1;\n  dirp->current = FindFirstFile (dirp->dir_name_mask, &dirp->entry);\n  if (dirp->current == INVALID_HANDLE_VALUE)\n    {\n      switch (GetLastError ())\n        {\n        case ERROR_FILE_NOT_FOUND:\n          dirp->status = -2;\n          break;\n        default:\n          /* Save the error code for the next readdir() call.  */\n          dirp->status = ENOENT;\n          break;\n        }\n    }\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/save-cwd.c": {
    "save_cwd": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nsave_cwd (struct saved_cwd *cwd)\n{\n  cwd->name = NULL;\n\n  cwd->desc = open (\".\", O_SEARCH);\n  if (!GNULIB_FCNTL_SAFER)\n    cwd->desc = fd_safer (cwd->desc);\n  if (cwd->desc < 0)\n    {\n      cwd->name = getcwd (NULL, 0);\n      return cwd->name ? 0 : -1;\n    }\n\n  set_cloexec_flag (cwd->desc, true);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "restore_cwd": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nrestore_cwd (const struct saved_cwd *cwd)\n{\n  if (0 <= cwd->desc)\n    return fchdir (cwd->desc);\n  else\n    return chdir_long (cwd->name);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_cwd": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nfree_cwd (struct saved_cwd *cwd)\n{\n  if (cwd->desc >= 0)\n    close (cwd->desc);\n  free (cwd->name);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/save-cwd.h": {},
  "inetutils/inetutils-1.9.4/lib/secure_getenv.c": {
    "secure_getenv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nsecure_getenv (char const *name)\n{\n#if HAVE___SECURE_GETENV\n  return __secure_getenv (name);\n#else\n  if (issetugid ())\n    return 0;\n  return getenv (name);\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsecure_getenv (char const *name)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/select.c": {
    "IsConsoleHandle": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static BOOL IsConsoleHandle (HANDLE h)\n{\n  DWORD mode;\n  return GetConsoleMode (h, &mode) != 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "IsSocketHandle": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static BOOL\nIsSocketHandle (HANDLE h)\n{\n  WSANETWORKEVENTS ev;\n\n  if (IsConsoleHandle (h))\n    return FALSE;\n\n  /* Under Wine, it seems that getsockopt returns 0 for pipes too.\n     WSAEnumNetworkEvents instead distinguishes the two correctly.  */\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents ((SOCKET) h, NULL, &ev);\n  return ev.lNetworkEvents != 0xDEADBEEF;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "windows_poll_handle": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "static int\nwindows_poll_handle (HANDLE h, int fd,\n                     struct bitset *rbits,\n                     struct bitset *wbits,\n                     struct bitset *xbits)\n{\n  BOOL read, write, except;\n  int i, ret;\n  INPUT_RECORD *irbuffer;\n  DWORD avail, nbuffer;\n  BOOL bRet;\n  IO_STATUS_BLOCK iosb;\n  FILE_PIPE_LOCAL_INFORMATION fpli;\n  static PNtQueryInformationFile NtQueryInformationFile;\n  static BOOL once_only;\n\n  read = write = except = FALSE;\n  switch (GetFileType (h))\n    {\n    case FILE_TYPE_DISK:\n      read = TRUE;\n      write = TRUE;\n      break;\n\n    case FILE_TYPE_PIPE:\n      if (!once_only)\n        {\n          NtQueryInformationFile = (PNtQueryInformationFile)\n            GetProcAddress (GetModuleHandle (\"ntdll.dll\"),\n                            \"NtQueryInformationFile\");\n          once_only = TRUE;\n        }\n\n      if (PeekNamedPipe (h, NULL, 0, NULL, &avail, NULL) != 0)\n        {\n          if (avail)\n            read = TRUE;\n        }\n      else if (GetLastError () == ERROR_BROKEN_PIPE)\n        ;\n\n      else\n        {\n          /* It was the write-end of the pipe.  Check if it is writable.\n             If NtQueryInformationFile fails, optimistically assume the pipe is\n             writable.  This could happen on Windows 9x, where\n             NtQueryInformationFile is not available, or if we inherit a pipe\n             that doesn't permit FILE_READ_ATTRIBUTES access on the write end\n             (I think this should not happen since Windows XP SP2; WINE seems\n             fine too).  Otherwise, ensure that enough space is available for\n             atomic writes.  */\n          memset (&iosb, 0, sizeof (iosb));\n          memset (&fpli, 0, sizeof (fpli));\n\n          if (!NtQueryInformationFile\n              || NtQueryInformationFile (h, &iosb, &fpli, sizeof (fpli),\n                                         FilePipeLocalInformation)\n              || fpli.WriteQuotaAvailable >= PIPE_BUF\n              || (fpli.OutboundQuota < PIPE_BUF &&\n                  fpli.WriteQuotaAvailable == fpli.OutboundQuota))\n            write = TRUE;\n        }\n      break;\n\n    case FILE_TYPE_CHAR:\n      write = TRUE;\n      if (!(rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n        break;\n\n      ret = WaitForSingleObject (h, 0);\n      if (ret == WAIT_OBJECT_0)\n        {\n          if (!IsConsoleHandle (h))\n            {\n              read = TRUE;\n              break;\n            }\n\n          nbuffer = avail = 0;\n          bRet = GetNumberOfConsoleInputEvents (h, &nbuffer);\n\n          /* Screen buffers handles are filtered earlier.  */\n          assert (bRet);\n          if (nbuffer == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          irbuffer = (INPUT_RECORD *) alloca (nbuffer * sizeof (INPUT_RECORD));\n          bRet = PeekConsoleInput (h, irbuffer, nbuffer, &avail);\n          if (!bRet || avail == 0)\n            {\n              except = TRUE;\n              break;\n            }\n\n          for (i = 0; i < avail; i++)\n            if (irbuffer[i].EventType == KEY_EVENT)\n              read = TRUE;\n        }\n      break;\n\n    default:\n      ret = WaitForSingleObject (h, 0);\n      write = TRUE;\n      if (ret == WAIT_OBJECT_0)\n        read = TRUE;\n\n      break;\n    }\n\n  ret = 0;\n  if (read && (rbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      rbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (write && (wbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      wbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  if (except && (xbits->in[fd / CHAR_BIT] & (1 << (fd & (CHAR_BIT - 1)))))\n    {\n      xbits->out[fd / CHAR_BIT] |= (1 << (fd & (CHAR_BIT - 1)));\n      ret++;\n    }\n\n  return ret;\n}",
      "lines": 133,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_select": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "int\nrpl_select (int nfds, fd_set *rfds, fd_set *wfds, fd_set *xfds,\n            struct timeval *timeout)\n{\n  int i;\n\n  /* FreeBSD 8.2 has a bug: it does not always detect invalid fds.  */\n  if (nfds < 0 || nfds > FD_SETSIZE)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  for (i = 0; i < nfds; i++)\n    {\n      if (((rfds && FD_ISSET (i, rfds))\n           || (wfds && FD_ISSET (i, wfds))\n           || (xfds && FD_ISSET (i, xfds)))\n          && dup2 (i, i) != i)\n        return -1;\n    }\n\n  /* Interix 3.5 has a bug: it does not support nfds == 0.  */\n  if (nfds == 0)\n    {\n      nfds = 1;\n      rfds = NULL;\n      wfds = NULL;\n      xfds = NULL;\n    }\n  return select (nfds, rfds, wfds, xfds, timeout);\n}",
      "lines": 31,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sethostname.c": {
    "sethostname": [
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "int\nsethostname (const char *name, size_t len)\n{\n  /* Ensure the string isn't too long.  glibc does allow setting an\n     empty hostname so no point in enforcing a lower bound. */\n  if (len > HOST_NAME_MAX)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef __minix /* Minix */\n  {\n    FILE *hostf;\n    int r = 0;\n\n    /* glibc returns EFAULT, EINVAL, and EPERM on error.  None of\n       these are appropriate for us to set, even if they may match the\n       situation, during failed open/write/close operations, so we\n       leave errno alone and rely on what the system sets up. */\n    hostf = fopen (\"/etc/hostname.file\", \"w\");\n    if (hostf == NULL)\n      r = -1;\n    else\n      {\n        fprintf (hostf, \"%.*s\\n\", (int) len, name);\n        if (ferror (hostf))\n          {\n            /* Close hostf, preserving the errno from the fprintf call.  */\n            int saved_errno = errno;\n            fclose (hostf);\n            errno = saved_errno;\n            r = -1;\n          }\n        else\n          {\n            if (fclose (hostf))\n              /* fclose sets errno on failure.  */\n              r = -1;\n          }\n      }\n\n    return r;\n  }\n#else\n  /* For platforms that we don't have a better option for, simply bail\n     out.  */\n  errno = ENOSYS;\n  return -1;\n#endif\n}",
        "lines": 51,
        "depth": 13,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          114,
          0
        ],
        "end_point": [
          159,
          1
        ],
        "content": "int\nsethostname (const char *name, size_t len)\n{\n  char name_asciz[HOST_NAME_MAX + 1];\n  char old_name[HOST_NAME_MAX + 1];\n  DWORD old_name_len;\n\n  /* Ensure the string isn't too long.  glibc does allow setting an\n     empty hostname so no point in enforcing a lower bound. */\n  if (len > HOST_NAME_MAX)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* Prepare a NUL-terminated copy of name.  */\n  memcpy (name_asciz, name, len);\n  name_asciz[len] = '\\0';\n\n  /* Save the old NetBIOS name.  */\n  old_name_len = sizeof (old_name) - 1;\n  if (! GetComputerNameEx (ComputerNamePhysicalNetBIOS,\n                           old_name, &old_name_len))\n    old_name_len = 0;\n\n  /* Set both the NetBIOS and the first part of the IP / DNS name.  */\n  if (! SetComputerNameEx (ComputerNamePhysicalNetBIOS, name_asciz))\n    {\n      errno = (GetLastError () == ERROR_ACCESS_DENIED ? EPERM : EINVAL);\n      return -1;\n    }\n  if (! SetComputerNameEx (ComputerNamePhysicalDnsHostname, name_asciz))\n    {\n      errno = (GetLastError () == ERROR_ACCESS_DENIED ? EPERM : EINVAL);\n      /* Restore the old NetBIOS name.  */\n      if (old_name_len > 0)\n        {\n          old_name[old_name_len] = '\\0';\n          SetComputerNameEx (ComputerNamePhysicalNetBIOS, old_name);\n        }\n      return -1;\n    }\n\n  /* Note that the new host name becomes effective only after a reboot!  */\n  return 0;\n}",
        "lines": 46,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/lib/signal.in.h": {},
  "inetutils/inetutils-1.9.4/lib/size_max.h": {},
  "inetutils/inetutils-1.9.4/lib/sleep.c": {
    "sleep": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "unsigned int\nsleep (unsigned int seconds)\n{\n  unsigned int remaining;\n\n  /* Sleep for 1 second many times, because\n       1. Sleep is not interruptible by Ctrl-C,\n       2. we want to avoid arithmetic overflow while multiplying with 1000.  */\n  for (remaining = seconds; remaining > 0; remaining--)\n    Sleep (1000);\n\n  return remaining;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "rpl_sleep": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "unsigned int\nrpl_sleep (unsigned int seconds)\n{\n  /* This requires int larger than 16 bits.  */\n  verify (UINT_MAX / 24 / 24 / 60 / 60);\n  const unsigned int limit = 24 * 24 * 60 * 60;\n  while (limit < seconds)\n    {\n      unsigned int result;\n      seconds -= limit;\n      result = sleep (limit);\n      if (result)\n        return seconds + result;\n    }\n  return sleep (seconds);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/snprintf.c": {
    "snprintf": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nsnprintf (char *str, size_t size, const char *format, ...)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (INT_MAX < len)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sockets.c": {
    "close_fd_maybe_socket": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nclose_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_close_fn primary,\n                       int fd)\n{\n  /* Note about multithread-safety: There is a race condition where, between\n     our calls to closesocket() and the primary close(), some other thread\n     could make system calls that allocate precisely the same HANDLE value\n     as sock; then the primary close() would call CloseHandle() on it.  */\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      /* FIXME: other applications, like squid, use an undocumented\n         _free_osfhnd free function.  But this is not enough: The 'osfile'\n         flags for fd also needs to be cleared, but it is hard to access it.\n         Instead, here we just close twice the file descriptor.  */\n      if (closesocket (sock))\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        {\n          /* This call frees the file descriptor and does a\n             CloseHandle ((HANDLE) _get_osfhandle (fd)), which fails.  */\n          _close (fd);\n          return 0;\n        }\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_close_hooks (remaining_list, primary, fd);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ioctl_fd_maybe_socket": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nioctl_fd_maybe_socket (const struct fd_hook *remaining_list,\n                       gl_ioctl_fn primary,\n                       int fd, int request, void *arg)\n{\n  SOCKET sock;\n  WSANETWORKEVENTS ev;\n\n  /* Test whether fd refers to a socket.  */\n  sock = FD_TO_SOCKET (fd);\n  ev.lNetworkEvents = 0xDEADBEEF;\n  WSAEnumNetworkEvents (sock, NULL, &ev);\n  if (ev.lNetworkEvents != 0xDEADBEEF)\n    {\n      /* fd refers to a socket.  */\n      if (ioctlsocket (sock, request, arg) < 0)\n        {\n          set_winsock_errno ();\n          return -1;\n        }\n      else\n        return 0;\n    }\n  else\n    /* Some other type of file descriptor.  */\n    return execute_ioctl_hooks (remaining_list, primary, fd, request, arg);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_sockets_startup": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int\ngl_sockets_startup (int version _GL_UNUSED)\n{\n#if WINDOWS_SOCKETS\n  if (version > initialized_sockets_version)\n    {\n      WSADATA data;\n      int err;\n\n      err = WSAStartup (version, &data);\n      if (err != 0)\n        return 1;\n\n      if (data.wVersion < version)\n        return 2;\n\n      if (initialized_sockets_version == 0)\n        register_fd_hook (close_fd_maybe_socket, ioctl_fd_maybe_socket,\n                          &fd_sockets_hook);\n\n      initialized_sockets_version = version;\n    }\n#endif\n\n  return 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "gl_sockets_cleanup": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngl_sockets_cleanup (void)\n{\n#if WINDOWS_SOCKETS\n  int err;\n\n  initialized_sockets_version = 0;\n\n  unregister_fd_hook (&fd_sockets_hook);\n\n  err = WSACleanup ();\n  if (err != 0)\n    return 1;\n#endif\n\n  return 0;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sockets.h": {
    "gl_fd_to_handle": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static inline SOCKET\ngl_fd_to_handle (int fd)\n{\n  return _get_osfhandle (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "SOCKET"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/stdalign.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stdarg.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stdbool.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stddef.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stdint.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stdio--.h": {},
  "inetutils/inetutils-1.9.4/lib/stdio-impl.h": {},
  "inetutils/inetutils-1.9.4/lib/stdio-safer.h": {},
  "inetutils/inetutils-1.9.4/lib/stdio.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stdlib.in.h": {},
  "inetutils/inetutils-1.9.4/lib/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strdup.c": {
    "__strdup": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "char",
        "*\n__strdup (const char *s)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strerror-override.h": {},
  "inetutils/inetutils-1.9.4/lib/strerror.c": {},
  "inetutils/inetutils-1.9.4/lib/string.in.h": {},
  "inetutils/inetutils-1.9.4/lib/strings.in.h": {},
  "inetutils/inetutils-1.9.4/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strndup.c": {
    "strndup": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "char *\nstrndup (char const *s, size_t n)\n{\n  size_t len = strnlen (s, n);\n  char *new = malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return memcpy (new, s, len);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nstrndup (char const *s, size_t n)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strnlen.c": {
    "strnlen": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\nstrnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strnlen1.c": {
    "strnlen1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "size_t\nstrnlen1 (const char *string, size_t maxlen)\n{\n  const char *end = (const char *) memchr (string, '\\0', maxlen);\n  if (end != NULL)\n    return end - string + 1;\n  else\n    return maxlen;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/strnlen1.h": {},
  "inetutils/inetutils-1.9.4/lib/sysexits.in.h": {},
  "inetutils/inetutils-1.9.4/lib/sys_ioctl.in.h": {},
  "inetutils/inetutils-1.9.4/lib/sys_select.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sys_socket.c": {},
  "inetutils/inetutils-1.9.4/lib/sys_socket.in.h": {
    "rpl_fd_isset": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "_GL_SYS_SOCKET_INLINE int\nrpl_fd_isset (SOCKET fd, fd_set * set)\n{\n  u_int i;\n  if (set == NULL)\n    return 0;\n\n  for (i = 0; i < set->fd_count; i++)\n    if (set->fd_array[i] == fd)\n      return 1;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "_GL_SYS_SOCKET_INLINE",
        "int",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/sys_time.in.h": {},
  "inetutils/inetutils-1.9.4/lib/sys_types.in.h": {},
  "inetutils/inetutils-1.9.4/lib/sys_uio.in.h": {},
  "inetutils/inetutils-1.9.4/lib/tempname.c": {
    "direxists": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__try_tempname": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int\n__try_tempname (char *tmpl, int suffixlen, void *args,\n                int (*tryfunc) (char *, void *))\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      fd = tryfunc (tmpl, args);\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "try_file": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\ntry_file (char *tmpl, void *flags)\n{\n  int *openflags = flags;\n  return __open (tmpl,\n                 (*openflags & ~O_ACCMODE)\n                 | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_dir": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "static int\ntry_dir (char *tmpl, void *flags _GL_UNUSED)\n{\n  return __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "try_nocreate": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static int\ntry_nocreate (char *tmpl, void *flags _GL_UNUSED)\n{\n  struct_stat64 st;\n\n  if (__lxstat64 (_STAT_VER, tmpl, &st) == 0)\n    __set_errno (EEXIST);\n  return errno == ENOENT ? 0 : -1;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int (*tryfunc) (char *, void *);\n\n  switch (kind)\n    {\n    case __GT_FILE:\n      tryfunc = try_file;\n      break;\n\n    case __GT_DIR:\n      tryfunc = try_dir;\n      break;\n\n    case __GT_NOCREATE:\n      tryfunc = try_nocreate;\n      break;\n\n    default:\n      assert (! \"invalid KIND in __gen_tempname\");\n      abort ();\n    }\n  return __try_tempname (tmpl, suffixlen, &flags, tryfunc);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/tempname.h": {},
  "inetutils/inetutils-1.9.4/lib/termios.in.h": {},
  "inetutils/inetutils-1.9.4/lib/time.in.h": {},
  "inetutils/inetutils-1.9.4/lib/uinttostr.c": {},
  "inetutils/inetutils-1.9.4/lib/umaxtostr.c": {},
  "inetutils/inetutils-1.9.4/lib/unistd--.h": {},
  "inetutils/inetutils-1.9.4/lib/unistd-safer.h": {},
  "inetutils/inetutils-1.9.4/lib/unistd.c": {},
  "inetutils/inetutils-1.9.4/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4614,
        16
      ],
      "end_point": [
        5533,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 920,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        width = arg;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = -width;\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = -width;",
        "width = -width",
        "width",
        "=",
        "-width",
        "-",
        "width",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    has_width = 1;\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "#endif",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = *mp++;",
        "*fbp++ = *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   width,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n                        if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n\n                        errno = saved_errno;\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (saved_errno == 0)\n                          {\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "if",
        "(saved_errno == 0)",
        "(",
        "saved_errno == 0",
        "saved_errno",
        "==",
        "0",
        ")",
        "{\n                            if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;\n                          }",
        "{",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                              saved_errno = EILSEQ;\n                            else\n                              saved_errno = EINVAL;",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "saved_errno = EILSEQ;",
        "saved_errno = EILSEQ",
        "saved_errno",
        "=",
        "EILSEQ",
        ";",
        "else",
        "saved_errno = EINVAL;",
        "saved_errno = EINVAL",
        "saved_errno",
        "=",
        "EINVAL",
        ";",
        "}",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/vasnprintf.h": {},
  "inetutils/inetutils-1.9.4/lib/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/verify.h": {},
  "inetutils/inetutils-1.9.4/lib/version-etc-fsf.c": {},
  "inetutils/inetutils-1.9.4/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/version-etc.h": {},
  "inetutils/inetutils-1.9.4/lib/vsnprintf.c": {
    "vsnprintf": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nvsnprintf (char *str, size_t size, const char *format, va_list args)\n{\n  char *output;\n  size_t len;\n  size_t lenbuf = size;\n\n  output = vasnprintf (str, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    return -1;\n\n  if (output != str)\n    {\n      if (size)\n        {\n          size_t pruned_len = (len < size ? len : size - 1);\n          memcpy (str, output, pruned_len);\n          str[pruned_len] = '\\0';\n        }\n\n      free (output);\n    }\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/w32sock.h": {
    "set_winsock_errno": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline void\nset_winsock_errno (void)\n{\n  int err = WSAGetLastError ();\n\n  /* Map some WSAE* errors to the runtime library's error codes.  */\n  switch (err)\n    {\n    case WSA_INVALID_HANDLE:\n      errno = EBADF;\n      break;\n    case WSA_NOT_ENOUGH_MEMORY:\n      errno = ENOMEM;\n      break;\n    case WSA_INVALID_PARAMETER:\n      errno = EINVAL;\n      break;\n    case WSAENAMETOOLONG:\n      errno = ENAMETOOLONG;\n      break;\n    case WSAENOTEMPTY:\n      errno = ENOTEMPTY;\n      break;\n    case WSAEWOULDBLOCK:\n      errno = EWOULDBLOCK;\n      break;\n    case WSAEINPROGRESS:\n      errno = EINPROGRESS;\n      break;\n    case WSAEALREADY:\n      errno = EALREADY;\n      break;\n    case WSAENOTSOCK:\n      errno = ENOTSOCK;\n      break;\n    case WSAEDESTADDRREQ:\n      errno = EDESTADDRREQ;\n      break;\n    case WSAEMSGSIZE:\n      errno = EMSGSIZE;\n      break;\n    case WSAEPROTOTYPE:\n      errno = EPROTOTYPE;\n      break;\n    case WSAENOPROTOOPT:\n      errno = ENOPROTOOPT;\n      break;\n    case WSAEPROTONOSUPPORT:\n      errno = EPROTONOSUPPORT;\n      break;\n    case WSAEOPNOTSUPP:\n      errno = EOPNOTSUPP;\n      break;\n    case WSAEAFNOSUPPORT:\n      errno = EAFNOSUPPORT;\n      break;\n    case WSAEADDRINUSE:\n      errno = EADDRINUSE;\n      break;\n    case WSAEADDRNOTAVAIL:\n      errno = EADDRNOTAVAIL;\n      break;\n    case WSAENETDOWN:\n      errno = ENETDOWN;\n      break;\n    case WSAENETUNREACH:\n      errno = ENETUNREACH;\n      break;\n    case WSAENETRESET:\n      errno = ENETRESET;\n      break;\n    case WSAECONNABORTED:\n      errno = ECONNABORTED;\n      break;\n    case WSAECONNRESET:\n      errno = ECONNRESET;\n      break;\n    case WSAENOBUFS:\n      errno = ENOBUFS;\n      break;\n    case WSAEISCONN:\n      errno = EISCONN;\n      break;\n    case WSAENOTCONN:\n      errno = ENOTCONN;\n      break;\n    case WSAETIMEDOUT:\n      errno = ETIMEDOUT;\n      break;\n    case WSAECONNREFUSED:\n      errno = ECONNREFUSED;\n      break;\n    case WSAELOOP:\n      errno = ELOOP;\n      break;\n    case WSAEHOSTUNREACH:\n      errno = EHOSTUNREACH;\n      break;\n    default:\n      errno = (err > 10000 && err < 10025) ? err - 10000 : err;\n      break;\n    }\n}",
      "lines": 103,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/wchar.in.h": {},
  "inetutils/inetutils-1.9.4/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/wctype-h.c": {},
  "inetutils/inetutils-1.9.4/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xalloc-oversized.h": {},
  "inetutils/inetutils-1.9.4/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          115,
          0
        ],
        "end_point": [
          121,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          235,
          29
        ],
        "end_point": [
          239,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          177,
          0
        ],
        "end_point": [
          209,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = floor (1.5 * N) + 1 so that progress is made even if N == 0.\n         Check for overflow, so that N * S stays in size_t range.\n         The check may be slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += n / 2 + 1;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          247,
          29
        ],
        "end_point": [
          251,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        229,
        29
      ],
      "end_point": [
        233,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        241,
        29
      ],
      "end_point": [
        245,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        253,
        29
      ],
      "end_point": [
        257,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xasprintf.c": {
    "xasprintf": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nxasprintf (const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = xvasprintf (format, args);\n  va_end (args);\n\n  return result;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxasprintf (const char *format, ...)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xgetcwd.c": {
    "xgetcwd": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nxgetcwd (void)\n{\n  char *cwd = getcwd (NULL, 0);\n  if (! cwd && errno == ENOMEM)\n    xalloc_die ();\n  return cwd;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nxgetcwd (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xgetcwd.h": {},
  "inetutils/inetutils-1.9.4/lib/xgetdomainname.c": {
    "xgetdomainname": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "char *\nxgetdomainname (void)\n{\n  char *domainname;\n  size_t size;\n\n  size = INITIAL_DOMAINNAME_LENGTH;\n  domainname = xmalloc (size);\n  while (1)\n    {\n      int k = size - 1;\n      int err;\n\n      errno = 0;\n      domainname[k] = '\\0';\n      err = getdomainname (domainname, size);\n      if (err >= 0 && domainname[k] == '\\0')\n        break;\n      else if (err < 0 && errno != EINVAL)\n        {\n          int saved_errno = errno;\n          free (domainname);\n          errno = saved_errno;\n          return NULL;\n        }\n      size *= 2;\n      domainname = xrealloc (domainname, size);\n    }\n\n  return domainname;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "char",
        "*\nxgetdomainname (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xgetdomainname.h": {},
  "inetutils/inetutils-1.9.4/lib/xgethostname.c": {
    "xgethostname": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "char *\nxgethostname (void)\n{\n  char *hostname = NULL;\n  size_t size = INITIAL_HOSTNAME_LENGTH;\n\n  while (1)\n    {\n      /* Use SIZE_1 here rather than SIZE to work around the bug in\n         SunOS 5.5's gethostname whereby it NUL-terminates HOSTNAME\n         even when the name is as long as the supplied buffer.  */\n      size_t size_1;\n\n      hostname = x2realloc (hostname, &size);\n      size_1 = size - 1;\n      hostname[size_1 - 1] = '\\0';\n      errno = 0;\n\n      if (gethostname (hostname, size_1) == 0)\n        {\n          if (! hostname[size_1 - 1])\n            break;\n        }\n      else if (errno != 0 && errno != ENAMETOOLONG && errno != EINVAL\n               /* OSX/Darwin does this when the buffer is not large enough */\n               && errno != ENOMEM)\n        {\n          int saved_errno = errno;\n          free (hostname);\n          errno = saved_errno;\n          return NULL;\n        }\n    }\n\n  return hostname;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "char",
        "*\nxgethostname (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xgethostname.h": {},
  "inetutils/inetutils-1.9.4/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xsize.c": {},
  "inetutils/inetutils-1.9.4/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "inetutils/inetutils-1.9.4/lib/xvasprintf.c": {
    "xstrcat": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static char *\nxstrcat (size_t argcount, va_list args)\n{\n  char *result;\n  va_list ap;\n  size_t totalsize;\n  size_t i;\n  char *p;\n\n  /* Determine the total size.  */\n  totalsize = 0;\n  va_copy (ap, args);\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (ap, const char *);\n      totalsize = xsum (totalsize, strlen (next));\n    }\n  va_end (ap);\n\n  /* Test for overflow in the summing pass above or in (totalsize + 1) below.\n     Also, don't return a string longer than INT_MAX, for consistency with\n     vasprintf().  */\n  if (totalsize == SIZE_MAX || totalsize > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      return NULL;\n    }\n\n  /* Allocate and fill the result string.  */\n  result = XNMALLOC (totalsize + 1, char);\n  p = result;\n  for (i = argcount; i > 0; i--)\n    {\n      const char *next = va_arg (args, const char *);\n      size_t len = strlen (next);\n      memcpy (p, next, len);\n      p += len;\n    }\n  *p = '\\0';\n\n  return result;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nxstrcat (size_t argcount, va_list args)",
        "*"
      ]
    },
    "xvasprintf": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "char *\nxvasprintf (const char *format, va_list args)\n{\n  char *result;\n\n  /* Recognize the special case format = \"%s...%s\".  It is a frequently used\n     idiom for string concatenation and needs to be fast.  We don't want to\n     have a separate function xstrcat() for this purpose.  */\n  {\n    size_t argcount = 0;\n    const char *f;\n\n    for (f = format;;)\n      {\n        if (*f == '\\0')\n          /* Recognized the special case of string concatenation.  */\n          return xstrcat (argcount, args);\n        if (*f != '%')\n          break;\n        f++;\n        if (*f != 's')\n          break;\n        f++;\n        argcount++;\n      }\n  }\n\n  if (vasprintf (&result, format, args) < 0)\n    {\n      if (errno == ENOMEM)\n        xalloc_die ();\n      return NULL;\n    }\n\n  return result;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "char",
        "*\nxvasprintf (const char *format, va_list args)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/xvasprintf.h": {},
  "inetutils/inetutils-1.9.4/lib/glthread/lock.c": {
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 28,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          255,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          257,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          282,
          0
        ],
        "end_point": [
          307,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          311,
          0
        ],
        "end_point": [
          337,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          391,
          0
        ],
        "end_point": [
          402,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          530,
          0
        ],
        "end_point": [
          541,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          543,
          0
        ],
        "end_point": [
          562,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          365,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          439,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          564,
          0
        ],
        "end_point": [
          578,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          373,
          0
        ],
        "end_point": [
          385,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          441,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          580,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          455,
          0
        ],
        "end_point": [
          469,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          502,
          0
        ],
        "end_point": [
          514,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          613,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          495,
          0
        ],
        "end_point": [
          500,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          611,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/lib/glthread/lock.h": {},
  "inetutils/inetutils-1.9.4/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libicmp/icmp.h": {},
  "inetutils/inetutils-1.9.4/libicmp/icmp_address.c": {
    "icmp_address_encode": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nicmp_address_encode (unsigned char * buffer, size_t bufsize, int ident, int seqno)\n{\n  icmphdr_t *icmp;\n\n  if (bufsize < ICMP_MASKLEN)\n    return -1;\n\n  icmp = (icmphdr_t *) buffer;\n  icmp->icmp_mask = 0;\n  icmp_generic_encode (buffer, bufsize, ICMP_ADDRESS, ident, seqno);\n  return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libicmp/icmp_cksum.c": {
    "icmp_cksum": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "unsigned short\nicmp_cksum (unsigned char * addr, int len)\n{\n  register int sum = 0;\n  unsigned short answer = 0;\n  unsigned short *wp;\n\n  for (wp = (unsigned short *) addr; len > 1; wp++, len -= 2)\n    sum += *wp;\n\n  /* Take in an odd byte if present */\n  if (len == 1)\n    {\n      *(unsigned char *) & answer = *(unsigned char *) wp;\n      sum += answer;\n    }\n\n  sum = (sum >> 16) + (sum & 0xffff);\t/* add high 16 to low 16 */\n  sum += (sum >> 16);\t\t/* add carry */\n  answer = ~sum;\t\t/* truncate to 16 bits */\n  return answer;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "unsigned short",
        "unsigned",
        "short"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libicmp/icmp_echo.c": {
    "icmp_generic_encode": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nicmp_generic_encode (unsigned char * buffer, size_t bufsize, int type, int ident,\n\t\t     int seqno)\n{\n  icmphdr_t *icmp;\n\n  if (bufsize < ICMP_MINLEN)\n    return -1;\n  icmp = (icmphdr_t *) buffer;\n  icmp->icmp_type = type;\n  icmp->icmp_code = 0;\n  icmp->icmp_cksum = 0;\n  icmp->icmp_seq = htons (seqno);\n  icmp->icmp_id = htons (ident);\n\n  icmp->icmp_cksum = icmp_cksum (buffer, bufsize);\n  return 0;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "icmp_generic_decode": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nicmp_generic_decode (unsigned char * buffer, size_t bufsize,\n\t\t     struct ip **ipp, icmphdr_t ** icmpp)\n{\n  size_t hlen;\n  unsigned short cksum;\n  struct ip *ip;\n  icmphdr_t *icmp;\n\n  /* IP header */\n  ip = (struct ip *) buffer;\n  hlen = ip->ip_hl << 2;\n  if (bufsize < hlen + ICMP_MINLEN)\n    return -1;\n\n  /* ICMP header */\n  icmp = (icmphdr_t *) (buffer + hlen);\n\n  /* Prepare return values */\n  *ipp = ip;\n  *icmpp = icmp;\n\n  /* Recompute checksum */\n  cksum = icmp->icmp_cksum;\n  icmp->icmp_cksum = 0;\n  icmp->icmp_cksum = icmp_cksum ((unsigned char *) icmp, bufsize - hlen);\n  if (icmp->icmp_cksum != cksum)\n    return 1;\n  return 0;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "icmp_echo_encode": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nicmp_echo_encode (unsigned char * buffer, size_t bufsize, int ident, int seqno)\n{\n  return icmp_generic_encode (buffer, bufsize, ICMP_ECHO, ident, seqno);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "icmp_echo_decode": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nicmp_echo_decode (unsigned char * buffer, size_t bufsize,\n\t\t  struct ip **ipp, icmphdr_t ** icmpp)\n{\n  return icmp_generic_decode (buffer, bufsize, ipp, icmpp);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libicmp/icmp_timestamp.c": {
    "icmp_timestamp_encode": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\nicmp_timestamp_encode (unsigned char * buffer, size_t bufsize, int ident, int seqno)\n{\n  icmphdr_t *icmp;\n  struct timeval tv;\n  unsigned long v;\n\n  if (bufsize < ICMP_TSLEN)\n    return -1;\n\n  gettimeofday (&tv, NULL);\n  v = htonl ((tv.tv_sec % 86400) * 1000 + tv.tv_usec / 1000);\n\n  icmp = (icmphdr_t *) buffer;\n  icmp->icmp_otime = v;\n  icmp->icmp_rtime = v;\n  icmp->icmp_ttime = v;\n  icmp_generic_encode (buffer, bufsize, ICMP_TIMESTAMP, ident, seqno);\n  return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/argcv.c": {
    "argcv_scan": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nargcv_scan (int len, const char *command, const char *delim,\n\t    int *start, int *end, int *save)\n{\n  int i = *save;\n\n  /* Skip initial whitespace */\n  while (i < len && isws (command[i]))\n    i++;\n  *start = i;\n\n  switch (command[i])\n    {\n    case '\"':\n    case '\\'':\n      while (++i < len && command[i] != command[*start])\n\t;\n      if (i < len)\t\t/* found matching quote */\n\tbreak;\n    default:\n      if (isdelim (command[i], delim))\n\tbreak;\n      /* Skip until next whitespace character or end of line */\n      while (++i < len && !(isws (command[i]) || isdelim (command[i], delim)))\n\t;\n      i--;\n      break;\n    }\n\n  *end = i;\n  *save = i + 1;\n  return *save;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "argcv_get": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nargcv_get (const char *command, const char *delim, int *argc, char ***argv)\n{\n  int len = strlen (command);\n  int i = 0;\n  int start, end, save;\n\n  *argc = 0;\n  *argv = NULL;\n\n  while (len > 0 && isspace ((int) command[len - 1]))\n    len--;\n  if (len < 1)\n    return 1;\n\n  /* Count number of arguments */\n  *argc = 1;\n  save = 0;\n  while (argcv_scan (len, command, delim, &start, &end, &save) < len)\n    (*argc)++;\n\n  *argv = calloc ((*argc + 1), sizeof (char *));\n\n  i = 0;\n  save = 0;\n  for (i = 0; i < *argc; i++)\n    {\n      int n;\n      argcv_scan (len, command, delim, &start, &end, &save);\n\n      if (command[start] == '\"' && command[end] == '\"')\n\t{\n\t  start++;\n\t  end--;\n\t}\n      else if (command[start] == '\\'' && command[end] == '\\'')\n\t{\n\t  start++;\n\t  end--;\n\t}\n      n = end - start + 1;\n      (*argv)[i] = calloc (n + 1, sizeof (char));\n      if ((*argv)[i] == NULL)\n\treturn 1;\n      memcpy ((*argv)[i], &command[start], n);\n      (*argv)[i][n] = 0;\n    }\n  (*argv)[i] = NULL;\n  return 0;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "argcv_free": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nargcv_free (int argc, char **argv)\n{\n  while (--argc >= 0)\n    free (argv[argc]);\n  free (argv);\n  return 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "argcv_string": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\nargcv_string (int argc, char **argv, char **pstring)\n{\n  int i;\n  size_t len;\n  char *buffer;\n\n  /* No need.  */\n  if (pstring == NULL)\n    return 1;\n\n  buffer = malloc (1);\n  if (buffer == NULL)\n    return 1;\n  *buffer = '\\0';\n\n  for (len = i = 0; i < argc; i++)\n    {\n      len += strlen (argv[i]) + 2;\n      buffer = realloc (buffer, len);\n      if (buffer == NULL)\n\treturn 1;\n      if (i != 0)\n\tstrcat (buffer, \" \");\n      strcat (buffer, argv[i]);\n    }\n\n  /* Strip off trailing space.  */\n  if (*buffer != '\\0')\n    {\n      while (buffer[strlen (buffer) - 1] == ' ')\n\t{\n\t  buffer[strlen (buffer) - 1] = '\\0';\n\t}\n    }\n  if (pstring)\n    *pstring = buffer;\n  return 0;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i, argc;\n  char **argv;\n  set_program_name (argv[0]);\n  argcv_get (command, \"=\", &argc, &argv);\n  printf (\"%d args:\\n\", argc);\n  for (i = 0; i < argc; i++)\n    printf (\"%s\\n\", argv[i]);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/argcv.h": {},
  "inetutils/inetutils-1.9.4/libinetutils/cleansess.c": {
    "cleanup_session": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\ncleanup_session (char *tty, int pty_fd)\n{\n  char *line;\n\n# ifdef PATH_TTY_PFX\n  if (strncmp (tty, PATH_TTY_PFX, sizeof PATH_TTY_PFX - 1) == 0)\n    line = tty + sizeof PATH_TTY_PFX - 1;\n  else\n# endif /* PATH_TTY_PFX */\n    line = tty;\n\n  if (logout (line))\n    logwtmp (line, \"\", \"\");\n\n  chmod (tty, 0666);\n  chown (tty, 0, 0);\n  fchmod (pty_fd, 0666);\n  fchown (pty_fd, 0, 0);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/daemon.c": {
    "waitdaemon_timeout": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\nwaitdaemon_timeout (int signo _GL_UNUSED_PARAMETER)\n{\n  int left;\n\n  left = alarm (0);\n  signal (SIGALRM, SIG_DFL);\n  if (left == 0)\n    error (EXIT_FAILURE, 0, \"timed out waiting for child\");\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "waitdaemon": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "int\nwaitdaemon (int nochdir, int noclose, int maxwait)\n{\n  int fd;\n  pid_t childpid;\n  pid_t ppid;\n\n  ppid = getpid ();\n\n  switch (childpid = fork ())\n    {\n    case -1:\t\t\t/* Something went wrong.  */\n      return (-1);\n\n    case 0:\t\t\t/* In the child.  */\n      break;\n\n    default:\t\t\t/* In the parent.  */\n      if (maxwait > 0)\n\t{\n\t  signal (SIGALRM, waitdaemon_timeout);\n\t  alarm (maxwait);\n\t  pause ();\n\t}\n      _exit (EXIT_SUCCESS);\n    }\n\n  if (setsid () == -1)\n    return -1;\n\n  /* SIGHUP must be ignored, because when the session leader terminates,\n     then SIGHUP is sent to all process belonging to the same session,\n     i.e., also to the second child.\n   */\n  signal (SIGHUP, SIG_IGN);\n\n  switch (fork ())\n    {\n    case 0:\n      break;\n\n    case -1:\n      return -1;\n\n    default:\n      _exit (EXIT_SUCCESS);\n    }\n\n  if (!nochdir && chdir (\"/\") < 0)\n    return -1;\t\t\t/* Unlikely failure, but check it.  */\n\n  if (!noclose)\n    {\n      int i;\n      long fdlimit = -1;\n\n#if defined _SC_OPEN_MAX\n      fdlimit = sysconf (_SC_OPEN_MAX);\n#elif defined (HAVE_GETDTABLESIZE)\n      fdlimit = getdtablesize ();\n#endif\n\n      if (fdlimit == -1)\n\tfdlimit = MAXFD;\n\n      for (i = 0; i < fdlimit; i++)\n\tclose (i);\n\n      fd = open (PATH_DEVNULL, O_RDWR, 0);\n      if (fd != -1)\n\t{\n\t  dup2 (fd, STDIN_FILENO);\n\t  dup2 (fd, STDOUT_FILENO);\n\t  dup2 (fd, STDERR_FILENO);\n\t  if (fd > 2)\n\t    close (fd);\n\t}\n    }\n  return ppid;\n}",
      "lines": 80,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "daemon": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\ndaemon (int nochdir, int noclose)\n{\n  return (waitdaemon (nochdir, noclose, 0) == -1) ? -1 : 0;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/defauthors.c": {},
  "inetutils/inetutils-1.9.4/libinetutils/if_index.c": {
    "if_nametoindex": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "unsigned int\nif_nametoindex (const char *ifname)\n{\n  int result = 0;\n#ifdef SIOCGIFINDEX\n  {\n    int fd = socket (AF_INET, SOCK_DGRAM, 0);\n    if (fd >= 0)\n      {\n\tint rc;\n\tstruct ifreq ifr;\n\tstrncpy (ifr.ifr_name, ifname, sizeof (ifr.ifr_name));\n\tifr.ifr_name[IFNAMSIZ - 1] = '\\0';\n\trc = ioctl (fd, SIOCGIFINDEX, &ifr);\n\tclose (fd);\n\tif (rc == 0)\n\t  return ifr.ifr_index;\n      }\n  }\n#endif\n  {\n    struct if_nameindex *idx;\n    idx = if_nameindex ();\n    if (idx != NULL)\n      {\n\tstruct if_nameindex *p;\n\tfor (p = idx; p->if_index || p->if_name; ++p)\n\t  {\n\t    if (strncmp (p->if_name, ifname, IFNAMSIZ) == 0)\n\t      {\n\t\tresult = p->if_index;\n\t\tbreak;\n\t      }\n\t  }\n\tif_freenameindex (idx);\n      }\n    return result;\n  }\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "if_freenameindex": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nif_freenameindex (struct if_nameindex *ifn)\n{\n  struct if_nameindex *ptr = ifn;\n  if (!ifn)\n    return;\n  while (ptr->if_name || ptr->if_index)\n    {\n      free (ptr->if_name);\n      ++ptr;\n    }\n  free (ifn);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "if_nameindex": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "struct if_nameindex *\nif_nameindex (void)\n{\n#if defined SIOCGIFCONF\n  int fd = socket (AF_INET, SOCK_DGRAM, 0);\n  struct ifconf ifc;\n  unsigned int i = 0;\n  int rq_len, last_len;\n  struct if_nameindex *idx = NULL;\n  struct ifreq *ifr, *end, *cur;\n\n  if (fd < 0)\n    return NULL;\n\n  /* A first estimate.  */\n  rq_len = 4 * sizeof (struct ifreq);\n\n  ifc.ifc_buf = NULL;\n  ifc.ifc_len = 0;\n  /* Read all the interfaces out of the kernel.  */\n  do\n    {\n      last_len = ifc.ifc_len;\n      ifc.ifc_buf = alloca (ifc.ifc_len = rq_len);\n      if (ifc.ifc_buf == NULL || ioctl (fd, SIOCGIFCONF, &ifc) < 0)\n\t{\n\t  close (fd);\n\t  return NULL;\n\t}\n      rq_len *= 2;\n    }\n  while (ifc.ifc_len != last_len);\n\n  i = 0;\n  ifr = (struct ifreq *) ifc.ifc_req;\n  end = (struct ifreq *) ((caddr_t) ifr + ifc.ifc_len);\n  while (ifr < end)\n    {\n      cur = ifr;\n\n      ++ifr;\n\n      /* We ignore the other families .. OK ?  */\n      if (cur->ifr_addr.sa_family != AF_INET)\n\tcontinue;\n\n      /* Make Room safely.  */\n      {\n\tstruct if_nameindex *tidx = NULL;\n\ttidx = realloc (idx, (i + 1) * sizeof (*idx));\n\tif (tidx == NULL)\n\t  {\n\t    if_freenameindex (idx);\n\t    close (fd);\n\t    errno = ENOBUFS;\n\t    return NULL;\n\t  }\n\tidx = tidx;\n      }\n\n      /* FIXME: We did not deal with duplicates or interface aliases.  */\n\n      idx[i].if_name = strdup (cur->ifr_name);\n      if (idx[i].if_name == NULL)\n\t{\n\t  if_freenameindex (idx);\n\t  close (fd);\n\t  errno = ENOBUFS;\n\t  return NULL;\n\t}\n\n# if defined SIOCGIFINDEX\n      if (ioctl (fd, SIOCGIFINDEX, cur) >= 0)\n\tidx[i].if_index = cur->ifr_index;\n      else\n# endif\n\tidx[i].if_index = i + 1;\n      i++;\n    }\n\n  /* Terminate the array with an empty solt.  */\n  {\n    struct if_nameindex *tidx = NULL;\n    tidx = realloc (idx, (i + 1) * sizeof (*idx));\n    if (tidx == NULL)\n      {\n\tif_freenameindex (idx);\n\tclose (fd);\n\terrno = ENOBUFS;\n\treturn NULL;\n      }\n    idx = tidx;\n  }\n  idx[i].if_index = 0;\n  idx[i].if_name = NULL;\n\n  close (fd);\n  return idx;\n\n#else\n  errno = ENOSYS;\n  return NULL;\n#endif\n}",
      "lines": 104,
      "depth": 15,
      "decorators": [
        "struct if_nameindex",
        "struct",
        "if_nameindex",
        "*\nif_nameindex (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/kcmd.c": {},
  "inetutils/inetutils-1.9.4/libinetutils/kerberos5.c": {
    "kerberos_auth": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\nkerberos_auth (krb5_context *ctx, int verbose, char **cname,\n\t       const char *sname, int sock, char *cmd,\n\t       unsigned short port, krb5_keyblock **key,\n\t       const char *realm)\n{\n  int rc;\n  char *out, *p;\n  size_t outlen;\n  int krb5len, msglen;\n  char *tmpserver;\n  char auth;\n  /* KERBEROS 5 SENDAUTH MESSAGE */\n  char krb5sendauth[] = \"KRB5_SENDAUTH_V1.0\";\n  /* PROTOCOL VERSION */\n  char krb5sendclient[] = \"KCMDV0.2\";\n\n  /* to store error msg sent by server */\n  char errormsg[101];\n  char cksumdata[101];\n\n  krb5_data cksum_data;\n  krb5_principal server;\n  krb5_auth_context auth_ctx = NULL;\n  krb5_flags authopts = AP_OPTS_USE_SUBKEY;\n\n  if (krb5_sname_to_principal (*ctx, sname, \"host\",\n\t\t\t       KRB5_NT_SRV_HST, &server))\n    return (-1);\n\n  /* If realm is null, look up from table */\n  if (realm == NULL || realm[0] == '\\0')\n#  ifdef KRB5_GENERAL__ /* MIT */\n    realm = (char *) krb5_princ_realm (*ctx, server);\n#  else /* Heimdal */\n    realm = krb5_principal_get_realm (*ctx, server);\n#  endif\n\n  /* size of KRB5 auth message */\n  krb5len = strlen (krb5sendauth) + 1;\n  msglen = htonl (krb5len);\n  write (sock, &msglen, sizeof (int));\n  /* KRB5 authentication message */\n  write (sock, krb5sendauth, krb5len);\n  /* size of client message */\n  krb5len = strlen (krb5sendclient) + 1;\n  msglen = htonl (krb5len);\n  write (sock, &msglen, sizeof (int));\n  /* KRB5 client message */\n  write (sock, krb5sendclient, krb5len);\n\n  /* get answer from server 0 = ok, 1 = error with message */\n  read (sock, &auth, 1);\n  if (auth)\n    {\n      ssize_t n;\n\n      errormsg[0] = '\\0';\n      n = read (sock, errormsg, sizeof (errormsg) - 1);\n\n      if (n >= 0 && n < (ssize_t) sizeof (errormsg))\n\terrormsg[n] = '\\0';\n      else\n\terrormsg[sizeof (errormsg) -1] = '\\0';\n\n      fprintf (stderr, \"Error during server authentication : %s\\n\", errormsg);\n      return -1;\n    }\n\n  if (verbose)\n    {\n      printf (\"Client: %s\\n\", *cname);\n      printf (\"Server: %s\\n\", sname);\n    }\n\n  /* Get a ticket for the server. */\n\n  tmpserver = malloc (strlen (SERVICE) + strlen (sname) + 2);\n  if (!tmpserver)\n    {\n      perror (\"kerberos_auth()\");\n      return -1;\n    }\n\n  p = strchr (sname, '/');\n  if (p && (p != sname))\n    strcpy (tmpserver, sname);\t/* Non-empty prefix.  */\n  else\n    sprintf (tmpserver, \"%s/%s\", SERVICE, sname + (p ? 1 : 0));\n\n  /* Retrieve realm assigned to this server as per configuration,\n   * unless an explicit domain was passed in the call.\n   */\n  if (!realm)\n    {\n      if (!p)\n\tp = (char *) sname;\n      else if (*p == '/')\n\t++p;\n    }\n\n  /* checksum = port: terminal name */\n\n  cksum_data.length = snprintf (cksumdata, sizeof (cksumdata) - 1,\n\t\t\t\t\"%u:%s%s\", ntohs (port), cmd, *cname);\n\n  if (strncmp (cmd, \"-x \", 3) == 0)\n    authopts |= AP_OPTS_MUTUAL_REQUIRED;\n\n  cksum_data.data = cksumdata;\n\n  rc = krb5_sendauth (*ctx, &auth_ctx, &sock, \"KCMDV0.2\",\n\t\t      NULL, server, authopts, &cksum_data,\n\t\t      NULL, NULL, NULL, NULL, NULL);\n\n  if (rc == KRB5_SENDAUTH_REJECTED)\n  {\n    fprintf (stderr, \"server rejected authentication\");\n    return rc;\n  }\n\n  krb5_free_principal (*ctx, server);\n# if 0\n  krb5_data_free (&cksum_data);\n# endif\n\n  rc = krb5_auth_con_getlocalsubkey (*ctx, auth_ctx, key);\n\n  /* send size of AP-REQ to the server */\n\n  msglen = outlen;\n  msglen = htonl (msglen);\n  write (sock, (char *) &msglen, sizeof (int));\n\n  /* send AP-REQ to the server */\n\n  write (sock, out, outlen);\n\n  /* read response from server - what ? */\n\n  read (sock, &rc, sizeof (rc));\n  if (rc)\n    return -1 /* SHISHI_APREP_VERIFY_FAILED */;\n\n  /* For mutual authentication, wait for server reply. */\n\n  /* We are now authenticated. */\n  if (verbose)\n    printf (\"User authenticated.\\n\");\n\n  return 0;\n\n}",
      "lines": 153,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "get_auth": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "int\nget_auth (int infd, krb5_context *ctx, krb5_auth_context *actx,\n\t  krb5_keyblock **key, const char **err_msg,\n\t  int *protoversion, int *cksumtype,\n\t  char **cksum, size_t *cksumlen, char *srvname)\n{\n  char *out;\n  size_t outlen;\n  char *buf;\n  int buflen;\n  int len;\n  int rc;\n  int error;\n  /* KERBEROS 5 SENDAUTH MESSAGE */\n  char krb5sendauth[] = \"KRB5_SENDAUTH_V1.0\";\n  /* PROTOCOL VERSION */\n  char krb5kcmd1[] = \"KCMDV0.1\";\n  char krb5kcmd2[] = \"KCMDV0.2\";\n  char *servername, *server = NULL, *realm = NULL;\n\n  *err_msg = NULL;\n  /* Get key for the server. */\n\n# if 0\n  /*\n   * XXX: Taken straight from the version for libshishi.\n   * XXX: No adaptions yet.\n   */\n  rc = shishi_init_server (handle);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  if (srvname && *srvname)\n    {\n      rc = shishi_parse_name (*handle, srvname, &server, &realm);\n      if (rc != SHISHI_OK)\n\t{\n\t  *err_msg = shishi_strerror (rc);\n\t  return rc;\n\t}\n    }\n\n  if (server && *server)\n    {\n      char *p;\n\n      servername = malloc (sizeof (SERVICE) + strlen (server) + 2);\n      if (!servername)\n\t{\n\t  *err_msg = \"Not enough memory\";\n\t  return SHISHI_TOO_SMALL_BUFFER;\n\t}\n\n      p = strchr (server, '/');\n      if (p && (p != server))\n\tsprintf (servername, \"%s\", server);\t/* Non-empty prefix.  */\n      else\n\tsprintf (servername, \"%s/%s\", SERVICE,\n\t\t server + (p ? 1 : 0));\t/* Remove initial slash.  */\n    }\n  else\n    servername = shishi_server_for_local_service (*handle, SERVICE);\n\n  if (realm && *realm)\n    shishi_realm_default_set (*handle, realm);\n\n  free (server);\n  free (realm);\n\n  /* Enable use of `~/.k5login'.  */\n  if (shishi_check_version (\"1.0.2\"))\t/* Faulty in version 1.0.1.  */\n    {\n      rc = shishi_cfg_authorizationtype_set (*handle, \"k5login basic\");\n      if (rc != SHISHI_OK)\n\t{\n\t  *err_msg = shishi_error (*handle);\n\t  return rc;\n\t}\n    }\n\n  key = shishi_hostkeys_for_serverrealm (*handle, servername,\n\t\t\t\t\t shishi_realm_default (*handle));\n  free (servername);\n  if (!key)\n    {\n      *err_msg = shishi_error (*handle);\n      return SHISHI_INVALID_KEY;\n    }\n\n  /* Read Kerberos 5 sendauth message */\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading message size\";\n      return SHISHI_IO_ERROR;\n    }\n\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading authentication message\";\n      return SHISHI_IO_ERROR;\n    }\n\n  len = strlen (krb5sendauth);\n  rc = strncmp (buf, krb5sendauth, buflen >= len ? len : buflen);\n  if (rc)\n    {\n      *err_msg = \"Invalid authentication type\";\n      /* Authentication type is wrong.  */\n      write (infd, \"\\001\", 1);\n      return SHISHI_VERIFY_FAILED;\n    }\n\n  free (buf);\n\n  /* Read protocol version */\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading protocol message size\";\n      return SHISHI_IO_ERROR;\n    }\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading protocol message\";\n      return SHISHI_IO_ERROR;\n    }\n\n  len = strlen (krb5kcmd1);\n  rc = strncmp (buf, krb5kcmd1, buflen >= len ? len : buflen);\n  if (rc)\n    {\n      len = strlen (krb5kcmd2);\n      rc = strncmp (buf, krb5kcmd2, buflen >= len ? len : buflen);\n      if (rc)\n\t{\n\t  *err_msg = \"Protocol version not supported\";\n\t  /* Protocol version is wrong.  */\n\t  write (infd, \"\\002\", 1);\n\t  return SHISHI_VERIFY_FAILED;\n\t}\n      *protoversion = 2;\n    }\n  else\n    *protoversion = 1;\n\n  free (buf);\n\n  /* Authentication type is ok */\n\n  write (infd, \"\\0\", 1);\n\n  /* Read Authentication request from client */\n\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading authentication request size\";\n      return SHISHI_IO_ERROR;\n    }\n\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading authentication request\";\n      return SHISHI_IO_ERROR;\n    }\n\n  /* Create Authentication context */\n\n  rc = shishi_ap_nosubkey (*handle, ap);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  /* Store request in context */\n\n  rc = shishi_ap_req_der_set (*ap, buf, buflen);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  free (buf);\n\n  /* Process authentication request */\n\n  rc = shishi_ap_req_process (*ap, key);\n  if (rc != SHISHI_OK)\n    return rc;\n\n# ifdef ENCRYPTION\n\n  /* extract subkey if present from ap exchange for secure connection */\n  if (*protoversion == 2)\n    {\n      *enckey = NULL;\n      shishi_authenticator_get_subkey (*handle,\n\t\t\t\t       shishi_ap_authenticator (*ap), enckey);\n    }\n\n# endif\n\n  /* Get authenticator checksum */\n  rc = shishi_authenticator_cksum (*handle,\n\t\t\t\t   shishi_ap_authenticator (*ap),\n\t\t\t\t   cksumtype, cksum, cksumlen);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  /* User is authenticated.  */\n  error = 0;\n  write (infd, &error, sizeof (int));\n\n  /* Authenticate ourself to client, if requested.  */\n\n  if (shishi_apreq_mutual_required_p (*handle, shishi_ap_req (*ap)))\n    {\n      int len;\n\n      rc = shishi_ap_rep_der (*ap, &out, &outlen);\n      if (rc != SHISHI_OK)\n\treturn rc;\n\n      len = outlen;\n      len = htonl (len);\n      rc = write (infd, &len, sizeof (len));\n      if (rc != sizeof (int))\n\t{\n\t  *err_msg = \"Error sending AP-REP\";\n\t  free (out);\n\t  return SHISHI_IO_ERROR;\n\t}\n\n      rc = write (infd, out, ntohl (len));\n      if (rc != (int) ntohl (len))\n\t{\n\t  *err_msg = \"Error sending AP-REP\";\n\t  free (out);\n\t  return SHISHI_IO_ERROR;\n\t}\n\n      free (out);\n\n      /* We are authenticated to client */\n    }\n\n# ifdef ENCRYPTION\n  if (*protoversion == 1)\n    {\n      Shishi_tkt *tkt;\n\n      tkt = shishi_ap_tkt (*ap);\n      if (tkt == NULL)\n\t{\n\t  *err_msg = \"Could not get tkt from AP-REQ\";\n\t  return SHISHI_INVALID_TICKET;\n\t}\n\n      rc = shishi_encticketpart_get_key (*handle,\n\t\t\t\t\t shishi_tkt_encticketpart (tkt),\n\t\t\t\t\t enckey);\n      if (rc != SHISHI_OK)\n\treturn rc;\n    }\n# endif /* ENCRYPTION */\n\n  return 0;\n# else\n  return -1;\n# endif\n}",
      "lines": 295,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/kerberos5_def.h": {},
  "inetutils/inetutils-1.9.4/libinetutils/krcmd.c": {
    "krcmd": [
      {
        "start_point": [
          104,
          0
        ],
        "end_point": [
          146,
          1
        ],
        "content": "int\nkrcmd (Shishi ** h, char **ahost, unsigned short rport, char **remuser,\n       char *cmd, int *fd2p, const char *realm, int af)\n{\n  int sock = -1, err = 0;\n  long authopts = 0L;\n\n#  ifdef HAVE_GETPWUID_R\n  if (!pwbuf)\n    {\n      pwbuflen = sysconf (_SC_GETPW_R_SIZE_MAX);\n      if (pwbuflen <= 0)\n\tpwbuflen = 1024;\t/* Guessing only.  */\n\n      pwbuf = malloc (pwbuflen);\n    }\n\n  if (pwbuf)\n    (void) getpwuid_r (getuid (), &pwstor, pwbuf, pwbuflen, &pwd);\n#  endif /* HAVE_GETPWUID_R */\n\n  err = kcmd (h, &sock, ahost, rport,\n#  ifdef HAVE_GETPWUID_R\n\t      pwd ? pwd->pw_name : *remuser,\t/* locuser */\n#  else /* !HAVE_GETPWUID_R */\n\t      NULL,\t\t/* locuser not used */\n#  endif\n\t      remuser, cmd, fd2p,\n\t      SERVICE_NAME, realm,\n\t      NULL,\t\t/* key schedule not used */\n\t      NULL,\t\t/* local addr not used */\n\t      NULL,\t\t/* foreign addr not used */\n\t      authopts, af);\n\n  if (err > SHISHI_OK)\n    {\n      fprintf (stderr, \"krcmd: error %d, %s\\n\", err, shishi_strerror (err));\n      return (-1);\n    }\n  if (err < 0)\n    return (-1);\n  return (sock);\n}",
        "lines": 43,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          149,
          0
        ],
        "end_point": [
          177,
          1
        ],
        "content": "int\nkrcmd (krb5_context *ctx, char **ahost, unsigned short rport,\n       char **remuser, char *cmd, int *fd2p, const char *realm)\n{\n  int sock = -1;\n  krb5_error_code err = 0;\n  long authopts = 0L;\n\n  err = kcmd (ctx, &sock, ahost, rport,\n\t      NULL,\t/* locuser not used */\n\t      remuser, cmd, fd2p,\n\t      SERVICE_NAME, realm,\n\t      (krb5_keyblock **) NULL,\t\t/* key not used */\n\t      (struct sockaddr_in *) NULL,\t/* local addr not used */\n\t      (struct sockaddr_in *) NULL,\t/* foreign addr not used */\n\t      authopts);\n\n  if (err > 0)\n    {\n      const char *text = krb5_get_error_message (*ctx, err);\n\n      fprintf (stderr, \"krcmd: %s\\n\", text);\n      krb5_free_error_message (*ctx, text);\n      return (-1);\n    }\n  if (err < 0)\n    return (-1);\n  return (sock);\n}",
        "lines": 29,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "krcmd_mutual": [
      {
        "start_point": [
          183,
          0
        ],
        "end_point": [
          228,
          1
        ],
        "content": "int\nkrcmd_mutual (Shishi ** h, char **ahost, unsigned short rport, char **remuser,\n\t      char *cmd, int *fd2p, const char *realm, Shishi_key ** key, int af)\n{\n  int sock = -1, err = 0;\n  struct sockaddr_storage laddr, faddr;\n  long authopts = SHISHI_APOPTIONS_MUTUAL_REQUIRED;\n\n#   ifdef HAVE_GETPWUID_R\n  if (!pwbuf)\n    {\n      pwbuflen = sysconf (_SC_GETPW_R_SIZE_MAX);\n      if (pwbuflen <= 0)\n\tpwbuflen = 1024;\t/* Guessing only.  */\n\n      pwbuf = malloc (pwbuflen);\n    }\n\n  if (pwbuf)\n    (void) getpwuid_r (getuid (), &pwstor, pwbuf, pwbuflen, &pwd);\n#   endif /* HAVE_GETPWUID_R */\n\n  err = kcmd (h, &sock, ahost, rport,\n#   ifdef HAVE_GETPWUID_R\n\t      pwd ? pwd->pw_name : *remuser,\t/* locuser */\n#   else /* !HAVE_GETPWUID_R */\n\t      NULL,\t\t/* locuser not used */\n#   endif\n\t      remuser, cmd, fd2p,\n\t      SERVICE_NAME, realm,\n\t      key,\t\t/* filled in */\n\t      &laddr,\t\t/* filled in */\n\t      &faddr,\t\t/* filled in */\n\t      authopts, af);\n\n  if (err > SHISHI_OK)\n    {\n      fprintf (stderr, \"krcmd_mutual: error %d, %s\\n\",\n\t       err, shishi_strerror (err));\n      return (-1);\n    }\n\n  if (err < 0)\n    return (-1);\n  return (sock);\n}",
        "lines": 46,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          231,
          0
        ],
        "end_point": [
          262,
          1
        ],
        "content": "int\nkrcmd_mutual (krb5_context *ctx, char **ahost, unsigned short rport,\n\t      char **remuser, char *cmd, int *fd2p, const char *realm,\n\t      krb5_keyblock **key)\n{\n  int sock;\n  krb5_error_code err = 0;\n  struct sockaddr_in laddr, faddr;\n  long authopts = AP_OPTS_MUTUAL_REQUIRED | AP_OPTS_USE_SUBKEY;\n\n  err = kcmd (ctx, &sock, ahost, rport,\n\t      NULL,\t\t/* locuser not used */\n\t      remuser, cmd, fd2p,\n\t      SERVICE_NAME, realm,\n\t      key,\t\t/* filled in */\n\t      &laddr,\t\t/* filled in */\n\t      &faddr,\t\t/* filled in */\n\t      authopts);\n\n  if (err > 0)\n    {\n      const char *text = krb5_get_error_message (*ctx, err);\n\n      fprintf (stderr, \"krcmd_mutual: %s\\n\", text);\n      krb5_free_error_message (*ctx, text);\n      return (-1);\n    }\n\n  if (err < 0)\n    return (-1);\n  return (sock);\n}",
        "lines": 32,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "inetutils/inetutils-1.9.4/libinetutils/libinetutils.h": {},
  "inetutils/inetutils-1.9.4/libinetutils/localhost.c": {
    "localhost": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "char *\nlocalhost (void)\n{\n  char *buf = NULL;\n  size_t buf_len = 0;\n  int status = 0;\n\n  do\n    {\n      char *tmp;\n      errno = 0;\n\n      buf_len += 256;\t\t/* Initial guess */\n      tmp = realloc (buf, buf_len);\n      if (tmp == NULL)\n\t{\n\t  errno = ENOMEM;\n\t  free (buf);\n\t  return 0;\n\t}\n      else\n\tbuf = tmp;\n    }\n  while (((status = gethostname (buf, buf_len)) == 0\n\t  && !memchr (buf, '\\0', buf_len))\n#ifdef ENAMETOOLONG\n\t || errno == ENAMETOOLONG\n#endif\n    );\n\n  if (status != 0 && errno != 0)\n    /* gethostname failed, abort.  */\n    {\n      free (buf);\n      buf = 0;\n    }\n  else\n    /* Determine FQDN.  */\n    {\n#if HAVE_DECL_GETADDRINFO\n      int rc;\n      struct addrinfo hints, *res;\n      char fqdn[NI_MAXHOST];\n\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_family = AF_INET;\n\n      rc = getaddrinfo (buf, NULL, &hints, &res);\n      if (!rc)\n\t{\n\t  /* Back resolving as official host name.  */\n\t  rc = getnameinfo (res->ai_addr, res->ai_addrlen,\n\t\t\t    fqdn, sizeof (fqdn), NULL, 0,\n\t\t\t    NI_NAMEREQD);\n\t  if (!rc)\n\t    {\n\t      free (buf);\n\t      buf = strdup (fqdn);\n\t    }\n\t  freeaddrinfo (res);\n\t}\n#else /* !HAVE_DECL_GETADDRINFO */\n      struct hostent *hp = gethostbyname (buf);\n\n      if (hp)\n\t{\n\t  struct in_addr addr;\n\t  addr.s_addr = *(unsigned int *) hp->h_addr;\n\t  hp = gethostbyaddr ((char *) &addr, sizeof (addr), AF_INET);\n\t  if (hp)\n\t    {\n\t      free (buf);\n\t      buf = strdup (hp->h_name);\n\t    }\n\t}\n#endif /* !HAVE_DECL_GETADDRINFO */\n    }\n  return buf;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "char",
        "*\nlocalhost (void)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/logwtmp.c": {},
  "inetutils/inetutils-1.9.4/libinetutils/logwtmpko.c": {
    "logwtmp": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nlogwtmp (char *line, char *name, char *host)\n{\n  struct utmpx ut;\n  struct timeval tv;\n\n  memset (&ut, 0, sizeof (ut));\n#ifdef HAVE_STRUCT_UTMPX_UT_TYPE\n  if (name && *name)\n    ut.ut_type = USER_PROCESS;\n  else\n    ut.ut_type = DEAD_PROCESS;\n#endif /* UT_TYPE */\n\n  strncpy (ut.ut_line, line, sizeof ut.ut_line);\n#ifdef HAVE_STRUCT_UTMPX_UT_USER\n  strncpy (ut.ut_user, name, sizeof ut.ut_user);\n#elif defined HAVE_STRUCT_UTMPX_UT_NAME\n  strncpy (ut.ut_name, name, sizeof ut.ut_name);\n#endif\n#ifdef HAVE_STRUCT_UTMPX_UT_HOST\n  strncpy (ut.ut_host, host, sizeof ut.ut_host);\n# ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN\n  if (strlen (host) < sizeof (ut.ut_host))\n    ut.ut_syslen = strlen (host) + 1;\n  else\n    {\n      ut.ut_host[sizeof (ut.ut_host) - 1] = '\\0';\n      ut.ut_syslen = sizeof (ut.ut_host);\n    }\n# endif /* UT_SYSLEN */\n#endif\n#ifdef HAVE_STRUCT_UTMPX_UT_PID\n  ut.ut_pid = getpid ();\n#endif\n\n  gettimeofday (&tv, NULL);\n  ut.ut_tv.tv_sec = tv.tv_sec;\n  ut.ut_tv.tv_usec = tv.tv_usec;\n\n  updwtmpx (PATH_WTMPX, &ut);\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/setsig.c": {
    "setsig": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "sighandler_t\nsetsig (int sig, sighandler_t handler)\n{\n#ifdef HAVE_SIGACTION\n  struct sigaction sa, osa;\n  sigemptyset (&sa.sa_mask);\n  sigemptyset (&osa.sa_mask);\n# ifdef SA_RESTART\n  sa.sa_flags |= SA_RESTART;\n# endif\n  sa.sa_handler = handler;\n  if (sigaction (sig, &sa, &osa) < 0)\n    return SIG_ERR;\n  return osa.sa_handler;\n#else /* !HAVE_SIGACTION */\n# ifdef HAVE_SIGVEC\n  struct sigvec sv, osv;\n  sigemptyset (&sv.sv_mask);\n  sigemptyset (&osv.sv_mask);\n  sv.sv_handler = handler;\n  if (sigvec (sig, &sv, &osv) < 0)\n    return SIG_ERR;\n  return osv.sv_handler;\n# else /* !HAVE_SIGVEC */\n  return signal (sig, handler);\n# endif\t/* HAVE_SIGVEC */\n#endif /* HAVE_SIGACTION */\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "sighandler_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/shishi.c": {
    "shishi_auth": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\nshishi_auth (Shishi ** handle, int verbose, char **cname,\n\t     const char *sname, int sock, char *cmd,\n\t     unsigned short port, Shishi_key ** enckey,\n\t     const char *realm)\n{\n  Shishi_ap *ap;\n  Shishi_tkt *tkt;\n  Shishi_tkts_hint hint;\n  Shishi *h;\n\n  int rc;\n  char *out, *p;\n  size_t outlen;\n  int krb5len, msglen;\n  char *tmpserver;\n  char auth;\n  /* KERBEROS 5 SENDAUTH MESSAGE */\n  char krb5sendauth[] = \"KRB5_SENDAUTH_V1.0\";\n  /* PROTOCOL VERSION */\n  char krb5sendclient[] = \"KCMDV0.2\";\n  /* to store error msg sent by server */\n  char errormsg[101];\n  char cksumdata[101];\n\n  if (!shishi_check_version (SHISHI_VERSION))\n    {\n      fprintf (stderr, \"shishi_check_version() failed:\\n\"\n\t       \"Header file incompatible with shared library.\\n\");\n      return SHISHI_INVALID_ARGUMENT;\n    }\n\n  rc = shishi_init (handle);\n  if (rc != SHISHI_OK)\n    {\n      fprintf (stderr,\n\t       \"error initializing shishi: %s\\n\", shishi_strerror (rc));\n      return rc;\n    }\n\n  if (realm)\n    shishi_realm_default_set (*handle, realm);\n\n  h = *handle;\n\n  if (!*cname)\n    *cname = (char *) shishi_principal_default (h);\n\n  /* size of KRB5 auth message */\n  krb5len = strlen (krb5sendauth) + 1;\n  msglen = htonl (krb5len);\n  write (sock, &msglen, sizeof (int));\n  /* KRB5 authentication message */\n  write (sock, krb5sendauth, krb5len);\n  /* size of client message */\n  krb5len = strlen (krb5sendclient) + 1;\n  msglen = htonl (krb5len);\n  write (sock, &msglen, sizeof (int));\n  /* KRB5 client message */\n  write (sock, krb5sendclient, krb5len);\n\n  /* get answer from server 0 = ok, 1 = error with message */\n  read (sock, &auth, 1);\n  if (auth)\n    {\n      ssize_t n;\n\n      errormsg[0] = '\\0';\n      n = read (sock, errormsg, sizeof (errormsg) - 1);\n\n      if (n >= 0 && n < (ssize_t) sizeof (errormsg))\n\terrormsg[n] = '\\0';\n      else\n\terrormsg[sizeof (errormsg) -1] = '\\0';\n\n      fprintf (stderr, \"Error during server authentication : %s\\n\", errormsg);\n      return SHISHI_VERIFY_FAILED;\n    }\n\n  if (verbose)\n    {\n      printf (\"Client: %s\\n\", *cname);\n      printf (\"Server: %s\\n\", sname);\n    }\n\n  /* Get a ticket for the server. */\n\n  memset (&hint, 0, sizeof (hint));\n\n  tmpserver = malloc (strlen (SERVICE) + strlen (sname) + 2);\n  if (!tmpserver)\n    {\n      perror (\"shishi_auth()\");\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  p = strchr (sname, '/');\n  if (p && (p != sname))\n    strcpy (tmpserver, sname);\t/* Non-empty prefix.  */\n  else\n    sprintf (tmpserver, \"%s/%s\", SERVICE, sname + (p ? 1 : 0));\n\n  /* Retrieve realm assigned to this server as per configuration,\n   * unless an explicit domain was passed in the call.\n   */\n  if (!realm)\n    {\n      if (!p)\n\tp = (char *) sname;\n      else if (*p == '/')\n\t++p;\n\n      shishi_realm_default_set (h, shishi_realm_for_server (h, p));\n    }\n\n  hint.client = (char *) *cname;\n  hint.server = (char *) tmpserver;\n\n  tkt = shishi_tkts_get (shishi_tkts_default (h), &hint);\n  if (!tkt)\n    {\n      fprintf (stderr, \"cannot find ticket for \\\"%s@%s\\\"\\n\",\n\t       tmpserver, shishi_realm_default (h));\n      free (tmpserver);\n      return SHISHI_INVALID_TICKET;\n    }\n\n  free (tmpserver);\n\n  if (verbose)\n    shishi_tkt_pretty_print (tkt, stderr);\n\n  /* Create Authentication context */\n\n  rc = shishi_ap_tktoptions (h, &ap, tkt, SHISHI_APOPTIONS_MUTUAL_REQUIRED);\n  if (rc != SHISHI_OK)\n    {\n      fprintf (stderr, \"cannot create authentication context\\n\");\n      return rc;\n    }\n\n\n  /* checksum = port: terminal name */\n\n  snprintf (cksumdata, sizeof (cksumdata) - 1,\n\t    \"%u:%s%s\", ntohs (port), cmd, *cname);\n\n  /* add checksum to authenticator */\n\n  shishi_ap_authenticator_cksumdata_set (ap, cksumdata, strlen (cksumdata));\n  /* To be compatible with MIT rlogind */\n  shishi_ap_authenticator_cksumtype_set (ap, SHISHI_RSA_MD5);\n\n  /* create der encoded AP-REQ */\n\n  rc = shishi_ap_req_der (ap, &out, &outlen);\n  if (rc != SHISHI_OK)\n    {\n      fprintf (stderr, \"cannot build authentication request: %s\\n\",\n\t       shishi_strerror (rc));\n\n      return rc;\n    }\n\n  if (verbose)\n    shishi_authenticator_print (h, stderr, shishi_ap_authenticator (ap));\n\n  /* extract subkey if present from ap exchange for secure connection */\n\n  if (enckey)\n    shishi_authenticator_get_subkey (h, shishi_ap_authenticator (ap), enckey);\n\n  /* send size of AP-REQ to the server */\n\n  msglen = outlen;\n  msglen = htonl (msglen);\n  write (sock, (char *) &msglen, sizeof (int));\n\n  /* send AP-REQ to the server */\n\n  write (sock, out, outlen);\n\n  /* read response from server - what ? */\n\n  read (sock, &rc, sizeof (rc));\n  if (rc)\n    return SHISHI_APREP_VERIFY_FAILED;\n\n  /* For mutual authentication, wait for server reply. */\n\n  if (shishi_apreq_mutual_required_p (h, shishi_ap_req (ap)))\n    {\n      if (verbose)\n\tprintf (\"Waiting for server to authenticate itself...\\n\");\n\n      /* read size of the AP-REP */\n\n      read (sock, (char *) &msglen, sizeof (int));\n\n      /* read AP-REP */\n      outlen = ntohl (msglen);\n      outlen = read (sock, out, outlen);\n\n      rc = shishi_ap_rep_verify_der (ap, out, outlen);\n      if (rc == SHISHI_OK)\n\t{\n\t  if (verbose)\n\t    printf (\"AP-REP verification OK...\\n\");\n\t}\n      else\n\t{\n\t  if (rc == SHISHI_APREP_VERIFY_FAILED)\n\t    fprintf (stderr, \"AP-REP verification failed...\\n\");\n\t  else\n\t    fprintf (stderr, \"AP-REP verification error: %s\\n\",\n\t\t     shishi_strerror (rc));\n\t  return rc;\n\t}\n\n      /* The server is authenticated. */\n      if (verbose)\n\tprintf (\"Server authenticated.\\n\");\n    }\n\n  /* We are now authenticated. */\n  if (verbose)\n    printf (\"User authenticated.\\n\");\n\n  return SHISHI_OK;\n\n}",
      "lines": 231,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "get_auth": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        568,
        1
      ],
      "content": "int\nget_auth (int infd, Shishi ** handle, Shishi_ap ** ap,\n\t  Shishi_key ** enckey, const char **err_msg, int *protoversion,\n\t  int *cksumtype, char **cksum, size_t *cksumlen, char *srvname)\n{\n  Shishi_key *key;\n  char *out;\n  size_t outlen;\n  char *buf;\n  int buflen;\n  int len;\n  int rc;\n  int error;\n  /* KERBEROS 5 SENDAUTH MESSAGE */\n  char krb5sendauth[] = \"KRB5_SENDAUTH_V1.0\";\n  /* PROTOCOL VERSION */\n  char krb5kcmd1[] = \"KCMDV0.1\";\n  char krb5kcmd2[] = \"KCMDV0.2\";\n  char *servername, *server = NULL, *realm = NULL;\n\n  *err_msg = NULL;\n  /* Get key for the server. */\n\n  if (!shishi_check_version (SHISHI_VERSION))\n    {\n      *err_msg =\n\t\"shishi_check_version() failed: header file incompatible with shared library.\";\n      return SHISHI_INVALID_ARGUMENT;\n    }\n\n  rc = shishi_init_server (handle);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  if (srvname && *srvname)\n    {\n      rc = shishi_parse_name (*handle, srvname, &server, &realm);\n      if (rc != SHISHI_OK)\n\t{\n\t  *err_msg = shishi_strerror (rc);\n\t  return rc;\n\t}\n    }\n\n  if (server && *server)\n    {\n      char *p;\n\n      servername = malloc (sizeof (SERVICE) + strlen (server) + 2);\n      if (!servername)\n\t{\n\t  *err_msg = \"Not enough memory\";\n\t  return SHISHI_TOO_SMALL_BUFFER;\n\t}\n\n      p = strchr (server, '/');\n      if (p && (p != server))\n\tsprintf (servername, \"%s\", server);\t/* Non-empty prefix.  */\n      else\n\tsprintf (servername, \"%s/%s\", SERVICE,\n\t\t server + (p ? 1 : 0));\t/* Remove initial slash.  */\n    }\n  else\n    servername = shishi_server_for_local_service (*handle, SERVICE);\n\n  if (realm && *realm)\n    shishi_realm_default_set (*handle, realm);\n\n  free (server);\n  free (realm);\n\n  /* Enable use of `~/.k5login'.  */\n  if (shishi_check_version (\"1.0.2\"))\t/* Faulty in version 1.0.1.  */\n    {\n      rc = shishi_cfg_authorizationtype_set (*handle, \"k5login basic\");\n      if (rc != SHISHI_OK)\n\t{\n\t  *err_msg = shishi_error (*handle);\n\t  return rc;\n\t}\n    }\n\n  key = shishi_hostkeys_for_serverrealm (*handle, servername,\n\t\t\t\t\t shishi_realm_default (*handle));\n  free (servername);\n  if (!key)\n    {\n      *err_msg = shishi_error (*handle);\n      return SHISHI_INVALID_KEY;\n    }\n\n  /* Read Kerberos 5 sendauth message */\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading message size\";\n      return SHISHI_IO_ERROR;\n    }\n\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading authentication message\";\n      return SHISHI_IO_ERROR;\n    }\n\n  len = strlen (krb5sendauth);\n  rc = strncmp (buf, krb5sendauth, buflen >= len ? len : buflen);\n  if (rc)\n    {\n      *err_msg = \"Invalid authentication type\";\n      /* Authentication type is wrong.  */\n      write (infd, \"\\001\", 1);\n      return SHISHI_VERIFY_FAILED;\n    }\n\n  free (buf);\n\n  /* Read protocol version */\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading protocol message size\";\n      return SHISHI_IO_ERROR;\n    }\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading protocol message\";\n      return SHISHI_IO_ERROR;\n    }\n\n  len = strlen (krb5kcmd1);\n  rc = strncmp (buf, krb5kcmd1, buflen >= len ? len : buflen);\n  if (rc)\n    {\n      len = strlen (krb5kcmd2);\n      rc = strncmp (buf, krb5kcmd2, buflen >= len ? len : buflen);\n      if (rc)\n\t{\n\t  *err_msg = \"Protocol version not supported\";\n\t  /* Protocol version is wrong.  */\n\t  write (infd, \"\\002\", 1);\n\t  return SHISHI_VERIFY_FAILED;\n\t}\n      *protoversion = 2;\n    }\n  else\n    *protoversion = 1;\n\n  free (buf);\n\n  /* Authentication type is ok */\n\n  write (infd, \"\\0\", 1);\n\n  /* Read Authentication request from client */\n\n  rc = read (infd, &len, sizeof (int));\n  if (rc != sizeof (int))\n    {\n      *err_msg = \"Error reading authentication request size\";\n      return SHISHI_IO_ERROR;\n    }\n\n  buflen = ntohl (len);\n  buf = malloc (buflen);\n  if (!buf)\n    {\n      *err_msg = \"Not enough memory\";\n      return SHISHI_TOO_SMALL_BUFFER;\n    }\n\n  rc = read (infd, buf, buflen);\n  if (rc != buflen)\n    {\n      *err_msg = \"Error reading authentication request\";\n      return SHISHI_IO_ERROR;\n    }\n\n  /* Create Authentication context */\n\n  rc = shishi_ap_nosubkey (*handle, ap);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  /* Store request in context */\n\n  rc = shishi_ap_req_der_set (*ap, buf, buflen);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  free (buf);\n\n  /* Process authentication request */\n\n  rc = shishi_ap_req_process (*ap, key);\n  if (rc != SHISHI_OK)\n    return rc;\n\n# ifdef ENCRYPTION\n\n  /* extract subkey if present from ap exchange for secure connection */\n  if (*protoversion == 2)\n    {\n      *enckey = NULL;\n      shishi_authenticator_get_subkey (*handle,\n\t\t\t\t       shishi_ap_authenticator (*ap), enckey);\n    }\n\n# endif\n\n  /* Get authenticator checksum */\n  rc = shishi_authenticator_cksum (*handle,\n\t\t\t\t   shishi_ap_authenticator (*ap),\n\t\t\t\t   cksumtype, cksum, cksumlen);\n  if (rc != SHISHI_OK)\n    return rc;\n\n  /* User is authenticated.  */\n  error = 0;\n  write (infd, &error, sizeof (int));\n\n  /* Authenticate ourself to client, if requested.  */\n\n  if (shishi_apreq_mutual_required_p (*handle, shishi_ap_req (*ap)))\n    {\n      int len;\n\n      rc = shishi_ap_rep_der (*ap, &out, &outlen);\n      if (rc != SHISHI_OK)\n\treturn rc;\n\n      len = outlen;\n      len = htonl (len);\n      rc = write (infd, &len, sizeof (len));\n      if (rc != sizeof (int))\n\t{\n\t  *err_msg = \"Error sending AP-REP\";\n\t  free (out);\n\t  return SHISHI_IO_ERROR;\n\t}\n\n      rc = write (infd, out, ntohl (len));\n      if (rc != (int) ntohl (len))\n\t{\n\t  *err_msg = \"Error sending AP-REP\";\n\t  free (out);\n\t  return SHISHI_IO_ERROR;\n\t}\n\n      free (out);\n\n      /* We are authenticated to client */\n    }\n\n# ifdef ENCRYPTION\n  if (*protoversion == 1)\n    {\n      Shishi_tkt *tkt;\n\n      tkt = shishi_ap_tkt (*ap);\n      if (tkt == NULL)\n\t{\n\t  *err_msg = \"Could not get tkt from AP-REQ\";\n\t  return SHISHI_INVALID_TICKET;\n\t}\n\n      rc = shishi_encticketpart_get_key (*handle,\n\t\t\t\t\t shishi_tkt_encticketpart (tkt),\n\t\t\t\t\t enckey);\n      if (rc != SHISHI_OK)\n\treturn rc;\n    }\n# endif\n\n  return SHISHI_OK;\n}",
      "lines": 294,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "readenc": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "int\nreadenc (Shishi * h, int sock, char *buf, int *len, shishi_ivector * iv,\n\t Shishi_key * enckey, int proto)\n{\n  char *out;\n  char *outbis;\n\n  int rc;\n  int val;\n  size_t outlen;\n  int dlen = 0, blocksize, enctype, hashsize;\n\n  /* read size of message */\n  read (sock, &dlen, sizeof (int));\n\n  dlen = ntohl (dlen);\n  /* if 0 put read size to 0 */\n  if (!dlen)\n    {\n      *len = dlen;\n      return SHISHI_OK;\n    }\n\n  if (proto == 1)\n    *len = dlen;\n\n  /* convert size to encryption size */\n  enctype = shishi_key_type (enckey);\n\n  blocksize = shishi_cipher_blocksize (enctype);\n  hashsize =\n    shishi_checksum_cksumlen (shishi_cipher_defaultcksumtype (enctype));\n\n  switch (enctype)\n    {\n    case SHISHI_AES128_CTS_HMAC_SHA1_96:\n    case SHISHI_AES256_CTS_HMAC_SHA1_96:\n      dlen += 4 + hashsize + blocksize;\n      break;\n    case SHISHI_ARCFOUR_HMAC:\n    case SHISHI_ARCFOUR_HMAC_EXP:\n      dlen += 4 + 8 + blocksize - 1;\n      dlen /= blocksize;\n      dlen *= blocksize;\n      dlen += hashsize;\n      break;\n    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n      dlen += 4 + 2 * blocksize - 1;\n      dlen /= blocksize;\n      dlen *= blocksize;\n      dlen += hashsize;\n      break;\n    case SHISHI_DES_CBC_CRC:\n      dlen += 2 * blocksize - 1;\n      if (proto == 2)\n\tdlen += 4;\n      dlen += hashsize;\n      dlen /= blocksize;\n      dlen *= blocksize;\n      break;\n    default:\n      dlen += blocksize - 1;\n      if (proto == 2)\n\tdlen += 4;\n      dlen += hashsize;\n      dlen /= blocksize;\n      dlen *= blocksize;\n      break;\n    }\n\n  /* read encrypted data */\n  outbis = malloc (dlen);\n  if (outbis == NULL)\n    {\n      perror (\"readenc()\");\n      return 1;\n    }\n\n  rc = read (sock, outbis, dlen);\n  if (rc != dlen)\n    {\n      fprintf (stderr, \"Error during read socket\\n\");\n      free (outbis);\n      return 1;\n    }\n\n  if (proto == 1)\n    {\n      rc =\n\tshishi_decrypt (h, enckey, iv->keyusage, outbis, dlen, &out, &outlen);\n      if (rc != SHISHI_OK)\n\t{\n\t  fprintf (stderr, \"decryption error\\n\");\n\t  free (outbis);\n\t  return 1;\n\t}\n\n      val = 0;\n    }\n  else\n    {\n      rc = shishi_crypto_decrypt (iv->ctx, outbis, dlen, &out, &outlen);\n      if (rc != SHISHI_OK)\n\t{\n\t  fprintf (stderr, \"decryption error\\n\");\n\t  free (outbis);\n\t  return 1;\n\t}\n\n      /* in KCMDV0.2 first 4 bytes of decrypted data = len of data */\n      *len = ntohl (*((int *) out));\n      val = sizeof (int);\n    }\n\n  memset (buf, 0, SHISHI_ENCRYPT_BUFLEN);\n\n  /* copy decrypted data to output */\n  memcpy (buf, out + val, outlen - val);\n\n  free (out);\n  free (outbis);\n\n  return SHISHI_OK;\n}",
      "lines": 124,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "writeenc": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        766,
        1
      ],
      "content": "int\nwriteenc (Shishi * h, int sock, char *buf, int wlen, int *len,\n\t  shishi_ivector * iv, Shishi_key * enckey, int proto)\n{\n  char *out;\n  char *bufbis;\n\n  int rc;\n  int dlen;\n  size_t outlen;\n\n  dlen = wlen;\n  dlen = htonl (dlen);\n\n  /* data to encrypt = size + data */\n  if (proto == 2)\n    {\n      bufbis = malloc (wlen + sizeof (int));\n      if (!bufbis)\n\t{\n\t  perror (\"writeenc\");\n\t  return 1;\n\t}\n      memcpy (bufbis, (char *) &dlen, sizeof (int));\n      memcpy (bufbis + sizeof (int), buf, wlen);\n\n      /* encrypt it */\n      rc =\n\tshishi_crypto_encrypt (iv->ctx, bufbis, wlen + sizeof (int), &out,\n\t\t\t       &outlen);\n    }\n  else\n    {\n      bufbis = malloc (wlen);\n      if (!bufbis)\n\t{\n\t  perror (\"bufbis\");\n\t  return 1;\n\t}\n      memcpy (bufbis, buf, wlen);\n\n      /* data to encrypt = size + data */\n      rc =\n\tshishi_encrypt (h, enckey, iv->keyusage, bufbis, wlen, &out, &outlen);\n    }\n\n  if (rc != SHISHI_OK)\n    {\n      fprintf (stderr, \"decryption error\\n\");\n      free (bufbis);\n      return 1;\n    }\n\n  free (bufbis);\n\n  /* data to send = original size + encrypted data */\n  /* send it */\n  write (sock, &dlen, sizeof (int));\n  write (sock, out, outlen);\n\n  *len = wlen;\n\n  free (out);\n\n  return SHISHI_OK;\n\n\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/shishi_def.h": {},
  "inetutils/inetutils-1.9.4/libinetutils/tftpsubs.c": {
    "w_init": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "struct tftphdr *\nw_init (void)\n{\n  return rw_init (0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct tftphdr",
        "struct",
        "tftphdr",
        "*\nw_init (void)",
        "*"
      ]
    },
    "r_init": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "struct tftphdr *\nr_init (void)\n{\n  return rw_init (1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct tftphdr",
        "struct",
        "tftphdr",
        "*\nr_init (void)",
        "*"
      ]
    },
    "rw_init": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static struct tftphdr *\nrw_init (int x)\n{\n  newline = 0;\t\t\t/* init crlf flag */\n  prevchar = -1;\n  bfs[0].counter = BF_ALLOC;\t/* pass out the first buffer */\n  current = 0;\n  bfs[1].counter = BF_FREE;\n  nextone = x;\t\t\t/* ahead or behind? */\n  return (struct tftphdr *) bfs[0].buf;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tftphdr",
        "struct",
        "tftphdr",
        "*\nrw_init (int x)",
        "*"
      ]
    },
    "readit": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nreadit (FILE * file, struct tftphdr **dpp, int convert)\n{\n  struct bf *b;\n\n  bfs[current].counter = BF_FREE;\t/* free old one */\n  current = !current;\t\t/* \"incr\" current */\n\n  b = &bfs[current];\t\t/* look at new buffer */\n  if (b->counter == BF_FREE)\t/* if it's empty */\n    read_ahead (file, convert);\t/* fill it */\n  /*      assert(b->counter != BF_FREE); *//* check */\n  *dpp = (struct tftphdr *) b->buf;\t/* set caller's ptr */\n  return b->counter;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "read_ahead": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "void\nread_ahead (FILE * file, int convert)\n{\n  register int i;\n  register char *p;\n  register int c;\n  struct bf *b;\n  struct tftphdr *dp;\n\n  b = &bfs[nextone];\t\t/* look at \"next\" buffer */\n  if (b->counter != BF_FREE)\t/* nop if not free */\n    return;\n  nextone = !nextone;\t\t/* \"incr\" next buffer ptr */\n\n  dp = (struct tftphdr *) b->buf;\n\n  if (convert == 0)\n    {\n      b->counter = read (fileno (file), dp->th_data, SEGSIZE);\n      return;\n    }\n\n  p = dp->th_data;\n  for (i = 0; i < SEGSIZE; i++)\n    {\n      if (newline)\n\t{\n\t  if (prevchar == '\\n')\n\t    c = '\\n';\t\t/* lf to cr,lf */\n\t  else\n\t    c = '\\0';\t\t/* cr to cr,nul */\n\t  newline = 0;\n\t}\n      else\n\t{\n\t  c = getc (file);\n\t  if (c == EOF)\n\t    break;\n\t  if (c == '\\n' || c == '\\r')\n\t    {\n\t      prevchar = c;\n\t      c = '\\r';\n\t      newline = 1;\n\t    }\n\t}\n      *p++ = c;\n    }\n  b->counter = (int) (p - dp->th_data);\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "writeit": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nwriteit (FILE * file, struct tftphdr **dpp, int ct, int convert)\n{\n  bfs[current].counter = ct;\t/* set size of data to write */\n  current = !current;\t\t/* switch to other buffer */\n  if (bfs[current].counter != BF_FREE)\t/* if not free */\n    write_behind (file, convert);\t/* flush it */\n  bfs[current].counter = BF_ALLOC;\t/* mark as alloc'd */\n  *dpp = (struct tftphdr *) bfs[current].buf;\n  return ct;\t\t\t/* this is a lie of course */\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "write_behind": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "int\nwrite_behind (FILE * file, int convert)\n{\n  char *buf;\n  int count;\n  register int ct;\n  register char *p;\n  register int c;\t\t/* current character */\n  struct bf *b;\n  struct tftphdr *dp;\n\n  b = &bfs[nextone];\n  if (b->counter < -1)\t\t/* anything to flush? */\n    return 0;\t\t\t/* just nop if nothing to do */\n\n  count = b->counter;\t\t/* remember byte count */\n  b->counter = BF_FREE;\t\t/* reset flag */\n  dp = (struct tftphdr *) b->buf;\n  nextone = !nextone;\t\t/* incr for next time */\n  buf = dp->th_data;\n\n  if (count <= 0)\n    return -1;\t\t\t/* nak logic? */\n\n  if (convert == 0)\n    return write (fileno (file), buf, count);\n\n  p = buf;\n  ct = count;\n  while (ct--)\n    {\t\t\t\t/* loop over the buffer */\n      c = *p++;\t\t\t/* pick up a character */\n      if (prevchar == '\\r')\n\t{\t\t\t/* if prev char was cr */\n\t  if (c == '\\n')\t/* if have cr,lf then just */\n\t    fseeko (file, -1, 1);\t/* smash lf on top of the cr */\n\t  else if (c == '\\0')\t/* if have cr,nul then */\n\t    goto skipit;\t/* just skip over the putc */\n\t  /* else just fall through and allow it */\n\t}\n      putc (c, file);\n    skipit:\n      prevchar = c;\n    }\n  return count;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "synchnet": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "int\nsynchnet (int f)\n{\n  int i, j = 0;\n  char rbuf[PKTSIZE];\n  struct sockaddr_storage from;\n  socklen_t fromlen;\n\n  while (1)\n    {\n      ioctl (f, FIONREAD, &i);\n      if (i)\n\t{\n\t  j++;\n\t  fromlen = sizeof from;\n\t  recvfrom (f, rbuf, sizeof (rbuf), 0,\n\t\t    (struct sockaddr *) &from, &fromlen);\n\t}\n      else\n\t{\n\t  return (j);\n\t}\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/tftpsubs.h": {},
  "inetutils/inetutils-1.9.4/libinetutils/ttymsg.c": {
    "ttymsg": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "char *\nttymsg (struct iovec *iov, int iovcnt, char *line, int tmout)\n{\n  static char errbuf[MAX_ERRBUF];\n  char *device;\n  register int cnt, fd, left, wret;\n  struct iovec localiov[6];\n  int forked = 0;\n\n  if (iovcnt > (int) (sizeof (localiov) / sizeof (localiov[0])))\n    return (char *) (\"too many iov's (change code in wall/ttymsg.c)\");\n\n  device = malloc (sizeof PATH_TTY_PFX - 1 + strlen (line) + 1);\n  if (!device)\n    {\n      snprintf (errbuf, sizeof errbuf,\n\t\t\"Not enough memory for tty device name\");\n      return errbuf;\n    }\n\n  strcpy (device, PATH_TTY_PFX);\n  strcat (device, line);\n  normalize_path (device, \"/\");\n  if (strncmp (device, PATH_TTY_PFX, strlen (PATH_TTY_PFX)))\n    {\n      /* An attempt to break security... */\n      snprintf (errbuf, sizeof (errbuf), \"bad line name: %s\", line);\n      return (errbuf);\n    }\n\n  /*\n   * open will fail on slip lines or exclusive-use lines\n   * if not running as root; not an error.\n   */\n  fd = open (device, O_WRONLY | O_NONBLOCK, 0);\n  if (fd < 0)\n    {\n      if (errno == EBUSY || errno == EACCES)\n\treturn (NULL);\n      snprintf (errbuf, sizeof (errbuf), \"%s: %s\", device, strerror (errno));\n      free (device);\n      return errbuf;\n    }\n\n  for (cnt = left = 0; cnt < iovcnt; ++cnt)\n    left += iov[cnt].iov_len;\n\n  for (;;)\n    {\n      wret = writev (fd, iov, iovcnt);\n      if (wret >= left)\n\tbreak;\n      if (wret >= 0)\n\t{\n\t  left -= wret;\n\t  if (iov != localiov)\n\t    {\n\t      memcpy (localiov, iov, iovcnt * sizeof (struct iovec));\n\t      iov = localiov;\n\t    }\n\t  for (cnt = 0; wret >= (int) iov->iov_len; ++cnt)\n\t    {\n\t      wret -= iov->iov_len;\n\t      ++iov;\n\t      --iovcnt;\n\t    }\n\t  if (wret)\n\t    {\n\t      iov->iov_base = (char *) iov->iov_base + wret;\n\t      iov->iov_len -= wret;\n\t    }\n\t  continue;\n\t}\n      if (errno == EWOULDBLOCK)\n\t{\n\t  int cpid, off = 0;\n\n\t  if (forked)\n\t    {\n\t      close (fd);\n\t      _exit (EXIT_FAILURE);\n\t    }\n\t  cpid = fork2 ();\n\t  if (cpid < 0)\n\t    {\n\t      snprintf (errbuf, sizeof (errbuf),\n\t\t\t\"fork: %s\", strerror (errno));\n\t      close (fd);\n\t      free (device);\n\t      return (errbuf);\n\t    }\n\t  if (cpid)\t\t/* Parent.  */\n\t    {\n\t      close (fd);\n\t      free (device);\n\t      return (NULL);\n\t    }\n\t  forked++;\n\t  /* wait at most tmout seconds */\n\t  signal (SIGALRM, SIG_DFL);\n\t  signal (SIGTERM, SIG_DFL);\t/* XXX */\n#ifdef HAVE_SIGACTION\n\t  {\n\t    sigset_t empty;\n\t    sigemptyset (&empty);\n\t    sigprocmask (SIG_SETMASK, &empty, 0);\n\t  }\n#else\n\t  sigsetmask (0);\n#endif\n\t  alarm ((u_int) tmout);\n\t  fcntl (fd, O_NONBLOCK, &off);\n\t  continue;\n\t}\n      /*\n       * We get ENODEV on a slip line if we're running as root,\n       * and EIO if the line just went away.\n       */\n      if (errno == ENODEV || errno == EIO)\n\tbreak;\n      close (fd);\n      if (forked)\n\t_exit (EXIT_FAILURE);\n      snprintf (errbuf, sizeof (errbuf), \"%s: %s\", device, strerror (errno));\n      free (device);\n      return (errbuf);\n    }\n\n  free (device);\n  close (fd);\n  if (forked)\n    _exit (EXIT_SUCCESS);\n  return (NULL);\n}",
      "lines": 134,
      "depth": 16,
      "decorators": [
        "char",
        "*\nttymsg (struct iovec *iov, int iovcnt, char *line, int tmout)",
        "*"
      ]
    },
    "fork2": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int\nfork2 (void)\n{\n  pid_t pid;\n  int status;\n\n  if (!(pid = fork ()))\n    {\n      switch (fork ())\n\t{\n\tcase 0:\t\t/* Child.  */\n\t  return 0;\n\tcase -1:\n\t  _exit (errno);\t/* Assumes all errnos are <256 */\n\tdefault:\t\t/* Parent.  */\n\t  _exit (EXIT_SUCCESS);\n\t}\n    }\n\n  if (pid < 0 || waitpid (pid, &status, 0) < 0)\n    return -1;\n\n  if (WIFEXITED (status))\n    if (WEXITSTATUS (status) == 0)\n      return 1;\n    else\n      errno = WEXITSTATUS (status);\n  else\n    errno = EINTR;\t\t/* well, sort of :-) */\n\n  return -1;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "normalize_path": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "char *\nnormalize_path (char *path, const char *delim)\n{\n  int len;\n  char *p;\n\n  if (!path)\n    return path;\n\n  len = strlen (path);\n\n  /* Empty string is returned as is */\n  if (len == 0)\n    return path;\n\n  /* delete trailing delimiter if any */\n  if (len && path[len - 1] == delim[0])\n    path[len - 1] = 0;\n\n  /* Eliminate any /../ */\n  for (p = strchr (path, '.'); p; p = strchr (p, '.'))\n    {\n      if (p > path && p[-1] == delim[0])\n\t{\n\t  if (p[1] == '.' && (p[2] == 0 || p[2] == delim[0]))\n\t    /* found */\n\t    {\n\t      char *q, *s;\n\n\t      /* Find previous delimiter */\n\t      for (q = p - 2; *q != delim[0] && q >= path; q--)\n\t\t;\n\n\t      if (q < path)\n\t\tbreak;\n\t      /* Copy stuff */\n\t      s = p + 2;\n\t      p = q;\n\t      while ((*q++ = *s++))\n\t\t;\n\t      continue;\n\t    }\n\t}\n\n      p++;\n    }\n\n  if (path[0] == 0)\n    {\n      path[0] = delim[0];\n      path[1] = 0;\n    }\n\n  return path;\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "char",
        "*\nnormalize_path (char *path, const char *delim)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/utmp_init.c": {
    "utmp_init": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\nutmp_init (char *line, char *user, char *id, char *host)\n{\n#ifdef HAVE_UTMPX_H\n  struct utmpx utx;\n  struct timeval tv;\n#else /* !HAVE_UTMPX_H */\n  struct utmp utx;\n# if defined HAVE_STRUCT_UTMP_UT_TV\n  struct timeval tv;\n# endif\n#endif\n\n  memset ((char *) &utx, 0, sizeof (utx));\n#if defined HAVE_STRUCT_UTMP_UT_ID || defined HAVE_STRUCT_UTMPX_UT_ID\n  strncpy (utx.ut_id, id, sizeof (utx.ut_id));\n#endif\n#if defined HAVE_STRUCT_UTMP_UT_USER || defined HAVE_STRUCT_UTMPX_UT_USER\n  strncpy (utx.ut_user, user, sizeof (utx.ut_user));\n#elif defined HAVE_STRUCT_UTMP_UT_NAME || defined HAVE_STRUCT_UTMPX_UT_NAME\n  strncpy (utx.ut_name, user, sizeof (utx.ut_name));\n#endif\n#if defined HAVE_STRUCT_UTMP_UT_HOST || defined HAVE_STRUCT_UTMPX_UT_HOST\n  strncpy (utx.ut_host, host, sizeof (utx.ut_host));\n# ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN\t/* Only utmpx.  */\n  if (strlen (host) < sizeof (utx.ut_host))\n    utx.ut_syslen = strlen (host) + 1;\n  else\n    {\n      utx.ut_host[sizeof (utx.ut_host) - 1] = '\\0';\n      utx.ut_syslen = sizeof (utx.ut_host);\n    }\n# endif\n#endif /* UT_HOST */\n#if defined HAVE_STRUCT_UTMP_UT_LINE || defined HAVE_STRUCT_UTMPX_UT_LINE\n  strncpy (utx.ut_line, line, sizeof (utx.ut_line));\n#endif\n\n#if defined HAVE_STRUCT_UTMP_UT_PID || defined HAVE_STRUCT_UTMPX_UT_PID\n  utx.ut_pid = getpid ();\n#endif\n#if defined HAVE_STRUCT_UTMP_UT_TYPE || defined HAVE_STRUCT_UTMPX_UT_TYPE\n  utx.ut_type = LOGIN_PROCESS;\n#endif\n#if defined HAVE_STRUCT_UTMP_UT_TV || defined HAVE_STRUCT_UTMPX_UT_TV\n  gettimeofday (&tv, 0);\n  utx.ut_tv.tv_sec = tv.tv_sec;\n  utx.ut_tv.tv_usec = tv.tv_usec;\n#else\n  time (&(utx.ut_time));\n#endif\n\n/* Prefer utmpx over utmp, and attempt to\n * use pututxline/pututline for writing the\n * initial entry.  Then apply whatever\n * wtmp updating that happens to be available.\n *\n * That failing, fall back to loginx/login.\n * This is made in order than we are granted\n * LOGIN_PROCESS type and stay unbound by\n * any tty sensing of stdin, stdout, or stderr,\n * like GNU libc would do in login().\n */\n#ifdef HAVE_UTMPX_H\n# ifdef HAVE_PUTUTXLINE\n  setutxent ();\n  pututxline (&utx);\n  /* Some systems perform wtmp updating\n   * already in calling pututxline().\n   */\n#  ifdef HAVE_UPDWTMPX\n  updwtmpx (PATH_WTMPX, &utx);\n#  elif defined HAVE_LOGWTMPX\n  logwtmpx (line, user, id, 0, LOGIN_PROCESS);\n#  endif /* wtmp updating */\n  endutxent ();\n# elif defined HAVE_LOGINX /* !HAVE_PUTUTXLINE */\n  loginx (&utx, 0, LOGIN_PROCESS);\n# endif /* HAVE_LOGINX && !HAVE_PUTUTXLINE */\n\n#else /* !HAVE_UTMPX_H */\n# ifdef HAVE_PUTUTLINE\n  setutent ();\n  pututline (&utx);\n#  ifdef HAVE_UPDWTMP\n  updwtmp (PATH_WTMP, &utx);\n#  elif defined HAVE_LOGWTMP /* !HAVE_UPDWTMP */\n  logwtmp (line, user, id);\n#  endif /* wtmp updating */\n  endutent ();\n# elif defined HAVE_LOGIN /* !HAVE_PUTUTLINE */\n  (void) id;\t\t/* Silence warnings.  */\n  login (&utx);\n# endif /* HAVE_LOGIN && !HAVE_PUTUTLINE */\n#endif /* !HAVE_UTMPX_H */\n}",
      "lines": 96,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "utmp_ptsid": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "char *\nutmp_ptsid (char *line, char *tag)\n{\n  static char buf[5];\n\n  strncpy (buf, tag, 2);\n  strncpy (buf + 2, line + strlen (line) - 2, 2);\n  return (buf);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*\nutmp_ptsid (char *line, char *tag)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libinetutils/utmp_logout.c": {
    "utmp_logout": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void\nutmp_logout (char *line)\n{\n#ifdef HAVE_UTMPX_H\n  struct utmpx utx;\n  struct utmpx *ut;\n\n  strncpy (utx.ut_line, line, sizeof (utx.ut_line));\n\n# ifdef HAVE_PUTUTXLINE\n  setutxent();\n  ut = getutxline (&utx);\n  if (ut)\n    {\n      struct timeval tv;\n\n      ut->ut_type = DEAD_PROCESS;\n#  ifdef HAVE_STRUCT_UTMPX_UT_EXIT\n      memset (&ut->ut_exit, 0, sizeof (ut->ut_exit));\n#  endif\n      gettimeofday (&tv, 0);\n      ut->ut_tv.tv_sec = tv.tv_sec;\n      ut->ut_tv.tv_usec = tv.tv_usec;\n#  ifdef HAVE_STRUCT_UTMPX_UT_USER\n      memset (&ut->ut_user, 0, sizeof (ut->ut_user));\n#  elif defined HAVE_STRUCT_UTMPX_UT_NAME\n      memset (&ut->ut_name, 0, sizeof (ut->ut_name));\n#  endif\n#  ifdef HAVE_STRUCT_UTMPX_UT_HOST\n      memset (ut->ut_host, 0, sizeof (ut->ut_host));\n#   ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN\n      ut->ut_syslen = 1;\t/* Counting NUL.  */\n#   endif\n#  endif /* UT_HOST */\n      pututxline (ut);\n      /* Some systems perform wtmp updating\n       * already in calling pututxline().\n       */\n#  ifdef HAVE_UPDWTMPX\n      updwtmpx (PATH_WTMPX, ut);\n#  elif defined HAVE_LOGWTMPX\n      logwtmpx (ut->ut_line, \"\", \"\", 0, DEAD_PROCESS);\n#  endif\n    }\n  endutxent ();\n# elif defined HAVE_LOGOUTX /* !HAVE_PUTUTXLINE */\n  if (logoutx (line, 0, DEAD_PROCESS))\n    logwtmpx (line, \"\", \"\", 0, DEAD_PROCESS);\n# endif /* HAVE_LOGOUTX */\n\n#else /* !HAVE_UTMPX_H */\n  struct utmp utx;\n# ifdef HAVE_PUTUTLINE\n  struct utmp *ut;\n# endif\n\n  strncpy (utx.ut_line, line, sizeof (utx.ut_line));\n\n# ifdef HAVE_PUTUTLINE\n  setutent();\n  ut = getutline (&utx);\n  if (ut)\n    {\n#  ifdef HAVE_STRUCT_UTMP_UT_TV\n      struct timeval tv;\n#  endif\n\n#  ifdef HAVE_STRUCT_UTMP_UT_TYPE\n      ut->ut_type = DEAD_PROCESS;\n#  endif\n#  ifdef HAVE_STRUCT_UTMP_UT_EXIT\n      memset (&ut->ut_exit, 0, sizeof (ut->ut_exit));\n#  endif\n#  ifdef HAVE_STRUCT_UTMP_UT_TV\n      gettimeofday (&tv, 0);\n      ut->ut_tv.tv_sec = tv.tv_sec;\n      ut->ut_tv.tv_usec = tv.tv_usec;\n#  else /* !HAVE_STRUCT_UTMP_UT_TV */\n      time (&(ut->ut_time));\n#  endif\n#  ifdef HAVE_STRUCT_UTMP_UT_USER\n      memset (&ut->ut_user, 0, sizeof (ut->ut_user));\n#  elif defined HAVE_STRUCT_UTMP_UT_NAME\n      memset (&ut->ut_name, 0, sizeof (ut->ut_name));\n#  endif\n#  ifdef HAVE_STRUCT_UTMP_UT_HOST\n      memset (ut->ut_host, 0, sizeof (ut->ut_host));\n#  endif\n      pututline (ut);\n#  ifdef HAVE_UPDWTMP\n      updwtmp (WTMP_FILE, ut);\n#  elif defined HAVE_LOGWTMP /* !HAVE_UPDWTMP */\n      logwtmp (ut->ut_line, \"\", \"\");\n#  endif\n    }\n  endutent ();\n# elif defined HAVE_LOGOUT /* !HAVE_PUTUTLINE */\n  if (logout (line))\n    logwtmp (line, \"\", \"\");\n# endif /* HAVE_LOGOUT */\n#endif\n}",
      "lines": 102,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/cmp.c": {
    "namecmp": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nnamecmp (const FTSENT *a, const FTSENT *b)\n{\n  return (strcmp (a->fts_name, b->fts_name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "revnamecmp": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nrevnamecmp (const FTSENT *a, const FTSENT *b)\n{\n  return (strcmp (b->fts_name, a->fts_name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "modcmp": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nmodcmp (const FTSENT *a, const FTSENT *b)\n{\n  if (b->fts_statp->st_mtime > a->fts_statp->st_mtime\n      ||\n#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n      ( b->fts_statp->st_mtime == a->fts_statp->st_mtime\n\t&&\n\tb->fts_statp->st_mtim.tv_nsec > a->fts_statp->st_mtim.tv_nsec\n      )\n#elif defined HAVE_STRUCT_STAT_ST_MTIM_TV_USEC\n      ( b->fts_statp->st_mtime == a->fts_statp->st_mtime\n\t&&\n\tb->fts_statp->st_mtim.tv_usec > a->fts_statp->st_mtim.tv_usec\n      )\n#else\n      0\n#endif\n     )\n    return (1);\n  else if (b->fts_statp->st_mtime < a->fts_statp->st_mtime\n\t   ||\n#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t   ( b->fts_statp->st_mtime == a->fts_statp->st_mtime\n\t     &&\n\t     b->fts_statp->st_mtim.tv_nsec < a->fts_statp->st_mtim.tv_nsec\n\t   )\n#elif defined HAVE_STRUCT_STAT_ST_MTIM_TV_USEC\n\t   ( b->fts_statp->st_mtime == a->fts_statp->st_mtime\n\t     &&\n\t     b->fts_statp->st_mtim.tv_usec < a->fts_statp->st_mtim.tv_usec\n\t   )\n#else\n\t   0\n#endif\n\t  )\n    return (-1);\n  else\n    return (namecmp (a, b));\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "revmodcmp": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\nrevmodcmp (const FTSENT *a, const FTSENT *b)\n{\n  return (- modcmp (a, b));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acccmp": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int\nacccmp (const FTSENT *a, const FTSENT *b)\n{\n  if (b->fts_statp->st_atime > a->fts_statp->st_atime\n      ||\n#ifdef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n      ( b->fts_statp->st_atime == a->fts_statp->st_atime\n\t&&\n\tb->fts_statp->st_atim.tv_nsec > a->fts_statp->st_atim.tv_nsec\n      )\n#elif defined HAVE_STRUCT_STAT_ST_ATIM_TV_USEC\n      ( b->fts_statp->st_atime == a->fts_statp->st_atime\n\t&&\n\tb->fts_statp->st_atim.tv_usec > a->fts_statp->st_atim.tv_usec\n      )\n#else\n      0\n#endif\n     )\n    return (1);\n  else if (b->fts_statp->st_atime < a->fts_statp->st_atime\n\t   ||\n#ifdef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n\t   ( b->fts_statp->st_atime == a->fts_statp->st_atime\n\t     &&\n\t     b->fts_statp->st_atim.tv_nsec < a->fts_statp->st_atim.tv_nsec\n\t   )\n#elif defined HAVE_STRUCT_STAT_ST_ATIM_TV_USEC\n\t   ( b->fts_statp->st_atime == a->fts_statp->st_atime\n\t     &&\n\t     b->fts_statp->st_atim.tv_usec < a->fts_statp->st_atim.tv_usec\n\t   )\n#else\n\t   0\n#endif\n\t  )\n    return (-1);\n  else\n    return (namecmp (a, b));\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "revacccmp": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "int\nrevacccmp (const FTSENT *a, const FTSENT *b)\n{\n  return (- acccmp (a, b));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "statcmp": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nstatcmp (const FTSENT *a, const FTSENT *b)\n{\n  if (b->fts_statp->st_ctime > a->fts_statp->st_ctime\n      ||\n#ifdef HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC\n      ( b->fts_statp->st_ctime == a->fts_statp->st_ctime\n\t&&\n\tb->fts_statp->st_ctim.tv_nsec > a->fts_statp->st_ctim.tv_nsec\n      )\n#elif defined HAVE_STRUCT_STAT_ST_CTIM_TV_USEC\n      ( b->fts_statp->st_ctime == a->fts_statp->st_ctime\n\t&&\n\tb->fts_statp->st_ctim.tv_usec > a->fts_statp->st_ctim.tv_usec\n      )\n#else\n      0\n#endif\n     )\n    return (1);\n  else if (b->fts_statp->st_ctime < a->fts_statp->st_ctime\n\t   ||\n#ifdef HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC\n\t   ( b->fts_statp->st_ctime == a->fts_statp->st_ctime\n\t     &&\n\t     b->fts_statp->st_ctim.tv_nsec < a->fts_statp->st_ctim.tv_nsec\n\t   )\n#elif defined HAVE_STRUCT_STAT_ST_CTIM_TV_USEC\n\t   ( b->fts_statp->st_ctime == a->fts_statp->st_ctime\n\t     &&\n\t     b->fts_statp->st_ctim.tv_usec < a->fts_statp->st_ctim.tv_usec\n\t   )\n#else\n\t   0\n#endif\n\t  )\n    return (-1);\n  else\n    return (namecmp (a, b));\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "revstatcmp": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "int\nrevstatcmp (const FTSENT *a, const FTSENT *b)\n{\n  return (- statcmp (a, b));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sizecmp": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int\nsizecmp (const FTSENT *a, const FTSENT *b)\n{\n  if (b->fts_statp->st_size > a->fts_statp->st_size)\n    return (1);\n  if (b->fts_statp->st_size < a->fts_statp->st_size)\n    return (-1);\n  else\n    return (namecmp (a, b));\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "revsizecmp": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "int\nrevsizecmp (const FTSENT *a, const FTSENT *b)\n{\n  return (- sizecmp (a, b));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/extern.h": {},
  "inetutils/inetutils-1.9.4/libls/fts.c": {
    "fts_open": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "FTS *\nfts_open (char *const *argv, register int options, int (*compar) (const FTSENT **, const FTSENT **))\n{\n  register FTS *sp;\n  register FTSENT *p, *root;\n  register int nitems;\n  FTSENT *parent;\n  FTSENT *tmp = NULL;\n  int len;\n\n  /* Options check. */\n  if (options & ~FTS_OPTIONMASK)\n    {\n      errno = EINVAL;\n      return (NULL);\n    }\n\n  /* Allocate/initialize the stream */\n  if ((sp = malloc ((u_int) sizeof (FTS))) == NULL)\n    return (NULL);\n  memset (sp, 0, sizeof (FTS));\n  sp->fts_compar = (int (*)(const void *, const void *)) compar;\n  sp->fts_options = options;\n\n  /* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n  if (ISSET (FTS_LOGICAL))\n    SET (FTS_NOCHDIR);\n\n  /* Always set NOCHDIR for OS lacking fchdir ()  */\n#ifndef HAVE_FCHDIR\n  SET (FTS_NOCHDIR);\n#endif\n  /*\n   * Start out with 1K of path space, and enough, in any case,\n   * to hold the user's paths.\n   */\n#ifndef MAXPATHLEN\n# define MAXPATHLEN 1024\n#endif\n  if (fts_palloc (sp, MAX (fts_maxarglen (argv), MAXPATHLEN)))\n    goto mem1;\n\n  /* Allocate/initialize root's parent. */\n  if ((parent = fts_alloc (sp, \"\", 0)) == NULL)\n    goto mem2;\n  parent->fts_level = FTS_ROOTPARENTLEVEL;\n\n  /* Allocate/initialize root(s). */\n  for (root = NULL, nitems = 0; *argv; ++argv, ++nitems)\n    {\n      /* Don't allow zero-length paths. */\n      if ((len = strlen (*argv)) == 0)\n\t{\n\t  errno = ENOENT;\n\t  goto mem3;\n\t}\n\n      p = fts_alloc (sp, *argv, len);\n      p->fts_level = FTS_ROOTLEVEL;\n      p->fts_parent = parent;\n      p->fts_accpath = p->fts_name;\n      p->fts_info = fts_stat (sp, NULL, p, ISSET (FTS_COMFOLLOW));\n\n      /* Command-line \".\" and \"..\" are real directories. */\n      if (p->fts_info == FTS_DOT)\n\tp->fts_info = FTS_D;\n\n      /*\n       * If comparison routine supplied, traverse in sorted\n       * order; otherwise traverse in the order specified.\n       */\n      if (compar)\n\t{\n\t  p->fts_link = root;\n\t  root = p;\n\t}\n      else\n\t{\n\t  p->fts_link = NULL;\n\t  if (root == NULL)\n\t    tmp = root = p;\n\t  else\n\t    {\n\t      tmp->fts_link = p;\n\t      tmp = p;\n\t    }\n\t}\n    }\n  if (compar && nitems > 1)\n    root = fts_sort (sp, root, nitems);\n\n  /*\n   * Allocate a dummy pointer and make fts_read think that we've just\n   * finished the node before the root(s); set p->fts_info to FTS_INIT\n   * so that everything about the \"current\" node is ignored.\n   */\n  if ((sp->fts_cur = fts_alloc (sp, \"\", 0)) == NULL)\n    goto mem3;\n  sp->fts_cur->fts_link = root;\n  sp->fts_cur->fts_info = FTS_INIT;\n\n  /*\n   * If using chdir(2), grab a file descriptor pointing to dot to insure\n   * that we can get back here; this could be avoided for some paths,\n   * but almost certainly not worth the effort.  Slashes, symbolic links,\n   * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n   * descriptor we run anyway, just more slowly.\n   */\n  if (!ISSET (FTS_NOCHDIR) && (sp->fts_rfd = open (\".\", O_RDONLY, 0)) < 0)\n    SET (FTS_NOCHDIR);\n\n  return (sp);\n\nmem3:fts_lfree (root);\n  free (parent);\nmem2:free (sp->fts_path);\nmem1:free (sp);\n  return (NULL);\n}",
      "lines": 119,
      "depth": 13,
      "decorators": [
        "FTS",
        "*\nfts_open (char *const *argv, register int options, int (*compar) (const FTSENT **, const FTSENT **))",
        "*"
      ]
    },
    "fts_load": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static void\nfts_load (FTS *sp, register FTSENT *p)\n{\n  register int len;\n  register char *cp;\n\n  /*\n   * Load the stream structure for the next traversal.  Since we don't\n   * actually enter the directory until after the preorder visit, set\n   * the fts_accpath field specially so the chdir gets done to the right\n   * place and the user can access the first node.  From fts_open it's\n   * known that the path will fit.\n   */\n  len = p->fts_pathlen = p->fts_namelen;\n  memmove (sp->fts_path, p->fts_name, len + 1);\n  if ((cp = strrchr (p->fts_name, '/')) && (cp != p->fts_name || cp[1]))\n    {\n      len = strlen (++cp);\n      memmove (p->fts_name, cp, len + 1);\n      p->fts_namelen = len;\n    }\n  p->fts_accpath = p->fts_path = sp->fts_path;\n  sp->fts_dev = p->fts_dev;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_close": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "int\nfts_close (FTS *sp)\n{\n  register FTSENT *freep, *p;\n  int saved_errno = 0;\n  int retval = 0;\n\n  /*\n   * This still works if we haven't read anything -- the dummy structure\n   * points to the root list, so we step through to the end of the root\n   * list which has a valid parent pointer.\n   */\n  if (sp->fts_cur)\n    {\n      for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;)\n\t{\n\t  freep = p;\n\t  p = p->fts_link ? p->fts_link : p->fts_parent;\n\t  free (freep);\n\t}\n      free (p);\n    }\n\n  /* Free up child linked list, sort array, path buffer. */\n  if (sp->fts_child)\n    fts_lfree (sp->fts_child);\n  free (sp->fts_array);\n  free (sp->fts_path);\n\n  /* Return to original directory, save errno if necessary. */\n  if (!ISSET (FTS_NOCHDIR))\n    {\n      saved_errno = fchdir (sp->fts_rfd) ? errno : 0;\n      close (sp->fts_rfd);\n    }\n\n  /* Set errno and return. */\n  if (!ISSET (FTS_NOCHDIR) && saved_errno)\n    {\n      errno = saved_errno;\n      retval = -1;\n    }\n\n  /* Free up the stream pointer. */\n  free (sp);\n\n  return retval;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "fts_read": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "FTSENT *\nfts_read (register FTS *sp)\n{\n  register FTSENT *p;\n  register FTSENT *tmp;\n  register int instr;\n  register char *t;\n  int saved_errno;\n\n  /* If finished or unrecoverable error, return NULL. */\n  if (sp->fts_cur == NULL || ISSET (FTS_STOP))\n    return (NULL);\n\n  /* Set current node pointer. */\n  p = sp->fts_cur;\n\n  /* Save and zero out user instructions. */\n  instr = p->fts_instr;\n  p->fts_instr = FTS_NOINSTR;\n\n  /* Any type of file may be re-visited; re-stat and re-turn. */\n  if (instr == FTS_AGAIN)\n    {\n      p->fts_info = fts_stat (sp, NULL, p, 0);\n      return (p);\n    }\n\n  /*\n   * Following a symlink -- SLNONE test allows application to see\n   * SLNONE and recover.  If indirecting through a symlink, have\n   * keep a pointer to current location.  If unable to get that\n   * pointer, follow fails.\n   */\n  if (instr == FTS_FOLLOW &&\n      (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE))\n    {\n      p->fts_info = fts_stat (sp, NULL, p, 1);\n      if (p->fts_info == FTS_D && !ISSET (FTS_NOCHDIR))\n\t{\n\t  if ((p->fts_symfd = open (\".\", O_RDONLY, 0)) < 0)\n\t    {\n\t      p->fts_errno = errno;\n\t      p->fts_info = FTS_ERR;\n\t    }\n\t  else\n\t    p->fts_flags |= FTS_SYMFOLLOW;\n\t}\n      return (p);\n    }\n\n  /* Directory in pre-order. */\n  if (p->fts_info == FTS_D)\n    {\n      /* If skipped or crossed mount point, do post-order visit. */\n      if (instr == FTS_SKIP ||\n\t  (ISSET (FTS_XDEV) && p->fts_dev != sp->fts_dev))\n\t{\n\t  if (p->fts_flags & FTS_SYMFOLLOW)\n\t    close (p->fts_symfd);\n\t  if (sp->fts_child)\n\t    {\n\t      fts_lfree (sp->fts_child);\n\t      sp->fts_child = NULL;\n\t    }\n\t  p->fts_info = FTS_DP;\n\t  return (p);\n\t}\n\n      /* Rebuild if only read the names and now traversing. */\n      if (sp->fts_child && sp->fts_options & FTS_NAMEONLY)\n\t{\n\t  sp->fts_options &= ~FTS_NAMEONLY;\n\t  fts_lfree (sp->fts_child);\n\t  sp->fts_child = NULL;\n\t}\n\n      /*\n       * Cd to the subdirectory.\n       *\n       * If have already read and now fail to chdir, whack the list\n       * to make the names come out right, and set the parent errno\n       * so the application will eventually get an error condition.\n       * Set the FTS_DONTCHDIR flag so that when we logically change\n       * directories back to the parent we don't do a chdir.\n       *\n       * If haven't read do so.  If the read fails, fts_build sets\n       * FTS_STOP or the fts_info field of the node.\n       */\n      if (sp->fts_child)\n\t{\n\t  if (CHDIR (sp, p->fts_accpath))\n\t    {\n\t      p->fts_errno = errno;\n\t      p->fts_flags |= FTS_DONTCHDIR;\n\t      for (p = sp->fts_child; p; p = p->fts_link)\n\t\tp->fts_accpath = p->fts_parent->fts_accpath;\n\t    }\n\t}\n      else if ((sp->fts_child = fts_build (sp, BREAD)) == NULL)\n\t{\n\t  if (ISSET (FTS_STOP))\n\t    return (NULL);\n\t  return (p);\n\t}\n      p = sp->fts_child;\n      sp->fts_child = NULL;\n      goto name;\n    }\n\n  /* Move to the next node on this level. */\nnext:tmp = p;\n  if ((p = p->fts_link))\n    {\n      free (tmp);\n\n      /*\n       * If reached the top, return to the original directory, and\n       * load the paths for the next root.\n       */\n      if (p->fts_level == FTS_ROOTLEVEL)\n\t{\n\t  if (!ISSET (FTS_NOCHDIR) && FCHDIR (sp, sp->fts_rfd))\n\t    {\n\t      SET (FTS_STOP);\n\t      return (NULL);\n\t    }\n\t  fts_load (sp, p);\n\t  return (sp->fts_cur = p);\n\t}\n\n      /*\n       * User may have called fts_set on the node.  If skipped,\n       * ignore.  If followed, get a file descriptor so we can\n       * get back if necessary.\n       */\n      if (p->fts_instr == FTS_SKIP)\n\tgoto next;\n      if (p->fts_instr == FTS_FOLLOW)\n\t{\n\t  p->fts_info = fts_stat (sp, NULL, p, 1);\n\t  if (p->fts_info == FTS_D && !ISSET (FTS_NOCHDIR))\n\t    {\n\t      if ((p->fts_symfd = open (\".\", O_RDONLY, 0)) < 0)\n\t\t{\n\t\t  p->fts_errno = errno;\n\t\t  p->fts_info = FTS_ERR;\n\t\t}\n\t      else\n\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t    }\n\t  p->fts_instr = FTS_NOINSTR;\n\t}\n\n    name:t = sp->fts_path + NAPPEND (p->fts_parent);\n      *t++ = '/';\n      memmove (t, p->fts_name, p->fts_namelen + 1);\n      return (sp->fts_cur = p);\n    }\n\n  /* Move up to the parent node. */\n  p = tmp->fts_parent;\n  free (tmp);\n\n  if (p->fts_level == FTS_ROOTPARENTLEVEL)\n    {\n      /*\n       * Done; free everything up and set errno to 0 so the user\n       * can distinguish between error and EOF.\n       */\n      free (p);\n      errno = 0;\n      return (sp->fts_cur = NULL);\n    }\n\n  /* Nul terminate the pathname. */\n  sp->fts_path[p->fts_pathlen] = '\\0';\n\n  /*\n   * Return to the parent directory.  If at a root node or came through\n   * a symlink, go back through the file descriptor.  Otherwise, cd up\n   * one directory.\n   */\n  if (p->fts_level == FTS_ROOTLEVEL)\n    {\n      if (!ISSET (FTS_NOCHDIR) && FCHDIR (sp, sp->fts_rfd))\n\t{\n\t  SET (FTS_STOP);\n\t  return (NULL);\n\t}\n    }\n  else if (p->fts_flags & FTS_SYMFOLLOW)\n    {\n      if (FCHDIR (sp, p->fts_symfd))\n\t{\n\t  saved_errno = errno;\n\t  close (p->fts_symfd);\n\t  errno = saved_errno;\n\t  SET (FTS_STOP);\n\t  return (NULL);\n\t}\n      close (p->fts_symfd);\n    }\n  else if (!(p->fts_flags & FTS_DONTCHDIR))\n    {\n      if (CHDIR (sp, \"..\"))\n\t{\n\t  SET (FTS_STOP);\n\t  return (NULL);\n\t}\n    }\n  p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n  return (sp->fts_cur = p);\n}",
      "lines": 213,
      "depth": 17,
      "decorators": [
        "FTSENT",
        "*\nfts_read (register FTS *sp)",
        "*"
      ]
    },
    "fts_set": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "int\nfts_set (FTS *sp _GL_UNUSED_PARAMETER, FTSENT *p, int instr)\n{\n  if (instr && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n      instr != FTS_NOINSTR && instr != FTS_SKIP)\n    {\n      errno = EINVAL;\n      return (1);\n    }\n  p->fts_instr = instr;\n  return (0);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "fts_children": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "FTSENT *\nfts_children (register FTS *sp, int instr)\n{\n  register FTSENT *p;\n  int fd;\n\n  if (instr && instr != FTS_NAMEONLY)\n    {\n      errno = EINVAL;\n      return (NULL);\n    }\n\n  /* Set current node pointer. */\n  p = sp->fts_cur;\n\n  /*\n   * Errno set to 0 so user can distinguish empty directory from\n   * an error.\n   */\n  errno = 0;\n\n  /* Fatal errors stop here. */\n  if (ISSET (FTS_STOP))\n    return (NULL);\n\n  /* Return logical hierarchy of user's arguments. */\n  if (p->fts_info == FTS_INIT)\n    return (p->fts_link);\n\n  /*\n   * If not a directory being visited in pre-order, stop here.  Could\n   * allow FTS_DNR, assuming the user has fixed the problem, but the\n   * same effect is available with FTS_AGAIN.\n   */\n  if (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */ )\n    return (NULL);\n\n  /* Free up any previous child list. */\n  if (sp->fts_child)\n    fts_lfree (sp->fts_child);\n\n  if (instr == FTS_NAMEONLY)\n    {\n      sp->fts_options |= FTS_NAMEONLY;\n      instr = BNAMES;\n    }\n  else\n    instr = BCHILD;\n\n  /*\n   * If using chdir on a relative path and called BEFORE fts_read does\n   * its chdir to the root of a traversal, we can lose -- we need to\n   * chdir into the subdirectory, and we don't know where the current\n   * directory is, so we can't get back so that the upcoming chdir by\n   * fts_read will work.\n   */\n  if (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n      ISSET (FTS_NOCHDIR))\n    return (sp->fts_child = fts_build (sp, instr));\n\n  if ((fd = open (\".\", O_RDONLY, 0)) < 0)\n    return (NULL);\n  sp->fts_child = fts_build (sp, instr);\n  if (fchdir (fd))\n    return (NULL);\n  close (fd);\n  return (sp->fts_child);\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "FTSENT",
        "*\nfts_children (register FTS *sp, int instr)",
        "*"
      ]
    },
    "fts_build": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "static FTSENT *\nfts_build (register FTS *sp, int type)\n{\n  struct dirent *dp;\n  register FTSENT *p, *head;\n  register int nitems;\n  FTSENT *cur, *tail;\n  DIR *dirp;\n  void *adjaddr;\n  int cderrno, descend, len, level, maxlen, nlinks, saved_errno;\n  char *cp = NULL;\n#ifdef HAVE___OPENDIR2\n  int oflag;\n#endif\n\n  /* Set current node pointer. */\n  cur = sp->fts_cur;\n\n  /*\n   * Open the directory for reading.  If this fails, we're done.\n   * If being called from fts_read, set the fts_info field.\n   */\n#if defined HAVE___OPENDIR2\n  oflag = DTF_NODUP;\n\n# ifdef DTF_REWIND\n  oflag |= DTF_REWIND;\n# endif\n\n# ifdef DTF_HIDEW\n  if (!ISSET (FTS_WHITEOUT))\n    oflag |= DTF_HIDEW;\n# endif /* DTF_HIDEW */\n\n  dirp = __opendir2 (cur->fts_accpath, oflag);\n#else /* !HAVE___OPENDIR2 */\n  dirp = opendir (cur->fts_accpath);\n#endif /* !HAVE___OPENDIR2 */\n\n  if (dirp == NULL)\n    {\n      if (type == BREAD)\n\t{\n\t  cur->fts_info = FTS_DNR;\n\t  cur->fts_errno = errno;\n\t}\n      return (NULL);\n    }\n\n  /*\n   * Nlinks is the number of possible entries of type directory in the\n   * directory if we're cheating on stat calls, 0 if we're not doing\n   * any stat calls at all, -1 if we're doing stats on everything.\n   */\n  if (type == BNAMES)\n    nlinks = 0;\n  else if (ISSET (FTS_NOSTAT) && ISSET (FTS_PHYSICAL))\n    nlinks = cur->fts_nlink - (ISSET (FTS_SEEDOT) ? 0 : 2);\n  else\n    nlinks = -1;\n\n  /*\n   * If we're going to need to stat anything or we want to descend\n   * and stay in the directory, chdir.  If this fails we keep going,\n   * but set a flag so we don't chdir after the post-order visit.\n   * We won't be able to stat anything, but we can still return the\n   * names themselves.  Note, that since fts_read won't be able to\n   * chdir into the directory, it will have to return different path\n   * names than before, i.e. \"a/b\" instead of \"b\".  Since the node\n   * has already been visited in pre-order, have to wait until the\n   * post-order visit to return the error.  There is a special case\n   * here, if there was nothing to stat then it's not an error to\n   * not be able to stat.  This is all fairly nasty.  If a program\n   * needed sorted entries or stat information, they had better be\n   * checking FTS_NS on the returned nodes.\n   */\n  cderrno = 0;\n  if (nlinks || type == BREAD)\n    {\n      if (FCHDIR (sp, dirfd (dirp)))\n\t{\n\t  if (nlinks && type == BREAD)\n\t    cur->fts_errno = errno;\n\t  cur->fts_flags |= FTS_DONTCHDIR;\n\t  descend = 0;\n\t  cderrno = errno;\n\t}\n      else\n\tdescend = 1;\n    }\n  else\n    descend = 0;\n\n  /*\n   * Figure out the max file name length that can be stored in the\n   * current path -- the inner loop allocates more path as necessary.\n   * We really wouldn't have to do the maxlen calculations here, we\n   * could do them in fts_read before returning the path, but it's a\n   * lot easier here since the length is part of the dirent structure.\n   *\n   * If not changing directories set a pointer so that can just append\n   * each new name into the path.\n   */\n  maxlen = sp->fts_pathlen - cur->fts_pathlen - 1;\n  len = NAPPEND (cur);\n  if (ISSET (FTS_NOCHDIR))\n    {\n      cp = sp->fts_path + len;\n      *cp++ = '/';\n    }\n\n  level = cur->fts_level + 1;\n\n  /* Read the directory, attaching each entry to the `link' pointer. */\n  adjaddr = NULL;\n  head = tail = NULL;\n  nitems = 0;\n  while ((dp = readdir (dirp)))\n    {\n      int namlen;\n\n      if (!ISSET (FTS_SEEDOT) && ISDOT (dp->d_name))\n\tcontinue;\n\n      namlen = strlen (dp->d_name) + 1;\n      if ((p = fts_alloc (sp, dp->d_name, namlen)) == NULL)\n\tgoto mem1;\n      if (namlen > maxlen)\n\t{\n\t  if (fts_palloc (sp, (size_t) namlen))\n\t    {\n\t      /*\n\t       * No more memory for path or structures.  Save\n\t       * errno, free up the current structure and the\n\t       * structures already allocated.\n\t       */\n\t    mem1:saved_errno = errno;\n\t      free (p);\n\t      fts_lfree (head);\n\t      closedir (dirp);\n\t      errno = saved_errno;\n\t      cur->fts_info = FTS_ERR;\n\t      SET (FTS_STOP);\n\t      return (NULL);\n\t    }\n\t  adjaddr = sp->fts_path;\n\t  maxlen = sp->fts_pathlen - sp->fts_cur->fts_pathlen - 1;\n\t}\n\n      p->fts_pathlen = len + namlen + 1;\n      p->fts_parent = sp->fts_cur;\n      p->fts_level = level;\n\n      if (cderrno)\n\t{\n\t  if (nlinks)\n\t    {\n\t      p->fts_info = FTS_NS;\n\t      p->fts_errno = cderrno;\n\t    }\n\t  else\n\t    p->fts_info = FTS_NSOK;\n\t  p->fts_accpath = cur->fts_accpath;\n\t}\n      else if (nlinks == 0\n#if defined DT_DIR && defined _DIRENT_HAVE_D_TYPE\n\t       || (nlinks > 0 &&\n\t\t   dp->d_type != DT_DIR && dp->d_type != DT_UNKNOWN)\n#endif\n\t)\n\t{\n\t  p->fts_accpath = ISSET (FTS_NOCHDIR) ? p->fts_path : p->fts_name;\n\t  p->fts_info = FTS_NSOK;\n\t}\n      else\n\t{\n\t  /* Build a file name for fts_stat to stat. */\n\t  if (ISSET (FTS_NOCHDIR))\n\t    {\n\t      p->fts_accpath = p->fts_path;\n\t      memmove (p->fts_name, cp, p->fts_namelen + 1);\n\t    }\n\t  else\n\t    p->fts_accpath = p->fts_name;\n\t  /* Stat it. */\n\t  p->fts_info = fts_stat (sp, dp, p, 0);\n\n\t  /* Decrement link count if applicable. */\n\t  if (nlinks > 0 && (p->fts_info == FTS_D ||\n\t\t\t     p->fts_info == FTS_DC || p->fts_info == FTS_DOT))\n\t    --nlinks;\n\t}\n\n      /* We walk in directory order so \"ls -f\" doesn't get upset. */\n      p->fts_link = NULL;\n      if (head == NULL)\n\thead = tail = p;\n      else\n\t{\n\t  tail->fts_link = p;\n\t  tail = p;\n\t}\n      ++nitems;\n    }\n  closedir (dirp);\n\n  /*\n   * If had to realloc the path, adjust the addresses for the rest\n   * of the tree.\n   */\n  if (adjaddr)\n    fts_padjust (sp, adjaddr);\n\n  /*\n   * If not changing directories, reset the path back to original\n   * state.\n   */\n  if (ISSET (FTS_NOCHDIR))\n    {\n      if (cp - 1 > sp->fts_path)\n\t--cp;\n      *cp = '\\0';\n    }\n\n  /*\n   * If descended after called from fts_children or after called from\n   * fts_read and nothing found, get back.  At the root level we use\n   * the saved fd; if one of fts_open()'s arguments is a relative path\n   * to an empty directory, we wind up here with no other way back.  If\n   * can't get back, we're done.\n   */\n  if (descend && (type == BCHILD || !nitems) &&\n      (cur->fts_level == FTS_ROOTLEVEL ?\n       FCHDIR (sp, sp->fts_rfd) : CHDIR (sp, \"..\")))\n    {\n      cur->fts_info = FTS_ERR;\n      SET (FTS_STOP);\n      return (NULL);\n    }\n\n  /* If didn't find anything, return NULL. */\n  if (!nitems)\n    {\n      if (type == BREAD)\n\tcur->fts_info = FTS_DP;\n      return (NULL);\n    }\n\n  /* Sort the entries. */\n  if (sp->fts_compar && nitems > 1)\n    head = fts_sort (sp, head, nitems);\n  return (head);\n}",
      "lines": 253,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_build (register FTS *sp, int type)",
        "*"
      ]
    },
    "fts_stat": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "static unsigned short\nfts_stat (FTS *sp, struct dirent *dp, register FTSENT *p, int follow)\n{\n  register FTSENT *t;\n  register dev_t dev;\n  register ino_t ino;\n  struct stat *sbp, sb;\n  int saved_errno;\n\n  /* If user needs stat info, stat buffer already allocated. */\n  sbp = ISSET (FTS_NOSTAT) ? &sb : p->fts_statp;\n\n#if defined DT_WHT && defined S_IFWHT\n  /*\n   * Whited-out files don't really exist.  However, there's stat(2) file\n   * mask for them, so we set it so that programs (i.e., find) don't have\n   * to test FTS_W separately from other file types.\n   */\n  if (dp != NULL && dp->d_type == DT_WHT)\n    {\n      memset (sbp, 0, sizeof (struct stat));\n      sbp->st_mode = S_IFWHT;\n      return (FTS_W);\n    }\n#endif\n\n  /*\n   * If doing a logical walk, or application requested FTS_FOLLOW, do\n   * a stat(2).  If that fails, check for a non-existent symlink.  If\n   * fail, set the errno from the stat call.\n   */\n  if (ISSET (FTS_LOGICAL) || follow)\n    {\n      if (stat (p->fts_accpath, sbp))\n\t{\n\t  saved_errno = errno;\n\t  if (!lstat (p->fts_accpath, sbp))\n\t    {\n\t      errno = 0;\n\t      return (FTS_SLNONE);\n\t    }\n\t  p->fts_errno = saved_errno;\n\t  goto err;\n\t}\n    }\n  else if (lstat (p->fts_accpath, sbp))\n    {\n      p->fts_errno = errno;\n    err:memset (sbp, 0, sizeof (struct stat));\n      return (FTS_NS);\n    }\n\n  if (S_ISDIR (sbp->st_mode))\n    {\n      /*\n       * Set the device/inode.  Used to find cycles and check for\n       * crossing mount points.  Also remember the link count, used\n       * in fts_build to limit the number of stat calls.  It is\n       * understood that these fields are only referenced if fts_info\n       * is set to FTS_D.\n       */\n      dev = p->fts_dev = sbp->st_dev;\n      ino = p->fts_ino = sbp->st_ino;\n      p->fts_nlink = sbp->st_nlink;\n\n      if (ISDOT (p->fts_name))\n\treturn (FTS_DOT);\n\n      /*\n       * Cycle detection is done by brute force when the directory\n       * is first encountered.  If the tree gets deep enough or the\n       * number of symbolic links to directories is high enough,\n       * something faster might be worthwhile.\n       */\n      for (t = p->fts_parent;\n\t   t->fts_level >= FTS_ROOTLEVEL; t = t->fts_parent)\n\tif (ino == t->fts_ino && dev == t->fts_dev)\n\t  {\n\t    p->fts_cycle = t;\n\t    return (FTS_DC);\n\t  }\n      return (FTS_D);\n    }\n  if (S_ISLNK (sbp->st_mode))\n    return (FTS_SL);\n  if (S_ISREG (sbp->st_mode))\n    return (FTS_F);\n  return (FTS_DEFAULT);\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned short",
        "unsigned",
        "short"
      ]
    },
    "fts_sort": {
      "start_point": [
        967,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "static FTSENT *\nfts_sort (FTS *sp, FTSENT *head, register int nitems)\n{\n  register FTSENT **ap, *p;\n\n  /*\n   * Construct an array of pointers to the structures and call qsort(3).\n   * Reassemble the array in the order returned by qsort.  If unable to\n   * sort for memory reasons, return the directory entries in their\n   * current order.  Allocate enough space for the current needs plus\n   * 40 so don't realloc one entry at a time.\n   */\n  if (nitems > sp->fts_nitems)\n    {\n      sp->fts_nitems = nitems + 40;\n      if ((sp->fts_array = realloc (sp->fts_array,\n\t\t\t\t    (size_t) (sp->fts_nitems *\n\t\t\t\t\t      sizeof (FTSENT *)))) == NULL)\n\t{\n\t  sp->fts_nitems = 0;\n\t  return (head);\n\t}\n    }\n  for (ap = sp->fts_array, p = head; p; p = p->fts_link)\n    *ap++ = p;\n  qsort ((void *) sp->fts_array, nitems, sizeof (FTSENT *), sp->fts_compar);\n  for (head = *(ap = sp->fts_array); --nitems; ++ap)\n    ap[0]->fts_link = ap[1];\n  ap[0]->fts_link = NULL;\n  return (head);\n}",
      "lines": 31,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_sort (FTS *sp, FTSENT *head, register int nitems)",
        "*"
      ]
    },
    "fts_alloc": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1032,
        1
      ],
      "content": "static FTSENT *\nfts_alloc (FTS *sp, const char *name, register int namelen)\n{\n  register FTSENT *p;\n  size_t len;\n\n  /*\n   * The file name is a variable length array and no stat structure is\n   * necessary if the user has set the nostat bit.  Allocate the FTSENT\n   * structure, the file name and the stat structure in one chunk, but\n   * be careful that the stat structure is reasonably aligned.  Since the\n   * fts_name field is declared to be of size 1, the fts_name pointer is\n   * namelen + 2 before the first possible address of the stat structure.\n   */\n  len = sizeof (FTSENT) + namelen;\n  if (!ISSET (FTS_NOSTAT))\n    len += sizeof (struct stat) + ALIGNBYTES;\n  if ((p = malloc (len)) == NULL)\n    return (NULL);\n\n  /* Copy the name plus the trailing NULL. */\n  memmove (p->fts_name, name, namelen + 1);\n\n  if (!ISSET (FTS_NOSTAT))\n    p->fts_statp = (struct stat *) ALIGN (p->fts_name + namelen + 2);\n  p->fts_namelen = namelen;\n  p->fts_path = sp->fts_path;\n  p->fts_errno = 0;\n  p->fts_flags = 0;\n  p->fts_instr = FTS_NOINSTR;\n  p->fts_number = 0;\n  p->fts_pointer = NULL;\n  return (p);\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "FTSENT",
        "*\nfts_alloc (FTS *sp, const char *name, register int namelen)",
        "*"
      ]
    },
    "fts_lfree": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1045,
        1
      ],
      "content": "static void\nfts_lfree (register FTSENT *head)\n{\n  register FTSENT *p;\n\n  /* Free a linked list of structures. */\n  while ((p = head))\n    {\n      head = head->fts_link;\n      free (p);\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_palloc": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "static int\nfts_palloc (FTS *sp, size_t more)\n{\n  sp->fts_pathlen += more + 256;\n  sp->fts_path = realloc (sp->fts_path, (size_t) sp->fts_pathlen);\n  return (sp->fts_path == NULL);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fts_padjust": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1085,
        1
      ],
      "content": "static void\nfts_padjust (FTS *sp, void *addr)\n{\n  FTSENT *p;\n\n#define ADJUST(p) {\t\t\t\t\t\t\t\\\n\t(p)->fts_accpath =\t\t\t\t\t\t\\\n\t    (char *)addr + ((p)->fts_accpath - (p)->fts_path);\t\t\\\n\t(p)->fts_path = addr;\t\t\t\t\t\t\\\n}\n  /* Adjust the current set of children. */\n  for (p = sp->fts_child; p; p = p->fts_link)\n    ADJUST (p);\n\n  /* Adjust the rest of the tree. */\n  for (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;)\n    {\n      ADJUST (p);\n      p = p->fts_link ? p->fts_link : p->fts_parent;\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fts_maxarglen": {
      "start_point": [
        1087,
        0
      ],
      "end_point": [
        1096,
        1
      ],
      "content": "static size_t\nfts_maxarglen (char *const *argv)\n{\n  size_t len, max;\n\n  for (max = 0; *argv; ++argv)\n    if ((len = strlen (*argv)) > max)\n      max = len;\n  return (max);\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/fts.h": {},
  "inetutils/inetutils-1.9.4/libls/ls.c": {
    "ls_main": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nls_main (int argc, char **argv)\n{\n  static char dot[] = \".\", *dotav[] = { dot, NULL };\n  struct winsize win;\n  int ch, fts_options;\n  int kflag = 0;\n  char *p;\n\n  /*\n   * Clear all settings made in any previous call.\n   */\n  output = 0;\n\n  f_accesstime = f_column = f_columnacross = f_flags = f_inode = 0;\n  f_listdir = f_listdot = f_longform = f_newline = 0;\n  f_nonprint = f_nosort = f_numericonly = 0;\n  f_recursive = f_reversesort = f_sectime = f_singlecol = 0;\n  f_size = f_statustime = f_stream = f_dirname = 0;\n  f_type = f_typedir = f_whiteout = 0;\n\n  /* Terminal defaults to -Cq, non-terminal defaults to -1. */\n  if (isatty (STDOUT_FILENO))\n    {\n      p = getenv (\"COLUMNS\");\n      if (p != NULL)\n\ttermwidth = atoi (p);\n      else if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &win) == 0 && win.ws_col > 0)\n\ttermwidth = win.ws_col;\n      f_column = f_nonprint = 1;\n    }\n  else\n    f_singlecol = 1;\n\n  /* Root is -A automatically. */\n  if (!getuid ())\n    f_listdot = 1;\n\n  optind = 1;\t/* Reset for reentrant scanning.  */\n\n  fts_options = FTS_PHYSICAL;\n  while ((ch = getopt (argc, argv, \"1ACFLRSTWacdfgiklmnopqrstux\")) != -1)\n    {\n      switch (ch)\n\t{\n\t  /*\n\t   * The options -1, -C, -l, -m, -n and -x all overrule each\n\t   * other so shell aliasing works right.\n\t   */\n\tcase '1':\n\t  f_singlecol = 1;\n\t  f_column = f_columnacross = f_longform = f_stream = 0;\n\t  break;\n\tcase 'C':\n\t  f_column = 1;\n\t  f_longform = f_columnacross = f_singlecol = f_stream = 0;\n\t  break;\n\tcase 'l':\n\t  f_longform = 1;\n\t  f_numericonly = 0;\n\t  f_column = f_columnacross = f_singlecol = f_stream = 0;\n\t  break;\n\tcase 'm':\n\t  f_stream = 1;\n\t  f_column = f_columnacross = f_longform = f_singlecol = 0;\n\t  break;\n\tcase 'x':\n\t  f_columnacross = 1;\n\t  f_column = f_longform = f_singlecol = f_stream = 0;\n\t  break;\n\tcase 'n':\n\t  f_longform = 1;\n\t  f_numericonly = 1;\n\t  f_column = f_columnacross = f_singlecol = f_stream = 0;\n\t  break;\n\t  /* The -c and -u options override each other. */\n\tcase 'c':\n\t  f_statustime = 1;\n\t  f_accesstime = 0;\n\t  break;\n\tcase 'u':\n\t  f_accesstime = 1;\n\t  f_statustime = 0;\n\t  break;\n\tcase 'F':\n\t  f_type = 1;\n\t  break;\n\tcase 'L':\n\t  fts_options &= ~FTS_PHYSICAL;\n\t  fts_options |= FTS_LOGICAL;\n\t  break;\n\tcase 'R':\n\t  f_recursive = 1;\n\t  break;\n\tcase 'a':\n\t  fts_options |= FTS_SEEDOT;\n\tcase 'A':\n\t  f_listdot = 1;\n\t  break;\n\t  /* The -d option turns off the -R option. */\n\tcase 'd':\n\t  f_listdir = 1;\n\t  f_recursive = 0;\n\t  break;\n\tcase 'f':\n\t  f_nosort = 1;\n\t  break;\n\tcase 'g':\t\t/* Compatibility with 4.3BSD. */\n\t  break;\n\tcase 'i':\n\t  f_inode = 1;\n\t  break;\n\tcase 'k':\n\t  blocksize = 1024;\n\t  kflag = 1;\n\t  break;\n\tcase 'o':\n\t  f_flags = 1;\n\t  break;\n\tcase 'p':\n\t  f_typedir = 1;\n\t  break;\n\tcase 'q':\n\t  f_nonprint = 1;\n\t  break;\n\tcase 'r':\n\t  f_reversesort = 1;\n\t  break;\n\tcase 'S':\n\t  sortkey = BY_SIZE;\n\t  break;\n\tcase 's':\n\t  f_size = 1;\n\t  break;\n\tcase 'T':\n\t  f_sectime = 1;\n\t  break;\n\tcase 't':\n\t  sortkey = BY_TIME;\n\t  break;\n\tcase 'W':\n\t  f_whiteout = 1;\n\t  break;\n\tdefault:\n\t  return usage ();\n\t}\n    }\n  argc -= optind;\n  argv += optind;\n\n  /*\n   * If not -F, -i, -l, -p, -S, -s or -t options, don't require stat\n   * information.\n   */\n  if (!f_longform && !f_inode && !f_size && !f_type && !f_typedir &&\n      sortkey == BY_NAME)\n    fts_options |= FTS_NOSTAT;\n\n  /*\n   * If not -F, -d or -l options, follow any symbolic links listed on\n   * the command line.\n   */\n  if (!f_longform && !f_listdir && !f_type)\n    fts_options |= FTS_COMFOLLOW;\n\n  /*\n   * If -W, show whiteout entries\n   */\n#ifdef FTS_WHITEOUT\n  if (f_whiteout)\n    fts_options |= FTS_WHITEOUT;\n#endif\n\n  /* If -l or -s, figure out block size. */\n  if (f_longform || f_size)\n    {\n      blocksize = 1024;\t\t/* Fuck this hair-splitting */\n      blocksize /= 512;\n    }\n\n  /* Select a sort function. */\n  if (f_reversesort)\n    {\n      switch (sortkey)\n\t{\n\tcase BY_NAME:\n\t  sortfcn = revnamecmp;\n\t  break;\n\tcase BY_SIZE:\n\t  sortfcn = revsizecmp;\n\t  break;\n\tcase BY_TIME:\n\t  if (f_accesstime)\n\t    sortfcn = revacccmp;\n\t  else if (f_statustime)\n\t    sortfcn = revstatcmp;\n\t  else\t\t\t/* Use modification time. */\n\t    sortfcn = revmodcmp;\n\t  break;\n\t}\n    }\n  else\n    {\n      switch (sortkey)\n\t{\n\tcase BY_NAME:\n\t  sortfcn = namecmp;\n\t  break;\n\tcase BY_SIZE:\n\t  sortfcn = sizecmp;\n\t  break;\n\tcase BY_TIME:\n\t  if (f_accesstime)\n\t    sortfcn = acccmp;\n\t  else if (f_statustime)\n\t    sortfcn = statcmp;\n\t  else\t\t\t/* Use modification time. */\n\t    sortfcn = modcmp;\n\t  break;\n\t}\n    }\n\n  /* Select a print function. */\n  if (f_singlecol)\n    printfcn = printscol;\n  else if (f_columnacross)\n    printfcn = printacol;\n  else if (f_longform)\n    printfcn = printlong;\n  else if (f_stream)\n    printfcn = printstream;\n  else\n    printfcn = printcol;\n\n  if (argc)\n    traverse (argc, argv, fts_options);\n  else\n    traverse (1, dotav, fts_options);\n  return (rval);\n}",
      "lines": 240,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "traverse": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "static void\ntraverse (int argc, char **argv, int options)\n{\n  FTS *ftsp;\n  FTSENT *p, *chp;\n  int ch_options;\n\n  ftsp = fts_open (argv, options, f_nosort ? NULL : mastercmp);\n  if (ftsp == NULL)\n    {\n      fprintf (stderr, \"%s: fts_open: %s\", argv[0], strerror (errno));\n      rval = EXIT_FAILURE;\n      return;\n    }\n\n  display (NULL, fts_children (ftsp, 0));\n  if (f_listdir)\n    return;\n\n  /*\n   * If not recursing down this tree and don't need stat info, just get\n   * the names.\n   */\n  ch_options = !f_recursive && options & FTS_NOSTAT ? FTS_NAMEONLY : 0;\n\n  while ((p = fts_read (ftsp)) != NULL)\n    switch (p->fts_info)\n      {\n      case FTS_D:\n\tif (p->fts_name[0] == '.' &&\n\t    p->fts_level != FTS_ROOTLEVEL && !f_listdot)\n\t  break;\n\n\t/*\n\t * If already output something, put out a newline as\n\t * a separator.  If multiple arguments, precede each\n\t * directory with its name.\n\t */\n\tif (output)\n\t  printf (\"\\n%s:\\n\", p->fts_path);\n\telse if (argc > 1)\n\t  {\n\t    printf (\"%s:\\n\", p->fts_path);\n\t    output = 1;\n\t  }\n\n\tchp = fts_children (ftsp, ch_options);\n\tdisplay (p, chp);\n\n\tif (!f_recursive && chp != NULL)\n\t  fts_set (ftsp, p, FTS_SKIP);\n\tbreak;\n      case FTS_DC:\n\tfprintf (stderr, \"%s: directory causes a cycle\", p->fts_name);\n\tbreak;\n      case FTS_DNR:\n      case FTS_ERR:\n\tfprintf (stderr, \"%s: %s\\n\", p->fts_name, strerror (p->fts_errno));\n\trval = 1;\n\tbreak;\n      }\n  if (errno)\n    {\n      fprintf (stderr, \"fts_read: %s\", strerror (errno));\n      rval = EXIT_FAILURE;\n      return;\n    }\n}",
      "lines": 68,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "static void\ndisplay (FTSENT *p, FTSENT *list)\n{\n  struct stat *sp;\n  DISPLAY d;\n  FTSENT *cur;\n  NAMES *np;\n  unsigned long long maxsize;\n  unsigned long btotal, maxinode, maxlen, maxnlink;\n  long maxblock;\n  int bcfile, flen, glen, ulen, maxflags, maxgroup, maxuser;\n  int entries, needstats;\n  char *user = NULL, *group = NULL, buf[INT_BUFSIZE_BOUND (uintmax_t)];\n  char nuser[INT_BUFSIZE_BOUND (uintmax_t)],\n       ngroup[INT_BUFSIZE_BOUND (uintmax_t)];\n  char *flags = NULL;\n\n  /*\n   * If list is NULL there are two possibilities: that the parent\n   * directory p has no children, or that fts_children() returned an\n   * error.  We ignore the error case since it will be replicated\n   * on the next call to fts_read() on the post-order visit to the\n   * directory p, and will be signalled in traverse().\n   */\n  if (list == NULL)\n    return;\n\n  needstats = f_inode || f_longform || f_size;\n  flen = 0;\n  btotal = maxblock = maxinode = maxlen = maxnlink = 0;\n  bcfile = 0;\n  maxuser = maxgroup = maxflags = 0;\n  maxsize = 0;\n  for (cur = list, entries = 0; cur; cur = cur->fts_link)\n    {\n      if (cur->fts_info == FTS_ERR || cur->fts_info == FTS_NS)\n\t{\n\t  fprintf (stderr, \"%s: %s\\n\",\n\t\t   cur->fts_name, strerror (cur->fts_errno));\n\t  cur->fts_number = NO_PRINT;\n\t  rval = 1;\n\t  continue;\n\t}\n\n      /*\n       * P is NULL if list is the argv list, to which different rules\n       * apply.\n       */\n      if (p == NULL)\n\t{\n\t  /* Directories will be displayed later. */\n\t  if (cur->fts_info == FTS_D && !f_listdir)\n\t    {\n\t      cur->fts_number = NO_PRINT;\n\t      continue;\n\t    }\n\t}\n      else\n\t{\n\t  /* Only display dot file if -a/-A set. */\n\t  if (cur->fts_name[0] == '.' && !f_listdot)\n\t    {\n\t      cur->fts_number = NO_PRINT;\n\t      continue;\n\t    }\n\t}\n      if (cur->fts_namelen > maxlen)\n\tmaxlen = cur->fts_namelen;\n      if (needstats)\n\t{\n\t  sp = cur->fts_statp;\n\t  if (sp->st_blocks > maxblock)\n\t    maxblock = sp->st_blocks;\n\t  if (sp->st_ino > maxinode)\n\t    maxinode = sp->st_ino;\n\t  if (sp->st_nlink > maxnlink)\n\t    maxnlink = sp->st_nlink;\n\t  if (sp->st_size > (off_t) maxsize)\n\t    maxsize = sp->st_size;\n\n\t  btotal += sp->st_blocks;\n\t  if (f_longform)\n\t    {\n\t      struct passwd *pwd;\n\t      struct group *grp;\n\n\t      user = group = NULL;\n\n\t      if (!f_numericonly)\n\t\t{\n\t\t  pwd = getpwuid (sp->st_uid);\n\t\t  if (pwd)\n\t\t    user = pwd->pw_name;\n\t\t  grp = getgrgid (sp->st_gid);\n\t\t  if (grp)\n\t\t    group = grp->gr_name;\n\t\t}\n\t      if (!user)\n\t\tuser = umaxtostr (sp->st_uid, nuser);\n\t      if (!group)\n\t\tgroup = umaxtostr (sp->st_gid, ngroup);\n\n\t      ulen = strlen (user);\n\t      if (ulen > maxuser)\n\t\tmaxuser = ulen;\n\t      glen = strlen (group);\n\t      if (glen > maxgroup)\n\t\tmaxgroup = glen;\n\n\t      if (f_flags)\n\t\t{\n\t\t  flags = \"-\";\n\t\t  flen = strlen (flags);\n\t\t  if (flen > maxflags)\n\t\t    maxflags = flen;\n\t\t}\n\t      else\n\t\tflen = 0;\n\n\t      np = malloc (sizeof (NAMES) + ulen + glen + flen + 3);\n\t      if (np == NULL)\n\t\t{\n\t\t  fprintf (stderr, \"malloc: %s\", strerror (errno));\n\t\t  rval = EXIT_FAILURE;\n\t\t  return;\n\t\t}\n\n\t      np->user = &np->data[0];\n\t      strcpy (np->user, user);\n\t      np->group = &np->data[ulen + 1];\n\t      strcpy (np->group, group);\n\n\t      if (S_ISCHR (sp->st_mode) || S_ISBLK (sp->st_mode))\n\t\tbcfile = 1;\n\n\t      if (f_flags)\n\t\t{\n\t\t  np->flags = &np->data[ulen + glen + 2];\n\t\t  strcpy (np->flags, flags);\n\t\t}\n\t      cur->fts_pointer = np;\n\t    }\n\t}\n      ++entries;\n    }\n\n  if (!entries)\n    return;\n\n  d.list = list;\n  d.entries = entries;\n  d.maxlen = maxlen;\n  if (needstats)\n    {\n      d.bcfile = bcfile;\n      d.btotal = btotal;\n      d.s_block = strlen (umaxtostr (maxblock, buf));\n      d.s_flags = maxflags;\n      d.s_group = maxgroup;\n      d.s_inode = strlen (umaxtostr (maxinode, buf));\n      d.s_nlink = strlen (umaxtostr (maxnlink, buf));\n      d.s_size = strlen (umaxtostr (maxsize, buf));\n      d.s_user = maxuser;\n    }\n\n  printfcn (&d);\n  output = 1;\n\n  if (f_longform)\n    for (cur = list; cur; cur = cur->fts_link)\n      free (cur->fts_pointer);\n}",
      "lines": 172,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mastercmp": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "static int\nmastercmp (const FTSENT **a, const FTSENT **b)\n{\n  int a_info, b_info;\n\n  a_info = (*a)->fts_info;\n  if (a_info == FTS_ERR)\n    return (0);\n  b_info = (*b)->fts_info;\n  if (b_info == FTS_ERR)\n    return (0);\n\n  if (a_info == FTS_NS || b_info == FTS_NS)\n    {\n      if (b_info != FTS_NS)\n        return (1);\n      else if (a_info != FTS_NS)\n        return (-1);\n      else\n        return (namecmp (*a, *b));\n    }\n\n  if (a_info != b_info && (*a)->fts_level == FTS_ROOTLEVEL && !f_listdir)\n    {\n      if (a_info == FTS_D)\n\treturn (1);\n      if (b_info == FTS_D)\n\treturn (-1);\n    }\n  return (sortfcn (*a, *b));\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/ls.h": {},
  "inetutils/inetutils-1.9.4/libls/print.c": {
    "printscol": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\nprintscol (DISPLAY *dp)\n{\n  FTSENT *p;\n\n  for (p = dp->list; p; p = p->fts_link)\n    {\n      if (IS_NOPRINT (p))\n\tcontinue;\n      printaname (p, dp->s_inode, dp->s_block);\n      putchar ('\\n');\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "printlong": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nprintlong (DISPLAY *dp)\n{\n  struct stat *sp;\n  FTSENT *p;\n  NAMES *np;\n  char buf[20];\n\n  if (dp->list->fts_level != FTS_ROOTLEVEL && (f_longform || f_size))\n    printf (\"total %lu\\n\", howmany (dp->btotal, blocksize));\n\n  for (p = dp->list; p; p = p->fts_link)\n    {\n      if (IS_NOPRINT (p))\n\tcontinue;\n      sp = p->fts_statp;\n      if (f_inode)\n\tprintf (\"%*lu \", dp->s_inode, (unsigned long) sp->st_ino);\n      if (f_size)\n\tprintf (\"%*llu \",\n\t\tdp->s_block, (long long) howmany (sp->st_blocks, blocksize));\n      strmode (sp->st_mode, buf);\n      np = p->fts_pointer;\n      printf (\"%s %*d %-*s  %-*s  \",\n\t      buf, dp->s_nlink, (int) sp->st_nlink,\n\t      dp->s_user, np->user, dp->s_group, np->group);\n      if (f_flags)\n\tprintf (\"%-*s \", dp->s_flags, np->flags);\n      if (S_ISCHR (sp->st_mode) || S_ISBLK (sp->st_mode))\n\tprintf (\"%3d, %3d \", major (sp->st_rdev), minor (sp->st_rdev));\n      else if (dp->bcfile)\n\tprintf (\"%*s%*llu \",\n\t\t8 - dp->s_size, \"\", dp->s_size, (long long) sp->st_size);\n      else\n\tprintf (\"%*llu \", dp->s_size, (long long) sp->st_size);\n      if (f_accesstime)\n\tprinttime (sp->st_atime);\n      else if (f_statustime)\n\tprinttime (sp->st_ctime);\n      else\n\tprinttime (sp->st_mtime);\n      putname (p->fts_name);\n      if (f_type || (f_typedir && S_ISDIR (sp->st_mode)))\n\tprinttype (sp->st_mode);\n      if (S_ISLNK (sp->st_mode))\n\tprintlink (p);\n      putchar ('\\n');\n    }\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "compute_columns": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "static int\ncompute_columns (DISPLAY *dp, int *pnum)\n{\n  int colwidth;\n  extern int termwidth;\n  int mywidth;\n\n  colwidth = dp->maxlen;\n  if (f_inode)\n    colwidth += dp->s_inode + 1;\n  if (f_size)\n    colwidth += dp->s_block + 1;\n  if (f_type || f_typedir)\n    colwidth += 1;\n\n  colwidth += 1;\n  mywidth = termwidth + 1;\t/* no extra space for last column */\n\n  if (mywidth < 2 * colwidth)\n    {\n      printscol (dp);\n      return (0);\n    }\n\n  *pnum = mywidth / colwidth;\n  return (mywidth / *pnum);\t/* spread out if possible */\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "printcol": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "void\nprintcol (DISPLAY *dp)\n{\n  static FTSENT **array;\n  static int lastentries = -1;\n  FTSENT *p;\n  int base, chcnt, col, colwidth, num;\n  int numcols, numrows, row;\n\n  if ((colwidth = compute_columns (dp, &numcols)) == 0)\n    return;\n  /*\n   * Have to do random access in the linked list -- build a table\n   * of pointers.\n   */\n  if (dp->entries > lastentries)\n    {\n      FTSENT **a;\n\n      if ((a = realloc (array, dp->entries * sizeof (FTSENT *))) == NULL)\n\t{\n\t  fprintf (stderr, \"realloci: %s \\n\", strerror (errno));\n\t  printscol (dp);\n\t  return;\n\t}\n      lastentries = dp->entries;\n      array = a;\n    }\n  for (p = dp->list, num = 0; p; p = p->fts_link)\n    if (p->fts_number != NO_PRINT)\n      array[num++] = p;\n\n  numrows = num / numcols;\n  if (num % numcols)\n    ++numrows;\n\n  if (dp->list->fts_level != FTS_ROOTLEVEL && (f_longform || f_size))\n    printf (\"total %lu\\n\", howmany (dp->btotal, blocksize));\n  for (row = 0; row < numrows; ++row)\n    {\n      for (base = row, col = 0;;)\n\t{\n\t  chcnt = printaname (array[base], dp->s_inode, dp->s_block);\n\t  if ((base += numrows) >= num)\n\t    break;\n\t  if (++col == numcols)\n\t    break;\n\t  while (chcnt++ < colwidth)\n\t    putchar (' ');\n\t}\n      putchar ('\\n');\n    }\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "printaname": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static int\nprintaname (FTSENT *p, unsigned long inodefield, unsigned long sizefield)\n{\n  struct stat *sp;\n  int chcnt;\n\n  sp = p->fts_statp;\n  chcnt = 0;\n  if (f_inode)\n    chcnt += printf (\"%*lu \", (int) inodefield, (unsigned long) sp->st_ino);\n  if (f_size)\n    chcnt += printf (\"%*llu \",\n\t\t     (int) sizefield, (long long) howmany (sp->st_blocks,\n\t\t\t\t\t\t\t   blocksize));\n  chcnt += putname (p->fts_name);\n  if (f_type || (f_typedir && S_ISDIR (sp->st_mode)))\n    chcnt += printtype (sp->st_mode);\n  return (chcnt);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "printtime": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static void\nprinttime (time_t ftime)\n{\n  int i;\n  char *longstring;\n\n  longstring = ctime (&ftime);\n  for (i = 4; i < 11; ++i)\n    putchar (longstring[i]);\n\n#define SIXMONTHS\t((DAYSPERNYEAR / 2) * SECSPERDAY)\n  if (f_sectime)\n    for (i = 11; i < 24; i++)\n      putchar (longstring[i]);\n  else if (ftime + SIXMONTHS > time (NULL))\n    for (i = 11; i < 16; ++i)\n      putchar (longstring[i]);\n  else\n    {\n      putchar (' ');\n      for (i = 20; i < 24; ++i)\n\tputchar (longstring[i]);\n    }\n  putchar (' ');\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printacol": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "void\nprintacol (DISPLAY *dp)\n{\n  FTSENT *p;\n  int chcnt, col, colwidth;\n  int numcols;\n\n  if ((colwidth = compute_columns (dp, &numcols)) == 0)\n    return;\n\n  if (dp->list->fts_level != FTS_ROOTLEVEL && (f_longform || f_size))\n    printf (\"total %llu\\n\", (long long) (howmany (dp->btotal, blocksize)));\n  col = 0;\n  for (p = dp->list; p; p = p->fts_link)\n    {\n      if (IS_NOPRINT (p))\n\tcontinue;\n      if (col >= numcols)\n\t{\n\t  col = 0;\n\t  putchar ('\\n');\n\t}\n      chcnt = printaname (p, dp->s_inode, dp->s_block);\n      col++;\n      if (col < numcols)\n\twhile (chcnt++ < colwidth)\n\t  putchar (' ');\n    }\n  putchar ('\\n');\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "printstream": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void\nprintstream (DISPLAY *dp)\n{\n  extern int termwidth;\n  FTSENT *p;\n  int col;\n  int extwidth;\n\n  extwidth = 0;\n  if (f_inode)\n    extwidth += dp->s_inode + 1;\n  if (f_size)\n    extwidth += dp->s_block + 1;\n  if (f_type)\n    extwidth += 1;\n\n  for (col = 0, p = dp->list; p != NULL; p = p->fts_link)\n    {\n      if (IS_NOPRINT (p))\n\tcontinue;\n      if (col > 0)\n\t{\n\t  putchar (','), col++;\n\t  if (col + 1 + extwidth + p->fts_namelen >= termwidth)\n\t    putchar ('\\n'), col = 0;\n\t  else\n\t    putchar (' '), col++;\n\t}\n      col += printaname (p, dp->s_inode, dp->s_block);\n    }\n  putchar ('\\n');\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "printtype": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static int\nprinttype (u_int mode)\n{\n  switch (mode & S_IFMT)\n    {\n    case S_IFDIR:\n      putchar ('/');\n      return (1);\n    case S_IFIFO:\n      putchar ('|');\n      return (1);\n    case S_IFLNK:\n      putchar ('@');\n      return (1);\n    case S_IFSOCK:\n      putchar ('=');\n      return (1);\n    }\n  if (mode & (S_IXUSR | S_IXGRP | S_IXOTH))\n    {\n      putchar ('*');\n      return (1);\n    }\n  return (0);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "printlink": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "static void\nprintlink (FTSENT *p)\n{\n  int lnklen;\n#ifndef MAXPATHLEN\n# define MAXPATHLEN 1024\n#endif\n  char name[MAXPATHLEN], path[MAXPATHLEN];\n\n  if (p->fts_level == FTS_ROOTLEVEL)\n    snprintf (name, sizeof (name), \"%s\", p->fts_name);\n  else\n    snprintf (name, sizeof (name),\n\t      \"%s/%s\", p->fts_parent->fts_accpath, p->fts_name);\n  if ((lnklen = readlink (name, path, sizeof (path) - 1)) == -1)\n    {\n      fprintf (stderr, \"\\nls: %s: %s\\n\", name, strerror (errno));\n      return;\n    }\n  path[lnklen] = '\\0';\n  printf (\" -> \");\n  putname (path);\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/stat_flags.c": {
    "flags_to_string": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "char *\nflags_to_string (u_int flags, char *def)\n{\n  static char string[128];\n  char *prefix;\n\n  string[0] = '\\0';\n  prefix = NULL;\n  return (prefix == NULL && def != NULL ? def : string);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "char",
        "*\nflags_to_string (u_int flags, char *def)",
        "*"
      ]
    },
    "string_to_flags": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nstring_to_flags (char **stringp, u_int *setp, u_int *clrp)\n{\n  if (setp)\n    *setp = 0;\n  if (clrp)\n    *clrp = 0;\n  return (0);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libls/util.c": {
    "putname": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "int\nputname (char *name)\n{\n  int len;\n\n  for (len = 0; *name; len++, name++)\n    putchar ((!isprint (*name) && f_nonprint) ? '?' : *name);\n  return len;\n}",
      "lines": 9,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "usage": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nusage (void)\n{\n  fprintf (stderr, \"usage: ls [-1ACFLRSTWacdfiklmnopqrstux] [file ...]\\n\");\n  return (EXIT_FAILURE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/auth-proto.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/auth.c": {
    "findauthenticator": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "TN_Authenticator *\nfindauthenticator (int type, int way)\n{\n  TN_Authenticator *ap = authenticators;\n\n  while (ap->type && (ap->type != type || ap->way != way))\n    ++ap;\n  return (ap->type ? ap : 0);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "TN_Authenticator",
        "*\nfindauthenticator (int type, int way)",
        "*"
      ]
    },
    "auth_init": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\nauth_init (char *name, int server)\n{\n  TN_Authenticator *ap = authenticators;\n\n  Server = server;\n  Name = name;\n\n  i_support = 0;\n  authenticated = NULL;\n  authenticating = 0;\n  while (ap->type)\n    {\n      if (!ap->init || (*ap->init) (ap, server))\n\t{\n\t  i_support |= typemask (ap->type);\n\t  if (auth_debug_mode)\n\t    printf (\">>>%s: I support auth type %s (%d) %s (%d)\\r\\n\",\n\t\t    Name,\n\t\t    (AUTHTYPE_NAME_OK (ap->type) && AUTHTYPE_NAME (ap->type))\n\t\t    ? AUTHTYPE_NAME (ap->type) : \"unknown\",\n\t\t    ap->type,\n\t\t    (ap->way & AUTH_HOW_MASK & AUTH_HOW_MUTUAL)\n\t\t    ? \"MUTUAL\" : \"ONEWAY\", ap->way);\n\t}\n      else if (auth_debug_mode)\n\tprintf (\">>>%s: Init failed: auth type %d %d\\r\\n\",\n\t\tName, ap->type, ap->way);\n      ++ap;\n    }\n}",
      "lines": 31,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "auth_disable_name": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\nauth_disable_name (char *name)\n{\n  int x;\n\n  for (x = 0; x < AUTHTYPE_CNT; ++x)\n    {\n      if (AUTHTYPE_NAME (x) && !strcasecmp (name, AUTHTYPE_NAME (x)))\n\t{\n\t  i_wont_support |= typemask (x);\n\t  break;\n\t}\n    }\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "getauthmask": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\ngetauthmask (char *type, int *maskp)\n{\n  register int x;\n\n  if (AUTHTYPE_NAME (0) && !strcasecmp (type, AUTHTYPE_NAME (0)))\n    {\n      *maskp = -1;\n      return (1);\n    }\n\n  for (x = 1; x < AUTHTYPE_CNT; ++x)\n    {\n      if (AUTHTYPE_NAME (x) && !strcasecmp (type, AUTHTYPE_NAME (x)))\n\t{\n\t  *maskp = typemask (x);\n\t  return (1);\n\t}\n    }\n  return (0);\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "auth_enable": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int\nauth_enable (char *type)\n{\n  return (auth_onoff (type, 1));\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "auth_disable": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "int\nauth_disable (char *type)\n{\n  return (auth_onoff (type, 0));\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "auth_onoff": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "int\nauth_onoff (char *type, int on)\n{\n  int i, mask = -1;\n  TN_Authenticator *ap;\n\n  if (!strcasecmp (type, \"?\") || !strcasecmp (type, \"help\"))\n    {\n      printf (\"auth %s 'type'\\n\", on ? \"enable\" : \"disable\");\n      printf (\"Where 'type' is one of:\\n\");\n      printf (\"\\t%s\\n\", AUTHTYPE_NAME (0));\n      mask = 0;\n      for (ap = authenticators; ap->type; ap++)\n\t{\n\t  i = typemask (ap->type);\n\t  if ((mask & i) != 0)\n\t    continue;\n\t  mask |= i;\n\t  printf (\"\\t%s\\n\", AUTHTYPE_NAME (ap->type));\n\t}\n      return (0);\n    }\n\n  if (!getauthmask (type, &mask))\n    {\n      printf (\"%s: invalid authentication type\\n\", type);\n      return (0);\n    }\n  if (on)\n    i_wont_support &= ~mask;\n  else\n    i_wont_support |= mask;\n  return (1);\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "auth_togdebug": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "int\nauth_togdebug (int on)\n{\n  if (on < 0)\n    auth_debug_mode ^= 1;\n  else\n    auth_debug_mode = on;\n  printf (\"auth debugging %s\\n\", auth_debug_mode ? \"enabled\" : \"disabled\");\n  return (1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "auth_status": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "int\nauth_status ()\n{\n  TN_Authenticator *ap;\n  int i, mask;\n\n  if (i_wont_support == -1)\n    printf (\"Authentication disabled\\n\");\n  else\n    printf (\"Authentication enabled\\n\");\n\n  mask = 0;\n  for (ap = authenticators; ap->type; ap++)\n    {\n      i = typemask (ap->type);\n      if ((mask & i) != 0)\n\tcontinue;\n      mask |= i;\n      printf (\"%s: %s\\n\", AUTHTYPE_NAME (ap->type),\n\t      (i_wont_support & typemask (ap->type)) ?\n\t      \"disabled\" : \"enabled\");\n    }\n  return (1);\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "auth_request": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void\nauth_request ()\n{\n  static unsigned char str_request[64] = { IAC, SB,\n    TELOPT_AUTHENTICATION,\n    TELQUAL_SEND,\n  };\n  TN_Authenticator *ap = authenticators;\n  unsigned char *e = str_request + 4;\n\n  if (!authenticating)\n    {\n      authenticating = 1;\n      while (ap->type)\n\t{\n\t  if (i_support & ~i_wont_support & typemask (ap->type))\n\t    {\n\t      if (auth_debug_mode)\n\t\t{\n\t\t  printf (\">>>%s: Sending type %d %d\\r\\n\",\n\t\t\t  Name, ap->type, ap->way);\n\t\t}\n\t      *e++ = ap->type;\n\t      *e++ = ap->way;\n\t    }\n\t  ++ap;\n\t}\n      *e++ = IAC;\n      *e++ = SE;\n      net_write (str_request, e - str_request);\n      printsub ('>', &str_request[2], e - str_request - 2);\n    }\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "auth_send": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "void\nauth_send (unsigned char *data, int cnt)\n{\n  TN_Authenticator *ap;\n  static unsigned char str_none[] = { IAC, SB, TELOPT_AUTHENTICATION,\n    TELQUAL_IS, AUTHTYPE_NULL, 0,\n    IAC, SE\n  };\n  if (Server)\n    {\n      if (auth_debug_mode)\n\t{\n\t  printf (\">>>%s: auth_send called!\\r\\n\", Name);\n\t}\n      return;\n    }\n\n  if (auth_debug_mode)\n    {\n      printf (\">>>%s: auth_send got:\", Name);\n      printd (data, cnt);\n      printf (\"\\r\\n\");\n    }\n\n  /*\n   * Save the data, if it is new, so that we can continue looking\n   * at it if the authorization we try doesn't work\n   */\n  if (data < _auth_send_data ||\n      data > _auth_send_data + sizeof (_auth_send_data))\n    {\n      auth_send_cnt = (cnt > (int) sizeof (_auth_send_data))\n\t\t      ? (int) sizeof (_auth_send_data) : cnt;\n      memmove ((void *) _auth_send_data, (void *) data, auth_send_cnt);\n      auth_send_data = _auth_send_data;\n    }\n  else\n    {\n      /*\n       * This is probably a no-op, but we just make sure\n       */\n      auth_send_data = data;\n      auth_send_cnt = cnt;\n    }\n  while ((auth_send_cnt -= 2) >= 0)\n    {\n      if (auth_debug_mode)\n\tprintf (\">>>%s: He supports %s (%d) %s (%d)\\r\\n\",\n\t\tName,\n\t\t(AUTHTYPE_NAME_OK (auth_send_data[0])\n\t\t && AUTHTYPE_NAME (auth_send_data[0]))\n\t\t? AUTHTYPE_NAME (auth_send_data[0]) : \"unknown\",\n\t\tauth_send_data[0],\n\t\t(auth_send_data[1] & AUTH_HOW_MASK & AUTH_HOW_MUTUAL)\n\t\t? \"MUTUAL\" : \"ONEWAY\",\n\t\tauth_send_data[1]);\n      if ((i_support & ~i_wont_support) & typemask (*auth_send_data))\n\t{\n\t  ap = findauthenticator (auth_send_data[0], auth_send_data[1]);\n\t  if (ap && ap->send)\n\t    {\n\t      if (auth_debug_mode)\n\t\tprintf (\">>>%s: Trying %s (%d) %s (%d)\\r\\n\",\n\t\t\tName,\n\t\t\t(AUTHTYPE_NAME_OK (auth_send_data[0])\n\t\t\t && AUTHTYPE_NAME (auth_send_data[0]))\n\t\t\t? AUTHTYPE_NAME (auth_send_data[0]) : \"unknown\",\n\t\t\tauth_send_data[0],\n\t\t\t(auth_send_data[1] & AUTH_HOW_MASK & AUTH_HOW_MUTUAL)\n\t\t\t? \"MUTUAL\" : \"ONEWAY\",\n\t\t\tauth_send_data[1]);\n\t      if ((*ap->send) (ap))\n\t\t{\n\t\t  /*\n\t\t   * Okay, we found one we like\n\t\t   * and did it.\n\t\t   * we can go home now.\n\t\t   */\n\t\t  if (auth_debug_mode)\n\t\t    printf (\">>>%s: Using type %s (%d)\\r\\n\",\n\t\t\t    Name,\n\t\t\t    (AUTHTYPE_NAME_OK (*auth_send_data)\n\t\t\t     && AUTHTYPE_NAME (*auth_send_data))\n\t\t\t    ? AUTHTYPE_NAME (*auth_send_data) : \"unknown\",\n\t\t\t    *auth_send_data);\n\t\t  auth_send_data += 2;\n\t\t  return;\n\t\t}\n\t    }\n\t  /* else\n\t   *      just continue on and look for the\n\t   *      next one if we didn't do anything.\n\t   */\n\t}\n      auth_send_data += 2;\n    }\n  net_write (str_none, sizeof (str_none));\n  printsub ('>', &str_none[2], sizeof (str_none) - 2);\n  if (auth_debug_mode)\n    printf (\">>>%s: Sent failure message\\r\\n\", Name);\n  auth_finished (0, AUTH_REJECT);\n# ifdef KANNAN\n  /*\n   *  We requested strong authentication, however no mechanisms worked.\n   *  Therefore, exit on client end.\n   */\n  printf (\"Unable to securely authenticate user ... exit\\n\");\n  exit (EXIT_SUCCESS);\n# endif\t/* KANNAN */\n}",
      "lines": 110,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "auth_send_retry": {
      "start_point": [
        552,
        0
      ],
      "end_point": [
        560,
        1
      ],
      "content": "void\nauth_send_retry ()\n{\n  /*\n   * if auth_send_cnt <= 0 then auth_send will end up rejecting\n   * the authentication and informing the other side of this.\n   */\n  auth_send (auth_send_data, auth_send_cnt);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "auth_is": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "void\nauth_is (unsigned char *data, int cnt)\n{\n  TN_Authenticator *ap;\n\n  if (cnt < 2)\n    return;\n\n  if (data[0] == AUTHTYPE_NULL)\n    {\n      auth_finished (0, AUTH_REJECT);\n      return;\n    }\n\n  ap = findauthenticator (data[0], data[1]);\n  if (ap)\n    {\n      if (ap->is)\n\t(*ap->is) (ap, data + 2, cnt - 2);\n    }\n  else if (auth_debug_mode)\n    printf (\">>>%s: Invalid authentication in IS: %d\\r\\n\", Name, *data);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "auth_reply": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "void\nauth_reply (unsigned char *data, int cnt)\n{\n  TN_Authenticator *ap;\n\n  if (cnt < 2)\n    return;\n\n  ap = findauthenticator (data[0], data[1]);\n  if (ap)\n    {\n      if (ap->reply)\n\t(*ap->reply) (ap, data + 2, cnt - 2);\n    }\n  else if (auth_debug_mode)\n    printf (\">>>%s: Invalid authentication in SEND: %d\\r\\n\", Name, *data);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "auth_name": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "void\nauth_name (unsigned char *data, int cnt)\n{\n  char savename[256];\n\n  if (cnt < 1)\n    {\n      if (auth_debug_mode)\n\tprintf (\">>>%s: Empty name in NAME\\r\\n\", Name);\n      return;\n    }\n  if (cnt + 1 > (int) sizeof (savename))\n    {\n      if (auth_debug_mode)\n\tprintf (\">>>%s: Name in NAME (len %d) overflows buffer (len %zu).\\r\\n\",\n\t\tName, cnt, sizeof (savename) - 1);\n      return;\n    }\n  memmove ((void *) savename, (void *) data, cnt);\n  savename[cnt] = '\\0';\t\t/* Null terminate */\n  if (auth_debug_mode)\n    printf (\">>>%s: Got NAME [%s]\\r\\n\", Name, savename);\n  auth_encrypt_user (savename);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "auth_sendname": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "int\nauth_sendname (char *name, int len)\n{\n  static unsigned char str_request[256 + 6]\n    = { IAC, SB, TELOPT_AUTHENTICATION, TELQUAL_NAME, };\n  register unsigned char *e = str_request + 4;\n  register unsigned char *ee = &str_request[sizeof (str_request) - 2];\n  unsigned char *cp = (unsigned char *) name;\n\n  while (--len >= 0)\n    {\n      if ((*e++ = *cp++) == IAC)\n\t*e++ = IAC;\n      if (e >= ee)\n\treturn (0);\n    }\n  *e++ = IAC;\n  *e++ = SE;\n  net_write (str_request, e - str_request);\n  printsub ('>', &str_request[2], e - &str_request[2]);\n  return (1);\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "auth_finished": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "void\nauth_finished (TN_Authenticator * ap, int result)\n{\n  if (ap && ap->cleanup)\n    (*ap->cleanup) (ap);\n\n  authenticated = ap;\n  if (!authenticated)\n    authenticated = &NoAuth;\n\n  validuser = result;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "auth_intr": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "static void\nauth_intr (int sig _GL_UNUSED_PARAMETER)\n{\n  auth_finished (0, AUTH_REJECT);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "auth_wait": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "int\nauth_wait (char *name, size_t len)\n{\n  if (auth_debug_mode)\n    printf (\">>>%s: in auth_wait.\\r\\n\", Name);\n\n  if (Server && !authenticating)\n    return (0);\n\n  signal (SIGALRM, auth_intr);\n  alarm (30);\n  while (!authenticated)\n    if (telnet_spin ())\n      break;\n  alarm (0);\n  signal (SIGALRM, SIG_DFL);\n\n  /*\n   * Now check to see if the user is valid or not\n   */\n  if (!authenticated || authenticated == &NoAuth)\n    return (AUTH_REJECT);\n\n  if (validuser == AUTH_VALID)\n    validuser = AUTH_USER;\n\n  if (authenticated->status)\n    validuser = (*authenticated->status) (authenticated, name, len,\n\t\t\t\t\t  validuser);\n  return (validuser);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "auth_debug": {
      "start_point": [
        703,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "void\nauth_debug (int mode)\n{\n  auth_debug_mode = mode;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "auth_gen_printsub": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        730,
        1
      ],
      "content": "static void\nauth_gen_printsub (unsigned char *data, int cnt, char *buf,\n\t\t   int buflen)\n{\n  register char *cp;\n  char tbuf[16];\n\n  cnt -= 3;\n  data += 3;\n  buf[buflen - 1] = '\\0';\n  buf[buflen - 2] = '*';\n  buflen -= 2;\n  for (; cnt > 0; cnt--, data++)\n    {\n      sprintf (tbuf, \" %d\", *data);\n      for (cp = tbuf; *cp && buflen > 0; --buflen)\n\t*buf++ = *cp++;\n      if (buflen <= 0)\n\treturn;\n    }\n  *buf = '\\0';\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "auth_printsub": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "void\nauth_printsub (unsigned char *data, int cnt, char *buf, int buflen)\n{\n  TN_Authenticator *ap;\n\n  ap = findauthenticator (data[1], data[2]);\n  if (ap && ap->printsub)\n    (*ap->printsub) (data, cnt, buf, buflen);\n  else\n    auth_gen_printsub (data, cnt, buf, buflen);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/auth.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/enc-proto.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/encrypt.c": {
    "findencryption": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "Encryptions *\nfindencryption (int type)\n{\n  Encryptions *ep = encryptions;\n\n  if (!(I_SUPPORT_ENCRYPT & remote_supports_decrypt & typemask (type)))\n    return (0);\n  while (ep->type && ep->type != type)\n    ++ep;\n  return (ep->type ? ep : 0);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "Encryptions",
        "*\nfindencryption (int type)",
        "*"
      ]
    },
    "finddecryption": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "Encryptions *\nfinddecryption (int type)\n{\n  Encryptions *ep = encryptions;\n\n  if (!(I_SUPPORT_DECRYPT & remote_supports_encrypt & typemask (type)))\n    return (0);\n  while (ep->type && ep->type != type)\n    ++ep;\n  return (ep->type ? ep : 0);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "Encryptions",
        "*\nfinddecryption (int type)",
        "*"
      ]
    },
    "encrypt_init": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\nencrypt_init (char *name, int server)\n{\n  Encryptions *ep = encryptions;\n\n  Name = name;\n  Server = server;\n  i_support_encrypt = i_support_decrypt = 0;\n  remote_supports_encrypt = remote_supports_decrypt = 0;\n  encrypt_mode = 0;\n  decrypt_mode = 0;\n  encrypt_output = 0;\n  decrypt_input = 0;\n  str_suplen = 4;\n\n  while (ep->type)\n    {\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: I will support %s\\r\\n\",\n\t\tName, ENCTYPE_NAME (ep->type));\n      i_support_encrypt |= typemask (ep->type);\n      i_support_decrypt |= typemask (ep->type);\n      if ((i_wont_support_decrypt & typemask (ep->type)) == 0)\n\tif ((str_send[str_suplen++] = ep->type) == IAC)\n\t  str_send[str_suplen++] = IAC;\n      if (ep->init)\n\t(*ep->init) (Server);\n      ++ep;\n    }\n  str_send[str_suplen++] = IAC;\n  str_send[str_suplen++] = SE;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "encrypt_list_types": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\nencrypt_list_types (void)\n{\n  Encryptions *ep = encryptions;\n\n  printf (\"Valid encryption types:\\n\");\n  while (ep->type)\n    {\n      printf (\"\\t%s (%d)\\r\\n\", ENCTYPE_NAME (ep->type), ep->type);\n      ++ep;\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "EncryptEnable": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\nEncryptEnable (char *type, char *mode)\n{\n  if (isprefix (type, \"help\") || isprefix (type, \"?\"))\n    {\n      printf (\"Usage: encrypt enable <type> [input|output]\\n\");\n      encrypt_list_types ();\n      return (0);\n    }\n  if (EncryptType (type, mode))\n    return (EncryptStart (mode));\n  return (0);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "EncryptDisable": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nEncryptDisable (char *type, char *mode)\n{\n  Encryptions *ep;\n  int ret = 0;\n\n  if (isprefix (type, \"help\") || isprefix (type, \"?\"))\n    {\n      printf (\"Usage: encrypt disable <type> [input|output]\\n\");\n      encrypt_list_types ();\n    }\n  else if ((ep = (Encryptions *) genget (type, (char **) encryptions,\n\t\t\t\t\t sizeof (Encryptions))) == 0)\n    printf (\"%s: invalid encryption type\\n\", type);\n  else if (Ambiguous ((char *) ep))\n    printf (\"Ambiguous type '%s'\\n\", type);\n  else\n    {\n      if ((mode == 0) || (isprefix (mode, \"input\") ? 1 : 0))\n\t{\n\t  if (decrypt_mode == ep->type)\n\t    EncryptStopInput ();\n\t  i_wont_support_decrypt |= typemask (ep->type);\n\t  ret = 1;\n\t}\n      if ((mode == 0) || (isprefix (mode, \"output\")))\n\t{\n\t  if (encrypt_mode == ep->type)\n\t    EncryptStopOutput ();\n\t  i_wont_support_encrypt |= typemask (ep->type);\n\t  ret = 1;\n\t}\n      if (ret == 0)\n\tprintf (\"%s: invalid encryption mode\\n\", mode);\n    }\n  return (ret);\n}",
      "lines": 37,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "EncryptType": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "int\nEncryptType (char *type, char *mode)\n{\n  Encryptions *ep;\n  int ret = 0;\n\n  if (isprefix (type, \"help\") || isprefix (type, \"?\"))\n    {\n      printf (\"Usage: encrypt type <type> [input|output]\\n\");\n      encrypt_list_types ();\n    }\n  else if ((ep = (Encryptions *) genget (type, (char **) encryptions,\n\t\t\t\t\t sizeof (Encryptions))) == 0)\n    printf (\"%s: invalid encryption type\\n\", type);\n  else if (Ambiguous ((char *) ep))\n    printf (\"Ambiguous type '%s'\\n\", type);\n  else\n    {\n      if ((mode == 0) || isprefix (mode, \"input\"))\n\t{\n\t  decrypt_mode = ep->type;\n\t  i_wont_support_decrypt &= ~typemask (ep->type);\n\t  ret = 1;\n\t}\n      if ((mode == 0) || isprefix (mode, \"output\"))\n\t{\n\t  encrypt_mode = ep->type;\n\t  i_wont_support_encrypt &= ~typemask (ep->type);\n\t  ret = 1;\n\t}\n      if (ret == 0)\n\tprintf (\"%s: invalid encryption mode\\n\", mode);\n    }\n  return (ret);\n}",
      "lines": 35,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "EncryptStart": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "int\nEncryptStart (char *mode)\n{\n  int ret = 0;\n  if (mode)\n    {\n      if (isprefix (mode, \"input\"))\n\treturn (EncryptStartInput ());\n      if (isprefix (mode, \"output\"))\n\treturn (EncryptStartOutput ());\n      if (isprefix (mode, \"help\") || isprefix (mode, \"?\"))\n\t{\n\t  printf (\"Usage: encrypt start [input|output]\\n\");\n\t  return (0);\n\t}\n      printf (\"%s: invalid encryption mode 'encrypt start ?' for help\\n\",\n\t      mode);\n      return (0);\n    }\n  ret += EncryptStartInput ();\n  ret += EncryptStartOutput ();\n  return (ret);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "EncryptStartInput": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "int\nEncryptStartInput (void)\n{\n  if (decrypt_mode)\n    {\n      encrypt_send_request_start ();\n      return (1);\n    }\n  printf (\"No previous decryption mode, decryption not enabled\\r\\n\");\n  return (0);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "EncryptStartOutput": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\nEncryptStartOutput (void)\n{\n  if (encrypt_mode)\n    {\n      encrypt_start_output (encrypt_mode);\n      return (1);\n    }\n  printf (\"No previous encryption mode, encryption not enabled\\r\\n\");\n  return (0);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "EncryptStop": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nEncryptStop (char *mode)\n{\n  int ret = 0;\n  if (mode)\n    {\n      if (isprefix (mode, \"input\"))\n\treturn (EncryptStopInput ());\n      if (isprefix (mode, \"output\"))\n\treturn (EncryptStopOutput ());\n      if (isprefix (mode, \"help\") || isprefix (mode, \"?\"))\n\t{\n\t  printf (\"Usage: encrypt stop [input|output]\\n\");\n\t  return (0);\n\t}\n      printf (\"%s: invalid encryption mode 'encrypt stop ?' for help\\n\",\n\t      mode);\n      return (0);\n    }\n  ret += EncryptStopInput ();\n  ret += EncryptStopOutput ();\n  return (ret);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "EncryptStopInput": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        420,
        1
      ],
      "content": "int\nEncryptStopInput (void)\n{\n  encrypt_send_request_end ();\n  return (1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "EncryptStopOutput": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "int\nEncryptStopOutput (void)\n{\n  encrypt_send_end ();\n  return (1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "encrypt_display": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "void\nencrypt_display (void)\n{\n  if (encrypt_output)\n    printf (\"Currently encrypting output with %s\\r\\n\",\n\t    ENCTYPE_NAME (encrypt_mode));\n  if (decrypt_input)\n    printf (\"Currently decrypting input with %s\\r\\n\",\n\t    ENCTYPE_NAME (decrypt_mode));\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "EncryptStatus": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "int\nEncryptStatus (void)\n{\n  if (encrypt_output)\n    printf (\"Currently encrypting output with %s\\r\\n\",\n\t    ENCTYPE_NAME (encrypt_mode));\n  else if (encrypt_mode)\n    {\n      printf (\"Currently output is clear text.\\r\\n\");\n      printf (\"Last encryption mode was %s\\r\\n\", ENCTYPE_NAME (encrypt_mode));\n    }\n  if (decrypt_input)\n    printf (\"Currently decrypting input with %s\\r\\n\",\n\t    ENCTYPE_NAME (decrypt_mode));\n  else if (decrypt_mode)\n    {\n      printf (\"Currently input is clear text.\\r\\n\");\n      printf (\"Last decryption mode was %s\\r\\n\", ENCTYPE_NAME (decrypt_mode));\n    }\n  return 1;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "encrypt_send_support": {
      "start_point": [
        462,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "void\nencrypt_send_support (void)\n{\n  if (str_suplen)\n    {\n      /*\n       * If the user has requested that decryption start\n       * immediatly, then send a \"REQUEST START\" before\n       * we negotiate the type.\n       */\n      if (!Server && autodecrypt)\n\tencrypt_send_request_start ();\n      net_write (str_send, str_suplen);\n      printsub ('>', &str_send[2], str_suplen - 2);\n      str_suplen = 0;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "EncryptDebug": {
      "start_point": [
        480,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "int\nEncryptDebug (int on)\n{\n  if (on < 0)\n    encrypt_debug_mode ^= 1;\n  else\n    encrypt_debug_mode = on;\n  printf (\"Encryption debugging %s\\r\\n\",\n\t  encrypt_debug_mode ? \"enabled\" : \"disabled\");\n  return (1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "EncryptVerbose": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "int\nEncryptVerbose (int on)\n{\n  if (on < 0)\n    encrypt_verbose ^= 1;\n  else\n    encrypt_verbose = on;\n  printf (\"Encryption %s verbose\\r\\n\", encrypt_verbose ? \"is\" : \"is not\");\n  return (1);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "EncryptAutoEnc": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "int\nEncryptAutoEnc (int on)\n{\n  encrypt_auto (on);\n  printf (\"Automatic encryption of output is %s\\r\\n\",\n\t  autoencrypt ? \"enabled\" : \"disabled\");\n  return (1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "EncryptAutoDec": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "int\nEncryptAutoDec (int on)\n{\n  decrypt_auto (on);\n  printf (\"Automatic decryption of input is %s\\r\\n\",\n\t  autodecrypt ? \"enabled\" : \"disabled\");\n  return (1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "encrypt_support": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        562,
        1
      ],
      "content": "void\nencrypt_support (unsigned char *typelist, int cnt)\n{\n  int type, use_type = 0;\n  Encryptions *ep;\n\n  /*\n   * Forget anything the other side has previously told us.\n   */\n  remote_supports_decrypt = 0;\n\n  while (cnt-- > 0)\n    {\n      type = *typelist++;\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: He is supporting %s (%d)\\r\\n\",\n\t\tName, ENCTYPE_NAME (type), type);\n      if ((type < ENCTYPE_CNT) && (I_SUPPORT_ENCRYPT & typemask (type)))\n\t{\n\t  remote_supports_decrypt |= typemask (type);\n\t  if (use_type == 0)\n\t    use_type = type;\n\t}\n    }\n  if (use_type)\n    {\n      ep = findencryption (use_type);\n      if (!ep)\n\treturn;\n      type = ep->start ? (*ep->start) (DIR_ENCRYPT, Server) : 0;\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: (*ep->start)() returned %d\\r\\n\", Name, type);\n      if (type < 0)\n\treturn;\n      encrypt_mode = use_type;\n      if (type == 0)\n\tencrypt_start_output (use_type);\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "encrypt_is": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "void\nencrypt_is (unsigned char *data, int cnt)\n{\n  Encryptions *ep;\n  int type, ret;\n\n  if (--cnt < 0)\n    return;\n  type = *data++;\n  if (type < ENCTYPE_CNT)\n    remote_supports_encrypt |= typemask (type);\n\n  ep = finddecryption (type);\n  if (!ep)\n    {\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: Can't find type %s (%d) for initial negotiation\\r\\n\",\n\t\tName,\n\t\tENCTYPE_NAME_OK (type) && ENCTYPE_NAME (type)\n\t\t? ENCTYPE_NAME (type) : \"(unknown)\", type);\n      return;\n    }\n  if (!ep->is)\n    {\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: No initial negotiation needed for type %s (%d)\\r\\n\",\n\t\tName,\n\t\tENCTYPE_NAME_OK (type) && ENCTYPE_NAME (type)\n\t\t? ENCTYPE_NAME (type) : \"(unknown)\", type);\n      ret = 0;\n    }\n  else\n    {\n      ret = (*ep->is) (data, cnt);\n      if (encrypt_debug_mode)\n\tprintf (\"(*ep->is)(%p, %d) returned %s (%d).\\r\\n\",\n\t\tdata, cnt,\n\t\t(ret < 0) ? \"FAIL \"\n\t\t\t  : ((ret == 0) ? \"SUCCESS \" : \"MORE_TO_DO \"),\n\t\tret);\n    }\n  if (ret < 0)\n    autodecrypt = 0;\n  else\n    {\n      decrypt_mode = type;\n      if (ret == 0 && autodecrypt)\n\tencrypt_send_request_start ();\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "encrypt_reply": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "void\nencrypt_reply (unsigned char *data, int cnt)\n{\n  Encryptions *ep;\n  int ret, type;\n\n  if (--cnt < 0)\n    return;\n  type = *data++;\n\n  ep = findencryption (type);\n  if (!ep)\n    {\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: Can't find type %s (%d) for initial negotiation\\r\\n\",\n\t\tName,\n\t\tENCTYPE_NAME_OK (type) && ENCTYPE_NAME (type)\n\t\t? ENCTYPE_NAME (type) : \"(unknown)\", type);\n      return;\n    }\n  if (!ep->reply)\n    {\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: No initial negotiation needed for type %s (%d)\\r\\n\",\n\t\tName,\n\t\tENCTYPE_NAME_OK (type) && ENCTYPE_NAME (type)\n\t\t? ENCTYPE_NAME (type) : \"(unknown)\", type);\n      ret = 0;\n    }\n  else\n    {\n      ret = (*ep->reply) (data, cnt);\n      if (encrypt_debug_mode)\n\tprintf (\"(*ep->reply)(%p, %d) returned %s (%d).\\r\\n\",\n\t\tdata, cnt,\n\t\t(ret < 0) ? \"FAIL \"\n\t\t\t  : ((ret == 0) ? \"SUCCESS \" : \"MORE_TO_DO \"),\n\t\tret);\n    }\n  if (encrypt_debug_mode)\n    printf (\">>>%s: encrypt_reply returned %d\\n\", Name, ret);\n  if (ret < 0)\n    autoencrypt = 0;\n  else\n    {\n      encrypt_mode = type;\n      if (ret == 0 && autoencrypt)\n\tencrypt_start_output (type);\n    }\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "encrypt_start": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "void\nencrypt_start (unsigned char *data _GL_UNUSED_PARAMETER,\n\t       int cnt _GL_UNUSED_PARAMETER)\n{\n  Encryptions *ep;\n\n  if (!decrypt_mode)\n    {\n      /*\n       * Something is wrong.  We should not get a START\n       * command without having already picked our\n       * decryption scheme.  Send a REQUEST-END to\n       * attempt to clear the channel...\n       */\n      printf (\"%s: Warning, Cannot decrypt input stream!!!\\r\\n\", Name);\n      encrypt_send_request_end ();\n      return;\n    }\n\n  ep = finddecryption (decrypt_mode);\n  if (ep)\n    {\n      decrypt_input = ep->input;\n      if (encrypt_verbose)\n\tprintf (\"[ Input is now decrypted with type %s ]\\r\\n\",\n\t\tENCTYPE_NAME (decrypt_mode));\n      if (encrypt_debug_mode)\n\tprintf (\">>>%s: Start to decrypt input with type %s\\r\\n\",\n\t\tName, ENCTYPE_NAME (decrypt_mode));\n    }\n  else\n    {\n      printf (\"%s: Warning, Cannot decrypt type %s (%d)!!!\\r\\n\",\n\t      Name,\n\t      ENCTYPE_NAME_OK (decrypt_mode) && ENCTYPE_NAME (decrypt_mode)\n\t      ? ENCTYPE_NAME (decrypt_mode) : \"(unknown)\", decrypt_mode);\n      encrypt_send_request_end ();\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "encrypt_session_key": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "void\nencrypt_session_key (Session_Key *key, int server)\n{\n  Encryptions *ep = encryptions;\n\n  havesessionkey = 1;\n\n  while (ep->type)\n    {\n      if (ep->session)\n\t(*ep->session) (key, server);\n      ++ep;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "encrypt_end": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "void\nencrypt_end (void)\n{\n  decrypt_input = 0;\n  if (encrypt_debug_mode)\n    printf (\">>>%s: Input is back to clear text\\r\\n\", Name);\n  if (encrypt_verbose)\n    printf (\"[ Input is now clear text ]\\r\\n\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encrypt_request_end": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        744,
        1
      ],
      "content": "void\nencrypt_request_end (void)\n{\n  encrypt_send_end ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "encrypt_request_start": {
      "start_point": [
        752,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "void\nencrypt_request_start (unsigned char *data _GL_UNUSED_PARAMETER,\n\t\t       int cnt _GL_UNUSED_PARAMETER)\n{\n  if (encrypt_mode == 0)\n    {\n      if (Server)\n\tautoencrypt = 1;\n      return;\n    }\n  encrypt_start_output (encrypt_mode);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encrypt_keyid": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        817,
        1
      ],
      "content": "static void\nencrypt_keyid (struct key_info *kp, unsigned char *keyid, int len)\n{\n  Encryptions *ep;\n  int dir = kp->dir;\n  int ret = 0;\n\n  if (len > MAXKEYLEN)\n    len = MAXKEYLEN;\n\n  ep = (*kp->getcrypt) (*kp->modep);\n  if (!ep)\n    {\n      if (len == 0)\n\treturn;\n      kp->keylen = 0;\n    }\n  else if (len == 0)\n    {\n      /*\n       * Empty option, indicates a failure.\n       */\n      if (kp->keylen == 0)\n\treturn;\n      kp->keylen = 0;\n      if (ep->keyid)\n\t(*ep->keyid) (dir, kp->keyid, &kp->keylen);\n\n    }\n  else if ((len != kp->keylen) || (memcmp (keyid, kp->keyid, len) != 0))\n    {\n      /*\n       * Length or contents are different\n       */\n      kp->keylen = len;\n      memmove (kp->keyid, keyid, len);\n      if (ep->keyid)\n\t(*ep->keyid) (dir, kp->keyid, &kp->keylen);\n    }\n  else\n    {\n      if (ep->keyid)\n\tret = (*ep->keyid) (dir, kp->keyid, &kp->keylen);\n      if ((ret == 0) && (dir == DIR_ENCRYPT) && autoencrypt)\n\tencrypt_start_output (*kp->modep);\n      return;\n    }\n\n  encrypt_send_keyid (dir, kp->keyid, kp->keylen, 0);\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encrypt_enc_keyid": {
      "start_point": [
        819,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "void\nencrypt_enc_keyid (unsigned char *keyid, int len)\n{\n  encrypt_keyid (&ki[1], keyid, len);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encrypt_dec_keyid": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "void\nencrypt_dec_keyid (unsigned char *keyid, int len)\n{\n  encrypt_keyid (&ki[0], keyid, len);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "encrypt_send_keyid": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "void\nencrypt_send_keyid (int dir, unsigned char *keyid, int keylen, int saveit)\n{\n  unsigned char *strp;\n\n  str_keyid[3] = (dir == DIR_ENCRYPT) ? ENCRYPT_ENC_KEYID : ENCRYPT_DEC_KEYID;\n  if (saveit)\n    {\n      struct key_info *kp = &ki[(dir == DIR_ENCRYPT) ? 0 : 1];\n      memmove (kp->keyid, keyid, keylen);\n      kp->keylen = keylen;\n    }\n\n  for (strp = &str_keyid[4]; keylen > 0; --keylen)\n    {\n      if ((*strp++ = *keyid++) == IAC)\n\t*strp++ = IAC;\n    }\n  *strp++ = IAC;\n  *strp++ = SE;\n  net_write (str_keyid, strp - str_keyid);\n  printsub ('>', &str_keyid[2], strp - str_keyid - 2);\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "encrypt_auto": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "void\nencrypt_auto (int on)\n{\n  if (on < 0)\n    autoencrypt ^= 1;\n  else\n    autoencrypt = on ? 1 : 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "decrypt_auto": {
      "start_point": [
        864,
        0
      ],
      "end_point": [
        871,
        1
      ],
      "content": "void\ndecrypt_auto (int on)\n{\n  if (on < 0)\n    autodecrypt ^= 1;\n  else\n    autodecrypt = on ? 1 : 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "encrypt_start_output": {
      "start_point": [
        873,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "void\nencrypt_start_output (int type)\n{\n  Encryptions *ep;\n  unsigned char *p;\n  int i;\n\n  ep = findencryption (type);\n  if (!ep)\n    {\n      if (encrypt_debug_mode)\n\t{\n\t  printf (\">>>%s: Can't encrypt with type %s (%d)\\r\\n\",\n\t\t  Name,\n\t\t  ENCTYPE_NAME_OK (type) && ENCTYPE_NAME (type)\n\t\t  ? ENCTYPE_NAME (type) : \"(unknown)\", type);\n\t}\n      return;\n    }\n  if (ep->start)\n    {\n      i = (*ep->start) (DIR_ENCRYPT, Server);\n      if (encrypt_debug_mode)\n\t{\n\t  printf (\">>>%s: Encrypt start: %s (%d) %s\\r\\n\",\n\t\t  Name,\n\t\t  (i < 0) ? \"failed\" :\n\t\t  \"initial negotiation in progress\", i, ENCTYPE_NAME (type));\n\t}\n      if (i)\n\treturn;\n    }\n  p = str_start + 3;\n  *p++ = ENCRYPT_START;\n  for (i = 0; i < ki[0].keylen; ++i)\n    {\n      if ((*p++ = ki[0].keyid[i]) == IAC)\n\t*p++ = IAC;\n    }\n  *p++ = IAC;\n  *p++ = SE;\n  net_write (str_start, p - str_start);\n  net_encrypt ();\n  printsub ('>', &str_start[2], p - &str_start[2]);\n  /*\n   * If we are already encrypting in some mode, then\n   * encrypt the ring (which includes our request) in\n   * the old mode, mark it all as \"clear text\" and then\n   * switch to the new mode.\n   */\n  encrypt_output = ep->output;\n  encrypt_mode = type;\n  if (encrypt_debug_mode)\n    printf (\">>>%s: Started to encrypt output with type %s\\r\\n\",\n\t    Name, ENCTYPE_NAME (type));\n  if (encrypt_verbose)\n    printf (\"[ Output is now encrypted with type %s ]\\r\\n\",\n\t    ENCTYPE_NAME (type));\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "encrypt_send_end": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        952,
        1
      ],
      "content": "void\nencrypt_send_end (void)\n{\n  if (!encrypt_output)\n    return;\n\n  str_end[3] = ENCRYPT_END;\n  net_write (str_end, sizeof (str_end));\n  net_encrypt ();\n  printsub ('>', &str_end[2], sizeof (str_end) - 2);\n  /*\n   * Encrypt the output buffer now because it will not be done by\n   * netflush...\n   */\n  encrypt_output = 0;\n  if (encrypt_debug_mode)\n    printf (\">>>%s: Output is back to clear text\\r\\n\", Name);\n  if (encrypt_verbose)\n    printf (\"[ Output is now clear text ]\\r\\n\");\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "encrypt_send_request_start": {
      "start_point": [
        954,
        0
      ],
      "end_point": [
        973,
        1
      ],
      "content": "void\nencrypt_send_request_start (void)\n{\n  unsigned char *p;\n  int i;\n\n  p = &str_start[3];\n  *p++ = ENCRYPT_REQSTART;\n  for (i = 0; i < ki[1].keylen; ++i)\n    {\n      if ((*p++ = ki[1].keyid[i]) == IAC)\n\t*p++ = IAC;\n    }\n  *p++ = IAC;\n  *p++ = SE;\n  net_write (str_start, p - str_start);\n  printsub ('>', &str_start[2], p - &str_start[2]);\n  if (encrypt_debug_mode)\n    printf (\">>>%s: Request input to be encrypted\\r\\n\", Name);\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "encrypt_send_request_end": {
      "start_point": [
        975,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "void\nencrypt_send_request_end (void)\n{\n  str_end[3] = ENCRYPT_REQEND;\n  net_write (str_end, sizeof (str_end));\n  printsub ('>', &str_end[2], sizeof (str_end) - 2);\n\n  if (encrypt_debug_mode)\n    printf (\">>>%s: Request input to be clear text\\r\\n\", Name);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "encrypt_wait": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "void\nencrypt_wait (void)\n{\n  if (encrypt_debug_mode)\n    printf (\">>>%s: in encrypt_wait\\r\\n\", Name);\n  if (!havesessionkey || !(I_SUPPORT_ENCRYPT & remote_supports_decrypt))\n    return;\n  while (autoencrypt && !encrypt_output)\n    if (telnet_spin ())\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "encrypt_debug": {
      "start_point": [
        998,
        0
      ],
      "end_point": [
        1002,
        1
      ],
      "content": "void\nencrypt_debug (int mode)\n{\n  encrypt_debug_mode = mode;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "encrypt_gen_printsub": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static void\nencrypt_gen_printsub (unsigned char *data, int cnt,\n\t\t      char *buf, int buflen)\n{\n  char tbuf[16], *cp;\n\n  cnt -= 2;\n  data += 2;\n  buf[buflen - 1] = '\\0';\n  buf[buflen - 2] = '*';\n  buflen -= 2;\n  for (; cnt > 0; cnt--, data++)\n    {\n      sprintf (tbuf, \" %d\", *data);\n      for (cp = tbuf; *cp && buflen > 0; --buflen)\n\t*buf++ = *cp++;\n      if (buflen <= 0)\n\treturn;\n    }\n  *buf = '\\0';\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "encrypt_printsub": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "void\nencrypt_printsub (unsigned char *data, int cnt,\n\t\t  char *buf, int buflen)\n{\n  Encryptions *ep;\n  int type = data[1];\n\n  for (ep = encryptions; ep->type && ep->type != type; ep++)\n    ;\n\n  if (ep->printsub)\n    (*ep->printsub) (data, cnt, buf, buflen);\n  else\n    encrypt_gen_printsub (data, cnt, buf, buflen);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/encrypt.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/enc_des.c": {
    "shishi_des_ecb_encrypt": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nshishi_des_ecb_encrypt (Shishi * h, const unsigned char key[sizeof (Block)],\n\t\t\tconst unsigned char *in, unsigned char *out)\n{\n  char *tmp;\n\n  shishi_des (h, 0, (const char *) key, NULL, NULL,\n\t      (const char *) in, sizeof (Block), &tmp);\n  memcpy (out, tmp, sizeof (Block));\n  free (tmp);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfb64_init": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\ncfb64_init (int server)\n{\n  fb64_init (&fb[CFB]);\n  fb[CFB].fb_feed[4] = ENCTYPE_DES_CFB64;\n  fb[CFB].streams[0].str_flagshift = SHIFT_VAL (0, CFB);\n  fb[CFB].streams[1].str_flagshift = SHIFT_VAL (1, CFB);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ofb64_init": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nofb64_init (int server)\n{\n  fb64_init (&fb[OFB]);\n  fb[OFB].fb_feed[4] = ENCTYPE_DES_OFB64;\n  fb[CFB].streams[0].str_flagshift = SHIFT_VAL (0, OFB);\n  fb[CFB].streams[1].str_flagshift = SHIFT_VAL (1, OFB);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fb64_init": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nfb64_init (register struct fb *fbp)\n{\n  memset ((void *) fbp, 0, sizeof (*fbp));\n  fbp->state[0] = fbp->state[1] = FAILED;\n  fbp->fb_feed[0] = IAC;\n  fbp->fb_feed[1] = SB;\n  fbp->fb_feed[2] = TELOPT_ENCRYPT;\n  fbp->fb_feed[3] = ENCRYPT_IS;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfb64_start": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "int\ncfb64_start (int dir, int server)\n{\n  return (fb64_start (&fb[CFB], dir, server));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ofb64_start": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int\nofb64_start (int dir, int server)\n{\n  return (fb64_start (&fb[OFB], dir, server));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fb64_start": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static int\nfb64_start (struct fb *fbp, int dir, int server)\n{\n  size_t x;\n  unsigned char *p;\n  register int state;\n\n  switch (dir)\n    {\n    case DIR_DECRYPT:\n      /*\n       * This is simply a request to have the other side\n       * start output (our input).  He will negotiate an\n       * IV so we need not look for it.\n       */\n      state = fbp->state[dir - 1];\n      if (state == FAILED)\n\tstate = IN_PROGRESS;\n      break;\n\n    case DIR_ENCRYPT:\n      state = fbp->state[dir - 1];\n      if (state == FAILED)\n\tstate = IN_PROGRESS;\n      else if ((state & NO_SEND_IV) == 0)\n\tbreak;\n\n      if (!VALIDKEY (fbp->krbdes_key))\n\t{\n\t  fbp->need_start = 1;\n\t  break;\n\t}\n      state &= ~NO_SEND_IV;\n      state |= NO_RECV_IV;\n      if (encrypt_debug_mode)\n\tprintf (\"Creating new feed\\r\\n\");\n      /*\n       * Create a random feed and send it over.\n       */\n#   ifdef SHISHI\n      if (shishi_randomize (shishi_handle, 0,\n\t\t\t    fbp->temp_feed, sizeof (Block)) != SHISHI_OK)\n\treturn (FAILED);\n\n#   else\n      des_new_random_key (fbp->temp_feed);\n      des_ecb_encrypt (fbp->temp_feed, fbp->temp_feed, fbp->krbdes_sched, 1);\n#   endif\n      p = fbp->fb_feed + 3;\n      *p++ = ENCRYPT_IS;\n      p++;\n      *p++ = FB64_IV;\n      for (x = 0; x < sizeof (Block); ++x)\n\t{\n\t  if ((*p++ = fbp->temp_feed[x]) == IAC)\n\t    *p++ = IAC;\n\t}\n      *p++ = IAC;\n      *p++ = SE;\n      printsub ('>', &fbp->fb_feed[2], p - &fbp->fb_feed[2]);\n      net_write (fbp->fb_feed, p - fbp->fb_feed);\n      break;\n    default:\n      return (FAILED);\n    }\n\n  fbp->state[dir - 1] = state;\n\n  return (state);\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cfb64_is": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "int\ncfb64_is (unsigned char *data, int cnt)\n{\n  return (fb64_is (data, cnt, &fb[CFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ofb64_is": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "int\nofb64_is (unsigned char *data, int cnt)\n{\n  return (fb64_is (data, cnt, &fb[OFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fb64_is": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static int\nfb64_is (unsigned char *data, int cnt, struct fb *fbp)\n{\n  unsigned char *p;\n  register int state = fbp->state[DIR_DECRYPT - 1];\n\n  if (cnt-- < 1)\n    goto failure;\n\n  switch (*data++)\n    {\n    case FB64_IV:\n      if (cnt != sizeof (Block))\n\t{\n\t  if (encrypt_debug_mode)\n\t    printf (\"FB64: initial vector failed on size\\r\\n\");\n\t  state = FAILED;\n\t  goto failure;\n\t}\n\n      if (encrypt_debug_mode)\n\tprintf (\"FB64: initial vector received\\r\\n\");\n\n      if (encrypt_debug_mode)\n\tprintf (\"Initializing Decrypt stream\\r\\n\");\n\n      fb64_stream_iv ((void *) data, &fbp->streams[DIR_DECRYPT - 1]);\n\n      p = fbp->fb_feed + 3;\n      *p++ = ENCRYPT_REPLY;\n      p++;\n      *p++ = FB64_IV_OK;\n      *p++ = IAC;\n      *p++ = SE;\n      printsub ('>', &fbp->fb_feed[2], p - &fbp->fb_feed[2]);\n      net_write (fbp->fb_feed, p - fbp->fb_feed);\n\n      state = fbp->state[DIR_DECRYPT - 1] = IN_PROGRESS;\n      break;\n\n    default:\n      if (encrypt_debug_mode)\n\t{\n\t  printf (\"Unknown option type: %d\\r\\n\", *(data - 1));\n\t  printd (data, cnt);\n\t  printf (\"\\r\\n\");\n\t}\n      /* FALL THROUGH */\n    failure:\n      /*\n       * We failed.  Send an FB64_IV_BAD option\n       * to the other side so it will know that\n       * things failed.\n       */\n      p = fbp->fb_feed + 3;\n      *p++ = ENCRYPT_REPLY;\n      p++;\n      *p++ = FB64_IV_BAD;\n      *p++ = IAC;\n      *p++ = SE;\n      printsub ('>', &fbp->fb_feed[2], p - &fbp->fb_feed[2]);\n      net_write (fbp->fb_feed, p - fbp->fb_feed);\n\n      break;\n    }\n\n  fbp->state[DIR_DECRYPT - 1] = state;\n\n  return (state);\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cfb64_reply": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "int\ncfb64_reply (unsigned char *data, int cnt)\n{\n  return (fb64_reply (data, cnt, &fb[CFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ofb64_reply": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "int\nofb64_reply (unsigned char *data, int cnt)\n{\n  return (fb64_reply (data, cnt, &fb[OFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fb64_reply": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static int\nfb64_reply (unsigned char *data, int cnt, struct fb *fbp)\n{\n  register int state = fbp->state[DIR_ENCRYPT - 1];\n\n  if (cnt-- < 1)\n    goto failure;\n\n  switch (*data++)\n    {\n    case FB64_IV_OK:\n      fb64_stream_iv (fbp->temp_feed, &fbp->streams[DIR_ENCRYPT - 1]);\n      if (state == FAILED)\n\tstate = IN_PROGRESS;\n      state &= ~NO_RECV_IV;\n      encrypt_send_keyid (DIR_ENCRYPT, (unsigned char *) \"\\0\", 1, 1);\n      break;\n\n    case FB64_IV_BAD:\n      memset (fbp->temp_feed, 0, sizeof (Block));\n      fb64_stream_iv (fbp->temp_feed, &fbp->streams[DIR_ENCRYPT - 1]);\n      state = FAILED;\n      break;\n\n    default:\n      if (encrypt_debug_mode)\n\t{\n\t  printf (\"Unknown option type: %d\\r\\n\", data[-1]);\n\t  printd (data, cnt);\n\t  printf (\"\\r\\n\");\n\t}\n      /* FALL THROUGH */\n    failure:\n      state = FAILED;\n      break;\n    }\n\n  fbp->state[DIR_ENCRYPT - 1] = state;\n\n  return (state);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cfb64_session": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void\ncfb64_session (Session_Key *key, int server)\n{\n  fb64_session (key, server, &fb[CFB]);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ofb64_session": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "void\nofb64_session (Session_Key *key, int server)\n{\n  fb64_session (key, server, &fb[OFB]);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fb64_session": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        531,
        1
      ],
      "content": "static void\nfb64_session (Session_Key *key, int server, struct fb *fbp)\n{\n  size_t offset;\n  unsigned char *derived_key;\n\n  if (!key || key->type != SK_DES)\n    {\n      /* FIXME: Support RFC 2952 approach instead of giving up here. */\n      if (encrypt_debug_mode)\n\tprintf (\"Received non-DES session key (%d != %d)\\r\\n\",\n\t\tkey ? key->type : -1, SK_DES);\n      if (!key)\n\treturn;\t/* XXX: Causes a segfault, since *key is NULL.  */\n\n      /* Follow RFC 2952 in using the authentication key\n       * to derived one or more DES-keys, after adjusting\n       * the parity in each eight byte block.\n       */\n    }\n\n  /* Make a copy of the authentication key,\n   * since the parity might need mending.  */\n  derived_key = malloc (key->length);\n  if (!derived_key)\n    return;\t/* Still destructive, but no alternate method in sight.  */\n\n  memmove ((void *) derived_key, (void *) key->data, key->length);\n\n  /* Check parity of each DES block, correct it whenever needed.  */\n  for (offset = 0; offset < (size_t) key->length; offset += sizeof (Block))\n    (void) des_set_parity (derived_key + offset);\n\n  /* XXX: A single key block is in use for now,\n   *      but all block are of correct parity.\n   *      krbdes_key should be an array of block,\n   *      which each encryption method may use at\n   *      it own discretion.  This is the content\n   *      if RFC 2946 and 2952, etcetera.\n   */\n  memmove ((void *) fbp->krbdes_key, (void *) derived_key, sizeof (Block));\n\n  /* XXX: These should at least be split according\n   *      to direction and role, i.e., client or server.\n   */\n  fb64_stream_key (fbp->krbdes_key, &fbp->streams[DIR_ENCRYPT - 1]);\n  fb64_stream_key (fbp->krbdes_key, &fbp->streams[DIR_DECRYPT - 1]);\n\n  /* Erase sensitive key material.  */\n  memset (derived_key, 0, key->length);\n\n  if (fbp->once == 0)\n    {\n#   ifndef SHISHI\n      des_set_random_generator_seed (fbp->krbdes_key);\n#   endif\n      fbp->once = 1;\n    }\n#   ifndef SHISHI\n  des_key_sched (fbp->krbdes_key, fbp->krbdes_sched);\n#   endif\n  /*\n   * Now look to see if krbdes_start() was waiting for\n   * the key to show up.  If so, go ahead and call it now\n   * that we have the key.\n   */\n  if (fbp->need_start)\n    {\n      fbp->need_start = 0;\n      fb64_start (fbp, DIR_ENCRYPT, server);\n    }\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfb64_keyid": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "int\ncfb64_keyid (int dir, unsigned char *kp, int *lenp)\n{\n  return (fb64_keyid (dir, kp, lenp, &fb[CFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ofb64_keyid": {
      "start_point": [
        544,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "int\nofb64_keyid (int dir, unsigned char *kp, int *lenp)\n{\n  return (fb64_keyid (dir, kp, lenp, &fb[OFB]));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fb64_keyid": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "static int\nfb64_keyid (int dir, unsigned char *kp, int *lenp, struct fb *fbp)\n{\n  register int state = fbp->state[dir - 1];\n\n  if (*lenp != 1 || (*kp != '\\0'))\n    {\n      *lenp = 0;\n      return (state);\n    }\n\n  if (state == FAILED)\n    state = IN_PROGRESS;\n\n  state &= ~NO_KEYID;\n\n  fbp->state[dir - 1] = state;\n\n  return (state);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fb64_printsub": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static void\nfb64_printsub (unsigned char *data, int cnt,\n\t       char *buf, int buflen,\n\t       const char *type)\n{\n  char lbuf[32];\n  register int i;\n  char *cp;\n\n  buf[buflen - 1] = '\\0';\t/* make sure it's NULL terminated */\n  buflen -= 1;\n\n  switch (data[2])\n    {\n    case FB64_IV:\n      sprintf (lbuf, \"%s_IV\", type);\n      cp = lbuf;\n      goto common;\n\n    case FB64_IV_OK:\n      sprintf (lbuf, \"%s_IV_OK\", type);\n      cp = lbuf;\n      goto common;\n\n    case FB64_IV_BAD:\n      sprintf (lbuf, \"%s_IV_BAD\", type);\n      cp = lbuf;\n      goto common;\n\n    default:\n      sprintf (lbuf, \" %d (unknown)\", data[2]);\n      cp = lbuf;\n    common:\n      for (; (buflen > 0) && (*buf = *cp++); buf++)\n\tbuflen--;\n      for (i = 3; i < cnt; i++)\n\t{\n\t  sprintf (lbuf, \" %d\", data[i]);\n\t  for (cp = lbuf; (buflen > 0) && (*buf = *cp++); buf++)\n\t    buflen--;\n\t}\n      break;\n    }\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfb64_printsub": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "void\ncfb64_printsub (unsigned char *data, int cnt,\n\t\tchar *buf, int buflen)\n{\n  fb64_printsub (data, cnt, buf, buflen, \"CFB64\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ofb64_printsub": {
      "start_point": [
        625,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "void\nofb64_printsub (unsigned char *data, int cnt,\n\t\tchar *buf, int buflen)\n{\n  fb64_printsub (data, cnt, buf, buflen, \"OFB64\");\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "fb64_stream_iv": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "static void\nfb64_stream_iv (Block seed, register struct stinfo *stp)\n{\n\n  memmove ((void *) stp->str_iv, (void *) seed, sizeof (Block));\n  memmove ((void *) stp->str_output, (void *) seed, sizeof (Block));\n\n#   ifndef SHISHI\n  des_key_sched (stp->str_ikey, stp->str_sched);\n#   endif\n\n  stp->str_index = sizeof (Block);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fb64_stream_key": {
      "start_point": [
        647,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "static void\nfb64_stream_key (Block key, register struct stinfo *stp)\n{\n  memmove ((void *) stp->str_ikey, (void *) key, sizeof (Block));\n#   ifndef SHISHI\n  des_key_sched (key, stp->str_sched);\n#   endif\n  memmove ((void *) stp->str_output, (void *) stp->str_iv, sizeof (Block));\n\n  stp->str_index = sizeof (Block);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfb64_encrypt": {
      "start_point": [
        681,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "void\ncfb64_encrypt (register unsigned char *s, int c)\n{\n  register struct stinfo *stp = &fb[CFB].streams[DIR_ENCRYPT - 1];\n  register int index;\n\n  index = stp->str_index;\n  while (c-- > 0)\n    {\n      if (index == sizeof (Block))\n\t{\n\t  Block b;\n#   ifdef SHISHI\n\t  shishi_des_ecb_encrypt (shishi_handle, fb[CFB].krbdes_key,\n\t\t\t\t  stp->str_output, b);\n#   else\n\t  des_ecb_encrypt (stp->str_output, b, stp->str_sched, 1);\n#   endif\n\t  memmove ((void *) stp->str_feed, (void *) b, sizeof (Block));\n\t  index = 0;\n\t}\n\n      /* On encryption, we store (feed ^ data) which is cypher */\n      *s = stp->str_output[index] = (stp->str_feed[index] ^ *s);\n      s++;\n      index++;\n    }\n  stp->str_index = index;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "cfb64_decrypt": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "int\ncfb64_decrypt (int data)\n{\n  register struct stinfo *stp = &fb[CFB].streams[DIR_DECRYPT - 1];\n  int index;\n\n  if (data == -1)\n    {\n      /*\n       * Back up one byte.  It is assumed that we will\n       * never back up more than one byte.  If we do, this\n       * may or may not work.\n       */\n      if (stp->str_index)\n\t--stp->str_index;\n      return (0);\n    }\n\n  index = stp->str_index++;\n  if (index == sizeof (Block))\n    {\n      Block b;\n#   ifdef SHISHI\n      shishi_des_ecb_encrypt (shishi_handle, fb[CFB].krbdes_key,\n\t\t\t      stp->str_output, b);\n#   else\n      des_ecb_encrypt (stp->str_output, b, stp->str_sched, 1);\n#   endif\n      memmove ((void *) stp->str_feed, (void *) b, sizeof (Block));\n      stp->str_index = 1;\t/* Next time will be 1 */\n      index = 0;\t\t/* But now use 0 */\n    }\n\n  /* On decryption we store (data) which is cypher. */\n  stp->str_output[index] = data;\n\n  return (data ^ stp->str_feed[index]);\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "ofb64_encrypt": {
      "start_point": [
        770,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "void\nofb64_encrypt (register unsigned char *s, int c)\n{\n  register struct stinfo *stp = &fb[OFB].streams[DIR_ENCRYPT - 1];\n  register int index;\n\n  index = stp->str_index;\n  while (c-- > 0)\n    {\n      if (index == sizeof (Block))\n\t{\n\t  Block b;\n#    ifdef SHISHI\n\t  shishi_des_ecb_encrypt (shishi_handle, fb[OFB].krbdes_key,\n\t\t\t\t  stp->str_feed, b);\n#    else\n\t  des_ecb_encrypt (stp->str_feed, b, stp->str_sched, 1);\n#    endif\n\t  memmove ((void *) stp->str_feed, (void *) b, sizeof (Block));\n\t  index = 0;\n\t}\n      *s++ ^= stp->str_feed[index];\n      index++;\n    }\n  stp->str_index = index;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "ofb64_decrypt": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        831,
        1
      ],
      "content": "int\nofb64_decrypt (int data)\n{\n  register struct stinfo *stp = &fb[OFB].streams[DIR_DECRYPT - 1];\n  int index;\n\n  if (data == -1)\n    {\n      /*\n       * Back up one byte.  It is assumed that we will\n       * never back up more than one byte.  If we do, this\n       * may or may not work.\n       */\n      if (stp->str_index)\n\t--stp->str_index;\n      return (0);\n    }\n\n  index = stp->str_index++;\n  if (index == sizeof (Block))\n    {\n      Block b;\n#    ifdef SHISHI\n      shishi_des_ecb_encrypt (shishi_handle, fb[OFB].krbdes_key,\n\t\t\t      stp->str_feed, b);\n#    else\n      des_ecb_encrypt (stp->str_feed, b, stp->str_sched, 1);\n#    endif\n      memmove ((void *) stp->str_feed, (void *) b, sizeof (Block));\n      stp->str_index = 1;\t/* Next time will be 1 */\n      index = 0;\t\t/* But now use 0 */\n    }\n\n  return (data ^ stp->str_feed[index]);\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "des_parity": {
      "start_point": [
        834,
        0
      ],
      "end_point": [
        858,
        1
      ],
      "content": "static int\ndes_parity (Block b, int adjust)\n{\n  size_t index;\n  int adj = 0;\n\n  for (index = 0; index < sizeof (Block); index++)\n    {\n      unsigned char c = b[index];\n\n      c ^= (c >> 4);\n      c ^= (c >> 2);\n      c ^= (c >> 1);\n\n      if (!(c & 1))\n\t{\n\t  /* Even parity.  */\n\t  adj++;\n\t  if (adjust)\n\t    *(&b[index]) ^= 0x01;\n\t}\n    }\n\n  return adj;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "des_check_parity": {
      "start_point": [
        866,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "static int\ndes_check_parity (Block b)\n{\n  return des_parity (b, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "des_set_parity": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "static int\ndes_set_parity (Block b)\n{\n  return des_parity (b, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/forward.c": {},
  "inetutils/inetutils-1.9.4/libtelnet/genget.c": {
    "isprefix": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nisprefix (register char *s1, register char *s2)\n{\n  char *os1;\n  register char c1, c2;\n\n  if (*s1 == '\\0')\n    return (-1);\n  os1 = s1;\n  c1 = *s1;\n  c2 = *s2;\n  while (LOWER (c1) == LOWER (c2))\n    {\n      if (c1 == '\\0')\n\tbreak;\n      c1 = *++s1;\n      c2 = *++s2;\n    }\n  return (*s1 ? 0 : (*s2 ? (s1 - os1) : (os1 - s1)));\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "genget": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "char **\ngenget (char *name, char **table, int stlen)\n{\n  register char **c, **found;\n  register int n;\n\n  if (name == 0)\n    return 0;\n\n  found = 0;\n  for (c = table; *c != 0; c = (char **) ((char *) c + stlen))\n    {\n      if ((n = isprefix (name, *c)) == 0)\n\tcontinue;\n      if (n < 0)\t\t/* exact match */\n\treturn (c);\n      if (found)\n\treturn (&ambiguous);\n      found = c;\n    }\n  return (found);\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "char",
        "**\ngenget (char *name, char **table, int stlen)",
        "*",
        "*\ngenget (char *name, char **table, int stlen)",
        "*"
      ]
    },
    "Ambiguous": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nAmbiguous (char *s)\n{\n  return ((char **) s == &ambiguous);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/genget.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/kerberos.c": {},
  "inetutils/inetutils-1.9.4/libtelnet/kerberos5.c": {
    "Data": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\nData (TN_Authenticator * ap, int type, krb5_pointer d, int c)\n{\n  unsigned char *p = str_data + 4;\n  unsigned char *cd = (unsigned char *) d;\n\n  if (c == -1)\n    c = strlen ((char *) cd);\n\n  if (auth_debug_mode)\n    {\n      printf (\"%s:%d: [%d] (%d)\",\n\t      str_data[3] == TELQUAL_IS ? \">>>IS\" : \">>>REPLY\",\n\t      str_data[3], type, c);\n      printd (d, c);\n      printf (\"\\r\\n\");\n    }\n\n  *p++ = ap->type;\n  *p++ = ap->way;\n  *p++ = type;\n\n  while (c-- > 0)\n    {\n      if ((*p++ = *cd++) == IAC)\n\t*p++ = IAC;\n    }\n  *p++ = IAC;\n  *p++ = SE;\n  if (str_data[3] == TELQUAL_IS)\n    printsub ('>', &str_data[2], p - &str_data[2]);\n  return (net_write (str_data, p - str_data));\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "kerberos5_init": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nkerberos5_init (TN_Authenticator * ap _GL_UNUSED_PARAMETER, int server)\n{\n  str_data[3] = server ? TELQUAL_REPLY : TELQUAL_IS;\n  if (telnet_context == 0 && krb5_init_context (&telnet_context))\n    return 0;\n  return 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "kerberos5_cleanup": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\nkerberos5_cleanup ()\n{\n  krb5_ccache ccache;\n  char *ccname;\n\n  if (telnet_context == 0)\n    return;\n\n  ccname = getenv (KRB5_ENV_CCNAME);\n  if (ccname)\n    {\n      if (!krb5_cc_resolve (telnet_context, ccname, &ccache))\n\tkrb5_cc_destroy (telnet_context, ccache);\n    }\n\n  krb5_free_context (telnet_context);\n  telnet_context = 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "encryption_init": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void\nencryption_init (krb5_creds * creds)\n{\n  krb5_keyblock *newkey = 0;\n\n  krb5_auth_con_getsendsubkey (telnet_context, auth_context, &newkey);\n  if (session_key)\n    {\n      krb5_free_keyblock (telnet_context, session_key);\n      session_key = 0;\n    }\n\n  if (newkey)\n    {\n      switch (newkey->enctype)\n\t{\n\tcase ENCTYPE_DES_CBC_CRC:\n\tcase ENCTYPE_DES_CBC_MD5:\n\t  krb5_copy_keyblock (telnet_context, newkey, &session_key);\n\t  break;\n\n\tdefault:\n\t  switch (creds->keyblock.enctype)\n\t    {\n\t    case ENCTYPE_DES_CBC_CRC:\n\t    case ENCTYPE_DES_CBC_MD5:\n\t      krb5_copy_keyblock (telnet_context, &creds->keyblock,\n\t\t\t\t  &session_key);\n\t      break;\n\n\t    default:\n\t      DEBUG ((\"can't determine which keyblock to use\"));\n\t      /*FIXME: abort? */\n\t    }\n\t}\n\n      krb5_free_keyblock (telnet_context, newkey);\n    }\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "kerberos5_send": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int\nkerberos5_send (TN_Authenticator * ap)\n{\n  krb5_error_code r;\n  krb5_ccache ccache;\n  krb5_creds creds;\n  krb5_creds *new_creds = 0;\n  int ap_opts;\n  char type_check[2];\n  krb5_data check_data;\n\n  if (!UserNameRequested)\n    {\n      DEBUG ((\"telnet: Kerberos V5: no user name supplied\\r\\n\"));\n      return 0;\n    }\n\n  if ((r = krb5_cc_default (telnet_context, &ccache)))\n    {\n      DEBUG ((\"telnet: Kerberos V5: could not get default ccache\\r\\n\"));\n      return 0;\n    }\n\n  memset (&creds, 0, sizeof (creds));\n  if ((r = krb5_sname_to_principal (telnet_context, RemoteHostName,\n\t\t\t\t    \"host\", KRB5_NT_SRV_HST, &creds.server)))\n    {\n      DEBUG ((\"telnet: Kerberos V5: error while constructing service name: %s\\r\\n\", error_message (r)));\n      return 0;\n    }\n\n  if (dest_realm)\n    {\n      krb5_data rdata;\n\n      rdata.length = strlen (dest_realm);\n      rdata.data = malloc (rdata.length + 1);\n      if (rdata.data == NULL)\n\t{\n\t  DEBUG ((\"telnet: Kerberos V5: could not allocate memory\\r\\n\"));\n\t  return 0;\n\t}\n      strcpy (rdata.data, dest_realm);\n      krb5_princ_set_realm (telnet_context, creds.server, &rdata);\n    }\n\n  if ((r = krb5_cc_get_principal (telnet_context, ccache, &creds.client)))\n    {\n      DEBUG ((\"telnet: Kerberos V5: failure on principal (%s)\\r\\n\",\n\t      error_message (r)));\n      krb5_free_cred_contents (telnet_context, &creds);\n      return 0;\n    }\n\n  creds.keyblock.enctype = ENCTYPE_DES_CBC_CRC;\n  if ((r = krb5_get_credentials (telnet_context, 0,\n\t\t\t\t ccache, &creds, &new_creds)))\n    {\n      DEBUG ((\"telnet: Kerberos V5: failure on credentials(%s)\\r\\n\",\n\t      error_message (r)));\n      krb5_free_cred_contents (telnet_context, &creds);\n      return 0;\n    }\n\n  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n    ap_opts = AP_OPTS_MUTUAL_REQUIRED;\n  else\n    ap_opts = 0;\n\n# ifdef ENCRYPTION\n  ap_opts |= AP_OPTS_USE_SUBKEY;\n# endif\n\n  if (auth_context)\n    {\n      krb5_auth_con_free (telnet_context, auth_context);\n      auth_context = 0;\n    }\n\n  if ((r = krb5_auth_con_init (telnet_context, &auth_context)))\n    {\n      DEBUG ((\"Kerberos V5: failed to init auth_context (%s)\\r\\n\",\n\t      error_message (r)));\n      return 0;\n    }\n\n  krb5_auth_con_setflags (telnet_context, auth_context,\n\t\t\t  KRB5_AUTH_CONTEXT_RET_TIME);\n\n  type_check[0] = ap->type;\n  type_check[1] = ap->way;\n  check_data.magic = KV5M_DATA;\n  check_data.length = 2;\n  check_data.data = (char *) &type_check;\n\n  r = krb5_mk_req_extended (telnet_context, &auth_context, ap_opts,\n\t\t\t    &check_data, new_creds, &auth);\n\n  encryption_init (new_creds);\n\n  krb5_free_cred_contents (telnet_context, &creds);\n  krb5_free_creds (telnet_context, new_creds);\n  if (r)\n    {\n      DEBUG ((\"telnet: Kerberos V5: mk_req failed (%s)\\r\\n\",\n\t      error_message (r)));\n      return 0;\n    }\n\n  if (!auth_sendname (UserNameRequested, strlen (UserNameRequested)))\n    {\n      DEBUG ((\"telnet: Not enough room for user name\\r\\n\"));\n      return 0;\n    }\n\n  if (!Data (ap, KRB_AUTH, auth.data, auth.length))\n    {\n      DEBUG ((\"telnet: Not enough room for authentication data\\r\\n\"));\n      return 0;\n    }\n\n  DEBUG ((\"telnet: Sent Kerberos V5 credentials to server\\r\\n\"));\n\n  return 1;\n}",
      "lines": 125,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "telnet_encrypt_key": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "void\ntelnet_encrypt_key (Session_Key * skey)\n{\n  if (session_key)\n    {\n      skey->type = SK_DES;\n      skey->length = 8;\n      skey->data = session_key->contents;\n      encrypt_session_key (skey, 0);\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "kerberos5_reply": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        426,
        1
      ],
      "content": "void\nkerberos5_reply (TN_Authenticator * ap, unsigned char *data, int cnt)\n{\n# ifdef ENCRYPTION\n  Session_Key skey;\n# endif\n  static int mutual_complete = 0;\n\n  if (cnt-- < 1)\n    return;\n\n  switch (*data++)\n    {\n    case KRB_REJECT:\n      if (cnt > 0)\n\tprintf (\"[ Kerberos V5 refuses authentication because %.*s ]\\r\\n\",\n\t\tcnt, data);\n      else\n\tprintf (\"[ Kerberos V5 refuses authentication ]\\r\\n\");\n      auth_send_retry ();\n      return;\n\n    case KRB_ACCEPT:\n      if (!mutual_complete)\n\t{\n\t  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t    {\n\t      printf\n\t\t(\"[ Kerberos V5 accepted you, but didn't provide mutual authentication! ]\\r\\n\");\n\t      auth_send_retry ();\n\t      break;\n\t    }\n\t  telnet_encrypt_key (&skey);\n\t}\n\n      if (cnt)\n\tprintf (\"[ Kerberos V5 accepts you as ``%.*s''%s ]\\r\\n\", cnt, data,\n\t\tmutual_complete ?\n\t\t\" (server authenticated)\" : \" (server NOT authenticated)\");\n      else\n\tprintf (\"[ Kerberos V5 accepts you ]\\r\\n\");\n      auth_finished (ap, AUTH_USER);\n# ifdef  FORWARD\n      if (forward_flags & OPTS_FORWARD_CREDS)\n\tkerberos5_forward (ap);\n# endif\n      break;\n\n    case KRB_RESPONSE:\n      if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t{\n\t  krb5_ap_rep_enc_part *reply;\n\t  krb5_data inbuf;\n\t  krb5_error_code r;\n\n\t  inbuf.length = cnt;\n\t  inbuf.data = (char *) data;\n\n\t  if ((r = krb5_rd_rep (telnet_context, auth_context, &inbuf,\n\t\t\t\t&reply)))\n\t    {\n\t      printf (\"[ Mutual authentication failed: %s ]\\r\\n\",\n\t\t      error_message (r));\n\t      auth_send_retry ();\n\t      break;\n\t    }\n\n\t  krb5_free_ap_rep_enc_part (telnet_context, reply);\n\t  telnet_encrypt_key (&skey);\n\t  mutual_complete = 1;\n\t}\n      break;\n\n# ifdef  FORWARD\n    case KRB_FORWARD_ACCEPT:\n      printf (\"[ Kerberos V5 accepted forwarded credentials ]\\r\\n\");\n      break;\n\n    case KRB_FORWARD_REJECT:\n      printf\n\t(\"[ Kerberos V5 refuses forwarded credentials because %.*s ]\\r\\n\",\n\t cnt, data);\n      break;\n# endif\t/* FORWARD */\n\n    default:\n      DEBUG ((\"Unknown Kerberos option %d\\r\\n\", data[-1]));\n    }\n}",
      "lines": 89,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "kerberos5_status": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "int\nkerberos5_status (TN_Authenticator * ap _GL_UNUSED_PARAMETER,\n\t\t  char *name, size_t len, int level)\n{\n  if (level < AUTH_USER)\n    return level;\n\n  if (UserNameRequested\n      && krb5_kuserok (telnet_context, ticket->enc_part2->client,\n\t\t       UserNameRequested))\n    {\n      /* FIXME: Check buffer length */\n      strncpy (name, UserNameRequested, len);\n      return AUTH_VALID;\n    }\n  return AUTH_USER;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "kerberos5_is_auth": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        639,
        1
      ],
      "content": "static int\nkerberos5_is_auth (TN_Authenticator * ap, unsigned char *data, int cnt,\n\t\t   char *errbuf, int errbuflen)\n{\n  int r = 0;\n  krb5_keytab keytabid = 0;\n  krb5_authenticator *authenticator;\n  char *name;\n  krb5_data outbuf;\n  krb5_keyblock *newkey = NULL;\n  krb5_principal server;\n\n# ifdef ENCRYPTION\n  Session_Key skey;\n# endif\n\n  auth.data = (char *) data;\n  auth.length = cnt;\n\n  if (!r && !auth_context)\n    r = krb5_auth_con_init (telnet_context, &auth_context);\n  if (!r)\n    {\n      krb5_rcache rcache;\n\n      r = krb5_auth_con_getrcache (telnet_context, auth_context, &rcache);\n      if (!r && !rcache)\n\t{\n\t  r = krb5_sname_to_principal (telnet_context, 0, 0,\n\t\t\t\t       KRB5_NT_SRV_HST, &server);\n\t  if (!r)\n\t    {\n\t      r = krb5_get_server_rcache (telnet_context,\n\t\t\t\t\t  krb5_princ_component\n\t\t\t\t\t  (telnet_context, server, 0),\n\t\t\t\t\t  &rcache);\n\t      krb5_free_principal (telnet_context, server);\n\t    }\n\t}\n      if (!r)\n\tr = krb5_auth_con_setrcache (telnet_context, auth_context, rcache);\n    }\n\n  if (!r && telnet_srvtab)\n    r = krb5_kt_resolve (telnet_context, telnet_srvtab, &keytabid);\n  if (!r)\n    r = krb5_rd_req (telnet_context, &auth_context, &auth,\n\t\t     NULL, keytabid, NULL, &ticket);\n  if (r)\n    {\n      snprintf (errbuf, errbuflen, \"krb5_rd_req failed: %s\",\n\t\terror_message (r));\n      return r;\n    }\n\n  /* 256 bytes should be much larger than any reasonable\n     first component of a service name especially since\n     the default is of length 4. */\n  if (krb5_princ_component (telnet_context, ticket->server, 0)->length < 256)\n    {\n      char princ[256];\n      strncpy (princ,\n\t       krb5_princ_component (telnet_context, ticket->server, 0)->data,\n\t       krb5_princ_component (telnet_context, ticket->server,\n\t\t\t\t     0)->length);\n      princ[krb5_princ_component (telnet_context, ticket->server, 0)->\n\t    length] = '\\0';\n      if (strcmp (\"host\", princ))\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"incorrect service name: \\\"%s\\\" != \\\"host\\\"\", princ);\n\t  return 1;\n\t}\n    }\n  else\n    {\n      strncpy (errbuf, \"service name too long\", errbuflen);\n      return 1;\n    }\n\n  r = krb5_auth_con_getauthenticator (telnet_context,\n\t\t\t\t      auth_context, &authenticator);\n  if (r)\n    {\n      snprintf (errbuf, errbuflen,\n\t\t\"krb5_auth_con_getauthenticator failed: %s\",\n\t\terror_message (r));\n      return 1;\n    }\n\n# ifdef AUTH_ENCRYPT_MASK\n  if ((ap->way & AUTH_ENCRYPT_MASK) == AUTH_ENCRYPT_ON\n      && !authenticator->checksum)\n    {\n      snprintf (errbuf, errbuflen,\n\t\t\"authenticator is missing required checksum\");\n      return 1;\n    }\n# endif\n\n  if (authenticator->checksum)\n    {\n      char type_check[2];\n      krb5_checksum *cksum = authenticator->checksum;\n      krb5_keyblock *key;\n      krb5_boolean valid;\n\n      type_check[0] = ap->type;\n      type_check[1] = ap->way;\n\n      r = krb5_auth_con_getkey (telnet_context, auth_context, &key);\n      if (r)\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"krb5_auth_con_getkey failed: %s\", error_message (r));\n\t  return 1;\n\t}\n\n#  if 1\n      /* XXX: Obsolete interface.  Remove after investigation.  */\n      r = krb5_verify_checksum (telnet_context,\n\t\t\t\tcksum->checksum_type, cksum,\n\t\t\t\t&type_check, 2, key->contents, key->length);\n      krb5_free_keyblock (telnet_context, key);\n\n      if (r)\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"checksum verification failed: %s\", error_message (r));\n\t  return 1;\n\t}\n#else\n      /* Incomplete call!\n       *\n       * XXX: Establish replacement for the preceding call.\n       *      It is no longer present in all implementations.\n       */\n      r = krb5_c_verify_checksum (telnet_context, key,\n\t\t\t\t  /* usage */, /* data */,\n\t\t\t\t  cksum, &valid);\n      krb5_free_keyblock (telnet_context, key);\n\n      if (r || !valid)\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"checksum verification failed: %s\", error_message (r));\n\t  return 1;\n\t}\n#endif\n    }\n\n  krb5_free_authenticator (telnet_context, authenticator);\n  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n    {\n      if ((r = krb5_mk_rep (telnet_context, auth_context, &outbuf)))\n\t{\n\t  snprintf (errbuf, errbuflen, \"Make reply failed: %s\",\n\t\t    error_message (r));\n\t  return 1;\n\t}\n\n      Data (ap, KRB_RESPONSE, outbuf.data, outbuf.length);\n    }\n\n  if (krb5_unparse_name (telnet_context, ticket->enc_part2->client, &name))\n    name = 0;\n\n  Data (ap, KRB_ACCEPT, name, name ? -1 : 0);\n  DEBUG ((\"telnetd: Kerberos5 identifies him as ``%s''\\r\\n\",\n\t  name ? name : \"\"));\n  auth_finished (ap, AUTH_USER);\n\n  free (name);\n  krb5_auth_con_getrecvsubkey (telnet_context, auth_context, &newkey);\n\n  if (session_key)\n    {\n      krb5_free_keyblock (telnet_context, session_key);\n      session_key = 0;\n    }\n\n  if (newkey)\n    {\n      krb5_copy_keyblock (telnet_context, newkey, &session_key);\n      krb5_free_keyblock (telnet_context, newkey);\n    }\n  else\n    {\n      krb5_copy_keyblock (telnet_context, ticket->enc_part2->session,\n\t\t\t  &session_key);\n    }\n  telnet_encrypt_key (&skey);\n  return 0;\n}",
      "lines": 194,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "kerberos5_is_forward": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        668,
        1
      ],
      "content": "static int\nkerberos5_is_forward (TN_Authenticator * ap, unsigned char *data, int cnt,\n\t\t      char *errbuf, int errbuflen)\n{\n  int r = 0;\n  krb5_data inbuf;\n\n  inbuf.length = cnt;\n  inbuf.data = (char *) data;\n  if ((r = krb5_auth_con_genaddrs (telnet_context, auth_context,\n\t\t\t\t   net,\n\t\t\t\t   KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR))\n      || (r = rd_and_store_for_creds (telnet_context, auth_context,\n\t\t\t\t      &inbuf, ticket)))\n    {\n      snprintf (errbuf, errbuflen, \"Read forwarded creds failed: %s\",\n\t\terror_message (r));\n      Data (ap, KRB_FORWARD_REJECT, errbuf, -1);\n      DEBUG ((\"Could not read forwarded credentials\\r\\n\"));\n    }\n  else\n    {\n      Data (ap, KRB_FORWARD_ACCEPT, 0, 0);\n      DEBUG ((\"Forwarded credentials obtained\\r\\n\"));\n    }\n  return r;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "kerberos5_is": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "void\nkerberos5_is (TN_Authenticator * ap, unsigned char *data, int cnt)\n{\n  int r = 0;\n  char errbuf[512];\n\n  if (cnt-- < 1)\n    return;\n  errbuf[0] = 0;\n  switch (*data++)\n    {\n    case KRB_AUTH:\n      r = kerberos5_is_auth (ap, data, cnt, errbuf, sizeof errbuf);\n      break;\n\n    case KRB_FORWARD:\n      r = kerberos5_is_forward (ap, data, cnt, errbuf, sizeof errbuf);\n      break;\n\n    default:\n      DEBUG ((\"Unknown Kerberos option %d\\r\\n\", data[-1]));\n      Data (ap, KRB_REJECT, 0, 0);\n      break;\n    }\n\n  if (r)\n    {\n      if (!errbuf[0])\n\tsnprintf (errbuf, sizeof errbuf,\n\t\t  \"kerberos_is: %s\", error_message (r));\n      Data (ap, KRB_REJECT, errbuf, -1);\n      DEBUG ((\"%s\\r\\n\", errbuf));\n      syslog (LOG_ERR, \"%s\", errbuf);\n      if (auth_context)\n\t{\n\t  krb5_auth_con_free (telnet_context, auth_context);\n\t  auth_context = 0;\n\t}\n    }\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "req_type_str": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static char *\nreq_type_str (int type)\n{\n  switch (type)\n    {\n    case KRB_REJECT:\n      return \"REJECT\";\n\n    case KRB_ACCEPT:\n      return \"ACCEPT\";\n\n    case KRB_AUTH:\n      return \"AUTH\";\n\n    case KRB_RESPONSE:\n      return \"RESPONSE\";\n\n    case KRB_FORWARD:\n      return \"FORWARD\";\n\n    case KRB_FORWARD_ACCEPT:\n      return \"FORWARD_ACCEPT\";\n\n    case KRB_FORWARD_REJECT:\n      return \"FORWARD_REJECT\";\n\n    }\n  return NULL;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreq_type_str (int type)",
        "*"
      ]
    },
    "kerberos5_printsub": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        794,
        1
      ],
      "content": "void\nkerberos5_printsub (unsigned char *data, int cnt,\n\t\t    char *buf, int buflen)\n{\n  char *p;\n  int i;\n\n  buf[buflen - 1] = '\\0';\t/* make sure its NULL terminated */\n  buflen -= 1;\n\n  p = req_type_str (data[3]);\n  if (!p)\n    {\n      int l = snprintf (buf, buflen, \" %d (unknown)\", data[3]);\n      buf += l;\n      buflen -= l;\n    }\n  else\n    {\n      while (buflen > 0 && (*buf++ = *p++) != 0)\n\tbuflen--;\n    }\n\n  switch (data[3])\n    {\n    case KRB_REJECT:\t\t/* Rejected (reason might follow) */\n    case KRB_ACCEPT:\t\t/* Accepted (username might follow) */\n      if (cnt <= 4)\n\tbreak;\n      ADDC (buf, buflen, '\"');\n      for (i = 4; i < cnt; i++)\n\tADDC (buf, buflen, data[i]);\n      ADDC (buf, buflen, '\"');\n      ADDC (buf, buflen, '\\0');\n      break;\n\n    case KRB_AUTH:\n    case KRB_RESPONSE:\n    case KRB_FORWARD:\n    case KRB_FORWARD_ACCEPT:\n    case KRB_FORWARD_REJECT:\n      for (i = 4; buflen > 0 && i < cnt; i++)\n\t{\n\t  int l = snprintf (buf, buflen, \" %d\", data[i]);\n\t  buf += l;\n\t  buflen -= l;\n\t}\n    }\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "kerberos5_forward": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "void\nkerberos5_forward (TN_Authenticator * ap)\n{\n  krb5_error_code r;\n  krb5_ccache ccache;\n  krb5_principal client = 0;\n  krb5_principal server = 0;\n  krb5_data forw_creds;\n\n  forw_creds.data = 0;\n\n  if ((r = krb5_cc_default (telnet_context, &ccache)))\n    {\n      DEBUG ((\"Kerberos V5: could not get default ccache - %s\\r\\n\",\n\t      error_message (r)));\n      return;\n    }\n\n  for (;;)\t\t\t/* Fake loop */\n    {\n      if ((r = krb5_cc_get_principal (telnet_context, ccache, &client)))\n\t{\n\t  DEBUG ((\"Kerberos V5: could not get default principal - %s\\r\\n\",\n\t\t  error_message (r)));\n\t  break;\n\t}\n      if ((r =\n\t   krb5_sname_to_principal (telnet_context, RemoteHostName, \"host\",\n\t\t\t\t    KRB5_NT_SRV_HST, &server)))\n\t{\n\t  DEBUG ((\"Kerberos V5: could not make server principal - %s\\r\\n\",\n\t\t  error_message (r)));\n\t  break;\n\t}\n      if ((r = krb5_auth_con_genaddrs (telnet_context, auth_context, net,\n\t\t\t\t       KRB5_AUTH_CONTEXT_GENERATE_LOCAL_FULL_ADDR)))\n\t{\n\t  DEBUG ((\"Kerberos V5: could not gen local full address - %s\\r\\n\",\n\t\t  error_message (r)));\n\t  break;\n\t}\n      if ((r = krb5_fwd_tgt_creds (telnet_context, auth_context, 0, client,\n\t\t\t\t   server, ccache,\n\t\t\t\t   forward_flags & OPTS_FORWARDABLE_CREDS,\n\t\t\t\t   &forw_creds)))\n\t{\n\t  DEBUG ((\"Kerberos V5: error getting forwarded creds - %s\\r\\n\",\n\t\t  error_message (r)));\n\t  break;\n\t}\n\n      /* Send forwarded credentials */\n      if (!Data (ap, KRB_FORWARD, forw_creds.data, forw_creds.length))\n\t{\n\t  DEBUG ((\"Not enough room for authentication data\\r\\n\"));\n\t}\n      else\n\t{\n\t  DEBUG ((\"Forwarded local Kerberos V5 credentials to server\\r\\n\"));\n\t}\n      break;\n    }\n\n  if (client)\n    krb5_free_principal (telnet_context, client);\n  if (server)\n    krb5_free_principal (telnet_context, server);\n  free (forw_creds.data);\n  krb5_cc_close (telnet_context, ccache);\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/key-proto.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/misc-proto.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/misc.c": {
    "auth_encrypt_init": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nauth_encrypt_init (char *local, char *remote, char *principal,\n\t\t   char *name, int server)\n{\n  RemoteHostName = remote;\n  LocalHostName = local;\n  ServerPrincipal = principal;\n  (void) name;\n  (void) server;\t\t/* silence gcc */\n#if defined AUTHENTICATION\n  auth_init (name, server);\n#endif\n#ifdef\tENCRYPTION\n  encrypt_init (name, server);\n#endif /* ENCRYPTION */\n  free (UserNameRequested);\n  UserNameRequested = NULL;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "auth_encrypt_user": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nauth_encrypt_user (char *name)\n{\n  extern char *strdup (const char *);\n\n  free (UserNameRequested);\n  UserNameRequested = name ? strdup (name) : NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "auth_encrypt_connect": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nauth_encrypt_connect (int cnt)\n{\n  (void) cnt;\t\t\t/* silence gcc */\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "printd": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nprintd (unsigned char *data, int cnt)\n{\n  if (cnt > 16)\n    cnt = 16;\n  while (cnt-- > 0)\n    {\n      printf (\" %02x\", *data);\n      ++data;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/libtelnet/misc.h": {},
  "inetutils/inetutils-1.9.4/libtelnet/read_passwd.c": {},
  "inetutils/inetutils-1.9.4/libtelnet/shishi.c": {
    "Data": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\nData (TN_Authenticator * ap, int type, void * d, int c)\n{\n  unsigned char *p = str_data + 4;\n  unsigned char *cd = (unsigned char *) d;\n\n  /* Submitted as test data.  */\n  if (c == -1)\n    c = strlen ((char *) cd);\n\n  if (auth_debug_mode)\n    {\n      printf (\"%s:%d: [%d] (%d)\",\n\t      str_data[3] == TELQUAL_IS ? \">>>IS\" : \">>>REPLY\",\n\t      str_data[3], type, c);\n      printd (d, c);\n      printf (\"\\r\\n\");\n    }\n\n  *p++ = ap->type;\n  *p++ = ap->way;\n  *p++ = type;\n\n  while (c-- > 0)\n    {\n      if ((*p++ = *cd++) == IAC)\n\t*p++ = IAC;\n    }\n  *p++ = IAC;\n  *p++ = SE;\n  if (str_data[3] == TELQUAL_IS)\n    printsub ('>', &str_data[2], p - &str_data[2]);\n  return (net_write (str_data, p - str_data));\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "krb5shishi_init": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\nkrb5shishi_init (TN_Authenticator * ap _GL_UNUSED_PARAMETER,\n\t\t int server)\n{\n  if (server)\n    str_data[3] = TELQUAL_REPLY;\n  else\n    str_data[3] = TELQUAL_IS;\n\n  if (!shishi_check_version (SHISHI_VERSION))\n    return 0;\n\n  return 1;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "delayed_shishi_init": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int\ndelayed_shishi_init (void)\n{\n  if (shishi_handle)\n    return 1;\n\n  if (str_data[3] == TELQUAL_REPLY)\n    {\n      if (!shishi_handle && shishi_init_server (&shishi_handle) != SHISHI_OK)\n\treturn 0;\n    }\n  else\n    {\n      if (!shishi_handle && shishi_init (&shishi_handle) != SHISHI_OK)\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "krb5shishi_cleanup": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nkrb5shishi_cleanup (TN_Authenticator * ap _GL_UNUSED_PARAMETER)\n{\n  if (shishi_handle == NULL)\n    return;\n\n  shishi_done (shishi_handle);\n  shishi_handle = NULL;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "krb5shishi_send": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\nkrb5shishi_send (TN_Authenticator * ap)\n{\n  int ap_opts;\n  char type_check[2];\n  Shishi_tkt *tkt;\n  Shishi_tkts_hint hint;\n  int rc;\n  char *tmp;\n  char *apreq;\n  size_t apreq_len;\n\n  if (!UserNameRequested)\n    {\n      DEBUG ((\"telnet: Kerberos V5: no user name supplied\\r\\n\"));\n      return 0;\n    }\n\n  if (!delayed_shishi_init ())\n    {\n      DEBUG ((\"telnet: Kerberos V5: shishi initialization failed\\r\\n\"));\n      return 0;\n    }\n\n  tmp = malloc (strlen (\"host/\") + strlen (RemoteHostName) + 1);\n  if (tmp == NULL)\n    {\n      DEBUG ((\"telnet: Kerberos V5: shishi memory allocation failed\\r\\n\"));\n      return 0;\n    }\n\n  /* Check for Kerberos prefix in principal name.  */\n  if (strchr (RemoteHostName, '/'))\n    strcpy (tmp, RemoteHostName);\n  else\n    sprintf (tmp, \"host/%s\", RemoteHostName);\n\n  memset (&hint, 0, sizeof (hint));\n  hint.server = tmp;\n  hint.client = UserNameRequested;\n\n  if (dest_realm && *dest_realm)\n    shishi_realm_default_set (shishi_handle, dest_realm);\n  else\n    {\n      /* Retrieve realm assigned to this server as per configuration.  */\n      char *p = strchr (RemoteHostName, '/');\n\n      if (p)\n\t++p;\n      else\n\tp = RemoteHostName;\n\n      shishi_realm_default_set (shishi_handle,\n\t\t\t\tshishi_realm_for_server (shishi_handle, p));\n    }\n\n  tkt = shishi_tkts_get (shishi_tkts_default (shishi_handle), &hint);\n  free (tmp);\n  if (!tkt)\n    {\n      DEBUG ((\"telnet: Kerberos V5: no shishi ticket for server\\r\\n\"));\n      return 0;\n    }\n\n  if (auth_debug_mode)\n    shishi_tkt_pretty_print (tkt, stdout);\n\n  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n    ap_opts = SHISHI_APOPTIONS_MUTUAL_REQUIRED;\n  else\n    ap_opts = 0;\n\n  type_check[0] = ap->type;\n  type_check[1] = ap->way;\n\n# ifndef DONT_ALWAYS_USE_DES\n  /* Even if we are not using a DES key, we can still try a DES\n     session-key.  Then we can support DES_?FB64 encryption with 3DES\n     or AES keys against non-RFC 2952 implementations.  Of course, it\n     would be better to follow RFC 2952, but enc_des.c does not\n     support this (see comment in that file). */\n  if (shishi_tkt_keytype_fast (tkt) != SHISHI_DES_CBC_CRC &&\n      shishi_tkt_keytype_fast (tkt) != SHISHI_DES_CBC_MD4 &&\n      shishi_tkt_keytype_fast (tkt) != SHISHI_DES_CBC_MD5)\n    rc = shishi_ap_etype_tktoptionsdata (shishi_handle, &auth_handle,\n\t\t\t\t\t SHISHI_DES_CBC_MD5,\n\t\t\t\t\t tkt, ap_opts,\n\t\t\t\t\t (char *) &type_check, 2);\n  else\n# endif\n    rc = shishi_ap_tktoptionsdata (shishi_handle, &auth_handle,\n\t\t\t\t   tkt, ap_opts, (char *) &type_check, 2);\n  if (rc != SHISHI_OK)\n    {\n      DEBUG ((\"telnet: Kerberos V5: Could not make AP-REQ (%s)\\r\\n\",\n\t      shishi_strerror (rc)));\n      return 0;\n    }\n\n# ifdef ENCRYPTION\n  if (enckey)\n    {\n      shishi_key_done (enckey);\n      enckey = NULL;\n    }\n\n  rc = shishi_authenticator_get_subkey\n    (shishi_handle, shishi_ap_authenticator (auth_handle), &enckey);\n  if (rc != SHISHI_OK)\n    {\n      DEBUG ((\"telnet: Kerberos V5: could not get encryption key (%s)\\r\\n\",\n\t      shishi_strerror (rc)));\n      return 0;\n    }\n# endif\n\n  rc = shishi_ap_req_der (auth_handle, &apreq, &apreq_len);\n  if (rc != SHISHI_OK)\n    {\n      DEBUG ((\"telnet: Kerberos V5: could not DER encode (%s)\\r\\n\",\n\t      shishi_strerror (rc)));\n      return 0;\n    }\n\n  if (auth_debug_mode)\n    {\n      shishi_authenticator_print (shishi_handle, stdout,\n\t\t\t\t  shishi_ap_authenticator (auth_handle));\n      shishi_apreq_print (shishi_handle, stdout, shishi_ap_req (auth_handle));\n    }\n\n  if (!auth_sendname (UserNameRequested, strlen (UserNameRequested)))\n    {\n      DEBUG ((\"telnet: Not enough room for user name\\r\\n\"));\n      return 0;\n    }\n\n  if (!Data (ap, KRB_AUTH, apreq, apreq_len))\n    {\n      DEBUG ((\"telnet: Not enough room for authentication data\\r\\n\"));\n      return 0;\n    }\n\n  DEBUG ((\"telnet: Sent Kerberos V5 credentials to server\\r\\n\"));\n\n  return 1;\n}",
      "lines": 148,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "shishi_init_key": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void\nshishi_init_key (Session_Key * skey, int type)\n{\n  int32_t etype = shishi_key_type (enckey);\n\n  if (etype == SHISHI_DES_CBC_CRC || etype == SHISHI_DES_CBC_MD4\n      || etype == SHISHI_DES_CBC_MD5)\n    skey->type = SK_DES;\n  else\n    skey->type = SK_OTHER;\n  skey->length = shishi_key_length (enckey);\n  skey->data = (unsigned char *) shishi_key_value (enckey);\n\n  encrypt_session_key (skey, type);\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "krb5shishi_reply": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void\nkrb5shishi_reply (TN_Authenticator * ap, unsigned char *data, int cnt)\n{\n  static int mutual_complete = 0;\n# ifdef ENCRYPTION\n  Session_Key skey;\n# endif\n\n  if (cnt-- < 1)\n    return;\n\n  switch (*data++)\n    {\n    case KRB_REJECT:\n      if (cnt > 0)\n\tprintf (\"[ Kerberos V5 rejects authentication: %.*s ]\\r\\n\",\n\t\tcnt, data);\n      else\n\tprintf (\"[ Kerberos V5 refuses authentication ]\\r\\n\");\n      auth_send_retry ();\n      return;\n\n    case KRB_ACCEPT:\n      if (!mutual_complete)\n\t{\n\t  if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t    {\n\t      printf (\"[ Kerberos V5 accepted you, \"\n\t\t      \"but didn't provide mutual authentication! ]\\r\\n\");\n\t      auth_send_retry ();\n\t      break;\n\t    }\n# ifdef ENCRYPTION\n\t  shishi_init_key (&skey, 0);\n# endif\n\t}\n\n      if (cnt)\n\tprintf (\"[ Kerberos V5 accepts you as ``%.*s''%s ]\\r\\n\", cnt, data,\n\t\tmutual_complete ?\n\t\t\" (server authenticated)\" : \" (server NOT authenticated)\");\n      else\n\tprintf (\"[ Kerberos V5 accepts you ]\\r\\n\");\n\n      auth_finished (ap, AUTH_USER);\n      /* This was last access to handle on behalf of the client.  */\n      shishi_done (shishi_handle);\n      shishi_handle = NULL;\n      break;\n\n    case KRB_RESPONSE:\n      if ((ap->way & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t{\n\t  if (shishi_ap_rep_verify_der (auth_handle, (char *) data, cnt)\n\t      != SHISHI_OK)\n\t    {\n\t      printf (\"[ Mutual authentication failed ]\\r\\n\");\n\t      auth_send_retry ();\n\t      break;\n\t    }\n\n\t  if (auth_debug_mode)\n\t    {\n\t      shishi_aprep_print (shishi_handle, stdout,\n\t\t\t\t  shishi_ap_rep (auth_handle));\n\t      shishi_encapreppart_print (shishi_handle, stdout,\n\t\t\t\t\t shishi_ap_encapreppart\n\t\t\t\t\t (auth_handle));\n\t    }\n\n# ifdef ENCRYPTION\n\t  shishi_init_key (&skey, 0);\n# endif\n\t  mutual_complete = 1;\n\t}\n      break;\n\n    default:\n      DEBUG ((\"Unknown Kerberos option %d\\r\\n\", data[-1]));\n    }\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "krb5shishi_status": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "int\nkrb5shishi_status (TN_Authenticator * ap _GL_UNUSED_PARAMETER,\n\t\t   char *name, size_t len, int level)\n{\n  int status;\n\n  if (level < AUTH_USER)\n    return level;\n\n  if (UserNameRequested\n      && shishi_authorized_p (shishi_handle,\n\t\t\t      shishi_ap_tkt (auth_handle),\n\t\t\t      UserNameRequested))\n    {\n      /* FIXME: Check buffer length */\n      strncpy (name, UserNameRequested, len);\n      status = AUTH_VALID;\n    }\n  else\n    status = AUTH_USER;\n\n  return status;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "krb5shishi_is_auth": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "static int\nkrb5shishi_is_auth (TN_Authenticator * a, unsigned char *data, int cnt,\n\t\t    char *errbuf, int errbuflen)\n{\n  Shishi_key *key;\n  int rc;\n  char *cnamerealm, *server = NULL, *realm = NULL;\n  size_t cnamerealmlen;\n# ifdef ENCRYPTION\n  Session_Key skey;\n# endif\n\n  if (!delayed_shishi_init ())\n    {\n      DEBUG ((\"telnet: Kerberos V5: shishi initialization failed\\r\\n\"));\n      return 0;\n    }\n\n  /* Enable use of `~/.k5login'.  */\n  if (shishi_check_version (\"1.0.2\"))\t/* Faulty in version 1.0.1.  */\n    {\n      rc = shishi_cfg_authorizationtype_set (shishi_handle, \"k5login basic\");\n      if (rc != SHISHI_OK)\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"Cannot initiate authorization types: %s\",\n\t\t    shishi_error (shishi_handle));\n\t  return rc;\n\t}\n    }\n\n  if (ServerPrincipal && *ServerPrincipal)\n    {\n      rc = shishi_parse_name (shishi_handle, ServerPrincipal,\n\t\t\t      &server, &realm);\n      if (rc != SHISHI_OK)\n\t{\n\t  snprintf (errbuf, errbuflen,\n\t\t    \"Cannot parse server principal name: %s\",\n\t\t    shishi_strerror (rc));\n\t  return 1;\n\t}\n      if (realm)\n\tshishi_realm_default_set (shishi_handle, realm);\n\n      /* Reclaim an empty server part.  */\n      if (server && !*server)\n\t{\n\t  free (server);\n\t  server = NULL;\n\t}\n    }\n\n  if (!server)\n    {\n      server = malloc (strlen (\"host/\") + strlen (LocalHostName) + 1);\n      if (server)\n\tsprintf (server, \"host/%s\", LocalHostName);\n    }\n\n  if (server)\n    {\n      /* Two possible action on `server':\n       *   \"srv.local\"    :  rewrite as \"host/srv.local\"\n       *   \"tn/srv.local\" :  accept as is\n       */\n      char *p = strchr (server, '/');\n\n      if (!p)\n\t{\n\t  p = server;\n\t  server = malloc (strlen (\"host/\") + strlen (p) + 1);\n\t  if (!server)\n\t    {\n\t      free (p);\t\t/* This old `server'.  */\n\t      snprintf (errbuf, errbuflen,\n\t\t\t\"Cannot allocate memory for server name\");\n\t      return 1;\n\t    }\n\t  sprintf (server, \"host/%s\", p);\n\t}\n\n      if (realm)\n\tkey = shishi_hostkeys_for_serverrealm (shishi_handle,\n\t\t\t\t\t       server, realm);\n      else\n\t/* Enforce a search with the known default realm.  */\n\tkey = shishi_hostkeys_for_serverrealm (shishi_handle,\n\t\t\tserver, shishi_realm_default (shishi_handle));\n\n      free (server);\n    }\n  else\n    key = shishi_hostkeys_for_localservicerealm (shishi_handle,\n\t\t\t\t\t\t \"host\", realm);\n\n  free (realm);\n\n  if (key == NULL)\n    {\n      snprintf (errbuf, errbuflen, \"Could not find key: %s\",\n\t\tshishi_error (shishi_handle));\n      return 1;\n    }\n\n  rc = shishi_ap (shishi_handle, &auth_handle);\n  if (rc != SHISHI_OK)\n    {\n      snprintf (errbuf, errbuflen,\n\t\t\"Cannot allocate authentication structures: %s\",\n\t\tshishi_strerror (rc));\n      return 1;\n    }\n\n  rc = shishi_ap_req_der_set (auth_handle, (char *) data, cnt);\n  if (rc != SHISHI_OK)\n    {\n      snprintf (errbuf, errbuflen,\n\t\t\"Cannot parse authentication information: %s\",\n\t\tshishi_strerror (rc));\n      return 1;\n    }\n\n  rc = shishi_ap_req_process (auth_handle, key);\n  if (rc != SHISHI_OK)\n    {\n      snprintf (errbuf, errbuflen, \"Could not process AP-REQ: %s\",\n\t\tshishi_strerror (rc));\n      return 1;\n    }\n\n  if (shishi_apreq_mutual_required_p (shishi_handle,\n\t\t\t\t      shishi_ap_req (auth_handle)))\n    {\n      char *der;\n      size_t derlen;\n\n      rc = shishi_ap_rep_der (auth_handle, &der, &derlen);\n      if (rc != SHISHI_OK)\n\t{\n\t  snprintf (errbuf, errbuflen, \"Error DER encoding aprep: %s\",\n\t\t    shishi_strerror (rc));\n\t  return 1;\n\t}\n\n      Data (a, KRB_RESPONSE, der, derlen);\n      free (der);\n    }\n\n  rc = shishi_encticketpart_clientrealm (\n\t\tshishi_handle,\n\t\tshishi_tkt_encticketpart (shishi_ap_tkt (auth_handle)),\n\t\t&cnamerealm, &cnamerealmlen);\n  if (rc != SHISHI_OK)\n    {\n      snprintf (errbuf, errbuflen, \"Error getting authenticator name: %s\",\n\t\tshishi_strerror (rc));\n      return 1;\n    }\n  Data (a, KRB_ACCEPT, cnamerealm, cnamerealm ? -1 : 0);\n  DEBUG ((\"telnetd: Kerberos5 identifies him as ``%s''\\r\\n\",\n\t  cnamerealm ? cnamerealm : \"\"));\n  free (cnamerealm);\n  auth_finished (a, AUTH_USER);\n\n  /* Make sure that shishi_handle is still valid,\n   * it must not be released in auth_finish()!\n   * The server side will make reference to it\n   * later on.  */\n\n# ifdef ENCRYPTION\n  if (enckey)\n    {\n      shishi_key_done (enckey);\n      enckey = NULL;\n    }\n\n  rc = shishi_authenticator_get_subkey (shishi_handle,\n\t\t\t\t\tshishi_ap_authenticator (auth_handle),\n\t\t\t\t\t&enckey);\n  if (rc != SHISHI_OK)\n    {\n      Shishi_tkt *tkt;\n\n      tkt = shishi_ap_tkt (auth_handle);\n      if (tkt)\n\t{\n\t  rc = shishi_encticketpart_get_key (shishi_handle,\n\t\t\t\t\t     shishi_tkt_encticketpart (tkt),\n\t\t\t\t\t     &enckey);\n\t  if (rc != SHISHI_OK)\n\t    enckey = NULL;\n\n\t  shishi_tkt_done (tkt);\n\t}\n    }\n\n  if (enckey == NULL)\n    {\n      snprintf (errbuf, errbuflen,\n\t\t\"telnet: Kerberos V5: could not get encryption key (%s)\\r\\n\",\n\t\tshishi_strerror (rc));\n      return 1;\n    }\n\n  shishi_init_key (&skey, 1);\n# endif\n\n  return 0;\n}",
      "lines": 210,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "krb5shishi_is": {
      "start_point": [
        631,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "void\nkrb5shishi_is (TN_Authenticator * ap, unsigned char *data, int cnt)\n{\n  int r = 0;\n  char errbuf[512];\n\n  if (cnt-- < 1)\n    return;\n  errbuf[0] = 0;\n  switch (*data++)\n    {\n    case KRB_AUTH:\n      r = krb5shishi_is_auth (ap, data, cnt, errbuf, sizeof errbuf);\n      break;\n\n    default:\n      DEBUG ((\"Unknown Kerberos option %d\\r\\n\", data[-1]));\n      Data (ap, KRB_REJECT, 0, 0);\n      break;\n    }\n\n  if (r)\n    {\n      if (!errbuf[0])\n\tsnprintf (errbuf, sizeof errbuf, \"kerberos_is: error\");\n      Data (ap, KRB_REJECT, errbuf, -1);\n      DEBUG ((\"%s\\r\\n\", errbuf));\n      syslog (LOG_ERR, \"%s\", errbuf);\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "req_type_str": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "static char *\nreq_type_str (int type)\n{\n  switch (type)\n    {\n    case KRB_REJECT:\n      return \"REJECT\";\n\n    case KRB_ACCEPT:\n      return \"ACCEPT\";\n\n    case KRB_AUTH:\n      return \"AUTH\";\n\n    case KRB_RESPONSE:\n      return \"RESPONSE\";\n\n    }\n  return NULL;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nreq_type_str (int type)",
        "*"
      ]
    },
    "krb5shishi_printsub": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        730,
        1
      ],
      "content": "void\nkrb5shishi_printsub (unsigned char *data, int cnt,\n\t\t     char *buf, int buflen)\n{\n  char *p;\n  int i;\n\n  buf[buflen - 1] = '\\0';\t/* make sure its NULL terminated */\n  buflen -= 1;\n\n  p = req_type_str (data[3]);\n  if (!p)\n    {\n      int l = snprintf (buf, buflen, \" %d (unknown)\", data[3]);\n      buf += l;\n      buflen -= l;\n    }\n  else\n    {\n      while (buflen > 0 && (*buf++ = *p++) != 0)\n\tbuflen--;\n    }\n\n  switch (data[3])\n    {\n    case KRB_REJECT:\t\t/* Rejected (reason might follow) */\n    case KRB_ACCEPT:\t\t/* Accepted (username might follow) */\n      if (cnt <= 4)\n\tbreak;\n      ADDC (buf, buflen, '\"');\n      for (i = 4; i < cnt; i++)\n\tADDC (buf, buflen, data[i]);\n      ADDC (buf, buflen, '\"');\n      ADDC (buf, buflen, '\\0');\n      break;\n\n    case KRB_AUTH:\n    case KRB_RESPONSE:\n      for (i = 4; buflen > 0 && i < cnt; i++)\n\t{\n\t  int l = snprintf (buf, buflen, \" %d\", data[i]);\n\t  buf += l;\n\t  buflen -= l;\n\t}\n    }\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/libping.c": {
    "_ping_packetsize": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "size_t\n_ping_packetsize (PING * p)\n{\n  if (p->ping_type == ICMP_TIMESTAMP || p->ping_type == ICMP_TIMESTAMPREPLY)\n    return ICMP_TSLEN;\n\n  if (p->ping_type == ICMP_ADDRESS || p->ping_type == ICMP_ADDRESSREPLY)\n    return ICMP_MASKLEN;\n\n  return PING_HEADER_LEN + p->ping_datalen;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "ping_init": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "PING *\nping_init (int type, int ident)\n{\n  int fd;\n  struct protoent *proto;\n  PING *p;\n\n  /* Initialize raw ICMP socket */\n  proto = getprotobyname (\"icmp\");\n  if (!proto)\n    {\n      fprintf (stderr, \"ping: unknown protocol icmp.\\n\");\n      return NULL;\n    }\n\n  fd = socket (AF_INET, SOCK_RAW, proto->p_proto);\n  if (fd < 0)\n    {\n      if (errno == EPERM || errno == EACCES)\n\tfprintf (stderr, \"ping: Lacking privilege for raw socket.\\n\");\n      return NULL;\n    }\n\n  /* Allocate PING structure and initialize it to default values */\n  p = malloc (sizeof (*p));\n  if (!p)\n    {\n      close (fd);\n      return p;\n    }\n\n  memset (p, 0, sizeof (*p));\n\n  p->ping_fd = fd;\n  p->ping_type = type;\n  p->ping_count = 0;\n  p->ping_interval = PING_DEFAULT_INTERVAL;\n  p->ping_datalen = sizeof (icmphdr_t);\n  /* Make sure we use only 16 bits in this field, id for icmp is a unsigned short.  */\n  p->ping_ident = ident & 0xFFFF;\n  p->ping_cktab_size = PING_CKTABSIZE;\n  gettimeofday (&p->ping_start_time, NULL);\n  return p;\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "PING",
        "*\nping_init (int type, int ident)",
        "*"
      ]
    },
    "ping_reset": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nping_reset (PING * p)\n{\n  p->ping_num_xmit = 0;\n  p->ping_num_recv = 0;\n  p->ping_num_rept = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_set_type": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\nping_set_type (PING * p, int type)\n{\n  p->ping_type = type;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_xmit": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nping_xmit (PING * p)\n{\n  int i, buflen;\n\n  if (_ping_setbuf (p, USE_IPV6))\n    return -1;\n\n  buflen = _ping_packetsize (p);\n\n  /* Mark sequence number as sent */\n  _PING_CLR (p, p->ping_num_xmit);\n\n  /* Encode ICMP header */\n  switch (p->ping_type)\n    {\n    case ICMP_ECHO:\n      icmp_echo_encode (p->ping_buffer, buflen, p->ping_ident,\n\t\t\tp->ping_num_xmit);\n      break;\n\n    case ICMP_TIMESTAMP:\n      icmp_timestamp_encode (p->ping_buffer, buflen, p->ping_ident,\n\t\t\t     p->ping_num_xmit);\n      break;\n\n    case ICMP_ADDRESS:\n      icmp_address_encode (p->ping_buffer, buflen, p->ping_ident,\n\t\t\t   p->ping_num_xmit);\n      break;\n\n    default:\n      icmp_generic_encode (p->ping_buffer, buflen, p->ping_type,\n\t\t\t   p->ping_ident, p->ping_num_xmit);\n      break;\n    }\n\n  i = sendto (p->ping_fd, (char *) p->ping_buffer, buflen, 0,\n\t      (struct sockaddr *) &p->ping_dest.ping_sockaddr, sizeof (struct sockaddr_in));\n  if (i < 0)\n    return -1;\n  else\n    {\n      p->ping_num_xmit++;\n      if (i != buflen)\n\tprintf (\"ping: wrote %s %d chars, ret=%d\\n\",\n\t\tp->ping_hostname, buflen, i);\n    }\n  return 0;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "my_echo_reply": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static int\nmy_echo_reply (PING * p, icmphdr_t * icmp)\n{\n  struct ip *orig_ip = &icmp->icmp_ip;\n  icmphdr_t *orig_icmp = (icmphdr_t *) (orig_ip + 1);\n\n  return (orig_ip->ip_dst.s_addr == p->ping_dest.ping_sockaddr.sin_addr.s_addr\n\t  && orig_ip->ip_p == IPPROTO_ICMP\n\t  && orig_icmp->icmp_type == ICMP_ECHO\n\t  && ntohs (orig_icmp->icmp_id) == p->ping_ident);\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_recv": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\nping_recv (PING * p)\n{\n  socklen_t fromlen = sizeof (p->ping_from.ping_sockaddr);\n  int n, rc;\n  icmphdr_t *icmp;\n  struct ip *ip;\n  int dupflag;\n\n  n = recvfrom (p->ping_fd,\n\t\t(char *) p->ping_buffer, _PING_BUFLEN (p, USE_IPV6), 0,\n\t\t(struct sockaddr *) &p->ping_from.ping_sockaddr, &fromlen);\n  if (n < 0)\n    return -1;\n\n  rc = icmp_generic_decode (p->ping_buffer, n, &ip, &icmp);\n  if (rc < 0)\n    {\n      /*FIXME: conditional */\n      fprintf (stderr, \"packet too short (%d bytes) from %s\\n\", n,\n\t       inet_ntoa (p->ping_from.ping_sockaddr.sin_addr));\n      return -1;\n    }\n\n  switch (icmp->icmp_type)\n    {\n    case ICMP_ECHOREPLY:\n    case ICMP_TIMESTAMPREPLY:\n    case ICMP_ADDRESSREPLY:\n      /*    case ICMP_ROUTERADV: */\n\n      if (ntohs (icmp->icmp_id) != p->ping_ident)\n\treturn -1;\n\n      if (rc)\n\tfprintf (stderr, \"checksum mismatch from %s\\n\",\n\t\t inet_ntoa (p->ping_from.ping_sockaddr.sin_addr));\n\n      p->ping_num_recv++;\n      if (_PING_TST (p, ntohs (icmp->icmp_seq)))\n\t{\n\t  p->ping_num_rept++;\n\t  p->ping_num_recv--;\n\t  dupflag = 1;\n\t}\n      else\n\t{\n\t  _PING_SET (p, ntohs (icmp->icmp_seq));\n\t  dupflag = 0;\n\t}\n\n      if (p->ping_event.handler)\n\t(*p->ping_event.handler) (dupflag ? PEV_DUPLICATE : PEV_RESPONSE,\n\t\t\t\t  p->ping_closure,\n\t\t\t\t  &p->ping_dest.ping_sockaddr,\n\t\t\t\t  &p->ping_from.ping_sockaddr, ip, icmp, n);\n      break;\n\n    case ICMP_ECHO:\n    case ICMP_TIMESTAMP:\n    case ICMP_ADDRESS:\n      return -1;\n\n    default:\n      if (!my_echo_reply (p, icmp))\n\treturn -1;\n\n      if (p->ping_event.handler)\n\t(*p->ping_event.handler) (PEV_NOECHO,\n\t\t\t\t  p->ping_closure,\n\t\t\t\t  &p->ping_dest.ping_sockaddr,\n\t\t\t\t  &p->ping_from.ping_sockaddr, ip, icmp, n);\n    }\n  return 0;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "ping_set_event_handler": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void\nping_set_event_handler (PING * ping, ping_efp pf, void *closure)\n{\n  ping->ping_event.handler = pf;\n  ping->ping_closure = closure;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ping_set_packetsize": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "void\nping_set_packetsize (PING * ping, size_t size)\n{\n  ping->ping_datalen = size;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_set_dest": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "int\nping_set_dest (PING * ping, char *host)\n{\n#if HAVE_DECL_GETADDRINFO\n  int rc;\n  struct addrinfo hints, *res;\n  char *p;\n\n# ifdef HAVE_IDN\n  rc = idna_to_ascii_lz (host, &p, 0);\t/* P is allocated.  */\n  if (rc)\n    return 1;\n# else /* !HAVE_IDN */\n  p = host;\n# endif\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_INET;\n  hints.ai_flags = AI_CANONNAME;\n# ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n# endif\n# ifdef AI_CANONIDN\n  hints.ai_flags |= AI_CANONIDN;\n# endif\n\n  rc = getaddrinfo (p, NULL, &hints, &res);\n\n  if (rc)\n    return 1;\n\n  memcpy (&ping->ping_dest.ping_sockaddr, res->ai_addr, res->ai_addrlen);\n  if (res->ai_canonname)\n    ping->ping_hostname = strdup (res->ai_canonname);\n  else\n    ping->ping_hostname = strdup (p);\n\n# ifdef HAVE_IDN\n  free (p);\n# endif\n  freeaddrinfo (res);\n\n  return 0;\n#else /* !HAVE_DECL_GETADDRINFO */\n\n  struct sockaddr_in *s_in = &ping->ping_dest.ping_sockaddr;\n  s_in->sin_family = AF_INET;\n# ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  s_in->sin_len = sizeof (*s_in);\n# endif\n  if (inet_aton (host, &s_in->sin_addr))\n    ping->ping_hostname = strdup (host);\n  else\n    {\n      struct hostent *hp;\n# ifdef HAVE_IDN\n      char *p;\n      int rc;\n\n      rc = idna_to_ascii_lz (host, &p, 0);\n      if (rc)\n\treturn 1;\n      hp = gethostbyname (p);\n      free (p);\n# else /* !HAVE_IDN */\n      hp = gethostbyname (host);\n# endif\n      if (!hp)\n\treturn 1;\n\n      s_in->sin_family = hp->h_addrtype;\n      if (hp->h_length > (int) sizeof (s_in->sin_addr))\n\thp->h_length = sizeof (s_in->sin_addr);\n\n      memcpy (&s_in->sin_addr, hp->h_addr, hp->h_length);\n      ping->ping_hostname = strdup (hp->h_name);\n    }\n  return 0;\n#endif /* !HAVE_DECL_GETADDRINFO */\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping.c": {
    "parse_opt": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  char *endptr;\n  static unsigned char pattern[MAXPATTERN];\n  double v;\n\n  switch (key)\n    {\n    case 'c':\n      count = ping_cvt_number (arg, 0, 1);\n      break;\n\n    case 'd':\n      socket_type |= SO_DEBUG;\n      break;\n\n    case 'i':\n      v = strtod (arg, &endptr);\n      if (*endptr)\n        argp_error (state, \"invalid value (`%s' near `%s')\", arg, endptr);\n      options |= OPT_INTERVAL;\n      interval = v * PING_PRECISION;\n      if (!is_root && interval < MIN_USER_INTERVAL)\n        error (EXIT_FAILURE, 0, \"option value too small: %s\", arg);\n      break;\n\n    case 'r':\n      socket_type |= SO_DONTROUTE;\n      break;\n\n    case 's':\n      data_length = ping_cvt_number (arg, PING_MAX_DATALEN, 1);\n      break;\n\n    case 'n':\n      options |= OPT_NUMERIC;\n      break;\n\n    case 'p':\n      decode_pattern (arg, &pattern_len, pattern);\n      patptr = pattern;\n      break;\n\n    case 'q':\n      options |= OPT_QUIET;\n      break;\n\n    case 'T':\n      tos = ping_cvt_number (arg, 255, 1);\n      break;\n\n    case 'w':\n      timeout = ping_cvt_number (arg, INT_MAX, 0);\n      break;\n\n    case 'R':\n      options |= OPT_RROUTE;\n      break;\n\n    case 'W':\n      linger = ping_cvt_number (arg, INT_MAX, 0);\n      break;\n\n    case 'v':\n      options |= OPT_VERBOSE;\n      break;\n\n    case 'l':\n      preload = strtoul (arg, &endptr, 0);\n      if (*endptr || preload > INT_MAX)\n        error (EXIT_FAILURE, 0, \"invalid preload value (%s)\", arg);\n      break;\n\n    case 'f':\n      options |= OPT_FLOOD;\n      break;\n\n    case 't':\n      ping_type = decode_type (arg);\n      break;\n\n    case ARG_ECHO:\n      ping_type = decode_type (\"echo\");\n      break;\n\n    case ARG_TIMESTAMP:\n      ping_type = decode_type (\"timestamp\");\n      break;\n\n    case ARG_ADDRESS:\n      ping_type = decode_type (\"address\");\n      break;\n\n    case ARG_ROUTERDISCOVERY:\n      ping_type = decode_type (\"router\");\n      break;\n\n    case ARG_TTL:\n      ttl = ping_cvt_number (arg, 255, 0);\n      break;\n\n    case ARG_IPTIMESTAMP:\n      options |= OPT_IPTIMESTAMP;\n      suboptions |= decode_ip_timestamp (arg);\n      break;\n\n    case ARGP_KEY_NO_ARGS:\n      argp_error (state, \"missing host operand\");\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 116,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n  int one = 1;\n  int status = 0;\n\n  set_program_name (argv[0]);\n\n# ifdef HAVE_SETLOCALE\n  setlocale(LC_ALL, \"\");\n# endif\n\n  if (getuid () == 0)\n    is_root = true;\n\n  /* Parse command line */\n  iu_argp_init (\"ping\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  ping = ping_init (ICMP_ECHO, getpid ());\n  if (ping == NULL)\n    /* ping_init() prints our error message.  */\n    exit (EXIT_FAILURE);\n\n  ping_set_sockopt (ping, SO_BROADCAST, (char *) &one, sizeof (one));\n\n  /* Reset root privileges */\n  setuid (getuid ());\n\n  /* Force line buffering regardless of output device.  */\n  setvbuf (stdout, NULL, _IOLBF, 0);\n\n  argv += index;\n  argc -= index;\n\n  if (count != 0)\n    ping_set_count (ping, count);\n\n  if (socket_type != 0)\n    ping_set_sockopt (ping, socket_type, &one, sizeof (one));\n\n  if (options & OPT_INTERVAL)\n    ping_set_interval (ping, interval);\n\n  if (ttl > 0)\n    if (setsockopt (ping->ping_fd, IPPROTO_IP, IP_TTL,\n\t\t    &ttl, sizeof (ttl)) < 0)\n      error (0, errno, \"setsockopt(IP_TTL)\");\n\n  if (tos >= 0)\n    if (setsockopt (ping->ping_fd, IPPROTO_IP, IP_TOS,\n\t\t    &tos, sizeof (tos)) < 0)\n      error (0, errno, \"setsockopt(IP_TOS)\");\n\n  init_data_buffer (patptr, pattern_len);\n\n  while (argc--)\n    {\n      status |= (*(ping_type)) (*argv++);\n      ping_reset (ping);\n    }\n\n  free (ping);\n  free (data_buffer);\n  return status;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "decode_type": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int (*decode_type (const char *arg)) (char *hostname)\n{\n  int (*ping_type) (char *hostname);\n\n  if (strcasecmp (arg, \"echo\") == 0)\n    ping_type = ping_echo;\n  else if (strcasecmp (arg, \"timestamp\") == 0)\n    ping_type = ping_timestamp;\n  else if (strcasecmp (arg, \"address\") == 0)\n    ping_type = ping_address;\n  else if (strcasecmp (arg, \"mask\") == 0)\n    ping_type = ping_address;\n#if 0\n  else if (strcasecmp (arg, \"router\") == 0)\n    ping_type = ping_router;\n#endif\n  else\n    error (EXIT_FAILURE, 0, \"unsupported packet type: %s\", arg);\n\n return ping_type;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int",
        "(*decode_type (const char *arg))",
        "(",
        "*decode_type (const char *arg)",
        "*"
      ]
    },
    "decode_ip_timestamp": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "int\ndecode_ip_timestamp (char *arg)\n{\n  int sopt = 0;\n\n  if (strcasecmp (arg, \"tsonly\") == 0)\n    sopt = SOPT_TSONLY;\n  else if (strcasecmp (arg, \"tsaddr\") == 0)\n    sopt = SOPT_TSADDR;\n#if 0\t/* Not yet implemented.  */\n  else if (strcasecmp (arg, \"prespec\") == 0)\n    sopt = SOPT_TSPRESPEC;\n#endif\n  else\n    error (EXIT_FAILURE, 0, \"unsupported timestamp type: %s\", arg);\n\n  return sopt;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sig_int": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void\nsig_int (int signal _GL_UNUSED_PARAMETER)\n{\n  stop = 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_run": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "int\nping_run (PING * ping, int (*finish) ())\n{\n  fd_set fdset;\n  int fdmax;\n  struct timeval resp_time;\n  struct timeval last, intvl, now;\n  struct timeval *t = NULL;\n  int finishing = 0;\n  size_t nresp = 0;\n  size_t i;\n\n  signal (SIGINT, sig_int);\n\n  fdmax = ping->ping_fd + 1;\n\n  /* Some systems use `struct timeval' of size 16.  As these are\n   * not initialising `timeval' properly by assignment alone, let\n   * us play safely here.  gettimeofday() is always sufficient.\n   */\n  memset (&resp_time, 0, sizeof (resp_time));\n  memset (&intvl, 0, sizeof (intvl));\n  memset (&now, 0, sizeof (now));\n\n  for (i = 0; i < preload; i++)\n    send_echo (ping);\n\n  if (options & OPT_FLOOD)\n    {\n      intvl.tv_sec = 0;\n      intvl.tv_usec = 10000;\n    }\n  else\n    PING_SET_INTERVAL (intvl, ping->ping_interval);\n\n  gettimeofday (&last, NULL);\n  send_echo (ping);\n\n  while (!stop)\n    {\n      int n;\n\n      FD_ZERO (&fdset);\n      FD_SET (ping->ping_fd, &fdset);\n      gettimeofday (&now, NULL);\n      resp_time.tv_sec = last.tv_sec + intvl.tv_sec - now.tv_sec;\n      resp_time.tv_usec = last.tv_usec + intvl.tv_usec - now.tv_usec;\n\n      while (resp_time.tv_usec < 0)\n\t{\n\t  resp_time.tv_usec += 1000000;\n\t  resp_time.tv_sec--;\n\t}\n      while (resp_time.tv_usec >= 1000000)\n\t{\n\t  resp_time.tv_usec -= 1000000;\n\t  resp_time.tv_sec++;\n\t}\n\n      if (resp_time.tv_sec < 0)\n\tresp_time.tv_sec = resp_time.tv_usec = 0;\n\n      n = select (fdmax, &fdset, NULL, NULL, &resp_time);\n      if (n < 0)\n\t{\n\t  if (errno != EINTR)\n\t    error (EXIT_FAILURE, errno, \"select failed\");\n\t  continue;\n\t}\n      else if (n == 1)\n\t{\n\t  if (ping_recv (ping) == 0)\n\t    nresp++;\n\t  if (t == 0)\n\t    {\n\t      gettimeofday (&now, NULL);\n\t      t = &now;\n\t    }\n\n\t  if (ping_timeout_p (&ping->ping_start_time, timeout))\n\t    break;\n\n\t  if (ping->ping_count && nresp >= ping->ping_count)\n\t    break;\n\t}\n      else\n\t{\n\t  if (!ping->ping_count || ping->ping_num_xmit < ping->ping_count)\n\t    {\n\t      send_echo (ping);\n\t      if (!(options & OPT_QUIET) && options & OPT_FLOOD)\n\t\tputchar ('.');\n\n\t      if (ping_timeout_p (&ping->ping_start_time, timeout))\n\t\tbreak;\n\t    }\n\t  else if (finishing)\n\t    break;\n\t  else\n\t    {\n\t      finishing = 1;\n\n\t      intvl.tv_sec = linger;\n\t    }\n\t  gettimeofday (&last, NULL);\n\t}\n    }\n\n  ping_unset_data (ping);\n\n  if (finish)\n    return (*finish) ();\n  return 0;\n}",
      "lines": 114,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "send_echo": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "int\nsend_echo (PING * ping)\n{\n  size_t off = 0;\n  int rc;\n\n  if (PING_TIMING (data_length))\n    {\n      struct timeval tv;\n      gettimeofday (&tv, NULL);\n      ping_set_data (ping, &tv, 0, sizeof (tv), USE_IPV6);\n      off += sizeof (tv);\n    }\n  if (data_buffer)\n    ping_set_data (ping, data_buffer, off,\n\t\t   data_length > off ? data_length - off : data_length,\n\t\t   USE_IPV6);\n\n  rc = ping_xmit (ping);\n  if (rc < 0)\n    error (EXIT_FAILURE, errno, \"sending packet\");\n\n  return rc;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "ping_finish": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        545,
        1
      ],
      "content": "int\nping_finish (void)\n{\n  fflush (stdout);\n  printf (\"--- %s ping statistics ---\\n\", ping->ping_hostname);\n  printf (\"%zu packets transmitted, \", ping->ping_num_xmit);\n  printf (\"%zu packets received, \", ping->ping_num_recv);\n  if (ping->ping_num_rept)\n    printf (\"+%zu duplicates, \", ping->ping_num_rept);\n  if (ping->ping_num_xmit)\n    {\n      if (ping->ping_num_recv > ping->ping_num_xmit)\n\tprintf (\"-- somebody is printing forged packets!\");\n      else\n\tprintf (\"%d%% packet loss\",\n\t\t(int) (((ping->ping_num_xmit - ping->ping_num_recv) * 100) /\n\t\t       ping->ping_num_xmit));\n\n    }\n  printf (\"\\n\");\n  return 0;\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping.h": {},
  "inetutils/inetutils-1.9.4/ping/ping6.c": {
    "parse_opt": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  char *endptr;\n  static unsigned char pattern[MAXPATTERN];\n\n  switch (key)\n    {\n    case 'c':\n      count = ping_cvt_number (arg, 0, 0);\n      break;\n\n    case 'd':\n      socket_type |= SO_DEBUG;\n      break;\n\n    case 'f':\n      if (!is_root)\n        error (EXIT_FAILURE, 0, \"flooding needs root privilege\");\n\n      options |= OPT_FLOOD;\n      setbuf (stdout, (char *) NULL);\n      break;\n\n#ifdef IPV6_FLOWINFO\n    case 'F':\n      options |= OPT_FLOWINFO;\n      flowinfo = ping_cvt_number (arg, 0, 0) & IPV6_FLOWINFO_FLOWLABEL;\n      break;\n#endif\n\n    case 'i':\n      options |= OPT_INTERVAL;\n      interval = ping_cvt_number (arg, 0, 0);\n      break;\n\n    case 'l':\n      if (!is_root)\n        error (EXIT_FAILURE, 0, \"preloading needs root privilege\");\n\n      preload = strtoul (arg, &endptr, 0);\n      if (*endptr || preload > INT_MAX)\n        error (EXIT_FAILURE, 0, \"preload size too large\");\n\n      break;\n\n    case 'n':\n      options |= OPT_NUMERIC;\n      break;\n\n    case 'p':\n      decode_pattern (arg, &pattern_len, pattern);\n      patptr = pattern;\n      break;\n\n    case 'q':\n      options |= OPT_QUIET;\n      break;\n\n    case 'r':\n      socket_type |= SO_DONTROUTE;\n      break;\n\n    case 's':\n      data_length = ping_cvt_number (arg, PING_MAX_DATALEN, 1);\n      break;\n\n#ifdef IPV6_TCLASS\n    case 'T':\n      options |= OPT_TCLASS;\n      tclass = ping_cvt_number (arg, 0, 0);\n      break;\n#endif\n\n    case 'v':\n      options |= OPT_VERBOSE;\n      break;\n\n    case 'w':\n      timeout = ping_cvt_number (arg, INT_MAX, 0);\n      break;\n\n    case ARG_HOPLIMIT:\n      hoplimit = ping_cvt_number (arg, 255, 0);\n      break;\n\n    case ARGP_KEY_NO_ARGS:\n      argp_error (state, \"missing host operand\");\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 95,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n  int status = 0;\n\n  set_program_name (argv[0]);\n\n# ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n# endif\n\n  if (getuid () == 0)\n    is_root = true;\n\n  /* Parse command line */\n  iu_argp_init (\"ping6\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  ping = ping_init (0, getpid ());\n  if (ping == NULL)\n    /* ping_init() prints our error message.  */\n    exit (EXIT_FAILURE);\n\n  setsockopt (ping->ping_fd, SOL_SOCKET, SO_BROADCAST, (char *) &one, sizeof (one));\n\n  /* Reset root privileges */\n  setuid (getuid ());\n\n  /* Force line buffering regardless of output device.  */\n  setvbuf (stdout, NULL, _IOLBF, 0);\n\n  argc -= index;\n  argv += index;\n\n  if (count != 0)\n    ping_set_count (ping, count);\n\n  if (socket_type != 0)\n    ping_set_sockopt (ping, socket_type, &one, sizeof (one));\n\n  if (options & OPT_INTERVAL)\n    ping_set_interval (ping, interval);\n\n  if (hoplimit > 0)\n    if (setsockopt (ping->ping_fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS,\n\t\t    &hoplimit, sizeof (hoplimit)) < 0)\n      error (0, errno, \"setsockopt(IPV6_HOPLIMIT)\");\n\n#ifdef IPV6_TCLASS\n  if (options & OPT_TCLASS)\n    if (setsockopt (ping->ping_fd, IPPROTO_IPV6, IPV6_TCLASS,\n\t\t    &tclass, sizeof (tclass)) < 0)\n      error (EXIT_FAILURE, errno, \"setsockopt(IPV6_TCLASS)\");\n#endif\n\n#ifdef IPV6_FLOWINFO\n  if (options & OPT_FLOWINFO)\n    if (setsockopt (ping->ping_fd, IPPROTO_IPV6, IPV6_FLOWINFO,\n\t\t    &flowinfo, sizeof (flowinfo)) < 0)\n      error (EXIT_FAILURE, errno, \"setsockopt(IPV6_FLOWINFO)\");\n#endif\n\n  init_data_buffer (patptr, pattern_len);\n\n  while (argc--)\n    {\n      status |= ping_echo (*argv++);\n      ping_reset (ping);\n    }\n\n  return status;\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sig_int": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "static void\nsig_int (int signal _GL_UNUSED_PARAMETER)\n{\n  stop = 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ping_run": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static int\nping_run (PING * ping, int (*finish) ())\n{\n  fd_set fdset;\n  int fdmax;\n  struct timeval resp_time;\n  struct timeval last, intvl, now;\n  struct timeval *t = NULL;\n  int finishing = 0;\n  size_t nresp = 0;\n  unsigned long i;\n\n  signal (SIGINT, sig_int);\n\n  fdmax = ping->ping_fd + 1;\n\n  /* Some systems use `struct timeval' of size 16.  As these are\n   * not initialising `timeval' properly by assignment alone, let\n   * us play safely here.  gettimeofday() is always sufficient.\n   */\n  memset (&resp_time, 0, sizeof (resp_time));\n  memset (&intvl, 0, sizeof (intvl));\n  memset (&now, 0, sizeof (now));\n\n  for (i = 0; i < preload; i++)\n    send_echo (ping);\n\n  if (options & OPT_FLOOD)\n    {\n      intvl.tv_sec = 0;\n      intvl.tv_usec = 10000;\n    }\n  else\n    PING_SET_INTERVAL (intvl, ping->ping_interval);\n\n  gettimeofday (&last, NULL);\n  send_echo (ping);\n\n  while (!stop)\n    {\n      int n;\n\n      FD_ZERO (&fdset);\n      FD_SET (ping->ping_fd, &fdset);\n\n      gettimeofday (&now, NULL);\n      resp_time.tv_sec = last.tv_sec + intvl.tv_sec - now.tv_sec;\n      resp_time.tv_usec = last.tv_usec + intvl.tv_usec - now.tv_usec;\n\n      while (resp_time.tv_usec < 0)\n\t{\n\t  resp_time.tv_usec += 1000000;\n\t  resp_time.tv_sec--;\n\t}\n      while (resp_time.tv_usec >= 1000000)\n\t{\n\t  resp_time.tv_usec -= 1000000;\n\t  resp_time.tv_sec++;\n\t}\n\n      if (resp_time.tv_sec < 0)\n\tresp_time.tv_sec = resp_time.tv_usec = 0;\n\n      n = select (fdmax, &fdset, NULL, NULL, &resp_time);\n      if (n < 0)\n\t{\n\t  if (errno != EINTR)\n\t    error (EXIT_FAILURE, errno, \"select failed\");\n\t  continue;\n\t}\n      else if (n == 1)\n\t{\n\t  if (ping_recv (ping) == 0)\n\t    nresp++;\n\t  if (t == 0)\n\t    {\n\t      gettimeofday (&now, NULL);\n\t      t = &now;\n\t    }\n\n\t  if (ping_timeout_p (&ping->ping_start_time, timeout))\n\t    break;\n\n\t  if (ping->ping_count && nresp >= ping->ping_count)\n\t    break;\n\t}\n      else\n\t{\n\t  if (!ping->ping_count || ping->ping_num_xmit < ping->ping_count)\n\t    {\n\t      send_echo (ping);\n\t      if (!(options & OPT_QUIET) && options & OPT_FLOOD)\n\t\t{\n\t\t  putchar ('.');\n\t\t}\n\n\t      if (ping_timeout_p (&ping->ping_start_time, timeout))\n\t\tbreak;\n\t    }\n\t  else if (finishing)\n\t    break;\n\t  else\n\t    {\n\t      finishing = 1;\n\n\t      intvl.tv_sec = MAXWAIT;\n\t    }\n\t  gettimeofday (&last, NULL);\n\t}\n    }\n\n  ping_unset_data (ping);\n\n  if (finish)\n    return (*finish) ();\n  return 0;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_echo": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "static int\nsend_echo (PING * ping)\n{\n  size_t off = 0;\n  int rc;\n\n  if (PING_TIMING (data_length))\n    {\n      struct timeval tv;\n      gettimeofday (&tv, NULL);\n      ping_set_data (ping, &tv, 0, sizeof (tv), USE_IPV6);\n      off += sizeof (tv);\n    }\n  if (data_buffer)\n    ping_set_data (ping, data_buffer, off,\n\t\t   data_length > off ? data_length - off : data_length,\n\t\t   USE_IPV6);\n\n  rc = ping_xmit (ping);\n  if (rc < 0)\n    error (EXIT_FAILURE, errno, \"sending packet\");\n\n  return rc;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_finish": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        473,
        1
      ],
      "content": "static int\nping_finish (void)\n{\n  fflush (stdout);\n  printf (\"--- %s ping statistics ---\\n\", ping->ping_hostname);\n  printf (\"%zu packets transmitted, \", ping->ping_num_xmit);\n  printf (\"%zu packets received, \", ping->ping_num_recv);\n  if (ping->ping_num_rept)\n    printf (\"+%zu duplicates, \", ping->ping_num_rept);\n  if (ping->ping_num_xmit)\n    {\n      if (ping->ping_num_recv > ping->ping_num_xmit)\n\tprintf (\"-- somebody's printing up packets!\");\n      else\n\tprintf (\"%d%% packet loss\",\n\t\t(int) (((ping->ping_num_xmit - ping->ping_num_recv) * 100) /\n\t\t       ping->ping_num_xmit));\n\n    }\n  printf (\"\\n\");\n  return 0;\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_echo": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static int\nping_echo (char *hostname)\n{\n  int err;\n  char buffer[256];\n  struct ping_stat ping_stat;\n  int status;\n\n  if (options & OPT_FLOOD && options & OPT_INTERVAL)\n    error (EXIT_FAILURE, 0, \"-f and -i incompatible options\");\n\n  memset (&ping_stat, 0, sizeof (ping_stat));\n  ping_stat.tmin = 999999999.0;\n\n  ping->ping_datalen = data_length;\n  ping->ping_closure = &ping_stat;\n\n  if (ping_set_dest (ping, hostname))\n    error (EXIT_FAILURE, 0, \"unknown host %s\", hostname);\n\n  err = getnameinfo ((struct sockaddr *) &ping->ping_dest.ping_sockaddr6,\n\t\t     sizeof (ping->ping_dest.ping_sockaddr6), buffer,\n\t\t     sizeof (buffer), NULL, 0, NI_NUMERICHOST);\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      error (EXIT_FAILURE, 0, \"getnameinfo: %s\", errmsg);\n    }\n\n  printf (\"PING %s (%s): %zu data bytes\",\n\t  ping->ping_hostname, buffer, data_length);\n  if (options & OPT_VERBOSE)\n    printf (\", id 0x%04x = %u\", ping->ping_ident, ping->ping_ident);\n\n  printf (\"\\n\");\n\n  status = ping_run (ping, echo_finish);\n  free (ping->ping_hostname);\n  return status;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_reset": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        536,
        1
      ],
      "content": "static void\nping_reset (PING * p)\n{\n  p->ping_num_xmit = 0;\n  p->ping_num_recv = 0;\n  p->ping_num_rept = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_echo": {
      "start_point": [
        538,
        0
      ],
      "end_point": [
        617,
        1
      ],
      "content": "static int\nprint_echo (int dupflag, int hops, struct ping_stat *ping_stat,\n\t    struct sockaddr_in6 *dest _GL_UNUSED_PARAMETER,\n\t    struct sockaddr_in6 *from,\n\t    struct icmp6_hdr *icmp6, int datalen)\n{\n  int err;\n  char buf[256];\n  struct timeval tv;\n  int timing = 0;\n  double triptime = 0.0;\n\n  gettimeofday (&tv, NULL);\n\n  /* Do timing */\n  if (PING_TIMING (datalen - sizeof (struct icmp6_hdr)))\n    {\n      struct timeval tv1, *tp;\n\n      timing++;\n      tp = (struct timeval *) (icmp6 + 1);\n\n      /* Avoid unaligned data: */\n      memcpy (&tv1, tp, sizeof (tv1));\n      tvsub (&tv, &tv1);\n\n      triptime = ((double) tv.tv_sec) * 1000.0 +\n\t((double) tv.tv_usec) / 1000.0;\n      ping_stat->tsum += triptime;\n      ping_stat->tsumsq += triptime * triptime;\n      if (triptime < ping_stat->tmin)\n\tping_stat->tmin = triptime;\n      if (triptime > ping_stat->tmax)\n\tping_stat->tmax = triptime;\n    }\n\n  if (options & OPT_QUIET)\n    return 0;\n  if (options & OPT_FLOOD)\n    {\n      putchar ('\\b');\n      return 0;\n    }\n\n  err = getnameinfo ((struct sockaddr *) from, sizeof (*from),\n\t\t     buf, sizeof (buf), NULL, 0,\n\t\t     (options & OPT_NUMERIC) ? NI_NUMERICHOST\n#ifdef NI_IDN\n\t\t     : NI_IDN\n#else\n\t\t     : 0\n#endif\n\t\t     );\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      fprintf (stderr, \"ping: getnameinfo: %s\\n\", errmsg);\n\n      strcpy (buf, \"unknown\");\n    }\n\n  printf (\"%d bytes from %s: icmp_seq=%u\", datalen, buf,\n\t  ntohs (icmp6->icmp6_seq));\n  if (hops >= 0)\n    printf (\" ttl=%d\", hops);\n  if (timing)\n    printf (\" time=%.3f ms\", triptime);\n  if (dupflag)\n    printf (\" (DUP!)\");\n\n  putchar ('\\n');\n\n  return 0;\n}",
      "lines": 80,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_dst_unreach": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "static void\nprint_dst_unreach (struct icmp6_hdr *icmp6)\n{\n  struct icmp_code_descr *p;\n\n  printf (\"Destination unreachable: \");\n  for (p = icmp_dest_unreach_desc;\n       p < icmp_dest_unreach_desc + NITEMS (icmp_dest_unreach_desc); p++)\n    {\n      if (p->code == icmp6->icmp6_code)\n\t{\n\t  puts (p->diag);\n\t  return;\n\t}\n    }\n\n  printf (\"Unknown code %d\\n\", icmp6->icmp6_code);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_packet_too_big": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "static void\nprint_packet_too_big (struct icmp6_hdr *icmp6)\n{\n  printf (\"Packet too big, mtu=%d\\n\", icmp6->icmp6_mtu);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_time_exceeded": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        682,
        1
      ],
      "content": "static void\nprint_time_exceeded (struct icmp6_hdr *icmp6)\n{\n  struct icmp_code_descr *p;\n\n  printf (\"Time exceeded: \");\n  for (p = icmp_time_exceeded_desc;\n       p < icmp_time_exceeded_desc + NITEMS (icmp_time_exceeded_desc); p++)\n    {\n      if (p->code == icmp6->icmp6_code)\n\t{\n\t  puts (p->diag);\n\t  return;\n\t}\n    }\n\n  printf (\"Unknown code %d\\n\", icmp6->icmp6_code);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_param_prob": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "static void\nprint_param_prob (struct icmp6_hdr *icmp6)\n{\n  struct icmp_code_descr *p;\n\n  printf (\"Parameter problem: \");\n  for (p = icmp_param_prob_desc;\n       p < icmp_param_prob_desc + NITEMS (icmp_param_prob_desc); p++)\n    {\n      if (p->code == icmp6->icmp6_code)\n\t{\n\t  puts (p->diag);\n\t  return;\n\t}\n    }\n\n  printf (\"Unknown code %d\\n\", icmp6->icmp6_code);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_ip_data": {
      "start_point": [
        709,
        0
      ],
      "end_point": [
        759,
        1
      ],
      "content": "void\nprint_ip_data (struct icmp6_hdr *icmp6)\n{\n  size_t j;\n  struct ip6_hdr *ip = (struct ip6_hdr *) ((char *) icmp6 + sizeof (*icmp6));\n  char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];\n\n  (void) inet_ntop (AF_INET6, &ip->ip6_dst, dst, sizeof (dst));\n  (void) inet_ntop (AF_INET6, &ip->ip6_src, src, sizeof (src));\n\n  printf (\"IP Header Dump:\\n \");\n  for (j = 0; j < sizeof (*ip) - sizeof (ip->ip6_src) - sizeof (ip->ip6_dst); ++j)\n    printf (\"%02x%s\", *((unsigned char *) ip + j),\n\t    (j % 2) ? \" \" : \"\");\t/* Group bytes two by two.  */\n  printf (\"(src) (dst)\\n\");\n\n  printf (\"Vr TC Flow Plen Nxt Hop Src\\t\\t  Dst\\n\");\n  printf (\" %1x %02x %04x %4hu %3hhu %3hhu %s %s\\n\",\n\t  ntohl (ip->ip6_flow) >> 28,\n\t  (ntohl (ip->ip6_flow) & 0x0fffffff) >> 20,\n\t  ntohl (ip->ip6_flow) & 0x0fffff,\n\t  ntohs (ip->ip6_plen), ip->ip6_nxt, ip->ip6_hlim,\n\t  src, dst);\n\n  switch (ip->ip6_nxt)\n    {\n    case IPPROTO_ICMPV6:\n      {\n\tstruct icmp6_hdr *hdr =\n\t  (struct icmp6_hdr *) ((unsigned char *) ip + sizeof (*ip));\n\n\tprintf (\"ICMP: type %hhu, code %hhu, size %hu\",\n\t\thdr->icmp6_type, hdr->icmp6_code, ntohs (ip->ip6_plen));\n\tswitch (hdr->icmp6_type)\n\t  {\n\t  case ICMP6_ECHO_REQUEST:\n\t  case ICMP6_ECHO_REPLY:\n\t    printf (\", id 0x%04x, seq 0x%04x\",\n\t\t    ntohs (hdr->icmp6_id), ntohs (hdr->icmp6_seq));\n\t    break;\n\t  default:\n\t    break;\n\t  }\n      }\n      break;\n    default:\n      break;\n    }\n\n  printf (\"\\n\");\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "print_icmp_error": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "static void\nprint_icmp_error (struct sockaddr_in6 *from, struct icmp6_hdr *icmp6, int len)\n{\n  char *s;\n  struct icmp_diag *p;\n\n  s = ipaddr2str ((struct sockaddr *) from, sizeof (*from));\n  printf (\"%d bytes from %s: \", len, s);\n  free (s);\n\n  for (p = icmp_diag; p < icmp_diag + NITEMS (icmp_diag); p++)\n    {\n      if (p->type == icmp6->icmp6_type)\n\t{\n\t  p->func (icmp6);\n\t  if (options & OPT_VERBOSE)\n\t    print_ip_data (icmp6);\n\n\t  return;\n\t}\n    }\n\n  /* This should never happen because of the ICMP6_FILTER set in\n     ping_init(). */\n  printf (\"Unknown ICMP type: %d\\n\", icmp6->icmp6_type);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "echo_finish": {
      "start_point": [
        799,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "static int\necho_finish (void)\n{\n  ping_finish ();\n  if (ping->ping_num_recv && PING_TIMING (data_length))\n    {\n      struct ping_stat *ping_stat = (struct ping_stat *) ping->ping_closure;\n      double total = ping->ping_num_recv + ping->ping_num_rept;\n      double avg = ping_stat->tsum / total;\n      double vari = ping_stat->tsumsq / total - avg * avg;\n\n      printf (\"round-trip min/avg/max/stddev = %.3f/%.3f/%.3f/%.3f ms\\n\",\n\t      ping_stat->tmin, avg, ping_stat->tmax, nsqrt (vari, 0.0005));\n    }\n  return (ping->ping_num_recv == 0);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_init": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        876,
        1
      ],
      "content": "static PING *\nping_init (int type _GL_UNUSED_PARAMETER, int ident)\n{\n  int fd, err;\n  const int on = 1;\n  PING *p;\n  struct icmp6_filter filter;\n\n  /* Initialize raw ICMPv6 socket */\n  fd = socket (PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n  if (fd < 0)\n    {\n      if (errno == EPERM || errno == EACCES)\n        error (EXIT_FAILURE, errno, \"raw socket\");\n\n      return NULL;\n    }\n\n  /* Tell which ICMPs we are interested in.  */\n  ICMP6_FILTER_SETBLOCKALL (&filter);\n  ICMP6_FILTER_SETPASS (ICMP6_ECHO_REPLY, &filter);\n  ICMP6_FILTER_SETPASS (ICMP6_DST_UNREACH, &filter);\n  ICMP6_FILTER_SETPASS (ICMP6_PACKET_TOO_BIG, &filter);\n  ICMP6_FILTER_SETPASS (ICMP6_TIME_EXCEEDED, &filter);\n  ICMP6_FILTER_SETPASS (ICMP6_PARAM_PROB, &filter);\n\n  err =\n    setsockopt (fd, IPPROTO_ICMPV6, ICMP6_FILTER, &filter, sizeof (filter));\n  if (err)\n    {\n      close (fd);\n      return NULL;\n    }\n\n  err = setsockopt (fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof (on));\n  if (err)\n    {\n      close (fd);\n      return NULL;\n    }\n\n  /* Allocate PING structure and initialize it to default values */\n  p = malloc (sizeof (*p));\n  if (!p)\n    {\n      close (fd);\n      return NULL;\n    }\n\n  memset (p, 0, sizeof (*p));\n\n  p->ping_fd = fd;\n  p->ping_count = DEFAULT_PING_COUNT;\n  p->ping_interval = PING_DEFAULT_INTERVAL;\n  p->ping_datalen = sizeof (struct timeval);\n  /* Make sure we use only 16 bits in this field, id for icmp is a unsigned short.  */\n  p->ping_ident = ident & 0xFFFF;\n  p->ping_cktab_size = PING_CKTABSIZE;\n  gettimeofday (&p->ping_start_time, NULL);\n  return p;\n}",
      "lines": 61,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "PING",
        "*\nping_init (int type _GL_UNUSED_PARAMETER, int ident)",
        "*"
      ]
    },
    "ping_xmit": {
      "start_point": [
        878,
        0
      ],
      "end_point": [
        914,
        1
      ],
      "content": "static int\nping_xmit (PING * p)\n{\n  int i, buflen;\n  struct icmp6_hdr *icmp6;\n\n  if (_ping_setbuf (p, USE_IPV6))\n    return -1;\n\n  buflen = p->ping_datalen + sizeof (struct icmp6_hdr);\n\n  /* Mark sequence number as sent */\n  _PING_CLR (p, p->ping_num_xmit);\n\n  icmp6 = (struct icmp6_hdr *) p->ping_buffer;\n  icmp6->icmp6_type = ICMP6_ECHO_REQUEST;\n  icmp6->icmp6_code = 0;\n  /* The checksum will be calculated by the TCP/IP stack.  */\n  icmp6->icmp6_cksum = 0;\n  icmp6->icmp6_id = htons (p->ping_ident);\n  icmp6->icmp6_seq = htons (p->ping_num_xmit);\n\n  i = sendto (p->ping_fd, (char *) p->ping_buffer, buflen, 0,\n\t      (struct sockaddr *) &p->ping_dest.ping_sockaddr6,\n\t      sizeof (p->ping_dest.ping_sockaddr6));\n  if (i < 0)\n    return -1;\n  else\n    {\n      p->ping_num_xmit++;\n      if (i != buflen)\n\tprintf (\"ping: wrote %s %d chars, ret=%d\\n\",\n\t\tp->ping_hostname, buflen, i);\n    }\n\n  return 0;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "my_echo_reply": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        926,
        1
      ],
      "content": "static int\nmy_echo_reply (PING * p, struct icmp6_hdr *icmp6)\n{\n  struct ip6_hdr *orig_ip = (struct ip6_hdr *) (icmp6 + 1);\n  struct icmp6_hdr *orig_icmp = (struct icmp6_hdr *) (orig_ip + 1);\n\n  return IN6_ARE_ADDR_EQUAL (&orig_ip->ip6_dst, &ping->ping_dest.ping_sockaddr6.sin6_addr)\n    && orig_ip->ip6_nxt == IPPROTO_ICMPV6\n    && orig_icmp->icmp6_type == ICMP6_ECHO_REQUEST\n    && orig_icmp->icmp6_id == htons (p->ping_ident);\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_recv": {
      "start_point": [
        928,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "static int\nping_recv (PING * p)\n{\n  int dupflag, n;\n  int hops = -1;\n  struct msghdr msg;\n  struct iovec iov;\n  struct icmp6_hdr *icmp6;\n  struct cmsghdr *cmsg;\n  char cmsg_data[1024];\n\n  iov.iov_base = p->ping_buffer;\n  iov.iov_len = _PING_BUFLEN (p, USE_IPV6);\n  msg.msg_name = &p->ping_from.ping_sockaddr6;\n  msg.msg_namelen = sizeof (p->ping_from.ping_sockaddr6);\n  msg.msg_iov = &iov;\n  msg.msg_iovlen = 1;\n  msg.msg_control = cmsg_data;\n  msg.msg_controllen = sizeof (cmsg_data);\n  msg.msg_flags = 0;\n\n  n = recvmsg (p->ping_fd, &msg, 0);\n  if (n < 0)\n    return -1;\n\n  for (cmsg = CMSG_FIRSTHDR (&msg); cmsg; cmsg = CMSG_NXTHDR (&msg, cmsg))\n    {\n      if (cmsg->cmsg_level == IPPROTO_IPV6\n\t  && cmsg->cmsg_type == IPV6_HOPLIMIT)\n\t{\n\t  hops = *(int *) CMSG_DATA (cmsg);\n\t  break;\n\t}\n    }\n\n  icmp6 = (struct icmp6_hdr *) p->ping_buffer;\n  if (icmp6->icmp6_type == ICMP6_ECHO_REPLY)\n    {\n      /* We got an echo reply.  */\n      if (ntohs (icmp6->icmp6_id) != p->ping_ident)\n\treturn -1;\t\t/* It's not a response to us.  */\n\n      if (_PING_TST (p, ntohs (icmp6->icmp6_seq)))\n\t{\n\t  /* We already got the reply for this echo request.  */\n\t  p->ping_num_rept++;\n\t  dupflag = 1;\n\t}\n      else\n\t{\n\t  _PING_SET (p, ntohs (icmp6->icmp6_seq));\n\t  p->ping_num_recv++;\n\t  dupflag = 0;\n\t}\n\n      print_echo (dupflag, hops, p->ping_closure, &p->ping_dest.ping_sockaddr6,\n\t\t  &p->ping_from.ping_sockaddr6, icmp6, n);\n\n    }\n  else\n    {\n      /* We got an error reply.  */\n      if (!my_echo_reply (p, icmp6))\n\treturn -1;\t\t/* It's not for us.  */\n\n      print_icmp_error (&p->ping_from.ping_sockaddr6, icmp6, n);\n    }\n\n  return 0;\n}",
      "lines": 70,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ping_set_dest": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1044,
        1
      ],
      "content": "static int\nping_set_dest (PING * ping, char *host)\n{\n  int err;\n  struct addrinfo *result, hints;\n  char *rhost;\n\n#ifdef HAVE_IDN\n  err = idna_to_ascii_lz (host, &rhost, 0);\n  if (err)\n    return 1;\n#else /* !HAVE_IDN */\n  rhost = host;\n#endif\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_INET6;\n  hints.ai_flags = AI_CANONNAME;\n#ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n#endif\n#ifdef AI_CANONIDN\n  hints.ai_flags |= AI_CANONIDN;\n#endif\n\n  err = getaddrinfo (rhost, NULL, &hints, &result);\n  if (err)\n    return 1;\n\n  memcpy (&ping->ping_dest.ping_sockaddr6, result->ai_addr, result->ai_addrlen);\n\n  if (result->ai_canonname)\n    ping->ping_hostname = strdup (result->ai_canonname);\n  else\n    ping->ping_hostname = strdup (rhost);\n\n#if HAVE_IDN\n  free (rhost);\n#endif\n  freeaddrinfo (result);\n\n  if (!ping->ping_hostname)\n    return 1;\n\n  return 0;\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping6.h": {},
  "inetutils/inetutils-1.9.4/ping/ping_address.c": {
    "ping_address": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nping_address (char *hostname)\n{\n  ping_set_type (ping, ICMP_ADDRESS);\n  ping_set_event_handler (ping, recv_address, NULL);\n  ping_set_packetsize (ping, ICMP_MASKLEN);\n  ping_set_count (ping, 1);\n\n  if (ping_set_dest (ping, hostname))\n    error (EXIT_FAILURE, 0, \"unknown host\");\n\n  printf (\"PING %s (%s): sending address mask request\\n\",\n\t  ping->ping_hostname, inet_ntoa (ping->ping_dest.ping_sockaddr.sin_addr));\n\n  return ping_run (ping, address_finish);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "recv_address": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nrecv_address (int code, void *closure,\n\t      struct sockaddr_in *dest, struct sockaddr_in *from,\n\t      struct ip *ip, icmphdr_t * icmp, int datalen)\n{\n  switch (code)\n    {\n    case PEV_RESPONSE:\n    case PEV_DUPLICATE:\n      print_address (code == PEV_DUPLICATE,\n\t\t     closure, dest, from, ip, icmp, datalen);\n      break;\n    case PEV_NOECHO:;\n      print_icmp_header (from, ip, icmp, datalen);\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "print_address": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nprint_address (int dupflag, void *closure _GL_UNUSED_PARAMETER,\n\t       struct sockaddr_in *dest _GL_UNUSED_PARAMETER,\n\t       struct sockaddr_in *from,\n\t       struct ip *ip _GL_UNUSED_PARAMETER,\n\t       icmphdr_t * icmp, int datalen)\n{\n  struct in_addr addr;\n\n  printf (\"%d bytes from %s: icmp_seq=%u\", datalen,\n\t  inet_ntoa (*(struct in_addr *) &from->sin_addr.s_addr),\n\t  ntohs (icmp->icmp_seq));\n  if (dupflag)\n    printf (\" (DUP!)\");\n  printf (\"\\n\");\n  addr.s_addr = icmp->icmp_mask;\n  printf (\"icmp_mask = %s\", inet_ntoa (addr));\n  printf (\"\\n\");\n  return;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "address_finish": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\naddress_finish (void)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping_common.c": {
    "ping_cvt_number": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "size_t\nping_cvt_number (const char *optarg, size_t maxval, int allow_zero)\n{\n  char *p;\n  unsigned long int n;\n\n  n = strtoul (optarg, &p, 0);\n  if (*p)\n    error (EXIT_FAILURE, 0, \"invalid value (`%s' near `%s')\", optarg, p);\n\n  if (n == 0 && !allow_zero)\n    error (EXIT_FAILURE, 0, \"option value too small: %s\", optarg);\n\n  if (maxval && n > maxval)\n    error (EXIT_FAILURE, 0, \"option value too big: %s\", optarg);\n\n  return n;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "init_data_buffer": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ninit_data_buffer (unsigned char * pat, size_t len)\n{\n  size_t i = 0;\n  unsigned char *p;\n\n  if (data_length == 0)\n    return;\n\n  data_buffer = xmalloc (data_length);\n\n  if (pat)\n    {\n      for (p = data_buffer; p < data_buffer + data_length; p++)\n\t{\n\t  *p = pat[i];\n\t  if (++i >= len)\n\t    i = 0;\n\t}\n    }\n  else\n    {\n      for (i = 0; i < data_length; i++)\n\tdata_buffer[i] = i;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "decode_pattern": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\ndecode_pattern (const char *text, int *pattern_len,\n\t\tunsigned char *pattern_data)\n{\n  int i, c, off;\n\n  for (i = 0; *text && i < *pattern_len; i++)\n    {\n      if (sscanf (text, \"%2x%n\", &c, &off) != 1)\n        error (EXIT_FAILURE, 0, \"error in pattern near %s\", text);\n\n      text += off;\n      pattern_data[i] = c;\n    }\n  *pattern_len = i;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tvsub": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void\ntvsub (struct timeval *out, struct timeval *in)\n{\n  if ((out->tv_usec -= in->tv_usec) < 0)\n    {\n      --out->tv_sec;\n      out->tv_usec += 1000000;\n    }\n  out->tv_sec -= in->tv_sec;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "nabs": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "double\nnabs (double a)\n{\n  return (a < 0) ? -a : a;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "nsqrt": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "double\nnsqrt (double a, double prec)\n{\n  double x0, x1;\n\n  if (a < 0)\n    return 0;\n  if (a < prec)\n    return 0;\n  x1 = a / 2;\n  do\n    {\n      x0 = x1;\n      x1 = (x0 + a / x0) / 2;\n    }\n  while (nabs (x1 - x0) > prec);\n\n  return x1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "is_normed_time": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nis_normed_time (n_time t)\n{\n  /* A set MSB indicates non-normalised time standard.  */\n  return (t & (1UL << 31)) ? 0 : 1;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ping_cvt_time": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "const char *\nping_cvt_time (char *buf, size_t buflen, n_time t)\n{\n  n_time t_red;\n\n  t_red = t & ((1UL << 31) - 1);\n\n  if (is_normed_time (t))\n    snprintf (buf, buflen, \"%u\", t_red);\n  else\n    snprintf (buf, buflen, \"<%u>\", t_red);\n\n  return buf;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nping_cvt_time (char *buf, size_t buflen, n_time t)",
        "*"
      ]
    },
    "_ping_setbuf": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\n_ping_setbuf (PING * p, bool use_ipv6)\n{\n  if (!p->ping_buffer)\n    {\n      p->ping_buffer = malloc (_PING_BUFLEN (p, use_ipv6));\n      if (!p->ping_buffer)\n\treturn -1;\n    }\n  if (!p->ping_cktab)\n    {\n      p->ping_cktab = malloc (p->ping_cktab_size);\n      if (!p->ping_cktab)\n\treturn -1;\n      memset (p->ping_cktab, 0, p->ping_cktab_size);\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "ping_set_data": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nping_set_data (PING * p, void *data, size_t off, size_t len, bool use_ipv6)\n{\n  icmphdr_t *icmp;\n\n  if (_ping_setbuf (p, use_ipv6))\n    return -1;\n  if (p->ping_datalen < off + len)\n    return -1;\n\n  icmp = (icmphdr_t *) p->ping_buffer;\n  memcpy (icmp->icmp_data + off, data, len);\n\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "ping_set_count": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nping_set_count (PING * ping, size_t count)\n{\n  ping->ping_count = count;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_set_sockopt": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void\nping_set_sockopt (PING * ping, int opt, void *val, int valsize)\n{\n  setsockopt (ping->ping_fd, SOL_SOCKET, opt, (char *) &val, valsize);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ping_set_interval": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "void\nping_set_interval (PING * ping, size_t interval)\n{\n  ping->ping_interval = interval;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "_ping_freebuf": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void\n_ping_freebuf (PING * p)\n{\n  if (p->ping_buffer)\n    {\n      free (p->ping_buffer);\n      p->ping_buffer = NULL;\n    }\n  if (p->ping_cktab)\n    {\n      free (p->ping_cktab);\n      p->ping_cktab = NULL;\n    }\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ping_unset_data": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void\nping_unset_data (PING * p)\n{\n  _ping_freebuf (p);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ping_timeout_p": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int\nping_timeout_p (struct timeval *start_time, int timeout)\n{\n  struct timeval now;\n  gettimeofday (&now, NULL);\n  if (timeout != -1)\n    {\n      tvsub (&now, start_time);\n      if (now.tv_sec >= timeout)\n        return 1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ipaddr2str": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "char *\nipaddr2str (struct sockaddr *from, socklen_t fromlen)\n{\n  int err;\n  size_t len;\n  char *buf, ipstr[INET6_ADDRSTRLEN], hoststr[256];\n\n  err = getnameinfo (from, fromlen, ipstr, sizeof (ipstr),\n\t\t     NULL, 0, NI_NUMERICHOST);\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      fprintf (stderr, \"ping: getnameinfo: %s\\n\", errmsg);\n      return xstrdup (\"unknown\");\n    }\n\n  if (options & OPT_NUMERIC)\n    return xstrdup (ipstr);\n\n  err = getnameinfo (from, fromlen, hoststr, sizeof (hoststr),\n\t\t     NULL, 0,\n#ifdef NI_IDN\n\t\t     NI_IDN | NI_NAMEREQD\n#else\n\t\t     NI_NAMEREQD\n#endif\n\t\t     );\n  if (err)\n    return xstrdup (ipstr);\n\n  len = strlen (ipstr) + strlen (hoststr) + 4;\t/* Pair of parentheses, a space\n\t\t\t\t\t\t   and a NUL. */\n  buf = xmalloc (len);\n  snprintf (buf, len, \"%s (%s)\", hoststr, ipstr);\n\n  return buf;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "char",
        "*\nipaddr2str (struct sockaddr *from, socklen_t fromlen)",
        "*"
      ]
    },
    "sinaddr2str": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "char *\nsinaddr2str (struct in_addr ina)\n{\n  struct hostent *hp;\n\n  if (options & OPT_NUMERIC)\n    return xstrdup (inet_ntoa (ina));\n\n  hp = gethostbyaddr ((char *) &ina, sizeof (ina), AF_INET);\n  if (hp == NULL)\n    return xstrdup (inet_ntoa (ina));\n  else\n    {\n      char *buf, *ipstr;\n      int len;\n\n      ipstr = inet_ntoa (ina);\n      len = strlen (ipstr) + 1;\n\n      if (hp->h_name)\n\tlen += strlen (hp->h_name) + 4;\t/* parentheses, space, and NUL */\n\n      buf = xmalloc (len);\n      if (hp->h_name)\n\tsnprintf (buf, len, \"%s (%s)\", hp->h_name, ipstr);\n      else\n\tsnprintf (buf, len, \"%s\", ipstr);\n      return buf;\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "char",
        "*\nsinaddr2str (struct in_addr ina)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping_common.h": {},
  "inetutils/inetutils-1.9.4/ping/ping_echo.c": {
    "ping_echo": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int\nping_echo (char *hostname)\n{\n#ifdef IP_OPTIONS\n  char rspace[MAX_IPOPTLEN];\t/* Maximal IP option space.  */\n#endif\n  struct ping_stat ping_stat;\n  int status;\n\n  if (options & OPT_FLOOD && options & OPT_INTERVAL)\n    error (EXIT_FAILURE, 0, \"-f and -i incompatible options\");\n\n  memset (&ping_stat, 0, sizeof (ping_stat));\n  ping_stat.tmin = 999999999.0;\n\n  ping_set_type (ping, ICMP_ECHO);\n  ping_set_packetsize (ping, data_length);\n  ping_set_event_handler (ping, handler, &ping_stat);\n\n  if (ping_set_dest (ping, hostname))\n    error (EXIT_FAILURE, 0, \"unknown host\");\n\n  if (options & OPT_RROUTE)\n    {\n#ifdef IP_OPTIONS\n      memset (rspace, 0, sizeof (rspace));\n      rspace[IPOPT_OPTVAL] = IPOPT_RR;\n      rspace[IPOPT_OLEN] = sizeof (rspace) - 1;\n      rspace[IPOPT_OFFSET] = IPOPT_MINOFF;\n      if (setsockopt (ping->ping_fd, IPPROTO_IP,\n\t\t      IP_OPTIONS, rspace, sizeof (rspace)) < 0)\n        error (EXIT_FAILURE, errno, \"setsockopt\");\n#else\n      error (EXIT_FAILURE, 0, \"record route not available in this \"\n             \"implementation.\");\n#endif /* IP_OPTIONS */\n    }\n  else if (options & OPT_IPTIMESTAMP)\n    {\n      int type;\n\n      if (suboptions & SOPT_TSPRESPEC)\n#ifdef IPOPT_TS_PRESPEC_RFC791\n\ttype = IPOPT_TS_PRESPEC_RFC791;\n#else\n\ttype = IPOPT_TS_PRESPEC;\n#endif\n      else if (suboptions & SOPT_TSADDR)\n\ttype = IPOPT_TS_TSANDADDR;\n      else\n        type = IPOPT_TS_TSONLY;\n\n#ifdef IP_OPTIONS\n      memset (rspace, 0, sizeof (rspace));\n      rspace[IPOPT_OPTVAL] = IPOPT_TS;\n      rspace[IPOPT_OLEN] = sizeof (rspace);\n      if (type != IPOPT_TS_TSONLY)\n\trspace[IPOPT_OLEN] -= sizeof (n_time);\t/* Exsessive part.  */\n      rspace[IPOPT_OFFSET] = IPOPT_MINOFF + 1;\n\n# ifdef IPOPT_POS_OV_FLG\n      rspace[IPOPT_POS_OV_FLG] = type;\n# else\n      rspace[3] = type;\n# endif /* !IPOPT_POS_OV_FLG */\n\n      if (setsockopt (ping->ping_fd, IPPROTO_IP,\n\t\t      IP_OPTIONS, rspace, rspace[IPOPT_OLEN]) < 0)\n        error (EXIT_FAILURE, errno, \"setsockopt\");\n#else /* !IP_OPTIONS */\n      error (EXIT_FAILURE, 0, \"IP timestamp not available in this \"\n             \"implementation.\");\n#endif /* IP_OPTIONS */\n    }\n\n  printf (\"PING %s (%s): %zu data bytes\",\n\t  ping->ping_hostname,\n\t  inet_ntoa (ping->ping_dest.ping_sockaddr.sin_addr), data_length);\n  if (options & OPT_VERBOSE)\n    printf (\", id 0x%04x = %u\", ping->ping_ident, ping->ping_ident);\n\n  printf (\"\\n\");\n\n  status = ping_run (ping, echo_finish);\n  free (ping->ping_hostname);\n  return status;\n}",
      "lines": 87,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "handler": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nhandler (int code, void *closure,\n\t struct sockaddr_in *dest, struct sockaddr_in *from,\n\t struct ip *ip, icmphdr_t * icmp, int datalen)\n{\n  switch (code)\n    {\n    case PEV_RESPONSE:\n    case PEV_DUPLICATE:\n      print_echo (code == PEV_DUPLICATE,\n\t\t  (struct ping_stat *) closure, dest, from, ip, icmp,\n\t\t  datalen);\n      break;\n    case PEV_NOECHO:;\n      print_icmp_header (from, ip, icmp, datalen);\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "print_echo": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "int\nprint_echo (int dupflag, struct ping_stat *ping_stat,\n\t    struct sockaddr_in *dest _GL_UNUSED_PARAMETER,\n\t    struct sockaddr_in *from,\n\t    struct ip *ip, icmphdr_t * icmp, int datalen)\n{\n  int hlen;\n  struct timeval tv;\n  int timing = 0;\n  double triptime = 0.0;\n\n  gettimeofday (&tv, NULL);\n\n  /* Length of IP header */\n  hlen = ip->ip_hl << 2;\n\n  /* Length of ICMP header+payload */\n  datalen -= hlen;\n\n  /* Do timing */\n  if (PING_TIMING (datalen - PING_HEADER_LEN))\n    {\n      struct timeval tv1, *tp;\n\n      timing++;\n      tp = (struct timeval *) icmp->icmp_data;\n\n      /* Avoid unaligned data: */\n      memcpy (&tv1, tp, sizeof (tv1));\n      tvsub (&tv, &tv1);\n\n      triptime = ((double) tv.tv_sec) * 1000.0 +\n\t((double) tv.tv_usec) / 1000.0;\n      ping_stat->tsum += triptime;\n      ping_stat->tsumsq += triptime * triptime;\n      if (triptime < ping_stat->tmin)\n\tping_stat->tmin = triptime;\n      if (triptime > ping_stat->tmax)\n\tping_stat->tmax = triptime;\n    }\n\n  if (options & OPT_QUIET)\n    return 0;\n  if (options & OPT_FLOOD)\n    {\n      putchar ('\\b');\n      return 0;\n    }\n\n  printf (\"%d bytes from %s: icmp_seq=%u\", datalen,\n\t  inet_ntoa (*(struct in_addr *) &from->sin_addr.s_addr),\n\t  ntohs (icmp->icmp_seq));\n  printf (\" ttl=%d\", ip->ip_ttl);\n  if (timing)\n    printf (\" time=%.3f ms\", triptime);\n  if (dupflag)\n    printf (\" (DUP!)\");\n\n  print_ip_opt (ip, hlen);\n  printf (\"\\n\");\n\n  return 0;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "print_icmp_code": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static void\nprint_icmp_code (int type, int code, char *prefix)\n{\n  struct icmp_code_descr *p;\n\n  for (p = icmp_code_descr; p < icmp_code_descr + NITEMS (icmp_code_descr);\n       p++)\n    if (p->type == type && p->code == code)\n      {\n\tprintf (\"%s\\n\", p->diag);\n\treturn;\n      }\n\n  printf (\"%s, Unknown Code: %d\\n\", prefix, code);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_ip_header": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "static void\nprint_ip_header (struct ip *ip)\n{\n  size_t hlen;\n  unsigned char *cp;\n\n  hlen = ip->ip_hl << 2;\n  cp = (unsigned char *) ip + sizeof (*ip);\t/* point to options */\n\n  if (options & OPT_VERBOSE)\n    {\n      size_t j;\n\n      printf (\"IP Hdr Dump:\\n \");\n      for (j = 0; j < sizeof (*ip); ++j)\n\tprintf (\"%02x%s\", *((unsigned char *) ip + j),\n\t\t(j % 2) ? \" \" : \"\");\t/* Group bytes two by two.  */\n      printf (\"\\n\");\n    }\n\n  printf\n    (\"Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src\\tDst\\tData\\n\");\n  printf (\" %1x  %1x  %02x\", ip->ip_v, ip->ip_hl, ip->ip_tos);\n  /*\n   * The member `ip_len' is not portably reported in any byte order.\n   * Use a simple heuristic to print a reasonable value.\n   */\n  printf (\" %04x %04x\",\n\t  (ip->ip_len > 0x2000) ? ntohs (ip->ip_len) : ip->ip_len,\n\t  ntohs (ip->ip_id));\n  printf (\"   %1x %04x\", (ntohs (ip->ip_off) & 0xe000) >> 13,\n\t  ntohs (ip->ip_off) & 0x1fff);\n  printf (\"  %02x  %02x %04x\", ip->ip_ttl, ip->ip_p, ntohs (ip->ip_sum));\n  printf (\" %s \", inet_ntoa (*((struct in_addr *) &ip->ip_src)));\n  printf (\" %s \", inet_ntoa (*((struct in_addr *) &ip->ip_dst)));\n  while (hlen-- > sizeof (*ip))\n    printf (\"%02x\", *cp++);\n\n  printf (\"\\n\");\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_ip_data": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "void\nprint_ip_data (icmphdr_t * icmp, void *data _GL_UNUSED_PARAMETER)\n{\n  int hlen;\n  unsigned char *cp;\n  struct ip *ip = &icmp->icmp_ip;\n\n  print_ip_header (ip);\n\n  hlen = ip->ip_hl << 2;\n  cp = (unsigned char *) ip + hlen;\n\n  if (ip->ip_p == IPPROTO_TCP)\n    printf (\"TCP: from port %u, to port %u (decimal)\\n\",\n\t    (*cp * 256 + *(cp + 1)), (*(cp + 2) * 256 + *(cp + 3)));\n  else if (ip->ip_p == IPPROTO_UDP)\n    printf (\"UDP: from port %u, to port %u (decimal)\\n\",\n\t    (*cp * 256 + *(cp + 1)), (*(cp + 2) * 256 + *(cp + 3)));\n  else if (ip->ip_p == IPPROTO_ICMP)\n    {\n      int type = *cp;\n      int code = *(cp + 1);\n\n      printf (\"ICMP: type %u, code %u, size %u\", type, code,\n\t      ntohs (ip->ip_len) - hlen);\n      if (type == ICMP_ECHOREPLY || type == ICMP_ECHO)\n\tprintf (\", id 0x%04x, seq 0x%04x\", *(cp + 4) * 256 + *(cp + 5),\n\t\t*(cp + 6) * 256 + *(cp + 7));\n      printf (\"\\n\");\n    }\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "print_icmp": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static void\nprint_icmp (icmphdr_t * icmp, void *data)\n{\n  print_icmp_code (icmp->icmp_type, icmp->icmp_code, data);\n  if (options & OPT_VERBOSE)\n    print_ip_data (icmp, NULL);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_parameterprob": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static void\nprint_parameterprob (icmphdr_t * icmp, void *data)\n{\n  printf (\"Parameter problem: IP address = %s\\n\",\n\t  inet_ntoa (icmp->icmp_gwaddr));\n  print_ip_data (icmp, data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_icmp_header": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "void\nprint_icmp_header (struct sockaddr_in *from,\n\t\t   struct ip *ip, icmphdr_t * icmp, int len)\n{\n  int hlen;\n  struct ip *orig_ip;\n  char *s;\n  struct icmp_diag *p;\n\n  /* Length of the IP header */\n  hlen = ip->ip_hl << 2;\n  /* Original IP header */\n  orig_ip = &icmp->icmp_ip;\n\n  if (!(options & OPT_VERBOSE\n\t|| orig_ip->ip_dst.s_addr == ping->ping_dest.ping_sockaddr.sin_addr.s_addr))\n    return;\n\n  s = ipaddr2str ((struct sockaddr *) from, sizeof (*from));\n  printf (\"%d bytes from %s: \", len - hlen, s);\n  free (s);\n\n  for (p = icmp_diag; p < icmp_diag + NITEMS (icmp_diag); p++)\n    {\n      if (p->type == icmp->icmp_type)\n\t{\n\t  if (p->text)\n\t    printf (\"%s\\n\", p->text);\n\t  if (p->fun)\n\t    p->fun (icmp, p->data);\n\t  return;\n\t}\n    }\n  printf (\"Bad ICMP type: %d\\n\", icmp->icmp_type);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "print_ip_opt": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "void\nprint_ip_opt (struct ip *ip, int hlen)\n{\n  unsigned char *cp;\n  int i, j, k, l;\n  static int old_rrlen;\n  static char old_rr[MAX_IPOPTLEN];\n\n  cp = (unsigned char *) (ip + 1);\n\n  for (; hlen > (int) sizeof (struct ip); --hlen, ++cp)\n    switch (*cp)\n      {\n      case IPOPT_EOL:\n\thlen = 0;\n\tbreak;\n\n      case IPOPT_LSRR:\n      case IPOPT_SSRR:\n\tprintf (\"\\n%cSRR: \", (*cp == IPOPT_LSRR) ? 'L' : 'S');\n\thlen -= 2;\n\tj = *++cp;\n\t++cp;\n\tif (j > IPOPT_MINOFF)\n\t  for (;;)\n\t    {\n\t      /* Fetch in network byte order, calculate as host.  */\n\t      l = *++cp;\n\t      l = (l << 8) + *++cp;\n\t      l = (l << 8) + *++cp;\n\t      l = (l << 8) + *++cp;\n\t      if (l == 0)\n\t\t{\n\t\t  printf (\"\\t0.0.0.0\");\n\t\t}\n\t      else\n\t\t{\n\t\t  struct in_addr ina;\n\t\t  char *s;\n\n\t\t  ina.s_addr = htonl (l);\n\t\t  printf (\"\\t%s\", s = sinaddr2str (ina));\n\t\t  free (s);\n\t\t}\n\t      hlen -= 4;\n\t      j -= 4;\n\t      if (j <= IPOPT_MINOFF)\n\t\tbreak;\n\t      putchar ('\\n');\n\t    }\n\tbreak;\n\n      case IPOPT_RR:\n\tj = *++cp;\n\ti = *++cp;\n\thlen -= 2;\n\tif (i > j)\n\t  i = j;\n\ti -= IPOPT_MINOFF;\n\tif (i <= 0)\n\t  break;\n\tif (i == old_rrlen\n\t    && cp == (unsigned char *) (ip + 1) + 2\n\t    && !memcmp ((char *) cp, old_rr, i) && !(options & OPT_FLOOD))\n\t  {\n\t    printf (\"\\t (same route)\");\n\t    i = ((i + 3) / 4) * 4;\n\t    hlen -= i;\n\t    cp += i;\n\t    break;\n\t  }\n\tif (i < MAX_IPOPTLEN)\n\t  {\n\t    old_rrlen = i;\n\t    memmove (old_rr, cp, i);\n\t  }\n\telse\n\t  old_rrlen = 0;\n\n\tprintf (\"\\nRR: \");\n\tj = 0;\n\tfor (;;)\n\t  {\n\t    /* Fetch in network byte order, calculate as host.  */\n\t    l = *++cp;\n\t    l = (l << 8) + *++cp;\n\t    l = (l << 8) + *++cp;\n\t    l = (l << 8) + *++cp;\n\t    if (l == 0)\n\t      {\n\t\tprintf (\"\\t0.0.0.0\");\n\t      }\n\t    else\n\t      {\n\t\tstruct in_addr ina;\n\t\tchar *s;\n\n\t\tina.s_addr = htonl (l);\n\t\tprintf (\"\\t%s\", s = sinaddr2str (ina));\n\t\tfree (s);\n\t      }\n\t    hlen -= 4;\n\t    i -= 4;\n\t    j += 4;\n\t    if (i <= 0)\n\t      break;\n\t    if (j >= MAX_IPOPTLEN)\n\t      {\n\t\tprintf (\"\\t (truncated route)\");\n\t\tbreak;\n\t      }\n\t    putchar ('\\n');\n\t  }\n\tbreak;\n\n      case IPOPT_TS:\n\tj = *++cp;\t/* len */\n\ti = *++cp;\t/* ptr */\n\thlen -= 2;\n\tif (i > j)\n\t  i = j;\n\n\t/* Check minimal sizing.  */\n\tif (j <= (int) (IPOPT_MINOFF + sizeof (n_time)))\n\t  break;\n\n\tk = *++cp;\t/* OV, FL */\n\t++cp;\t\t/* Points at first content.  */\n\thlen -= 2;\n\n\tprintf (\"\\nTS:\");\n\tj = 5;\t\t/* First possible slot.  */\n\tfor (;;)\n\t  {\n\t    char timestr[16];\n\n\t    if ((k & 0x0f) != IPOPT_TS_TSONLY\n\t\t&& ((j / 4) % 2 == 1))\t/* find 5, 13, 21, 29 */\n\t      {\n\t\t/* IP addresses */\n\t\tstruct in_addr ina;\n\t\tchar *s;\n\n\t\tina.s_addr = *((in_addr_t *) cp);\n\t\tprintf (\"\\t%s\", s = sinaddr2str (ina));\n\t\tfree (s);\n\n\t\thlen -= sizeof (in_addr_t);\n\t\tcp += sizeof (in_addr_t);\n\t\tj += sizeof (in_addr_t);\n\t      }\n\t    else\n\t      {\n\t\t/* Timestamps */\n\t\tprintf (\"\\t%s ms\",\n\t\t\tping_cvt_time (timestr, sizeof (timestr),\n\t\t\t\t\tntohl (*(n_time *) cp)));\n\t\tif (options & OPT_VERBOSE)\n\t\t  printf (\" = 0x%08x\", ntohl (*(n_time *) cp));\n\n\t\thlen -= sizeof (n_time);\n\t\tcp += sizeof (n_time);\n\t\tj += sizeof (n_time);\n\n\t\tputchar ('\\n');\n\t      }\n\n\t    if (j >= i)\n\t      break;\n\t  }\n\n\tif (k & 0xf0)\n\t  printf (\"\\t(%u overflowing hosts)\", k >> 4);\n\tbreak;\n\n      case IPOPT_NOP:\n\tprintf (\"\\nNOP\");\n\tbreak;\n\n      default:\n\tprintf (\"\\nunknown option %x\", *cp);\n\tbreak;\n      }\n}",
      "lines": 184,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "echo_finish": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "int\necho_finish (void)\n{\n  ping_finish ();\n  if (ping->ping_num_recv && PING_TIMING (data_length))\n    {\n      struct ping_stat *ping_stat = (struct ping_stat *) ping->ping_closure;\n      double total = ping->ping_num_recv + ping->ping_num_rept;\n      double avg = ping_stat->tsum / total;\n      double vari = ping_stat->tsumsq / total - avg * avg;\n\n      printf (\"round-trip min/avg/max/stddev = %.3f/%.3f/%.3f/%.3f ms\\n\",\n\t      ping_stat->tmin, avg, ping_stat->tmax, nsqrt (vari, 0.0005));\n    }\n  return (ping->ping_num_recv == 0);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping_impl.h": {},
  "inetutils/inetutils-1.9.4/ping/ping_router.c": {
    "ping_router": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nping_router (char *hostname _GL_UNUSED_PARAMETER)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/ping/ping_timestamp.c": {
    "ping_timestamp": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nping_timestamp (char *hostname)\n{\n  ping_set_type (ping, ICMP_TIMESTAMP);\n  ping_set_event_handler (ping, recv_timestamp, NULL);\n  ping_set_packetsize (ping, ICMP_TSLEN);\n\n  if (ping_set_dest (ping, hostname))\n    error (EXIT_FAILURE, 0, \"unknown host\");\n\n  printf (\"PING %s (%s): sending timestamp requests\\n\",\n\t  ping->ping_hostname, inet_ntoa (ping->ping_dest.ping_sockaddr.sin_addr));\n\n  return ping_run (ping, timestamp_finish);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "recv_timestamp": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\nrecv_timestamp (int code, void *closure,\n\t\tstruct sockaddr_in *dest, struct sockaddr_in *from,\n\t\tstruct ip *ip, icmphdr_t * icmp, int datalen)\n{\n  switch (code)\n    {\n    case PEV_RESPONSE:\n    case PEV_DUPLICATE:\n      print_timestamp (code == PEV_DUPLICATE,\n\t\t       closure, dest, from, ip, icmp, datalen);\n      break;\n    case PEV_NOECHO:;\n      print_icmp_header (from, ip, icmp, datalen);\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "print_timestamp": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nprint_timestamp (int dupflag, void *closure _GL_UNUSED_PARAMETER,\n\t\t struct sockaddr_in *dest _GL_UNUSED_PARAMETER,\n\t\t struct sockaddr_in *from,\n\t\t struct ip *ip _GL_UNUSED_PARAMETER,\n\t\t icmphdr_t * icmp, int datalen)\n{\n  char timestr[16];\n\n  printf (\"%d bytes from %s: icmp_seq=%u\", datalen,\n\t  inet_ntoa (*(struct in_addr *) &from->sin_addr.s_addr),\n\t  ntohs (icmp->icmp_seq));\n  if (dupflag)\n    printf (\" (DUP!)\");\n  printf (\"\\n\");\n  printf (\"icmp_otime = %s\\n\",\n\t  ping_cvt_time (timestr, sizeof (timestr),\n\t\t\t ntohl (icmp->icmp_otime)));\n  printf (\"icmp_rtime = %s\\n\",\n\t  ping_cvt_time (timestr, sizeof (timestr),\n\t\t\t ntohl (icmp->icmp_rtime)));\n  printf (\"icmp_ttime = %s\\n\",\n\t  ping_cvt_time (timestr, sizeof (timestr),\n\t\t\t ntohl (icmp->icmp_ttime)));\n\n  if ((options & OPT_VERBOSE)\n      && is_normed_time (ntohl (icmp->icmp_otime))\n      && is_normed_time (ntohl (icmp->icmp_otime)))\n    printf (\"difference = %d ms\\n\",\n\t    ntohl (icmp->icmp_ttime) - ntohl (icmp->icmp_otime));\n\n  return;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "timestamp_finish": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\ntimestamp_finish (void)\n{\n  return ping_finish ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/dnsdomainname.c": {
    "dnsdomainname": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\ndnsdomainname (void)\n{\n  char *host_name;\n  struct addrinfo hints, *res;\n  const char *dn;\n  int rc;\n\n  host_name = xgethostname ();\n  if (!host_name)\n    error (EXIT_FAILURE, errno, \"cannot determine host name\");\n\n  memset (&hints, 0, sizeof (struct addrinfo));\n  hints.ai_flags = AI_CANONNAME;\n\n  rc = getaddrinfo (host_name, NULL, &hints, &res);\n  if (rc != 0)\n    error (EXIT_FAILURE, 0, \"%s\", gai_strerror (rc));\n\n  dn = strchr (res->ai_canonname, '.');\n  if (dn)\n    puts (dn + 1);\n\n  free (host_name);\n  freeaddrinfo (res);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  set_program_name (argv[0]);\n\n  iu_argp_init (\"dnsdomainname\", program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  dnsdomainname ();\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/hostname.c": {
    "parse_opt": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  hostname_arguments *const args = (hostname_arguments *const) state->input;\n\n  switch (key)\n    {\n    case 'a':\n      get_name_action = xgethostname;\n      args->hostname_alias = 1;\n      break;\n\n    case 'd':\n      get_name_action = xgethostname;\n      args->hostname_fqdn = 1;\n      args->hostname_dns_domain = 1;\n      break;\n\n    case 'F':\n      set_name_action = sethostname;\n      args->hostname_file = arg;\n      break;\n\n    case 'f':\n      get_name_action = xgethostname;\n      args->hostname_fqdn = 1;\n      break;\n\n    case 'i':\n      get_name_action = xgethostname;\n      args->hostname_ip_address = 1;\n      break;\n\n    case 's':\n      get_name_action = xgethostname;\n      args->hostname_fqdn = 1;\n      args->hostname_short = 1;\n      break;\n\n    case 'y':\n      get_name_action = xgetdomainname;\n      break;\n\n    case ARGP_KEY_ARG:\n      set_name_action = sethostname;\n      args->hostname_new = strdup (arg);\n      if (args->hostname_new == NULL)\n        error (EXIT_FAILURE, errno, \"strdup\");\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 56,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  hostname_arguments args;\n\n  set_program_name (argv[0]);\n\n  memset ((void *) &args, 0, sizeof (args));\n\n  /* Parse command line */\n  iu_argp_init (\"hostname\", program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, (void *) &args);\n\n  /* Set default action */\n  if (get_name_action == NULL && set_name_action ==  NULL)\n    get_name_action = xgethostname;\n\n  if (get_name_action == xgetdomainname || get_name_action == xgethostname)\n    get_name (&args);\n  else if (set_name_action == sethostname)\n    set_name (&args);\n\n  return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "get_name": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static void\nget_name (const hostname_arguments *const args)\n{\n  char *sname, *name;\n\n  sname = (*get_name_action) ();\n\n  if (!sname)\n    error (EXIT_FAILURE, errno, \"cannot determine name\");\n\n  if (args->hostname_alias == 1)\n    name = get_aliases (sname);\n  else if (args->hostname_fqdn == 1)\n    {\n      name = get_fqdn (sname);\n\n      if (args->hostname_dns_domain == 1 || args->hostname_short == 1)\n\t{\n\t  /* Eliminate empty replies, as well as `(none)'.  */\n\t  if (name && *name && *name != '(')\n\t    {\n\t      free (sname);\n\t      sname = name;\n\t      name = NULL;\n\t    }\n\t  else if (name && *name == '(')\n\t    {\n\t      free (name);\n\t      name = NULL;\n\t    }\n\t}\n\n      if (args->hostname_dns_domain == 1)\n        name = get_dns_domain_name (sname);\n      else if (args->hostname_short == 1)\n        name = get_short_hostname (sname);\n    }\n  else if (args->hostname_ip_address == 1)\n      name = get_ip_addresses (sname);\n  else\n    {\n      name = strdup (sname);\n      if (name == NULL)\n        error (EXIT_FAILURE, errno, \"strdup\");\n    }\n\n  if (name && *name)\n    puts (name);\n\n  free (name);\n  free (sname);\n  return;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_name": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static void\nset_name (const hostname_arguments *const args)\n{\n  char *hostname_new;\n  int status;\n  size_t size;\n\n  if (args->hostname_file != NULL)\n    hostname_new = parse_file (args->hostname_file);\n  else\n    hostname_new = args->hostname_new;\n\n  size = strlen (hostname_new);\n  if (!size)\n    error (EXIT_FAILURE, 0, \"Empty hostname\");\n\n  status = (*set_name_action) (hostname_new, size);\n  if (status == -1)\n    error (EXIT_FAILURE, errno, \"sethostname\");\n\n  free (hostname_new);\n  return;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_aliases": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "static char *\nget_aliases (const char *const host_name)\n{\n  char *aliases;\n  unsigned int count = 0;\n  unsigned int i;\n  unsigned int size = 256;\n  struct hostent *ht;\n\n  aliases = xmalloc (sizeof (char) * size);\n  aliases[0] = '\\0';\n\n  ht = gethostbyname (host_name);\n  if (ht == NULL)\n    strcpy (aliases, \"\");\t/* Be honest about missing aliases.  */\n  else\n    {\n      for (i = 0; ht->h_aliases[i] != NULL; i++)\n        {\n          /* Aliases should be blankspace separated. */\n          if (ht->h_aliases[i+1] != NULL)\n            count++;\n          count += strlen (ht->h_aliases[i]);\n          if (count >= size)\n            {\n              size *= 2;\n              aliases = xrealloc (aliases, size);\n            }\n\n          strcat (aliases, ht->h_aliases[i]);\n          strcat (aliases, \" \");\n        }\n    }\n\n  return aliases;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_aliases (const char *const host_name)",
        "*"
      ]
    },
    "get_fqdn": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static char *\nget_fqdn (const char *const host_name)\n{\n  char *fqdn;\n  struct hostent *ht;\n\n  ht = gethostbyname (host_name);\n  if (ht == NULL)\n    fqdn = strdup (host_name);\t/* Fall back to system name.  */\n  else\n    fqdn = strdup (ht->h_name);\n\n  if (fqdn == NULL)\n    error (EXIT_FAILURE, errno, \"strdup\");\n\n  return fqdn;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_fqdn (const char *const host_name)",
        "*"
      ]
    },
    "get_ip_addresses": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static char *\nget_ip_addresses (const char *const host_name)\n{\n  char address[16];\n  char *addresses;\n  unsigned int count = 0;\n  unsigned int i;\n  unsigned int size = 256;\n  struct hostent *ht;\n\n  addresses = xmalloc (sizeof (char) * size);\n  addresses[0] = '\\0';\n\n  ht = gethostbyname (host_name);\n  if (ht == NULL)\n#if HAVE_HSTRERROR\n    error (EXIT_FAILURE, 0, \"gethostbyname: %s\", hstrerror (h_errno));\n#else\n    strcpy (addresses, \"(none)\");\n#endif\n  else\n    {\n      for (i = 0; ht->h_addr_list[i] != NULL; i++)\n        {\n          inet_ntop (ht->h_addrtype, (void *) ht->h_addr_list[i],\n                     address, sizeof (address));\n\n          /* IP addresses should be blankspace separated. */\n          if (ht->h_addr_list[i+1] != NULL)\n            count++;\n          count += strlen (address);\n          if (count >= size)\n            {\n              size *= 2;\n              addresses = xrealloc (addresses, size);\n            }\n\n          strcat (addresses, address);\n          strcat (addresses, \" \");\n        }\n    }\n\n  return addresses;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_ip_addresses (const char *const host_name)",
        "*"
      ]
    },
    "get_dns_domain_name": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "static char *\nget_dns_domain_name (const char *const host_name)\n{\n  char *domain_name;\n  const char * pos;\n\n  pos = strchr (host_name, '.');\n  if (pos == NULL)\n    domain_name = strdup (\"(none)\");\n  else\n    domain_name = strdup (pos+1);\n\n  if (domain_name == NULL)\n    error (EXIT_FAILURE, errno, \"strdup\");\n\n  return domain_name;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_dns_domain_name (const char *const host_name)",
        "*"
      ]
    },
    "get_short_hostname": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static char *\nget_short_hostname (const char *const host_name)\n{\n  size_t size;\n  char *short_hostname;\n  const char * pos;\n\n  pos = strchr (host_name, '.');\n  if (pos == NULL)\n    short_hostname = strdup (host_name);\n  else\n    {\n      size = pos - host_name;\n      short_hostname = strndup (host_name, size);\n    }\n\n  if (short_hostname == NULL)\n    error (EXIT_FAILURE, errno, \"strdup\");\n\n  return short_hostname;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_short_hostname (const char *const host_name)",
        "*"
      ]
    },
    "parse_file": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static char *\nparse_file (const char *const file_name)\n{\n  char *buffer = NULL;\n  char *name = NULL;\n  FILE *file;\n  ssize_t nread;\n  size_t size = 0;\n\n  file = fopen (file_name, \"r\");\n  if (file == NULL)\n    error (EXIT_FAILURE, errno, \"fopen\");\n\n  errno = 0;\t\t\t/* Portability issue!  */\n\n  do\n    {\n      nread = getline (&buffer, &size, file);\n      if (nread == -1)\n\terror (EXIT_FAILURE, errno, \"getline%s\", errno ? \"\" : \": No text\");\n\n      if (buffer[0] != '#')\n        {\n\t  name = (char *) xmalloc (sizeof (char) * nread);\n\t  if (sscanf (buffer, \"%s\", name)  == 1)\n\t    break;\n        }\n    }\n  while (feof (file) == 0);\n\n  free (buffer);\n  fclose (file);\n  return name;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nparse_file (const char *const file_name)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/inetd.c": {
    "parse_opt": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  char *p;\n  int number;\n\n  switch (key)\n    {\n    case 'd':\n      debug = true;\n      options |= SO_DEBUG;\n      break;\n\n    case OPT_ENVIRON:\n      env_option = true;\n      break;\n\n    case 'p':\n      if (arg && strlen (arg))\n\tpid_file = arg;\n      else\n\tpidfile_option = false;\n      break;\n\n    case 'R':\n      number = strtol (arg, &p, 0);\n      if (number < 1 || *p)\n        syslog (LOG_ERR, \"-R %s: bad value for service invocation rate\", arg);\n      else\n        toomany = number;\n      break;\n\n    case OPT_RESOLVE:\n      resolve_option = true;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "bi_lookup": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "struct biltin *\nbi_lookup (const struct servtab *sep)\n{\n  struct biltin *bi;\n\n  for (bi = biltins; bi->bi_service; bi++)\n    if (bi->bi_socktype == sep->se_socktype\n\t&& strcmp (bi->bi_service, sep->se_service) == 0)\n      return bi;\n  return NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct biltin",
        "struct",
        "biltin",
        "*\nbi_lookup (const struct servtab *sep)",
        "*"
      ]
    },
    "signal_set_handler": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "void\nsignal_set_handler (int signo, void (*handler) ())\n{\n#if defined HAVE_SIGACTION\n  struct sigaction sa;\n  memset ((char *) &sa, 0, sizeof (sa));\n  sigemptyset (&sa.sa_mask);\n  sigaddset (&sa.sa_mask, signo);\n# ifdef SA_RESTART\n  sa.sa_flags = SA_RESTART;\n# endif\n  sa.sa_handler = handler;\n  sigaction (signo, &sa, NULL);\n#elif defined(HAVE_SIGVEC)\n  struct sigvec sv;\n  memset (&sv, 0, sizeof (sv));\n  sv.sv_mask = SIGBLOCK;\n  sv.sv_handler = handler;\n  sigvec (signo, &sv, NULL);\n#else /* !HAVE_SIGVEC */\n  signal (signo, handler);\n#endif /* HAVE_SIGACTION */\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "signal_block": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "void\nsignal_block (SIGSTATUS * old_status)\n{\n#ifdef HAVE_SIGACTION\n  sigset_t sigs;\n\n  sigemptyset (&sigs);\n  sigaddset (&sigs, SIGCHLD);\n  sigaddset (&sigs, SIGHUP);\n  sigaddset (&sigs, SIGALRM);\n  sigprocmask (SIG_BLOCK, &sigs, old_status);\n#else\n  long omask = sigblock (SIGBLOCK);\n  if (old_status)\n    *old_status = omask;\n#endif\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "signal_unblock": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "void\nsignal_unblock (SIGSTATUS * status)\n{\n#ifdef HAVE_SIGACTION\n  if (status)\n    sigprocmask (SIG_SETMASK, status, 0);\n  else\n    {\n      sigset_t empty;\n      sigemptyset (&empty);\n      sigprocmask (SIG_SETMASK, &empty, 0);\n    }\n#else\n  sigsetmask (status ? *status : 0);\n#endif\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "run_service": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "void\nrun_service (int ctrl, struct servtab *sep)\n{\n  struct passwd *pwd;\n  struct group *grp = NULL;\n  char buf[50];\n\n  if (sep->se_bi)\n    {\n      (*sep->se_bi->bi_fn) (ctrl, sep);\n    }\n  else\n    {\n      if (debug)\n\tfprintf (stderr, \"%d execl %s\\n\", (int) getpid (), sep->se_server);\n      dup2 (ctrl, 0);\n      close (ctrl);\n      dup2 (0, 1);\n      dup2 (0, 2);\n      pwd = getpwnam (sep->se_user);\n      if (pwd == NULL)\n\t{\n\t  syslog (LOG_ERR, \"%s/%s: %s: No such user\",\n\t\t  sep->se_service, sep->se_proto, sep->se_user);\n\t  if (sep->se_socktype != SOCK_STREAM)\n\t    recv (0, buf, sizeof buf, 0);\n\t  _exit (EXIT_FAILURE);\n\t}\n      if (sep->se_group && *sep->se_group)\n\t{\n\t  grp = getgrnam (sep->se_group);\n\t  if (grp == NULL)\n\t    {\n\t      syslog (LOG_ERR, \"%s/%s: %s: No such group\",\n\t\t      sep->se_service, sep->se_proto, sep->se_group);\n\t      if (sep->se_socktype != SOCK_STREAM)\n\t\trecv (0, buf, sizeof buf, 0);\n\t      _exit (EXIT_FAILURE);\n\t    }\n\t}\n      if (pwd->pw_uid)\n\t{\n\t  if (grp && grp->gr_gid)\n\t    {\n\t      if (setgid (grp->gr_gid) < 0)\n\t\t{\n\t\t  syslog (LOG_ERR, \"%s: can't set gid %d: %m\",\n\t\t\t  sep->se_service, grp->gr_gid);\n\t\t  _exit (EXIT_FAILURE);\n\t\t}\n\t    }\n\t  else if (setgid (pwd->pw_gid) < 0)\n\t    {\n\t      syslog (LOG_ERR, \"%s: can't set gid %d: %m\",\n\t\t      sep->se_service, pwd->pw_gid);\n\t      _exit (EXIT_FAILURE);\n\t    }\n#ifdef HAVE_INITGROUPS\n\t  initgroups (pwd->pw_name,\n\t\t      (grp && grp->gr_gid) ? grp->gr_gid : pwd->pw_gid);\n#endif\n\t  if (setuid (pwd->pw_uid) < 0)\n\t    {\n\t      syslog (LOG_ERR, \"%s: can't set uid %d: %m\",\n\t\t      sep->se_service, pwd->pw_uid);\n\t      _exit (EXIT_FAILURE);\n\t    }\n\t}\n      execv (sep->se_server, sep->se_argv);\n      if (sep->se_socktype != SOCK_STREAM)\n\trecv (0, buf, sizeof buf, 0);\n      syslog (LOG_ERR, \"cannot execute %s: %m\", sep->se_server);\n      _exit (EXIT_FAILURE);\n    }\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "reapchild": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "void\nreapchild (int signo _GL_UNUSED_PARAMETER)\n{\n  int status;\n  pid_t pid;\n  struct servtab *sep;\n\n  for (;;)\n    {\n#ifdef HAVE_WAIT3\n      pid = wait3 (&status, WNOHANG, NULL);\n#else\n      pid = wait (&status);\n#endif\n      if (pid <= 0)\n\tbreak;\n      if (debug)\n\tfprintf (stderr, \"%d reaped, status %#x\\n\", (int) pid, status);\n      for (sep = servtab; sep; sep = sep->se_next)\n\tif (sep->se_wait == pid)\n\t  {\n\t    if (status)\n\t      syslog (LOG_WARNING, \"%s: exit status 0x%x\",\n\t\t      sep->se_server, status);\n\t    if (debug)\n\t      fprintf (stderr, \"restored %s, fd %d\\n\",\n\t\t       sep->se_service, sep->se_fd);\n\t    FD_SET (sep->se_fd, &allsock);\n\t    nsock++;\n\t    sep->se_wait = 1;\n\t  }\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "newstr": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "char *\nnewstr (const char *cp)\n{\n  char *s;\n  s = strdup (cp ? cp : \"\");\n  if (s != NULL)\n    return s;\n  syslog (LOG_ERR, \"strdup: %m\");\n  exit (-1);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "char",
        "*\nnewstr (const char *cp)",
        "*"
      ]
    },
    "dupmem": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "void\ndupmem (void **pptr, size_t size)\n{\n  void *ptr = malloc (size);\n  if (!ptr)\n    {\n      syslog (LOG_ERR, \"dupmem: %m\");\n      exit (-1);\n    }\n  memcpy (ptr, *pptr, size);\n  *pptr = ptr;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dupstr": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "void\ndupstr (char **pstr)\n{\n  if (*pstr)\n    dupmem ((void**)pstr, strlen (*pstr) + 1);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_service": {
      "start_point": [
        562,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "void\nprint_service (const char *action, struct servtab *sep)\n{\n  fprintf (stderr,\n\t   \"%s:%d: %s: %s:%s proto=%s, wait=%d, max=%u, \"\n\t   \"user=%s group=%s builtin=%s server=%s\\n\",\n\t   sep->se_file, sep->se_line,\n\t   action,\n\t   ISMUX (sep) ? (ISMUXPLUS (sep) ? \"tcpmuxplus\" : \"tcpmux\")\n\t\t      : (sep->se_node ? sep->se_node : \"*\"),\n\t   sep->se_service, sep->se_proto,\n\t   (int) sep->se_wait, sep->se_max,\n\t   sep->se_user, sep->se_group,\n\t   sep->se_bi ? sep->se_bi->bi_service : \"no\",\n\t   sep->se_server);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "setup": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "int\nsetup (struct servtab *sep)\n{\n  int err;\n  int on = 1;\n\n tryagain:\n  sep->se_fd = socket (sep->se_family, sep->se_socktype, 0);\n  if (sep->se_fd < 0)\n    {\n      /* If we don't support creating AF_INET6 sockets, create AF_INET\n\t sockets.  */\n      if (errno == EAFNOSUPPORT && sep->se_family == AF_INET6\n\t  && sep->se_v4mapped)\n\t{\n\t  /* Fall back to IPv4 silently.  */\n\t  sep->se_family = AF_INET;\n\t  goto tryagain;\n\t}\n\n      if (debug)\n\tfprintf (stderr, \"socket failed on %s/%s: %s\\n\",\n\t\t sep->se_service, sep->se_proto, strerror (errno));\n      syslog (LOG_ERR, \"%s/%s: socket: %m\",\n\t      sep->se_service, sep->se_proto);\n      return 1;\n    }\n#ifdef IPV6\n  if (sep->se_family == AF_INET6)\n    {\n      /* Reverse the value of SEP->se_v4mapped, since otherwise if\n\t using `tcp6' as a protocol type, all connections will be\n\t mapped to IPv6, and with `tcp6only', IPv4 gets mapped to\n\t IPv6.  */\n      int val = sep->se_v4mapped ? 0 : 1;\n      if (setsockopt (sep->se_fd, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t      (char *) &val, sizeof (val)) < 0)\n\tsyslog (LOG_ERR, \"setsockopt (IPV6_V6ONLY): %m\");\n    }\n#endif\n  if (strncmp (sep->se_proto, \"tcp\", 3) == 0 && (options & SO_DEBUG))\n    {\n      if (setsockopt (sep->se_fd, SOL_SOCKET, SO_DEBUG,\n\t\t      (char *) &on, sizeof (on)) < 0\n\t  && errno != EACCES)\t/* Ignore insufficient permission.  */\n\tsyslog (LOG_ERR, \"setsockopt (SO_DEBUG): %m\");\n    }\n\n  err = setsockopt (sep->se_fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t    (char *) &on, sizeof (on));\n  if (err < 0)\n    syslog (LOG_ERR, \"setsockopt (SO_REUSEADDR): %m\");\n\n  err = bind (sep->se_fd, (struct sockaddr *) &sep->se_ctrladdr,\n\t      sep->se_addrlen);\n  if (err < 0)\n    {\n      /* If we can't bind with AF_INET6 try again with AF_INET.  */\n      if ((errno == EADDRNOTAVAIL || errno == EAFNOSUPPORT)\n\t  && sep->se_family == AF_INET6 && sep->se_v4mapped)\n\t{\n\t  /* Fall back to IPv4 silently.  */\n\t  sep->se_family = AF_INET;\n\t  close (sep->se_fd);\n\t  goto tryagain;\n\t}\n      if (sep->se_node)\n\t{\n\t  if (debug)\n\t    fprintf (stderr, \"bind failed for %s %s/%s: %s\\n\",\n\t\t     sep->se_node, sep->se_service, sep->se_proto,\n\t\t     strerror (errno));\n\t  syslog (LOG_ERR,\"%s %s/%s: bind: %m\",\n\t\t  sep->se_node, sep->se_service, sep->se_proto);\n\t}\n      else\n\t{\n\t  if (debug)\n\t    fprintf (stderr, \"bind failed for %s/%s: %s\\n\",\n\t\t     sep->se_service, sep->se_proto, strerror (errno));\n\t  syslog (LOG_ERR,\"%s/%s: bind: %m\", sep->se_service, sep->se_proto);\n\t}\n      close (sep->se_fd);\n      sep->se_fd = -1;\n      if (!timingout)\n\t{\n\t  timingout = 1;\n\t  alarm (RETRYTIME);\n\t}\n      return 1;\n    }\n  return 0;\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "servent_setup": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        690,
        1
      ],
      "content": "void\nservent_setup (struct servtab *sep)\n{\n  sep->se_checked = 1;\n  if (sep->se_fd == -1 && setup (sep) == 0)\n    {\n      if (sep->se_socktype == SOCK_STREAM)\n\tlisten (sep->se_fd, 10);\n      FD_SET (sep->se_fd, &allsock);\n      nsock++;\n      if (sep->se_fd > maxsock)\n\tmaxsock = sep->se_fd;\n      if (debug)\n\tfprintf (stderr, \"registered %s on %d\\n\", sep->se_server, sep->se_fd);\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "retry": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "void\nretry (int signo _GL_UNUSED_PARAMETER)\n{\n  struct servtab *sep;\n\n  timingout = 0;\n  for (sep = servtab; sep; sep = sep->se_next)\n    if (sep->se_fd == -1 && !ISMUX (sep))\n      setup (sep);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "close_sep": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "void\nclose_sep (struct servtab *sep)\n{\n  if (sep->se_fd >= 0)\n    {\n      nsock--;\n      FD_CLR (sep->se_fd, &allsock);\n      close (sep->se_fd);\n      sep->se_fd = -1;\n    }\n  sep->se_count = 0;\n  /*\n   * Don't keep the pid of this running deamon: when reapchild()\n   * reaps this pid, it would erroneously increment nsock.\n   */\n  if (sep->se_wait > 1)\n    sep->se_wait = 1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "enter": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        796,
        1
      ],
      "content": "struct servtab *\nenter (struct servtab *cp)\n{\n  struct servtab *sep;\n  SIGSTATUS sigstatus;\n  size_t i;\n\n  /* Checking/Removing duplicates */\n  for (sep = servtab; sep; sep = sep->se_next)\n    if (memcmp (&sep->se_ctrladdr, &cp->se_ctrladdr,\n\t\tsizeof (sep->se_ctrladdr)) == 0\n\t&& strcmp (sep->se_service, cp->se_service) == 0\n\t&& strcmp (sep->se_proto, cp->se_proto) == 0\n\t&& ISMUX (sep) == ISMUX (cp))\n      break;\n  if (sep != 0)\n    {\n      signal_block (&sigstatus);\n      /*\n       * sep->se_wait may be holding the pid of a daemon\n       * that we're waiting for.  If so, don't overwrite\n       * it unless the config file explicitly says don't\n       * wait.\n       */\n      if (cp->se_bi == 0 && (sep->se_wait == 1 || cp->se_wait == 0))\n\tsep->se_wait = cp->se_wait;\n#define SWAP(a, b) { char *c = a; a = b; b = c; }\n      if (cp->se_user)\n\tSWAP (sep->se_user, cp->se_user);\n      if (cp->se_group)\n\tSWAP (sep->se_group, cp->se_group);\n      if (cp->se_server)\n\tSWAP (sep->se_server, cp->se_server);\n      argcv_free (sep->se_argc, sep->se_argv);\n      sep->se_argc = cp->se_argc;\n      sep->se_argv = cp->se_argv;\n      cp->se_argc = 0;\n      cp->se_argv = NULL;\n      sep->se_checked = 1;\n      signal_unblock (&sigstatus);\n      if (debug)\n\tprint_service (\"REDO\", sep);\n      return sep;\n    }\n\n  if (debug)\n    print_service (\"ADD \", cp);\n\n  sep = (struct servtab *) malloc (sizeof (*sep));\n  if (sep == NULL)\n    {\n      syslog (LOG_ERR, \"Out of memory.\");\n      exit (-1);\n    }\n  *sep = *cp;\n  dupstr (&sep->se_node);\n  dupstr (&sep->se_service);\n  dupstr (&sep->se_proto);\n  dupstr (&sep->se_user);\n  dupstr (&sep->se_group);\n  dupstr (&sep->se_server);\n  dupmem ((void**)&sep->se_argv, sep->se_argc * sizeof (sep->se_argv[0]));\n  for (i = 0; i < sep->se_argc; i++)\n    dupstr (&sep->se_argv[i]);\n\n  sep->se_fd = -1;\n  signal_block (&sigstatus);\n  sep->se_next = servtab;\n  servtab = sep;\n  signal_unblock (&sigstatus);\n  return sep;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "struct servtab",
        "struct",
        "servtab",
        "*\nenter (struct servtab *cp)",
        "*"
      ]
    },
    "inetd_getaddrinfo": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "int\ninetd_getaddrinfo (struct servtab *sep, int proto, struct addrinfo **result)\n{\n  struct addrinfo hints;\n#ifdef IPV6\n  bool numeric_address = false;\n\n  /* In case a numerical address is supplied, which does not\n     apply to the indicated domain, a non-local resolver\n     will wait in vain until time out occurs, thus blocking.\n     Avoid this by falling back to numerical host resolving\n     when address string seems to be numerical.  */\n\n  /* Purely numeric address?  Separate criteria for IPv4 and IPv6,\n     since IPv6 allows hexadecimal coding and IPv4 mapping!  */\n  if (sep->se_node\n      && (strspn (sep->se_node, IPV4_NUMCHARS) == strlen (sep->se_node)\n\t  || (strchr (sep->se_node, ':')\n\t      && strspn (sep->se_node, IPV6_NUMCHARS)) ) )\n    numeric_address = true;\n  else\n    if (debug && sep->se_node)\n      fprintf (stderr, \"Resolving address: %s\\n\", sep->se_node);\n#endif /* IPV6 */\n\n  memset (&hints, 0, sizeof (hints));\n\n  hints.ai_flags = AI_PASSIVE;\n#ifdef AI_V4MAPPED\n  if (sep->se_v4mapped && (sep->se_family != AF_INET))\n    hints.ai_flags |= AI_V4MAPPED;\n#endif\n#ifdef IPV6\n  if (numeric_address)\n    hints.ai_flags |= AI_NUMERICHOST;\n#endif\n  hints.ai_family = sep->se_family;\n  hints.ai_socktype = sep->se_socktype;\n  hints.ai_protocol = proto;\n\n  return getaddrinfo (sep->se_node, sep->se_service, &hints, result);\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "expand_enter": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        916,
        1
      ],
      "content": "int\nexpand_enter (struct servtab *sep)\n{\n  int err;\n  struct addrinfo *result, *rp;\n  struct protoent *proto;\n  struct servtab *cp;\n\n  /* Make sure that tcp6 etc also work.  */\n  if (strncmp (sep->se_proto, \"tcp\", 3) == 0)\n    proto = getprotobyname (\"tcp\");\n  else if (strncmp (sep->se_proto, \"udp\", 3) == 0)\n    proto = getprotobyname (\"udp\");\n  else\n    proto = getprotobyname (sep->se_proto);\n\n  if (!proto)\n    {\n      syslog (LOG_ERR, \"%s: Unknown protocol\", sep->se_proto);\n      return 1;\n    }\n\n  err = inetd_getaddrinfo (sep, proto->p_proto, &result);\n#if IPV6\n  if (err == EAI_ADDRFAMILY\n      && sep->se_family == AF_INET6 && sep->se_v4mapped)\n    {\n      /* Fall back to IPv4 silently.  */\n      sep->se_family = AF_INET;\n      err = inetd_getaddrinfo (sep, proto->p_proto, &result);\n    }\n#endif\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      if (sep->se_node)\n\t{\n\t  if (debug)\n\t    fprintf (stderr, \"resolution of %s %s/%s failed: %s\\n\",\n\t\t     sep->se_node, sep->se_service, sep->se_proto, errmsg);\n\t  syslog (LOG_ERR, \"%s %s/%s: getaddrinfo: %s\",\n\t\t  sep->se_node, sep->se_service, sep->se_proto, errmsg);\n\t}\n      else\n\t{\n\t  if (debug)\n\t    fprintf (stderr, \"resolution of %s/%s failed: %s\\n\",\n\t\t     sep->se_service, sep->se_proto, errmsg);\n\t  syslog (LOG_ERR, \"%s/%s: getaddrinfo: %s\",\n\t\t  sep->se_service, sep->se_proto, errmsg);\n\t}\n      return 1;\n    }\n\n  for (rp = result; rp != NULL; rp = rp->ai_next)\n    {\n      memset (&sep->se_ctrladdr, 0, sizeof (sep->se_ctrladdr));\n      memcpy (&sep->se_ctrladdr, rp->ai_addr, rp->ai_addrlen);\n      sep->se_addrlen = rp->ai_addrlen;\n      cp = enter (sep);\n      servent_setup (cp);\n    }\n\n  freeaddrinfo (result);\n\n  return 0;\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "setconfig": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "FILE *\nsetconfig (const char *file)\n{\n  return fopen (file, \"r\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "FILE",
        "*\nsetconfig (const char *file)",
        "*"
      ]
    },
    "endconfig": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        938,
        1
      ],
      "content": "void\nendconfig (FILE *fconfig)\n{\n  if (fconfig)\n    fclose (fconfig);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "freeconfig": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "void\nfreeconfig (struct servtab *cp)\n{\n  free (cp->se_node);\n  free (cp->se_service);\n  free (cp->se_proto);\n  free (cp->se_user);\n  free (cp->se_group);\n  free (cp->se_server);\n  argcv_free (cp->se_argc, cp->se_argv);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "next_node_sep": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "struct servtab *\nnext_node_sep (struct servtab *sep)\n{\n  if (serv_node)\n    {\n      size_t i = strcspn (serv_node + serv_node_offset, \",\");\n      sep->se_node = malloc (i + 1);\n      if (!sep->se_node)\n\t{\n\t  syslog (LOG_ERR, \"malloc: %m\");\n\t  exit (-1);\n\t}\n      memcpy (sep->se_node, serv_node + serv_node_offset, i);\n      sep->se_node[i] = 0;\n      serv_node_offset += i;\n      if (serv_node[serv_node_offset])\n\tserv_node_offset++;\n      else\n\t{\n\t  free (serv_node);\n\t  serv_node = NULL;\n\t}\n    }\n  return sep;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "struct servtab",
        "struct",
        "servtab",
        "*\nnext_node_sep (struct servtab *sep)",
        "*"
      ]
    },
    "getconfigent": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        1256,
        1
      ],
      "content": "struct servtab *\ngetconfigent (FILE *fconfig, const char *file, size_t *line)\n{\n  static struct servtab serv;\n  struct servtab *sep = &serv;\n  int argc = 0;\n  size_t i;\n  char **argv = NULL;\n  char *node, *service;\n  static char TCPMUX_TOKEN[] = \"tcpmux/\";\n#define MUX_LEN\t\t(sizeof(TCPMUX_TOKEN)-1)\n\n  if (serv_node)\n    return next_node_sep (sep);\n\n  memset ((caddr_t) sep, 0, sizeof *sep);\n\n  while (1)\n    {\n      argcv_free (argc, argv);\n      freeconfig (sep);\n      memset ((caddr_t) sep, 0, sizeof *sep);\n\n      do\n\t{\n\t  ssize_t n = getline (&linebuf, &linebufsize, fconfig);\n\t  if (n < 0)\n\t    return 0;\n\t  else if (n == 0)\n\t    continue;\n\n\t  if (linebuf[n-1] == '\\n')\n\t    linebuf[n-1] = 0;\n\t  ++ *line;\n\t}\n      while (*linebuf == '#' || *linebuf == 0);\n\n      if (argcv_get (linebuf, \"\", &argc, &argv))\n\tcontinue;\n\n      if (argc < INETD_FIELDS_MIN)\n\t{\n\t  if (argc == 1 && argv[0][strlen (argv[0]) - 1] == ':')\n\t    {\n\t      argv[0][strlen (argv[0]) - 1] = 0;\n\t      free (global_serv_node);\n\t      if (strcmp (argv[0], \"*\"))\n\t\tglobal_serv_node = newstr (argv[0]);\n\t    }\n\t  else\n\t    syslog (LOG_ERR, \"%s:%lu: not enough fields\",\n\t\t    file, (unsigned long) *line);\n\t  continue;\n\t}\n\n      sep->se_file = file;\n      sep->se_line = *line;\n\n      node = argv[INETD_SERVICE];\n      service = strrchr (node, ':');\n      if (!service)\n        {\n\t  if (global_serv_node)\n\t    {\n\t      node = global_serv_node;\n\t      serv_node = newstr (node);\n\t      serv_node_offset = 0;\n\t    }\n\t  else\n\t      node = NULL;\n\n\t  service = argv[INETD_SERVICE];\n        }\n      else\n        {\n          *service++ = 0;\n          if (strcmp (node, \"*\") == 0)\n            node = NULL;\n\t  else\n\t    {\n\t      serv_node = newstr (node);\n\t      serv_node_offset = 0;\n\t    }\n        }\n\n      if (strncmp (service, TCPMUX_TOKEN, MUX_LEN) == 0)\n\t{\n\t  char *c = service + MUX_LEN;\n\t  if (*c == '+')\n\t    {\n\t      sep->se_type = MUXPLUS_TYPE;\n\t      c++;\n\t    }\n\t  else\n\t    sep->se_type = MUX_TYPE;\n\t  sep->se_service = newstr (c);\n\t}\n      else\n\t{\n\t  sep->se_service = newstr (service);\n\t  sep->se_type = NORM_TYPE;\n\t}\n\n      if (strcmp (argv[INETD_SOCKET], \"stream\") == 0)\n\tsep->se_socktype = SOCK_STREAM;\n      else if (strcmp (argv[INETD_SOCKET], \"dgram\") == 0)\n\tsep->se_socktype = SOCK_DGRAM;\n      else if (strcmp (argv[INETD_SOCKET], \"rdm\") == 0)\n\tsep->se_socktype = SOCK_RDM;\n      else if (strcmp (argv[INETD_SOCKET], \"seqpacket\") == 0)\n\tsep->se_socktype = SOCK_SEQPACKET;\n      else if (strcmp (argv[INETD_SOCKET], \"raw\") == 0)\n\tsep->se_socktype = SOCK_RAW;\n      else\n\t{\n\t  syslog (LOG_WARNING, \"%s:%lu: bad socket type\",\n\t\t  file, (unsigned long) *line);\n\t  sep->se_socktype = -1;\n\t}\n\n      sep->se_proto = newstr (argv[INETD_PROTOCOL]);\n\n#ifdef IPV6\n      /* We default to IPv4. */\n      sep->se_family = AF_INET;\n      sep->se_v4mapped = 1;\n\n      if ((strncmp (sep->se_proto, \"tcp\", 3) == 0)\n\t  || (strncmp (sep->se_proto, \"udp\", 3) == 0))\n\t{\n\t  if (sep->se_proto[3] == '6')\n\t    {\n\t      sep->se_family = AF_INET6;\n\t      sep->se_v4mapped = 0;\n\t      /* Check for tcp6only and udp6only.  */\n\t      if (strcmp (&sep->se_proto[3], \"6only\") == 0)\n\t        sep->se_v4mapped = 0;\n\t    }\n\t  else if (sep->se_proto[3] == '4')\n\t    {\n\t      sep->se_family = AF_INET;\n\t    }\n\t}\n#else\n      if ((strncmp (sep->se_proto, \"tcp6\", 4) == 0)\n\t  || (strncmp (sep->se_proto, \"udp6\", 4) == 0))\n\t{\n\t  syslog (LOG_ERR, \"%s:%lu: %s: IPv6 support isn't enabled\",\n\t\t  file, (unsigned long) *line, sep->se_proto);\n\t  continue;\n\t}\n\n      sep->se_family = AF_INET;\n#endif\n      {\n\tchar *p, *q;\n\n\tp = strchr(argv[INETD_WAIT], '.');\n\tif (p)\n\t  *p++ = 0;\n\tif (strcmp (argv[INETD_WAIT], \"wait\") == 0)\n\t  sep->se_wait = 1;\n\telse if (strcmp (argv[INETD_WAIT], \"nowait\") == 0)\n\t  sep->se_wait = 0;\n\telse\n\t  {\n\t    syslog (LOG_WARNING, \"%s:%lu: bad wait type\",\n\t\t    file, (unsigned long) *line);\n\t  }\n\tif (p)\n\t  {\n\t    sep->se_max = strtoul(p, &q, 10);\n\t    if (*q)\n\t      syslog (LOG_WARNING, \"%s:%lu: invalid number (%s)\",\n\t\t      file, (unsigned long) *line, p);\n\t  }\n      }\n\n      if (ISMUX (sep))\n\t{\n\t  /*\n\t   * Silently enforce \"nowait\" for TCPMUX services since\n\t   * they don't have an assigned port to listen on.\n\t   */\n\t  sep->se_wait = 0;\n\n\t  if (strncmp (sep->se_proto, \"tcp\", 3))\n\t    {\n\t      syslog (LOG_ERR, \"%s:%lu: bad protocol for tcpmux service %s\",\n\t\t      file, (unsigned long) *line, sep->se_service);\n\t      continue;\n\t    }\n\t  if (sep->se_socktype != SOCK_STREAM)\n\t    {\n\t      syslog (LOG_ERR,\n\t\t      \"%s:%lu: bad socket type for tcpmux service %s\",\n\t\t      file, (unsigned long) *line, sep->se_service);\n\t      continue;\n\t    }\n\t}\n\n      /* Establish optional group identity:\n       *   user:group, user.group\n       */\n      {\n\tchar *p;\n\n\tsep->se_user = newstr (argv[INETD_USER]);\n\n\tp = strchr (sep->se_user, ':');\n\tif (!p)\n\t  p = strchr (sep->se_user, '.');\n\n\tif (p)\n\t  {\n\t    *p = '\\0';\n\t    sep->se_group = newstr (++p);\n\t  }\n\telse\n\t  sep->se_group = newstr (NULL);\n      }\n\n      sep->se_server = newstr (argv[INETD_SERVER_PATH]);\n      if (strcmp (sep->se_server, \"internal\") == 0)\n\t{\n\t  sep->se_bi = bi_lookup (sep);\n\t  if (!sep->se_bi)\n\t    {\n\t      syslog (LOG_ERR, \"%s:%lu: internal service %s unknown\",\n\t\t      file, (unsigned long) *line, sep->se_service);\n\t      continue;\n\t    }\n\t  sep->se_wait = sep->se_bi->bi_wait;\n\t}\n      else\n\tsep->se_bi = NULL;\n\n      sep->se_argc = argc - INETD_FIELDS_MIN + 1;\n      sep->se_argv = calloc (sep->se_argc + 1, sizeof sep->se_argv[0]);\n      if (!sep->se_argv)\n\t{\n\t  syslog (LOG_ERR, \"%s:%lu: Out of memory.\",\n\t\t  file, (unsigned long) *line);\n\t  exit (-1);\n\t}\n\n      for (i = 0; i < sep->se_argc; i++)\n\t{\n\t  sep->se_argv[i] = argv[INETD_SERVER_ARGS + i];\n\t  argv[INETD_SERVER_ARGS + i] = 0;\n\t}\n\n      /* If no arguments are provided, use server name as argv[0].  */\n      if (sep->se_argc == 1)\n\t{\n\t  const char *argv0 = strrchr (sep->se_server, '/');\n\t  if (argv0)\n\t    argv0++;\n\t  else\n\t    argv0 = sep->se_server;\n          sep->se_argv[0] = newstr (argv0);\n\t}\n\n      sep->se_argv[i] = NULL;\n      break;\n    }\n  argcv_free (argc, argv);\n  return next_node_sep (sep);\n}",
      "lines": 269,
      "depth": 18,
      "decorators": [
        "struct servtab",
        "struct",
        "servtab",
        "*\ngetconfigent (FILE *fconfig, const char *file, size_t *line)",
        "*"
      ]
    },
    "nextconfig": {
      "start_point": [
        1258,
        0
      ],
      "end_point": [
        1333,
        1
      ],
      "content": "void\nnextconfig (const char *file)\n{\n#ifndef IPV6\n  struct servent *sp;\n#endif\n  struct servtab *sep, **sepp;\n  struct passwd *pwd;\n  struct group *grp;\n  FILE *fconfig;\n  SIGSTATUS sigstatus;\n\n  size_t line = 0;\n\n  fconfig = setconfig (file);\n  if (!fconfig)\n    {\n      syslog (LOG_ERR, \"%s: %m\", file);\n      return;\n    }\n  while ((sep = getconfigent (fconfig, file, &line)))\n    {\n      pwd = getpwnam (sep->se_user);\n      if (pwd == NULL)\n\t{\n\t  syslog (LOG_ERR, \"%s/%s: No such user '%s', service ignored\",\n\t\t  sep->se_service, sep->se_proto, sep->se_user);\n\t  continue;\n\t}\n      if (sep->se_group && *sep->se_group)\n\t{\n\t  grp = getgrnam (sep->se_group);\n\t  if (grp == NULL)\n\t    {\n\t      syslog (LOG_ERR, \"%s/%s: No such group '%s', service ignored\",\n\t\t      sep->se_service, sep->se_proto, sep->se_group);\n\t      continue;\n\t    }\n\t}\n      if (ISMUX (sep))\n\t{\n\t  sep->se_fd = -1;\n\t  sep->se_checked = 1;\n\t  enter (sep);\n\t}\n      else\n\texpand_enter (sep);\n\n      if (serv_node)\n\tfree (sep->se_node);\n      else\n\tfreeconfig (sep);\n    }\n  endconfig (fconfig);\n  /*\n   * Purge anything not looked at above.\n   */\n  signal_block (&sigstatus);\n  sepp = &servtab;\n  while ((sep = *sepp))\n    {\n      if (sep->se_checked)\n\t{\n\t  sepp = &sep->se_next;\n\t  continue;\n\t}\n      *sepp = sep->se_next;\n      if (sep->se_fd >= 0)\n\tclose_sep (sep);\n      if (debug)\n\tprint_service (\"FREE\", sep);\n      freeconfig (sep);\n      free (sep);\n    }\n  signal_unblock (&sigstatus);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fix_tcpmux": {
      "start_point": [
        1335,
        0
      ],
      "end_point": [
        1398,
        1
      ],
      "content": "void\nfix_tcpmux (void)\n{\n  struct servtab *sep;\n  int need_tcpmux = 0;\n  int has_tcpmux = 0;\n\n  for (sep = servtab; sep; sep = sep->se_next)\n    {\n      if (sep->se_checked)\n\t{\n\t  if (ISMUX (sep))\n\t    {\n\t      if (has_tcpmux)\n\t\treturn;\n\t      need_tcpmux = 1;\n\t    }\n\t  if (strcmp (sep->se_service, \"tcpmux\") == 0)\n\t    {\n\t      if (need_tcpmux)\n\t\treturn;\n\t      has_tcpmux = 1;\n\t    }\n\t}\n    }\n  if (need_tcpmux && !has_tcpmux)\n    {\n      struct servtab serv;\n      memset (&serv, 0, sizeof (serv));\n\n      serv.se_file = \"fix_tcpmux\";\n      serv.se_service = newstr (\"tcpmux\");\n      serv.se_socktype = SOCK_STREAM;\n      serv.se_checked = 1;\n      serv.se_user = newstr (\"root\");\n      serv.se_group = newstr (NULL);\t/* Group name for root is not portable.  */\n      serv.se_bi = bi_lookup (&serv);\n      if (!serv.se_bi)\n\t{\n\t  /* Should not happen */\n\t  freeconfig (&serv);\n\t  if (debug)\n\t    fprintf (stderr, \"INTERNAL ERROR: could not find tcpmux built-in\");\n\t  syslog (LOG_ERR, \"INTERNAL ERROR: could not find tcpmux built-in\");\n\t  return;\n\t}\n      serv.se_wait = serv.se_bi->bi_wait;\n      serv.se_server = newstr (\"internal\");\n      serv.se_fd = -1;\n      serv.se_type = NORM_TYPE;\n#ifdef IPV6\n      serv.se_proto = newstr (\"tcp6\");\n      serv.se_family = AF_INET6;\n      serv.se_v4mapped = 1;\n#else\n      serv.se_proto = newstr (\"tcp\");\n      serv.se_family = AF_INET;\n#endif\n      if (debug)\n\tfprintf (stderr, \"inserting default tcpmux entry\\n\");\n      syslog (LOG_INFO, \"inserting default tcpmux entry\");\n      expand_enter (&serv);\n    }\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "config": {
      "start_point": [
        1400,
        0
      ],
      "end_point": [
        1463,
        1
      ],
      "content": "void\nconfig (int signo)\n{\n  int i;\n  struct stat stats;\n  struct servtab *sep;\n\n  for (sep = servtab; sep; sep = sep->se_next)\n    sep->se_checked = 0;\n\n  for (i = 0; config_files[i]; i++)\n    {\n      struct stat statbuf;\n\n      if (stat (config_files[i], &statbuf) == 0)\n\t{\n\t  if (S_ISDIR (statbuf.st_mode))\n\t    {\n\t      DIR *dirp = opendir (config_files[i]);\n\n\t      if (dirp)\n\t\t{\n\t\t  struct dirent *dp;\n\n\t\t  while ((dp = readdir (dirp)) != NULL)\n\t\t    {\n\t\t      char *path = calloc (strlen (config_files[i])\n\t\t\t\t\t   + strlen (dp->d_name) + 2, 1);\n\t\t      if (path)\n\t\t\t{\n\t\t\t  sprintf (path, \"%s/%s\", config_files[i],\n\t\t\t\t   dp->d_name);\n\t\t\t  if (stat (path, &stats) == 0\n\t\t\t      && S_ISREG (stats.st_mode))\n\t\t\t    {\n\t\t\t      nextconfig (path);\n\t\t\t    }\n\t\t\t  free (path);\n\t\t\t}\n\t\t    }\n\t\t  closedir (dirp);\n\t\t}\n\t    }\n\t  else if (S_ISREG (statbuf.st_mode))\n\t    {\n\t      nextconfig (config_files[i]);\n\t    }\n\t}\n      else\n\t{\n\t  if (signo == 0)\n\t    fprintf (stderr, \"inetd: %s, %s\\n\",\n\t\t     config_files[i], strerror (errno));\n\t  else\n\t    syslog (LOG_ERR, \"%s: %m\", config_files[i]);\n\t}\n    }\n\n  free (linebuf);\n  linebuf = NULL;\n  linebufsize = 0;\n\n  fix_tcpmux ();\n}",
      "lines": 64,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "set_proc_title": {
      "start_point": [
        1467,
        0
      ],
      "end_point": [
        1503,
        1
      ],
      "content": "void\nset_proc_title (char *a, int s)\n{\n  socklen_t size;\n  char *cp;\n#ifdef IPV6\n  struct sockaddr_storage saddr;\n#else\n  struct sockaddr_in saddr;\n#endif\n  char buf[80];\n\n  cp = Argv[0];\n  size = sizeof saddr;\n  if (getpeername (s, (struct sockaddr *) &saddr, &size) == 0)\n    {\n#ifdef IPV6\n      int err;\n      char buf2[80];\n\n      err = getnameinfo ((struct sockaddr *) &saddr, sizeof (saddr), buf2,\n\t\t\t sizeof (buf2), NULL, 0, NI_NUMERICHOST);\n      if (!err)\n\tsnprintf (buf, sizeof buf, \"-%s [%s]\", a, buf2);\n      else\n\tsnprintf (buf, sizeof buf, \"-%s\", a);\n#else\n      snprintf (buf, sizeof buf, \"-%s [%s]\", a, inet_ntoa (saddr.sin_addr));\n#endif\n    }\n  else\n    snprintf (buf, sizeof buf, \"-%s\", a);\n  strncpy (cp, buf, LastArg - cp);\n  cp += strlen (cp);\n  while (cp < LastArg)\n    *cp++ = ' ';\n}",
      "lines": 37,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "echo_stream": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "void\necho_stream (int s, struct servtab *sep)\n{\n  char buffer[BUFSIZE];\n  int i;\n\n  set_proc_title (sep->se_service, s);\n  while ((i = read (s, buffer, sizeof buffer)) > 0\n\t && write (s, buffer, i) > 0)\n    ;\n  exit (EXIT_SUCCESS);\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "echo_dg": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1542,
        1
      ],
      "content": "void\necho_dg (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  char buffer[BUFSIZE];\n  int i;\n  socklen_t size;\n#ifdef IPV6\n  struct sockaddr_storage sa;\n#else\n  struct sockaddr sa;\n#endif\n\n  size = sizeof sa;\n  i = recvfrom (s, buffer, sizeof buffer, 0, (struct sockaddr *) &sa, &size);\n  if (i < 0)\n    return;\n  sendto (s, buffer, i, 0, (struct sockaddr *) &sa, sizeof sa);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "discard_stream": {
      "start_point": [
        1545,
        0
      ],
      "end_point": [
        1560,
        1
      ],
      "content": "void\ndiscard_stream (int s, struct servtab *sep)\n{\n  int ret;\n  char buffer[BUFSIZE];\n\n  set_proc_title (sep->se_service, s);\n  while (1)\n    {\n      while ((ret = read (s, buffer, sizeof buffer)) > 0)\n\t;\n      if (ret == 0 || errno != EINTR)\n\tbreak;\n    }\n  exit (EXIT_SUCCESS);\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "discard_dg": {
      "start_point": [
        1562,
        0
      ],
      "end_point": [
        1569,
        1
      ],
      "content": "void\n/* Discard service -- ignore data */\ndiscard_dg (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  char buffer[BUFSIZE];\n\n  read (s, buffer, sizeof buffer);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "/* Discard service -- ignore data */"
      ]
    },
    "initring": {
      "start_point": [
        1576,
        0
      ],
      "end_point": [
        1586,
        1
      ],
      "content": "void\ninitring (void)\n{\n  int i;\n\n  endring = ring;\n\n  for (i = 0; i <= 128; ++i)\n    if (isprint (i))\n      *endring++ = i;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "chargen_stream": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1621,
        1
      ],
      "content": "void\nchargen_stream (int s, struct servtab *sep)\n{\n  int len;\n  char *rs, text[LINESIZ + 2];\n\n  set_proc_title (sep->se_service, s);\n\n  if (!endring)\n    {\n      initring ();\n      rs = ring;\n    }\n\n  text[LINESIZ] = '\\r';\n  text[LINESIZ + 1] = '\\n';\n  for (rs = ring;;)\n    {\n      len = endring - rs;\n      if (len >= LINESIZ)\n\tmemmove (text, rs, LINESIZ);\n      else\n\t{\n\t  memmove (text, rs, len);\n\t  memmove (text + len, ring, LINESIZ - len);\n\t}\n      if (++rs == endring)\n\trs = ring;\n      if (write (s, text, sizeof text) != sizeof text)\n\tbreak;\n    }\n  exit (EXIT_SUCCESS);\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "chargen_dg": {
      "start_point": [
        1624,
        0
      ],
      "end_point": [
        1660,
        1
      ],
      "content": "void\nchargen_dg (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n#ifdef IPV6\n  struct sockaddr_storage sa;\n#else\n  struct sockaddr sa;\n#endif\n  static char *rs;\n  int len;\n  socklen_t size;\n  char text[LINESIZ + 2];\n\n  if (endring == 0)\n    {\n      initring ();\n      rs = ring;\n    }\n\n  size = sizeof sa;\n  if (recvfrom (s, text, sizeof text, 0, (struct sockaddr *) &sa, &size) < 0)\n    return;\n\n  len = endring - rs;\n  if (len >= LINESIZ)\n    memmove (text, rs, LINESIZ);\n  else\n    {\n      memmove (text, rs, len);\n      memmove (text + len, ring, LINESIZ - len);\n    }\n  if (++rs == endring)\n    rs = ring;\n  text[LINESIZ] = '\\r';\n  text[LINESIZ + 1] = '\\n';\n  sendto (s, text, sizeof text, 0, (struct sockaddr *) &sa, sizeof sa);\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "machtime": {
      "start_point": [
        1670,
        0
      ],
      "end_point": [
        1684,
        1
      ],
      "content": "long\nmachtime (void)\n{\n  struct timeval tv;\n\n  if (gettimeofday (&tv, NULL) < 0)\n    {\n      if (debug)\n\tfprintf (stderr, \"Unable to get time of day\\n\");\n      return 0L;\n    }\n#define OFFSET ((unsigned long)25567 * 24*60*60)\n  return (htonl ((long) (tv.tv_sec + OFFSET)));\n#undef OFFSET\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "long",
        "long"
      ]
    },
    "machtime_stream": {
      "start_point": [
        1686,
        0
      ],
      "end_point": [
        1693,
        1
      ],
      "content": "void\nmachtime_stream (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  long result;\n\n  result = machtime ();\n  write (s, (char *) &result, sizeof result);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "machtime_dg": {
      "start_point": [
        1695,
        0
      ],
      "end_point": [
        1713,
        1
      ],
      "content": "void\nmachtime_dg (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  long result;\n#ifdef IPV6\n  struct sockaddr_storage sa;\n#else\n  struct sockaddr sa;\n#endif\n  socklen_t size;\n\n  size = sizeof sa;\n  if (recvfrom (s, (char *) &result, sizeof result, 0,\n\t\t(struct sockaddr *) &sa, &size) < 0)\n    return;\n  result = machtime ();\n  sendto (s, (char *) &result, sizeof result, 0,\n\t  (struct sockaddr *) &sa, sizeof sa);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "daytime_stream": {
      "start_point": [
        1715,
        0
      ],
      "end_point": [
        1726,
        1
      ],
      "content": "void\n/* Return human-readable time of day */\ndaytime_stream (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  char buffer[256];\n  time_t lclock;\n\n  lclock = time ((time_t *) 0);\n\n  sprintf (buffer, \"%.24s\\r\\n\", ctime (&lclock));\n  write (s, buffer, strlen (buffer));\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void",
        "/* Return human-readable time of day */"
      ]
    },
    "daytime_dg": {
      "start_point": [
        1729,
        0
      ],
      "end_point": [
        1749,
        1
      ],
      "content": "void\ndaytime_dg (int s, struct servtab *sep _GL_UNUSED_PARAMETER)\n{\n  char buffer[256];\n  time_t lclock;\n#ifdef IPV6\n  struct sockaddr_storage sa;\n#else\n  struct sockaddr sa;\n#endif\n  socklen_t size;\n\n  lclock = time ((time_t *) 0);\n\n  size = sizeof sa;\n  if (recvfrom (s, buffer, sizeof buffer, 0, (struct sockaddr *) &sa, &size) <\n      0)\n    return;\n  sprintf (buffer, \"%.24s\\r\\n\", ctime (&lclock));\n  sendto (s, buffer, strlen (buffer), 0, (struct sockaddr *) &sa, sizeof sa);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fd_getline": {
      "start_point": [
        1758,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "static int\nfd_getline (int fd, char *buf, int len)\n{\n  int count = 0, n;\n\n  do\n    {\n      n = read (fd, buf, len - count);\n      if (n == 0)\n\treturn count;\n      if (n < 0)\n\treturn -1;\n      while (--n >= 0)\n\t{\n\t  if (*buf == '\\r' || *buf == '\\n' || *buf == '\\0')\n\t    return count;\n\t  count++;\n\t  buf++;\n\t}\n    }\n  while (count < len);\n  return count;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tcpmux": {
      "start_point": [
        1786,
        0
      ],
      "end_point": [
        1835,
        1
      ],
      "content": "void\ntcpmux (int s, struct servtab *sep)\n{\n  char service[MAX_SERV_LEN + 1];\n  int len;\n\n  /* Get requested service name */\n  len = fd_getline (s, service, MAX_SERV_LEN);\n  if (len < 0)\n    {\n      strwrite (s, \"-Error reading service name\\r\\n\");\n      _exit (EXIT_FAILURE);\n    }\n  service[len] = '\\0';\n\n  if (debug)\n    fprintf (stderr, \"tcpmux: someone wants %s\\n\", service);\n\n  /*\n   * Help is a required command, and lists available services,\n   * one per line.\n   */\n  if (!strcasecmp (service, \"help\"))\n    {\n      for (sep = servtab; sep; sep = sep->se_next)\n\t{\n\t  if (!ISMUX (sep))\n\t    continue;\n\t  write (s, sep->se_service, strlen (sep->se_service));\n\t  strwrite (s, \"\\r\\n\");\n\t}\n      _exit (EXIT_FAILURE);\n    }\n\n  /* Try matching a service in inetd.conf with the request */\n  for (sep = servtab; sep; sep = sep->se_next)\n    {\n      if (ISMUX (sep) && !strcasecmp (service, sep->se_service))\n\t{\n\t  if (ISMUXPLUS (sep))\n\t    {\n\t      strwrite (s, \"+Go\\r\\n\");\n\t    }\n\t  run_service (s, sep);\n\t  return;\n\t}\n    }\n  strwrite (s, \"-Service not available\\r\\n\");\n  exit (EXIT_FAILURE);\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "prepenv": {
      "start_point": [
        1840,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "void\nprepenv (int ctrl, struct sockaddr *sa_client, socklen_t sa_len)\n{\n  char str[16];\n  /* IP is used both for numeric addresses and for symbolic ones.\n   * Being statically allocated, and only for logging purposes,\n   * a full MAXPATHLEN is exaggerated, so a compromise is made.  */\n  char ip[4 * INET6_ADDRSTRLEN];\n  int ret;\n#ifdef IPV6\n  struct sockaddr_storage sa_server;\n#else\n  struct sockaddr_in sa_server;\n#endif\n  socklen_t len = sizeof (sa_server);\n\n  setenv (\"PROTO\", \"TCP\", 1);\n  unsetenv (\"TCPLOCALIP\");\n  unsetenv (\"TCPLOCALHOST\");\n  unsetenv (\"TCPLOCALPORT\");\n  unsetenv (\"TCPREMOTEIP\");\n  unsetenv (\"TCPREMOTEPORT\");\n  unsetenv (\"TCPREMOTEHOST\");\n\n  if (getsockname (ctrl, (struct sockaddr *) &sa_server, &len) < 0)\n    syslog (LOG_WARNING, \"getsockname(): %m\");\n  else\n    {\n      ret = getnameinfo ((struct sockaddr *) &sa_server, len,\n\t\t\t  ip, sizeof (ip), str, sizeof (str),\n\t\t\t  NI_NUMERICHOST | NI_NUMERICSERV);\n      if (ret == 0)\n\t{\n\t  if (setenv (\"TCPLOCALIP\", ip, 1) < 0)\n\t    syslog (LOG_WARNING, \"setenv (TCPLOCALIP): %m\");\n\t  else if (debug)\n\t    fprintf (stderr, \"Assigned TCPLOCALIP = %s\\n\", ip);\n\n\t  if (setenv (\"TCPLOCALPORT\", str, 1) < 0)\n\t    syslog (LOG_WARNING, \"setenv (TCPLOCALPORT): %m\");\n\t}\n      else\n\tsyslog (LOG_WARNING, \"getnameinfo: %s\", gai_strerror (ret));\n\n      if (resolve_option)\n\t{\n\t  ret = getnameinfo ((struct sockaddr *) &sa_server, len,\n\t\t\t      ip, sizeof (ip), NULL, 0, 0);\n\t  if (ret != 0)\n\t    syslog (LOG_WARNING, \"getnameinfo: %s\", gai_strerror (ret));\n\t  else if (setenv (\"TCPLOCALHOST\", ip, 1) < 0)\n\t    syslog (LOG_WARNING, \"setenv(TCPLOCALHOST): %m\");\n\t}\n    }\n\n  ret = getnameinfo (sa_client, sa_len, ip, sizeof (ip), str, sizeof (str),\n\t\t      NI_NUMERICHOST | NI_NUMERICSERV);\n  if (ret == 0)\n    {\n      if (setenv (\"TCPREMOTEIP\", ip, 1) < 0)\n\tsyslog (LOG_WARNING, \"setenv(TCPREMOTEIP): %m\");\n      else if (debug)\n\tfprintf (stderr, \"Assigned TCPREMOTEIP = %s\\n\", ip);\n\n      if (setenv (\"TCPREMOTEPORT\", str, 1) < 0)\n\tsyslog (LOG_WARNING, \"setenv(TCPREMOTEPORT): %m\");\n\n      if (resolve_option)\n\t{\n\t  ret = getnameinfo (sa_client, sa_len, ip, sizeof (ip), NULL, 0, 0);\n\t  if (ret != 0)\n\t    syslog (LOG_WARNING, \"getnameinfo: %s\", gai_strerror (ret));\n\t  else if (setenv (\"TCPREMOTEHOST\", ip, 1) < 0)\n\t    syslog (LOG_WARNING, \"setenv(TCPREMOTEHOST): %m\");\n\t  else if (debug)\n\t    fprintf (stderr, \"Assigned TCPREMOTEHOST = %s\\n\", ip);\n\t}\n    }\n  else\n    syslog (LOG_WARNING, \"getnameinfo: %s\", gai_strerror (ret));\n}",
      "lines": 81,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        1924,
        0
      ],
      "end_point": [
        2138,
        1
      ],
      "content": "int\nmain (int argc, char *argv[], char *envp[])\n{\n  int index;\n  struct servtab *sep;\n  int dofork;\n  pid_t pid;\n\n  set_program_name (argv[0]);\n\n  Argv = argv;\n  if (envp == 0 || *envp == 0)\n    envp = argv;\n  while (*envp)\n    envp++;\n  LastArg = envp[-1] + strlen (envp[-1]);\n\n  /* Parse command line */\n  iu_argp_init (\"inetd\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  if (resolve_option)\n    env_option = true;\n\n  if (index < argc)\n    {\n      int i;\n      config_files = calloc (argc - index + 1, sizeof (*config_files));\n      for (i = 0; index < argc; index++, i++)\n\t{\n\t  config_files[i] = strdup (argv[index]);\n\t}\n    }\n  else\n    {\n      config_files = calloc (3, sizeof (*config_files));\n      config_files[0] = newstr (PATH_INETDCONF);\n      config_files[1] = newstr (PATH_INETDDIR);\n    }\n\n  if (!debug)\n    {\n      if (daemon (0, 0) < 0)\n\t{\n\t  syslog (LOG_DAEMON | LOG_ERR,\n\t\t  \"%s: Unable to enter daemon mode, %m\", argv[0]);\n\t  exit (EXIT_FAILURE);\n\t};\n    }\n\n  openlog (\"inetd\", LOG_PID | LOG_NOWAIT, LOG_DAEMON);\n\n  if (pidfile_option)\n  {\n    FILE *fp = fopen (pid_file, \"w\");\n    if (fp != NULL)\n      {\n\tif (debug)\n\t  fprintf(stderr, \"Using pid-file at \\\"%s\\\".\\n\", pid_file);\n\tfprintf (fp, \"%d\\n\", (int) getpid ());\n\tfclose (fp);\n      }\n    else\n      syslog (LOG_CRIT, \"can't open %s: %s\\n\", pid_file,\n\t      strerror (errno));\n  }\n\n  signal_set_handler (SIGALRM, retry);\n  config (0);\n  signal_set_handler (SIGHUP, config);\n  signal_set_handler (SIGCHLD, reapchild);\n  signal_set_handler (SIGPIPE, SIG_IGN);\n\n  {\n    /* space for daemons to overwrite environment for ps */\n#define DUMMYSIZE\t100\n    char dummy[DUMMYSIZE];\n\n    memset (dummy, 'x', DUMMYSIZE - 1);\n    dummy[DUMMYSIZE - 1] = '\\0';\n    setenv (\"inetd_dummy\", dummy, 1);\n  }\n\n  for (;;)\n    {\n      int n, ctrl;\n      fd_set readable;\n\n      if (nsock == 0)\n\t{\n\t  SIGSTATUS stat;\n\t  sigstatus_empty (stat);\n\n\t  signal_block (NULL);\n\t  while (nsock == 0)\n\t    inetd_pause (stat);\n\t  signal_unblock (NULL);\n\t}\n      readable = allsock;\n      n = select (maxsock + 1, &readable, NULL, NULL, NULL);\n      if (n <= 0)\n\t{\n\t  if (n < 0 && errno != EINTR)\n\t    syslog (LOG_WARNING, \"select: %m\");\n\t  sleep (1);\n\t  continue;\n\t}\n      for (sep = servtab; n && sep; sep = sep->se_next)\n\tif (sep->se_fd != -1 && FD_ISSET (sep->se_fd, &readable))\n\t  {\n\t    n--;\n\t    if (debug)\n\t      fprintf (stderr, \"someone wants %s\\n\", sep->se_service);\n\t    if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)\n\t      {\n#ifdef IPV6\n\t\tstruct sockaddr_storage sa_client;\n#else\n\t\tstruct sockaddr_in sa_client;\n#endif\n\t\tsocklen_t len = sizeof (sa_client);\n\n\t\tctrl = accept (sep->se_fd, (struct sockaddr *) &sa_client,\n\t\t\t       &len);\n\t\tif (debug)\n\t\t  fprintf (stderr, \"accept, ctrl %d\\n\", ctrl);\n\t\tif (ctrl < 0)\n\t\t  {\n\t\t    if (errno != EINTR)\n\t\t      syslog (LOG_WARNING, \"accept (for %s): %m\",\n\t\t\t      sep->se_service);\n\t\t    continue;\n\t\t  }\n\t\tif (env_option)\n\t\t  prepenv (ctrl, (struct sockaddr *) &sa_client, len);\n\t      }\n\t    else\n\t      ctrl = sep->se_fd;\n\n\t    signal_block (NULL);\n\t    pid = 0;\n\t    dofork = (sep->se_bi == 0 || sep->se_bi->bi_fork);\n\t    if (dofork)\n\t      {\n\t\tif (sep->se_count++ == 0)\n\t\t  gettimeofday (&sep->se_time, NULL);\n\t\telse if ((sep->se_max && sep->se_count > sep->se_max)\n\t\t\t || sep->se_count >= toomany)\n\t\t  {\n\t\t    struct timeval now;\n\n\t\t    gettimeofday (&now, NULL);\n\t\t    if (now.tv_sec - sep->se_time.tv_sec > CNT_INTVL)\n\t\t      {\n\t\t\tsep->se_time = now;\n\t\t\tsep->se_count = 1;\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tsyslog (LOG_ERR,\n\t\t\t\t\"%s/%s server failing (looping), service terminated\",\n\t\t\t\tsep->se_service, sep->se_proto);\n\t\t\tclose_sep (sep);\n\t\t\tif (! sep->se_wait && sep->se_socktype == SOCK_STREAM)\n\t\t\t  close (ctrl);\n\t\t\tsignal_unblock (NULL);\n\t\t\tif (!timingout)\n\t\t\t  {\n\t\t\t    timingout = 1;\n\t\t\t    alarm (RETRYTIME);\n\t\t\t  }\n\t\t\tcontinue;\n\t\t      }\n\t\t  }\n\t\tpid = fork ();\n\t      }\n\t    if (pid < 0)\n\t      {\n\t\tsyslog (LOG_ERR, \"fork: %m\");\n\t\tif (!sep->se_wait && sep->se_socktype == SOCK_STREAM)\n\t\t  close (ctrl);\n\t\tsignal_unblock (NULL);\n\t\tsleep (1);\n\t\tcontinue;\n\t      }\n\t    if (pid && sep->se_wait)\n\t      {\n\t\tsep->se_wait = pid;\n\t\tif (sep->se_fd >= 0)\n\t\t  {\n\t\t    FD_CLR (sep->se_fd, &allsock);\n\t\t    nsock--;\n\t\t  }\n\t      }\n\t    signal_unblock (NULL);\n\t    if (pid == 0)\n\t      {\n\t\tif (debug && dofork)\n\t\t  setsid ();\n\t\tif (dofork)\n\t\t  {\n\t\t    int sock;\n\t\t    if (debug)\n\t\t      fprintf (stderr, \"+ Closing from %d\\n\", maxsock);\n\t\t    for (sock = maxsock; sock > 2; sock--)\n\t\t      if (sock != ctrl)\n\t\t\tclose (sock);\n\t\t  }\n\t\trun_service (ctrl, sep);\n\t      }\n\t    if (!sep->se_wait && sep->se_socktype == SOCK_STREAM)\n\t      close (ctrl);\n\t  }\n    }\n}",
      "lines": 215,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/logger.c": {
    "decode": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "int\ndecode (char *name, CODE *codetab, const char *what)\n{\n  CODE *cp;\n\n  if (isdigit (*name))\n    {\n      char *p;\n      unsigned long n = strtoul (name, &p, 0);\n\n      /* For portability reasons, a numerical facility is entered\n       * as a decimal integer, shifted left by three binary bits.\n       * Any overflow check must adapt to this fact.\n       * For the purpose of remote logging from a local system,\n       * tests based on LOG_NFACILITIES are insufficient, as a\n       * remote system may well distinguish more facilities than\n       * the local system does!\n       */\n      if (*p || n > LOG_FACMASK)\t/* Includes range errors.  */\n\terror (EXIT_FAILURE, 0, \"invalid %s number: %s\", what, name);\n\n      return n;\n    }\n\n  for (cp = codetab; cp->c_name; cp++)\n    {\n      if (strcasecmp (name, cp->c_name) == 0)\n\treturn cp->c_val;\n    }\n  error (EXIT_FAILURE, 0, \"unknown %s name: %s\", what, name);\n  return -1; /* to pacify gcc */\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "parse_level": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nparse_level (char *str)\n{\n  char *p;\n  int fac, prio = LOG_NOTICE;\t/* Default priority!  */\n\n  p = strchr (str, '.');\n  if (p)\n    *p++ = 0;\n\n  fac = decode (str, facilitynames, \"facility\");\n  if (p)\n    prio = decode (p, prioritynames, \"priority\");\n\n  return MAKE_PRI (fac, prio);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "open_socket": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static void\nopen_socket (void)\n{\n  union logger_sockaddr sockaddr;\n  socklen_t socklen;\n  int family;\n#if HAVE_DECL_GETADDRINFO\n  int ret;\n#endif\n\n  /* A UNIX socket name can be specified in two ways.\n   * Zero length of `unixsock' is handled automatically.  */\n  if ((host != NULL && strchr (host, '/')) || unixsock != NULL)\n    {\n      size_t len;\n\n      /* Copy `unixsock' to `host' if necessary.\n       * There is no need to differentiate them.  */\n      if (unixsock)\n\thost = unixsock;\n      len = strlen (host);\n      if (len >= sizeof sockaddr.sunix.sun_path)\n\terror (EXIT_FAILURE, 0, \"UNIX socket name too long\");\n      strcpy (sockaddr.sunix.sun_path, host);\n      sockaddr.sunix.sun_family = AF_UNIX;\n      family = PF_UNIX;\n      socklen = sizeof (sockaddr.sunix);\n    }\n  else\n    {\n#if HAVE_DECL_GETADDRINFO\n      struct addrinfo hints, *ai, *res;\n#else\n      struct hostent *hp;\n      struct servent *sp;\n      unsigned short port;\n#endif /* !HAVE_DECL_GETADDRINFO */\n      char *p;\n\n#if HAVE_IPV6\n      /* Bare, numeric IPv6 addresses must be contained\n       * in brackets in order that an appended port not\n       * be read by mistake.  */\n      if (*host == '[')\n\t{\n\t  ++host;\n\t  p = strchr (host, ']');\n\t  if (p)\n\t    {\n\t      *p++ = '\\0';\n\t      if (*p == ':')\n\t\t++p;\n\t      else\n\t\tp = NULL;\n\t    }\n\t}\n      else\n        {\n\t  /* When no bracket was detected, then seek the\n\t   * right-most colon character in order to correctly\n\t   * parse IPv6 addresses.  */\n\t  p = strrchr (host, ':');\n\t  if (p)\n\t    *p++ = 0;\n\t}\n#else /* !HAVE_IPV6 */\n      p = strchr (host, ':');\n      if (p)\n\t*p++ = 0;\n#endif /* !HAVE_IPV6 */\n\n      if (!p)\n\tp = \"syslog\";\n\n#if HAVE_DECL_GETADDRINFO\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_socktype = SOCK_DGRAM;\n\n      /* This falls back to AF_INET if compilation\n       * was made with !HAVE_IPV6.  */\n      hints.ai_family = host_family;\n\n      /* The complete handshake is attempted within\n       * a single while-loop, since the answers from\n       * getaddrinfo() need to be checked in detail.  */\n      ret = getaddrinfo (host, p, &hints, &res);\n      if (ret < 0)\n\terror (EXIT_FAILURE, 0, \"%s:%s, %s\", host, p, gai_strerror(ret));\n\n      for (ai = res; ai; ai = ai->ai_next)\n        {\n\t  fd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t  if (fd < 0)\n\t    continue;\n\n\t  if (source)\n\t    {\n\t      /* Resolver uses the same address family\n\t       * as the already resolved target host.\n\t       */\n\t      int ret;\n\t      struct addrinfo tips, *a;\n\n\t      memset (&tips, 0, sizeof (tips));\n\t      tips.ai_family = ai->ai_family;\n\n\t      ret = getaddrinfo(source, NULL, &tips, &a);\n\t      if (ret)\n\t\t{\n\t\t  close (fd);\n\t\t  continue;\n\t\t}\n\n\t      if (bind (fd, a->ai_addr, a->ai_addrlen))\n\t\t{\n\t\t  freeaddrinfo (a);\n\t\t  close (fd);\n\t\t  continue;\n\t\t}\n\n\t      freeaddrinfo (a);\n\t    }\n\n\t  if (connect (fd, ai->ai_addr, ai->ai_addrlen))\n\t    {\n\t      close (fd);\n\t      continue;\n\t    }\n\n\t  /* Socket standing, bound and connected.  */\n\t  break;\n\t}\n\n      if (res)\n\tfreeaddrinfo (res);\n\n      if (ai == NULL)\n\terror (EXIT_FAILURE, EADDRNOTAVAIL, \"%s:%s\", host, p);\n\n      /* Existing socket can be returned now.\n       * This handles AF_INET and AF_INET6 in case\n       * HAVE_DECL_GETADDRINFO is true.  */\n      return;\n\n#else /* !HAVE_DECL_GETADDRINFO */\n\n      sockaddr.sinet.sin_family = AF_INET;\n      family = PF_INET;\n\n      hp = gethostbyname (host);\n      if (hp)\n\tsockaddr.sinet.sin_addr.s_addr = *(unsigned long*) hp->h_addr_list[0];\n      else if (inet_aton (host, (struct in_addr *) &sockaddr.sinet.sin_addr)\n\t       != 1)\n\terror (EXIT_FAILURE, 0, \"unknown host name\");\n\n      if (isdigit (*p))\n\t{\n\t  char *end;\n\t  unsigned long n = strtoul (p, &end, 10);\n\t  if (*end || (port = n) != n)\n\t    error (EXIT_FAILURE, 0, \"%s: invalid port number\", p);\n\t  port = htons (port);\n\t}\n      else if ((sp = getservbyname (p, \"udp\")) != NULL)\n\tport = sp->s_port;\n      else\n\terror (EXIT_FAILURE, 0, \"%s: unknown service name\", p);\n\n      sockaddr.sinet.sin_port = port;\n#endif /* !HAVE_DECL_GETADDRINFO */\n\n      socklen = sizeof (sockaddr.sinet);\n    }\n\n  /* Execution arrives here for AF_UNIX and for\n   * situations with !HAVE_DECL_GETADDRINFO.  */\n\n  fd = socket (family, SOCK_DGRAM, 0);\n  if (fd < 0)\n    error (EXIT_FAILURE, errno, \"cannot create socket\");\n\n  if (family == PF_INET)\n    {\n      struct sockaddr_in s;\n      s.sin_family = AF_INET;\n\n      if (source)\n\t{\n\t  if (inet_aton (source, (struct in_addr *) &s.sin_addr) != 1)\n\t    error (EXIT_FAILURE, 0, \"invalid source address\");\n\t}\n      else\n\ts.sin_addr.s_addr = INADDR_ANY;\n      s.sin_port = 0;\n\n      if (bind(fd, (struct sockaddr*) &s, sizeof(s)) < 0)\n\terror (EXIT_FAILURE, errno, \"cannot bind to source address\");\n    }\n\n  if (connect (fd, &sockaddr.sa, socklen))\n    error (EXIT_FAILURE, errno, \"cannot connect\");\n}",
      "lines": 203,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_to_syslog": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "static void\nsend_to_syslog (const char *msg)\n{\n  char *pbuf;\n  time_t now = time (NULL);\n  size_t len;\n  ssize_t rc;\n\n  if (logflags & LOG_PID)\n    rc = asprintf (&pbuf, \"<%d>%.15s %s[%s]: %s\",\n\t\t   pri, ctime (&now) + 4, tag, pidstr, msg);\n  else\n    rc = asprintf (&pbuf, \"<%d>%.15s %s: %s\",\n\t\t   pri, ctime (&now) + 4, tag, msg);\n  if (rc == -1)\n    error (EXIT_FAILURE, errno, \"cannot format message\");\n  len = strlen (pbuf);\n\n#ifdef LOG_PERROR\n  if (logflags & LOG_PERROR)\n    {\n      struct iovec iov[2], *ioptr;\n      size_t msglen = strlen (msg);\n\n      ioptr = iov;\n      ioptr->iov_base = (char*) msg;\n      ioptr->iov_len = msglen;\n\n      if (msg[msglen - 1] != '\\n')\n\t{\n\t  /* provide a newline */\n\t  ioptr++;\n\t  ioptr->iov_base = (char *) \"\\n\";\n\t  ioptr->iov_len = 1;\n\t}\n      writev (fileno (stderr), iov, ioptr - iov + 1);\n    }\n#endif /* LOG_PERROR */\n\n  rc = send (fd, pbuf, len, 0);\n  free (pbuf);\n  if (rc == -1)\n    error (0, errno, \"send failed\");\n  else if (rc != (ssize_t) len)\n    error (0, errno, \"sent less bytes than expected (%lu vs. %lu)\",\n\t   (unsigned long) rc, (unsigned long) len);\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case '4':\n      host_family = AF_INET;\n      break;\n\n    case '6':\n#if HAVE_IPV6\n      host_family = AF_INET6;\n      break;\n\n#else /* !HAVE_IPV6 */\n      /* Print a warning but continue with IPv4.  */\n      error (0, 0, \"warning: Falling back to IPv4, \"\n\t\t\"since IPv6 is disabled\");\n      /* AF_INET is set by default in this case.  */\n      break;\n#endif /* !HAVE_IPV6 */\n\n    case 'h':\n      host = arg;\n      unixsock = NULL;\t/* Erase any previous `-u'.  */\n      break;\n\n    case 'u':\n      unixsock = arg;\n      host = NULL;\t/* Erase previous `-h'.  */\n      break;\n\n    case 'S':\n      source = arg;\n      break;\n\n    case 'i':\n      logflags |= LOG_PID;\n      if (arg)\n\tpidstr = arg;\n      else\n\t{\n\t  char buf[INT_BUFSIZE_BOUND (uintmax_t)];\n\t  arg = umaxtostr (getpid (), buf);\n\t  pidstr = xstrdup (arg);\n\t}\n      break;\n\n#ifdef LOG_PERROR\n    case 's':\n      logflags |= LOG_PERROR;\n      break;\n#endif /* LOG_PERROR */\n\n    case 'f':\n      if (strcmp (arg, \"-\") && freopen (arg, \"r\", stdin) == NULL)\n        error (EXIT_FAILURE, errno, \"%s\", arg);\n      break;\n\n    case 'p':\n      pri = parse_level (arg);\n      break;\n\n    case 't':\n      tag = arg;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 73,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n  char *buf = NULL;\n\n  set_program_name (argv[0]);\n  iu_argp_init (\"logger\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  argc -= index;\n  argv += index;\n\n  if (!tag)\n    {\n      tag = getenv (\"USER\");\n      if (!tag)\n\t{\n\t  struct passwd *pw = getpwuid (getuid ());\n\t  if (pw)\n\t    tag = xstrdup (pw->pw_name);\n\t  else\n\t    tag = xstrdup (\"none\");\n\t}\n    }\n\n  open_socket ();\n\n  if (argc > 0)\n    {\n      int i;\n      size_t len = 0;\n      char *p;\n\n      for (i = 0; i < argc; i++)\n\tlen += strlen (argv[i]) + 1;\n\n      buf = xmalloc (len);\n      for (i = 0, p = buf; i < argc; i++)\n\t{\n\t  len = strlen (argv[i]);\n\t  memcpy (p, argv[i], len);\n\t  p += len;\n\t  *p++ = ' ';\n\t}\n      p[-1] = 0;\n\n      send_to_syslog (buf);\n    }\n  else\n    {\n      size_t size = 0;\n\n      while (getline (&buf, &size, stdin) > 0)\n\tsend_to_syslog (buf);\n    }\n  free (buf);\n  exit (EXIT_SUCCESS);\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/logprio.h": {},
  "inetutils/inetutils-1.9.4/src/rcp.c": {
    "parse_opt": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n#if defined WITH_ORCMD_AF || defined WITH_RCMD_AF || defined SHISHI\n    case '4':\n      family = AF_INET;\n      break;\n    case '6':\n      family = AF_INET6;\n      break;\n#endif /* WITH_ORCMD_AF || WITH_RCMD_AF || SHISHI */\n\n#if defined KERBEROS || defined SHISHI\n    case 'K':\n      use_kerberos = 0;\n      break;\n\n    case 'k':\n      dest_realm = arg;\n      break;\n\n# ifdef ENCRYPTION\n    case 'x':\n      doencrypt = 1;\n#  ifdef KERBEROS\n      des_set_key(cred.session, schedule);\n#  endif\n      break;\n# endif /* ENCRYPTION */\n#endif /* KERBEROS || SHISHI */\n\n    case 'p':\n      preserve_option = 1;\n      break;\n\n    case 'r':\n      iamrecursive = 1;\n      break;\n\n      /* Server options. */\n    case 'd':\n      targetshouldbedirectory = 1;\n      if (arg && strlen (arg))\n\ttarget = xstrdup (arg);\t/* Client side use.  */\n      break;\n\n    case 'f':\t\t/* \"from\" */\n      iamremote = 1;\n      from_option = 1;\n      break;\n\n    case 't':\t\t/* \"to\" */\n      iamremote = 1;\n      to_option = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  struct servent *sp;\n  char *targ;\n  const char *shell;\n  int index, rc;\n\n  set_program_name (argv[0]);\n\n  from_option = to_option = 0;\n  iu_argp_init (\"rcp\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n  argc -= index;\n  argv += index;\n\n#if defined KERBEROS || defined SHISHI\n  if (use_kerberos)\n    {\n# if defined ENCRYPTION && defined KERBEROS\n      shell = doencrypt ? \"ekshell\" : \"kshell\";\n# else /* SHISHI */\n      shell = \"kshell\";\t\t/* Libshishi uses a single service.  */\n# endif\n\n      sp = getservbyname (shell, \"tcp\");\n      if (sp == NULL)\n\t{\n\t  use_kerberos = 0;\n\t  oldw (\"can't get entry for %s/tcp service\", shell);\n\t  sp = getservbyname (shell = \"shell\", \"tcp\");\n\t}\n    }\n  else\n    sp = getservbyname (shell = \"shell\", \"tcp\");\n#else /* !KERBEROS && !SHISHI */\n  sp = getservbyname (shell = \"shell\", \"tcp\");\n#endif\n  if (sp == NULL)\n    error (EXIT_FAILURE, 0, \"%s/tcp: unknown service\", shell);\n  port = sp->s_port;\n\n  effuid = geteuid ();\n  userid = getuid ();\n  pwd = getpwuid (userid);\n  if (pwd == NULL)\n    error (EXIT_FAILURE, 0, \"unknown user %d\", (int) userid);\n\n  rem = STDIN_FILENO;\t\t/* XXX */\n\n  if (from_option)\n    {\t\t\t\t/* Follow \"protocol\", send data. */\n      response ();\n      setuid (userid);\n      source (argc, argv);\n      exit (errs);\n    }\n\n  if (to_option)\n    {\t\t\t\t/* Receive data. */\n      setuid (userid);\n      sink (argc, argv);\n      exit (errs);\n    }\n\n  if (argc < 1 || (argc < 2 && !(target && strlen (target))))\n    error (EXIT_FAILURE, 0, \"not enough arguments\");\n\n  if (argc > 2)\n    targetshouldbedirectory = 1;\n\n#if defined KERBEROS || defined SHISHI\n  if (doencrypt && !use_kerberos)\n    error (EXIT_FAILURE, 0, \"encryption must use Kerberos\");\n#endif\n\n  /* Command to be executed on remote system using \"rsh\". */\n  rc = asprintf (&command, \"rcp%s%s%s\",\n\t\t iamrecursive ? \" -r\" : \"\", preserve_option ? \" -p\" : \"\",\n\t\t targetshouldbedirectory ? \" -d\" : \"\");\n\n  if (rc < 0)\n    xalloc_die ();\n\n  rem = -1;\n  signal (SIGPIPE, lostconn);\n\n  /* Without a specified target, the last argument\n   * is extracted to serve as target.\n   */\n  if (!target || !strlen (target))\n    {\n      target = xstrdup (argv[argc - 1]);\n      argc--;\t\t\t/* Do not count target directory.  */\n    }\n\n  targ = colon (target);\n  if (targ)\t\t\t/* Dest is remote host. */\n    toremote (targ, argc, argv);\n  else\n    {\n      tolocal (argc, argv);\t/* Dest is local host. */\n      if (targetshouldbedirectory)\n\tverifydir (target);\n    }\n  exit (errs);\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "toremote": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "void\ntoremote (char *targ, int argc, char *argv[])\n{\n  int i, tos;\n  char *bp, *host, *src, *suser, *thost, *tuser;\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  struct sockaddr_storage ss;\n  socklen_t sslen;\n#endif\n\n  *targ++ = 0;\n  if (*targ == 0)\n    targ = \".\";\n\n  thost = strchr (target, '@');\n  if (thost)\n    {\n      /* user@host */\n      *thost++ = 0;\n      tuser = target;\n      if (*tuser == '\\0')\n\ttuser = NULL;\n      else if (!okname (tuser))\n\texit (EXIT_FAILURE);\n    }\n  else\n    {\n      thost = target;\n      tuser = NULL;\n    }\n\n  for (i = 0; i < argc; i++)\n    {\n      src = colon (argv[i]);\n      if (src)\n\t{\t\t\t/* remote to remote */\n\t  *src++ = 0;\n\t  if (*src == 0)\n\t    src = \".\";\n\t  host = strchr (argv[i], '@');\n\n\t  if (host)\n\t    {\n\t      *host++ = 0;\n\t      suser = argv[i];\n\t      if (*suser == '\\0')\n\t\tsuser = pwd->pw_name;\n\t      else if (!okname (suser))\n\t\tcontinue;\n\t      if (asprintf (&bp,\n#if defined ENCRYPTION && (defined KERBEROS || defined SHISHI)\n\t\t\t    \"%s%s -l %s -n %s %s %s '%s%s%s:%s'\",\n#else\n\t\t\t    \"%s -l %s -n %s %s %s '%s%s%s:%s'\",\n#endif\n\t\t\t    PATH_RSH,\n#if ENCRYPTION && (defined KERBEROS || defined SHISHI)\n\t\t\t    doencrypt ? \" -x\" : \"\",\n#endif\n\t\t\t    suser, host, command, src,\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ) < 0)\n\t\txalloc_die ();\n\t    }\n\t  else\n\t    {\n\t      if (asprintf (&bp,\n#if defined ENCRYPTION && (defined KERBEROS || defined SHISHI)\n\t\t\t    \"exec %s%s -n %s %s %s '%s%s%s:%s'\",\n#else\n\t\t\t    \"exec %s -n %s %s %s '%s%s%s:%s'\",\n#endif\n\t\t\t    PATH_RSH,\n#if ENCRYPTION && (defined KERBEROS || defined SHISHI)\n\t\t\t    doencrypt ? \" -x\" : \"\",\n#endif\n\t\t\t    argv[i], command, src,\n\t\t\t    tuser ? tuser : \"\", tuser ? \"@\" : \"\",\n\t\t\t    thost, targ) < 0)\n\t\txalloc_die ();\n\t    }\n\t  susystem (bp, userid);\n\t  free (bp);\n\t}\n      else\n\t{\t\t\t/* local to remote */\n\t  if (rem == -1)\n\t    {\n\t      if (asprintf (&bp, \"%s -t %s\", command, targ) < 0)\n\t\txalloc_die ();\n\t      host = thost;\n#if defined KERBEROS || defined SHISHI\n\t      if (use_kerberos)\n\t\trem = kerberos (&host, bp, pwd->pw_name,\n\t\t\t\ttuser ? tuser : pwd->pw_name);\n\t      else\n#endif /* KERBEROS || SHISHI */\n#ifdef WITH_ORCMD_AF\n\t\trem = orcmd_af (&host, port, pwd->pw_name,\n\t\t\t\ttuser ? tuser : pwd->pw_name,\n\t\t\t\tbp, 0, family);\n#elif defined WITH_RCMD_AF\n\t\trem = rcmd_af (&host, port, pwd->pw_name,\n\t\t\t       tuser ? tuser : pwd->pw_name,\n\t\t\t       bp, 0, family);\n#elif defined WITH_ORCMD\n\t\trem = orcmd (&host, port, pwd->pw_name,\n\t\t\t     tuser ? tuser : pwd->pw_name, bp, 0);\n#else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n\t\trem = rcmd (&host, port, pwd->pw_name,\n\t\t\t    tuser ? tuser : pwd->pw_name, bp, 0);\n#endif\n\t      if (rem < 0)\n\t\t{\n\t\t  /* rcmd() provides its own error messages,\n\t\t   * but we add a vital addition, caused by\n\t\t   * insufficient capabilites.\n\t\t   */\n\t\t  if (errno == EACCES)\n\t\t    error (EXIT_FAILURE, 0,\n\t\t\t   \"No access to privileged ports.\");\n\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n\t      sslen = sizeof (ss);\n\t      (void) getpeername (rem, (struct sockaddr *) &ss, &sslen);\n\t      tos = IPTOS_THROUGHPUT;\n\t      if (ss.ss_family == AF_INET &&\n\t\t  setsockopt (rem, IPPROTO_IP, IP_TOS,\n\t\t\t      (char *) &tos, sizeof (int)) < 0)\n\t\tif (errno != ENOPROTOOPT)\n\t\t  error (0, errno, \"TOS (ignored)\");\n#endif\n\t      if (response () < 0)\n\t\texit (EXIT_FAILURE);\n\t      free (bp);\n\t      setuid (userid);\n\t    }\n\t  source (1, argv + i);\n\t  close (rem);\n\t  rem = -1;\n#ifdef SHISHI\n\t  if (use_kerberos)\n\t    {\n\t      shishi_done (h);\n# ifdef ENCRYPTION\n\t      if (doencrypt)\n\t\t{\n\t\t  shishi_key_done (enckey);\n\t\t  for (i = 0; i < 4; i++)\n\t\t    {\n\t\t      shishi_crypto_close (ivtab[i]->ctx);\n\t\t      free (ivtab[i]->iv);\n\t\t    }\n\t\t}\n# endif /* ENCRYPTION */\n\t    }\n#endif /* SHISHI */\n\t}\n    }\n}",
      "lines": 162,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "tolocal": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        670,
        1
      ],
      "content": "void\ntolocal (int argc, char *argv[])\n{\n  int i, len, tos;\n  char *bp, *host, *src, *suser, *vect[1];\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n  struct sockaddr_storage ss;\n  socklen_t sslen;\n#endif\n\n  for (i = 0; i < argc; i++)\n    {\n      src = colon (argv[i]);\n      if (!src)\n\t{\t\t\t/* Local to local. */\n\t  len = strlen (PATH_CP) + strlen (argv[i]) +\n\t\tstrlen (target) + 20;\n\t  if (asprintf (&bp, \"exec %s%s%s %s %s\",\n\t\t\tPATH_CP,\n\t\t\tiamrecursive ? \" -R\" : \"\",\n\t\t\tpreserve_option ? \" -p\" : \"\",\n\t\t\targv[i], target) < 0)\n\t    xalloc_die ();\n\t  if (susystem (bp, userid))\n\t    ++errs;\n\t  free (bp);\n\t  continue;\n\t}\n      *src++ = 0;\n      if (*src == 0)\n\tsrc = \".\";\n\n      host = strchr (argv[i], '@');\n      if (host == NULL)\n\t{\n\t  host = argv[i];\n\t  suser = pwd->pw_name;\n\t}\n      else\n\t{\n\t  *host++ = 0;\n\t  suser = argv[i];\n\t  if (*suser == '\\0')\n\t    suser = pwd->pw_name;\n\t  else if (!okname (suser))\n\t    continue;\n\t}\n      if (asprintf (&bp, \"%s -f %s\", command, src) < 0)\n\txalloc_die ();\n\n#if defined KERBEROS || defined SHISHI\n      if (use_kerberos)\n\trem = kerberos (&host, bp, pwd->pw_name, suser);\n      else\n#elif defined WITH_ORCMD_AF\n\trem = orcmd_af (&host, port, pwd->pw_name, suser, bp, 0, family);\n#elif defined WITH_RCMD_AF\n\trem = rcmd_af (&host, port, pwd->pw_name, suser, bp, 0, family);\n#elif defined WITH_ORCMD\n\trem = orcmd (&host, port, pwd->pw_name, suser, bp, 0);\n#else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n\trem = rcmd (&host, port, pwd->pw_name, suser, bp, 0);\n#endif\n      free (bp);\n      if (rem < 0)\n\t{\n\t  ++errs;\n\t  continue;\n\t}\n      seteuid (userid);\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_THROUGHPUT\n      sslen = sizeof (ss);\n      (void) getpeername (rem, (struct sockaddr *) &ss, &sslen);\n      tos = IPTOS_THROUGHPUT;\n      if (ss.ss_family == AF_INET &&\n\t  setsockopt (rem, IPPROTO_IP, IP_TOS,\n\t\t      (char *) &tos, sizeof (int)) < 0)\n\tif (errno != ENOPROTOOPT)\n\t  error (0, errno, \"TOS (ignored)\");\n#endif\n      vect[0] = target;\n      sink (1, vect);\n      seteuid (effuid);\n      close (rem);\n      rem = -1;\n#ifdef SHISHI\n      if (use_kerberos)\n\tshishi_done (h);\n\t{\n# ifdef ENCRYPTION\n\t  if (doencrypt)\n\t    {\n\t      shishi_key_done (enckey);\n\t      for (i = 0; i < 4; i++)\n\t\t{\n\t\t  shishi_crypto_close (ivtab[i]->ctx);\n\t\t  free (ivtab[i]->iv);\n\t\t}\n\t    }\n# endif /* ENCRYPTION */\n\t}\n#endif /* SHISHI */\n    }\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "write_stat_time": {
      "start_point": [
        672,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "static int\nwrite_stat_time (int fd, struct stat *stat)\n{\n  char buf[4 * sizeof (long) * 3 + 2];\n  time_t a_sec, m_sec;\n  long a_usec = 0, m_usec = 0;\n\n  a_sec = stat->st_atime;\n#ifdef HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC\n  a_usec = stat->st_atim.tv_nsec / 1000;\n#elif defined HAVE_STRUCT_STAT_ST_ATIM_TV_USEC\n  a_usec = stat->st_atim.tv_usec;\n#endif\n\n  m_sec = stat->st_mtime;\n#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n  m_usec = stat->st_mtim.tv_nsec / 1000;\n#elif defined HAVE_STRUCT_STAT_ST_MTIM_TV_USEC\n  m_usec = stat->st_mtim.tv_usec;\n#endif\n\n  snprintf (buf, sizeof (buf), \"T%ld %ld %ld %ld\\n\",\n\t    m_sec, m_usec, a_sec, a_usec);\n  return write (fd, buf, strlen (buf));\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "source": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        790,
        1
      ],
      "content": "void\nsource (int argc, char *argv[])\n{\n  struct stat stb;\n  static BUF buffer;\n  BUF *bp;\n  off_t i;\n  int amt, fd, haderr, indx, result;\n  char *last, *name, buf[BUFSIZ];\n\n  for (indx = 0; indx < argc; ++indx)\n    {\n      name = argv[indx];\n      fd = open (name, O_RDONLY, 0);\n      if (fd < 0)\n\tgoto syserr;\n      if (fstat (fd, &stb))\n\t{\n\tsyserr:\n\t  run_err (\"%s: %s\", name, strerror (errno));\n\t  goto next;\n\t}\n      switch (stb.st_mode & S_IFMT)\n\t{\n\tcase S_IFREG:\n\t  break;\n\n\tcase S_IFDIR:\n\t  if (iamrecursive)\n\t    {\n\t      rsource (name, &stb);\n\t      goto next;\n\t    }\n\tdefault:\n\t  run_err (\"%s: not a regular file\", name);\n\t  goto next;\n\t}\n      last = strrchr (name, '/');\n      if (last == NULL)\n\tlast = name;\n      else\n\t++last;\n      if (preserve_option)\n\t{\n\t  write_stat_time (rem, &stb);\n\t  if (response () < 0)\n\t    goto next;\n\t}\n#define RCP_MODEMASK\t(S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)\n      snprintf (buf, sizeof buf, \"C%04o %jd %s\\n\",\n\t\tstb.st_mode & RCP_MODEMASK, (intmax_t) stb.st_size, last);\n      write (rem, buf, strlen (buf));\n      if (response () < 0)\n\tgoto next;\n\n      bp = allocbuf (&buffer, fd, BUFSIZ);\n      if (bp == NULL)\n\t{\n\tnext:\n\t  close (fd);\n\t  continue;\n\t}\n\n      /* Keep writing after an error so that we stay sync'd up. */\n      for (haderr = i = 0; i < stb.st_size; i += bp->cnt)\n\t{\n\t  amt = bp->cnt;\n\t  if (i + amt > stb.st_size)\n\t    amt = stb.st_size - i;\n\t  if (!haderr)\n\t    {\n\t      result = read (fd, bp->buf, amt);\n\t      if (result != amt)\n\t\thaderr = result >= 0 ? EIO : errno;\n\t    }\n\t  if (haderr)\n\t    write (rem, bp->buf, amt);\n\t  else\n\t    {\n\t      result = write (rem, bp->buf, amt);\n\t      if (result != amt)\n\t\thaderr = result >= 0 ? EIO : errno;\n\t    }\n\t}\n      if (close (fd) && !haderr)\n\thaderr = errno;\n      if (!haderr)\n\twrite (rem, \"\", 1);\n      else\n\trun_err (\"%s: %s\", name, strerror (haderr));\n      response ();\n    }\n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "rsource": {
      "start_point": [
        792,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "void\nrsource (char *name, struct stat *statp)\n{\n  DIR *dirp;\n  struct dirent *dp;\n  char *last, *vect[1];\n  char *buf;\n  int buf_len;\n\n  dirp = opendir (name);\n  if (!dirp)\n    {\n      run_err (\"%s: %s\", name, strerror (errno));\n      return;\n    }\n  last = strrchr (name, '/');\n  if (last == 0)\n    last = name;\n  else\n    last++;\n\n  if (preserve_option)\n    {\n      write_stat_time (rem, statp);\n      if (response () < 0)\n\t{\n\t  closedir (dirp);\n\t  return;\n\t}\n    }\n\n  buf_len =\n    1 + sizeof (int) * 3 + 1 + sizeof (int) * 3 + 1 + strlen (last) + 2;\n  buf = malloc (buf_len);\n  if (!buf)\n    {\n      run_err (\"malloc failed for %d bytes\", buf_len);\n      closedir (dirp);\n      return;\n    }\n\n  sprintf (buf, \"D%04o %d %s\\n\", statp->st_mode & RCP_MODEMASK, 0, last);\n  write (rem, buf, strlen (buf));\n  free (buf);\n\n  if (response () < 0)\n    {\n      closedir (dirp);\n      return;\n    }\n\n  while ((dp = readdir (dirp)))\n    {\n      if (!strcmp (dp->d_name, \".\") || !strcmp (dp->d_name, \"..\"))\n\tcontinue;\n\n      buf_len = strlen (name) + 1 + strlen (dp->d_name) + 1;\n      buf = malloc (buf_len);\n      if (!buf)\n\t{\n\t  run_err (\"malloc_failed for %d bytes\", buf_len);\n\t  continue;\n\t}\n\n      sprintf (buf, \"%s/%s\", name, dp->d_name);\n      vect[0] = buf;\n\n      source (1, vect);\n\n      free (buf);\n    }\n\n  closedir (dirp);\n  write (rem, \"E\\n\", 2);\n  response ();\n}",
      "lines": 76,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sink": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "void\nsink (int argc, char *argv[])\n{\n  static BUF buffer;\n  struct stat stb;\n  struct timeval tv[2];\n  enum\n  { YES, NO, DISPLAYED } wrerr;\n  BUF *bp;\n  off_t i, j;\n  int amt, count, exists, first, mask, mode, ofd, omode;\n  int setimes, size, targisdir, wrerrno;\n  char ch, *cp, *np, *targ, *vect[1], buf[BUFSIZ];\n  const char *why;\n\n#define atime\ttv[0]\n#define mtime\ttv[1]\n#define SCREWUP(str)\t{ why = str; goto screwup; }\n\n  setimes = targisdir = 0;\n  mask = umask (0);\n  if (!preserve_option)\n    umask (mask);\n  if (argc != 1)\n    {\n      run_err (\"ambiguous target\");\n      exit (EXIT_FAILURE);\n    }\n  targ = *argv;\n  if (targetshouldbedirectory)\n    verifydir (targ);\n  write (rem, \"\", 1);\n  if (stat (targ, &stb) == 0 && S_ISDIR (stb.st_mode))\n    targisdir = 1;\n  for (first = 1;; first = 0)\n    {\n      cp = buf;\n      if (read (rem, cp, 1) <= 0)\n\treturn;\n      if (*cp++ == '\\n')\n\tSCREWUP (\"unexpected <newline>\");\n      do\n\t{\n\t  if (read (rem, &ch, sizeof ch) != sizeof ch)\n\t    SCREWUP (\"lost connection\");\n\t  *cp++ = ch;\n\t}\n      while (cp < &buf[BUFSIZ - 1] && ch != '\\n');\n      *cp = 0;\n\n      if (buf[0] == '\\01' || buf[0] == '\\02')\n\t{\n\t  if (iamremote == 0)\n\t    write (STDERR_FILENO, buf + 1, strlen (buf + 1));\n\t  if (buf[0] == '\\02')\n\t    exit (EXIT_FAILURE);\n\t  ++errs;\n\t  continue;\n\t}\n      if (buf[0] == 'E')\n\t{\n\t  write (rem, \"\", 1);\n\t  return;\n\t}\n\n      if (ch == '\\n')\n\t*--cp = 0;\n\n#define getnum(t) (t) = 0; while (isdigit(*cp)) (t) = (t) * 10 + (*cp++ - '0');\n      cp = buf;\n      if (*cp == 'T')\n\t{\n\t  setimes++;\n\t  cp++;\n\t  getnum (mtime.tv_sec);\n\t  if (*cp++ != ' ')\n\t    SCREWUP (\"mtime.sec not delimited\");\n\t  getnum (mtime.tv_usec);\n\t  if (*cp++ != ' ')\n\t    SCREWUP (\"mtime.usec not delimited\");\n\t  getnum (atime.tv_sec);\n\t  if (*cp++ != ' ')\n\t    SCREWUP (\"atime.sec not delimited\");\n\t  getnum (atime.tv_usec);\n\t  if (*cp++ != '\\0')\n\t    SCREWUP (\"atime.usec not delimited\");\n\t  write (rem, \"\", 1);\n\t  continue;\n\t}\n      if (*cp != 'C' && *cp != 'D')\n\t{\n\t  /*\n\t   * Check for the case \"rcp remote:foo\\* local:bar\".\n\t   * In this case, the line \"No match.\" can be returned\n\t   * by the shell before the rcp command on the remote is\n\t   * executed so the ^Aerror_message convention isn't\n\t   * followed.\n\t   */\n\t  if (first)\n\t    {\n\t      run_err (\"%s\", cp);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  SCREWUP (\"expected control record\");\n\t}\n      mode = 0;\n      for (++cp; cp < buf + 5; cp++)\n\t{\n\t  if (*cp < '0' || *cp > '7')\n\t    SCREWUP (\"bad mode\");\n\t  mode = (mode << 3) | (*cp - '0');\n\t}\n      if (*cp++ != ' ')\n\tSCREWUP (\"mode not delimited\");\n\n      for (size = 0; isdigit (*cp);)\n\tsize = size * 10 + (*cp++ - '0');\n      if (*cp++ != ' ')\n\tSCREWUP (\"size not delimited\");\n      if (targisdir)\n\t{\n\t  static char *namebuf = NULL;\n\t  static size_t cursize = 0;\n\t  size_t need;\n\n\t  need = strlen (targ) + strlen (cp) + 250;\n\t  if (need > cursize)\n\t    {\n\t      free (namebuf);\n\t      namebuf = malloc (need);\n\t      if (namebuf)\n\t\tcursize = need;\n\t      else\n\t\t{\n\t\t  run_err (\"%s\", strerror (errno));\n\t\t  cursize = 0;\n\t\t  continue;\n\t\t}\n\t    }\n\t  snprintf (namebuf, cursize, \"%s%s%s\", targ, *targ ? \"/\" : \"\", cp);\n\t  np = namebuf;\n\t}\n      else\n\tnp = targ;\n      exists = stat (np, &stb) == 0;\n      if (buf[0] == 'D')\n\t{\n\t  int mod_flag = preserve_option;\n\t  if (exists)\n\t    {\n\t      if (!S_ISDIR (stb.st_mode))\n\t\t{\n\t\t  errno = ENOTDIR;\n\t\t  goto bad;\n\t\t}\n\t      if (preserve_option)\n\t\tchmod (np, mode);\n\t    }\n\t  else\n\t    {\n\t      /* Handle copying from a read-only directory */\n\t      mod_flag = 1;\n\t      if (mkdir (np, mode | S_IRWXU) < 0)\n\t\tgoto bad;\n\t    }\n\t  vect[0] = np;\n\t  sink (1, vect);\n\t  if (setimes)\n\t    {\n#ifndef HAVE_UTIMES\n\t      struct utimbuf utbuf;\n\t      utbuf.actime = atime.tv_sec;\n\t      utbuf.modtime = mtime.tv_sec;\n#endif\n\t      setimes = 0;\n#ifdef HAVE_UTIMES\n\t      if (utimes (np, tv) < 0)\n#else\n\t      if (utime (np, &utbuf) < 0)\n#endif\n\t\trun_err (\"%s: set times: %s\", np, strerror (errno));\n\t    }\n\t  if (mod_flag)\n\t    chmod (np, mode);\n\t  continue;\n\t}\n      omode = mode;\n      mode |= S_IWRITE;\n      ofd = open (np, O_WRONLY | O_CREAT, mode);\n      if (ofd < 0)\n\t{\n\tbad:\n\t  run_err (\"%s: %s\", np, strerror (errno));\n\t  continue;\n\t}\n      write (rem, \"\", 1);\n      bp = allocbuf (&buffer, ofd, BUFSIZ);\n      if (bp == NULL)\n\t{\n\t  close (ofd);\n\t  continue;\n\t}\n      cp = bp->buf;\n      wrerr = NO;\n      for (count = i = 0; i < size; i += BUFSIZ)\n\t{\n\t  amt = BUFSIZ;\n\t  if (i + amt > size)\n\t    amt = size - i;\n\t  count += amt;\n\t  do\n\t    {\n\t      j = read (rem, cp, amt);\n\t      if (j <= 0)\n\t\t{\n\t\t  run_err (\"%s\", j ? strerror (errno) : \"dropped connection\");\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t      amt -= j;\n\t      cp += j;\n\t    }\n\t  while (amt > 0);\n\t  if (count == bp->cnt)\n\t    {\n\t      /* Keep reading so we stay sync'd up. */\n\t      if (wrerr == NO)\n\t\t{\n\t\t  j = write (ofd, bp->buf, count);\n\t\t  if (j != count)\n\t\t    {\n\t\t      wrerr = YES;\n\t\t      wrerrno = j >= 0 ? EIO : errno;\n\t\t    }\n\t\t}\n\t      count = 0;\n\t      cp = bp->buf;\n\t    }\n\t}\n      if (count != 0 && wrerr == NO\n\t  && (j = write (ofd, bp->buf, count)) != count)\n\t{\n\t  wrerr = YES;\n\t  wrerrno = j >= 0 ? EIO : errno;\n\t}\n      if (ftruncate (ofd, size))\n\t{\n\t  run_err (\"%s: truncate: %s\", np, strerror (errno));\n\t  wrerr = DISPLAYED;\n\t}\n      if (preserve_option)\n\t{\n\t  if (exists || omode != mode)\n\t    if (fchmod (ofd, omode))\n\t      run_err (\"%s: set mode: %s\", np, strerror (errno));\n\t}\n      else\n\t{\n\t  if (!exists && omode != mode)\n\t    if (fchmod (ofd, omode & ~mask))\n\t      run_err (\"%s: set mode: %s\", np, strerror (errno));\n\t}\n      close (ofd);\n      response ();\n      if (setimes && wrerr == NO)\n\t{\n#ifndef HAVE_UTIMES\n\t  struct utimbuf utbuf;\n\t  utbuf.actime = atime.tv_sec;\n\t  utbuf.modtime = mtime.tv_sec;\n#endif\n\t  setimes = 0;\n#ifdef HAVE_UTIMES\n\t  if (utimes (np, tv) < 0)\n\t    {\n#else\n\t  if (utime (np, &utbuf) < 0)\n\t    {\n#endif\n\t      run_err (\"%s: set times: %s\", np, strerror (errno));\n\t      wrerr = DISPLAYED;\n\t    }\n\t}\n      switch (wrerr)\n\t{\n\tcase YES:\n\t  run_err (\"%s: %s\", np, strerror (wrerrno));\n\t  break;\n\n\tcase NO:\n\t  write (rem, \"\", 1);\n\t  break;\n\n\tcase DISPLAYED:\n\t  break;\n\t}\n    }\nscrewup:\n  run_err (\"protocol error: %s\", why);\n  exit (EXIT_FAILURE);\n}\n\n#if defined KERBEROS || defined SHISHI\nint\nkerberos (char **host, char *bp, char *locuser, char *user)\n{\n  int krb_errno = 0;\n  struct servent *sp;\n\nagain:\n  if (use_kerberos)\n    {\n      errno = 0;\n# ifdef KERBEROS\n      rem = KSUCCESS;\n      if (dest_realm == NULL)\n\tdest_realm = krb_realmofhost (*host);\n# elif defined SHISHI\n      rem = SHISHI_OK;\n# endif\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n#  ifdef KERBEROS\n\t  rem = krcmd_mutual (host, port, user, bp, 0, dest_realm,\n\t\t\t      &cred, schedule) :\n\t  krb_errno = errno;\n#  elif defined SHISHI\n\t  int i;\n\t  char *xbp = NULL;\n\n\t  xbp = xmalloc (strlen (bp) + sizeof (\"-x \"));\n\t  sprintf (xbp, \"%s%s\", \"-x \", bp);\n\t  rem = krcmd_mutual (&h, host, port, &user, xbp, NULL,\n\t\t\t      dest_realm, &enckey, family);\n\t  krb_errno = errno;\n\t  if (rem > 0)\n\t    {\n\t      keytype = shishi_key_type (enckey);\n\t      keylen = shishi_cipher_blocksize (keytype);\n\n\t      ivtab[0] = &iv1;\n\t      ivtab[1] = &iv2;\n\t      ivtab[2] = &iv3;\n\t      ivtab[3] = &iv4;\n\n\t      for (i = 0; i < 4; i++)\n\t\t{\n\t\t  ivtab[i]->ivlen = keylen;\n\n\t\t  switch (keytype)\n\t\t    {\n\t\t    case SHISHI_DES_CBC_CRC:\n\t\t    case SHISHI_DES_CBC_MD4:\n\t\t    case SHISHI_DES_CBC_MD5:\n\t\t    case SHISHI_DES_CBC_NONE:\n\t\t    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t\t      ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv,\n\t\t\t      2 * i + 1 * (i < 2) - 4 * (i >= 2),\n\t\t\t      ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t      break;\n\t\t    case SHISHI_ARCFOUR_HMAC:\n\t\t    case SHISHI_ARCFOUR_HMAC_EXP:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), NULL, 0);\n\t\t      break;\n\t\t    default:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t    }\n\t\t}\n\t    }\n\t  free (xbp);\n#  endif\n\t}\n      else\n# endif /* ENCRYPTION */\n\t{\n# ifdef KERBEROS\n\t  rem = krcmd (host, port, user, bp, 0, dest_realm);\n# else /* SHISHI */\n\t  rem = krcmd (&h, host, port, &user, bp, NULL, dest_realm, family);\n# endif\n\t  krb_errno = errno;\n\t}\n\n      if (rem < 0)\n\t{\n\t  use_kerberos = 0;\n\t  if (krb_errno == ECONNREFUSED)\n\t    oldw (\"remote host doesn't support Kerberos\");\n\t  else if (krb_errno == ENOENT)\n\t    error (EXIT_FAILURE, 0, \"Can't provide Kerberos authentication data.\");\n\t  else\n\t    error (EXIT_FAILURE, 0, \"Kerberos authentication failed.\");\n\n\t  sp = getservbyname (\"shell\", \"tcp\");\n\t  if (sp == NULL)\n\t    error (EXIT_FAILURE, 0, \"unknown service shell/tcp\");\n\t  port = sp->s_port;\n\t  goto again;\n\t}\n    }\n  else\n    {\n      char *p = strchr (*host, '/');\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n\terror (EXIT_FAILURE, 0, \"the -x option requires Kerberos authentication\");\n# endif\n      if (p)\n\t*host = ++p;\t/* Skip prefix like `host/'.  */\n# ifdef WITH_ORCMD_AF\n      rem = orcmd_af (host, port, locuser, user, bp, 0, family);\n# elif defined WITH_RCMD_AF\n      rem = rcmd_af (host, port, locuser, user, bp, 0, family);\n# elif defined WITH_ORCMD\n      rem = orcmd (host, port, locuser, user, bp, 0);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n      rem = rcmd (host, port, locuser, user, bp, 0);\n# endif\n    }\n  return rem;\n}\n#endif /* KERBEROS || SHISHI */\n\nint\nresponse (void)\n{\n  char ch, *cp, resp, rbuf[BUFSIZ];\n\n  if (read (rem, &resp, sizeof resp) != sizeof resp)\n    lostconn (0);\n\n  cp = rbuf;\n  switch (resp)\n    {\n    case 0:\t\t\t/* ok */\n      return 0;\n\n    default:\n      *cp++ = resp;\n    case 1:\t\t\t/* error, followed by error msg */\n    case 2:\t\t\t/* fatal error, \"\" */\n      do\n\t{\n\t  if (read (rem, &ch, sizeof (ch)) != sizeof (ch))\n\t    lostconn (0);\n\t  *cp++ = ch;\n\t}\n      while (cp < &rbuf[BUFSIZ] && ch != '\\n');\n\n      if (!iamremote)\n\twrite (STDERR_FILENO, rbuf, cp - rbuf);\n      ++errs;\n      if (resp == 1)\n\treturn -1;\n      exit (EXIT_FAILURE);\n    }\n}\n\n#if defined KERBEROS || defined SHISHI\nvoid\noldw (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  fprintf (stderr, \"rcp: \");\n  vfprintf (stderr, fmt, ap);\n  fprintf (stderr, \", using standard rcp\\n\");\n  va_end (ap);\n}\n#endif /* KERBEROS || SHISHI */\n\nvoid\nrun_err (const char *fmt, ...)\n{\n  static FILE *fp;\n  va_list ap;\n\n  va_start (ap, fmt);\n\n  ++errs;\n  if (fp == NULL && !(fp = fdopen (rem, \"w\")))\n    return;\n  fprintf (fp, \"%c\", 0x01);\n  fprintf (fp, \"rcp: \");\n  vfprintf (fp, fmt, ap);\n  va_end (ap);\n  fprintf (fp, \"\\n\");\n  fflush (fp);\n\n  if (!iamremote)\n    {\n      fprintf (stderr, \"%s: \", program_invocation_name);\n      va_start (ap, fmt);\n      vfprintf (stderr, fmt, ap);\n      va_end (ap);\n      fprintf (stderr, \"\\n\");\n    }\n}\n\nchar *\ncolon (char *cp)\n{\n  if (*cp == ':')\t\t/* Leading colon is part of file name. */\n    return (0);\n\n  for (; *cp; ++cp)\n    {\n      if (*cp == ':')\n\treturn (cp);\n      if (*cp == '/')\n\treturn (0);\n    }\n  return (0);\n}\n\nvoid\nverifydir (char *cp)\n{\n  struct stat stb;\n\n  if (!stat (cp, &stb))\n    {\n      if (S_ISDIR (stb.st_mode))\n\treturn;\n      errno = ENOTDIR;\n    }\n  run_err (\"%s: %s\", cp, strerror (errno));\n  exit (EXIT_FAILURE);\n}\n\nint\nokname (char *cp0)\n{\n  int c;\n  char *cp;\n\n  cp = cp0;\n  do\n    {\n      c = *cp;\n      if (c & 0200)\n\tgoto bad;\n      if (!isalpha (c) && !isdigit (c) && c != '_' && c != '-')\n\tgoto bad;\n    }\n  while (*++cp);\n  return (1);\n\nbad:\n  error (0, 0, \"%s: invalid user name\", cp0);\n  return (0);\n}\n\nint\nsusystem (char *s, int userid)\n{\n  sighandler_t istat, qstat;\n  int status;\n  pid_t pid;\n\n  pid = vfork ();\n  switch (pid)\n    {\n    case -1:\n      return (127);\n\n    case 0:\n      setuid (userid);\n      execl (PATH_BSHELL, \"sh\", \"-c\", s, NULL);\n      _exit (127);\n    }\n  istat = signal (SIGINT, SIG_IGN);\n  qstat = signal (SIGQUIT, SIG_IGN);\n  if (waitpid (pid, &status, 0) < 0)\n    status = -1;\n  signal (SIGINT, istat);\n  signal (SIGQUIT, qstat);\n  return (status);\n}\n\nBUF *\nallocbuf (BUF * bp, int fd, int blksize)\n{\n  struct stat stb;\n  size_t size;\n\n  if (fstat (fd, &stb) < 0)\n    {\n      run_err (\"fstat: %s\", strerror (errno));\n      return (0);\n    }\n#ifndef roundup\n# define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))\n#endif\n  size = roundup (BUFSIZ, blksize);\n  if (size == 0)\n    size = blksize;\n  if ((size_t) bp->cnt >= size)\n    return (bp);\n\n  bp->buf = realloc (bp->buf, size);\n  if (bp->buf == NULL)\n    {\n      bp->cnt = 0;\n      run_err (\"%s\", strerror (errno));\n      return (0);\n    }\n  bp->cnt = size;\n  return (bp);\n}\n\nvoid\nlostconn (int signo _GL_UNUSED_PARAMETER)\n{\n  if (!iamremote)\n    error (0, 0, \"lost connection\");\n  exit (EXIT_FAILURE);\n}",
      "lines": 637,
      "depth": 29,
      "decorators": [
        "void"
      ]
    },
    "kerberos": {
      "start_point": [
        1171,
        0
      ],
      "end_point": [
        1307,
        1
      ],
      "content": "int\nkerberos (char **host, char *bp, char *locuser, char *user)\n{\n  int krb_errno = 0;\n  struct servent *sp;\n\nagain:\n  if (use_kerberos)\n    {\n      errno = 0;\n# ifdef KERBEROS\n      rem = KSUCCESS;\n      if (dest_realm == NULL)\n\tdest_realm = krb_realmofhost (*host);\n# elif defined SHISHI\n      rem = SHISHI_OK;\n# endif\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n#  ifdef KERBEROS\n\t  rem = krcmd_mutual (host, port, user, bp, 0, dest_realm,\n\t\t\t      &cred, schedule) :\n\t  krb_errno = errno;\n#  elif defined SHISHI\n\t  int i;\n\t  char *xbp = NULL;\n\n\t  xbp = xmalloc (strlen (bp) + sizeof (\"-x \"));\n\t  sprintf (xbp, \"%s%s\", \"-x \", bp);\n\t  rem = krcmd_mutual (&h, host, port, &user, xbp, NULL,\n\t\t\t      dest_realm, &enckey, family);\n\t  krb_errno = errno;\n\t  if (rem > 0)\n\t    {\n\t      keytype = shishi_key_type (enckey);\n\t      keylen = shishi_cipher_blocksize (keytype);\n\n\t      ivtab[0] = &iv1;\n\t      ivtab[1] = &iv2;\n\t      ivtab[2] = &iv3;\n\t      ivtab[3] = &iv4;\n\n\t      for (i = 0; i < 4; i++)\n\t\t{\n\t\t  ivtab[i]->ivlen = keylen;\n\n\t\t  switch (keytype)\n\t\t    {\n\t\t    case SHISHI_DES_CBC_CRC:\n\t\t    case SHISHI_DES_CBC_MD4:\n\t\t    case SHISHI_DES_CBC_MD5:\n\t\t    case SHISHI_DES_CBC_NONE:\n\t\t    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t\t      ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv,\n\t\t\t      2 * i + 1 * (i < 2) - 4 * (i >= 2),\n\t\t\t      ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t      break;\n\t\t    case SHISHI_ARCFOUR_HMAC:\n\t\t    case SHISHI_ARCFOUR_HMAC_EXP:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), NULL, 0);\n\t\t      break;\n\t\t    default:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t    }\n\t\t}\n\t    }\n\t  free (xbp);\n#  endif\n\t}\n      else\n# endif /* ENCRYPTION */\n\t{\n# ifdef KERBEROS\n\t  rem = krcmd (host, port, user, bp, 0, dest_realm);\n# else /* SHISHI */\n\t  rem = krcmd (&h, host, port, &user, bp, NULL, dest_realm, family);\n# endif\n\t  krb_errno = errno;\n\t}\n\n      if (rem < 0)\n\t{\n\t  use_kerberos = 0;\n\t  if (krb_errno == ECONNREFUSED)\n\t    oldw (\"remote host doesn't support Kerberos\");\n\t  else if (krb_errno == ENOENT)\n\t    error (EXIT_FAILURE, 0, \"Can't provide Kerberos authentication data.\");\n\t  else\n\t    error (EXIT_FAILURE, 0, \"Kerberos authentication failed.\");\n\n\t  sp = getservbyname (\"shell\", \"tcp\");\n\t  if (sp == NULL)\n\t    error (EXIT_FAILURE, 0, \"unknown service shell/tcp\");\n\t  port = sp->s_port;\n\t  goto again;\n\t}\n    }\n  else\n    {\n      char *p = strchr (*host, '/');\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n\terror (EXIT_FAILURE, 0, \"the -x option requires Kerberos authentication\");\n# endif\n      if (p)\n\t*host = ++p;\t/* Skip prefix like `host/'.  */\n# ifdef WITH_ORCMD_AF\n      rem = orcmd_af (host, port, locuser, user, bp, 0, family);\n# elif defined WITH_RCMD_AF\n      rem = rcmd_af (host, port, locuser, user, bp, 0, family);\n# elif defined WITH_ORCMD\n      rem = orcmd (host, port, locuser, user, bp, 0);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n      rem = rcmd (host, port, locuser, user, bp, 0);\n# endif\n    }\n  return rem;\n}",
      "lines": 137,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "response": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "int\nresponse (void)\n{\n  char ch, *cp, resp, rbuf[BUFSIZ];\n\n  if (read (rem, &resp, sizeof resp) != sizeof resp)\n    lostconn (0);\n\n  cp = rbuf;\n  switch (resp)\n    {\n    case 0:\t\t\t/* ok */\n      return 0;\n\n    default:\n      *cp++ = resp;\n    case 1:\t\t\t/* error, followed by error msg */\n    case 2:\t\t\t/* fatal error, \"\" */\n      do\n\t{\n\t  if (read (rem, &ch, sizeof (ch)) != sizeof (ch))\n\t    lostconn (0);\n\t  *cp++ = ch;\n\t}\n      while (cp < &rbuf[BUFSIZ] && ch != '\\n');\n\n      if (!iamremote)\n\twrite (STDERR_FILENO, rbuf, cp - rbuf);\n      ++errs;\n      if (resp == 1)\n\treturn -1;\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "oldw": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1356,
        1
      ],
      "content": "void\noldw (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  fprintf (stderr, \"rcp: \");\n  vfprintf (stderr, fmt, ap);\n  fprintf (stderr, \", using standard rcp\\n\");\n  va_end (ap);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "run_err": {
      "start_point": [
        1359,
        0
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "void\nrun_err (const char *fmt, ...)\n{\n  static FILE *fp;\n  va_list ap;\n\n  va_start (ap, fmt);\n\n  ++errs;\n  if (fp == NULL && !(fp = fdopen (rem, \"w\")))\n    return;\n  fprintf (fp, \"%c\", 0x01);\n  fprintf (fp, \"rcp: \");\n  vfprintf (fp, fmt, ap);\n  va_end (ap);\n  fprintf (fp, \"\\n\");\n  fflush (fp);\n\n  if (!iamremote)\n    {\n      fprintf (stderr, \"%s: \", program_invocation_name);\n      va_start (ap, fmt);\n      vfprintf (stderr, fmt, ap);\n      va_end (ap);\n      fprintf (stderr, \"\\n\");\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "colon": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1401,
        1
      ],
      "content": "char *\ncolon (char *cp)\n{\n  if (*cp == ':')\t\t/* Leading colon is part of file name. */\n    return (0);\n\n  for (; *cp; ++cp)\n    {\n      if (*cp == ':')\n\treturn (cp);\n      if (*cp == '/')\n\treturn (0);\n    }\n  return (0);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "char",
        "*\ncolon (char *cp)",
        "*"
      ]
    },
    "verifydir": {
      "start_point": [
        1403,
        0
      ],
      "end_point": [
        1416,
        1
      ],
      "content": "void\nverifydir (char *cp)\n{\n  struct stat stb;\n\n  if (!stat (cp, &stb))\n    {\n      if (S_ISDIR (stb.st_mode))\n\treturn;\n      errno = ENOTDIR;\n    }\n  run_err (\"%s: %s\", cp, strerror (errno));\n  exit (EXIT_FAILURE);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "okname": {
      "start_point": [
        1418,
        0
      ],
      "end_point": [
        1439,
        1
      ],
      "content": "int\nokname (char *cp0)\n{\n  int c;\n  char *cp;\n\n  cp = cp0;\n  do\n    {\n      c = *cp;\n      if (c & 0200)\n\tgoto bad;\n      if (!isalpha (c) && !isdigit (c) && c != '_' && c != '-')\n\tgoto bad;\n    }\n  while (*++cp);\n  return (1);\n\nbad:\n  error (0, 0, \"%s: invalid user name\", cp0);\n  return (0);\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "susystem": {
      "start_point": [
        1441,
        0
      ],
      "end_point": [
        1466,
        1
      ],
      "content": "int\nsusystem (char *s, int userid)\n{\n  sighandler_t istat, qstat;\n  int status;\n  pid_t pid;\n\n  pid = vfork ();\n  switch (pid)\n    {\n    case -1:\n      return (127);\n\n    case 0:\n      setuid (userid);\n      execl (PATH_BSHELL, \"sh\", \"-c\", s, NULL);\n      _exit (127);\n    }\n  istat = signal (SIGINT, SIG_IGN);\n  qstat = signal (SIGQUIT, SIG_IGN);\n  if (waitpid (pid, &status, 0) < 0)\n    status = -1;\n  signal (SIGINT, istat);\n  signal (SIGQUIT, qstat);\n  return (status);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "allocbuf": {
      "start_point": [
        1468,
        0
      ],
      "end_point": [
        1497,
        1
      ],
      "content": "BUF *\nallocbuf (BUF * bp, int fd, int blksize)\n{\n  struct stat stb;\n  size_t size;\n\n  if (fstat (fd, &stb) < 0)\n    {\n      run_err (\"fstat: %s\", strerror (errno));\n      return (0);\n    }\n#ifndef roundup\n# define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))\n#endif\n  size = roundup (BUFSIZ, blksize);\n  if (size == 0)\n    size = blksize;\n  if ((size_t) bp->cnt >= size)\n    return (bp);\n\n  bp->buf = realloc (bp->buf, size);\n  if (bp->buf == NULL)\n    {\n      bp->cnt = 0;\n      run_err (\"%s\", strerror (errno));\n      return (0);\n    }\n  bp->cnt = size;\n  return (bp);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "BUF",
        "*\nallocbuf (BUF * bp, int fd, int blksize)",
        "*"
      ]
    },
    "lostconn": {
      "start_point": [
        1499,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "void\nlostconn (int signo _GL_UNUSED_PARAMETER)\n{\n  if (!iamremote)\n    error (0, 0, \"lost connection\");\n  exit (EXIT_FAILURE);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rexec.c": {
    "parse_opt": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  struct arguments *arguments = state->input;\n\n  switch (key)\n    {\n    case 'u':\n      arguments->user = arg;\n      break;\n    case 'p':\n      arguments->password = arg;\n      break;\n    case 'P':\n      arguments->port = atoi (arg);\n      break;\n    case 'e':\n      arguments->err_port = atoi (arg);\n      break;\n    case 'h':\n      arguments->host = arg;\n      break;\n    case 'n':\n      arguments->use_err = 0;\n      break;\n    case '4':\n      arguments->af = AF_INET;\n      break;\n    case '6':\n      arguments->af = AF_INET6;\n      break;\n    case 'a':\n      arguments->af = AF_UNSPEC;\n      break;\n    case ARGP_KEY_ARG:\n      arguments->command = arg;\n      state->next = state->argc;\n    }\n\n  return 0;\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct arguments arguments;\n  char password[64];\n  int n, failed = 0;\n  set_program_name (argv[0]);\n\n  iu_argp_init (\"rexec\", program_authors);\n\n  arguments.user = NULL;\n  arguments.password = NULL;\n  arguments.host = NULL;\n  arguments.command = NULL;\n  arguments.af = AF_UNSPEC;\n  arguments.err_port = 0;\n  arguments.use_err = 1;\n  arguments.port = 512;\n\n  argp_parse (&argp, argc, argv, ARGP_IN_ORDER, 0, &arguments);\n\n  if (arguments.user == NULL)\n    {\n      error (0, 0, \"user not specified\");\n      failed++;\n    }\n\n  if (arguments.password == NULL)\n    {\n      error (0, 0, \"password not specified\");\n      failed++;\n    }\n\n  if (arguments.host == NULL)\n    {\n      error (0, 0, \"host not specified\");\n      failed++;\n    }\n\n  if (arguments.command == NULL)\n    {\n      error (0, 0, \"command not specified\");\n      failed++;\n    }\n\n  if (failed > 0)\n    exit (EXIT_FAILURE);\n\n  if (strcmp (\"-\", arguments.password) == 0)\n    {\n      password[0] = '\\0';\n\n      alarm (15);\n\n      if (isatty (STDIN_FILENO))\n\t{\n\t  int changed = 0;\n\t  struct termios tt, newtt;\n\n\t  if (tcgetattr (STDIN_FILENO, &tt) >= 0)\n\t    {\n\t      memcpy (&newtt, &tt, sizeof (newtt));\n\t      newtt.c_lflag &= ~ECHO;\n\t      newtt.c_lflag |= ECHONL;\n\t      if (tcsetattr (STDIN_FILENO, TCSANOW, &newtt))\n\t\terror (0, errno, \"failed to turn off echo\");\n\t      changed = 1;\n\t    }\n\n\t  printf (\"Password: \");\n\t  if (fgets (password, sizeof (password), stdin) == NULL)\n\t    password[0] = '\\0';\n\n\t  if (changed && (tcsetattr (STDIN_FILENO, TCSANOW, &tt) < 0))\n\t    error (0, errno, \"failed to restore terminal\");\n\t}\n      else if (fgets (password, sizeof (password), stdin) == NULL)\n\tpassword[0] = '\\0';\n      alarm (0);\n\n      n = strlen (password);\n      if ((n > 0) && (password[n - 1] == '\\n'))\n\t{\n\t  password[n - 1] = '\\0';\n\t  --n;\n\t}\n\n      if (n == 0)\n\terror (EXIT_FAILURE, 0, \"empty password\");\n      else\n\targuments.password = password;\n    }\n\n  do_rexec (&arguments);\n\n  exit (remote_err);\n}",
      "lines": 97,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "safe_write": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "static void\nsafe_write (int socket, const char *str, size_t len)\n{\n  if (write (socket, str, len) < 0)\n    error (EXIT_FAILURE, errno, \"error sending data\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_rexec": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "void\ndo_rexec (struct arguments *arguments)\n{\n  int err;\n  char buffer[1024];\n  int sock, ret;\n  char port_str[12];\n  socklen_t addrlen;\n  struct sockaddr_storage addr;\n  struct addrinfo hints, *ai, *res;\n  int stdin_fd = STDIN_FILENO;\n  int err_sock = -1;\n\n  snprintf (port_str, sizeof (port_str), \"%d\", arguments->port);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = arguments->af;\n  hints.ai_socktype = SOCK_STREAM;\n\n  ret = getaddrinfo (arguments->host, port_str, &hints, &res);\n  if (ret)\n    error (EXIT_FAILURE, errno, \"getaddrinfo: %s\", gai_strerror (ret));\n\n  for (ai = res; ai != NULL; ai = ai->ai_next)\n    {\n      sock = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (sock < 0)\n\tcontinue;\n\n      if (connect (sock, ai->ai_addr, ai->ai_addrlen) < 0)\n\t{\n\t  close (sock);\n\t  sock = -1;\n\t  continue;\n\t}\n\n      break;\t/* Acceptable.  */\n    }\n\n  if (ai == NULL)\n    {\n      freeaddrinfo (res);\n      error (EXIT_FAILURE, errno, \"cannot find host %s\", arguments->host);\n    }\n\n  addrlen = ai->ai_addrlen;\n  memcpy (&addr, ai->ai_addr, ai->ai_addrlen);\n  freeaddrinfo (res);\n\n  if (!arguments->use_err)\n    {\n      port_str[0] = '0';\n      port_str[1] = '\\0';\n      safe_write (sock, port_str, 2);\n      arguments->err_port = 0;\n    }\n  else\n    {\n      struct sockaddr_storage serv_addr;\n      socklen_t len;\n      int on = 1;\n      int serv_sock = socket (addr.ss_family, SOCK_STREAM, 0);\n\n      if (serv_sock < 0)\n        error (EXIT_FAILURE, errno, \"cannot open socket\");\n\n      setsockopt (serv_sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on));\n\n      memset (&serv_addr, 0, sizeof (serv_addr));\n\n      /* Need to bind to explicit port, when err_port is non-zero,\n       * or to be assigned a free port, should err_port be naught.\n       */\n      switch (addr.ss_family)\n\t{\n\tcase AF_INET:\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n\t  ((struct sockaddr_in *) &serv_addr)->sin_len = addrlen;\n#endif\n\t  ((struct sockaddr_in *) &serv_addr)->sin_family = addr.ss_family;\n\t  ((struct sockaddr_in *) &serv_addr)->sin_port = arguments->err_port;\n\t  break;\n\tcase AF_INET6:\n#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN\n\t  ((struct sockaddr_in6 *) &serv_addr)->sin6_len = addrlen;\n#endif\n\t  ((struct sockaddr_in6 *) &serv_addr)->sin6_family = addr.ss_family;\n\t  ((struct sockaddr_in6 *) &serv_addr)->sin6_port = arguments->err_port;\n\t  break;\n\tdefault:\n\t  error (EXIT_FAILURE, EAFNOSUPPORT, \"unknown address family\");\n\t}\n\n      if (bind (serv_sock, (struct sockaddr *) &serv_addr, addrlen) < 0)\n        error (EXIT_FAILURE, errno, \"cannot bind socket\");\n\n      len = sizeof (serv_addr);\n      if (getsockname (serv_sock, (struct sockaddr *) &serv_addr, &len))\n        error (EXIT_FAILURE, errno, \"error reading socket port\");\n\n      if (listen (serv_sock, 1))\n        error (EXIT_FAILURE, errno, \"error listening on socket\");\n\n      switch (serv_addr.ss_family)\n\t{\n\tcase AF_INET:\n\t  arguments->err_port = ntohs (((struct sockaddr_in *) &serv_addr)->sin_port);\n\t  break;\n\tcase AF_INET6:\n\t  arguments->err_port = ntohs (((struct sockaddr_in6 *) &serv_addr)->sin6_port);\n\t  break;\n\tdefault:\n\t  error (EXIT_FAILURE, EAFNOSUPPORT, \"unknown address family\");\n\t}\n      snprintf (port_str, sizeof (port_str), \"%u\", arguments->err_port);\n      safe_write (sock, port_str, strlen (port_str) + 1);\n\n      /* Limit waiting time in case the server fails to call back:\n       * if it aborts prematurely, or if a firewall is blocking\n       * the intended STDERR connection to reach us.\n       */\n      alarm (5);\n\n      err_sock = accept (serv_sock, (struct sockaddr *) &serv_addr, &len);\n      if (err_sock < 0)\n        error (EXIT_FAILURE, errno, \"error accepting connection\");\n\n      alarm (0);\n\n      shutdown (err_sock, SHUT_WR);\n\n      close (serv_sock);\n    }\n\n  safe_write (sock, arguments->user, strlen (arguments->user) + 1);\n  safe_write (sock, arguments->password, strlen (arguments->password) + 1);\n  safe_write (sock, arguments->command, strlen (arguments->command) + 1);\n\n  while (1)\n    {\n      int consumed = 0;\t\t/* Signals remote return status.  */\n      int ret, offset;\n      fd_set rsocks;\n\n      /* No other data to read.  */\n      if (sock < 0 && err_sock < 0)\n        break;\n\n      FD_ZERO (&rsocks);\n      if (0 <= sock)\n        FD_SET (sock, &rsocks);\n      if (0 <= stdin_fd)\n\tFD_SET (stdin_fd, &rsocks);\n      if (0 <= err_sock)\n        FD_SET (err_sock, &rsocks);\n\n      ret = select (MAX3 (sock, stdin_fd, err_sock) + 1, &rsocks, NULL, NULL, NULL);\n      if (ret == -1)\n        error (EXIT_FAILURE, errno, \"error select\");\n\n      if (0 <= stdin_fd && FD_ISSET (stdin_fd, &rsocks))\n        {\n\t  err = read (stdin_fd, buffer, 1024);\n\n          if (err < 0)\n            error (EXIT_FAILURE, errno, \"error reading stdin\");\n\n          if (!err)\n            {\n              shutdown (sock, SHUT_WR);\n\t      close (stdin_fd);\n\t      stdin_fd = -1;\n              continue;\n            }\n\n          if (write (sock, buffer, err) < 0)\n            error (EXIT_FAILURE, errno, \"error writing\");\n        }\n\n      if (0 <= sock && FD_ISSET (sock, &rsocks))\n        {\n          err = read (sock, buffer, 1024);\n\n          if (err < 0)\n            error (EXIT_FAILURE, errno, \"error reading out stream\");\n\n          if (!err)\n            {\n              close (sock);\n              sock = -1;\n              continue;\n            }\n\n\t  offset = 0;\n\n\t  if ((err > 0) && (consumed < 2))\t/* Status can be two chars.  */\n\t    while ((err > offset) && (offset < 2)\n\t\t   && (buffer[offset] == 0 || buffer[offset] == 1))\n\t      remote_err = buffer[offset++];\n\n          if (write (STDOUT_FILENO, buffer + offset, err - offset) < 0)\n            error (EXIT_FAILURE, errno, \"error writing\");\n\n\t  consumed += err;\n        }\n\n     if (0 <= err_sock && FD_ISSET (err_sock, &rsocks))\n        {\n          err = read (err_sock, buffer, 1024);\n\n          if (err < 0)\n            error (EXIT_FAILURE, errno, \"error reading err stream\");\n\n          if (!err)\n            {\n              close (err_sock);\n              err_sock = -1;\n              continue;\n            }\n\n\t  offset = 0;\n\n\t  if ((err > 0) && (consumed < 2))\t/* Status can be two chars.  */\n\t    while ((err > offset) && (offset < 2)\n\t\t   && (buffer[offset] == 0 || buffer[offset] == 1))\n\t      remote_err = buffer[offset++];\n\n          if (write (STDERR_FILENO, buffer + offset, err - offset) < 0)\n            error (EXIT_FAILURE, errno, \"error writing to stderr\");\n\n\t  consumed += err;\n        }\n    }\n}",
      "lines": 234,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rexecd.c": {
    "parse_opt": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg _GL_UNUSED_PARAMETER,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'l':\n      ++logging;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct sockaddr_storage from;\n  socklen_t fromlen;\n  int sockfd = STDIN_FILENO;\n  int index;\n\n  set_program_name (argv[0]);\n\n  iu_argp_init (\"rexecd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  openlog (\"rexecd\", LOG_PID | LOG_ODELAY | LOG_NOWAIT, LOG_DAEMON);\n\n  if (argc > index)\n    /* Record this complaint locally.  */\n    syslog (LOG_NOTICE, \"%d extra arguments\", argc - index);\n\n  fromlen = sizeof (from);\n  if (getpeername (sockfd, (struct sockaddr *) &from, &fromlen) < 0)\n    {\n      syslog (LOG_ERR, \"getpeername: %m\");\n      error (EXIT_FAILURE, errno, \"getpeername\");\n    }\n\n  doit (sockfd, (struct sockaddr *) &from, fromlen);\n  exit (EXIT_SUCCESS);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "get_user_password": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static char *\nget_user_password (struct passwd *pwd)\n{\n  char *pw_text = pwd->pw_passwd;\n#ifdef HAVE_SHADOW_H\n  struct spwd *spwd = getspnam (pwd->pw_name);\n  if (spwd)\n    pw_text = spwd->sp_pwdp;\n#endif\n  return pw_text;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_user_password (struct passwd *pwd)",
        "*"
      ]
    },
    "doit": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "int\ndoit (int f, struct sockaddr *fromp, socklen_t fromlen)\n{\n  char *cmdbuf, *cp;\n  char *user, *pass;\n#ifndef WITH_PAM\n  char *namep, *pw_password;\n#endif\n#ifdef HAVE_GETPWNAM_R\n  char *pwbuf;\n  int pwbuflen;\n  struct passwd *pwd, pwstor;\n#else /* !HAVE_GETPWNAM_R */\n  struct passwd *pwd;\n#endif\n  char rhost[INET6_ADDRSTRLEN];\n  int s, ret;\n  in_port_t port;\n  int pv[2], pid, cc;\n  fd_set readfrom, ready;\n  char buf[BUFSIZ], sig;\n  int one = 1;\n\n#ifdef HAVE_GETPWNAM_R\n  pwbuflen = sysconf (_SC_GETPW_R_SIZE_MAX);\n  if (pwbuflen <= 0)\n    pwbuflen = 1024;\t/* Guessing only.  */\n\n  pwbuf = xmalloc (pwbuflen);\n#endif /* HAVE_GETPWNAM_R */\n\n  signal (SIGINT, SIG_DFL);\n  signal (SIGQUIT, SIG_DFL);\n  signal (SIGTERM, SIG_DFL);\n#ifdef DEBUG\n  {\n    int t = open (PATH_TTY, O_RDWR);\n    if (t >= 0)\n      {\n\tioctl (t, TIOCNOTTY, (char *) 0);\n\tclose (t);\n      }\n  }\n#endif\n  if (f != STDIN_FILENO)\n    {\n      dup2 (f, STDIN_FILENO);\n      dup2 (f, STDOUT_FILENO);\n      dup2 (f, STDERR_FILENO);\n    }\n\n  ret = getnameinfo (fromp, fromlen, rhost, sizeof (rhost),\n\t\t     NULL, 0, NI_NUMERICHOST);\n  if (ret)\n    {\n      syslog (LOG_WARNING, \"getnameinfo: %m\");\n      strncpy (rhost, \"(unknown)\", sizeof (rhost));\n    }\n\n  if (logging > 1)\n    syslog (LOG_INFO, \"request from \\\"%s\\\"\", rhost);\n\n  alarm (60);\n  port = 0;\n  for (;;)\n    {\n      char c;\n      if (read (f, &c, 1) != 1)\n\t{\n\t  if (logging)\n\t    syslog (LOG_ERR, \"main socket: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n      if (c == 0)\n\tbreak;\n      port = port * 10 + c - '0';\n    }\n  alarm (0);\n\n  if (port != 0)\n    {\n      s = socket (fromp->sa_family, SOCK_STREAM, 0);\n      if (s < 0)\n\t{\n\t  if (logging)\n\t    syslog (LOG_ERR, \"stderr socket: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n      setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &one, sizeof (one));\n      alarm (60);\n      switch (fromp->sa_family)\n\t{\n\tcase AF_INET:\n\t  ((struct sockaddr_in *) fromp)->sin_port = htons (port);\n\t  break;\n\tcase AF_INET6:\n\t  ((struct sockaddr_in6 *) fromp)->sin6_port = htons (port);\n\t  break;\n\tdefault:\n\t  syslog (LOG_ERR, \"unknown address family %d\", fromp->sa_family);\n\t  exit (EXIT_FAILURE);\n\t}\n      if (connect (s, fromp, fromlen) < 0)\n\t{\n\t  /* Use LOG_NOTICE since the remote part might cause\n\t   * this error by blocking.  We are less probable.\n\t   */\n\t  if (logging)\n\t    syslog (LOG_NOTICE, \"connect: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n      alarm (0);\n    }\n\n  user = getstr (\"username\");\n  pass = getstr (\"password\");\n  cmdbuf = getstr (\"command\");\n\n  setpwent ();\n\n#ifdef HAVE_GETPWNAM_R\n  ret = getpwnam_r (user, &pwstor, pwbuf, pwbuflen, &pwd);\n  if (ret || pwd == NULL)\n#else /* !HAVE_GETPWNAM_R */\n  pwd = getpwnam (user);\n  if (pwd == NULL)\n#endif /* HAVE_GETPWNAM_R */\n    {\n      if (logging)\n\tsyslog (LOG_WARNING | LOG_AUTH, \"no user named \\\"%s\\\"\", user);\n      die (EXIT_FAILURE, \"Login incorrect.\");\n    }\n\n  endpwent ();\n\n#ifndef WITH_PAM\n  /* Last need of elevated privilege.  */\n  pw_password = get_user_password (pwd);\n  if (*pw_password != '\\0')\n    {\n      namep = crypt (pass, pw_password);\n      if (strcmp (namep, pw_password))\n\t{\n\t  if (logging)\n\t    syslog (LOG_WARNING | LOG_AUTH, \"password failure for \\\"%s\\\"\", user);\n\t  die (EXIT_FAILURE, \"Password incorrect.\");\n\t}\n    }\n#else /* WITH_PAM */\n  /* Failure at this stage should not disclose server side causes,\n   * but only fail almost silently.  Use \"Try again\" for now.\n   */\n  password_pam = pass;\t\t/* Needed by pam_conv().  */\n\n  pam_rc = pam_start (\"rexec\", user, &pam_conv, &pam_handle);\n  if (pam_rc != PAM_SUCCESS)\n    die (EXIT_FAILURE, \"Try again.\");\n\n  pam_rc = pam_set_item (pam_handle, PAM_RHOST, rhost);\n  if (pam_rc != PAM_SUCCESS)\n    die (EXIT_FAILURE, \"Try again.\");\n\n  pam_rc = pam_authenticate (pam_handle, pam_flags);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_ABORT:\n\t  /* This is potentially severe.  No communication!  */\n\t  pam_end (pam_handle, pam_rc);\n\t  exit (EXIT_FAILURE);\n\t  break;\n\tcase PAM_AUTHINFO_UNAVAIL:\n\tcase PAM_CRED_INSUFFICIENT:\n\tcase PAM_USER_UNKNOWN:\n\t  die (EXIT_FAILURE, \"Login incorrect.\");\n\t  break;\n\tcase PAM_AUTH_ERR:\n\tcase PAM_MAXTRIES:\n\tdefault:\n\t  die (EXIT_FAILURE, \"Password incorrect.\");\n\t  break;\n\t}\n    }\n\n  pam_rc = pam_acct_mgmt (pam_handle, pam_flags);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_NEW_AUTHTOK_REQD:\n\tcase PAM_PERM_DENIED:\n\t  die (EXIT_FAILURE, \"Password incorrect.\");\n\t  break;\n\tcase PAM_ACCT_EXPIRED:\n\tcase PAM_AUTH_ERR:\n\tcase PAM_USER_UNKNOWN:\n\tdefault:\n\t  die (EXIT_FAILURE, \"Login incorrect.\");\n\t  break;\n\t}\n    }\n#endif /* WITH_PAM */\n\n#ifdef HAVE_SETLOGIN\n  if (setlogin (pwd->pw_name) < 0)\n    syslog (LOG_ERR, \"setlogin() failed: %m\");\n#endif\n\n  /* Step down from superuser personality.\n   *\n   * The changing of group membership will seldomly\n   * fail, but a relevant message is passed just in\n   * case.  These messages are non-standard.\n   */\n  if (setgid ((gid_t) pwd->pw_gid) < 0)\n    {\n#ifdef WITH_PAM\n      pam_rc = PAM_ABORT;\n#endif\n      syslog (LOG_DEBUG | LOG_AUTH, \"setgid(gid = %d): %m\", pwd->pw_gid);\n      die (EXIT_FAILURE, \"Failed group protections.\");\n    }\n\n#ifdef HAVE_INITGROUPS\n  if (initgroups (pwd->pw_name, pwd->pw_gid) < 0)\n    {\n# ifdef WITH_PAM\n      pam_rc = PAM_ABORT;\n# endif\n      syslog (LOG_DEBUG | LOG_AUTH, \"initgroups(%s, %d): %m\",\n\t      pwd->pw_name, pwd->pw_gid);\n      die (EXIT_FAILURE, \"Failed group protections.\");\n    }\n#endif\n\n#ifdef WITH_PAM\n  pam_rc = pam_setcred (pam_handle, PAM_SILENT | PAM_ESTABLISH_CRED);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"pam_setcred: %s\",\n\t      pam_strerror (pam_handle, pam_rc));\n      pam_rc = PAM_SUCCESS;\t/* Only report the above anomaly.  */\n    }\n#endif /* WITH_PAM */\n\n  if (setuid ((uid_t) pwd->pw_uid) < 0)\n    {\n#ifdef WITH_PAM\n      pam_rc = PAM_ABORT;\n#endif\n      syslog (LOG_DEBUG | LOG_AUTH, \"setuid(uid = %d): %m\", pwd->pw_uid);\n      die (EXIT_FAILURE, \"Failed user identity.\");\n    }\n\n  if (port)\n    {\n      pipe (pv);\n      pid = fork ();\n      if (pid == -1)\n\t{\n\t  if (logging)\n\t    syslog (LOG_ERR, \"forking for \\\"%s\\\": %m\", user);\n#ifdef WITH_PAM\n\t  pam_rc = PAM_ABORT;\n#endif\n\t  die (EXIT_FAILURE, \"Try again.\");\n\t}\n\n      if (pid)\n\t{\n#ifdef WITH_PAM\n\t  /* This process steps down from PAM now,\n\t   * the child continues communication.  */\n\t  pam_handle = NULL;\n# ifdef PAM_DATA_SILENT\n\t  pam_rc |= PAM_DATA_SILENT;\n# endif\n#endif /* WITH_PAM */\n\t  close (STDIN_FILENO);\n\t  close (STDOUT_FILENO);\n\t  close (STDERR_FILENO);\n\t  close (f);\n\t  close (pv[1]);\n\t  FD_ZERO (&readfrom);\n\t  FD_SET (s, &readfrom);\n\t  FD_SET (pv[0], &readfrom);\n\t  ioctl (pv[1], FIONBIO, (char *) &one);\n\t  /* should set s nbio! */\n\t  do\n\t    {\n\t      int maxfd = s;\n\t      ready = readfrom;\n\t      if (pv[0] > maxfd)\n\t\tmaxfd = pv[0];\n\t      select (maxfd + 1, (fd_set *) & ready,\n\t\t      (fd_set *) NULL, (fd_set *) NULL,\n\t\t      (struct timeval *) NULL);\n\t      if (FD_ISSET (s, &ready))\n\t\t{\n\t\t  if (read (s, &sig, 1) <= 0)\n\t\t    FD_CLR (s, &readfrom);\n\t\t  else\n\t\t    killpg (pid, sig);\n\t\t}\n\t      if (FD_ISSET (pv[0], &ready))\n\t\t{\n\t\t  cc = read (pv[0], buf, sizeof (buf));\n\t\t  if (cc <= 0)\n\t\t    {\n\t\t      shutdown (s, 1 + 1);\n\t\t      FD_CLR (pv[0], &readfrom);\n\t\t    }\n\t\t  else\n\t\t    write (s, buf, cc);\n\t\t}\n\t    }\n\t  while (FD_ISSET (pv[0], &readfrom) || FD_ISSET (s, &readfrom));\n\t  exit (EXIT_SUCCESS);\n\t} /* Parent process.  */\n\n#ifdef HAVE_SETLOGIN\n      /* Not sufficient to call setpgid() on BSD systems.  */\n      if (setsid () < 0)\n\tsyslog (LOG_ERR, \"setsid() failed: %m\");\n#elif defined HAVE_SETPGID /* !HAVE_SETLOGIN */\n      setpgid (0, getpid ());\n#endif\n\n      close (s);\n      close (pv[0]);\n      dup2 (pv[1], STDERR_FILENO);\n      close (pv[1]);\n    }\n\n  if (f > 2)\n    close (f);\n\n  /* Last point of failure due to incorrect user settings.  */\n  if (chdir (pwd->pw_dir) < 0)\n    {\n      if (logging)\n\tsyslog (LOG_NOTICE | LOG_AUTH, \"\\\"%s\\\" uses invalid \\\"%s\\\"\",\n\t\tuser, pwd->pw_dir);\n#ifdef WITH_PAM\n      pam_rc = PAM_ABORT;\n#endif\n      die (EXIT_FAILURE, \"No remote directory.\");\n    }\n\n#ifdef WITH_PAM\n  /* Refresh knowledge of user, which might have been\n   * remapped by the PAM stack during conversation.\n   */\n  free (user);\n  pam_rc = pam_get_item (pam_handle, PAM_USER, (const void **) &user);\n  if (pam_rc != PAM_SUCCESS)\n    die (EXIT_FAILURE, \"Try again.\");\n\n# ifdef HAVE_GETPWNAM_R\n  ret = getpwnam_r (user, &pwstor, pwbuf, pwbuflen, &pwd);\n  if (ret || pwd == NULL)\n# else /* !HAVE_GETPWNAM_R */\n  pwd = getpwnam (user);\n  if (pwd == NULL)\n# endif /* HAVE_GETPWNAM_R */\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"no user named \\\"%s\\\"\", user);\n      die (EXIT_FAILURE, \"Login incorrect.\");\n    }\n#endif /* WITH_PAM */\n\n  strcat (path, PATH_DEFPATH);\n  strncat (homedir, pwd->pw_dir, sizeof (homedir) - sizeof (\"HOME=\") - 1);\n  strncat (shell, pwd->pw_shell, sizeof (shell) - sizeof (\"SHELL=\") - 1);\n  strncat (username, pwd->pw_name, sizeof (username) - sizeof (\"USER=\") - 1);\n  strncat (logname, pwd->pw_name, sizeof (logname) - sizeof (\"LOGNAME=\") - 1);\n  strncat (remotehost, rhost, sizeof (remotehost) - sizeof (\"RHOST=\") - 1);\n\n#ifdef WITH_PAM\n  if (pam_getenv (pam_handle, \"PATH\") == NULL)\n    (void) pam_putenv (pam_handle, path);\n  if (pam_getenv (pam_handle, \"HOME\") == NULL)\n    (void) pam_putenv (pam_handle, homedir);\n  if (pam_getenv (pam_handle, \"SHELL\") == NULL)\n    (void) pam_putenv (pam_handle, shell);\n  if (pam_getenv (pam_handle, \"USER\") == NULL)\n    (void) pam_putenv (pam_handle, username);\n  if (pam_getenv (pam_handle, \"LOGNAME\") == NULL)\n    (void) pam_putenv (pam_handle, logname);\n  if (pam_getenv (pam_handle, \"RHOST\") == NULL)\n    (void) pam_putenv (pam_handle, remotehost);\n\n  environ = pam_getenvlist (pam_handle);\n#else /* !WITH_PAM */\n  environ = envinit;\n#endif /* !WITH_PAM */\n\n  if (*pwd->pw_shell == '\\0')\n    pwd->pw_shell = PATH_BSHELL;\n\n  cp = strrchr (pwd->pw_shell, '/');\n  if (cp)\n    cp++;\n  else\n    cp = pwd->pw_shell;\n\n  /* This is the 7th step in the protocol standard.\n   * All authentication has been successful, and the\n   * execution can be handed over to the requested shell.\n   */\n  write (STDERR_FILENO, \"\\0\", 1);\n  if (logging)\n    syslog (LOG_INFO, \"accepted user \\\"%s\\\" from %s\", user, rhost);\n\n  execl (pwd->pw_shell, cp, \"-c\", cmdbuf, NULL);\n  if (logging)\n    syslog (LOG_ERR, \"execl fails for \\\"%s\\\": %m\", user);\n#ifdef WITH_PAM\n  pam_end (pam_handle, PAM_SUCCESS);\n#endif\n  error (EXIT_FAILURE, errno, \"executing %s\", pwd->pw_shell);\n\n  return -1;\n}",
      "lines": 425,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "die": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "void\ndie (int code, const char *fmt, ...)\n{\n  va_list ap;\n  char buf[BUFSIZ];\n  int n;\n\n  va_start (ap, fmt);\n  buf[0] = 1;\t\t/* Error condition.  */\n  n = vsnprintf (buf + 1, sizeof buf - 1, fmt, ap);\n  va_end (ap);\n  if (n + 1 > (int) sizeof buf)\n    n = sizeof buf - 1;\n  buf[n++] = '\\n';\n  write (STDERR_FILENO, buf, n);\n#ifdef WITH_PAM\n  if (pam_handle != NULL)\n    pam_end (pam_handle, pam_rc);\n#endif\n  exit (code);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getstr": {
      "start_point": [
        685,
        0
      ],
      "end_point": [
        721,
        1
      ],
      "content": "char *\ngetstr (const char *err)\n{\n  size_t buf_len = 100;\n  char *buf = malloc (buf_len), *end = buf;\n\n  if (!buf)\n    die (EXIT_FAILURE, \"Out of space reading %s\", err);\n\n  do\n    {\n      /* Oh this is efficient, oh yes.  [But what can be done?] */\n      int rd = read (STDIN_FILENO, end, 1);\n      if (rd <= 0)\n\t{\n\t  if (rd == 0)\n\t    die (EXIT_FAILURE, \"EOF reading %s\", err);\n\t  else\n\t    error (EXIT_FAILURE, 0, \"%s\", err);\n\t}\n\n      end += rd;\n      if ((buf + buf_len - end) < (ssize_t) (buf_len >> 3))\n\t{\n\t  /* Not very much room left in our buffer, grow it. */\n\t  size_t end_offs = end - buf;\n\t  buf_len += buf_len;\n\t  buf = realloc (buf, buf_len);\n\t  if (!buf)\n\t    die (EXIT_FAILURE, \"Out of space reading %s\", err);\n\t  end = buf + end_offs;\n\t}\n    }\n  while (*(end - 1));\n\n  return buf;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "char",
        "*\ngetstr (const char *err)",
        "*"
      ]
    },
    "rexec_conv": {
      "start_point": [
        727,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "static int\nrexec_conv (int num, const struct pam_message **pam_msg,\n\t    struct pam_response **pam_resp,\n\t    void *data _GL_UNUSED_PARAMETER)\n{\n  struct pam_response *resp;\n\n  /* Reject composite call-backs.  */\n  if (num <= 0 || num > 1)\n    return PAM_CONV_ERR;\n\n  /* We only accept password reporting.  */\n  if (pam_msg[0]->msg_style != PAM_PROMPT_ECHO_OFF)\n    return PAM_CONV_ERR;\n\n  /* Allocate a single response structure,\n   * as we are ignoring composite calls.\n   *\n   * This is an external call-back, so we check\n   * for successful allocation ourselves.\n   */\n  resp = malloc (sizeof (*resp));\n  if (resp == NULL)\n    return PAM_BUF_ERR;\n\n  /* Prepare response to a single PAM_PROMPT_ECHO_OFF.  */\n  resp->resp_retcode = 0;\n  resp->resp = strdup (password_pam);\n  if (resp->resp == NULL)\n    {\n      free (resp);\n      return PAM_BUF_ERR;\n    }\n\n  *pam_resp = resp;\n\n  return PAM_SUCCESS;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rlogin.c": {
    "parse_opt": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n#if defined WITH_ORCMD_AF || defined WITH_RCMD_AF || defined SHISHI\n    case '4':\n      family = AF_INET;\n      break;\n    case '6':\n      family = AF_INET6;\n      break;\n#endif\n    /* 8-bit input Specifying this forces us to use RAW mode input from\n       the user's terminal.  Also, in this mode we won't perform any\n       local flow control.  */\n    case '8':\n      eight = 1;\n      break;\n\n    case 'd':\n      dflag = 1;\n      break;\n\n    case 'e':\n      noescape = 0;\n      escapechar = getescape (arg);\n      if (escapechar == 0)\n\terror (EXIT_FAILURE, 0, \"illegal option value -- e\");\n      break;\n\n    case 'E':\n      noescape = 1;\n      break;\n\n    case 'l':\n      user = arg;\n      break;\n\n#if defined KERBEROS || defined SHISHI\n# ifdef ENCRYPTION\n    case 'x':\n      doencrypt = 1;\n#  ifdef KERBEROS\n      des_set_key (cred.session, schedule);\n#  endif\n      break;\n# endif\n\n    case 'K':\n      use_kerberos = 0;\n      break;\n\n    case 'k':\n      strncpy (dest_realm_buf, arg, sizeof (dest_realm_buf));\n      /* Make sure it's null termintated.  */\n      dest_realm_buf[sizeof (dest_realm_buf) - 1] = '\\0';\n      dest_realm = dest_realm_buf;\n      break;\n#endif\n\n    case ARGP_KEY_NO_ARGS:\n      if (host == NULL)\n        argp_error (state, \"missing host operand\");\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  struct passwd *pw;\n  struct servent *sp;\n  struct sigaction sa;\n  sigset_t smask, osmask;\n  uid_t uid;\n  int index;\n  int term_speed;\n  char term[1024];\n\n  set_program_name (argv[0]);\n\n  /* Traditionally, if a symbolic link was made to the rlogin binary\n         hostname --> rlogin\n     then hostname will be used as the name of the server to access.  */\n  {\n    char *p = strrchr (argv[0], '/');\n    if (p)\n      ++p;\n    else\n      p = argv[0];\n\n    if (strcmp (p, \"rlogin\") != 0)\n      host = p;\n  }\n\n  /* Parse command line */\n  iu_argp_init (\"rlogin\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  if (index < argc)\n    host = argv[index++];\n\n  argc -= index;\n\n  /* Get the name of the user invoking us: the client-user-name.  */\n  uid = getuid ();\n  pw = getpwuid (uid);\n  if (!pw)\n    error (EXIT_FAILURE, 0, \"unknown user id.\");\n\n  /* Accept user1@host format, though \"-l user2\" overrides user1 */\n  {\n    char *p = strchr (host, '@');\n    if (p)\n      {\n\t*p = '\\0';\n\tif (!user && p > host)\n\t  user = host;\n\thost = p + 1;\n\tif (*host == '\\0')\n          error (EXIT_FAILURE, 0, \"invalid host operand\");\n      }\n  }\n\n  sp = NULL;\n#if defined KERBEROS || defined SHISHI\n  if (use_kerberos)\n    {\n      sp = getservbyname ((doencrypt ? \"eklogin\" : \"klogin\"), \"tcp\");\n      if (sp == NULL)\n\t{\n\t  use_kerberos = 0;\n\t  warning (\"can't get entry for %s/tcp service\",\n\t\t   doencrypt ? \"eklogin\" : \"klogin\");\n\t}\n    }\n#endif\n\n  /* Get the port number for the rlogin service.  */\n  if (sp == NULL)\n    sp = getservbyname (\"login\", \"tcp\");\n  if (sp == NULL)\n    error (EXIT_FAILURE, 0, \"login/tcp: unknown service.\");\n\n  /* Get the name of the terminal from the environment.  Also get the\n     terminal's speed.  The name and the speed are passed to the server\n     as the argument \"cmd\" of the rcmd() function.  This is something like\n     \"vt100/9600\".  */\n  term_speed = speed (STDIN_FILENO);\n  if (term_speed == SPEED_NOTATTY)\n    {\n      char *p;\n      snprintf (term, sizeof term, \"%s\",\n\t\t((p = getenv (\"TERM\")) ? p : \"network\"));\n    }\n  else\n    {\n      char *p;\n      snprintf (term, sizeof term, \"%s/%d\",\n\t\t((p = getenv (\"TERM\")) ? p : \"network\"), term_speed);\n    }\n  get_window_size (STDIN_FILENO, &winsize);\n\n  setsig (SIGPIPE, lostpeer);\t/* XXX: Replace setsig()?  */\n\n  /*\n   * Block SIGURG and SIGUSR1 signals during connection setup.\n   * These signals will be handled distinctly by parent and child\n   * after completion of process forking.\n   *\n   * SIGUSR1 will be be raise by the child for the parent process,\n   * in order that the client's finding of window size be transmitted\n   * to the remote machine.\n   *\n   * osmask will be passed along as the desired runtime signal mask.\n   */\n  sigemptyset (&smask);\n  sigemptyset (&osmask);\n  sigaddset (&smask, SIGURG);\n  sigaddset (&smask, SIGUSR1);\n  sigprocmask (SIG_SETMASK, &smask, &osmask);\n\n  /*\n   * We set disposition for SIGURG and SIGUSR1 so that an\n   * incoming signal will be held pending rather than being\n   * discarded. Note that these routines will be ready to get\n   * a signal by the time that they are unblocked later on.\n   */\n  sigemptyset (&sa.sa_mask);\n  sa.sa_flags = SA_RESTART;\n  sa.sa_handler = copytochild;\n  (void) sigaction (SIGURG, &sa, NULL);\n  sa.sa_handler = writeroob;\n  (void) sigaction (SIGUSR1, &sa, NULL);\n\n#if defined KERBEROS || defined SHISHI\ntry_connect:\n  if (use_kerberos)\n    {\n      int krb_errno = 0;\n# if defined KERBEROS\n      struct hostent *hp;\n\n      /* Fully qualified hostname (needed for krb_realmofhost).  */\n      hp = gethostbyname (host);\n      if (hp != NULL && !(host = strdup (hp->h_name)))\n\terror (EXIT_FAILURE, errno, \"strdup\");\n\n      rem = KSUCCESS;\n      errno = 0;\n      if (dest_realm == NULL)\n\tdest_realm = krb_realmofhost (host);\n# elif defined (SHISHI)\n      rem = SHISHI_OK;\n      errno = 0;\n# endif\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n#  if defined SHISHI\n\t{\n\t  int i;\n\n\t  rem = krcmd_mutual (&handle, &host, sp->s_port, &user, term, 0,\n\t\t\t      dest_realm, &key, family);\n\t  krb_errno = errno;\n\t  if (rem > 0)\n\t    {\n\t      keytype = shishi_key_type (key);\n\t      keylen = shishi_cipher_blocksize (keytype);\n\n\t      ivtab[0] = &iv1;\n\t      ivtab[1] = &iv2;\n\n\t      for (i = 0; i < 2; i++)\n\t\t{\n\t\t  ivtab[i]->ivlen = keylen;\n\n\t\t  switch (keytype)\n\t\t    {\n\t\t    case SHISHI_DES_CBC_CRC:\n\t\t    case SHISHI_DES_CBC_MD4:\n\t\t    case SHISHI_DES_CBC_MD5:\n\t\t    case SHISHI_DES_CBC_NONE:\n\t\t    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t\t      ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv, !i, ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (handle, key, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (key), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t      break;\n\t\t    case SHISHI_ARCFOUR_HMAC:\n\t\t    case SHISHI_ARCFOUR_HMAC_EXP:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (handle, key, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (key), NULL, 0);\n\t\t      break;\n\t\t    default:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (handle, key, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (key), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      else\n#  else /* KERBEROS */\n\t{\n\t  rem = krcmd_mutual (&host, sp->s_port, user, term, 0,\n\t\t\t      dest_realm, &cred, schedule);\n\t  krb_errno = errno;\n\t}\n      else\n#  endif\n# endif\t/* ENCRYPTION */\n\t{\n# if defined SHISHI\n\t  rem = krcmd (&handle, &host, sp->s_port, &user, term, 0,\n\t\t       dest_realm, family);\n# else /* KERBEROS */\n\t  rem = krcmd (&host, sp->s_port, user, term, 0, dest_realm);\n# endif\n\t  krb_errno = errno;\n\t}\n      if (rem < 0)\n\t{\n\t  use_kerberos = 0;\n\t  if (krb_errno == ECONNREFUSED)\n\t    warning (\"remote host doesn't support Kerberos\");\n\t  else if (krb_errno == ENOENT)\n\t    error (EXIT_FAILURE, 0, \"Can't provide Kerberos auth data.\");\n\t  else\n\t    error (EXIT_FAILURE, 0, \"Kerberos authentication failed.\");\n\n\t  sp = getservbyname (\"login\", \"tcp\");\n\t  if (sp == NULL)\n\t    error (EXIT_FAILURE, 0, \"unknown service login/tcp.\");\n\t  goto try_connect;\n\t}\n    }\n\n  else\n    {\n      char *p = strchr (host, '/');\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n\terror (EXIT_FAILURE, 0, \"the -x flag requires Kerberos authentication.\");\n# endif\t/* ENCRYPTION */\n      if (!user)\n\tuser = pw->pw_name;\n      if (p)\n\thost = ++p;\t/* Skip prefix like `host/'.  */\n\n# ifdef WITH_ORCMD_AF\n      rem = orcmd_af (&host, sp->s_port, pw->pw_name, user, term, 0, family);\n# elif defined WITH_RCMD_AF\n      rem = rcmd_af (&host, sp->s_port, pw->pw_name, user, term, 0, family);\n# elif defined WITH_ORCMD\n      rem = orcmd (&host, sp->s_port, pw->pw_name, user, term, 0);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n      rem = rcmd (&host, sp->s_port, pw->pw_name, user, term, 0);\n# endif\n    }\n#else /* !KERBEROS && !SHISHI */\n  if (!user)\n    user = pw->pw_name;\n\n# ifdef WITH_ORCMD_AF\n  rem = orcmd_af (&host, sp->s_port, pw->pw_name, user, term, 0, family);\n# elif defined WITH_RCMD_AF\n  rem = rcmd_af (&host, sp->s_port, pw->pw_name, user, term, 0, family);\n# elif defined WITH_ORCMD\n  rem = orcmd (&host, sp->s_port, pw->pw_name, user, term, 0);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n  rem = rcmd (&host, sp->s_port, pw->pw_name, user, term, 0);\n# endif\n#endif /* KERBEROS */\n\n  if (rem < 0)\n    {\n      puts (\"\");\t/* Glibc does not close all error strings in rcmd().  */\n      /* rcmd() provides its own error messages,\n       * but we add a vital addition, caused by\n       * insufficient capabilites.\n       */\n      if (errno == EACCES)\n\terror (EXIT_FAILURE, 0, \"No access to privileged ports.\");\n\n      exit (EXIT_FAILURE);\n    }\n\n  {\n    int one = 1;\n    if (dflag && setsockopt (rem, SOL_SOCKET, SO_DEBUG, (char *) &one,\n\t\t\t     sizeof one) < 0)\n      error (0, errno, \"setsockopt DEBUG (ignored)\");\n  }\n\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_LOWDELAY\n  {\n    struct sockaddr_storage ss;\n    socklen_t sslen = sizeof (ss);\n    int one = IPTOS_LOWDELAY;\n\n    (void) getpeername (rem, (struct sockaddr *) &ss, &sslen);\n    if (ss.ss_family == AF_INET &&\n\tsetsockopt (rem, IPPROTO_IP, IP_TOS,\n\t\t    (char *) &one, sizeof (int)) < 0)\n      error (0, errno, \"setsockopt TOS (ignored)\");\n  }\n#endif\n\n  /* Now change to the real user ID.  We have to be set-user-ID root\n     to get the privileged port that rcmd () uses.  We now want, however,\n     to run as the real user who invoked us.  */\n  seteuid (uid);\n  setuid (uid);\n\n  doit (&osmask);\t/* The old mask will activate SIGURG and SIGUSR1!  */\n\n  return 0;\n}",
      "lines": 326,
      "depth": 23,
      "decorators": [
        "int"
      ]
    },
    "speed_translate": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "unsigned int\nspeed_translate (unsigned int sym)\n{\n  unsigned int i;\n  for (i = 0; i < (sizeof (termspeeds) / sizeof (*termspeeds)); i++)\n    {\n      if (termspeeds[i].sym == sym)\n\treturn termspeeds[i].speed;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int"
      ]
    },
    "speed": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "int\nspeed (int fd)\n{\n  struct termios tt;\n\n  if (tcgetattr (fd, &tt) == 0)\n    {\n      /* speed_t sp; */\n      unsigned int sp = cfgetispeed (&tt);\n      return speed_translate (sp);\n    }\n  return SPEED_NOTATTY;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "doit": {
      "start_point": [
        765,
        0
      ],
      "end_point": [
        866,
        1
      ],
      "content": "void\ndoit (sigset_t * osmask)\n{\n  int i;\n  struct sigaction sa;\n\n  for (i = 0; i < NCCS; i++)\n    nott.c_cc[i] = _POSIX_VDISABLE;\n  tcgetattr (0, &deftt);\n  nott.c_cc[VSTART] = deftt.c_cc[VSTART];\n  nott.c_cc[VSTOP] = deftt.c_cc[VSTOP];\n\n  sigemptyset (&sa.sa_mask);\n  sa.sa_flags = SA_RESTART;\n  sa.sa_handler = SIG_IGN;\n  (void) sigaction (SIGINT, &sa, NULL);\n\n  setsignal (SIGHUP);\n  setsignal (SIGQUIT);\n\n  child = fork ();\n  if (child == -1)\n    {\n      error (0, errno, \"fork\");\n      done (1);\n    }\n  if (child == 0)\n    {\n      mode (1);\n      if (reader (osmask) == 0)\n\t{\n\t  /* If the reader returns zero, the socket to the server returned\n\t     an EOF, meaning the client logged out of the remote system.\n\t     This is the normal termination.  */\n#ifdef SHISHI\n\t  if (use_kerberos)\n\t    {\n# ifdef ENCRYPTION\n\t      if (doencrypt)\n\t\t{\n\t\t  shishi_key_done (key);\n\t\t  shishi_crypto_close (iv1.ctx);\n\t\t  shishi_crypto_close (iv2.ctx);\n\t\t  free (iv1.iv);\n\t\t  free (iv2.iv);\n\t\t}\n# endif /* ENCRYPTION */\n\t      shishi_done (handle);\n\t    }\n#endif /* SHISHI */\n          error (0, 0, \"Connection to %s closed normally.\\r\", host);\n          /* EXIT_SUCCESS is usually zero. So error might not exit.  */\n          exit (EXIT_SUCCESS);\n\t}\n      /* If the reader returns non-zero, the socket to the server\n         returned an error.  Something went wrong.  */\n      sleep (1);\n      error (EXIT_FAILURE, 0, \"\\007Connection to %s closed with error.\\r\", host);\n    }\n\n  /*\n   * Parent process == writer.\n   *\n   * We may still own the socket, and may have a pending SIGURG (or might\n   * receive one soon) that we really want to send to the reader.  When\n   * one of these comes in, the trap copytochild simply copies such\n   * signals to the child. We can now unblock SIGURG and SIGUSR1\n   * that were set above.\n   */\n  /* Reenable SIGURG and SIGUSR1.  */\n  sigprocmask (SIG_SETMASK, osmask, (sigset_t *) 0);\n\n  sa.sa_handler = catch_child;\n  (void) sigaction (SIGCHLD, &sa, NULL);\n\n  writer ();\n\n  /* If the writer returns, it means the user entered \"~.\" on the terminal.\n     In this case we terminate and the server will eventually get an EOF\n     on its end of the network connection.  This should cause the server to\n     log you out on the remote system.  */\n  error (0, 0, \"Connection to %s aborted.\\r\", host);\n\n#ifdef SHISHI\n  if (use_kerberos)\n    {\n      shishi_done (handle);\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n\t  shishi_key_done (key);\n\t  shishi_crypto_close (iv1.ctx);\n\t  shishi_crypto_close (iv2.ctx);\n\t  free (iv1.iv);\n\t  free (iv2.iv);\n\t}\n# endif\n    }\n#endif\n\n  done (0);\n}",
      "lines": 102,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "setsignal": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "void\nsetsignal (int sig)\n{\n  int rc;\n  struct sigaction sa;\n\n  /* Query the present disposition of SIG.\n   * This achieves minimal manipulation.  */\n  sa.sa_flags = 0;\n  sa.sa_handler = NULL;\n  sigemptyset (&sa.sa_mask);\n  rc = sigaction (sig, NULL, &sa);\n\n  /* Set action to exit, unless the signal is ignored.  */\n  if (!rc && sa.sa_handler != SIG_IGN)\n    {\n      sa.sa_handler = _exit;\n      (void) sigaction (sig, &sa, NULL);\n    }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "done": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "void\ndone (int status)\n{\n  pid_t w;\n  int wstatus;\n\n  mode (0);\t/* FIXME: Calls tcgetattr/tcsetattr in signal handler.  */\n  if (child > 0)\n    {\n      /* make sure catch_child does not snap it up */\n      setsig (SIGCHLD, SIG_DFL);\t\t/* XXX: Replace setsig()?  */\n      if (kill (child, SIGKILL) >= 0)\n\twhile ((w = waitpid (-1, &wstatus, WNOHANG)) > 0 && w != child)\n\t  continue;\n    }\n  exit (status);\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "writeroob": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        942,
        1
      ],
      "content": "void\nwriteroob (int signo _GL_UNUSED_PARAMETER)\n{\n  if (dosigwinch == 0)\n    {\n      struct sigaction sa;\n\n      sendwindow ();\n\n      sa.sa_flags = SA_RESTART;\n      sa.sa_handler = sigwinch;\n      sigemptyset (&sa.sa_mask);\n      (void) sigaction (SIGWINCH, &sa, NULL);\n    }\n  dosigwinch = 1;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "catch_child": {
      "start_point": [
        946,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "void\ncatch_child (int signo _GL_UNUSED_PARAMETER)\n{\n  int status;\n  pid_t pid;\n\n  for (;;)\n    {\n      pid = waitpid (-1, &status, WNOHANG | WUNTRACED);\n      if (pid == 0)\n\treturn;\n      /* if the child (reader) dies, just quit */\n      if (pid < 0 && errno == EINTR)\n\tcontinue;\n      if (pid < 0 || (pid == child && !WIFSTOPPED (status)))\n\tdone (WEXITSTATUS (status) | WTERMSIG (status));\n    }\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "writer": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        1074,
        1
      ],
      "content": "void\nwriter (void)\n{\n  register int bol, local, n;\n  char c;\n\n  bol = 1;\t\t\t/* beginning of line */\n  local = 0;\n  for (;;)\n    {\n      n = read (STDIN_FILENO, &c, 1);\n      if (n <= 0)\n\t{\n\t  if (n < 0 && errno == EINTR)\n\t    continue;\n\t  break;\n\t}\n      /*\n       * If we're at the beginning of the line and recognize a\n       * command character, then we echo locally.  Otherwise,\n       * characters are echo'd remotely.  If the command character\n       * is doubled, this acts as a force and local echo is\n       * suppressed.\n       */\n      if (bol)\n\t{\n\t  bol = 0;\n\t  if (!noescape && c == escapechar)\n\t    {\n\t      local = 1;\n\t      continue;\n\t    }\n\t}\n      else if (local)\n\t{\n\t  local = 0;\n\t  if (c == '.' || c == deftt.c_cc[VEOF])\n\t    {\n\t      echo (c);\n\t      break;\n\t    }\n\t  if (c == deftt.c_cc[VSUSP]\n#ifdef VDSUSP\n\t      || c == deftt.c_cc[VDSUSP]\n#endif\n\t    )\n\t    {\n\t      bol = 1;\n\t      echo (c);\n\t      stop (c);\n\t      continue;\n\t    }\n\t  if (c != escapechar)\n\t    {\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n\t      if (doencrypt)\n\t\tdes_write (rem, (char *) &escapechar, 1);\n\t      else\n# elif defined(SHISHI)\n\t      if (doencrypt)\n\t\twriteenc (handle, rem, (char *) &escapechar, 1, &wlen,\n\t\t\t  &iv2, key, 2);\n\t      else\n# endif /* SHISHI */\n#endif /* ENCRYPTION */\n\t\twrite (rem, &escapechar, 1);\n\t    }\n\t}\n\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n      if (doencrypt)\n\t{\n\t  if (des_write (rem, &c, 1) == 0)\n\t    {\n              error (0, 0, \"line gone\");\n\t      break;\n\t    }\n\t}\n      else\n# elif defined(SHISHI)\n      if (doencrypt)\n\t{\n\t  writeenc (handle, rem, &c, 1, &wlen, &iv2, key, 2);\n\t  if (wlen == 0)\n\t    {\n              error (0, 0, \"line gone\");\n\t      break;\n\t    }\n\t}\n      else\n# endif\n#endif\n      if (write (rem, &c, 1) == 0)\n\t{\n          error (0, 0, \"line gone\");\n\t  break;\n\t}\n      bol = c == deftt.c_cc[VKILL] || c == deftt.c_cc[VEOF] ||\n\tc == deftt.c_cc[VINTR] || c == deftt.c_cc[VSUSP] ||\n\tc == '\\r' || c == '\\n';\n    }\n}",
      "lines": 104,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "echo": {
      "start_point": [
        1076,
        0
      ],
      "end_point": [
        1100,
        1
      ],
      "content": "void\necho (register char c)\n{\n  register char *p;\n  char buf[8];\n\n  p = buf;\n  c &= 0177;\n  *p++ = escapechar;\n  if (c < ' ')\n    {\n      *p++ = '^';\n      *p++ = c + '@';\n    }\n  else if (c == 0177)\n    {\n      *p++ = '^';\n      *p++ = '?';\n    }\n  else\n    *p++ = c;\n  *p++ = '\\r';\n  *p++ = '\\n';\n  write (STDOUT_FILENO, buf, p - buf);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "stop": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1111,
        1
      ],
      "content": "void\nstop (char cmdc)\n{\n  mode (0);\n  setsig (SIGCHLD, SIG_IGN);\t\t/* XXX: Replace setsig()?  */\n  kill (cmdc == deftt.c_cc[VSUSP] ? 0 : getpid (), SIGTSTP);\n  setsig (SIGCHLD, catch_child);\n  mode (1);\n  sigwinch (0);\t\t\t/* check for size changes */\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sigwinch": {
      "start_point": [
        1113,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "void\nsigwinch (int signo _GL_UNUSED_PARAMETER)\n{\n  struct winsize ws;\n\n  if (dosigwinch && get_window_size (STDIN_FILENO, &ws) == 0\n      && memcmp (&ws, &winsize, sizeof ws))\n    {\n      winsize = ws;\n      sendwindow ();\n    }\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "sendwindow": {
      "start_point": [
        1131,
        0
      ],
      "end_point": [
        1159,
        1
      ],
      "content": "void\nsendwindow (void)\n{\n  struct winsize *wp;\n  char obuf[4 + sizeof (struct winsize)];\n\n  wp = (struct winsize *) (obuf + 4);\n  obuf[0] = 0377;\n  obuf[1] = 0377;\n  obuf[2] = 's';\n  obuf[3] = 's';\n  wp->ws_row = htons (winsize.ws_row);\n  wp->ws_col = htons (winsize.ws_col);\n  wp->ws_xpixel = htons (winsize.ws_xpixel);\n  wp->ws_ypixel = htons (winsize.ws_ypixel);\n\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n  if (doencrypt)\n    des_write (rem, obuf, sizeof obuf);\n  else\n# elif defined(SHISHI)\n  if (doencrypt)\n    writeenc (handle, rem, obuf, sizeof obuf, &wlen, &iv2, key, 2);\n  else\n# endif\n#endif\n    write (rem, obuf, sizeof obuf);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "oob": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1278,
        1
      ],
      "content": "void\noob (int signo _GL_UNUSED_PARAMETER)\n{\n  char mark;\n  struct termios tt;\n  int atmark, n, out, rcvd;\n  char waste[BUFSIZ];\n\n  out = O_RDWR;\n  rcvd = 0;\n\n#ifdef SHISHI\n  if (use_kerberos)\n    mark = rcvbuf[4];\t\t/* Payload in fifth byte.  */\n  else\n#endif\n    while (recv (rem, &mark, 1, MSG_OOB) < 0)\n      {\n\tswitch (errno)\n\t  {\n\t  case EWOULDBLOCK:\n\t    /*\n\t     * Urgent data not here yet.  It may not be possible\n\t     * to send it yet if we are blocked for output and\n\t     * our input buffer is full.\n\t     */\n\t    if ((size_t) rcvcnt < sizeof rcvbuf)\n\t      {\n\t\tn = read (rem, rcvbuf + rcvcnt, sizeof (rcvbuf) - rcvcnt);\n\t\tif (n <= 0)\n\t\t  return;\n\t\trcvd += n;\n\t      }\n\t    else\n\t      {\n\t\tn = read (rem, waste, sizeof waste);\n\t\tif (n <= 0)\n\t\t  return;\n\t      }\n\t    continue;\n\t  default:\n\t    return;\n\t  }\n      }\n\n  if (mark & TIOCPKT_WINDOW)\n    {\n      /* Let server know about window size changes */\n      kill (ppid, SIGUSR1);\n    }\n  if (!eight && (mark & TIOCPKT_NOSTOP))\n    {\n      tcgetattr (0, &tt);\n      tt.c_iflag &= ~(IXON | IXOFF);\n      tt.c_cc[VSTOP] = _POSIX_VDISABLE;\n      tt.c_cc[VSTART] = _POSIX_VDISABLE;\n      tcsetattr (0, TCSANOW, &tt);\n    }\n  if (!eight && (mark & TIOCPKT_DOSTOP))\n    {\n      tcgetattr (0, &tt);\n      tt.c_iflag |= (IXON | IXOFF);\n      tt.c_cc[VSTOP] = deftt.c_cc[VSTOP];\n      tt.c_cc[VSTART] = deftt.c_cc[VSTART];\n      tcsetattr (0, TCSANOW, &tt);\n    }\n  if (mark & TIOCPKT_FLUSHWRITE)\n    {\n#ifdef TIOCFLUSH\t\t/* BSD and Solaris.  */\n      ioctl (STDOUT_FILENO, TIOCFLUSH, (char *) &out);\n#elif defined TCIOFLUSH\t\t/* Glibc, BSD, and Solaris.  */\n      out = TCIOFLUSH;\n      ioctl (STDOUT_FILENO, TCIOFLUSH, &out);\n#endif\n      for (;;)\n\t{\n\t  if (ioctl (rem, SIOCATMARK, &atmark) < 0)\n\t    {\n\t      error (0, errno, \"ioctl SIOCATMARK (ignored)\");\n\t      break;\n\t    }\n\t  if (atmark)\n\t    break;\n\t  n = read (rem, waste, sizeof waste);\n\t  if (n <= 0)\n\t    break;\n\t}\n      /*\n       * Don't want any pending data to be output, so clear the recv\n       * buffer.  If we were hanging on a write when interrupted,\n       * don't want it to restart.  If we were reading, restart\n       * anyway.\n       */\n      rcvcnt = 0;\n      longjmp (rcvtop, 1);\n    }\n\n  /* oob does not do FLUSHREAD (alas!) */\n\n  /*\n   * If we filled the receive buffer while a read was pending, longjmp\n   * to the top to restart appropriately.  Don't abort a pending write,\n   * however, or we won't know how much was written.\n   */\n  if (rcvd && rcvstate == READING)\n    longjmp (rcvtop, 1);\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "reader": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1356,
        1
      ],
      "content": "int\nreader (sigset_t * osmask)\n{\n  pid_t pid;\n  int n, remaining;\n  char *bufp;\n  struct sigaction sa;\n\n  pid = getpid ();\t/* Modern systems use positive values for pid.  */\n  ppid = getppid ();\n\n  fcntl (rem, F_SETOWN, pid);\t\t/* Get ownership early.  */\n\n  sa.sa_flags = SA_RESTART;\n  sa.sa_handler = SIG_IGN;\n  sigemptyset (&sa.sa_mask);\n  (void) sigaction (SIGTTOU, &sa, NULL);\n  sa.sa_handler = oob;\n  (void) sigaction (SIGURG, &sa, NULL);\n\n  setjmp (rcvtop);\n  sigprocmask (SIG_SETMASK, osmask, (sigset_t *) 0);\n  bufp = rcvbuf;\n\n  for (;;)\n    {\n#ifdef SHISHI\n      if (use_kerberos)\n\t{\n\t  if ((rcvcnt >= 5) && (bufp[0] == '\\377') && (bufp[1] == '\\377'))\n\t    if ((bufp[2] == 'o') && (bufp[3] == 'o'))\n\t      {\n\t\toob (1);\n\t\tbufp += 5;\n\t      }\n\t}\n#endif\n      while ((remaining = rcvcnt - (bufp - rcvbuf)) > 0)\n\t{\n\t  rcvstate = WRITING;\n\t  n = write (STDOUT_FILENO, bufp, remaining);\n\t  if (n < 0)\n\t    {\n\t      if (errno != EINTR)\n\t\treturn -1;\n\t      continue;\n\t    }\n\t  bufp += n;\n\t}\n      bufp = rcvbuf;\n      rcvcnt = 0;\n      rcvstate = READING;\n\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n      if (doencrypt)\n\trcvcnt = des_read (rem, rcvbuf, sizeof rcvbuf);\n      else\n# elif defined(SHISHI)\n      if (doencrypt)\n\treadenc (handle, rem, rcvbuf, &rcvcnt, &iv1, key, 2);\n      else\n# endif\n#endif\n\trcvcnt = read (rem, rcvbuf, sizeof rcvbuf);\n      if (rcvcnt == 0)\n\treturn 0;\n      if (rcvcnt < 0)\n\t{\n\t  if (errno == EINTR)\n\t    continue;\n\t  error (0, errno, \"read\");\n\t  return -1;\n\t}\n    }\n}",
      "lines": 76,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "mode": {
      "start_point": [
        1358,
        0
      ],
      "end_point": [
        1393,
        1
      ],
      "content": "void\nmode (int f)\n{\n  struct termios tt;\n\n  switch (f)\n    {\n    case 0:\n      /* remember whether IXON is set, set it can be restore at mode(1) */\n      tcgetattr (0, &ixon_state);\n      tcsetattr (0, TCSADRAIN, &deftt);\n      break;\n    case 1:\n      tt = deftt;\n      tt.c_oflag &= ~(OPOST);\n      tt.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n      tt.c_iflag &= ~(ICRNL);\n      tt.c_cc[VMIN] = 1;\n      tt.c_cc[VTIME] = 0;\n      if (eight)\n\t{\n\t  tt.c_iflag &= ~(IXON | IXOFF | ISTRIP);\n\t  tt.c_cc[VSTOP] = _POSIX_VDISABLE;\n\t  tt.c_cc[VSTART] = _POSIX_VDISABLE;\n\t}\n      if ((ixon_state.c_iflag & IXON) && !eight)\n\ttt.c_iflag |= IXON;\n      else\n\ttt.c_iflag &= ~IXON;\n      tcsetattr (0, TCSADRAIN, &tt);\n      break;\n\n    default:\n      return;\n    }\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "lostpeer": {
      "start_point": [
        1397,
        0
      ],
      "end_point": [
        1403,
        1
      ],
      "content": "void\nlostpeer (int signo)\n{\n  setsig (signo, SIG_IGN);\t/* Used with SIGPIPE only.  */\n  error (0, 0, \"\\007Connection to %s lost.\\r\", host);\n  done (1);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "copytochild": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1410,
        1
      ],
      "content": "void\ncopytochild (int signo)\n{\n  kill (child, signo);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "warning": {
      "start_point": [
        1413,
        0
      ],
      "end_point": [
        1423,
        1
      ],
      "content": "void\nwarning (const char *fmt, ...)\n{\n  va_list ap;\n\n  fprintf (stderr, \"rlogin: warning, using standard rlogin: \");\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fprintf (stderr, \".\\n\");\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "get_window_size": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1446,
        1
      ],
      "content": "int\nget_window_size (int fd, struct winsize *wp)\n{\n  struct ttysize ts;\n  int error;\n\n  error = ioctl (0, TIOCGSIZE, &ts);\n  if (error != 0)\n    return error;\n\n  wp->ws_row = ts.ts_lines;\n  wp->ws_col = ts.ts_cols;\n  wp->ws_xpixel = 0;\n  wp->ws_ypixel = 0;\n  return 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getescape": {
      "start_point": [
        1449,
        0
      ],
      "end_point": [
        1472,
        1
      ],
      "content": "u_int\ngetescape (register char *p)\n{\n  long val;\n  int len;\n\n  len = strlen (p);\n  if (len == 1)\t\t/* use any single char, including '\\'.  */\n    return ((u_int) * p);\n\n  /* otherwise, \\nnn */\n  if (*p == '\\\\' && len >= 2 && len <= 4)\n    {\n      val = strtol (++p, NULL, 8);\n      for (;;)\n\t{\n\t  if (!*++p)\n\t    return ((u_int) val);\n\t  if (*p < '0' || *p > '8')\n\t    break;\n\t}\n    }\n  return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "u_int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rlogind.c": {
    "rlogind_sigchld": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\nrlogind_sigchld (int signo _GL_UNUSED_PARAMETER)\n{\n  pid_t pid;\n  int status;\n\n  while ((pid = waitpid (-1, &status, WNOHANG)) > 0)\n    --numchildren;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "check_host": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static int\ncheck_host (struct sockaddr *sa, socklen_t len)\n{\n  int rc;\n  char addr[INET6_ADDRSTRLEN];\n# if HAVE_DECL_GETNAMEINFO\n  char name[NI_MAXHOST];\n# else\n  struct hostent *hp;\n  void *addrp;\n  char *name;\n# endif /* !HAVE_DECL_NAMEINFO */\n\n  if (sa->sa_family != AF_INET\n# ifdef IPV6\n      && sa->sa_family != AF_INET6\n# endif\n     )\n    return 1;\n\n# if HAVE_DECL_GETNAMEINFO\n  (void) getnameinfo(sa, len, addr, sizeof (addr), NULL, 0, NI_NUMERICHOST);\n  rc = getnameinfo(sa, len, name, sizeof (name), NULL, 0, NI_NAMEREQD);\n# else /* !HAVE_DECL_GETNAMEINFO */\n\n  (void) len;\t\t/* Silence warning.  */\n\n  switch (sa->sa_family)\n    {\n#  ifdef IPV6\n    case AF_INET6:\n      addrp = (void *) &((struct sockaddr_in6 *) sa)->sin6_addr;\n      hp = gethostbyaddr (addrp, sizeof (struct in6_addr),\n\t\t\t  sa->sa_family);\n      break;\n#  endif\n    case AF_INET:\n    default:\n      addrp = (void *) &((struct sockaddr_in *) sa)->sin_addr;\n      hp = gethostbyaddr (addrp, sizeof (struct in_addr),\n\t\t\t  sa->sa_family);\n    }\n\n  (void) inet_ntop (sa->sa_family, addrp, addr, sizeof (addr));\n  if (hp)\n    name = hp->h_name;\n  rc = (hp == NULL);\t\t/* Translate to getnameinfo style.  */\n# endif /* !HAVE_DECL_GETNAMEINFO */\n\n  if (!rc)\n    {\n      if (!hosts_ctl (\"rlogind\", name, addr, STRING_UNKNOWN))\n\t{\n\t  syslog (deny_severity, \"tcpd rejects %s [%s]\",\n\t\t  name, addr);\n\t  return 0;\n\t}\n    }\n  else\n    {\n      if (!hosts_ctl (\"rlogind\", STRING_UNKNOWN, addr, STRING_UNKNOWN))\n\t{\n\t  syslog (deny_severity, \"tcpd rejects [%s]\", addr);\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 68,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_opt": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case '4':\n      use_af = AF_INET;\n      break;\n\n#ifdef IPV6\n    case '6':\n      use_af = AF_INET6;\n      break;\n#endif\n\n    case 'a':\n      verify_hostname = 1;\n      break;\n\n    case 'D':\n      if (arg)\n\tdebug_level = strtoul (arg, NULL, 10);\n      break;\n\n    case 'd':\n      mode = MODE_DAEMON;\n      if (arg)\n\tmaxchildren = strtoul (arg, NULL, 10);\n      if (maxchildren == 0)\n\tmaxchildren = DEFMAXCHILDREN;\n      break;\n\n#ifdef HAVE___CHECK_RHOSTS_FILE\n    case 'l':\n      __check_rhosts_file = 0;\t/* FIXME: extern var? */\n      break;\n#endif\n\n    case 'L':\n      local_domain_name = arg;\n      break;\n\n    case 'n':\n      keepalive = 0;\n      break;\n\n#if defined KERBEROS || defined SHISHI\n    case 'k':\n      kerberos = AUTH_KERBEROS_DEFAULT;\n      break;\n\n    case 'S':\n      servername = arg;\n      break;\n\n# ifdef ENCRYPTION\n    case 'x':\n      encrypt_io = 1;\n      break;\n# endif\t/* ENCRYPTION */\n#endif /* KERBEROS */\n\n    case 'o':\n      allow_root = 1;\n      break;\n\n    case 'p':\n      port = strtoul (arg, NULL, 10);\n      break;\n\n    case 'r':\n      reverse_required = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 81,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        622,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n\n  set_program_name (argv[0]);\n\n  /* Parse command line */\n  iu_argp_init (\"rlogind\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  openlog (\"rlogind\", LOG_PID | LOG_CONS, LOG_DAEMON);\n  argc -= index;\n  if (argc > 0)\n    {\n      syslog (LOG_ERR, \"%d extra arguments\", argc);\n      exit (EXIT_FAILURE);\n    }\n\n  setsig (SIGHUP, SIG_IGN);\n\n  if (!local_domain_name)\n    {\n      char *p = localhost ();\n\n      if (!p)\n\t{\n\t  syslog (LOG_ERR, \"can't determine local hostname\");\n\t  exit (EXIT_FAILURE);\n\t}\n      local_dot_count = 2;\n      local_domain_name = topdomain (p, local_dot_count);\n    }\n  else\n    {\n      char *p;\n\n      local_dot_count = 0;\n      for (p = local_domain_name; *p; p++)\n\tif (*p == '.')\n\t  local_dot_count++;\n    }\n\n  if (mode == MODE_DAEMON)\n    rlogin_daemon (maxchildren, port);\n  else\n    exit (rlogind_mainloop (fileno (stdin), fileno (stdout)));\n\n  return 0;\t\t/* Not reachable.  */\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "find_listenfd": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "int\nfind_listenfd (int family, int port)\n{\n  int fd, on = 1;\n  socklen_t size;\n#if HAVE_DECL_GETADDRINFO\n  int rc;\n  struct sockaddr_storage saddr;\n  struct addrinfo hints, *ai, *res;\n  char portstr[16];\n#else /* !HAVE_DECL_GETADDRINFO */\n  struct sockaddr_in saddr;\n\n  /* Enforce IPv4, lacking getaddrinfo().  */\n  if (family != AF_INET)\n    return -1;\n#endif\n\n#if HAVE_DECL_GETADDRINFO\n  memset (&hints, 0, sizeof hints);\n  hints.ai_family = family;\n  hints.ai_flags = AI_PASSIVE;\n  hints.ai_socktype = SOCK_STREAM;\n  snprintf (portstr, sizeof portstr, \"%u\", port);\n\n  rc = getaddrinfo (NULL, portstr, &hints, &res);\n  if (rc)\n    {\n      syslog (LOG_ERR, \"getaddrinfo: %s\", gai_strerror (rc));\n      return -1;\n    }\n\n  /* Passive socket, so grab the first relevant answer.  */\n  for (ai = res; ai; ai = ai->ai_next)\n    if (ai->ai_family == family)\n      break;\n\n  if (ai == NULL)\n    {\n      syslog (LOG_ERR, \"address family not available\");\n      freeaddrinfo (res);\n      return -1;\n    }\n\n  size = ai->ai_addrlen;\n  memcpy (&saddr, ai->ai_addr, ai->ai_addrlen);\n  freeaddrinfo (res);\n\n#else /* !HAVE_DECL_GETADDRINFO */\n  size = sizeof saddr;\n  memset (&saddr, 0, size);\n  saddr.sin_family = family;\n# ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  saddr.sin_len = sizeof (struct sockaddr_in);\n# endif\n  saddr.sin_addr.s_addr = htonl (INADDR_ANY);\n  saddr.sin_port = htons (port);\n#endif\n\n  fd = socket (family, SOCK_STREAM, 0);\n  if (fd < 0)\n    return -1;\n\n  (void) setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof on);\n\n#ifdef IPV6\n  /* Make it a single ended socket.  */\n  if (family == AF_INET6)\n    (void) setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &on, sizeof on);\n#endif\n\n  if (bind (fd, (struct sockaddr *) &saddr, size) == -1)\n    {\n      syslog (LOG_ERR, \"bind: %s\", strerror (errno));\n      close (fd);\n      return -1;\n    }\n\n  if (listen (fd, 128) == -1)\n    {\n      syslog (LOG_ERR, \"listen: %s\", strerror (errno));\n      close (fd);\n      return -1;\n    }\n\n  return fd;\n}",
      "lines": 87,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rlogin_daemon": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "void\nrlogin_daemon (int maxchildren, int port)\n{\n  int listenfd[2], fd, numfd, maxfd;\n\n  if (port == 0)\n    {\n      char *service;\n      struct servent *svp;\n\n#if defined KERBEROS || defined SHISHI\n# ifdef ENCRYPTION\n      if (kerberos && encrypt_io)\n\t{\n\t  service = \"eklogin\";\n\t  port = DEFPORT_EKLOGIN;\n\t}\n      else\n# endif /* ENCRYPTION */\n\tif (kerberos)\n\t  {\n\t    service = \"klogin\";\n\t    port = DEFPORT_KLOGIN;\n\t  }\n\telse\n#endif /* KERBEROS || SHISHI */\n\t  {\n\t    service = \"login\";\n\t    port = DEFPORT;\n\t  }\n\n      svp = getservbyname (service, \"tcp\");\n      if (svp != NULL)\n\tport = ntohs (svp->s_port);\n    }\n\n  /* Become a daemon. Take care to close inherited fds and reserve\n     the first three, lest master/slave ptys may clash with standard\n     input, output, or error.  */\n  if (daemon (0, 0) < 0)\n    {\n      syslog (LOG_ERR, \"failed to become a daemon %s\", strerror (errno));\n      fatal (fileno (stderr), \"fork failed, exiting\", 0);\n    }\n\n  setsig (SIGCHLD, rlogind_sigchld);\n\n  numfd = maxfd = 0;\n\n  if ((use_af == AF_UNSPEC) || (use_af == AF_INET))\n    {\n      fd = find_listenfd (AF_INET, port);\n      if (fd >= 0)\n\tlistenfd[numfd++] = maxfd = fd;\n    }\n\n#ifdef IPV6\n  if ((use_af == AF_UNSPEC) || (use_af == AF_INET6))\n    {\n      fd = find_listenfd (AF_INET6, port);\n      if (fd >= 0)\n\t{\n\t  listenfd[numfd++] = fd;\n\t  if (fd > maxfd)\n\t    maxfd = fd;\n\t}\n    }\n#endif\n\n  if (numfd == 0)\n    {\n      syslog (LOG_ERR, \"socket creation failed\");\n      exit (EXIT_FAILURE);\n    }\n\n  while (1)\n    {\n      int n, j;\n      fd_set lfdset;\n\n      if (numchildren > maxchildren)\n\t{\n\t  syslog (LOG_ERR, \"too many children (%d)\", numchildren);\n\t  pause ();\n\t  continue;\n\t}\n\n      FD_ZERO (&lfdset);\n      FD_SET (listenfd[0], &lfdset);\n      if (numfd > 1)\n\tFD_SET (listenfd[1], &lfdset);\n\n      n = select (maxfd + 1, &lfdset, NULL, NULL, NULL);\n      if (n <= 0)\n\tcontinue;\n\n      for (j = 0; j < numfd; j++)\n\t{\n\t  pid_t pid;\n\t  socklen_t size;\n#if HAVE_DECL_GETADDRINFO\n\t  struct sockaddr_storage saddr;\n#else /* !HAVE_DECL_GETADDRINFO */\n\t  struct sockaddr_in saddr;\n#endif\n\n\t  if (!FD_ISSET (listenfd[j], &lfdset))\n\t    continue;\n\n\t  size = sizeof (saddr);\n\t  fd = accept (listenfd[j], (struct sockaddr *) &saddr, &size);\n\n\t  if (fd < 0)\n\t    {\n\t      if (errno == EINTR)\n\t\tcontinue;\n\t      syslog (LOG_ERR, \"accept: %s\", strerror (errno));\n\t      continue;\n\t    }\n\n\t  pid = fork ();\n\t  if (pid == -1)\n\t    syslog (LOG_ERR, \"fork: %s\", strerror (errno));\n\t  else if (pid == 0)\t/* child */\n\t    {\n\t      close (listenfd[0]);\n\t      if (numfd > 1)\n\t\tclose (listenfd[1]);\n#ifdef WITH_WRAP\n\t      if (!check_host ((struct sockaddr *) &saddr, size))\n\t\texit (EXIT_FAILURE);\n#endif\n\t      exit (rlogind_mainloop (fd, fd));\n\t    }\n\t  /* parent only */\n\t  numchildren++;\n\t  close (fd);\n\t}\n    }\n  /* NOT REACHED */\n}",
      "lines": 141,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "rlogind_auth": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "int\nrlogind_auth (int fd, struct auth_data *ap)\n{\n#if HAVE_DECL_GETNAMEINFO && HAVE_DECL_GETADDRINFO\n  int rc;\n  char hoststr[NI_MAXHOST];\n#else\n  struct hostent *hp;\n  void *addrp;\n#endif\n  char *hostname = \"\";\n  int authenticated = 0;\n  int port;\n\n#ifdef SHISHI\n  int len, c;\n#endif\n\n  switch (ap->from.ss_family)\n    {\n    case AF_INET6:\n#if !HAVE_DECL_GETADDRINFO || !HAVE_DECL_GETNAMEINFO\n      addrp = (void *) &((struct sockaddr_in6 *) &ap->from)->sin6_addr;\n#endif\n      port = ntohs (((struct sockaddr_in6 *) &ap->from)->sin6_port);\n      break;\n    case AF_INET:\n    default:\n#if !HAVE_DECL_GETADDRINFO || !HAVE_DECL_GETNAMEINFO\n      addrp = (void *) &((struct sockaddr_in *) &ap->from)->sin_addr;\n#endif\n      port = ntohs (((struct sockaddr_in *) &ap->from)->sin_port);\n    }\n\n  confirmed = 0;\n\n  /* Check the remote host name */\n#if HAVE_DECL_GETNAMEINFO\n  rc = getnameinfo ((struct sockaddr *) &ap->from, ap->fromlen,\n\t\t    hoststr, sizeof (hoststr), NULL, 0, NI_NAMEREQD);\n  if (!rc)\n    hostname = hoststr;\n#else /* !HAVE_DECL_GETNAMEINFO */\n  switch (ap->from.ss_family)\n    {\n    case AF_INET6:\n      hp = gethostbyaddr (addrp, sizeof (struct in6_addr),\n\t\t\t  ap->from.ss_family);\n      break;\n    case AF_INET:\n    default:\n      hp = gethostbyaddr (addrp, sizeof (struct in_addr),\n\t\t\t  ap->from.ss_family);\n    }\n  if (hp)\n    hostname = hp->h_name;\n#endif /* !HAVE_DECL_GETNAMEINFO */\n\n  else if (reverse_required)\n    {\n      syslog (LOG_NOTICE, \"can't resolve remote IP address\");\n      fatal (fd, \"Permission denied\", 0);\n    }\n  else\n    hostname = ap->hostaddr;\n\n  ap->hostname = strdup (hostname);\n\n  if (verify_hostname || in_local_domain (ap->hostname))\n    {\n      int match = 0;\n#if HAVE_DECL_GETADDRINFO && HAVE_DECL_GETNAMEINFO\n      struct addrinfo hints, *ai, *res;\n      char astr[INET6_ADDRSTRLEN];\n\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_family = ap->from.ss_family;\n      hints.ai_socktype = SOCK_STREAM;\n\n      rc = getaddrinfo (ap->hostname, NULL, &hints, &res);\n      if (!rc)\n\t{\n\t  for (ai = res; ai; ai = ai->ai_next)\n\t    {\n\t      rc = getnameinfo (ai->ai_addr, ai->ai_addrlen,\n\t\t\t\tastr, sizeof (astr), NULL, 0,\n\t\t\t\tNI_NUMERICHOST);\n\t      if (rc)\n\t\tcontinue;\n\t      match = strcmp (astr, ap->hostaddr) == 0;\n\t      if (match)\n\t\tbreak;\n\t    }\n\t  freeaddrinfo (res);\n\t}\n#else /* !HAVE_DECL_GETADDRINFO */\n      for (hp = gethostbyname (ap->hostname); hp && !match; hp->h_addr_list++)\n\t{\n\t  if (hp->h_addr_list[0] == NULL)\n\t    break;\n\t  match = memcmp (hp->h_addr_list[0], addrp, hp->h_length) == 0;\n\t}\n#endif /* !HAVE_DECL_GETADDRINFO */\n      if (!match)\n\t{\n\t  syslog (LOG_ERR | LOG_AUTH, \"cannot verify matching IP for %s (%s)\",\n\t\t  ap->hostname, ap->hostaddr);\n\t  fatal (fd, \"Permission denied\", 0);\n\t}\n    }\n\n#ifdef IP_OPTIONS\n  prevent_routing (fd, ap);\n#endif\n\n#if defined KERBEROS || defined SHISHI\n  if (kerberos)\n    {\n      const char *err_msg;\n      int c = 0;\n\n      if (do_krb_login (fd, ap, &err_msg) == 0)\n\tauthenticated++;\n      else\n\tfatal (fd, err_msg, 0);\n      write (fd, &c, 1);\n      confirmed = 1;\t\t/* We have sent the null!  */\n    }\n  else\n#endif\n    {\n      if ((ap->from.ss_family != AF_INET\n#ifndef KERBEROS\n\t   && ap->from.ss_family != AF_INET6\n#endif\n\t  )\n\t  || port >= IPPORT_RESERVED || port < IPPORT_RESERVED / 2)\n\t{\n\t  syslog (LOG_NOTICE, \"Connection from %s on illegal port %d\",\n\t\t  ap->hostaddr, port);\n\t  fatal (fd, \"Permission denied\", 0);\n\t}\n\n      if (do_rlogin (fd, ap) == 0)\n\tauthenticated++;\n    }\n\n  if (confirmed == 0)\n    {\n      write (fd, \"\", 1);\n      confirmed = 1;\t\t/* we sent the null! */\n    }\n#ifdef SHISHI\n  len = sizeof (SECURE_MESSAGE) - 1;\n  IF_ENCRYPT (writeenc\n\t      (ap->h, fd, SECURE_MESSAGE, len, &c, &ap->iv2, ap->enckey,\n\t       ap->protocol));\n#else\n  IF_ENCRYPT (des_write (fd, SECURE_MESSAGE, sizeof (SECURE_MESSAGE) - 1));\n#endif\n  return authenticated;\n}",
      "lines": 162,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "prevent_routing": {
      "start_point": [
        1022,
        0
      ],
      "end_point": [
        1078,
        1
      ],
      "content": "void\nprevent_routing (int fd, struct auth_data *ap)\n{\n  unsigned char optbuf[BUFSIZ / 3], *cp;\n  char lbuf[BUFSIZ], *lp;\n  socklen_t optsize = sizeof (optbuf);\n  int ipproto;\n  struct protoent *ip;\n\n  ip = getprotobyname (\"ip\");\n  if (ip != NULL)\n    ipproto = ip->p_proto;\n  else\n    ipproto = IPPROTO_IP;\n\n  if (getsockopt (fd, ipproto, IP_OPTIONS, (char *) optbuf, &optsize) == 0\n      && optsize != 0)\n    {\n      lp = lbuf;\n      for (cp = optbuf; optsize > 0; )\n\t{\n\t  sprintf (lp, \" %2.2x\", *cp);\n\t  lp += 3;\n\n\t  /* These two open an attack vector.  */\n\t  if (*cp == IPOPT_SSRR || *cp == IPOPT_LSRR)\n\t    {\n\t      syslog (LOG_NOTICE,\n\t\t      \"Discarding connection from %s with set source routing\",\n\t\t      ap->hostaddr);\n\t      exit (EXIT_FAILURE);\n\t    }\n\n\t  if (*cp == IPOPT_EOL)\n\t    break;\n\n\t  if (*cp == IPOPT_NOP)\n\t    cp++, optsize--;\n\t  else\n\t    {\n\t      /* Options using a length octet, see RFC 791.  */\n\t      int inc = cp[1];\n\n\t      optsize -= inc;\n\t      cp += inc;\n\t    }\n\t}\n\n      syslog (LOG_NOTICE, \"Ignoring IP options: %s\", lbuf);\n\n      if (setsockopt (fd, ipproto, IP_OPTIONS, (char *) NULL, optsize))\n\t{\n\t  syslog (LOG_ERR, \"setsockopt IP_OPTIONS NULL: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "setup_tty": {
      "start_point": [
        1081,
        0
      ],
      "end_point": [
        1109,
        1
      ],
      "content": "void\nsetup_tty (int fd, struct auth_data *ap)\n{\n  register char *cp = strchr (ap->term + ENVSIZE, '/');\n  char *speed;\n  struct termios tt;\n\n  tcgetattr (fd, &tt);\n  if (cp)\n    {\n      *cp++ = '\\0';\n      speed = cp;\n      cp = strchr (speed, '/');\n      if (cp)\n\t*cp++ = '\\0';\n#ifdef HAVE_CFSETSPEED\n      cfsetspeed (&tt, strtoul (speed, NULL, 10));\n#else\n      cfsetispeed (&tt, strtoul (speed, NULL, 10));\n      cfsetospeed (&tt, strtoul (speed, NULL, 10));\n#endif\n    }\n  tt.c_iflag = TTYDEF_IFLAG;\n  tt.c_oflag = TTYDEF_OFLAG;\n  tt.c_lflag = TTYDEF_LFLAG;\n  tcsetattr (fd, TCSAFLUSH, &tt);\n  ap->env[0] = ap->term;\n  ap->env[1] = 0;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "setup_utmp": {
      "start_point": [
        1111,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "void\nsetup_utmp (char *line, char *host)\n{\n  char *ut_id = utmp_ptsid (line, \"rl\");\n\n  utmp_init (line + sizeof (PATH_TTY_PFX) - 1, \".rlogin\", ut_id, host);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "exec_login": {
      "start_point": [
        1119,
        0
      ],
      "end_point": [
        1166,
        1
      ],
      "content": "void\nexec_login (int authenticated, struct auth_data *ap)\n{\n  if (authenticated)\n    {\n#ifdef SOLARIS10\n      execle (path_login, \"login\", \"-p\", \"-r\", ap->hostname,\n\t      \"-d\", line, \"-U\", ap->rusername,\n# if defined KERBEROS || defined SHISHI\n\t      \"-s\", (kerberos ? \"krlogin\" : \"rlogin\"),\n\t      \"-u\", (ap->rprincipal ? ap->rprincipal : ap->rusername),\n# else /* !KERBEROS && !SHISHI */\n\t      \"-s\", \"rlogin\",\n# endif\n\t      ap->lusername, NULL, ap->env);\n\n#elif defined SOLARIS\t/* !SOLARIS10 */\n      execle (path_login, \"login\", \"-p\", \"-r\", ap->hostname,\n\t      \"-d\", line, ap->lusername, NULL, ap->env);\n\n#else /* !SOLARIS */\n      /* Some GNU/Linux systems, but not all,  provide `-r'\n       * for use instead of `-h'.  Some BSD systems provide `-u'.\n       */\n      execle (path_login, \"login\", \"-p\", \"-h\", ap->hostname, \"-f\",\n\t      ap->lusername, NULL, ap->env);\n#endif\n    }\n  else\n    {\n#ifdef SOLARIS10\n      /* `-U' in not strictly needed, but is probably harmless.  */\n      execle (path_login, \"login\", \"-p\", \"-r\", ap->hostname,\n\t      \"-d\", line, \"-s\", \"rlogin\", \"-U\", ap->rusername,\n\t      ap->lusername, NULL, ap->env);\n#elif defined SOLARIS\n      execle (path_login, \"login\", \"-p\", \"-r\", ap->hostname,\n\t      \"-d\", line, ap->lusername, NULL, ap->env);\n#else\n      /* Some GNU/Linux systems, but not all,  provide `-r'\n       * for use instead of `-h'.  Some BSD systems provide `-u'.\n       */\n      execle (path_login, \"login\", \"-p\", \"-h\", ap->hostname,\n\t      ap->lusername, NULL, ap->env);\n#endif\n    }\n  syslog (LOG_ERR, \"can't exec login: %m\");\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rlogind_mainloop": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1295,
        1
      ],
      "content": "int\nrlogind_mainloop (int infd, int outfd)\n{\n  struct auth_data auth_data;\n  char addrstr[INET6_ADDRSTRLEN];\n  const char *reply;\n  int true;\n  char c;\n  int authenticated;\n  pid_t pid;\n  int master;\n\n  memset (&auth_data, 0, sizeof (auth_data));\n  auth_data.fromlen = sizeof (auth_data.from);\n  if (getpeername (infd, (struct sockaddr *) &auth_data.from,\n\t\t   &auth_data.fromlen) < 0)\n    {\n      syslog (LOG_ERR, \"Can't get peer name of remote host: %m\");\n      fatal (outfd, \"Can't get peer name of remote host\", 1);\n    }\n\n  reply = inet_ntop (auth_data.from.ss_family,\n\t\t     (auth_data.from.ss_family == AF_INET6)\n\t\t       ? (void *) &((struct sockaddr_in6 *) &auth_data.from)->sin6_addr\n\t\t       : (void *) &((struct sockaddr_in *) &auth_data.from)->sin_addr,\n\t\t     addrstr, sizeof (addrstr));\n  if (reply == NULL)\n    {\n      syslog (LOG_ERR, \"Get numerical address: %m\");\n      fatal (outfd, \"Cannot get numerical address of peer.\", 1);\n    }\n  auth_data.hostaddr = xstrdup (addrstr);\n\n  syslog (LOG_INFO, \"Connect from %s:%d\", auth_data.hostaddr,\n\t  (auth_data.from.ss_family == AF_INET6)\n\t  ? ntohs (((struct sockaddr_in6 *) &auth_data.from)->sin6_port)\n\t  : ntohs (((struct sockaddr_in *) &auth_data.from)->sin_port));\n\n  true = 1;\n  if (keepalive\n      && setsockopt (infd, SOL_SOCKET, SO_KEEPALIVE, &true, sizeof true) < 0)\n    syslog (LOG_WARNING, \"setsockopt (SO_KEEPALIVE): %m\");\n\n#if defined IP_TOS && defined IPPROTO_IP && defined IPTOS_LOWDELAY\n  true = IPTOS_LOWDELAY;\n  if (auth_data.from.ss_family == AF_INET &&\n      setsockopt (infd, IPPROTO_IP, IP_TOS,\n\t\t  (char *) &true, sizeof true) < 0)\n    syslog (LOG_WARNING, \"setsockopt (IP_TOS): %m\");\n#endif\n\n  alarm (60);\t\t\t/* Wait at most 60 seconds. FIXME: configurable? */\n\n  /* Read the null byte */\n  if (read (infd, &c, 1) != 1 || c != 0)\n    {\n      syslog (LOG_ERR, \"protocol error: expected 0 byte\");\n      exit (EXIT_FAILURE);\n    }\n\n  alarm (0);\n\n  authenticated = rlogind_auth (infd, &auth_data);\n\n  pid = forkpty (&master, line, NULL, &win);\n\n  if (pid < 0)\n    {\n      if (errno == ENOENT)\n\t{\n\t  syslog (LOG_ERR, \"Out of ptys\");\n\t  fatal (infd, \"Out of ptys\", 0);\n\t}\n      else\n\t{\n\t  syslog (LOG_ERR, \"forkpty: %m\");\n\t  fatal (infd, \"Forkpty\", 1);\n\t}\n    }\n\n  if (pid == 0)\n    {\n      /* Child */\n      if (infd > 2)\n\tclose (infd);\n\n      setup_tty (0, &auth_data);\n      setup_utmp (line, auth_data.hostname);\n\n      exec_login (authenticated, &auth_data);\n      fatal (infd, \"can't execute login\", 1);\n    }\n\n  /* Parent */\n  true = 1;\n  IF_NOT_ENCRYPT (ioctl (infd, FIONBIO, &true));\n  ioctl (master, FIONBIO, &true);\n  ioctl (master, TIOCPKT, &true);\n  netf = infd;\t\t\t/* Needed for cleanup() */\n  setsig (SIGCHLD, cleanup);\n  protocol (infd, master, &auth_data);\n  setsig (SIGCHLD, SIG_IGN);\n\n#ifdef SHISHI\n  if (kerberos)\n    {\n      int i;\n\n      shishi_done (auth_data.h);\n# ifdef ENCRYPTION\n      if (encrypt_io)\n\t{\n\t  shishi_key_done (auth_data.enckey);\n\t  for (i = 0; i < 2; i++)\n\t    {\n\t      shishi_crypto_close (auth_data.ivtab[i]->ctx);\n\t      free (auth_data.ivtab[i]->iv);\n\t    }\n\t}\n# endif\n    }\n#endif /* SHISHI */\n\n  cleanup (0);\n  /* NOT REACHED */\n\n  return 0;\n}",
      "lines": 128,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "do_rlogin": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1370,
        1
      ],
      "content": "int\ndo_rlogin (int infd, struct auth_data *ap)\n{\n  struct passwd *pwd;\n  int rc;\n#if defined WITH_IRUSEROK_AF || defined WITH_IRUSEROK\n  void *addrp;\n\n  switch (ap->from.ss_family)\n    {\n    case AF_INET6:\n      addrp = (void *) &((struct sockaddr_in6 *) &ap->from)->sin6_addr;\n      break;\n    case AF_INET:\n    default:\n      addrp = (void *) &((struct sockaddr_in *) &ap->from)->sin_addr;\n    }\n#endif /* WITH_IRUSEROK_AF || WITH_IRUSEROK */\n\n  getstr (infd, &ap->rusername, NULL);\t\t/* Requesting user.  */\n  getstr (infd, &ap->lusername, NULL);\t\t/* Acting user.  */\n  getstr (infd, &ap->term, \"TERM=\");\n\n  pwd = getpwnam (ap->lusername);\n  if (pwd == NULL)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"no passwd entry for %s\", ap->lusername);\n      fatal (infd, \"Permission denied\", 0);\n    }\n  if (!allow_root && pwd->pw_uid == 0)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"root logins are not permitted\");\n      fatal (infd, \"Permission denied\", 0);\n    }\n\n#ifdef WITH_PAM\n  rc = do_pam_check (infd, ap, \"rlogin\");\n  if (rc != PAM_SUCCESS)\n    return rc;\n#endif /* WITH_PAM */\n\n#if defined WITH_IRUSEROK_SA || defined WITH_IRUSEROK_AF \\\n    || defined WITH_IRUSEROK\n# ifdef WITH_IRUSEROK_SA\n  rc = iruserok_sa ((struct sockaddr *) &ap->from, ap->fromlen, 0,\n\t\t    ap->rusername, ap->lusername);\n# elif defined WITH_IRUSEROK_AF\n  rc = iruserok_af (addrp, 0, ap->rusername, ap->lusername,\n\t\t    ap->from.ss_family);\n# else /* WITH_IRUSEROK */\n  rc = iruserok (addrp, 0, ap->rusername, ap->lusername);\n# endif /* WITH_IRUSEROK_SA || WITH_IRUSEROK_AF || WITH_IRUSEROK */\n  if (rc)\n    syslog (LOG_ERR | LOG_AUTH,\n\t    \"iruserok failed: rusername=%s, lusername=%s\",\n\t    ap->rusername, ap->lusername);\n#elif defined WITH_RUSEROK_AF || defined WITH_RUSEROK\n# ifdef WITH_RUSEROK_AF\n  rc = ruserok_af (ap->hostaddr, 0, ap->rusername, ap->lusername,\n\t\t   ap->from.ss_family);\n# else /* WITH_RUSEROK */\n  rc = ruserok (ap->hostaddr, 0, ap->rusername, ap->lusername);\n# endif /* WITH_RUSEROK_AF || WITH_RUSEROK */\n  if (rc)\n    syslog (LOG_ERR | LOG_AUTH,\n\t    \"ruserok failed: rusername=%s, lusername=%s\",\n\t    ap->rusername, ap->lusername);\n#else /* !WITH_IRUSEROK* && !WITH_RUSEROK* */\n#error Unable to use mandatory iruserok/ruserok.  This should not happen.\n#endif /* !WITH_IRUSEROK* && !WITH_RUSEROK* */\n\n  return rc;\n}",
      "lines": 73,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "do_krb_login": {
      "start_point": [
        1373,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "int\ndo_krb_login (int infd, struct auth_data *ap, const char **err_msg)\n{\n# if defined SHISHI\n  int rc = SHISHI_VERIFY_FAILED;\n# else /* KERBEROS */\n  int rc = 1;\n# endif\n\n  *err_msg = NULL;\n# if defined KRB5\n  if (kerberos == AUTH_KERBEROS_5)\n    rc = do_krb5_login (infd, ap, err_msg);\n# elif defined SHISHI\n  if (kerberos == AUTH_KERBEROS_SHISHI)\n    rc = do_shishi_login (infd, ap, err_msg);\n# else\n  rc = do_krb4_login (infd, ap, err_msg);\n# endif\n\n  if (rc && !*err_msg)\n    *err_msg = kerberos_error_string (rc);\n\n  return rc;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "do_krb4_login": {
      "start_point": [
        1400,
        0
      ],
      "end_point": [
        1473,
        1
      ],
      "content": "int\ndo_krb4_login (int infd, struct auth_data *ap, const char **err_msg)\n{\n  int rc;\n  char instance[INST_SZ], version[VERSION_SZ];\n  long authopts = 0L;\t\t/* !mutual */\n  struct sockaddr_in faddr;\n  unsigned char auth_buf[sizeof (AUTH_DAT)];\n  unsigned char tick_buf[sizeof (KTEXT_ST)];\n  Key_schedule schedule;\n  AUTH_DAT *kdata;\n  KTEXT ticket;\n  struct passwd *pwd;\n\n  kdata = (AUTH_DAT *) auth_buf;\n  ticket = (KTEXT) tick_buf;\n\n  instance[0] = '*';\n  instance[1] = '\\0';\n\n#  ifdef ENCRYPTION\n  if (encrypt_io)\n    {\n      rc = sizeof faddr;\n      if (getsockname (0, (struct sockaddr *) &faddr, &rc))\n\t{\n\t  *err_msg = \"getsockname failed\";\n\t  syslog (LOG_ERR, \"getsockname failed: %m\");\n\t  return 1;\n\t}\n      authopts = KOPT_DO_MUTUAL;\n      rc = krb_recvauth (authopts, 0,\n\t\t\t ticket, \"rcmd\",\n\t\t\t instance, &ap->from, &faddr,\n\t\t\t kdata, \"\", schedule, version);\n      des_set_key (kdata->session, schedule);\n\n    }\n  else\n#  endif\n    rc = krb_recvauth (authopts, 0,\n\t\t       ticket, \"rcmd\",\n\t\t       instance, &ap->from, NULL, kdata, \"\", NULL, version);\n\n  if (rc != KSUCCESS)\n    return 1;\n\n  getstr (infd, &ap->lusername, NULL);\n  /* get the \"cmd\" in the rcmd protocol */\n  getstr (infd, &ap->term, \"TERM=\");\n\n  pwd = getpwnam (ap->lusername);\n  if (pwd == NULL)\n    {\n      *err_msg = \"getpwnam failed\";\n      syslog (LOG_ERR | LOG_AUTH, \"getpwnam failed: %m\");\n      return 1;\n    }\n  /* returns nonzero for no access */\n  if (kuserok (kdata, ap->lusername) != 0)\n    return 1;\n\n  if (pwd->pw_uid == 0)\n    syslog (LOG_INFO | LOG_AUTH,\n\t    \"ROOT Kerberos login from %s.%s@%s on %s\\n\",\n\t    kdata->pname, kdata->pinst, kdata->prealm, ap->hostname);\n  else\n    syslog (LOG_INFO | LOG_AUTH,\n\t    \"%s Kerberos login from %s.%s@%s on %s\\n\",\n\t    pwd->pw_name,\n\t    kdata->pname, kdata->pinst, kdata->prealm, ap->hostname);\n\n  return 0;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "do_krb5_login": {
      "start_point": [
        1477,
        0
      ],
      "end_point": [
        1600,
        1
      ],
      "content": "int\ndo_krb5_login (int infd, struct auth_data *ap, const char **err_msg)\n{\n  krb5_auth_context auth_ctx = NULL;\n  krb5_error_code status;\n  krb5_data inbuf;\n  krb5_data version;\n  krb5_authenticator *authenticator;\n  krb5_principal server;\n  krb5_rcache rcache;\n  krb5_keyblock *key;\n  krb5_ticket *ticket;\n  struct sockaddr_in laddr;\n  int len;\n  struct passwd *pwd;\n\n  status = krb5_init_context (&ap->context);\n  if (status)\n    {\n      syslog (LOG_ERR, \"Error initializing krb5: %s\",\n\t      error_message (status));\n      return status;\n    }\n\n  if (servername && *servername)\n    {\n      status = krb5_parse_name (ap->context, servername, &server);\n      if (status)\n\t{\n\t  syslog (LOG_ERR, \"Invalid principal '%s': %s\",\n\t\t  servername, error_message (status));\n\t  return status;\n\t}\n\n      /* A realm name missing in `servername' has been augmented\n       * by krb5_parse_name(), so setting it is always harmless.\n       */\n      status = krb5_set_default_realm (ap->context,\n\t\t\t\t       krb5_princ_realm (ap->context,\n\t\t\t\t\t\t\t server)->data);\n      krb5_free_principal (ap->context, server);\n      if (status)\n\t{\n\t  syslog (LOG_ERR, \"Setting krb5 realm: %s\",\n\t\t  error_message (status));\n\t  return status;\n\t}\n    }\n\n  if ((status = krb5_auth_con_init (ap->context, &auth_ctx))\n      || (status = krb5_auth_con_genaddrs (ap->context, auth_ctx, infd,\n\t\t\t\t\t   KRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR))\n      || (status = krb5_auth_con_getrcache (ap->context, auth_ctx, &rcache)))\n    return status;\n\n  if (!rcache)\n    {\n      status = krb5_sname_to_principal (ap->context, 0, 0, KRB5_NT_SRV_HST,\n\t\t\t\t\t&server);\n      if (status)\n\treturn status;\n\n      status = krb5_get_server_rcache (ap->context,\n\t\t\t\t       krb5_princ_component (ap->context,\n\t\t\t\t\t\t\t     server, 0),\n\t\t\t\t       &rcache);\n      krb5_free_principal (ap->context, server);\n\n      if (status)\n\treturn status;\n\n      status = krb5_auth_con_setrcache (ap->context, auth_ctx, rcache);\n      if (status)\n\treturn status;\n    }\n\n  len = sizeof (laddr);\n  if (getsockname (infd, (struct sockaddr *) &laddr, &len))\n    return errno;\n\n  status = krb5_recvauth (ap->context, &auth_ctx, &infd, NULL, 0,\n\t\t\t  0, ap->keytab, &ticket);\n  if (status)\n    return status;\n\n  status = krb5_auth_con_getauthenticator (ap->context, auth_ctx,\n\t\t\t\t\t   &authenticator);\n  if (status)\n    return status;\n\n  getstr (infd, &ap->lusername, NULL);\n  getstr (infd, &ap->term, \"TERM=\");\n\n  pwd = getpwnam (ap->lusername);\n  if (pwd == NULL)\n    {\n      *err_msg = \"getpwnam failed\";\n      syslog (LOG_ERR | LOG_AUTH, \"getpwnam failed: %m\");\n      return 1;\n    }\n\n  getstr (infd, &ap->rusername, NULL);\n\n  status = krb5_copy_principal (ap->context, ticket->enc_part2->client,\n\t\t\t\t&ap->client);\n  if (status)\n    return status;\n\n  /*OK:: */\n  if (ap->client && !krb5_kuserok (ap->context, ap->client, ap->lusername))\n    return 1;\n\n  ap->rprincipal = NULL;\n\n  krb5_unparse_name (ap->context, ap->client, &ap->rprincipal);\n\n  syslog (LOG_INFO | LOG_AUTH,\n\t  \"%sKerberos V login from %s on %s\\n\",\n\t  (pwd->pw_uid == 0) ? \"ROOT \" : \"\",\n\t  ap->rprincipal ? ap->rprincipal : ap->rusername,\n\t  ap->hostname);\n\n  return 0;\n}",
      "lines": 124,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "do_shishi_login": {
      "start_point": [
        1605,
        0
      ],
      "end_point": [
        1774,
        1
      ],
      "content": "int\ndo_shishi_login (int infd, struct auth_data *ad, const char **err_msg)\n{\n  int rc;\n  int error = 0;\n  int keylen, keytype;\n  struct passwd *pwd = NULL;\n  int cksumtype;\n  char *cksum;\n  char *compcksum;\n  size_t compcksumlen, cksumlen = 30;\n  char cksumdata[100];\n  struct sockaddr_storage sock;\n  socklen_t socklen = sizeof (sock);\n\n#  ifdef ENCRYPTION\n  rc = get_auth (infd, &ad->h, &ad->ap, &ad->enckey, err_msg, &ad->protocol,\n\t\t &cksumtype, &cksum, &cksumlen, servername);\n#  else\n  rc = get_auth (infd, &ad->h, &ad->ap, NULL, err_msg, &ad->protocol,\n\t\t &cksumtype, &cksum, &cksumlen, servername);\n#  endif\n  if (rc != SHISHI_OK)\n    return rc;\n\n#  ifdef ENCRYPTION\n  /* init IV */\n  if (encrypt_io)\n    {\n      int i;\n\n      ad->ivtab[0] = &ad->iv1;\n      ad->ivtab[1] = &ad->iv2;\n\n      keytype = shishi_key_type (ad->enckey);\n      keylen = shishi_cipher_blocksize (keytype);\n\n      for (i = 0; i < 2; i++)\n\t{\n\t  ad->ivtab[i]->ivlen = keylen;\n\n\t  switch (keytype)\n\t    {\n\t    case SHISHI_DES_CBC_CRC:\n\t    case SHISHI_DES_CBC_MD4:\n\t    case SHISHI_DES_CBC_MD5:\n\t    case SHISHI_DES_CBC_NONE:\n\t    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t      ad->ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t      ad->ivtab[i]->iv = xmalloc (ad->ivtab[i]->ivlen);\n\t      memset (ad->ivtab[i]->iv, i, ad->ivtab[i]->ivlen);\n\t      ad->ivtab[i]->ctx =\n\t\tshishi_crypto (ad->h, ad->enckey, ad->ivtab[i]->keyusage,\n\t\t\t       shishi_key_type (ad->enckey), ad->ivtab[i]->iv,\n\t\t\t       ad->ivtab[i]->ivlen);\n\t      break;\n\t    case SHISHI_ARCFOUR_HMAC:\n\t    case SHISHI_ARCFOUR_HMAC_EXP:\n\t      ad->ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES + 6 - 4 * i;\n\t      ad->ivtab[i]->ctx =\n\t\tshishi_crypto (ad->h, ad->enckey, ad->ivtab[i]->keyusage,\n\t\t\t       shishi_key_type (ad->enckey), NULL, 0);\n\t      break;\n\t    default:\n\t      ad->ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES + 6 - 4 * i;\n\t      ad->ivtab[i]->iv = xmalloc (ad->ivtab[i]->ivlen);\n\t      memset (ad->ivtab[i]->iv, 0, ad->ivtab[i]->ivlen);\n\t      if (ad->protocol == 2)\n\t\tad->ivtab[i]->ctx =\n\t\t  shishi_crypto (ad->h, ad->enckey, ad->ivtab[i]->keyusage,\n\t\t\t\t shishi_key_type (ad->enckey),\n\t\t\t\t ad->ivtab[i]->iv, ad->ivtab[i]->ivlen);\n\t    }\n\t}\n    }\n#  endif /* ENCRYPTION */\n\n  getstr (infd, &ad->lusername, NULL);\t\t/* Acting user.  */\n  getstr (infd, &ad->term, \"TERM=\");\n  getstr (infd, &ad->rusername, NULL);\t\t/* Requesting user.  */\n\n  rc = read (infd, &error, sizeof (int));\t/* XXX: not protocol */\n  if ((rc != sizeof (int)) || error)\n    {\n      *err_msg = \"Authentication exchange failed.\";\n      free (cksum);\n      return EXIT_FAILURE;\n    }\n\n  pwd = getpwnam (ad->lusername);\n  if (pwd == NULL)\n    {\n      *err_msg = \"getpwnam failed\";\n      free (cksum);\n      syslog (LOG_ERR | LOG_AUTH, \"getpwnam failed: %m\");\n      return 1;\n    }\n  if (!allow_root && pwd->pw_uid == 0)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"root logins are not permitted\");\n      fatal (infd, \"Permission denied\", 0);\n    }\n\n  /* verify checksum */\n\n  if (getsockname (infd, (struct sockaddr *) &sock, &socklen) < 0)\n    {\n      syslog (LOG_ERR, \"Can't get sock name\");\n      fatal (infd, \"Can't get sockname\", 1);\n    }\n\n  snprintf (cksumdata, sizeof (cksumdata), \"%u:%s%s\",\n\t    (sock.ss_family == AF_INET6)\n\t      ? ntohs (((struct sockaddr_in6 *) &sock)->sin6_port)\n\t      : ntohs (((struct sockaddr_in *) &sock)->sin_port),\n\t    ad->term + 5, ad->lusername);\n  rc = shishi_checksum (ad->h, ad->enckey, 0, cksumtype, cksumdata,\n\t\t\tstrlen (cksumdata), &compcksum, &compcksumlen);\n  if (rc != SHISHI_OK\n      || compcksumlen != cksumlen\n      || memcmp (compcksum, cksum, cksumlen) != 0)\n    {\n      *err_msg = \"Authentication exchange failed.\";\n      syslog (LOG_ERR, \"checksum verify failed: %s\", shishi_error (ad->h));\n      free (cksum);\n      free (compcksum);\n      return rc;\n    }\n\n  free (cksum);\n  free (compcksum);\n\n  rc = shishi_authorized_p (ad->h, shishi_ap_tkt (ad->ap), ad->lusername);\n  if (!rc)\n    {\n      syslog (LOG_ERR | LOG_AUTH,\n\t      \"User %s@%s is not authorized to log in as: %s.\",\n\t      ad->rusername, ad->hostname, ad->lusername);\n      shishi_ap_done (ad->ap);\n      rlogind_error (infd, 0, \"Failed to get authorized as `%s'.\\n\",\n\t\t     ad->lusername);\n      return rc;\n    }\n\n  rc = shishi_encticketpart_clientrealm (ad->h,\n\t\t\tshishi_tkt_encticketpart (shishi_ap_tkt (ad->ap)),\n\t\t\t&ad->rprincipal, NULL);\n  if (rc != SHISHI_OK)\n    ad->rprincipal = NULL;\n\n  shishi_ap_done (ad->ap);\n\n#  ifdef WITH_PAM\n  rc = do_pam_check (infd, ad, \"krlogin\");\n  if (rc != PAM_SUCCESS)\n    {\n      *err_msg = \"Permission denied\";\n      return rc;\n    }\n#  endif /* WITH_PAM */\n\n  syslog (LOG_INFO | LOG_AUTH,\n\t  \"Kerberos V %slogin from %s on %s as `%s'.\\n\",\n\t  ENCRYPT_IO ? \"encrypted \" : \"\",\n\t  ad->rprincipal ? ad->rprincipal : ad->rusername,\n\t  ad->hostname,\n\t  ad->lusername);\n\n  return SHISHI_OK;\n}",
      "lines": 170,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "getstr": {
      "start_point": [
        1780,
        0
      ],
      "end_point": [
        1831,
        1
      ],
      "content": "void\ngetstr (int infd, char **ptr, const char *prefix)\n{\n  char c;\n  char *buf;\n  int pos;\n  int size = BUFFER_SIZE;\n\n  if (prefix)\n    {\n      int len = strlen (prefix);\n\n      if (size < len + 1)\n\tsize = len + 1;\n    }\n\n  buf = malloc (size);\n  if (!buf)\n    {\n      syslog (LOG_ERR, \"not enough memory\");\n      exit (EXIT_FAILURE);\n    }\n\n  pos = 0;\n  if (prefix)\n    {\n      strcpy (buf, prefix);\n      pos += strlen (buf);\n    }\n\n  do\n    {\n      if (read (infd, &c, 1) != 1)\n\t{\n\t  syslog (LOG_ERR, \"read error: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n      if (pos == size)\n\t{\n\t  size += BUFFER_SIZE;\n\t  buf = realloc (buf, size);\n\t  if (!buf)\n\t    {\n\t      syslog (LOG_ERR, \"not enough memory\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n      buf[pos++] = c;\n    }\n  while (c != 0);\n  *ptr = buf;\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "protocol": {
      "start_point": [
        1849,
        0
      ],
      "end_point": [
        2046,
        1
      ],
      "content": "void\nprotocol (int f, int p, struct auth_data *ap)\n{\n  char fibuf[BUFLEN], *pbp = NULL, *fbp = NULL;\n  int pcc = 0, fcc = 0;\n  int cc, n;\n  unsigned int nfd;\n  char cntl;\n\n#ifndef SHISHI\n  (void) ap;\t\t/* Silence warning.  */\n#endif\n  /*\n   * Must ignore SIGTTOU, otherwise we'll stop\n   * when we try and set slave pty's window shape\n   * (our controlling tty is the master pty).\n   */\n  setsig (SIGTTOU, SIG_IGN);\n#ifdef SHISHI\n  if (kerberos && (ap->protocol == 2))\n    {\n      ENC_WRITE (n, f, oobdata_new, 5, ap);\n    }\n  else\n#endif\n    send (f, oobdata, 1, MSG_OOB);\t/* indicate new rlogin */\n  if (f > p)\n    nfd = f + 1;\n  else\n    nfd = p + 1;\n  if (nfd > FD_SETSIZE)\n    {\n      syslog (LOG_ERR, \"select mask too small, increase FD_SETSIZE\");\n      fatal (f, \"internal error (select mask too small)\", 0);\n    }\n\n  while (1)\n    {\n      fd_set ibits, obits, ebits, *omask;\n\n      FD_ZERO (&ebits);\n      FD_ZERO (&ibits);\n      FD_ZERO (&obits);\n      omask = (fd_set *) NULL;\n\n      if (fcc)\n\t{\n\t  FD_SET (p, &obits);\n\t  omask = &obits;\n\t}\n      else\n\tFD_SET (f, &ibits);\n\n      if (pcc >= 0)\n\t{\n\t  if (pcc)\n\t    {\n\t      FD_SET (f, &obits);\n\t      omask = &obits;\n\t    }\n\t  else\n\t    FD_SET (p, &ibits);\n\t}\n\n      FD_SET (p, &ebits);\n\n      n = select (nfd, &ibits, omask, &ebits, 0);\n      if (n < 0)\n\t{\n\t  if (errno == EINTR)\n\t    continue;\n\t  fatal (f, \"select\", 1);\n\t}\n      if (n == 0)\n\t{\n\t  /* shouldn't happen... */\n\t  sleep (5);\n\t  continue;\n\t}\n\n      if (FD_ISSET (p, &ebits))\n\t{\n\t  cc = read (p, &cntl, 1);\n\t  if (cc == 1 && pkcontrol (cntl))\n\t    {\n\t      cntl |= oobdata[0];\n\t      send (f, &cntl, 1, MSG_OOB);\n\t      if (cntl & TIOCPKT_FLUSHWRITE)\n\t\t{\n\t\t  pcc = 0;\n\t\t  FD_CLR (p, &ibits);\n\t\t}\n\t    }\n\t}\n\n      if (FD_ISSET (f, &ibits))\n\t{\n\t  ENC_READ (fcc, f, fibuf, sizeof (fibuf), ap);\n\n\t  if (fcc < 0 && errno == EWOULDBLOCK)\n\t    fcc = 0;\n\t  else\n\t    {\n\t      register char *cp;\n\t      int left;\n\n\t      if (fcc <= 0)\n\t\tbreak;\n\t      fbp = fibuf;\n\n\t      for (cp = fibuf; cp < fibuf + fcc - 1; cp++)\n\t\tif (cp[0] == magic[0] && cp[1] == magic[1])\n\t\t  {\n\t\t    int len;\n\n\t\t    left = fcc - (cp - fibuf);\n\t\t    len = control (p, cp, left);\n\t\t    if (len)\n\t\t      {\n\t\t\tleft -= len;\n\t\t\tif (left > 0)\n\t\t\t  memmove (cp, cp + len, left);\n\t\t\tfcc -= len;\n\t\t\tcp--;\n\t\t      }\n\t\t  }\n\t      FD_SET (p, &obits);\t/* try write */\n\t    }\n\t}\n\n      if (FD_ISSET (p, &obits) && fcc > 0)\n\t{\n\t  cc = write (p, fbp, fcc);\n\t  if (cc > 0)\n\t    {\n\t      fcc -= cc;\n\t      fbp += cc;\n\t    }\n\t}\n\n      if (FD_ISSET (p, &ibits))\n\t{\n\t  char dbuf[BUFLEN + 1];\n\n\t  pcc = read (p, dbuf, sizeof dbuf);\n\n\t  pbp = dbuf;\n\t  if (pcc < 0)\n\t    {\n\t      if (errno == EWOULDBLOCK)\n\t\tpcc = 0;\n\t      else\n\t\tbreak;\n\t    }\n\t  else if (pcc == 0)\n\t    {\n\t      break;\n\t    }\n\t  else if (dbuf[0] == 0)\n\t    {\n\t      pbp++;\n\t      pcc--;\n\t      IF_NOT_ENCRYPT (FD_SET (f, &obits));\t/* try write */\n\t    }\n\t  else\n\t    {\n\t      if (pkcontrol (dbuf[0]))\n\t\t{\n\t\t  dbuf[0] |= oobdata[0];\n\t\t  send (f, &dbuf[0], 1, MSG_OOB);\n\t\t}\n\t      pcc = 0;\n\t    }\n\t}\n\n      if ((FD_ISSET (f, &obits)) && pcc > 0)\n\t{\n\t  ENC_WRITE (cc, f, pbp, pcc, ap);\n\n\t  if (cc < 0 && errno == EWOULDBLOCK)\n\t    {\n\t      /*\n\t       * This happens when we try write after read\n\t       * from p, but some old kernels balk at large\n\t       * writes even when select returns true.\n\t       */\n\t      if (!FD_ISSET (p, &ibits))\n\t\tsleep (5);\n\t      continue;\n\t    }\n\t  if (cc > 0)\n\t    {\n\t      pcc -= cc;\n\t      pbp += cc;\n\t    }\n\t}\n    }\n}",
      "lines": 198,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "control": {
      "start_point": [
        2051,
        0
      ],
      "end_point": [
        2066,
        1
      ],
      "content": "int\ncontrol (int pty, char *cp, size_t n)\n{\n  struct winsize w;\n\n  if (n < 4 + sizeof (w) || cp[2] != 's' || cp[3] != 's')\n    return (0);\n  oobdata[0] &= ~TIOCPKT_WINDOW;\t/* we know he heard */\n  memmove (&w, cp + 4, sizeof w);\n  w.ws_row = ntohs (w.ws_row);\n  w.ws_col = ntohs (w.ws_col);\n  w.ws_xpixel = ntohs (w.ws_xpixel);\n  w.ws_ypixel = ntohs (w.ws_ypixel);\n  ioctl (pty, TIOCSWINSZ, &w);\n  return (4 + sizeof w);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "cleanup": {
      "start_point": [
        2068,
        0
      ],
      "end_point": [
        2097,
        1
      ],
      "content": "void\ncleanup (int signo)\n{\n  int status = EXIT_FAILURE;\n  char *p;\n\n  if (signo == SIGCHLD)\n    {\n      (void) waitpid ((pid_t) -1, &status, WNOHANG);\n\n      status = WEXITSTATUS (status);\n    }\n\n  p = line + sizeof (PATH_TTY_PFX) - 1;\n#if !defined HAVE_LOGOUT || !defined HAVE_LOGWTMP\n  utmp_logout (p);\n  chmod (line, 0644);\n  chown (line, 0, 0);\n#else\n  if (logout (p))\n    logwtmp (p, \"\", \"\");\n  chmod (line, 0666);\n  chown (line, 0, 0);\n  *p = 'p';\n  chmod (line, 0666);\n  chown (line, 0, 0);\n#endif\n  shutdown (netf, 2);\n  exit (status);\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "in_local_domain": {
      "start_point": [
        2099,
        0
      ],
      "end_point": [
        2105,
        1
      ],
      "content": "int\nin_local_domain (char *hostname)\n{\n  char *p = topdomain (hostname, local_dot_count);\n\n  return p && strcasecmp (p, local_domain_name) == 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "topdomain": {
      "start_point": [
        2107,
        0
      ],
      "end_point": [
        2119,
        1
      ],
      "content": "char *\ntopdomain (char *name, int max_dots)\n{\n  char *p;\n  int dot_count = 0;\n\n  for (p = name + strlen (name) - 1; p >= name; p--)\n    {\n      if (*p == '.' && ++dot_count == max_dots)\n\treturn p + 1;\n    }\n  return name;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "char",
        "*\ntopdomain (char *name, int max_dots)",
        "*"
      ]
    },
    "rlogind_error": {
      "start_point": [
        2121,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "void\nrlogind_error (int f, int syserr, const char *msg, ...)\n{\n  int len;\n  char buf[BUFSIZ], buf2[BUFSIZ], *bp = buf;\n  va_list ap;\n  va_start (ap, msg);\n\n  /*\n   * Error message proper, with variadic parts.\n   */\n  vsnprintf (buf2, sizeof (buf2) - 1, msg, ap);\n  va_end (ap);\n\n  /*\n   * Prepend binary one to message if we haven't sent\n   * the magic null as confirmation.\n   */\n  if (!confirmed)\n    *bp++ = '\\01';\t\t/* error indicator */\n  if (syserr)\n    snprintf (bp, sizeof buf - (bp - buf),\n\t      \"rlogind: %s: %s.\\r\\n\", buf2, strerror (errno));\n  else\n    snprintf (bp, sizeof buf - (bp - buf), \"rlogind: %s\\r\\n\", buf2);\n\n  len = strlen (bp);\n  write (f, buf, bp + len - buf);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fatal": {
      "start_point": [
        2151,
        0
      ],
      "end_point": [
        2161,
        1
      ],
      "content": "void\nfatal (int f, const char *msg, int syserr)\n{\n  rlogind_error (f, syserr, (msg && *msg) ? msg : \"unspecified error\");\n#ifdef WITH_PAM\n  if (pam_handle)\n    pam_end (pam_handle, pam_rc);\n#endif\n\n  exit (EXIT_FAILURE);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "do_pam_check": {
      "start_point": [
        2164,
        0
      ],
      "end_point": [
        2284,
        1
      ],
      "content": "int\ndo_pam_check (int infd, struct auth_data *ap, const char *service)\n{\n  char *user;\n  struct passwd *pwd;\n\n  pam_rc = pam_start (service, ap->lusername, &pam_conv, &pam_handle);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_RHOST, ap->hostname);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_RUSER, ap->rusername);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_TTY, service);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_get_item (pam_handle, PAM_USER, (const void **) &user);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      if (pam_handle)\n\t{\n\t  pam_end (pam_handle, pam_rc);\n\t  pam_handle = NULL;\n\t}\n\n      /* Failed set-up is deemed serious.  Abort!  */\n      syslog (LOG_ERR | LOG_AUTH, \"PAM set-up failed.\");\n      fatal (infd, \"Permission denied\", 0);\n    }\n\n  pam_rc = pam_authenticate (pam_handle, PAM_SILENT);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_ABORT:\n\t  /* Serious enough to merit immediate abortion.  */\n\t  pam_end (pam_handle, pam_rc);\n\t  syslog (LOG_ERR | LOG_AUTH, \"PAM authentication said PAM_ABORT.\");\n\t  exit (EXIT_FAILURE);\n\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t  pam_rc = pam_chauthtok (pam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\t  if (pam_rc == PAM_SUCCESS)\n\t    pam_rc = pam_authenticate (pam_handle, PAM_SILENT);\n\t  break;\n\n\tdefault:\n\t  break;\t\t\t/* Non-zero status.  */\n\t}\n    }\n\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_NOTICE | LOG_AUTH,\n\t      \"PAM authentication of '%s' from %s(%s): %s\",\n\t      user, ap->hostname, ap->hostaddr,\n\t      pam_strerror (pam_handle, pam_rc));\n      pam_end (pam_handle, pam_rc);\n      pam_handle = NULL;\n\n      return pam_rc;\n    }\n\n  pam_rc = pam_acct_mgmt (pam_handle, PAM_SILENT);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t  pam_rc = pam_chauthtok (pam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\t  if (pam_rc == PAM_SUCCESS)\n\t    pam_rc = pam_acct_mgmt (pam_handle, PAM_SILENT);\n\t  break;\n\n\tcase PAM_ACCT_EXPIRED:\n\tcase PAM_AUTH_ERR:\n\tcase PAM_PERM_DENIED:\n\tcase PAM_USER_UNKNOWN:\n\tdefault:\n\t  break;\t\t\t/* Non-zero status.  */\n\t}\n    }\n\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_INFO | LOG_AUTH,\n\t      \"PAM accounting of '%s' from %s(%s): %s\",\n\t      user, ap->hostname, ap->hostaddr,\n\t      pam_strerror (pam_handle, pam_rc));\n      pam_end (pam_handle, pam_rc);\n      pam_handle = NULL;\n\n      return pam_rc;\n    }\n\n  /* Renew client information, since the PAM stack may have\n   * mapped the request onto another identity.\n   */\n  pam_rc = pam_get_item (pam_handle, PAM_USER, (const void **) &user);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_NOTICE | LOG_AUTH, \"pam_get_item(PAM_USER): %s\",\n\t      pam_strerror (pam_handle, pam_rc));\n      user = \"<invalid>\";\n    }\n\n  pwd = getpwnam (user);\n  free (ap->lusername);\n  ap->lusername = xstrdup (user);\n\n  if (pwd == NULL)\n    {\n      syslog (LOG_INFO | LOG_AUTH, \"%s@%s as %s: unknown login.\",\n\t      ap->rusername, ap->hostname, ap->lusername);\n      pam_rc = PAM_AUTH_ERR;\t\t/* Non-zero status.  */\n    }\n\n  pam_end (pam_handle, pam_rc);\t\t/* PAM access is complete.  */\n  pam_handle = NULL;\n\n  return pam_rc;\n}",
      "lines": 121,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rlogin_conv": {
      "start_point": [
        2289,
        0
      ],
      "end_point": [
        2330,
        1
      ],
      "content": "static int\nrlogin_conv (int num, const struct pam_message **pam_msg,\n\t     struct pam_response **pam_resp,\n\t     void *data _GL_UNUSED_PARAMETER)\n{\n  struct pam_response *resp;\n\n  /* Reject composite calls at the time being.  */\n  if (num <= 0 || num > 1)\n    return PAM_CONV_ERR;\n\n  /* Ensure an empty response.  */\n  *pam_resp = NULL;\n\n  switch ((*pam_msg)->msg_style)\n    {\n    case PAM_PROMPT_ECHO_OFF:\n      /* Return an empty password.  */\n      resp = (struct pam_response *) malloc (sizeof (*resp));\n      if (!resp)\n\treturn PAM_BUF_ERR;\n      resp->resp_retcode = 0;\n      resp->resp = strdup (\"\");\n      if (!resp->resp)\n\t{\n\t  free (resp);\n\t  return PAM_BUF_ERR;\n\t}\n      syslog (LOG_NOTICE | LOG_AUTH, \"PAM message \\\"%s\\\".\",\n\t      (*pam_msg)->msg);\n      *pam_resp = resp;\n      return PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:\t\t/* Would break protocol.  */\n    case PAM_ERROR_MSG:\t\t/* Likewise.  */\n    case PAM_PROMPT_ECHO_ON:\t/* Interactivity is not supported.  */\n    default:\n      return PAM_CONV_ERR;\n    }\n  return PAM_CONV_ERR;\t\t/* Never reached.  */\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rsh.c": {
    "parse_opt": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n#if defined WITH_ORCMD_AF || defined WITH_RCMD_AF || defined SHISHI\n    case '4':\n      family = AF_INET;\n      break;\n    case '6':\n      family = AF_INET6;\n      break;\n#endif\n    case 'L':\t\t/* -8Lew are ignored to allow rlogin aliases */\n    case 'e':\n    case 'w':\n    case '8':\n      break;\n\n    case 'd':\n      debug_option = 1;\n      break;\n\n    case 'l':\n      user = arg;\n      break;\n\n#if defined KRB5 || defined SHISHI\n    case 'K':\n      use_kerberos = 0;\n      break;\n\n    case 'k':\n      dest_realm = arg;\n      break;\n\n# ifdef ENCRYPTION\n    case 'x':\n      doencrypt = 1;\n      break;\n# endif\n#endif /* KRB5 || SHISHI */\n\n    case 'n':\n      null_input_option = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 54,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n  struct passwd *pw;\n  struct servent *sp;\n  sigset_t sigs, osigs;\n  int asrsh, rem;\n#if defined KRB5 || defined SHISHI\n  int krb_errno;\n#endif\n  pid_t pid = 0;\n  uid_t uid;\n  char *args, *host;\n\n  set_program_name (argv[0]);\n\n  asrsh = 0;\n  host = user = NULL;\n\n  /* If called as something other than \"rsh\", use it as the host name */\n  {\n    char *p = strrchr (argv[0], '/');\n    if (p)\n      ++p;\n    else\n      p = argv[0];\n    if (strcmp (p, \"rsh\"))\n      host = p;\n    else\n      asrsh = 1;\n  }\n\n  /* Parse command line */\n  iu_argp_init (\"rsh\", default_program_authors);\n  argp_parse (&argp, argc, argv, ARGP_IN_ORDER, &index, NULL);\n\n  if (index < argc)\n    host = argv[index++];\n\n  /* To few args.  */\n  if (!host)\n    error (EXIT_FAILURE, 0, \"host not specified\");\n\n  /* If no further arguments, must have been called as rlogin. */\n  if (!argv[index])\n    {\n      if (asrsh)\n\t*argv = (char *) \"rlogin\";\n      seteuid (getuid ());\n      setuid (getuid ());\n      execv (PATH_RLOGIN, argv);\n      error (EXIT_FAILURE, errno, \"cannot execute %s\", PATH_RLOGIN);\n    }\n\n  argc -= index;\n  argv += index;\n\n  uid = getuid ();\n  pw = getpwuid (uid);\n  if (!pw)\n    error (EXIT_FAILURE, 0, \"unknown user id\");\n\n  /* Accept user1@host format, though \"-l user2\" overrides user1 */\n  {\n    char *p = strchr (host, '@');\n    if (p)\n      {\n\t*p = '\\0';\n\tif (!user && p > host)\n\t  user = host;\n\thost = p + 1;\n\tif (*host == '\\0')\n\t  error (EXIT_FAILURE, 0, \"empty host name\");\n      }\n  }\n\n#if defined KRB5 || defined SHISHI\n# ifdef ENCRYPTION\n  /* -x turns off -n */\n  if (doencrypt)\n    null_input_option = 0;\n# endif\n#endif\n\n  args = copyargs (argv);\n\n  sp = NULL;\n#if defined KRB5 || defined SHISHI\n  if (use_kerberos)\n    {\n      sp = getservbyname (\"kshell\", \"tcp\");\n      if (sp == NULL)\n\t{\n\t  use_kerberos = 0;\n\t  warning (\"can't get entry for %s/tcp service\", \"kshell\");\n\t}\n    }\n#endif\n  if (sp == NULL)\n    sp = getservbyname (\"shell\", \"tcp\");\n  if (sp == NULL)\n    error (EXIT_FAILURE, 0, \"shell/tcp: unknown service\");\n\n#if defined KRB5\n  if (use_kerberos)\n    {\n      rem = krb5_init_context (&ctx);\n      if (rem)\n\terror (EXIT_FAILURE, errno, \"Error initializing krb5\");\n    }\n#endif /* KRB5 */\n\n#if defined KRB5 || defined SHISHI\ntry_connect:\n  if (use_kerberos)\n    {\n# if defined KRB5\n      struct hostent *hp;\n\n      /* Get fully qualify hostname for realm determination.  */\n      hp = gethostbyname (host);\n      if (hp != NULL && !(host = strdup (hp->h_name)))\n\terror (EXIT_FAILURE, errno, \"strdup\");\n\n      rem = 0;\n      krb_errno = 0;\n\n      if (dest_realm == NULL)\n\t{\n\t  krb_errno = krb5_sname_to_principal (ctx, host, SERVICE,\n\t\t\t\t\t       KRB5_NT_SRV_HST,\n\t\t\t\t\t       &server);\n\t  if (krb_errno)\n\t    warning (\"cannot assign principal to host %s\", host);\n\t  else\n\t    dest_realm = krb5_principal_get_realm (ctx, server);\n\t}\n# elif defined SHISHI\n      rem = SHISHI_OK;\n      krb_errno = 0;\n# endif\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n\t  int i;\n#  if defined KRB5 || defined SHISHI\n\t  char *term;\n\n\t  term = xmalloc (strlen (args) + 4);\n\t  strcpy (term, \"-x \");\n\t  strcat (term, args);\n\n#   ifdef SHISHI\n\t  rem = krcmd_mutual (&h, &host, sp->s_port, &user, term, &rfd2,\n\t\t\t      dest_realm, &enckey, family);\n#   else /* KRB5 && !SHISHI */\n\t  rem = krcmd_mutual (&ctx, &host, sp->s_port, &user, args,\n\t\t\t      &rfd2, dest_realm, &keyblock);\n#   endif\n\t  krb_errno = errno;\n\t  free (term);\n\n#   ifdef SHISHI\n\t  if (rem > 0)\n\t    {\n\t      keytype = shishi_key_type (enckey);\n\t      keylen = shishi_cipher_blocksize (keytype);\n\n\t      ivtab[0] = &iv1;\n\t      ivtab[1] = &iv2;\n\t      ivtab[2] = &iv3;\n\t      ivtab[3] = &iv4;\n\n\t      for (i = 0; i < 4; i++)\n\t\t{\n\t\t  ivtab[i]->ivlen = keylen;\n\n\t\t  switch (keytype)\n\t\t    {\n\t\t    case SHISHI_DES_CBC_CRC:\n\t\t    case SHISHI_DES_CBC_MD4:\n\t\t    case SHISHI_DES_CBC_MD5:\n\t\t    case SHISHI_DES_CBC_NONE:\n\t\t    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t\t      ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv,\n\t\t\t      2 * i + 1 * (i < 2) - 4 * (i >= 2),\n\t\t\t      ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t      break;\n\t\t    case SHISHI_ARCFOUR_HMAC:\n\t\t    case SHISHI_ARCFOUR_HMAC_EXP:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), NULL, 0);\n\t\t      break;\n\t\t    default:\n\t\t      ivtab[i]->keyusage =\n\t\t\tSHISHI_KEYUSAGE_KCMD_DES + 2 + 4 * i;\n\t\t      ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t      memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey), ivtab[i]->iv,\n\t\t\t\t       ivtab[i]->ivlen);\n\t\t    }\n\t\t}\n\t    }\n#   endif /* SHISHI */\n#  endif /* KRB5 || SHISHI */\n\t}\n      else\n# endif /* ENCRYPTION */\n\t{\n# if defined SHISHI\n\t  rem = krcmd (&h, &host, sp->s_port, &user, args, &rfd2,\n\t\t       dest_realm, family);\n# else /* KRB5 && !SHISHI */\n\t  rem = krcmd (&ctx, &host, sp->s_port, &user, args,\n\t\t       &rfd2, dest_realm);\n# endif /* KRB5 */\n\t  krb_errno = errno;\n\t}\n\n# ifdef KRB5\n      /* No more use of dest_realm.  */\n      krb5_free_principal (ctx, server);\n# endif\n\n      if (rem < 0)\n\t{\n\t  use_kerberos = 0;\n\t  if (krb_errno == ECONNREFUSED)\n\t    warning (\"remote host doesn't support Kerberos\");\n\t  else if (krb_errno == ENOENT)\n\t    error (EXIT_FAILURE, 0, \"Can't provide Kerberos auth data.\");\n\t  else\n\t    error (EXIT_FAILURE, 0, \"Kerberos authentication failed.\");\n\n\t  sp = getservbyname (\"shell\", \"tcp\");\n\t  if (sp == NULL)\n\t    error (EXIT_FAILURE, 0, \"shell/tcp: unknown service\");\n\t  goto try_connect;\n\t}\n    }\n  else\n    {\n      char *p = strchr (host, '/');\n\n      if (!user)\n\tuser = pw->pw_name;\n      if (doencrypt)\n\terror (EXIT_FAILURE, 0, \"the -x flag requires Kerberos authentication\");\n      if (p)\n\thost = ++p;\t/* Skip prefix like `host/'.  */\n\n# ifdef WITH_ORCMD_AF\n      rem = orcmd_af (&host, sp->s_port, pw->pw_name, user, args, &rfd2, family);\n# elif defined WITH_RCMD_AF\n      rem = rcmd_af (&host, sp->s_port, pw->pw_name, user, args, &rfd2, family);\n# elif defined WITH_ORCMD\n      rem = orcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n      rem = rcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);\n# endif\n    }\n#else /* !KRB5 && !SHISHI */\n  if (!user)\n    user = pw->pw_name;\n# ifdef WITH_ORCMD_AF\n  rem = orcmd_af (&host, sp->s_port, pw->pw_name, user, args, &rfd2, family);\n# elif defined WITH_RCMD_AF\n  rem = rcmd_af (&host, sp->s_port, pw->pw_name, user, args, &rfd2, family);\n# elif defined WITH_ORCMD\n  rem = orcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);\n# else /* !WITH_ORCMD_AF && !WITH_RCMD_AF && !WITH_ORCMD */\n  rem = rcmd (&host, sp->s_port, pw->pw_name, user, args, &rfd2);\n# endif\n#endif /* !KRB5 && !SHISHI */\n\n  if (rem < 0)\n    {\n      /* rcmd() provides its own error messages,\n       * but we add a vital addition, caused by\n       * insufficient capabilites.\n       */\n      if (errno == EACCES)\n\terror (EXIT_FAILURE, 0, \"No access to privileged ports.\");\n\n      exit (EXIT_FAILURE);\n    }\n\n  if (rfd2 < 0)\n    error (EXIT_FAILURE, 0, \"can't establish stderr\");\n\n  if (debug_option)\n    {\n      int one = 1;\n      if (setsockopt (rem, SOL_SOCKET, SO_DEBUG, (char *) &one,\n\t\t      sizeof one) < 0)\n\terror (0, errno, \"setsockopt DEBUG (ignored)\");\n      if (setsockopt (rfd2, SOL_SOCKET, SO_DEBUG, (char *) &one,\n\t\t      sizeof one) < 0)\n\terror (0, errno, \"setsockopt DEBUG (ignored)\");\n    }\n\n  seteuid (uid);\n  setuid (uid);\n#ifdef HAVE_SIGACTION\n  sigemptyset (&sigs);\n  sigaddset (&sigs, SIGINT);\n  sigaddset (&sigs, SIGQUIT);\n  sigaddset (&sigs, SIGTERM);\n  sigprocmask (SIG_BLOCK, &sigs, &osigs);\n#else\n  sigs = sigmask (SIGINT) | sigmask (SIGQUIT) | sigmask (SIGTERM);\n  osigs = sigblock (sigs);\n#endif\n  if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n    signal (SIGINT, sendsig);\n  if (signal (SIGQUIT, SIG_IGN) != SIG_IGN)\n    signal (SIGQUIT, sendsig);\n  if (signal (SIGTERM, SIG_IGN) != SIG_IGN)\n    signal (SIGTERM, sendsig);\n\n  if (null_input_option)\n    /* Nothing from stdin will be written to the socket,\n     * but we still expect response from the server.\n     */\n    shutdown (rem, SHUT_WR);\n  else\n    {\n      pid = fork ();\n      if (pid < 0)\n\terror (EXIT_FAILURE, errno, \"fork\");\n    }\n\n#if defined KRB5 || defined SHISHI\n# ifdef ENCRYPTION\n  if (!doencrypt)\n# endif\n#endif\n    {\n      int one = 1;\n      ioctl (rfd2, FIONBIO, &one);\n      ioctl (rem, FIONBIO, &one);\n    }\n\n  talk (null_input_option, &osigs, pid, rem);\n\n#ifdef SHISHI\n  if (use_kerberos)\n    {\n      int i;\n\n      shishi_done (h);\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n\t  shishi_key_done (enckey);\n\t  for (i = 0; i < 4; i++)\n\t    {\n\t      shishi_crypto_close (ivtab[i]->ctx);\n\t      free (ivtab[i]->iv);\n\t    }\n\t}\n# endif\n    }\n#endif\n\n  if (!null_input_option)\n    kill (pid, SIGKILL);\n  return 0;\n}",
      "lines": 382,
      "depth": 27,
      "decorators": [
        "int"
      ]
    },
    "talk": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "void\ntalk (int null_input_option, sigset_t * osigs, pid_t pid, int rem)\n{\n  int cc, wc;\n  fd_set readfrom, ready, rembits;\n  char *bp, buf[BUFSIZ];\n#ifdef HAVE_SIGACTION\n  struct sigaction sa;\n#endif\n\n  if (!null_input_option && pid == 0)\n    {\n      close (rfd2);\n\n    reread:\n      errno = 0;\n      cc = read (STDIN_FILENO, buf, sizeof buf);\n      if (cc <= 0)\n\tgoto done;\n      bp = buf;\n\n    rewrite:\n      FD_ZERO (&rembits);\n      FD_SET (rem, &rembits);\n      if (select (rem + 1, 0, &rembits, 0, 0) < 0)\n\t{\n\t  if (errno != EINTR)\n\t    error (EXIT_FAILURE, errno, \"select\");\n\t  goto rewrite;\n\t}\n      if (!FD_ISSET (rem, &rembits))\n\tgoto rewrite;\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n      if (doencrypt)\n\twc = des_write (rem, bp, cc);\n      else\n# elif defined(SHISHI)\n      if (doencrypt)\n\twriteenc (h, rem, bp, cc, &wc, &iv3, enckey, 2);\n      else\n# endif\n#endif\n\twc = write (rem, bp, cc);\n      if (wc < 0)\n\t{\n\t  if (errno == EWOULDBLOCK)\n\t    goto rewrite;\n\t  goto done;\n\t}\n      bp += wc;\n      cc -= wc;\n      if (cc == 0)\n\tgoto reread;\n      goto rewrite;\n    done:\n      shutdown (rem, SHUT_WR);\n      exit (EXIT_SUCCESS);\n    }\n\n#ifdef HAVE_SIGACTION\n  sigprocmask (SIG_SETMASK, osigs, NULL);\n#else /* !HAVE_SIGACTION */\n  sigsetmask (*osigs);\n#endif\n\n  /* The access to SIGPIPE is neeeded to kill the child process\n   * in an orderly fashion, for example when a command line\n   * pipe fails.  Otherwise the child lives on eternally.\n   */\n#ifdef HAVE_SIGACTION\n  sigemptyset (&sa.sa_mask);\n  sa.sa_flags = SA_RESTART;\n  sa.sa_handler = sigpipe;\n  (void) sigaction (SIGPIPE, &sa, NULL);\n#else /* !HAVE_SIGACTION */\n  signal (SIGPIPE, sigpipe);\n#endif\n\n  FD_ZERO (&readfrom);\n  FD_SET (rfd2, &readfrom);\n  FD_SET (rem, &readfrom);\n  do\n    {\n      int maxfd = rem;\n      if (rfd2 > maxfd)\n\tmaxfd = rfd2;\n      ready = readfrom;\n      if (select (maxfd + 1, &ready, 0, 0, 0) < 0)\n\t{\n\t  if (errno != EINTR)\n\t    error (EXIT_FAILURE, errno, \"select\");\n\t  continue;\n\t}\n      if (FD_ISSET (rfd2, &ready))\n\t{\n\t  errno = 0;\n#ifdef KERBEROS\n# ifdef ENCRYPTION\n\t  if (doencrypt)\n\t    cc = des_read (rfd2, buf, sizeof buf);\n\t  else\n# endif\n#elif defined(SHISHI) && defined(ENCRYPTION)\n\t  if (doencrypt)\n\t    readenc (h, rfd2, buf, &cc, &iv2, enckey, 2);\n\t  else\n#endif\n\t    cc = read (rfd2, buf, sizeof buf);\n\t  if (cc <= 0)\n\t    {\n\t      if (errno != EWOULDBLOCK)\n\t\tFD_CLR (rfd2, &readfrom);\n\t    }\n\t  else\n\t    write (STDERR_FILENO, buf, cc);\n\t}\n      if (FD_ISSET (rem, &ready))\n\t{\n\t  errno = 0;\n#ifdef KERBEROS\n# ifdef ENCRYPTION\n\t  if (doencrypt)\n\t    cc = des_read (rem, buf, sizeof buf);\n\t  else\n# endif\n#elif defined(SHISHI) && defined(ENCRYPTION)\n\t  if (doencrypt)\n\t    readenc (h, rem, buf, &cc, &iv1, enckey, 2);\n\t  else\n#endif\n\t    cc = read (rem, buf, sizeof buf);\n\t  if (cc <= 0)\n\t    {\n\t      if (errno != EWOULDBLOCK)\n\t\tFD_CLR (rem, &readfrom);\n\t    }\n\t  else\n\t    write (STDOUT_FILENO, buf, cc);\n\t}\n    }\n  while ((FD_ISSET (rfd2, &readfrom) || FD_ISSET (rem, &readfrom))\n\t && !end_of_pipe);\n}",
      "lines": 144,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "sendsig": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "void\nsendsig (int sig)\n{\n  char signo;\n\n#if defined SHISHI && defined ENCRYPTION\n  int n;\n#endif\n\n  signo = sig;\n#ifdef KERBEROS\n# ifdef ENCRYPTION\n  if (doencrypt)\n    des_write (rfd2, &signo, 1);\n  else\n# endif\n#elif defined(SHISHI) && defined (ENCRYPTION)\n  if (doencrypt)\n    writeenc (h, rfd2, &signo, 1, &n, &iv4, enckey, 2);\n  else\n#endif\n\n    write (rfd2, &signo, 1);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sigpipe": {
      "start_point": [
        784,
        0
      ],
      "end_point": [
        788,
        1
      ],
      "content": "void\nsigpipe (int sig _GL_UNUSED_PARAMETER)\n{\n  ++end_of_pipe;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "warning": {
      "start_point": [
        791,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "void\nwarning (const char *fmt, ...)\n{\n  va_list ap;\n\n  fprintf (stderr, \"%s: warning, using standard rsh: \", program_name);\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fprintf (stderr, \".\\n\");\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "copyargs": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "char *\ncopyargs (char **argv)\n{\n  int cc;\n  char **ap, *args, *p;\n\n  cc = 0;\n  for (ap = argv; *ap; ++ap)\n    cc += strlen (*ap) + 1;\n  args = malloc ((u_int) cc);\n  if (!args)\n    error (EXIT_FAILURE, errno, \"copyargs\");\n  for (p = args, ap = argv; *ap; ++ap)\n    {\n      strcpy (p, *ap);\n      for (p = strcpy (p, *ap); *p; ++p);\n      if (ap[1])\n\t*p++ = ' ';\n    }\n  return args;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "char",
        "*\ncopyargs (char **argv)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/rshd.c": {
    "parse_opt": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'a':\n      check_all = 1;\n      break;\n\n#ifdef HAVE___CHECK_RHOSTS_FILE\n    case 'l':\n      __check_rhosts_file = 0;\t/* don't check .rhosts file */\n      break;\n#endif\n\n    case 'n':\n      keepalive = 0;\t/* don't enable SO_KEEPALIVE */\n      break;\n\n    case 'r':\n      reverse_required = 1;\n      break;\n\n#if defined KERBEROS || defined SHISHI\n    case 'k':\n      use_kerberos = 1;\n      break;\n\n    case 'v':\n      vacuous = 1;\n      break;\n\n# ifdef ENCRYPTION\n    case 'x':\n      doencrypt = 1;\n      break;\n# endif\n\n    case 'S':\n      servername = arg;\n      break;\n#endif /* KERBEROS || SHISHI */\n\n    case 'L':\n      log_success = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 53,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n  struct linger linger;\n  int on = 1;\n  socklen_t fromlen;\n  struct sockaddr_storage from;\n  int sockfd;\n\n  set_program_name (argv[0]);\n  iu_argp_init (\"rshd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  openlog (\"rshd\", LOG_PID | LOG_ODELAY, LOG_DAEMON);\n\n  argc -= index;\n  if (argc > 0)\n    {\n      syslog (LOG_ERR, \"%d extra arguments\", argc);\n      exit (EXIT_FAILURE);\n    }\n\n#if defined KERBEROS || defined SHISHI\n  if (use_kerberos && vacuous)\n    {\n      syslog (LOG_ERR, \"only one of -k and -v allowed\");\n      exit (EXIT_FAILURE);\n    }\n# ifdef ENCRYPTION\n  if (doencrypt && !use_kerberos)\n    {\n      syslog (LOG_ERR, \"-k is required for -x\");\n      exit (EXIT_FAILURE);\n    }\n# endif /* ENCRYPTION */\n#endif /* KERBEROS || SHISHI */\n\n  /*\n   * We assume we're invoked by inetd, so the socket that the\n   * connection is on, is open on descriptors 0, 1 and 2.\n   * STD{IN,OUT,ERR}_FILENO.\n   * We may in the future make it standalone for certain platform.\n   */\n  sockfd = STDIN_FILENO;\n\n  /*\n   * First get the Internet address of the client process.\n   * This is requored for all the authentication we perform.\n   */\n\n  fromlen = sizeof from;\n  if (getpeername (sockfd, (struct sockaddr *) &from, &fromlen) < 0)\n    {\n      syslog (LOG_ERR, \"getpeername: %m\");\n      _exit (EXIT_FAILURE);\n    }\n\n  /* Set the socket options: SO_KEEPALIVE and SO_LINGER */\n  if (keepalive && setsockopt (sockfd, SOL_SOCKET, SO_KEEPALIVE, (char *) &on,\n\t\t\t       sizeof on) < 0)\n    syslog (LOG_WARNING, \"setsockopt (SO_KEEPALIVE): %m\");\n  linger.l_onoff = 1;\n  linger.l_linger = 60;\t\t/* XXX */\n  if (setsockopt (sockfd, SOL_SOCKET, SO_LINGER, (char *) &linger,\n\t\t  sizeof linger) < 0)\n    syslog (LOG_WARNING, \"setsockopt (SO_LINGER): %m\");\n  doit (sockfd, (struct sockaddr *) &from, fromlen);\n  return 0;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "doit": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        1963,
        1
      ],
      "content": "void\ndoit (int sockfd, struct sockaddr *fromp, socklen_t fromlen)\n{\n#ifdef HAVE___RCMD_ERRSTR\n  extern char *__rcmd_errstr;\t/* syslog hook from libc/net/rcmd.c. */\n#endif\n#ifdef HAVE_GETPWNAM_R\n  char *pwbuf;\n  int ret, pwbuflen;\n  struct passwd *pwd, pwstor;\n#else /* !HAVE_GETPWNAM_R */\n  struct passwd *pwd;\n#endif\n  unsigned short port, inport;\n  fd_set ready, readfrom;\n  int cc, nfd, pv[2], pid, s = sockfd;\n  int rc, one = 1;\n  char portstr[8], addrstr[INET6_ADDRSTRLEN];\n#if HAVE_DECL_GETNAMEINFO\n  char addrname[NI_MAXHOST];\n#else /* !HAVE_DECL_GETNAMEINFO */\n  struct hostent *hp;\n#endif\n  const char *hostname, *errorstr, *errorhost = NULL;\n  char *cp, sig, buf[BUFSIZ];\n  char *cmdbuf, *locuser, *remuser;\n  char *rprincipal = NULL;\n#if defined WITH_IRUSEROK_AF && !defined WITH_PAM\n  void * fromaddrp;\t/* Pointer to remote address.  */\n#endif\n#ifdef WITH_PAM\n  char *service;\n#endif\n\n#ifdef\tKERBEROS\n# ifdef KRB4\n  AUTH_DAT *kdata = (AUTH_DAT *) NULL;\n  KTEXT ticket = (KTEXT) NULL;\n  char instance[INST_SZ], version[VERSION_SIZE];\n# elif defined KRB5\t/* !KRB4 */\n  krb5_context context;\n  krb5_auth_context auth_ctx;\n  krb5_authenticator *author;\n  krb5_principal client;\n  krb5_rcache rcache;\n  krb5_keytab keytab;\n  krb5_ticket *ticket;\n# endif /* KRB4 || KRB5 */\n  struct sockaddr_in fromaddr;\n  long authopts;\n  int pv1[2], pv2[2];\n  fd_set wready, writeto;\n#elif defined SHISHI /* !KERBEROS */\n  int n;\n  int pv1[2], pv2[2];\n  fd_set wready, writeto;\n  int keytype, keylen;\n  int cksumtype;\n  size_t cksumlen;\n  char *cksum = NULL;\n#endif /* KERBEROS || SHISHI */\n\n#ifdef KERBEROS\n  memcpy (&fromaddr, fromp, sizeof (fromaddr));\n#endif\n\n#ifdef HAVE_GETPWNAM_R\n  pwbuflen = sysconf (_SC_GETPW_R_SIZE_MAX);\n  if (pwbuflen <= 0)\n    pwbuflen = 1024;\t/* Guessing only.  */\n\n  pwbuf = xmalloc (pwbuflen);\n#endif /* HAVE_GETPWNAM_R */\n\n  signal (SIGINT, SIG_DFL);\n  signal (SIGQUIT, SIG_DFL);\n  signal (SIGTERM, SIG_DFL);\n#ifdef DEBUG\n  {\n    int t = open (PATH_TTY, O_RDWR);\n    if (t >= 0)\n      {\n\tioctl (t, TIOCNOTTY, (char *) 0);\n\tclose (t);\n      }\n  }\n#endif\n\n#if HAVE_DECL_GETNAMEINFO\n  rc = getnameinfo (fromp, fromlen,\n\t\t    addrstr, sizeof (addrstr),\n\t\t    portstr, sizeof (portstr),\n\t\t    NI_NUMERICHOST | NI_NUMERICSERV);\n  if (rc != 0)\n    {\n      syslog (LOG_WARNING, \"getnameinfo: %s\", gai_strerror (rc));\n      exit (EXIT_FAILURE);\n    }\n  inport = atoi (portstr);\n#else /* !HAVE_DECL_GETNAMEINFO */\n  strncpy (addrstr, inet_ntoa (((struct sockaddr_in *) fromp)->sin_addr),\n\t   sizeof (addrstr));\n  inport = ntohs (((struct sockaddr_in *) fromp)->sin_port);\n  snprintf (portstr, sizeof (portstr), \"%u\", inport);\n#endif\n\n  /* Verify that the client's address is an Internet adress. */\n#ifdef KERBEROS\n  if (fromp->sa_family != AF_INET)\n    {\n      syslog (LOG_ERR, \"malformed originating address (af %d)\\n\",\n\t      fromp->sa_family);\n      exit (EXIT_FAILURE);\n    }\n#endif /* KERBEROS */\n#ifdef IP_OPTIONS\n  {\n    unsigned char optbuf[BUFSIZ / 3], *cp;\n    char lbuf[BUFSIZ], *lp;\n    socklen_t optsize = sizeof (optbuf);\n    int ipproto;\n    struct protoent *ip;\n\n    ip = getprotobyname (\"ip\");\n    if (ip != NULL)\n      ipproto = ip->p_proto;\n    else\n      ipproto = IPPROTO_IP;\n    if (!getsockopt (sockfd, ipproto, IP_OPTIONS, (char *) optbuf,\n\t\t     &optsize) && optsize != 0)\n      {\n\tlp = lbuf;\n\t/* The client has set IP options.  This isn't allowed.\n\t * Use syslog() to record the fact.  Only the option\n\t * types are printed, not their contents.\n\t */\n\tfor (cp = optbuf; optsize > 0; )\n\t  {\n\t    sprintf (lp, \" %2.2x\", *cp);\n\t    lp += 3;\n\n\t    if (*cp == IPOPT_SSRR || *cp == IPOPT_LSRR)\n\t      {\n\t\t/* Already the TCP handshake suffices for\n\t\t * a man-in-the-middle attack vector.\n\t\t */\n\t\tsyslog (LOG_NOTICE,\n\t\t\t\"Discarding connection from %s with set source routing\",\n\t\t\taddrstr);\n\t\texit (EXIT_FAILURE);\n\t      }\n\t    if (*cp == IPOPT_EOL)\n\t      break;\n\t    if (*cp == IPOPT_NOP)\n\t      cp++, optsize--;\n\t    else\n\t      {\n\t\t/* Options using a length octet, see RFC 791.  */\n\t\tint inc = cp[1];\n\n\t\toptsize -= inc;\n\t\tcp += inc;\n\t      }\n\t  }\n\n\t/* At this point presumably harmless options are present.\n\t * Make a report about them, erase them, and continue.  */\n\tsyslog (LOG_NOTICE,\n\t\t\"Connection received from %s using IP options (erased):%s\",\n\t\taddrstr, lbuf);\n\n\t/* Turn off the options.  If this doesn't work, we quit.  */\n\tif (setsockopt (sockfd, ipproto, IP_OPTIONS,\n\t\t\t(char *) NULL, optsize) != 0)\n\t  {\n\t    syslog (LOG_ERR, \"setsockopt IP_OPTIONS NULL: %m\");\n\t    exit (EXIT_FAILURE);\n\t  }\n      }\n  }\n#endif\n\n  /* Verify that the client's address was bound to a reserved port */\n#if defined KERBEROS || defined SHISHI\n  if (!use_kerberos)\n#endif\n    if (inport >= IPPORT_RESERVED || inport < IPPORT_RESERVED / 2)\n      {\n\tsyslog (LOG_NOTICE | LOG_AUTH,\n\t\t\"Connection from %s on illegal port %s\",\n\t\taddrstr, portstr);\n\texit (EXIT_FAILURE);\n      }\n\n  /* Read the ASCII string specifying the secondary port# from\n   * the socket.  We set a timer of 60 seconds to do this read,\n   * else we assume something is wrong.  If the client doesn't want\n   * the secondary port, they just send the terminating null byte.\n   */\n  alarm (60);\n  port = 0;\n  for (;;)\n    {\n      char c;\n\n      cc = read (sockfd, &c, 1);\n      if (cc != 1)\n\t{\n\t  if (cc < 0)\n\t    syslog (LOG_NOTICE, \"read: %m\");\n\t  shutdown (sockfd, SHUT_RDWR);\n\t  exit (EXIT_FAILURE);\n\t}\n      /* null byte terminates the string */\n      if (c == 0)\n\tbreak;\n      port = port * 10 + c - '0';\n    }\n\n  alarm (0);\n  if (port != 0)\n    {\n      /* If the secondary port# is non-zero, then we have to\n       * connect to that port (which the client has already\n       * created and is listening on).  The secondary port#\n       * that the client tells us to connect to has also to be\n       * a reserved port#.  Also, our end of this secondary\n       * connection has also to have a reserved TCP port bound\n       * to it, plus.\n       */\n      int lport = IPPORT_RESERVED - 1;\n#ifdef WITH_RRESVPORT_AF\n      s = rresvport_af (&lport, fromp->sa_family);\n#else\n      s = rresvport (&lport);\n#endif\n      if (s < 0)\n\t{\n\t  syslog (LOG_ERR, \"can't get stderr port: %m\");\n\t  exit (EXIT_FAILURE);\n\t}\n#if defined KERBEROS || defined SHISHI\n      if (!use_kerberos)\n#endif\n\tif (port >= IPPORT_RESERVED || port < IPPORT_RESERVED / 2)\n\t  {\n\t    syslog (LOG_ERR, \"Second port outside reserved range.\");\n\t    exit (EXIT_FAILURE);\n\t  }\n      /* Use the fromp structure that we already have available.\n       * The 32-bit Internet address is obviously that of the\n       * client; just change the port# to the one specified\n       * as secondary port by the client.\n       */\n      switch (fromp->sa_family)\n\t{\n\tcase AF_INET6:\n\t  ((struct sockaddr_in6 *) fromp)->sin6_port = htons (port);\n\t  break;\n\tcase AF_INET:\n\tdefault:\n\t  ((struct sockaddr_in *) fromp)->sin_port = htons (port);\n\t}\n      if (connect (s, fromp, fromlen) < 0)\n\t{\n\t  syslog (LOG_INFO, \"connect second port %d: %m\", port);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n\n#if defined KERBEROS || defined SHISHI\n  if (vacuous)\n    {\n      rshd_error (\"rshd: remote host requires Kerberos authentication\\n\");\n      exit (EXIT_FAILURE);\n    }\n#endif /* KERBEROS || SHISHI */\n\n  /* from inetd, socket is already on 0, 1, 2 */\n  if (sockfd != STDIN_FILENO)\n    {\n      dup2 (sockfd, STDIN_FILENO);\n      dup2 (sockfd, STDOUT_FILENO);\n      dup2 (sockfd, STDERR_FILENO);\n    }\n\n  /* Get the \"name\" of the client from its Internet address.  This is\n   * used for the authentication below.\n   */\n  errorstr = NULL;\n#if HAVE_DECL_GETNAMEINFO\n  rc = getnameinfo (fromp, fromlen, addrname, sizeof (addrname),\n\t\t    NULL, 0, NI_NAMEREQD);\n  if (rc == 0)\n    {\n      hostname = addrname;\n# if defined KERBEROS || defined SHISHI\n      if (!use_kerberos)\n# endif\n\tif (check_all || local_domain (addrname))\n\t  {\n\t    struct addrinfo hints, *ai, *res;\n\n\t    errorhost = addrname;\n\t    memset (&hints, 0, sizeof (hints));\n\t    hints.ai_family = fromp->sa_family;\n\t    hints.ai_socktype = SOCK_STREAM;\n\n\t    rc = getaddrinfo (hostname, NULL, &hints, &res);\n\t    if (rc != 0)\n\t      {\n\t\tsyslog (LOG_INFO, \"Could not resolve address for %s.\",\n\t\t\thostname);\n\t\terrorstr = \"Could not resolve address for your host (%s).\\n\";\n\t\thostname = addrstr;\n\t      }\n\t    else\n\t      {\n\t\tfor (ai = res; ai; ai = ai->ai_next)\n\t\t  {\n\t\t    char astr[INET6_ADDRSTRLEN] = \"\";\n\n\t\t    if (getnameinfo (ai->ai_addr, ai->ai_addrlen,\n\t\t\t\t     astr, sizeof (astr),\n\t\t\t\t     NULL, 0, NI_NUMERICHOST))\n\t\t      continue;\n\t\t    if (!strcmp (addrstr, astr))\n\t\t      {\n\t\t\thostname = addrname;\n\t\t\tbreak;\t/* equal, OK */\n\t\t      }\n\t\t  }\n\t\tfreeaddrinfo (res);\n\t\tif (ai == NULL)\n\t\t  {\n\t\t    syslog (LOG_NOTICE,\n\t\t\t    \"Host addr %s not listed for host %s.\",\n\t\t\t    addrstr, hostname);\n\t\t    errorstr = \"Host address mismatch for %s.\\n\";\n\t\t    hostname = addrstr;\n\t\t  }\n\t      }\n\t  }\n    }\n#else /* !HAVE_DECL_GETNAMEINFO */\n  switch (fromp->sa_family)\n    {\n    case AF_INET6:\n      hp = gethostbyaddr ((void *) &((struct sockaddr_in6 *) fromp)->sin6_addr,\n\t\t\t  sizeof (struct in6_addr), fromp->sa_family);\n      break;\n    case AF_INET:\n    default:\n      hp = gethostbyaddr ((void *) &((struct sockaddr_in *) fromp)->sin_addr,\n\t\t\t  sizeof (struct in_addr), fromp->sa_family);\n    }\n  if (hp)\n    {\n      /*\n       * If name returned by gethostbyaddr is in our domain,\n       * attempt to verify that we haven't been fooled by someone\n       * in a remote net; look up the name and check that this\n       * address corresponds to the name.\n       */\n      hostname = strdup (hp->h_name);\n# if defined KERBEROS || defined SHISHI\n      if (!use_kerberos)\n# endif\n\tif (check_all || local_domain (hp->h_name))\n\t  {\n\t    char *remotehost = alloca (strlen (hostname) + 1);\n\t    if (!remotehost)\n\t      errorstr = \"Out of memory.\\n\";\n\t    else\n\t      {\n\t\tstrcpy (remotehost, hostname);\n\t\terrorhost = remotehost;\n\t\thp = gethostbyname (remotehost);\n\t\tif (hp == NULL)\n\t\t  {\n\t\t    syslog (LOG_INFO,\n\t\t\t    \"Couldn't look up address for %s.\", remotehost);\n\t\t    errorstr =\n\t\t      \"Couldn't look up address for your host (%s).\\n\";\n\t\t    hostname = addrstr;\n\t\t  }\n\t\telse\n\t\t  for (;; hp->h_addr_list++)\n\t\t    {\n\t\t      if (hp->h_addr_list[0] == NULL)\n\t\t\t{\n\t\t\t  syslog (LOG_NOTICE,\n\t\t\t\t  \"Host addr %s not listed for host %s.\",\n\t\t\t\t  addrstr, hp->h_name);\n\t\t\t  errorstr = \"Host address mismatch for %s.\\n\";\n\t\t\t  hostname = addrstr;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (!memcmp (hp->h_addr_list[0],\n\t\t\t\t   (fromp->sa_family == AF_INET6)\n\t\t\t\t   ? (void *) & ((struct sockaddr_in6 *) fromp)->sin6_addr\n\t\t\t\t   : (void *) & ((struct sockaddr_in *) fromp)->sin_addr,\n\t\t\t\t   hp->h_length))\n\t\t\t{\n\t\t\t  hostname = strdup (hp->h_name);\n\t\t\t  break;\t/* equal, OK */\n\t\t\t}\n\t\t    }\n\t      }\n\t  }\n    }\n#endif /* !HAVE_DECL_GETNAMEINFO */\n\n  else if (reverse_required)\n    {\n      syslog (LOG_NOTICE,\n\t      \"Could not resolve remote %s.\", addrstr);\n      rshd_error (\"Permission denied.\\n\");\n      exit (EXIT_FAILURE);\n    }\n  else\n    errorhost = hostname = addrstr;\n\n#ifdef KRB4\n  if (use_kerberos)\n    {\n      kdata = (AUTH_DAT *) authbuf;\n      ticket = (KTEXT) tickbuf;\n      authopts = 0L;\n      strcpy (instance, \"*\");\n      version[VERSION_SIZE - 1] = '\\0';\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n\t  struct sockaddr_in local_addr;\n\t  rc = sizeof local_addr;\n\t  if (getsockname (STDIN_FILENO,\n\t\t\t   (struct sockaddr *) &local_addr, &rc) < 0)\n\t    {\n\t      syslog (LOG_ERR, \"getsockname: %m\");\n\t      rshd_error (\"rshd: getsockname: %s\", strerror (errno));\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  authopts = KOPT_DO_MUTUAL;\n\t  rc = krb_recvauth (authopts, 0, ticket,\n\t\t\t     \"rcmd\", instance, &fromaddr,\n\t\t\t     &local_addr, kdata, \"\", schedule, version);\n\t  des_set_key (kdata->session, schedule);\n\t}\n      else\n# endif /* ENCRYPTION */\n\trc = krb_recvauth (authopts, 0, ticket, \"rcmd\",\n\t\t\t   instance, &fromaddr,\n\t\t\t   (struct sockaddr_in *) 0,\n\t\t\t   kdata, \"\", (bit_64 *) 0, version);\n      if (rc != KSUCCESS)\n\t{\n\t  rshd_error (\"Kerberos authentication failure: %s\\n\",\n\t\t      krb_err_txt[rc]);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n  else\n#elif defined KRB5\n  if (use_kerberos)\n    {\n      krb5_principal server;\n\n      /* Set up context data.  */\n      rc = krb5_init_context (&context);\n\n      if (!rc && servername && *servername)\n\t{\n\t  rc = krb5_parse_name (context, servername, &server);\n\n\t  /* A realm name missing in `servername' has been augmented\n\t   * by krb5_parse_name(), so setting it again is harmless.\n\t   */\n\t  if (!rc)\n\t    {\n\t      rc = krb5_set_default_realm (context,\n\t\t\t\t\t   krb5_princ_realm\n\t\t\t\t\t\t(context, server)->data);\n\t      krb5_free_principal (context, server);\n\t    }\n\t}\n\n      if (!rc)\n        rc = krb5_auth_con_init (context, &auth_ctx);\n      if (!rc)\n\trc = krb5_auth_con_genaddrs (context, auth_ctx, sockfd,\n\t\t\tKRB5_AUTH_CONTEXT_GENERATE_REMOTE_FULL_ADDR);\n      if (!rc)\n\trc = krb5_auth_con_getrcache (context, auth_ctx, &rcache);\n\n      if (!rc && !rcache)\n\t{\n\t  rc = krb5_sname_to_principal (context, 0, 0,\n\t\t\t\t\tKRB5_NT_SRV_HST, &server);\n\t  if (!rc)\n\t    {\n\t      krb5_data *pdata;\n\n\t      pdata = krb5_princ_component (context, server, 0);\n\n\t      rc = krb5_get_server_rcache (context, pdata, &rcache);\n\t      krb5_free_principal (context, server);\n\n\t      if (!rc)\n\t\trc = krb5_auth_con_setrcache (context, auth_ctx, rcache);\n\t    }\n\t}\n\n      if (rc)\n\t{\n\t  syslog (LOG_ERR, \"Error initializing krb5: %s\",\n\t\t  error_message (rc));\n\t  rshd_error (\"Permission denied.\\n\");\n\t  exit (EXIT_FAILURE);\n\t}\n\n# ifdef ENCRYPTION\n      if (doencrypt)\n\t{\n\t  struct sockaddr_in local_addr;\n\t  rc = sizeof local_addr;\n\t  if (getsockname (STDIN_FILENO,\n\t\t\t   (struct sockaddr *) &local_addr, &rc) < 0)\n\t    {\n\t      syslog (LOG_ERR, \"getsockname: %m\");\n\t      rshd_error (\"rshd: getsockname: %s\", strerror (errno));\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  authopts = KOPT_DO_MUTUAL;\n\t  rc = krb_recvauth (authopts, 0, ticket,\n\t\t\t     \"rcmd\", instance, &fromaddr,\n\t\t\t     &local_addr, kdata, \"\", schedule, version);\n\t  des_set_key (kdata->session, schedule);\n\t}\n      else\n# endif /* ENCRYPTION */\n\trc = krb5_recvauth (context, &auth_ctx, &sockfd, \"rcmd\",\n\t\t\t    0, 0, keytab, &ticket);\n\n      if (!rc)\n\trc = krb5_auth_con_getauthenticator (context, auth_ctx, &author);\n\n      if (!rc)\n\t{\n\t  rshd_error (\"Kerberos authentication failure: %s\\n\",\n\t\t      error_message(rc));\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n  else\n#elif defined (SHISHI)\t/* !KRB4 && !KRB5 */\n  if (use_kerberos)\n    {\n      int rc;\n      const char *err_msg;\n\n      rc = get_auth (STDIN_FILENO, &h, &ap, &enckey, &err_msg, &protocol,\n\t\t     &cksumtype, &cksum, &cksumlen, servername);\n      if (rc != SHISHI_OK)\n\t{\n\t  rshd_error (\"Kerberos authentication failure: %s\\n\",\n\t\t      (err_msg && *err_msg) ? err_msg : shishi_strerror (rc));\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n  else\n#endif /* KERBEROS || SHISHI */\n    remuser = getstr (\"remuser\");\t/* The requesting user!  */\n\n  /* Read three strings from the client. */\n  locuser = getstr (\"locuser\");\t\t/* The acting user!  */\n  cmdbuf = getstr (\"command\");\n\n#ifdef SHISHI\n  if (use_kerberos)\n    {\n      int error;\n      int rc;\n      char *compcksum;\n      size_t compcksumlen;\n      char cksumdata[100];\n      struct sockaddr_storage sock;\n      socklen_t socklen;\n\n      if (strlen (cmdbuf) >= 3)\n\tif (!strncmp (cmdbuf, \"-x \", 3))\n# ifdef ENCRYPTION\n\t  {\n\t    int i;\n\n\t    uses_encryption = 1;\n\n\t    ivtab[0] = &iv1;\n\t    ivtab[1] = &iv2;\n\t    ivtab[2] = &iv3;\n\t    ivtab[3] = &iv4;\n\n\t    keytype = shishi_key_type (enckey);\n\t    keylen = shishi_cipher_blocksize (keytype);\n\n\t    for (i = 0; i < 4; i++)\n\t      {\n\t\tivtab[i]->ivlen = keylen;\n\n\t\tswitch (keytype)\n\t\t  {\n\t\t  case SHISHI_DES_CBC_CRC:\n\t\t  case SHISHI_DES_CBC_MD4:\n\t\t  case SHISHI_DES_CBC_MD5:\n\t\t  case SHISHI_DES_CBC_NONE:\n\t\t  case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n\t\t    ivtab[i]->keyusage = SHISHI_KEYUSAGE_KCMD_DES;\n\t\t    ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t    memset (ivtab[i]->iv, 2 * i - 3 * (i >= 2),\n\t\t\t    ivtab[i]->ivlen);\n\t\t    ivtab[i]->ctx =\n\t\t      shishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t     shishi_key_type (enckey),\n\t\t\t\t     ivtab[i]->iv, ivtab[i]->ivlen);\n\t\t    break;\n\n\t\t  case SHISHI_ARCFOUR_HMAC:\n\t\t  case SHISHI_ARCFOUR_HMAC_EXP:\n\t\t    ivtab[i]->keyusage =\n\t\t      SHISHI_KEYUSAGE_KCMD_DES + 4 * (i < 2) + 2 + 2 * (i % 2);\n\t\t    ivtab[i]->ctx =\n\t\t      shishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t     shishi_key_type (enckey), NULL, 0);\n\t\t    break;\n\n\t\t  default:\n\t\t    ivtab[i]->keyusage =\n\t\t      SHISHI_KEYUSAGE_KCMD_DES + 4 * (i < 2) + 2 + 2 * (i % 2);\n\t\t    ivtab[i]->iv = xmalloc (ivtab[i]->ivlen);\n\t\t    memset (ivtab[i]->iv, 0, ivtab[i]->ivlen);\n\t\t    if (protocol == 2)\n\t\t      ivtab[i]->ctx =\n\t\t\tshishi_crypto (h, enckey, ivtab[i]->keyusage,\n\t\t\t\t       shishi_key_type (enckey),\n\t\t\t\t       ivtab[i]->iv, ivtab[i]->ivlen);\n\t\t  }\n\t      }\n\t  }\n# else /* !ENCRYPTION */\n\t  {\n\t    shishi_ap_done (ap);\n\t    rshd_error (\"Encrypted sessions are not supported.\\n\");\n\t    exit (EXIT_FAILURE);\n\t  }\n# endif /* ENCRYPTION */\n\n    remuser = getstr (\"remuser\");\t/* The requesting user!  */\n\n    rc = read (STDIN_FILENO, &error, sizeof (int)); /* XXX: not protocol */\n    if ((rc != sizeof (int)) || error)\n      exit (EXIT_FAILURE);\n\n    /* verify checksum */\n    {\n      unsigned short pport;\n\n      socklen = sizeof (sock);\n      if (getsockname (STDIN_FILENO, (struct sockaddr *)&sock, &socklen) < 0)\n\t{\n\t  syslog (LOG_ERR, \"Can't get sock name\");\n\t  exit (EXIT_FAILURE);\n\t}\n\n      pport = (sock.ss_family == AF_INET6)\n\t      ? ((struct sockaddr_in6 *) &sock)->sin6_port\n\t      : ((struct sockaddr_in *) &sock)->sin_port;\n\n      snprintf (cksumdata, 100, \"%u:%s%s\", ntohs (pport), cmdbuf, locuser);\n    }\n\n    rc = shishi_checksum (h, enckey, 0, cksumtype,\n\t\t\t  cksumdata, strlen (cksumdata),\n\t\t\t  &compcksum, &compcksumlen);\n    if (rc != SHISHI_OK\n\t|| compcksumlen != cksumlen\n\t|| memcmp (compcksum, cksum, cksumlen) != 0)\n      {\n\t/* err_msg crash ? */\n\t/* *err_msg = \"checksum verify failed\"; */\n\tsyslog (LOG_ERR, \"checksum verify failed: %s\", shishi_error (h));\n\tfree (compcksum);\n\tshishi_ap_done (ap);\n\trshd_error (\"Authentication exchange failed.\\n\");\n\texit (EXIT_FAILURE);\n      }\n\n    if (doencrypt && !uses_encryption)\n      {\n\tsyslog (LOG_INFO, \"non-encrypted session denied from %s\", hostname);\n\tfree (compcksum);\n\tshishi_ap_done (ap);\n\trshd_error (\"Only encrypted sessions are allowed.\\n\");\n\texit (EXIT_FAILURE);\n      }\n    else\n      doencrypt = uses_encryption;\n\n    rc = shishi_authorized_p (h, shishi_ap_tkt (ap), locuser);\n    if (!rc)\n      {\n\tsyslog (LOG_AUTH | LOG_ERR,\n\t\t\"User %s@%s is not authorized to run as: %s.\",\n\t\tremuser, hostname, locuser);\n\tshishi_ap_done (ap);\n\trshd_error (\"Failed to get authorized as `%s'.\\n\", locuser);\n\texit (EXIT_FAILURE);\n      }\n\n    free (compcksum);\n\n    rc = shishi_encticketpart_clientrealm (h,\n\t\t\tshishi_tkt_encticketpart (shishi_ap_tkt (ap)),\n\t\t\t&rprincipal, NULL);\n    if (rc != SHISHI_OK)\n      rprincipal = NULL;\n\n    shishi_ap_done (ap);\n\n  }\n#elif defined KRB5\t/* !SHISHI */\n  if (use_kerberos)\n    {\n      remuser = getstr (\"remuser\");\t/* The requesting user!  */\n\n      rc = krb5_copy_principal (context, ticket->enc_part2->client,\n\t\t\t\t&client);\n      if (rc)\n\tgoto fail;\t/* FIXME: Temporary handler.  */\n\n      if (client && !krb5_kuserok (context, client, locuser))\n\tgoto fail;\t/* FIXME: Temporary handler.  */\n\n      rprincipal = NULL;\n      krb5_unparse_name (context, client, &rprincipal);\n    }\n#endif /* KRB5 || SHISHI */\n\n  /* Look up locuser in the passwd file.  The locuser has to be a\n   * valid account on this system.\n   */\n  setpwent ();\n#ifdef HAVE_GETPWNAM_R\n  ret = getpwnam_r (locuser, &pwstor, pwbuf, pwbuflen, &pwd);\n  if (ret || pwd == NULL)\n#else /* !HAVE_GETPWNAM_R */\n  pwd = getpwnam (locuser);\n  if (pwd == NULL)\n#endif /* HAVE_GETPWNAM_R */\n    {\n      syslog (LOG_INFO | LOG_AUTH, \"%s@%s as %s: unknown login. cmd='%.80s'\",\n\t      remuser, hostname, locuser, cmdbuf);\n      if (errorstr == NULL)\n\terrorstr = \"Login incorrect.\\n\";\n      goto fail;\n    }\n\n#ifdef WITH_PAM\n# if defined KERBEROS || defined SHISHI\n  if (use_kerberos)\n    service = \"krsh\";\n  else\n# endif\n    service = \"rsh\";\n\n  pam_rc = pam_start (service, locuser, &pam_conv, &pam_handle);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_RHOST, hostname);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_RUSER, remuser);\n  if (pam_rc == PAM_SUCCESS)\n    pam_rc = pam_set_item (pam_handle, PAM_TTY, service);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      errorstr = \"Try again.\\n\";\n      goto fail;\n    }\n\n  /* Checks existence of account, and more.\n   */\n  pam_rc = pam_authenticate (pam_handle, PAM_SILENT);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_ABORT:\n\t  pam_end (pam_handle, pam_rc);\n\t  exit (EXIT_FAILURE);\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t  pam_rc = pam_chauthtok (pam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\t  if (pam_rc == PAM_SUCCESS)\n\t    {\n\t      pam_rc = pam_authenticate (pam_handle, PAM_SILENT);\n\t      if (pam_rc == PAM_SUCCESS)\n\t\tbreak;\n\t    }\n\tdefault:\n\t  errorstr = \"Password incorrect.\\n\";\n\t  goto fail;\n\t}\n    }\n\n  /* Checks expiration of account, and more.\n   */\n  pam_rc = pam_acct_mgmt (pam_handle, PAM_SILENT);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      switch (pam_rc)\n\t{\n\tcase PAM_NEW_AUTHTOK_REQD:\n\t  pam_rc = pam_chauthtok (pam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\t  if (pam_rc == PAM_SUCCESS)\n\t    {\n\t      pam_rc = pam_acct_mgmt (pam_handle, PAM_SILENT);\n\t      if (pam_rc == PAM_SUCCESS)\n\t\tbreak;\n\t    }\n\tcase PAM_AUTH_ERR:\n\t  errorstr = \"Password incorrect.\\n\";\n\t  goto fail;\n\t  break;\n\tcase PAM_ACCT_EXPIRED:\n\tcase PAM_PERM_DENIED:\n\tcase PAM_USER_UNKNOWN:\n\tdefault:\n\t  errorstr = \"Permission denied.\\n\";\n\t  goto fail;\n\t  break;\n\t}\n    }\n\n  /* Renew client information, since the PAM stack may have\n   * mapped the request onto another identity.\n   */\n  free (locuser);\n  locuser = NULL;\n  pam_rc = pam_get_item (pam_handle, PAM_USER, (const void **) &locuser);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_NOTICE | LOG_AUTH, \"pam_get_item(PAM_USER): %s\",\n\t      pam_strerror (pam_handle, pam_rc));\n      /* Intentionally let `locuser' be ill defined.  */\n    }\n# ifdef HAVE_GETPWNAM_R\n  ret = getpwnam_r (locuser, &pwstor, pwbuf, pwbuflen, &pwd);\n  if (ret || pwd == NULL)\n# else /* !HAVE_GETPWNAM_R */\n  pwd = getpwnam (locuser);\n  if (pwd == NULL)\n# endif /* HAVE_GETPWNAM_R */\n    {\n      syslog (LOG_INFO | LOG_AUTH, \"%s@%s as %s: unknown login. cmd='%.80s'\",\n\t      remuser, hostname, locuser, cmdbuf);\n      errorstr = \"Login incorrect.\\n\";\n      goto fail;\n    }\n#else /* !WITH_PAM */\n  /*\n   * The account exists by a previous call to getpwnam().\n   * Is the account locked, or has it expired?\n   */\n  {\n    time_t now;\n\n# ifdef HAVE_GETSPNAM\n    struct spwd *spwd;\n\n    /*\n     * GNU/Linux, Solaris\n     *\n     * Locked account?\n     */\n    spwd = getspnam (pwd->pw_name);\n    if (!spwd)\n      {\n\tsyslog (LOG_ERR | LOG_AUTH, \"No access to encrypted password.\");\n\tif (errorstr == NULL)\n\t  errorstr = \"Login incorrect.\\n\";\n\tgoto fail;\n      }\n    else\n      {\n\t/* Locked accounts have their passwords prefixed with a blocker.  */\n\tif (!strncmp (\"!\", spwd->sp_pwdp, strlen (\"!\"))\n\t    || !strncmp (\"*LK*\", spwd->sp_pwdp, strlen (\"*OK*\")))\n\t  {\n\t    syslog (LOG_INFO | LOG_AUTH,\n\t\t    \"%s@%s as %s: account is locked. cmd='%.80s'\",\n\t\t    remuser, hostname, locuser, cmdbuf);\n\t    if (errorstr == NULL)\n\t      errorstr = \"Permission denied.\\n\";\n\t    goto fail;\n\t  }\n      }\n\n    /*\n     * Expired account?\n     */\n    time (&now);\n    if (spwd->sp_expire > 0)\n      {\n\ttime_t end_acct = DAY * spwd->sp_expire;\n\n\tif (difftime (now, end_acct) > 0)\n\t  {\n\t    syslog (LOG_INFO | LOG_AUTH,\n\t\t    \"%s@%s as %s: account is expired. cmd='%.80s'\",\n\t\t    remuser, hostname, locuser, cmdbuf);\n\t    if (errorstr == NULL)\n\t      errorstr = \"Permission denied.\\n\";\n\t    goto fail;\n\t  }\n      }\n# else /* !HAVE_GETSPNAM */\n    /*\n     * BSD systems.\n     *\n     * Locked account?\n     */\n    if (!strncmp (\"*LOCKED*\", pwd->pw_passwd, strlen (\"*LOCKED*\")))\n      {\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"%s@%s as %s: account is locked. cmd='%.80s'\",\n\t\tremuser, hostname, locuser, cmdbuf);\n\tif (errorstr == NULL)\n\t  errorstr = \"Permission denied.\\n\";\n\tgoto fail;\n      }\n\n    /*\n     * Expired account?\n     */\n#  ifdef HAVE_STRUCT_PASSWD_PW_EXPIRE\n    time (&now);\n\n    /*\n     * Negative `pw_expire' indicates on NetBSD\n     * an immediate need for change of password.\n     */\n    if (((pwd->pw_expire > 0) && (difftime (now, pwd->pw_expire) > 0))\n\t|| (pwd->pw_expire < 0))\n      {\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"%s@%s as %s: account is expired. cmd='%.80s'\",\n\t\tremuser, hostname, locuser, cmdbuf);\n\tif (errorstr == NULL)\n\t  errorstr = \"Permission denied.\\n\";\n\tgoto fail;\n      }\n#  endif /* HAVE_STRUCT_PASSWD_PW_EXPIRE */\n# endif /* !HAVE_GETSPNAM */\n  }\n\n#if defined WITH_IRUSEROK_AF\n  switch (fromp->sa_family)\n    {\n    case AF_INET6:\n      fromaddrp = (void *) &((struct sockaddr_in6 *) fromp)->sin6_addr;\n      break;\n    case AF_INET:\n    default:\n      fromaddrp = (void *) &((struct sockaddr_in *) fromp)->sin_addr;\n    }\n# endif /* !WITH_IRUSEROK_AF */\n#endif /* !WITH_PAM */\n\n#ifdef KRB4\n  if (use_kerberos)\n    {\n      if (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0')\n\t{\n\t  if (kuserok (kdata, locuser) != 0)\n\t    {\n\t      syslog (LOG_INFO | LOG_AUTH, \"Kerberos rsh denied to %s.%s@%s\",\n\t\t      kdata->pname, kdata->pinst, kdata->prealm);\n\t      rshd_error (\"Permission denied.\\n\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n    }\n  else\n#elif defined KRB5\t/* !KRB4 */\n  if (use_kerberos)\n    {\n      if (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0' && client)\n\t{\n\t  if (krb5_kuserok (context, client, locuser) != 0)\n\t    {\n\t      syslog (LOG_INFO | LOG_AUTH, \"Kerberos rsh denied to %s.%s@%s\",\n\t\t      \"kdata->pname\", \"kdata->pinst\", \"kdata->prealm\");\n\t      rshd_error (\"Permission denied.\\n\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n    }\n  else\n#elif defined(SHISHI) /* !KERBEROS */\n  if (use_kerberos)\n    {\t\t\t\t/*\n\t\t\t\t   if (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0')\n\t\t\t\t   {\n\t\t\t\t   if (kuserok (kdata, locuser) != 0)\n\t\t\t\t   {\n\t\t\t\t   syslog (LOG_INFO|LOG_AUTH, \"Kerberos rsh denied to %s.%s@%s\",\n\t\t\t\t   kdata->pname, kdata->pinst, kdata->prealm);\n\t\t\t\t   rshd_error (\"Permission denied.\\n\");\n\t\t\t\t   exit (EXIT_FAILURE);\n\t\t\t\t   }\n\t\t\t\t   } */\n    }\n  else\n#endif /* KERBEROS || SHISHI */\n\n#ifndef WITH_PAM\n# ifdef WITH_IRUSEROK_SA\n    if (errorstr || (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0'\n                     && (iruserok_sa ((void *) fromp, fromlen,\n\t\t\t\t      pwd->pw_uid == 0, remuser, locuser)) < 0))\n# elif defined WITH_IRUSEROK_AF\n    if (errorstr || (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0'\n                     && (iruserok_af (fromaddrp, pwd->pw_uid == 0,\n\t\t\t\t      remuser, locuser, fromp->sa_family)) < 0))\n# elif defined WITH_IRUSEROK\n    if (errorstr || (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0'\n                     && (iruserok (((struct sockaddr_in *) fromp)->sin_addr.s_addr,\n\t\t\t\t   pwd->pw_uid == 0, remuser, locuser)) < 0))\n# elif defined WITH_RUSEROK_AF\n    if (errorstr || (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0'\n                     && (ruserok_af (addrstr, pwd->pw_uid == 0,\n\t\t\t\t  remuser, locuser, fromp->sa_family)) < 0))\n# elif defined WITH_RUSEROK\n    if (errorstr || (pwd->pw_passwd != 0 && *pwd->pw_passwd != '\\0'\n                     && (ruserok (addrstr, pwd->pw_uid == 0,\n\t\t\t\t  remuser, locuser)) < 0))\n# else /* !WITH_IRUSEROK* && !WITH_RUSEROK* */\n# error Unable to use mandatory iruserok/ruserok.  This should not happen.\n# endif /* !WITH_IRUSEROK* && !WITH_RUSEROK* */\n#else /* WITH_PAM */\n    if (0)\t/* Wrapper for `fail' jump label.  */\n#endif /* !WITH_PAM */\n    {\n#ifdef HAVE___RCMD_ERRSTR\n      if (__rcmd_errstr)\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"%s@%s as %s: permission denied (%s). cmd='%.80s'\",\n\t\tremuser, hostname, locuser, __rcmd_errstr, cmdbuf);\n      else\n#endif /* HAVE___RCMD_ERRSTR */\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"%s@%s as %s: permission denied. cmd='%.80s'\",\n\t\tremuser, hostname, locuser, cmdbuf);\n    fail:\n#ifdef WITH_PAM\n      if (pam_handle)\n\t{\n\t  if (pam_rc != PAM_SUCCESS)\n\t    syslog (LOG_NOTICE | LOG_AUTH, \"%s@%s as %s, PAM: %s\",\n\t\t    remuser, hostname, locuser,\n\t\t    pam_strerror (pam_handle, pam_rc));\n\t  pam_end (pam_handle, pam_rc);\n\t}\n#endif /* WITH_PAM */\n      if (errorstr == NULL)\n\terrorstr = \"Permission denied.\\n\";\n      rshd_error (errorstr, errorhost);\n      exit (EXIT_FAILURE);\n    }\n\n  /* If the locuser isn't root, then check if logins are disabled. */\n  if (pwd->pw_uid && !access (PATH_NOLOGIN, F_OK))\n    {\n      rshd_error (\"Logins currently disabled.\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  /* Now write the null byte back to the client, telling it\n   * that everything is OK.\n   *\n   * Note that this means that any error message that we generate\n   * from now on (such as the perror() if the execl() fails), won't\n   * be seen by the rcmd() function, but it will be seen by the\n   * application that called rcmd() once it reads from the socket.\n   */\n  if (write (STDERR_FILENO, \"\\0\", 1) < 0)\n    {\n      rshd_error (\"Lost connection.\\n\");\n      exit (EXIT_FAILURE);\n    }\n  sent_null = 1;\n\n  if (port)\n    {\n      /* We need a secondary channel.  Here is where we create\n       * the control process that will handle this secondary\n       * channel.\n       * First create a pipe to use for communication between\n       * the parent and child, then fork.\n       */\n      if (pipe (pv) < 0)\n\t{\n\t  rshd_error (\"Can't make pipe.\\n\");\n\t  exit (EXIT_FAILURE);\n\t}\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n      if (doencrypt)\n\t{\n\t  if (pipe (pv1) < 0)\n\t    {\n\t      rshd_error (\"Can't make 2nd pipe.\\n\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  if (pipe (pv2) < 0)\n\t    {\n\t      rshd_error (\"Can't make 3rd pipe.\\n\");\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n      pid = fork ();\n      if (pid == -1)\n\t{\n\t  rshd_error (\"Can't fork; try again.\\n\");\n\t  exit (EXIT_FAILURE);\n\t}\n      if (pid)\n\t{\n\t  /* Parent process == control process.\n\t   * We: (1) read from the pipe and write to s;\n\t   *     (2) read from s and send corresponding\n\t   *         signal.\n\t   */\n#ifdef ENCRYPTION\n# if defined KERBEROS\n\t  if (doencrypt)\n\t    {\n\t      static char msg[] = SECURE_MESSAGE;\n\t      close (pv1[1]);\n\t      close (pv2[1]);\n\t      des_write (s, msg, sizeof (msg) - 1);\n\t    }\n\t  else\n# elif defined(SHISHI) /* !KERBEROS */\n\t  if (doencrypt)\n\t    {\n\t      close (pv1[1]);\n\t      close (pv2[1]);\n\t    }\n\t  else\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t    {\n\t      /* child handles the original socket */\n\t      close (STDIN_FILENO);\n\t      /* (0, 1, and 2 were from inetd */\n\t      close (STDOUT_FILENO);\n\t    }\n\t  close (STDERR_FILENO);\n\t  close (pv[1]);\t/* close write end of pipe */\n\n\t  FD_ZERO (&readfrom);\n\t  FD_SET (s, &readfrom);\n\t  FD_SET (pv[0], &readfrom);\n\t  /* set max fd + 1 for select */\n\t  if (pv[0] > s)\n\t    nfd = pv[0];\n\t  else\n\t    nfd = s;\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n\t  if (doencrypt)\n\t    {\n\t      FD_ZERO (&writeto);\n\t      FD_SET (pv2[0], &writeto);\n\t      FD_SET (pv1[0], &readfrom);\n\n\t      nfd = MAX (nfd, pv2[0]);\n\t      nfd = MAX (nfd, pv1[0]);\n\t    }\n\t  else\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t    ioctl (pv[0], FIONBIO, (char *) &one);\n\t  /* should set s nbio! */\n\t  nfd++;\n\t  do\n\t    {\n\t      ready = readfrom;\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n\t      if (doencrypt)\n\t\t{\n#  ifdef SHISHI\n\t\t  wready = readfrom;\n#  else /* KERBEROS && !SHISHI */\n\t\t  wready = writeto;\n#  endif\n\t\t  if (select (nfd, &ready, &wready, (fd_set *) 0,\n\t\t\t      (struct timeval *) 0) < 0)\n\t\t    break;\n\t\t}\n\t      else\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t      if (select (nfd, &ready, (fd_set *) 0,\n\t\t\t    (fd_set *) 0, (struct timeval *) 0) < 0)\n\t\t/* wait until there is something to read */\n\t\tbreak;\n\t      if (FD_ISSET (s, &ready))\n\t\t{\n\t\t  int ret;\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n\t\t  if (doencrypt)\n\t\t    ret = des_read (s, &sig, 1);\n\t\t  else\n# elif defined(SHISHI) /* !KERBEROS */\n\t\t  if (doencrypt)\n\t\t    readenc (h, s, &sig, &ret, &iv2, enckey, protocol);\n\t\t  else\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t\t    ret = read (s, &sig, 1);\n\t\t  if (ret <= 0)\n\t\t    FD_CLR (s, &readfrom);\n\t\t  else\n\t\t    killpg (pid, sig);\n\t\t}\n\t      if (FD_ISSET (pv[0], &ready))\n\t\t{\n\t\t  errno = 0;\n\t\t  cc = read (pv[0], buf, sizeof buf);\n\t\t  if (cc <= 0)\n\t\t    {\n\t\t      shutdown (s, SHUT_RDWR);\n\t\t      FD_CLR (pv[0], &readfrom);\n\t\t    }\n\t\t  else\n\t\t    {\n#ifdef ENCRYPTION\n# ifdef KERBEROS\n\t\t      if (doencrypt)\n\t\t\tdes_write (s, buf, cc);\n\t\t      else\n# elif defined(SHISHI) /* !KERBEROS */\n\t\t      if (doencrypt)\n\t\t\twriteenc (h, s, buf, cc, &n, &iv4, enckey, protocol);\n\t\t      else\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t\t\twrite (s, buf, cc);\n\t\t    }\n\t\t}\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n\t      if (doencrypt && FD_ISSET (pv1[0], &ready))\n\t\t{\n\t\t  errno = 0;\n\t\t  cc = read (pv1[0], buf, sizeof (buf));\n\t\t  if (cc <= 0)\n\t\t    {\n\t\t      shutdown (pv1[0], SHUT_RDWR);\n\t\t      FD_CLR (pv1[0], &readfrom);\n\t\t    }\n\t\t  else\n#  ifdef SHISHI\n\t\t    writeenc (h, STDOUT_FILENO, buf, cc, &n, &iv3, enckey,\n\t\t\t      protocol);\n#  else /* KERBEROS */\n\t\t    des_write (STDOUT_FILENO, buf, cc);\n#  endif\n\t\t}\n\n\t      if (doencrypt && FD_ISSET (pv2[0], &wready))\n\t\t{\n\t\t  errno = 0;\n#  ifdef SHISHI\n\t\t  readenc (h, STDIN_FILENO, buf, &cc, &iv1, enckey, protocol);\n#  else /* KERBEROS */\n\t\t  cc = des_read (STDIN_FILENO, buf, sizeof buf);\n#  endif\n\t\t  if (cc <= 0)\n\t\t    {\n\t\t      shutdown (pv2[0], SHUT_RDWR);\n\t\t      FD_CLR (pv2[0], &writeto);\n\t\t    }\n\t\t  else\n\t\t    write (pv2[0], buf, cc);\n\t\t}\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\t    }\n\t  while (FD_ISSET (s, &readfrom) ||\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n\t\t (doencrypt && FD_ISSET (pv1[0], &readfrom)) ||\n# endif\n#endif /* ENCRYPTION */\n\t\t FD_ISSET (pv[0], &readfrom));\n\t  /* The pipe will generate an EOF when the shell\n\t   * terminates.  The socket will terminate when the\n\t   * client process terminates.\n\t   */\n#ifdef WITH_PAM\n\t  /* The child opened the session; now it\n\t   * should be closed down properly.  */\n\t  pam_rc = pam_close_session (pam_handle, PAM_SILENT);\n\t  if (pam_rc != PAM_SUCCESS)\n\t    syslog (LOG_WARNING | LOG_AUTH, \"pam_close_session: %s\",\n\t\t    pam_strerror (pam_handle, pam_rc));\n\t  pam_rc = pam_setcred (pam_handle, PAM_SILENT | PAM_DELETE_CRED);\n\t  if (pam_rc != PAM_SUCCESS)\n\t    syslog (LOG_WARNING | LOG_AUTH, \"pam_setcred: %s\",\n\t\t    pam_strerror (pam_handle, pam_rc));\n\t  pam_end (pam_handle, pam_rc);\n#endif /* WITH_PAM */\n\n\t  exit (EXIT_SUCCESS);\n\t} /* Parent process ends.  */\n\n      close (s);\t\t/* control process handles this fd */\n      close (pv[0]);\t\t/* close read end of pipe */\n#ifdef ENCRYPTION\n# if defined KERBEROS || defined SHISHI\n      if (doencrypt)\n\t{\n\t  close (pv1[0]);\n\t  close (pv2[0]);\n\t  dup2 (pv1[1], STDOUT_FILENO);\n\t  dup2 (pv2[1], STDIN_FILENO);\n\t  close (pv1[1]);\n\t  close (pv2[1]);\n\t}\n# endif /* KERBEROS || SHISHI */\n#endif /* ENCRYPTION */\n\n#if defined SHISHI\n      if (use_kerberos)\n\t{\n\t  int i;\n\n\t  shishi_done (h);\n# ifdef ENCRYPTION\n\t  if (doencrypt)\n\t    {\n\t      shishi_key_done (enckey);\n\t      for (i = 0; i < 4; i++)\n\t\t{\n\t\t  shishi_crypto_close (ivtab[i]->ctx);\n\t\t  free (ivtab[i]->iv);\n\t\t}\n\t    }\n# endif /* ENCRYPTION */\n\t}\n\n#endif /* SHISHI */\n\n      dup2 (pv[1], STDERR_FILENO);\t/* stderr of shell has to go\n\t\t\t\t\t   pipe to control process */\n      close (pv[1]);\n    }\n#ifdef WITH_PAM\n    /* Session handling must end also in this case.  */\n  else\n    {\n      pid = fork ();\n      if (pid < 0)\n\t{\n\t  rshd_error (\"Can't fork; try again.\\n\");\n\t  exit (EXIT_FAILURE);\n\t}\n      if (pid)\n\t{\n\t  /* Parent: Wait for child and tear down\n\t   * the PAM session.  */\n\t  int status;\n\n\t  while (wait (&status) < 0 && errno == EINTR)\n\t    ;\n\n\t  pam_rc = pam_close_session (pam_handle, PAM_SILENT);\n\t  if (pam_rc != PAM_SUCCESS)\n\t    syslog (LOG_WARNING | LOG_AUTH, \"pam_close_session: %s\",\n\t\t    pam_strerror (pam_handle, pam_rc));\n\t  pam_rc = pam_setcred (pam_handle, PAM_SILENT | PAM_DELETE_CRED);\n\t  if (pam_rc != PAM_SUCCESS)\n\t    syslog (LOG_WARNING | LOG_AUTH, \"pam_setcred: %s\",\n\t\t    pam_strerror (pam_handle, pam_rc));\n\t  pam_end (pam_handle, pam_rc);\n\n\t  exit (WIFEXITED (status) ? WEXITSTATUS (status) : EXIT_FAILURE);\n\t} /* Parent process ends.  */\n    }\n#endif /* WITH_PAM */\n\n  /* Child process, with and without handler for stderr.\n   * Become a process group leader, so that the control\n   * process above can send signals to all the processes\n   * we may be the parent of.  The process group ID\n   * (the getpid() value below) equals the childpid value\n   * from the fork above.\n   */\n#ifdef HAVE_SETLOGIN\n  /* Not sufficient to call setpgid() on BSD systems.  */\n  if (setsid () < 0)\n    syslog (LOG_ERR, \"setsid() failed: %m\");\n\n  if (setlogin (pwd->pw_name) < 0)\n    syslog (LOG_ERR, \"setlogin() failed: %m\");\n#else /* !HAVE_SETLOGIN */\n  setpgid (0, getpid ());\n#endif\n\n  if (*pwd->pw_shell == '\\0')\n    pwd->pw_shell = PATH_BSHELL;\n\n  /* Set the gid, then uid to become the user specified by \"locuser\" */\n  setegid ((gid_t) pwd->pw_gid);\n  setgid ((gid_t) pwd->pw_gid);\n#ifdef HAVE_INITGROUPS\n  initgroups (pwd->pw_name, pwd->pw_gid);\t/* BSD groups */\n#endif\n\n#ifdef WITH_PAM\n  pam_rc = pam_setcred (pam_handle, PAM_SILENT | PAM_ESTABLISH_CRED);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"pam_setcred: %s\",\n\t      pam_strerror (pam_handle, pam_rc));\n      pam_rc = PAM_SUCCESS;\t/* Only report the above anomaly.  */\n    }\n  pam_rc = pam_open_session (pam_handle, PAM_SILENT);\n  if (pam_rc != PAM_SUCCESS)\n    {\n      syslog (LOG_ERR | LOG_AUTH, \"pam_open_session: %s\",\n\t      pam_strerror (pam_handle, pam_rc));\n      pam_rc = PAM_SUCCESS;\t/* Only report the above anomaly.  */\n    }\n#endif /* WITH_PAM */\n\n  setuid ((uid_t) pwd->pw_uid);\n\n  /* We'll execute the client's command in the home directory\n   * of locuser. Note, that the chdir must be executed after\n   * setuid(), otherwise it may fail on NFS mounted directories\n   * (root mapped to nobody).\n   */\n  if (chdir (pwd->pw_dir) < 0)\n    {\n      syslog (LOG_INFO | LOG_AUTH,\n\t      \"%s@%s as %s: no home directory. cmd='%.80s'\", remuser,\n\t      hostname, locuser, cmdbuf);\n      rshd_error (\"No remote directory.\\n\");\n\n      if (chdir (\"/\") < 0)\n\t{\n\t  syslog (LOG_ERR | LOG_AUTH,\n\t\t  \"%s@%s as %s: access denied to '/'\",\n\t\t  remuser, hostname, locuser);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n\n  /* Set up an initial environment for the shell that we exec() */\n  strncat (homedir, pwd->pw_dir, sizeof (homedir) - sizeof (\"HOME=\") - 1);\n  strncat (path, PATH_DEFPATH, sizeof (path) - sizeof (\"PATH=\") - 1);\n  strncat (shell, pwd->pw_shell, sizeof (shell) - sizeof (\"SHELL=\") - 1);\n  strncat (username, pwd->pw_name, sizeof (username) - sizeof (\"USER=\") - 1);\n  strncat (logname, pwd->pw_name, sizeof (logname) - sizeof (\"LOGNAME=\") - 1);\n  strncat (rhost, hostname, sizeof (rhost) - sizeof (\"RHOST=\") - 1);\n\n#ifdef WITH_PAM\n  if (pam_getenv (pam_handle, \"PATH\") == NULL)\n    (void) pam_putenv (pam_handle, path);\n  if (pam_getenv (pam_handle, \"HOME\") == NULL)\n    (void) pam_putenv (pam_handle, homedir);\n  if (pam_getenv (pam_handle, \"SHELL\") == NULL)\n    (void) pam_putenv (pam_handle, shell);\n  if (pam_getenv (pam_handle, \"USER\") == NULL)\n    (void) pam_putenv (pam_handle, username);\n  if (pam_getenv (pam_handle, \"LOGNAME\") == NULL)\n    (void) pam_putenv (pam_handle, logname);\n  if (pam_getenv (pam_handle, \"RHOST\") == NULL)\n    (void) pam_putenv (pam_handle, rhost);\n\n  environ = pam_getenvlist (pam_handle);\n#else /* !WITH_PAM */\n  environ = envinit;\n#endif /* WITH_PAM */\n\n  cp = strrchr (pwd->pw_shell, '/');\n  if (cp)\n    cp++;\t\t\t/* step past last slash */\n  else\n    cp = pwd->pw_shell;\t\t/* no slash in shell string */\n  endpwent ();\n  if (log_success || pwd->pw_uid == 0)\n    {\n#ifdef KRB4\n      if (use_kerberos)\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"Kerberos shell from %s.%s@%s on %s as %s, cmd='%.80s'\",\n\t\tkdata->pname, kdata->pinst, kdata->prealm,\n\t\thostname, locuser, cmdbuf);\n      else\n#endif /* KRB4 */\n\tsyslog (LOG_INFO | LOG_AUTH,\n\t\t\"%s%s from %s as '%s': cmd='%.80s'\",\n#ifdef SHISHI\n\t\t!use_kerberos ? \"\"\n\t\t  : !doencrypt ? \"Kerberized \"\n\t\t    : \"Kerberized and encrypted \",\n#else\n\t\t\"\",\n#endif\n\t\trprincipal ? rprincipal : remuser,\n\t\thostname, locuser, cmdbuf);\n    }\n#ifdef SHISHI\n  if (doencrypt)\n    execl (pwd->pw_shell, cp, \"-c\", cmdbuf + 3, NULL);\n  else\n#endif /* SHISHI */\n    execl (pwd->pw_shell, cp, \"-c\", cmdbuf, NULL);\n\n#ifdef WITH_PAM\n  pam_end (pam_handle, PAM_SUCCESS);\n#endif\n  syslog (LOG_ERR, \"execl failed for \\\"%s\\\": %m\", pwd->pw_name);\n  error (EXIT_FAILURE, errno, \"cannot execute %s\", pwd->pw_shell);\n}",
      "lines": 1541,
      "depth": 28,
      "decorators": [
        "void"
      ]
    },
    "rshd_error": {
      "start_point": [
        1971,
        0
      ],
      "end_point": [
        1990,
        1
      ],
      "content": "void\nrshd_error (const char *fmt, ...)\n{\n  va_list ap;\n  int len;\n  char *bp, buf[BUFSIZ];\n  va_start (ap, fmt);\n\n  bp = buf;\n  if (sent_null == 0)\n    {\n      *bp++ = 1;\t/* error indicator */\n      len = 1;\n    }\n  else\n    len = 0;\n  vsnprintf (bp, sizeof (buf) - 1, fmt, ap);\n  va_end (ap);\n  write (STDERR_FILENO, buf, len + strlen (bp));\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "getstr": {
      "start_point": [
        1992,
        0
      ],
      "end_point": [
        2036,
        1
      ],
      "content": "char *\ngetstr (const char *err)\n{\n  size_t buf_len = 100;\n  char *buf = malloc (buf_len), *end = buf;\n\n  if (!buf)\n    {\n      rshd_error (\"Out of space reading %s\\n\", err);\n      exit (EXIT_FAILURE);\n    }\n\n  do\n    {\n      /* Oh this is efficient, oh yes.  [But what can be done?] */\n      int rd = read (STDIN_FILENO, end, 1);\n\n      if (rd <= 0)\n\t{\n\t  if (rd == 0)\n\t    rshd_error (\"EOF reading %s\\n\", err);\n\t  else\n\t    perror (err);\n\t  exit (EXIT_FAILURE);\n\t}\n\n      end += rd;\n      if ((buf + buf_len - end) < (ssize_t) (buf_len >> 3))\n\t{\n\t  /* Not very much room left in our buffer, grow it. */\n\t  size_t end_offs = end - buf;\n\t  buf_len += buf_len;\n\t  buf = realloc (buf, buf_len);\n\t  if (!buf)\n\t    {\n\t      rshd_error (\"Out of space reading %s\\n\", err);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t  end = buf + end_offs;\n\t}\n    }\n  while (*(end - 1));\n\n  return buf;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "char",
        "*\ngetstr (const char *err)",
        "*"
      ]
    },
    "local_domain": {
      "start_point": [
        2046,
        0
      ],
      "end_point": [
        2066,
        1
      ],
      "content": "int\nlocal_domain (const char *h)\n{\n  char *hostname = localhost ();\n\n  if (!hostname)\n    return 0;\n  else\n    {\n      int is_local = 0;\n      const char *p1 = topdomain (hostname);\n      const char *p2 = topdomain (h);\n\n      if (p1 == NULL || p2 == NULL || !strcasecmp (p1, p2))\n\tis_local = 1;\n\n      free (hostname);\n\n      return is_local;\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "topdomain": {
      "start_point": [
        2068,
        0
      ],
      "end_point": [
        2084,
        1
      ],
      "content": "const char *\ntopdomain (const char *h)\n{\n  const char *p, *maybe = NULL;\n  int dots = 0;\n\n  for (p = h + strlen (h); p >= h; p--)\n    {\n      if (*p == '.')\n\t{\n\t  if (++dots == 2)\n\t    return p;\n\t  maybe = p;\n\t}\n    }\n  return maybe;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ntopdomain (const char *h)",
        "*"
      ]
    },
    "rsh_conv": {
      "start_point": [
        2090,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "static int\nrsh_conv (int num, const struct pam_message **pam_msg,\n\t    struct pam_response **pam_resp,\n\t    void *data _GL_UNUSED_PARAMETER)\n{\n  struct pam_response *resp;\n\n  /* Reject composite calls at the time being.  */\n  if (num <= 0 || num > 1)\n    return PAM_CONV_ERR;\n\n  /* Ensure an empty response.  */\n  *pam_resp = NULL;\n\n  switch ((*pam_msg)->msg_style)\n    {\n    case PAM_PROMPT_ECHO_OFF:\t/* Return an empty password.  */\n      resp = (struct pam_response *) malloc (sizeof (*resp));\n      if (!resp)\n\treturn PAM_BUF_ERR;\n      resp->resp_retcode = 0;\n      resp->resp = strdup (\"\");\n      if (!resp->resp)\n\t{\n\t  free (resp);\n\t  return PAM_BUF_ERR;\n\t}\n      if (log_success)\n\tsyslog (LOG_NOTICE | LOG_AUTH, \"PAM message \\\"%s\\\".\",\n\t\t(*pam_msg)->msg);\n      *pam_resp = resp;\n      return PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:\t\t/* Not yet supported.  */\n    case PAM_ERROR_MSG:\t\t/* Likewise.  */\n    case PAM_PROMPT_ECHO_ON:\t/* Interactivity is not supported.  */\n    default:\n      return PAM_CONV_ERR;\n    }\n  return PAM_CONV_ERR;\t/* Never reached.  */\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/syslogd.c": {
    "parse_opt": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  char *endptr;\n  int v;\n\n  switch (key)\n    {\n    case 'a':\n      add_funix (arg);\n      break;\n\n    case 'l':\n      LocalHosts = crunch_list (LocalHosts, arg);\n      break;\n\n    case 's':\n      StripDomains = crunch_list (StripDomains, arg);\n      break;\n\n    case 'd':\n      Debug = 1;\n      NoDetach = 1;\n      break;\n\n    case 'h':\n      NoHops = 0;\n      break;\n\n    case 'r':\n      AcceptRemote = 1;\n      break;\n\n    case '4':\n      usefamily = AF_INET;\n      break;\n\n    case '6':\n      usefamily = AF_INET6;\n      break;\n\n    case OPT_IPANY:\n      usefamily = AF_UNSPEC;\n      break;\n\n    case 'b':\n      BindAddress = arg;\n      break;\n\n    case 'B':\n      BindPort = arg;\n      break;\n\n    case 'm':\n      v = strtol (arg, &endptr, 10);\n      if (*endptr)\n        argp_error (state, \"invalid value (`%s' near `%s')\", arg, endptr);\n      MarkInterval = v * 60;\n      break;\n\n    case 'n':\n      NoDetach = 1;\n      break;\n\n    case OPT_NO_FORWARD:\n      NoForward = 1;\n      break;\n\n    case OPT_NO_KLOG:\n      NoKLog = 1;\n      break;\n\n    case OPT_NO_UNIXAF:\n      NoUnixAF = 1;\n      break;\n\n    case 'P':\n      PidFile = arg;\n      break;\n\n    case 'f':\n      ConfFile = arg;\n      break;\n\n    case 'D':\n      ConfDir = arg;\n      break;\n\n    case 'p':\n      funix[0].name = arg;\n      funix[0].fd = -1;\n      break;\n\n    case 'S':\n      force_sync = 1;\n      break;\n\n    case 'T':\n      set_local_time = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 107,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        484,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  size_t i;\n  FILE *fp;\n  char *p;\n  char line[MAXLINE + 1];\n  char kline[MAXLINE + 1];\n  int kline_len = 0;\n  pid_t ppid = 0;\t\t/* We run in debug mode and didn't fork.  */\n  struct pollfd *fdarray;\n  unsigned long nfds = 0;\n#ifdef HAVE_SIGACTION\n  struct sigaction sa;\n#endif\n\n  set_program_name (argv[0]);\n\n  /* Initialize PATH_LOG as the first element of the unix sockets array.  */\n  add_funix (PATH_LOG);\n\n  /* Parse command line */\n  iu_argp_init (\"syslogd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  /* Check desired port, if in demand at all.  */\n  find_inet_port (BindPort);\n\n  /* Daemonise, if not, set the buffering for line buffer.  */\n  if (!NoDetach)\n    {\n      /* History: According to the GNU/Linux sysklogd ChangeLogs \"Wed\n         Feb 14 12:42:09 CST 1996: Dr. Wettstein Parent process of\n         syslogd does not exit until child process has finished\n         initialization process.  This allows rc.* startup to pause\n         until syslogd facility is up and operating.\"\n\n         IMO, the GNU/Linux distributors should fix there booting\n         sequence.  But we still keep the approach.  */\n      signal (SIGTERM, doexit);\n      ppid = waitdaemon (0, 0, 30);\n      if (ppid < 0)\n        error (EXIT_FAILURE, errno, \"could not become daemon\");\n    }\n  else\n    {\n      if (Debug)\n\tdbg_output = 1;\n      setvbuf (stdout, 0, _IOLBF, 0);\n    }\n\n  /* Get our hostname.  */\n  LocalHostName = localhost ();\n  if (LocalHostName == NULL)\n    error (EXIT_FAILURE, errno, \"can't get local host name\");\n\n  /* Get the domainname.  */\n  p = strchr (LocalHostName, '.');\n  if (p != NULL)\n    {\n      *p++ = '\\0';\n      LocalDomain = p;\n    }\n  else\n    {\n      struct addrinfo hints, *rp;\n      int err;\n\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_family = AF_UNSPEC;\t/* Family is irrelevant.  */\n      hints.ai_flags = AI_CANONNAME;\n\n      /* Try to resolve the domainname by calling DNS.  */\n      err = getaddrinfo (LocalHostName, NULL, &hints, &rp);\n      if (err == 0)\n\t{\n\t  /* Override what we had */\n\t  free (LocalHostName);\n\t  LocalHostName = strdup (rp->ai_canonname);\n\t  p = strchr (LocalHostName, '.');\n\t  if (p != NULL)\n\t    {\n\t      *p++ = '\\0';\n\t      LocalDomain = p;\n\t    }\n\t  freeaddrinfo (rp);\n\t}\n      if (LocalDomain == NULL)\n\tLocalDomain = strdup (\"\");\n    }\n\n  consfile.f_type = F_CONSOLE;\n  consfile.f_un.f_fname = strdup (ctty);\n\n  signal (SIGTERM, die);\n  signal (SIGINT, NoDetach ? die : SIG_IGN);\n  signal (SIGQUIT, NoDetach ? die : SIG_IGN);\n\n#ifdef HAVE_SIGACTION\n  /* Register repeatable actions portably!  */\n  sa.sa_flags = SA_RESTART;\n  sigemptyset (&sa.sa_mask);\n\n  sa.sa_handler = domark;\n  (void) sigaction (SIGALRM, &sa, NULL);\n\n  sa.sa_handler = NoDetach ? dbg_toggle : SIG_IGN;\n  (void) sigaction (SIGUSR1, &sa, NULL);\n#else /* !HAVE_SIGACTION */\n  signal (SIGALRM, domark);\n  signal (SIGUSR1, NoDetach ? dbg_toggle : SIG_IGN);\n#endif\n\n  alarm (TIMERINTVL);\n\n  /* We add  3 = 1(klog) + 2(inet,inet6), even if they may stay unused.  */\n  fdarray = (struct pollfd *) malloc ((nfunix + 3) * sizeof (*fdarray));\n  if (fdarray == NULL)\n    error (EXIT_FAILURE, errno, \"can't allocate fd table\");\n\n  /* read configuration file */\n  init (0);\n\n#ifdef PATH_KLOG\n  /* Initialize kernel logging and add to the list.  */\n  if (!NoKLog)\n    {\n      fklog = open (PATH_KLOG, O_RDONLY, 0);\n      if (fklog >= 0)\n\t{\n\t  fdarray[nfds].fd = fklog;\n\t  fdarray[nfds].events = POLLIN | POLLPRI;\n\t  nfds++;\n\t  dbg_printf (\"Klog open %s\\n\", PATH_KLOG);\n\t}\n      else\n\tdbg_printf (\"Can't open %s: %s\\n\", PATH_KLOG, strerror (errno));\n    }\n#endif\n\n  /* Initialize unix sockets.  */\n  if (!NoUnixAF)\n    {\n      for (i = 0; i < nfunix; i++)\n\t{\n\t  funix[i].fd = create_unix_socket (funix[i].name);\n\t  if (funix[i].fd >= 0)\n\t    {\n\t      fdarray[nfds].fd = funix[i].fd;\n\t      fdarray[nfds].events = POLLIN | POLLPRI;\n\t      nfds++;\n\t      dbg_printf (\"Opened UNIX socket `%s'.\\n\", funix[i].name);\n\t    }\n\t  else\n\t    dbg_printf (\"Can't open %s: %s\\n\", funix[i].name,\n\t\t\tstrerror (errno));\n\t}\n    }\n\n  /* Initialize inet socket and add it to the list.  */\n  if (AcceptRemote)\n    {\n      create_inet_socket (usefamily, finet);\n      if (finet[IU_FD_IP4] >= 0)\n\t{\n\t  /* IPv4 socket is present.  */\n\t  fdarray[nfds].fd = finet[IU_FD_IP4];\n\t  fdarray[nfds].events = POLLIN | POLLPRI;\n\t  nfds++;\n\t  dbg_printf (\"Opened syslog UDP/IPv4 port.\\n\");\n\t}\n      if (finet[IU_FD_IP6] >= 0)\n\t{\n\t  /* IPv6 socket is present.  */\n\t  fdarray[nfds].fd = finet[IU_FD_IP6];\n\t  fdarray[nfds].events = POLLIN | POLLPRI;\n\t  nfds++;\n\t  dbg_printf (\"Opened syslog UDP/IPv6 port.\\n\");\n\t}\n      if (finet[IU_FD_IP4] < 0 && finet[IU_FD_IP6] < 0)\n\tdbg_printf (\"Can't open UDP port: %s\\n\", strerror (errno));\n    }\n\n  /* Tuck my process id away.  */\n  fp = fopen (PidFile, \"w\");\n  if (fp != NULL)\n    {\n      fprintf (fp, \"%d\\n\", (int) getpid ());\n      fclose (fp);\n    }\n\n  dbg_printf (\"off & running....\\n\");\n\n#ifdef HAVE_SIGACTION\n  /* `sa' has been cleared already.  */\n  sa.sa_handler = trigger_restart;\n  (void) sigaction (SIGHUP, &sa, NULL);\n#else /* !HAVE_SIGACTION */\n  signal (SIGHUP, trigger_restart);\n#endif\n\n  if (NoDetach)\n    {\n      dbg_output = 1;\n      dbg_printf (\"Debugging is disabled. Send SIGUSR1 to PID=%d \"\n\t\t  \"to turn on debugging.\\n\", (int) getpid ());\n      dbg_output = 0;\n    }\n\n  /* If we're doing waitdaemon(), tell the parent to exit,\n     we are ready to roll.  */\n  if (ppid)\n    kill (ppid, SIGTERM);\n\n  for (;;)\n    {\n      int nready;\n      nready = poll (fdarray, nfds, -1);\n      if (nready == 0)\t\t/* ??  noop */\n\tcontinue;\n\n      /* Sighup was dropped.  */\n      if (restart)\n\t{\n\t  dbg_printf (\"\\nReceived SIGHUP, restarting syslogd.\\n\");\n\t  init (0);\n\t  restart = 0;\n\t  continue;\n\t}\n\n      if (nready < 0)\n\t{\n\t  if (errno != EINTR)\n\t    logerror (\"poll\");\n\t  continue;\n\t}\n\n      /*dbg_printf (\"got a message (%d)\\n\", nready); */\n\n      for (i = 0; i < nfds; i++)\n\tif (fdarray[i].revents & (POLLIN | POLLPRI))\n\t  {\n\t    int result;\n\t    socklen_t len;\n\t    if (fdarray[i].fd == -1)\n\t      continue;\n\t    else if (fdarray[i].fd == fklog)\n\t      {\n\t\tresult = read (fdarray[i].fd, &kline[kline_len],\n\t\t\t       sizeof (kline) - kline_len - 1);\n\n\t\tif (result > 0)\n\t\t  {\n\t\t    kline_len += result;\n\t\t  }\n\t\telse if (result < 0 && errno != EINTR)\n\t\t  {\n\t\t    logerror (\"klog\");\n\t\t    fdarray[i].fd = fklog = -1;\n\t\t  }\n\n\t\twhile (1)\n\t\t  {\n\t\t    char *bol, *eol;\n\n\t\t    kline[kline_len] = '\\0';\n\n\t\t    for (bol = kline, eol = strchr (kline, '\\n'); eol;\n\t\t\t bol = eol, eol = strchr (bol, '\\n'))\n\t\t      {\n\t\t\t*(eol++) = '\\0';\n\t\t\tkline_len -= (eol - bol);\n\t\t\tprintsys (bol);\n\t\t      }\n\n\t\t    /* This loop makes sure the daemon won't lock up\n\t\t     * on null bytes in the klog stream.  They still hurt\n\t\t     * efficiency, acting like a message separator that\n\t\t     * forces a shift-and-reiterate when the buffer was\n\t\t     * never full.\n\t\t     */\n\t\t    while (kline_len && !*bol)\n\t\t      {\n\t\t\tbol++;\n\t\t\tkline_len--;\n\t\t      }\n\n\t\t    if (!kline_len)\n\t\t      break;\n\n\t\t    if (bol != kline)\n\t\t      {\n\t\t\t/* shift the partial line to start of buffer, so\n\t\t\t * we can re-iterate.\n\t\t\t */\n\t\t\tmemmove (kline, bol, kline_len);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tif (kline_len < MAXLINE)\n\t\t\t  break;\n\n\t\t\t/* The pathological case of a single message that\n\t\t\t * overfills our buffer.  The best we can do is\n\t\t\t * log it in pieces.\n\t\t\t */\n\t\t\tprintsys (kline);\n\n\t\t\t/* Clone priority signal if present\n\t\t\t * We merely shift the kline_len pointer after\n\t\t\t * it so the next chunk is written after it.\n\t\t\t *\n\t\t\t * strchr(kline,'>') is not used as it would allow\n\t\t\t * a pathological line ending in '>' to cause an\n\t\t\t * endless loop.\n\t\t\t */\n\t\t\tif (kline[0] == '<'\n\t\t\t    && isdigit (kline[1]) && kline[2] == '>')\n\t\t\t  kline_len = 3;\n\t\t\telse\n\t\t\t  kline_len = 0;\n\t\t      }\n\t\t  }\n\t      }\n\t    else if (fdarray[i].fd == finet[IU_FD_IP4]\n\t\t     || fdarray[i].fd == finet[IU_FD_IP6])\n\t      {\n\t\tstruct sockaddr_storage frominet;\n\t\t/*dbg_printf (\"inet message\\n\"); */\n\t\tlen = sizeof (frominet);\n\t\tmemset (line, '\\0', sizeof (line));\n\t\tresult = recvfrom (fdarray[i].fd, line, MAXLINE, 0,\n\t\t\t\t   (struct sockaddr *) &frominet, &len);\n\t\tif (result > 0)\n\t\t  {\n\t\t    line[result] = '\\0';\n\t\t    printline (cvthname ((struct sockaddr *) &frominet, len), line);\n\t\t  }\n\t\telse if (result < 0 && errno != EINTR)\n\t\t  logerror (\"recvfrom inet\");\n\t      }\n\t    else\n\t      {\n\t\tstruct sockaddr_un fromunix;\n\t\t/*dbg_printf (\"unix message\\n\"); */\n\t\tlen = sizeof (fromunix);\n\t\tresult = recvfrom (fdarray[i].fd, line, MAXLINE, 0,\n\t\t\t\t   (struct sockaddr *) &fromunix, &len);\n\t\tif (result > 0)\n\t\t  {\n\t\t    line[result] = '\\0';\n\t\t    printline (LocalHostName, line);\n\t\t  }\n\t\telse if (result < 0 && errno != EINTR)\n\t\t  logerror (\"recvfrom unix\");\n\t      }\n\t  }\n\telse if (fdarray[i].revents & POLLNVAL)\n\t  {\n\t    logerror (\"poll nval\\n\");\n\t    fdarray[i].fd = -1;\n\t  }\n\telse if (fdarray[i].revents & POLLERR)\n\t  logerror (\"poll err\\n\");\n\telse if (fdarray[i].revents & POLLHUP)\n\t  logerror (\"poll hup\\n\");\n    }\t\t\t\t/* for (;;) */\n}",
      "lines": 368,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "add_funix": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "static void\nadd_funix (const char *name)\n{\n  funix = realloc (funix, (nfunix + 1) * sizeof (*funix));\n  if (funix == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate space for unix sockets\");\n\n  funix[nfunix].name = name;\n  funix[nfunix].fd = -1;\n  nfunix++;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_unix_socket": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        902,
        1
      ],
      "content": "static int\ncreate_unix_socket (const char *path)\n{\n  int fd;\n  struct sockaddr_un sunx;\n  char line[MAXLINE + 1];\n\n  if (path[0] == '\\0')\n    return -1;\n\n  if (strlen (path) >= sizeof (sunx.sun_path))\n    {\n      snprintf (line, sizeof (line), \"UNIX socket name too long: %s\", path);\n      logerror (line);\n      return -1;\n    }\n\n  unlink (path);\n\n  memset (&sunx, 0, sizeof (sunx));\n  sunx.sun_family = AF_UNIX;\n  strncpy (sunx.sun_path, path, sizeof (sunx.sun_path) - 1);\n  fd = socket (AF_UNIX, SOCK_DGRAM, 0);\n  if (fd < 0 || bind (fd, (struct sockaddr *) &sunx, SUN_LEN (&sunx)) < 0\n      || chmod (path, 0666) < 0)\n    {\n      snprintf (line, sizeof (line), \"cannot create %s\", path);\n      logerror (line);\n      dbg_printf (\"cannot create %s: %s\\n\", path, strerror (errno));\n      close (fd);\n      fd = -1;\n    }\n  return fd;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "create_inet_socket": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        969,
        1
      ],
      "content": "static void\ncreate_inet_socket (int af, int fd46[2])\n{\n  int err, fd = -1;\n  struct addrinfo hints, *rp, *ai;\n\n  /* Invalidate old descriptors.  */\n  fd46[IU_FD_IP4] = fd46[IU_FD_IP6] = -1;\n\n  if (!LogPortText)\n    {\n      dbg_printf (\"No listen port has been accepted.\\n\");\n      return;\n    }\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = af;\n  hints.ai_socktype = SOCK_DGRAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  err = getaddrinfo (BindAddress, LogPortText, &hints, &rp);\n  if (err)\n    {\n      logerror (\"lookup error, suspending inet service\");\n      return;\n    }\n\n  for (ai = rp; ai; ai = ai->ai_next)\n    {\n      int yes = 1;\n\n      fd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      err = setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof (yes));\n      if (err < 0)\n\tlogerror (\"failed to set SO_REUSEADDR\");\n\n      if (ai->ai_family == AF_INET6)\n\t{\n\t  /* Avoid dual stacked sockets.  Better to use distinct sockets.  */\n\t  (void) setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof (yes));\n\t}\n\n      if (bind (fd, ai->ai_addr, ai->ai_addrlen) < 0)\n\t{\n\t  close (fd);\n\t  fd = -1;\n\t  continue;\n\t}\n      /* Register any success.  */\n      if (ai->ai_family == AF_INET && fd46[IU_FD_IP4] < 0)\n\tfd46[IU_FD_IP4] = fd;\n      else if (ai->ai_family == AF_INET6 && fd46[IU_FD_IP6] < 0)\n\tfd46[IU_FD_IP6] = fd;\n    }\n  freeaddrinfo (rp);\n\n  if (fd46[IU_FD_IP4] < 0 && fd46[IU_FD_IP6] < 0)\n    {\n      logerror (\"inet service, failed lookup.\");\n      return;\n    }\n  return;\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "crunch_list": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "char **\ncrunch_list (char **oldlist, char *list)\n{\n  int count, i;\n  char *p, *q;\n\n  p = list;\n\n  /* Strip off trailing delimiters.  */\n  while (p[strlen (p) - 1] == LIST_DELIMITER)\n    {\n      p[strlen (p) - 1] = '\\0';\n    }\n  /* Cut off leading delimiters.  */\n  while (p[0] == LIST_DELIMITER)\n    {\n      p++;\n    }\n\n  /* Bailout early the string is empty.  */\n  if (*p == '\\0')\n    return oldlist;\n\n  /* Count delimiters to calculate elements.  */\n  for (count = 1, i = 0; p[i]; i++)\n    if (p[i] == LIST_DELIMITER)\n      count++;\n\n  /* Count how many we add in the old list.  */\n  for (i = 0; oldlist && oldlist[i]; i++)\n    ;\n\n  /* allocate enough space */\n  oldlist = (char **) realloc (oldlist, (i + count + 1) * sizeof (*oldlist));\n  if (oldlist == NULL)\n    error (EXIT_FAILURE, errno, \"can't allocate memory\");\n\n  /*\n     We now can assume that the first and last\n     characters are different from any delimiters,\n     so we don't have to care about it anymore.  */\n\n  /* Start from where we left last time.  */\n  for (count = i; (q = strchr (p, LIST_DELIMITER)) != NULL;\n       count++, p = q, p++)\n    {\n      oldlist[count] = (char *) malloc ((q - p + 1) * sizeof (char));\n      if (oldlist[count] == NULL)\n        error (EXIT_FAILURE, errno, \"can't allocate memory\");\n\n      strncpy (oldlist[count], p, q - p);\n      oldlist[count][q - p] = '\\0';\n    }\n\n  /* take the last one */\n  oldlist[count] = (char *) xmalloc ((strlen (p) + 1) * sizeof (char));\n  if (oldlist[count] == NULL)\n    error (EXIT_FAILURE, errno, \"can't allocate memory\");\n\n  strcpy (oldlist[count], p);\n\n  oldlist[++count] = NULL;\t/* terminate the array with a NULL */\n\n  if (Debug)\n    {\n      for (count = 0; oldlist[count]; count++)\n\tprintf (\"#%d: %s\\n\", count, oldlist[count]);\n    }\n  return oldlist;\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "char",
        "**\ncrunch_list (char **oldlist, char *list)",
        "*",
        "*\ncrunch_list (char **oldlist, char *list)",
        "*"
      ]
    },
    "printline": {
      "start_point": [
        1044,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "void\nprintline (const char *hname, const char *msg)\n{\n  int c, pri;\n  const char *p;\n  char *q, line[MAXLINE + 1];\n\n  /* test for special codes */\n  pri = DEFUPRI;\n  p = msg;\n  if (*p == '<')\n    {\n      pri = 0;\n      while (isdigit (*++p))\n\tpri = 10 * pri + (*p - '0');\n      if (*p == '>')\n\t++p;\n    }\n\n  /* This overrides large positive and overflowing negative values.  */\n  if (pri & ~(LOG_FACMASK | LOG_PRIMASK))\n    pri = DEFUPRI;\n\n  /* Avoid undefined facilities.  */\n  if (LOG_FAC (pri) > LOG_NFACILITIES)\n    pri = DEFUPRI;\n\n  /* Do not allow users to log kernel messages.  */\n  if (LOG_FAC (pri) == (LOG_KERN >> 3))\n    pri = LOG_MAKEPRI (LOG_USER, LOG_PRI (pri));\n\n  q = line;\n  while ((c = *p++) != '\\0' && q < &line[sizeof (line) - 1])\n    if (iscntrl (c))\n      if (c == '\\n')\n\t*q++ = ' ';\n      else if (c == '\\t')\n\t*q++ = '\\t';\n      else if (c >= 0177)\n\t*q++ = c;\n      else\n\t{\n\t  *q++ = '^';\n\t  *q++ = c ^ 0100;\n\t}\n    else\n      *q++ = c;\n  *q = '\\0';\n\n  /* This for the default behaviour on GNU/Linux syslogd who\n     sync on every line.  */\n  if (force_sync)\n    logmsg (pri, line, hname, SYNC_FILE);\n  else\n    logmsg (pri, line, hname, 0);\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "printsys": {
      "start_point": [
        1103,
        0
      ],
      "end_point": [
        1137,
        1
      ],
      "content": "void\nprintsys (const char *msg)\n{\n  int c, pri, flags;\n  char *lp, *q, line[MAXLINE + 1];\n  const char *p;\n\n  strcpy (line, \"vmunix: \");\n  lp = line + strlen (line);\n  for (p = msg; *p != '\\0';)\n    {\n      flags = SYNC_FILE | ADDDATE;\t/* Fsync after write.  */\n      pri = DEFSPRI;\n      if (*p == '<')\n\t{\n\t  pri = 0;\n\t  while (isdigit (*++p))\n\t    pri = 10 * pri + (*p - '0');\n\t  if (*p == '>')\n\t    ++p;\n\t}\n      else\n\t{\n\t  /* kernel printf's come out on console */\n\t  flags |= IGN_CONS;\n\t}\n      if (pri & ~(LOG_FACMASK | LOG_PRIMASK))\n\tpri = DEFSPRI;\n      q = lp;\n      while (*p != '\\0' && (c = *p++) != '\\n' && q < &line[MAXLINE])\n\t*q++ = c;\n      *q = '\\0';\n      logmsg (pri, line, LocalHostName, flags);\n    }\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "textpri": {
      "start_point": [
        1140,
        0
      ],
      "end_point": [
        1154,
        1
      ],
      "content": "char *\ntextpri (int pri)\n{\n  static char res[20];\n  CODE *c_pri, *c_fac;\n\n  for (c_fac = facilitynames; c_fac->c_name\n       && !(c_fac->c_val == LOG_FAC (pri) << 3); c_fac++);\n  for (c_pri = prioritynames; c_pri->c_name\n       && !(c_pri->c_val == LOG_PRI (pri)); c_pri++);\n\n  snprintf (res, sizeof (res), \"%s.%s\", c_fac->c_name, c_pri->c_name);\n\n  return res;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "char",
        "*\ntextpri (int pri)",
        "*"
      ]
    },
    "logmsg": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1310,
        1
      ],
      "content": "void\nlogmsg (int pri, const char *msg, const char *from, int flags)\n{\n  struct filed *f;\n  int fac, msglen, prilev;\n#ifdef HAVE_SIGACTION\n  sigset_t sigs, osigs;\n#else\n  int omask;\n#endif\n\n  const char *timestamp;\n\n  dbg_printf (\"(logmsg): %s (%d), flags %x, from %s, msg %s\\n\",\n\t      textpri (pri), pri, flags, from, msg);\n\n#ifdef HAVE_SIGACTION\n  sigemptyset (&sigs);\n  sigaddset (&sigs, SIGHUP);\n  sigaddset (&sigs, SIGALRM);\n  sigprocmask (SIG_BLOCK, &sigs, &osigs);\n#else\n  omask = sigblock (sigmask (SIGHUP) | sigmask (SIGALRM));\n#endif\n\n  /* Check to see if msg looks non-standard.  */\n  msglen = strlen (msg);\n  if (msglen < 16 || msg[3] != ' ' || msg[6] != ' ' ||\n      msg[9] != ':' || msg[12] != ':' || msg[15] != ' ')\n    flags |= ADDDATE;\n\n  time (&now);\n  if (flags & ADDDATE)\n    timestamp = ctime (&now) + 4;\n  else\n    {\n      if (set_local_time)\n\ttimestamp = ctime (&now) + 4;\n      else\n\ttimestamp = msg;\n      msg += 16;\n      msglen -= 16;\n    }\n\n  /* Extract facility and priority level.  */\n  if (flags & MARK)\n#ifdef INTERNAL_MARK\n    fac = LOG_FAC (INTERNAL_MARK);\n#else\n    fac = LOG_NFACILITIES;\n#endif\n  else\n    fac = LOG_FAC (pri);\n  prilev = LOG_PRI (pri);\n\n  /* Log the message to the particular outputs. */\n  if (!Initialized)\n    {\n      f = &consfile;\n      f->f_file = open (ctty, O_WRONLY, 0);\n      f->f_prevhost = strdup (LocalHostName);\n      if (f->f_file >= 0)\n\t{\n\t  fprintlog (f, from, flags, msg);\n\t  close (f->f_file);\n\t}\n#ifdef HAVE_SIGACTION\n      sigprocmask (SIG_SETMASK, &osigs, 0);\n#else\n      sigsetmask (omask);\n#endif\n      return;\n    }\n  for (f = Files; f; f = f->f_next)\n    {\n      /* Skip messages that are incorrect priority. */\n      if (!(f->f_pmask[fac] & LOG_MASK (prilev)))\n\tcontinue;\n\n      if (f->f_type == F_CONSOLE && (flags & IGN_CONS))\n\tcontinue;\n\n      /* Don't output marks to recently written files.  */\n      if ((flags & MARK) && (now - f->f_time) < MarkInterval / 2)\n\tcontinue;\n\n      if (f->f_progname)\n\t{\n\t  /* The usual, and desirable, formattings are:\n\t   *\n\t   *   prg: message text\n\t   *   prg[PIDNO]: message text\n\t   */\n\n\t  /* Skip on selector mismatch.  */\n\t  if (strncmp (msg, f->f_progname, f->f_prognlen))\n\t    continue;\n\n\t  /* Avoid matching on prefixes.  */\n\t  if (isalnum (msg[f->f_prognlen])\n\t      || msg[f->f_prognlen] == '-'\n\t      || msg[f->f_prognlen] == '_')\n\t    continue;\n\t}\n\n      /* Suppress duplicate lines to this file.  */\n      if ((flags & MARK) == 0 && msglen == f->f_prevlen && f->f_prevhost\n\t  && !strcmp (msg, f->f_prevline) && !strcmp (from, f->f_prevhost))\n\t{\n\t  strncpy (f->f_lasttime, timestamp, sizeof (f->f_lasttime) - 1);\n\t  f->f_prevcount++;\n\t  dbg_printf (\"msg repeated %d times, %ld sec of %d\\n\",\n\t\t      f->f_prevcount, now - f->f_time,\n\t\t      repeatinterval[f->f_repeatcount]);\n\t  /* If domark would have logged this by now, flush it now (so we\n\t     don't hold isolated messages), but back off so we'll flush\n\t     less often in the future.  */\n\t  if (now > REPEATTIME (f))\n\t    {\n\t      fprintlog (f, from, flags, (char *) NULL);\n\t      BACKOFF (f);\n\t    }\n\t}\n      else\n\t{\n\t  /* New line, save it.  */\n\t  if (f->f_prevcount)\n\t    fprintlog (f, from, 0, (char *) NULL);\n\t  f->f_repeatcount = 0;\n\t  strncpy (f->f_lasttime, timestamp, sizeof (f->f_lasttime) - 1);\n\t  free (f->f_prevhost);\n\t  f->f_prevhost = strdup (from);\n\t  if (msglen < MAXSVLINE)\n\t    {\n\t      f->f_prevlen = msglen;\n\t      f->f_prevpri = pri;\n\t      strcpy (f->f_prevline, msg);\n\t      fprintlog (f, from, flags, (char *) NULL);\n\t    }\n\t  else\n\t    {\n\t      f->f_prevline[0] = 0;\n\t      f->f_prevlen = 0;\n\t      fprintlog (f, from, flags, msg);\n\t    }\n\t}\n    }\n#ifdef HAVE_SIGACTION\n  sigprocmask (SIG_SETMASK, &osigs, 0);\n#else\n  sigsetmask (omask);\n#endif\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "fprintlog": {
      "start_point": [
        1312,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "void\nfprintlog (struct filed *f, const char *from, int flags, const char *msg)\n{\n  struct iovec iov[IOVCNT];\n  struct iovec *v;\n  int l;\n  char line[MAXLINE + 1], repbuf[80], greetings[200];\n  time_t fwd_suspend;\n\n  v = iov;\n  /* Be paranoid.  */\n  memset (v, 0, sizeof (struct iovec) * IOVCNT);\n  if (f->f_type == F_WALL)\n    {\n      v->iov_base = greetings;\n      snprintf (greetings, sizeof (greetings),\n\t\t\"\\r\\n\\7Message from syslogd@%s at %.24s ...\\r\\n\",\n\t\tf->f_prevhost, ctime (&now));\n      v->iov_len = strlen (greetings);\n      v++;\n      v->iov_base = (char *) \"\";\n      v->iov_len = 0;\n      v++;\n    }\n  else\n    {\n      v->iov_base = f->f_lasttime;\n      v->iov_len = sizeof (f->f_lasttime) - 1;\n      v++;\n      v->iov_base = (char *) \" \";\n      v->iov_len = 1;\n      v++;\n    }\n  if (f->f_prevhost)\n    {\n      v->iov_base = f->f_prevhost;\n      v->iov_len = strlen (v->iov_base);\n      v++;\n    }\n  v->iov_base = (char *) \" \";\n  v->iov_len = 1;\n  v++;\n\n  if (msg)\n    {\n      v->iov_base = (char *) msg;\n      v->iov_len = strlen (msg);\n    }\n  else if (f->f_prevcount > 1)\n    {\n      v->iov_base = repbuf;\n      snprintf (repbuf, sizeof (repbuf), \"last message repeated %d times\",\n\t\tf->f_prevcount);\n      v->iov_len = strlen (repbuf);\n    }\n  else\n    {\n      v->iov_base = f->f_prevline;\n      v->iov_len = f->f_prevlen;\n    }\n  v++;\n\n  dbg_printf (\"Logging to %s\", TypeNames[f->f_type]);\n\n  switch (f->f_type)\n    {\n    case F_UNUSED:\n      f->f_time = now;\n      dbg_printf (\"\\n\");\n      break;\n\n    case F_FORW_SUSP:\n      fwd_suspend = time ((time_t *) 0) - f->f_time;\n      if (fwd_suspend >= INET_SUSPEND_TIME)\n\t{\n\t  dbg_printf (\"\\nForwarding suspension over, retrying FORW \");\n\t  f->f_type = F_FORW;\n\t  goto f_forw;\n\t}\n      else\n\t{\n\t  dbg_printf (\" %s\\n\", f->f_un.f_forw.f_hname);\n\t  dbg_printf (\"Forwarding suspension not over, time left: %d.\\n\",\n\t\t      INET_SUSPEND_TIME - fwd_suspend);\n\t}\n      break;\n\n    case F_FORW_UNKN:\n      dbg_printf (\" %s\\n\", f->f_un.f_forw.f_hname);\n      fwd_suspend = time ((time_t *) 0) - f->f_time;\n      if (fwd_suspend >= INET_SUSPEND_TIME)\n\t{\n\t  struct addrinfo hints, *rp;\n\t  int err;\n\n\t  memset (&hints, 0, sizeof (hints));\n\t  hints.ai_family = usefamily;\n#ifdef AI_ADDRCONFIG\n\t  if (usefamily == AF_UNSPEC)\n\t    hints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\t  err = getaddrinfo (f->f_un.f_forw.f_hname, LogForwardPort,\n\t\t\t     &hints, &rp);\n\t  if (err)\n\t    {\n\t      dbg_printf (\"Failure: %s\\n\", gai_strerror (err));\n\t      dbg_printf (\"Retries: %d\\n\", f->f_prevcount);\n\t      if (--f->f_prevcount < 0)\n\t\t{\n\t\t  f->f_type = F_UNUSED;\n\t\t  free (f->f_un.f_forw.f_hname);\n\t\t  f->f_un.f_forw.f_hname = NULL;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      dbg_printf (\"%s found, resuming.\\n\", f->f_un.f_forw.f_hname);\n\t      f->f_un.f_forw.f_addrlen = rp->ai_addrlen;\n\t      memcpy (&f->f_un.f_forw.f_addr, rp->ai_addr, rp->ai_addrlen);\n\t      freeaddrinfo (rp);\n\t      f->f_prevcount = 0;\n\t      f->f_type = F_FORW;\n\t      goto f_forw;\n\t    }\n\t}\n      else\n\tdbg_printf (\"Forwarding suspension not over, time left: %d\\n\",\n\t\t    INET_SUSPEND_TIME - fwd_suspend);\n      break;\n\n    case F_FORW:\n    f_forw:\n      dbg_printf (\" %s\\n\", f->f_un.f_forw.f_hname);\n      if (strcasecmp (from, LocalHostName) && NoHops)\n\tdbg_printf (\"Not forwarding remote message.\\n\");\n      else if (NoForward)\n\tdbg_printf (\"Not forwarding because forwarding is disabled.\\n\");\n      else\n\t{\n\t  int temp_finet, *pfinet;\t/* PFINET points to active fd.  */\n\n\t  if (f->f_un.f_forw.f_addr.ss_family == AF_INET)\n\t    pfinet = &finet[IU_FD_IP4];\n\t  else\t/* AF_INET6 */\n\t    pfinet = &finet[IU_FD_IP6];\n\n\t  temp_finet = *pfinet;\n\n\t  if (temp_finet < 0)\n\t    {\n\t      int err;\n\t      struct addrinfo hints, *rp;\n\n\t      /* Forwarding needs a temporary socket.\n\t       * The source port is fixed!  */\n\t      memset (&hints, 0, sizeof (hints));\n\t      hints.ai_family = f->f_un.f_forw.f_addr.ss_family;\n\t      hints.ai_socktype = SOCK_DGRAM;\n\t      hints.ai_flags = AI_PASSIVE;\n\n\t      err = getaddrinfo (NULL, LogForwardPort, &hints, &rp);\n\t      if (err)\n\t\t{\n\t\t  dbg_printf (\"Not forwarding due to lookup failure: %s.\\n\",\n\t\t\t      gai_strerror(err));\n\t\t  break;\n\t\t}\n\t      temp_finet = socket (rp->ai_family, rp->ai_socktype,\n\t\t\t\t   rp->ai_protocol);\n\t      if (temp_finet < 0)\n\t\t{\n\t\t  dbg_printf (\"Not forwarding due to socket failure.\\n\");\n\t\t  freeaddrinfo (rp);\n\t\t  break;\n\t\t}\n\n\t      err = bind (temp_finet, rp->ai_addr, rp->ai_addrlen);\n\t      freeaddrinfo (rp);\n\t      if (err)\n\t\t{\n\t\t  dbg_printf (\"Not forwarding due to bind error: %s.\\n\",\n\t\t\t      strerror (errno));\n\t\t  break;\n\t\t}\n\t    } /* Creation of temporary outgoing socket since \"finet < 0\" */\n\n\t  f->f_time = now;\n\t  snprintf (line, sizeof (line), \"<%d>%.15s %s\",\n\t\t    f->f_prevpri, (char *) iov[0].iov_base,\n\t\t    (char *) iov[4].iov_base);\n\t  l = strlen (line);\n\t  if (l > MAXLINE)\n\t    l = MAXLINE;\n\t  if (sendto (temp_finet, line, l, 0,\n\t\t      (struct sockaddr *) &f->f_un.f_forw.f_addr,\n\t\t      f->f_un.f_forw.f_addrlen) != l)\n\t    {\n\t      int e = errno;\n\t      dbg_printf (\"INET sendto error: %d = %s.\\n\", e, strerror (e));\n\t      f->f_type = F_FORW_SUSP;\n\t      errno = e;\n\t      logerror (\"sendto\");\n\t    }\n\n\t  if (*pfinet < 0)\n\t    close (temp_finet);\t/* Only temporary socket may be closed.  */\n\t}\n      break;\n\n    case F_CONSOLE:\n      f->f_time = now;\n      if (flags & IGN_CONS)\n\t{\n\t  dbg_printf (\" (ignored)\\n\");\n\t  break;\n\t}\n\n    case F_TTY:\n    case F_FILE:\n    case F_PIPE:\n      f->f_time = now;\n      dbg_printf (\" %s\\n\", f->f_un.f_fname);\n      if (f->f_type == F_TTY || f->f_type == F_CONSOLE)\n\t{\n\t  v->iov_base = (char *) \"\\r\\n\";\n\t  v->iov_len = 2;\n\t}\n      else\n\t{\n\t  v->iov_base = (char *) \"\\n\";\n\t  v->iov_len = 1;\n\t}\n    again:\n      if (writev (f->f_file, iov, IOVCNT) < 0)\n\t{\n\t  int e = errno;\n\n\t  /* XXX: If a named pipe is full, ignore it.  */\n\t  if (f->f_type == F_PIPE && e == EAGAIN)\n\t    break;\n\n\t  close (f->f_file);\n\t  /* Check for errors on TTY's due to loss of tty. */\n\t  if ((e == EIO || e == EBADF)\n\t      && (f->f_type == F_TTY || f->f_type == F_CONSOLE))\n\t    {\n\t      f->f_file = open (f->f_un.f_fname, O_WRONLY | O_APPEND, 0);\n\t      if (f->f_file < 0)\n\t\t{\n\t\t  f->f_type = F_UNUSED;\n\t\t  logerror (f->f_un.f_fname);\n\t\t  free (f->f_un.f_fname);\n\t\t  f->f_un.f_fname = NULL;\n\t\t}\n\t      else\n\t\tgoto again;\n\t    }\n\t  else\n\t    {\n\t      f->f_type = F_UNUSED;\n\t      errno = e;\n\t      logerror (f->f_un.f_fname);\n\t      free (f->f_un.f_fname);\n\t      f->f_un.f_fname = NULL;\n\t    }\n\t}\n      else if ((flags & SYNC_FILE) && !(f->f_flags & OMIT_SYNC))\n\tfsync (f->f_file);\n      break;\n\n    case F_USERS:\n    case F_WALL:\n      f->f_time = now;\n      dbg_printf (\"\\n\");\n      v->iov_base = (char *) \"\\r\\n\";\n      v->iov_len = 2;\n      wallmsg (f, iov);\n      break;\n    }\n\n  if (f->f_type != F_FORW_UNKN)\n    f->f_prevcount = 0;\n}",
      "lines": 283,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "wallmsg": {
      "start_point": [
        1598,
        0
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "void\nwallmsg (struct filed *f, struct iovec *iov)\n{\n  static int reenter;\t\t/* Avoid calling ourselves.  */\n  STRUCT_UTMP *utp;\n#if defined UTMP_NAME_FUNCTION || !defined HAVE_GETUTXENT\n  STRUCT_UTMP *utmpbuf;\n  size_t utmp_count;\n#endif /* UTMP_NAME_FUNCTION || !HAVE_GETUTXENT */\n  int i;\n  char *p;\n  char line[sizeof (utp->ut_line) + 1];\n\n  if (reenter++)\n    return;\n\n#if !defined UTMP_NAME_FUNCTION && defined HAVE_GETUTXENT\n  setutxent ();\n\n  while ((utp = getutxent ()))\n#else /* UTMP_NAME_FUNCTION || !HAVE_GETUTXENT */\n  if (read_utmp (UTMP_FILE, &utmp_count, &utmpbuf,\n\t\t READ_UTMP_USER_PROCESS | READ_UTMP_CHECK_PIDS) < 0)\n    {\n      logerror (\"opening utmp file\");\n      return;\n    }\n\n  for (utp = utmpbuf; utp < utmpbuf + utmp_count; utp++)\n#endif /* UTMP_NAME_FUNCTION || !HAVE_GETUTXENT */\n    {\n      strncpy (line, utp->ut_line, sizeof (utp->ut_line));\n      line[sizeof (utp->ut_line)] = '\\0';\n      if (f->f_type == F_WALL)\n\t{\n\t  /* Note we're using our own version of ttymsg\n\t     which does a double fork () to not have\n\t     zombies.  No need to waitpid().  */\n\t  p = ttymsg (iov, IOVCNT, line, TTYMSGTIME);\n\t  if (p != NULL)\n\t    {\n\t      errno = 0;\t/* Already in message. */\n\t      logerror (p);\n\t    }\n\t  continue;\n\t}\n      /* Should we send the message to this user? */\n      for (i = 0; i < f->f_un.f_user.f_nusers; i++)\n\tif (!strncmp (f->f_un.f_user.f_unames[i], UT_USER (utp),\n\t\t      sizeof (UT_USER (utp))))\n\t  {\n\t    p = ttymsg (iov, IOVCNT, line, TTYMSGTIME);\n\t    if (p != NULL)\n\t      {\n\t\terrno = 0;\t/* Already in message. */\n\t\tlogerror (p);\n\t      }\n\t    break;\n\t  }\n    }\n#if defined UTMP_NAME_FUNCTION || !defined HAVE_GETUTXENT\n  free (utmpbuf);\n#else /* !UTMP_NAME_FUNCTION && HAVE_GETUTXENT */\n  endutxent ();\n#endif\n  reenter = 0;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "cvthname": {
      "start_point": [
        1667,
        0
      ],
      "end_point": [
        1730,
        1
      ],
      "content": "const char *\ncvthname (struct sockaddr *f, socklen_t len)\n{\n  int err;\n  char *p;\n\n  err = getnameinfo (f, len, addrstr, sizeof (addrstr),\n\t\t     NULL, 0, NI_NUMERICHOST);\n  if (err)\n    {\n      dbg_printf (\"Malformed from address: %s.\\n\",\n\t\t  gai_strerror (err));\n      return \"???\";\n    }\n\n  dbg_printf (\"cvthname(%s)\\n\", addrstr);\n\n  err = getnameinfo (f, len, addrname, sizeof (addrname),\n\t\t     NULL, 0, NI_NAMEREQD);\n  if (err)\n    {\n      dbg_printf (\"Host name for your address (%s) unknown.\\n\", addrstr);\n      return addrstr;\n    }\n\n  p = strchr (addrname, '.');\n  if (p != NULL)\n    {\n      if (strcasecmp (p + 1, LocalDomain) == 0)\n\t*p = '\\0';\n      else\n\t{\n\t  int count;\n\n\t  if (StripDomains)\n\t    {\n\t      count = 0;\n\t      while (StripDomains[count])\n\t\t{\n\t\t  if (strcasecmp (p + 1, StripDomains[count]) == 0)\n\t\t    {\n\t\t      *p = '\\0';\n\t\t      return addrname;\n\t\t    }\n\t\t  count++;\n\t\t}\n\t    }\n\t  if (LocalHosts)\n\t    {\n\t      count = 0;\n\t      while (LocalHosts[count])\n\t\t{\n\t\t  if (strcasecmp (addrname, LocalHosts[count]) == 0)\n\t\t    {\n\t\t      *p = '\\0';\n\t\t      return addrname;\n\t\t    }\n\t\t  count++;\n\t\t}\n\t    }\n\t}\n    }\n  return addrname;\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ncvthname (struct sockaddr *f, socklen_t len)",
        "*"
      ]
    },
    "domark": {
      "start_point": [
        1732,
        0
      ],
      "end_point": [
        1764,
        1
      ],
      "content": "void\ndomark (int signo _GL_UNUSED_PARAMETER)\n{\n  struct filed *f;\n\n  now = time ((time_t *) NULL);\n  if (MarkInterval > 0)\n    {\n      MarkSeq += TIMERINTVL;\n      if (MarkSeq >= MarkInterval)\n\t{\n\t  logmsg (LOG_INFO, \"-- MARK --\", LocalHostName, ADDDATE | MARK);\n\t  MarkSeq = 0;\n\t}\n    }\n\n  for (f = Files; f; f = f->f_next)\n    {\n      if (f->f_prevcount && now >= REPEATTIME (f))\n\t{\n\t  dbg_printf (\"flush %s: repeated %d times, %d sec.\\n\",\n\t\t      TypeNames[f->f_type], f->f_prevcount,\n\t\t      repeatinterval[f->f_repeatcount]);\n\t  fprintlog (f, LocalHostName, 0, (char *) NULL);\n\t  BACKOFF (f);\n\t}\n    }\n\n#ifndef HAVE_SIGACTION\n  signal (SIGALRM, domark);\n#endif\n  alarm (TIMERINTVL);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "logerror": {
      "start_point": [
        1767,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "void\nlogerror (const char *type)\n{\n  char buf[100];\n\n  if (errno)\n    snprintf (buf, sizeof (buf), \"syslogd: %s: %s\", type, strerror (errno));\n  else\n    snprintf (buf, sizeof (buf), \"syslogd: %s\", type);\n  errno = 0;\n  dbg_printf (\"%s\\n\", buf);\n  logmsg (LOG_SYSLOG | LOG_ERR, buf, LocalHostName, ADDDATE);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "doexit": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1785,
        1
      ],
      "content": "void\ndoexit (int signo _GL_UNUSED_PARAMETER)\n{\n  _exit (EXIT_SUCCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "die": {
      "start_point": [
        1787,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "void\ndie (int signo)\n{\n  struct filed *f;\n  int was_initialized = Initialized;\n  char buf[100];\n  size_t i;\n\n  Initialized = 0;\t\t/* Don't log SIGCHLDs. */\n  for (f = Files; f != NULL; f = f->f_next)\n    {\n      /* Flush any pending output.  */\n      if (f->f_prevcount)\n\tfprintlog (f, LocalHostName, 0, (char *) NULL);\n    }\n  Initialized = was_initialized;\n  if (signo)\n    {\n      dbg_printf (\"%s: exiting on signal %d\\n\",\n                  program_invocation_name, signo);\n      snprintf (buf, sizeof (buf), \"exiting on signal %d\", signo);\n      errno = 0;\n      logerror (buf);\n    }\n\n  if (fklog >= 0)\n    close (fklog);\n\n  for (i = 0; i < nfunix; i++)\n    if (funix[i].fd >= 0)\n      {\n\tclose (funix[i].fd);\n\tif (funix[i].name)\n\t  unlink (funix[i].name);\n      }\n\n  if (finet[IU_FD_IP4] >= 0)\n    close (finet[IU_FD_IP4]);\n  if (finet[IU_FD_IP6] >= 0)\n    close (finet[IU_FD_IP6]);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "load_conffile": {
      "start_point": [
        1834,
        0
      ],
      "end_point": [
        2024,
        1
      ],
      "content": "static int\nload_conffile (const char *filename, struct filed **nextp)\n{\n  FILE *cf;\n  struct filed *f;\n#ifndef LINE_MAX\n# define LINE_MAX 2048\n#endif\n  size_t line_max = LINE_MAX;\n  char *cbuf;\n  char *cline;\n  int cont_line = 0;\n\n  /* Beware: Do not assume *nextp to be NULL.  */\n\n  /* Open the configuration file.  */\n  cf = fopen (filename, \"r\");\n  if (cf == NULL)\n    {\n      dbg_printf (\"cannot open %s\\n\", filename);\n\n      /* Add emergency logging if everything else was missing.  */\n      if (*nextp == NULL)\n\t{\n\t  /* Send LOG_ERR to the system console.  */\n\t  f = (struct filed *) calloc (1, sizeof (*f));\n\t  cfline (\"*.ERR\\t\" PATH_CONSOLE, f);\t\t/* Erases *f!  */\n\n\t  /* Below that, send LOG_EMERG to all users.  */\n\t  f->f_next = (struct filed *) calloc (1, sizeof (*f));\n\t  cfline (\"*.PANIC\\t*\", f->f_next);\t/* Erases *(f->f_next)!  */\n\n\t  *nextp = f;\t/* Return this minimal table to the caller.  */\n\t}\n\n      Initialized = 1;\n      return 1;\n    }\n\n  /* Allocate a buffer for line parsing.  */\n  cbuf = malloc (line_max);\n  if (cbuf == NULL)\n    {\n      /* There is no graceful recovery here.  */\n      dbg_printf (\"cannot allocate space for configuration\\n\");\n      fclose (cf);\n      return 0;\n    }\n  cline = cbuf;\n\n  /* Reset selecting program.  */\n  free (selector);\n  selector = NULL;\n\n  /* Line parsing :\n     - skip comments,\n     - strip off trailing spaces,\n     - skip empty lines,\n     - glob leading spaces,\n     - readjust buffer if line is too big,\n     - deal with continuation lines, last char is '\\' .  */\n  while (fgets (cline, line_max - (cline - cbuf), cf) != NULL)\n    {\n      char *p;\n      size_t len = strlen (cline);\n\n      /* If this is a continuation line, skip leading whitespace for\n         compatibility with sysklogd.  Note that this requires\n         whitespace before the backslash in the previous line if you\n         want to separate the selector from the action.  */\n      if (cont_line)\n\t{\n\t  char *start = cline;\n\t  while (*start == ' ' || *start == '\\t')\n\t    start++;\n\t  len = len - (start - cline);\n\t  memmove (cline, start, len + 1);\n\t  cont_line = 0;\n\t}\n\n      /* No newline, so the line is too big for the buffer.  Readjust.  */\n      if (strchr (cline, '\\n') == NULL)\n\t{\n\t  size_t offset = cline - cbuf;\n\t  char *tmp;\n\t  tmp = realloc (cbuf, line_max * 2);\n\t  if (tmp == NULL)\n\t    {\n\t      /* Sigh ...  */\n\t      dbg_printf (\"cannot allocate space configuration\\n\");\n\t      fclose (cf);\n\t      free (cbuf);\n\t      return 0;\n\t    }\n\t  else\n\t    cbuf = tmp;\n\t  line_max *= 2;\n\t  cline = cbuf + offset + len - 1;\n\t  continue;\n\t}\n      else\n\tcline = cbuf;\n\n      /* Glob the leading spaces.  */\n      for (p = cline; isspace (*p); ++p)\n\t;\n\n      /* Record program selector.\n       *\n       * Acceptable formats are typically:\n       *\n       *   !name\n       *   #! name\n       *   ! *\n       *\n       * The latter is clearing the previous setting.\n       */\n      if (*p == '!' || (*p == '#' && *(p + 1) == '!'))\n\t{\n\t  if (*++p == '!')\n\t    ++p;\n\t  while (isspace (*p))\n\t    ++p;\n\t  if (*p == '\\0')\n\t    continue;\n\n\t  /* Reset previous setting.  */\n\t  free (selector);\n\t  selector = NULL;\n\n\t  if (*p != '*')\n\t    {\n\t      char *sep;\n\n\t      /* BSD systems allow multiple selectors\n\t       * separated by commata.  Strip away any\n\t       * additional names since at this time\n\t       * we only support a single name.\n\t       */\n\t      sep = strchr (p, ',');\n\t      if (sep)\n\t\t*sep = '\\0';\n\n\t      /* Remove trailing whitespace.  */\n\t      sep = strpbrk (p, \" \\t\\n\\r\");\n\t      if (sep)\n\t\t*sep = '\\0';\n\n\t      selector = strdup (p);\n\t    }\n\t  continue;\n\t}\n\n      /* Skip comments and empty line.  */\n      if (*p == '\\0' || *p == '#')\n\tcontinue;\n\n      memmove (cline, p, strlen (p) + 1);\n\n      /* Cut the trailing spaces.  */\n      for (p = strchr (cline, '\\0'); isspace (*--p);)\n\t;\n\n      /* if '\\', indicates continuation on the next line.  */\n      if (*p == '\\\\')\n\t{\n\t  *p = '\\0';\n\t  cline = p;\n\t  cont_line = 1;\n\t  continue;\n\t}\n\n      *++p = '\\0';\n\n      /* Send the line for more parsing.\n       * Then generate the new entry,\n       * inserting it at the head of\n       * the already existing table.\n       */\n      f = (struct filed *) calloc (1, sizeof (*f));\n      cfline (cbuf, f);\t\t\t/* Erases *f!  */\n      f->f_next = *nextp;\n      *nextp = f;\n    }\n\n  /* Close the configuration file.  */\n  fclose (cf);\n  free (cbuf);\n\n  return 1;\n}",
      "lines": 191,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "load_confdir": {
      "start_point": [
        2029,
        0
      ],
      "end_point": [
        2075,
        1
      ],
      "content": "static int\nload_confdir (const char *dirname, struct filed **nextp)\n{\n  int rc = 0, found = 0;\n  struct dirent *dent;\n  DIR *dir;\n\n  dir = opendir (dirname);\n  if (dir == NULL)\n    {\n      dbg_printf (\"cannot open %s\\n\", dirname);\n      return 1;\t\t/* Acceptable deviation.  */\n    }\n\n  while ((dent = readdir (dir)) != NULL)\n    {\n      struct stat st;\n      char *file;\n\n      if (asprintf (&file, \"%s/%s\", dirname, dent->d_name) < 0)\n\t{\n\t  dbg_printf (\"cannot allocate space for configuration filename\\n\");\n\t  return 0;\n\t}\n\n      if (stat (file, &st) != 0)\n\t{\n\t  dbg_printf (\"cannot stat file configuration file\\n\");\n\t  continue;\n\t}\n\n\n      if (S_ISREG(st.st_mode))\n\t{\n\t  found++;\n\t  rc += load_conffile (file, nextp);\n\t}\n\n      free (file);\n    }\n\n  closedir (dir);\n\n  /* An empty directory is acceptable.\n   */\n  return (found ? rc : 1);\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "init": {
      "start_point": [
        2078,
        0
      ],
      "end_point": [
        2182,
        1
      ],
      "content": "void\ninit (int signo _GL_UNUSED_PARAMETER)\n{\n  int rc, ret;\n  struct filed *f, *next, **nextp;\n\n  dbg_printf (\"init\\n\");\n\n  /* Close all open log files.  */\n  Initialized = 0;\n  for (f = Files; f != NULL; f = next)\n    {\n      int j;\n\n      /* Flush any pending output.  */\n      if (f->f_prevcount)\n\tfprintlog (f, LocalHostName, 0, (char *) NULL);\n\n      switch (f->f_type)\n\t{\n\tcase F_FILE:\n\tcase F_TTY:\n\tcase F_CONSOLE:\n\tcase F_PIPE:\n\t  free (f->f_un.f_fname);\n\t  close (f->f_file);\n\t  break;\n\tcase F_FORW:\n\tcase F_FORW_SUSP:\n\tcase F_FORW_UNKN:\n\t  free (f->f_un.f_forw.f_hname);\n\t  break;\n\tcase F_USERS:\n\t  for (j = 0; j < f->f_un.f_user.f_nusers; ++j)\n\t    free (f->f_un.f_user.f_unames[j]);\n\t  free (f->f_un.f_user.f_unames);\n\t  break;\n\t}\n      free (f->f_progname);\n      free (f->f_prevhost);\n      next = f->f_next;\n      free (f);\n    }\n\n  Files = NULL;\t\t/* Empty the table.  */\n  nextp = &Files;\n  facilities_seen = 0;\n\n  rc = load_conffile (ConfFile, nextp);\n\n  ret = load_confdir (ConfDir, nextp);\n  if (!ret)\n    rc = 0;\t\t/* Some allocation errors were found.  */\n\n  Initialized = 1;\n\n  if (Debug)\n    {\n      for (f = Files; f; f = f->f_next)\n\t{\n\t  int i;\n\t  for (i = 0; i <= LOG_NFACILITIES; i++)\n\t    if (f->f_pmask[i] == 0)\n\t      dbg_printf (\" X \");\n\t    else\n\t      dbg_printf (\"%2x \", f->f_pmask[i]);\n\t  dbg_printf (\"%s: \", TypeNames[f->f_type]);\n\t  switch (f->f_type)\n\t    {\n\t    case F_FILE:\n\t    case F_TTY:\n\t    case F_CONSOLE:\n\t    case F_PIPE:\n\t      dbg_printf (\"%s\", f->f_un.f_fname);\n\t      break;\n\n\t    case F_FORW:\n\t    case F_FORW_SUSP:\n\t    case F_FORW_UNKN:\n\t      dbg_printf (\"%s\", f->f_un.f_forw.f_hname);\n\t      break;\n\n\t    case F_USERS:\n\t      for (i = 0; i < f->f_un.f_user.f_nusers; i++)\n\t\tdbg_printf (\"%s, \", f->f_un.f_user.f_unames[i]);\n\t      break;\n\t    }\n\t  dbg_printf (\"\\n\");\n\t}\n    }\n\n  if (AcceptRemote)\n    logmsg (LOG_SYSLOG | LOG_INFO, \"syslogd (\" PACKAGE_NAME\n\t    \" \" PACKAGE_VERSION \"): restart (remote reception)\",\n\t    LocalHostName, ADDDATE);\n  else\n    logmsg (LOG_SYSLOG | LOG_INFO, \"syslogd (\" PACKAGE_NAME\n\t    \" \" PACKAGE_VERSION \"): restart\", LocalHostName, ADDDATE);\n\n  if (!rc)\n    logmsg (LOG_SYSLOG | LOG_ERR, \"syslogd: Incomplete configuration.\",\n\t    LocalHostName, ADDDATE);\n\n  dbg_printf (\"syslogd: restarted\\n\");\n}",
      "lines": 105,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "cfline": {
      "start_point": [
        2185,
        0
      ],
      "end_point": [
        2457,
        1
      ],
      "content": "void\ncfline (const char *line, struct filed *f)\n{\n  struct addrinfo hints, *rp;\n  int i, pri, negate_pri, excl_pri, err;\n  unsigned int pri_set, pri_clear;\n  char *bp;\n  const char *p, *q;\n  char buf[MAXLINE], ebuf[200];\n\n  dbg_printf (\"cfline(%s)%s%s\\n\", line,\n\t      selector ? \" tagged \" : \"\",\n\t      selector ? selector : \"\");\n\n  errno = 0;\t/* keep strerror() stuff out of logerror messages */\n\n  /* Clear out file entry.  */\n  memset (f, 0, sizeof (*f));\n  for (i = 0; i <= LOG_NFACILITIES; i++)\n    {\n      f->f_pmask[i] = 0;\n      f->f_flags = 0;\n    }\n\n  /* Scan through the list of selectors.  */\n  for (p = line; *p && *p != '\\t' && *p != ' ';)\n    {\n\n      /* Find the end of this facility name list.  */\n      for (q = p; *q && *q != '\\t' && *q++ != '.';)\n\tcontinue;\n\n      /* Collect priority name.  */\n      for (bp = buf; *q && !strchr (\"\\t ,;\", *q);)\n\t*bp++ = *q++;\n      *bp = '\\0';\n\n      /* Skip cruft.  */\n      while (*q && strchr (\",;\", *q))\n\tq++;\n\n      bp = buf;\n      negate_pri = excl_pri = 0;\n\n      while (*bp == '!' || *bp == '=')\n\tswitch (*bp++)\n\t  {\n\t  case '!':\n\t    negate_pri = 1;\n\t    break;\n\n\t  case '=':\n\t    excl_pri = 1;\n\t    break;\n\t  }\n\n      /* Decode priority name and set up bit masks.  */\n      if (*bp == '*')\n\t{\n\t  pri_clear = 0;\n\t  pri_set = LOG_UPTO (LOG_PRIMASK);\n\t}\n      else\n\t{\n\t  pri = decode (bp, prioritynames);\n\t  if (pri < 0 || (pri > LOG_PRIMASK && pri != INTERNAL_NOPRI))\n\t    {\n\t      snprintf (ebuf, sizeof (ebuf),\n\t\t\t\"unknown priority name \\\"%s\\\"\", bp);\n\t      logerror (ebuf);\n\t      return;\n\t    }\n\t  if (pri == INTERNAL_NOPRI)\n\t    {\n\t      pri_clear = 255;\n\t      pri_set = 0;\n\t    }\n\t  else\n\t    {\n\t      pri_clear = 0;\n\t      pri_set = excl_pri ? LOG_MASK (pri) : LOG_UPTO (pri);\n\t    }\n\t}\n      if (negate_pri)\n\t{\n\t  unsigned int exchange = pri_set;\n\t  pri_set = pri_clear;\n\t  pri_clear = exchange;\n\t}\n\n      /* Scan facilities.  */\n      while (*p && !strchr (\"\\t .;\", *p))\n\t{\n\t  for (bp = buf; *p && !strchr (\"\\t ,;.\", *p);)\n\t    *bp++ = *p++;\n\t  *bp = '\\0';\n\t  if (*buf == '*')\n\t    for (i = 0; i <= LOG_NFACILITIES; i++)\n\t      {\n\t\t/* make \"**\" act as a wildcard only for facilities not\n\t\t * specified elsewhere\n\t\t */\n\t\tif (buf[1] == '*' && ((1 << i) & facilities_seen))\n\t\t  continue;\n\n\t\tf->f_pmask[i] &= ~pri_clear;\n\t\tf->f_pmask[i] |= pri_set;\n\t      }\n\t  else\n\t    {\n\t      i = decode (buf, facilitynames);\n\n\t      if (i < 0 || i > (LOG_NFACILITIES << 3))\n\t\t{\n\t\t  snprintf (ebuf, sizeof (ebuf),\n\t\t\t    \"unknown facility name \\\"%s\\\"\", buf);\n\t\t  logerror (ebuf);\n\t\t  return;\n\t\t}\n\n\t      f->f_pmask[LOG_FAC (i)] &= ~pri_clear;\n\t      f->f_pmask[LOG_FAC (i)] |= pri_set;\n\n\t      facilities_seen |= (1 << LOG_FAC (i));\n\t    }\n\t  while (*p == ',' || *p == ' ')\n\t    p++;\n\t}\n      p = q;\n    }\n\n  /* Skip to action part.  */\n  while (*p == '\\t' || *p == ' ')\n    p++;\n\n  if (*p == '-')\n    {\n      f->f_flags |= OMIT_SYNC;\n      p++;\n    }\n\n  if (!strlen(p))\n    {\n      /* Invalidate an entry with empty action field.  */\n      f->f_type = F_UNUSED;\n      logerror (\"empty action field\");\n      return;\n    }\n\n  switch (*p)\n    {\n    case '@':\n      f->f_un.f_forw.f_hname = strdup (++p);\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_family = usefamily;\n      hints.ai_socktype = SOCK_DGRAM;\n#ifdef AI_ADDRCONFIG\n      if (usefamily == AF_UNSPEC)\n\thints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\n      f->f_un.f_forw.f_addrlen = 0;\t/* Invalidate address.  */\n      memset (&f->f_un.f_forw.f_addr, 0, sizeof (f->f_un.f_forw.f_addr));\n\n      err = getaddrinfo (p, LogForwardPort, &hints, &rp);\n      if (err)\n\t{\n\t  switch (err)\n\t    {\n\t      case EAI_AGAIN:\t/* Known kinds of temporary error.  */\n\t      case EAI_MEMORY:\n\t\tf->f_type = F_FORW_UNKN;\n\t\tf->f_prevcount = INET_RETRY_MAX;\n\t\tbreak;\n\n\t      case EAI_NONAME:\t/* The most probable causes for failure.  */\n#if defined EAI_NODATA && (EAI_NODATA != EAI_NONAME)\t/* FreeBSD complains.  */\n\t      case EAI_NODATA:\n#endif\n#ifdef EAI_ADDRFAMILY\n\t      case EAI_ADDRFAMILY:\n#endif\n\t      default:\t\t/* Catch system exceptions.  */\n\t\tf->f_type = F_UNUSED;\n\t    }\n\n\t  f->f_time = time ((time_t *) 0);\n\t}\n      else\n\t{\n\t  f->f_type = F_FORW;\n\t  f->f_un.f_forw.f_addrlen = rp->ai_addrlen;\n\t  memcpy (&f->f_un.f_forw.f_addr, rp->ai_addr, rp->ai_addrlen);\n\t  freeaddrinfo (rp);\n\t}\n      break;\n\n    case '|':\n      f->f_un.f_fname = strdup (p);\n      f->f_file = open (++p, O_RDWR | O_NONBLOCK);\n      if (f->f_file < 0)\n\t{\n\t  f->f_type = F_UNUSED;\n\t  logerror (p);\n\t  free (f->f_un.f_fname);\n\t  f->f_un.f_fname = NULL;\n\t  break;\n\t}\n      if (strcmp (p, ctty) == 0)\n\tf->f_type = F_CONSOLE;\n      else if (isatty (f->f_file))\n\tf->f_type = F_TTY;\n      else\n\tf->f_type = F_PIPE;\n      break;\n\n    case '/':\n      f->f_un.f_fname = strdup (p);\n      f->f_file = open (p, O_WRONLY | O_APPEND | O_CREAT, 0644);\n      if (f->f_file < 0)\n\t{\n\t  f->f_type = F_UNUSED;\n\t  logerror (p);\n\t  free (f->f_un.f_fname);\n\t  f->f_un.f_fname = NULL;\n\t  break;\n\t}\n      if (strcmp (p, ctty) == 0)\n\tf->f_type = F_CONSOLE;\n      else if (isatty (f->f_file))\n\tf->f_type = F_TTY;\n      else\n\tf->f_type = F_FILE;\n      break;\n\n    case '*':\n      f->f_type = F_WALL;\n      break;\n\n    default:\n      f->f_un.f_user.f_nusers = 1;\n      for (q = p; *q; q++)\n\tif (*q == ',')\n\t  f->f_un.f_user.f_nusers++;\n      f->f_un.f_user.f_unames =\n\t(char **) malloc (f->f_un.f_user.f_nusers * sizeof (char *));\n      for (i = 0; *p; i++)\n\t{\n\t  for (q = p; *q && *q != ',';)\n\t    q++;\n\t  f->f_un.f_user.f_unames[i] = malloc (q - p + 1);\n\t  if (f->f_un.f_user.f_unames[i])\n\t    {\n\t      strncpy (f->f_un.f_user.f_unames[i], p, q - p);\n\t      f->f_un.f_user.f_unames[i][q - p] = '\\0';\n\t    }\n\t  while (*q == ',' || *q == ' ')\n\t    q++;\n\t  p = q;\n\t}\n      f->f_type = F_USERS;\n      break;\n    }\n\n    /* Set program selector.  */\n    if (selector)\n      {\n\tf->f_progname = strdup (selector);\n\tf->f_prognlen = strlen (selector);\n      }\n    else\n      f->f_progname = NULL;\n}",
      "lines": 273,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "decode": {
      "start_point": [
        2460,
        0
      ],
      "end_point": [
        2473,
        1
      ],
      "content": "int\ndecode (const char *name, CODE * codetab)\n{\n  CODE *c;\n\n  if (isdigit (*name))\n    return atoi (name);\n\n  for (c = codetab; c->c_name; c++)\n    if (!strcasecmp (name, c->c_name))\n      return c->c_val;\n\n  return -1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dbg_toggle": {
      "start_point": [
        2475,
        0
      ],
      "end_point": [
        2488,
        1
      ],
      "content": "void\ndbg_toggle (int signo _GL_UNUSED_PARAMETER)\n{\n  int dbg_save = dbg_output;\n\n  dbg_output = 1;\n  dbg_printf (\"Switching dbg_output to %s.\\n\",\n\t      dbg_save == 0 ? \"true\" : \"false\");\n  dbg_output = (dbg_save == 0) ? 1 : 0;\n\n#ifndef HAVE_SIGACTION\n  signal (SIGUSR1, dbg_toggle);\n#endif\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dbg_printf": {
      "start_point": [
        2491,
        0
      ],
      "end_point": [
        2504,
        1
      ],
      "content": "static void\ndbg_printf (const char *fmt, ...)\n{\n  va_list ap;\n\n  if (!(NoDetach && dbg_output))\n    return;\n\n  va_start (ap, fmt);\n  vfprintf (stdout, fmt, ap);\n  va_end (ap);\n\n  fflush (stdout);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "trigger_restart": {
      "start_point": [
        2511,
        0
      ],
      "end_point": [
        2518,
        1
      ],
      "content": "void\ntrigger_restart (int signo _GL_UNUSED_PARAMETER)\n{\n  restart = 1;\n#ifndef HAVE_SIGACTION\n  signal (SIGHUP, trigger_restart);\n#endif\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "find_inet_port": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2574,
        1
      ],
      "content": "void\nfind_inet_port (const char *port)\n{\n  int err;\n  struct addrinfo hints, *ai;\n\n  /* Fall back to numerical description.  */\n#ifdef IPPORT_SYSLOG\n  snprintf (portstr, sizeof (portstr), \"%u\", IPPORT_SYSLOG);\n  LogForwardPort = portstr;\n#else\n  LogForwardPort = \"514\";\n#endif\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_DGRAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  err = getaddrinfo (NULL, \"syslog\", &hints, &ai);\n  if (err == 0)\n    {\n      LogForwardPort = \"syslog\";\t/* Symbolic name is usable.  */\n      freeaddrinfo (ai);\n    }\n\n  LogPortText = (char *) port;\n\n  if (!LogPortText)\n    {\n      LogPortText = LogForwardPort;\n      return;\n    }\n\n  /* Is the port specified on command line really usable?  */\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_DGRAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  err = getaddrinfo (NULL, LogPortText, &hints, &ai);\n  if (err != 0)\n    {\n      /* Not usable, disable listener.\n       * It is too early to report failure at this time.  */\n      LogPortText = NULL;\n    }\n  else\n    freeaddrinfo (ai);\n\n  return;\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/tftp.c": {
    "get_port": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static in_port_t\nget_port (struct sockaddr_storage *ss)\n{\n  switch (ss->ss_family)\n    {\n    case AF_INET6:\n      return ntohs (((struct sockaddr_in6 *) ss)->sin6_port);\n      break;\n    case AF_INET:\n    default:\n      return ntohs (((struct sockaddr_in *) ss)->sin_port);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "in_port_t"
      ]
    },
    "set_port": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\nset_port (struct sockaddr_storage *ss, in_port_t port)\n{\n  switch (ss->ss_family)\n    {\n    case AF_INET6:\n      ((struct sockaddr_in6 *) ss)->sin6_port = htons(port);\n      break;\n    case AF_INET:\n    default:\n      ((struct sockaddr_in *) ss)->sin_port = htons(port);\n      break;\n    }\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case 'v':\t\t/* Verbose.  */\n      verbose++;\n      break;\n\n    case ARGP_KEY_ARG:\n      if (state->arg_num >= 2 || hostport_argc >= 3)\n\t/* Too many arguments. */\n\targp_usage (state);\n      hostport_argv[hostport_argc++] = arg;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  struct servent *sp;\n\n  set_program_name (argv[0]);\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  iu_argp_init (\"tftp\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  /* Initiate a default port.  */\n  sp = getservbyname (\"tftp\", \"udp\");\n  if (sp == 0)\n    port = 69;\n  else\n    port = ntohs (sp->s_port);\n\n  fromatty = isatty (STDIN_FILENO);\n\n  strcpy (mode, \"netascii\");\n  signal (SIGINT, intr);\n  if (hostport_argc > 1)\n    {\n      if (setjmp (toplevel) != 0)\n\texit (EXIT_SUCCESS);\n      setpeer (hostport_argc, hostport_argv);\n    }\n  if (setjmp (toplevel) != 0)\n    putchar ('\\n');\n  command ();\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "resolve_name": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static int\nresolve_name (char *name)\n{\n  int err;\n  char *rname;\n  struct sockaddr_storage ss;\n  struct addrinfo hints, *ai, *aiptr;\n\n#ifdef HAVE_IDN\n  err = idna_to_ascii_lz (name, &rname, 0);\n  if (err)\n    {\n      fprintf (stderr, \"tftp: %s: %s\\n\", name, idna_strerror (err));\n      return RESOLVE_FAIL;\n    }\n#else /* !HAVE_IDN */\n  rname = name;\n#endif\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_DGRAM;\n  hints.ai_flags = AI_CANONNAME;\n#ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n#endif\n#ifdef AI_CANONIDN\n  hints.ai_flags |= AI_CANONIDN;\n#endif\n\n  err = getaddrinfo (rname, \"tftp\", &hints, &aiptr);\n  if (err)\n    {\n      fprintf (stderr, \"tftp: %s: %s\\n\", rname, gai_strerror (err));\n      return RESOLVE_FAIL;\n    }\n\n#ifdef HAVE_IDN\n  free (rname);\n#endif\n\n  if (f >= 0)\n    {\n      close (f);\n      f = -1;\n    }\n\n  for (ai = aiptr; ai; ai = ai->ai_next)\n    {\n      f = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (f < 0)\n\tcontinue;\n\n      memset (&ss, 0, sizeof (ss));\n      ss.ss_family = ai->ai_family;\n#if HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n      ss.ss_len = ai->ai_addrlen;\n#endif\n      if (bind (f, (struct sockaddr *) &ss, ai->ai_addrlen))\n        {\n\t  close (f);\n\t  f = -1;\n\t  continue;\n\t}\n\n      /* Successfully resolved hostname. */\n      peerlen = ai->ai_addrlen;\n      memcpy (&peeraddr, ai->ai_addr, ai->ai_addrlen);\n      connected = 1;\n      free (hostname);\n      if (ai->ai_canonname)\n\thostname = xstrdup (ai->ai_canonname);\n      else\n\thostname = xstrdup (\"<dummy>\");\n      break;\n    }\n\n  freeaddrinfo (aiptr);\n\n  if (ai == NULL)\n    return RESOLVE_FAIL;\n  else\n    return RESOLVE_OK;\n}",
      "lines": 84,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_args": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static void\nget_args (char *arg0, char *prompt, int *argc, char ***argv)\n{\n  size_t arg0_len = strlen (arg0);\n\n  strcpy (line, arg0);\n  strcat (line, \" \");\n\n  printf (\"%s\", prompt);\n  if (fgets (line + arg0_len + 1, sizeof line - arg0_len - 1, stdin))\n    {\n      makeargv ();\n      *argc = margc;\n      *argv = margv;\n    }\n  else\n    {\n      *argv[0] = arg0;\n      *argc = 1;\t\t/* Will produce a usage printout.  */\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setpeer": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "void\nsetpeer (int argc, char *argv[])\n{\n  if (argc < 2)\n    get_args (\"Connect\", \"(to) \", &argc, &argv);\n\n  if (argc < 2 || argc > 3)\n    {\n      printf (\"usage: %s host-name [port]\\n\", argv[0]);\n      return;\n    }\n\n  switch (resolve_name (argv[1]))\n    {\n    case RESOLVE_OK:\n      break;\n\n    case RESOLVE_FAIL:\n      return;\n    }\n\n  if (argc == 3)\n    {\n      /* Take a user-specified port number.  */\n      port = atoi (argv[2]);\n      if (port <= 0)\n\t{\n\t  printf (\"%s: bad port number\\n\", argv[2]);\n\t  connected = 0;\n\t  return;\n\t}\n    }\n  else\n    {\n      /* Use the standard TFTP port.  */\n      struct servent *sp;\n      sp = getservbyname (\"tftp\", \"udp\");\n      if (sp == 0)\n\terror (EXIT_FAILURE, 0, \"udp/tftp: unknown service\\n\");\n      port = ntohs (sp->s_port);\n    }\n  connected = 1;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "modecmd": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "void\nmodecmd (int argc, char *argv[])\n{\n  register struct modes *p;\n  char *sep;\n\n  if (argc < 2)\n    {\n      printf (\"Using %s mode to transfer files.\\n\", mode);\n      return;\n    }\n  if (argc == 2)\n    {\n      for (p = modes; p->m_name; p++)\n\tif (strcmp (argv[1], p->m_name) == 0)\n\t  break;\n      if (p->m_name)\n\t{\n\t  settftpmode (p->m_mode);\n\t  return;\n\t}\n      printf (\"%s: unknown mode\\n\", argv[1]);\n      /* drop through and print usage message */\n    }\n\n  printf (\"usage: %s [\", argv[0]);\n  sep = \" \";\n  for (p = modes; p->m_name; p++)\n    {\n      printf (\"%s%s\", sep, p->m_name);\n      if (*sep == ' ')\n\tsep = \" | \";\n    }\n  printf (\" ]\\n\");\n  return;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "setbinary": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "void\nsetbinary (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  settftpmode (\"octet\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setascii": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "void\nsetascii (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  settftpmode (\"netascii\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "settftpmode": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "static void\nsettftpmode (char *newmode)\n{\n  strcpy (mode, newmode);\n  if (verbose)\n    printf (\"mode set to %s\\n\", mode);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "put": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "void\nput (int argc, char *argv[])\n{\n  int fd;\n  register int n;\n  register char *cp, *targ;\n\n  if (argc < 2)\n    get_args (\"send\", \"(file) \", &argc, &argv);\n\n  if (argc < 2)\n    {\n      putusage (argv[0]);\n      return;\n    }\n  targ = argv[argc - 1];\n  if (strchr (argv[argc - 1], ':'))\n    {\n      char *cp;\n\n      for (n = 1; n < argc - 1; n++)\n\tif (strchr (argv[n], ':'))\n\t  {\n\t    putusage (argv[0]);\n\t    return;\n\t  }\n      cp = argv[argc - 1];\n      /* Is host string escaped using square brackets?  */\n      if (cp[0] == '[')\n\t{ /* Locate far end.  */\n\t  cp = strchr (cp, ']');\n\t  if (cp == NULL)\n\t    return;\t/* Unpaired bracket.  Fail!  */\n\n\t  /* Erase far end and capture valid host string.  */\n\t  *cp = 0;\n\t  targ = cp + 1;\t/* Position beyond bracket.  */\n\t  cp = argv[argc - 1] + 1;\n\t  /* Verify presence of a colon. Else backup\n\t   * in order to accept a strange file name.  */\n\t  if (targ[0] == ':')\n\t    ++targ;\n\t  else\n\t    {\n\t      targ = argv[argc - 1];\n\t      cp = NULL;\t/* Invalidate host name string.  */\n\t    }\n\t}\n      else\n\t{\n\t  targ = strchr (cp, ':');\n\t  *targ++ = 0;\n\t  /* Test whether host string lacks content.\n\t   * Then the host string will be ignored.  */\n\t  if (strlen (cp) == 0)\n\t    cp = NULL;\t/* Invalidate host name string.  */\n\t}\n      /* If a remote host was stated, resolve it!  */\n      if (cp != NULL && resolve_name (cp) != RESOLVE_OK)\n\treturn;\n    }\n  if (!connected)\n    {\n      printf (\"No target machine specified.\\n\");\n      return;\n    }\n  if (argc < 4)\n    {\n      cp = argc == 2 ? tail (targ) : argv[1];\n      fd = open (cp, O_RDONLY);\n      if (fd < 0)\n\t{\n\t  fprintf (stderr, \"tftp: \");\n\t  perror (cp);\n\t  return;\n\t}\n      if (verbose)\n\tprintf (\"putting %s to %s:%s [%s]\\n\", cp, hostname, targ, mode);\n      set_port (&peeraddr, port);\n      send_file (fd, targ, mode);\n      return;\n    }\n  /* this assumes the target is a directory */\n  /* on a remote unix system.  hmmmm.  */\n  cp = strchr (targ, '\\0');\n  *cp++ = '/';\n  for (n = 1; n < argc - 1; n++)\n    {\n      strcpy (cp, tail (argv[n]));\n      fd = open (argv[n], O_RDONLY);\n      if (fd < 0)\n\t{\n\t  fprintf (stderr, \"tftp: \");\n\t  perror (argv[n]);\n\t  continue;\n\t}\n      if (verbose)\n\tprintf (\"putting %s to %s:%s [%s]\\n\", argv[n], hostname, targ, mode);\n      set_port (&peeraddr, port);\n      send_file (fd, targ, mode);\n    }\n}",
      "lines": 102,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "putusage": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "static void\nputusage (char *s)\n{\n  printf (\"usage: %s file ... host:target, or\\n\", s);\n  printf (\"       %s file ... target (when already connected)\\n\", s);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        741,
        1
      ],
      "content": "void\nget (int argc, char *argv[])\n{\n  int fd;\n  register int n;\n  register char *cp;\n  char *src;\n\n  if (argc < 2)\n    get_args (\"get\", \"(files) \", &argc, &argv);\n\n  if (argc < 2)\n    {\n      getusage (argv[0]);\n      return;\n    }\n  if (!connected)\n    {\n      for (n = 1; n < argc; n++)\n\tif (strchr (argv[n], ':') == 0)\n\t  {\n\t    getusage (argv[0]);\n\t    return;\n\t  }\n    }\n  for (n = 1; n < argc; n++)\n    {\n      src = strchr (argv[n], ':');\n      if (src == NULL)\n\tsrc = argv[n];\n      else if (src == argv[n])\n\t{\n\t  /* Degenerate case: silently drop initial colon.\n\t   * No usable host name.  */\n\t  ++src;\n\t}\n      else\n\t{ /* Parse the host name string; remove square brackets.  */\n\t  cp = argv[n];\n\n\t  if (cp[0] == '[')\n\t    {\n\t      cp = strchr (argv[n], ']');\n\t      if (cp)\n\t\t{\n\t\t  /* Calculate host string and sorce file name.  */\n\t\t  src = cp + 1;\n\t\t  *cp = 0;\n\t\t  if (*src == ':')\n\t\t    ++src;\n\t\t  cp = argv[n] + 1;\n\t\t}\n\t    }\n\t  else\n\t    { /* No escaping; break string at first colon.  */\n\t      *src++ = 0;\n\t    }\n\t  if (cp != NULL && resolve_name (cp) != RESOLVE_OK)\n\t    continue;\n\t}\n\n      if (argc < 4)\n\t{\n\t  cp = argc == 3 ? argv[2] : tail (src);\n\t  fd = creat (cp, 0644);\n\t  if (fd < 0)\n\t    {\n\t      fprintf (stderr, \"tftp: \");\n\t      perror (cp);\n\t      return;\n\t    }\n\t  if (verbose)\n\t    printf (\"getting from %s:%s to %s [%s]\\n\",\n\t\t    hostname, src, cp, mode);\n\t  set_port (&peeraddr, port);\n\t  recvfile (fd, src, mode);\n\t  break;\n\t}\n      cp = tail (src);\t\t/* new .. jdg */\n      fd = creat (cp, 0644);\n      if (fd < 0)\n\t{\n\t  fprintf (stderr, \"tftp: \");\n\t  perror (cp);\n\t  continue;\n\t}\n      if (verbose)\n\tprintf (\"getting from %s:%s to %s [%s]\\n\", hostname, src, cp, mode);\n      set_port (&peeraddr, port);\n      recvfile (fd, src, mode);\n    }\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "getusage": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "static void\ngetusage (char *s)\n{\n  printf (\"usage: %s host:file host:file ... file, or\\n\", s);\n  printf (\"       %s file file ... file if connected\\n\", s);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setrexmt": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "void\nsetrexmt (int argc, char *argv[])\n{\n  int t;\n\n  if (argc < 2)\n    get_args (\"Rexmt-timeout\", \"(value) \", &argc, &argv);\n\n  if (argc != 2)\n    {\n      printf (\"usage: %s value\\n\", argv[0]);\n      return;\n    }\n  t = atoi (argv[1]);\n  if (t < 0)\n    printf (\"%s: bad value\\n\", argv[1]);\n  else\n    rexmtval = t;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "settimeout": {
      "start_point": [
        770,
        0
      ],
      "end_point": [
        788,
        1
      ],
      "content": "void\nsettimeout (int argc, char *argv[])\n{\n  int t;\n\n  if (argc < 2)\n    get_args (\"Maximum-timeout\", \"(value) \", &argc, &argv);\n\n  if (argc != 2)\n    {\n      printf (\"usage: %s value\\n\", argv[0]);\n      return;\n    }\n  t = atoi (argv[1]);\n  if (t < 0)\n    printf (\"%s: bad value\\n\", argv[1]);\n  else\n    maxtimeout = t;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "status": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "void\nstatus (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    printf (\"Connected to %s.\\n\", hostname);\n  else\n    printf (\"Not connected.\\n\");\n  printf (\"Mode: %s Verbose: %s Tracing: %s\\n\", mode,\n\t  verbose ? \"on\" : \"off\", trace ? \"on\" : \"off\");\n  printf (\"Rexmt-interval: %d seconds, Max-timeout: %d seconds\\n\",\n\t  rexmtval, maxtimeout);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "intr": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "void\nintr (int signo _GL_UNUSED_PARAMETER)\n{\n  signal (SIGALRM, SIG_IGN);\n  alarm (0);\n  longjmp (toplevel, -1);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "tail": {
      "start_point": [
        811,
        0
      ],
      "end_point": [
        826,
        1
      ],
      "content": "char *\ntail (char *filename)\n{\n  register char *s;\n\n  while (*filename)\n    {\n      s = strrchr (filename, '/');\n      if (s == NULL)\n\tbreak;\n      if (s[1])\n\treturn (s + 1);\n      *s = '\\0';\n    }\n  return filename;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "char",
        "*\ntail (char *filename)",
        "*"
      ]
    },
    "command": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "static void\ncommand (void)\n{\n  register struct cmd *c;\n\n  for (;;)\n    {\n      if (fromatty)\n\tprintf (\"%s> \", prompt);\n      if (fgets (line, sizeof line, stdin) == 0)\n\t{\n\t  if (feof (stdin))\n\t    exit (EXIT_SUCCESS);\n\t  else\n\t    continue;\n\t}\n      if (line[0] == 0)\n\tcontinue;\n      makeargv ();\n      if (margc == 0)\n\tcontinue;\n      c = getcmd (margv[0]);\n      if (c == (struct cmd *) -1)\n\t{\n\t  printf (\"?Ambiguous command\\n\");\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command\\n\");\n\t  continue;\n\t}\n      (*c->handler) (margc, margv);\n    }\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getcmd": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "struct cmd *\ngetcmd (register char *name)\n{\n  register char *p, *q;\n  register struct cmd *c, *found;\n  register int nmatches, longest;\n\n  longest = 0;\n  nmatches = 0;\n  found = 0;\n  for (c = cmdtab; (p = c->name) != NULL; c++)\n    {\n      for (q = name; *q == *p++; q++)\n\tif (*q == 0)\t\t/* exact match? */\n\t  return (c);\n\n      if (!*q)\n\t{\t\t\t/* the name was a prefix */\n\t  if (q - name > longest)\n\t    {\n\t      longest = q - name;\n\t      nmatches = 1;\n\t      found = c;\n\t    }\n\t  else if (q - name == longest)\n\t    nmatches++;\n\t}\n    }\n  if (nmatches > 1)\n    return (struct cmd *) -1;\n  return found;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "struct cmd",
        "struct",
        "cmd",
        "*\ngetcmd (register char *name)",
        "*"
      ]
    },
    "makeargv": {
      "start_point": [
        903,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "static void\nmakeargv (void)\n{\n  register char *cp;\n  register char **argp = margv;\n\n  margc = 0;\n  for (cp = line; *cp;)\n    {\n      while (isspace (*cp))\n\tcp++;\n      if (*cp == '\\0')\n\tbreak;\n      *argp++ = cp;\n      margc += 1;\n      while (*cp != '\\0' && !isspace (*cp))\n\tcp++;\n      if (*cp == '\\0')\n\tbreak;\n      *cp++ = '\\0';\n    }\n  *argp++ = 0;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "quit": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "void\nquit (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  exit (EXIT_SUCCESS);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "help": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        962,
        1
      ],
      "content": "void\nhelp (int argc, char *argv[])\n{\n  register struct cmd *c;\n\n  if (argc == 1)\n    {\n      printf (\"Commands may be abbreviated.  Commands are:\\n\\n\");\n      for (c = cmdtab; c->name; c++)\n\tprintf (\"%-*s\\t%s\\n\", (int) HELPINDENT, c->name, c->help);\n      return;\n    }\n\n  while (--argc > 0)\n    {\n      register char *arg;\n\n      arg = *++argv;\n      c = getcmd (arg);\n      if (c == (struct cmd *) -1)\n\tprintf (\"?Ambiguous help command %s\\n\", arg);\n      else if (c == (struct cmd *) 0)\n\tprintf (\"?Invalid help command %s\\n\", arg);\n      else\n\tprintf (\"%s\\n\", c->help);\n    }\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "settrace": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        969,
        1
      ],
      "content": "void\nsettrace (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  trace = !trace;\n  printf (\"Packet tracing %s.\\n\", trace ? \"on\" : \"off\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "setverbose": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "void\nsetverbose (int argc _GL_UNUSED_PARAMETER, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  verbose = !verbose;\n  printf (\"Verbose mode %s.\\n\", verbose ? \"on\" : \"off\");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "send_file": {
      "start_point": [
        981,
        0
      ],
      "end_point": [
        1089,
        1
      ],
      "content": "void\nsend_file (int fd, char *name, char *mode)\n{\n  register struct tftphdr *ap;\t/* data and ack packets */\n  struct tftphdr *r_init (void), *dp;\n  register int n;\n  volatile int block, size, convert;\n  volatile unsigned long amount;\n  struct sockaddr_storage from;\n  socklen_t fromlen;\n  FILE *file;\n\n  startclock ();\t\t/* start stat's clock */\n  dp = r_init ();\t\t/* reset fillbuf/read-ahead code */\n  ap = (struct tftphdr *) ackbuf;\n  file = fdopen (fd, \"r\");\n  convert = !strcmp (mode, \"netascii\");\n  block = 0;\n  amount = 0;\n\n  signal (SIGALRM, timer);\n  do\n    {\n      if (block == 0)\n\tsize = makerequest (WRQ, name, dp, mode) - 4;\n      else\n\t{\n\t  /*      size = read(fd, dp->th_data, SEGSIZE);   */\n\t  size = readit (file, &dp, convert);\n\t  if (size < 0)\n\t    {\n\t      nak (errno + 100);\n\t      break;\n\t    }\n\t  dp->th_opcode = htons ((unsigned short) DATA);\n\t  dp->th_block = htons ((unsigned short) block);\n\t}\n      timeout = 0;\n      setjmp (timeoutbuf);\n\n    send_data:\n      if (trace)\n\ttpacket (\"sent\", dp, size + 4);\n      n = sendto (f, (const char *) dp, size + 4, 0,\n\t\t  (struct sockaddr *) &peeraddr, peerlen);\n      if (n != size + 4)\n\t{\n\t  perror (\"tftp: sendto\");\n\t  goto abort;\n\t}\n      read_ahead (file, convert);\n\n      for (;;)\n\t{\n\t  alarm (rexmtval);\n\t  do\n\t    {\n\t      fromlen = sizeof (from);\n\t      n = recvfrom (f, ackbuf, sizeof (ackbuf), 0,\n\t\t\t    (struct sockaddr *) &from, &fromlen);\n\t    }\n\t  while (n <= 0);\n\t  alarm (0);\n\t  if (n < 0)\n\t    {\n\t      perror (\"tftp: recvfrom\");\n\t      goto abort;\n\t    }\n\t  set_port (&peeraddr, get_port (&from));\n\t  if (trace)\n\t    tpacket (\"received\", ap, n);\n\t  /* should verify packet came from server */\n\t  ap->th_opcode = ntohs (ap->th_opcode);\n\t  ap->th_block = ntohs (ap->th_block);\n\t  if (ap->th_opcode == ERROR)\n\t    {\n\t      printf (\"Error code %d: %s\\n\", ap->th_code, ap->th_msg);\n\t      goto abort;\n\t    }\n\t  if (ap->th_opcode == ACK)\n\t    {\n\t      int j;\n\n\t      if (ap->th_block == block)\n\t\tbreak;\n\n\t      /* On an error, try to synchronize\n\t       * both sides.\n\t       */\n\t      j = synchnet (f);\n\t      if (j && trace)\n\t\tprintf (\"discarded %d packets\\n\", j);\n\n\t      if (ap->th_block == (block - 1))\n\t\tgoto send_data;\n\t    }\n\t}\n      if (block > 0)\n\tamount += size;\n      block++;\n    }\n  while (size == SEGSIZE || block == 1);\n\nabort:\n  fclose (file);\n  stopclock ();\n  if (amount > 0)\n    printstats (\"Sent\", amount);\n}",
      "lines": 109,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "recvfile": {
      "start_point": [
        1094,
        0
      ],
      "end_point": [
        1212,
        1
      ],
      "content": "void\nrecvfile (int fd, char *name, char *mode)\n{\n  register struct tftphdr *ap;\n  struct tftphdr *dp, *w_init (void);\n  register int n;\n  volatile int block, size, firsttrip;\n  volatile unsigned long amount;\n  struct sockaddr_storage from;\n  socklen_t fromlen;\n  FILE *file;\n  volatile int convert;\t\t/* true if converting crlf -> lf */\n\n  startclock ();\n  dp = w_init ();\n  ap = (struct tftphdr *) ackbuf;\n  file = fdopen (fd, \"w\");\n  convert = !strcmp (mode, \"netascii\");\n  block = 1;\n  firsttrip = 1;\n  amount = 0;\n\n  signal (SIGALRM, timer);\n  do\n    {\n      if (firsttrip)\n\t{\n\t  size = makerequest (RRQ, name, ap, mode);\n\t  firsttrip = 0;\n\t}\n      else\n\t{\n\t  ap->th_opcode = htons ((unsigned short) ACK);\n\t  ap->th_block = htons ((unsigned short) (block));\n\t  size = 4;\n\t  block++;\n\t}\n      timeout = 0;\n      setjmp (timeoutbuf);\n\n    send_ack:\n      if (trace)\n\ttpacket (\"sent\", ap, size);\n      if (sendto (f, ackbuf, size, 0, (struct sockaddr *) &peeraddr,\n\t\t  peerlen) != size)\n\t{\n\t  alarm (0);\n\t  perror (\"tftp: sendto\");\n\t  goto abort;\n\t}\n      write_behind (file, convert);\n\n      for (;;)\n\t{\n\t  alarm (rexmtval);\n\t  do\n\t    {\n\t      fromlen = sizeof (from);\n\t      n = recvfrom (f, (char *) dp, PKTSIZE, 0,\n\t\t\t    (struct sockaddr *) &from, &fromlen);\n\t    }\n\t  while (n <= 0);\n\n\t  alarm (0);\n\t  if (n < 0)\n\t    {\n\t      perror (\"tftp: recvfrom\");\n\t      goto abort;\n\t    }\n\t  set_port (&peeraddr, get_port (&from));\n\t  if (trace)\n\t    tpacket (\"received\", dp, n);\n\t  /* should verify client address */\n\t  dp->th_opcode = ntohs (dp->th_opcode);\n\t  dp->th_block = ntohs (dp->th_block);\n\t  if (dp->th_opcode == ERROR)\n\t    {\n\t      printf (\"Error code %d: %s\\n\", dp->th_code, dp->th_msg);\n\t      goto abort;\n\t    }\n\t  if (dp->th_opcode == DATA)\n\t    {\n\t      int j;\n\n\t      if (dp->th_block == block)\n\t\tbreak;\t\t/* have next packet */\n\n\t      /* On an error, try to synchronize\n\t       * both sides.\n\t       */\n\t      j = synchnet (f);\n\t      if (j && trace)\n\t\tprintf (\"discarded %d packets\\n\", j);\n\n\t      if (dp->th_block == (block - 1))\n\t\tgoto send_ack;\t/* resend ack */\n\t    }\n\t}\n      /*      size = write(fd, dp->th_data, n - 4); */\n      size = writeit (file, &dp, n - 4, convert);\n      if (size < 0)\n\t{\n\t  nak (errno + 100);\n\t  break;\n\t}\n      amount += size;\n    }\n  while (size == SEGSIZE);\n\nabort:\t\t\t\t/* ok to ack, since user */\n  ap->th_opcode = htons ((unsigned short) ACK);\t/* has seen err msg */\n  ap->th_block = htons ((unsigned short) block);\n  sendto (f, ackbuf, 4, 0, (struct sockaddr *) &peeraddr, peerlen);\n  write_behind (file, convert);\t/* flush last buffer */\n  fclose (file);\n  stopclock ();\n  if (amount > 0)\n    printstats (\"Received\", amount);\n}",
      "lines": 119,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "makerequest": {
      "start_point": [
        1214,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "static int\nmakerequest (int request, const char *name, struct tftphdr *tp,\n\t     const char *mode)\n{\n  register char *cp;\n  size_t arglen, len;\n\n  tp->th_opcode = htons ((unsigned short) request);\n#if HAVE_STRUCT_TFTPHDR_TH_U\n  /*\n   * GNU and BSD essentially, i.e. modulo a macro, define\n   * 'tftphdr.th_stuff' as a character array of length\n   * naught with GNU, and one with BSD!\n   *\n   * When compiling with stack protectors, like during\n   * hardened builds in Debian, every useful file name\n   * will overflow that limit.  However, our code ensures\n   * '*tp' to be of length PKTSIZE.  Assigning CP via an\n   * offset calculation avoids this issue.\n   */\n  cp = (char *) tp + (tp->th_stuff - (char *) tp);\n#else\n  cp = (char *) &(tp->th_stuff);\n#endif\n\n  /* Available space for naming the target file.  */\n  len = PKTSIZE - sizeof (struct tftphdr) - sizeof (\"netascii\");\n  arglen = strlen (name);\n\n  strncpy (cp, name, len);\n\n  cp += (arglen < len) ? arglen : len;\n  *cp++ = '\\0';\n\n  /* Mode is either \"netascii\" or \"octet\", so is always fits\n   * based on our choice of LEN.  */\n  strcpy (cp, mode);\n  cp += strlen (mode);\n  *cp++ = '\\0';\n  return cp - (char *) tp;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nak": {
      "start_point": [
        1279,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "static void\nnak (int error)\n{\n  register struct errmsg *pe;\n  register struct tftphdr *tp;\n  int length;\n\n  tp = (struct tftphdr *) ackbuf;\n  tp->th_opcode = htons ((unsigned short) ERROR);\n  tp->th_code = htons ((unsigned short) error);\n  for (pe = errmsgs; pe->e_code >= 0; pe++)\n    if (pe->e_code == error)\n      break;\n\n  if (pe->e_code < 0)\n    {\n      pe->e_msg = strerror (error - 100);\n      tp->th_code = EUNDEF;\n    }\n  strcpy (tp->th_msg, pe->e_msg);\n  length = strlen (pe->e_msg) + 4;\n  if (trace)\n    tpacket (\"sent\", tp, length);\n  if (sendto (f, ackbuf, length, 0, (struct sockaddr *) &peeraddr,\n\t      peerlen) != length)\n    perror (\"nak\");\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tpacket": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static void\ntpacket (const char *s, struct tftphdr *tp, int n)\n{\n  static char *opcodes[] = { \"#0\", \"RRQ\", \"WRQ\", \"DATA\", \"ACK\", \"ERROR\" };\n  register char *cp, *file;\n  unsigned short op = ntohs (tp->th_opcode);\n\n  if (op < RRQ || op > ERROR)\n    printf (\"%s opcode=%x \", s, op);\n  else\n    printf (\"%s %s \", s, opcodes[op]);\n  switch (op)\n    {\n    case RRQ:\n    case WRQ:\n      n -= 2;\n#if HAVE_STRUCT_TFTPHDR_TH_U\n      file = cp = tp->th_stuff;\n#else\n      file = cp = (char *) &(tp->th_stuff);\n#endif\n      cp = strchr (cp, '\\0');\n      printf (\"<file=%s, mode=%s>\\n\", file, cp + 1);\n      break;\n\n    case DATA:\n      printf (\"<block=%d, %d bytes>\\n\", ntohs (tp->th_block), n - 4);\n      break;\n\n    case ACK:\n      printf (\"<block=%d>\\n\", ntohs (tp->th_block));\n      break;\n\n    case ERROR:\n      printf (\"<code=%d, msg=%s>\\n\", ntohs (tp->th_code), tp->th_msg);\n      break;\n    }\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "startclock": {
      "start_point": [
        1349,
        0
      ],
      "end_point": [
        1353,
        1
      ],
      "content": "static void\nstartclock (void)\n{\n  gettimeofday (&tstart, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stopclock": {
      "start_point": [
        1355,
        0
      ],
      "end_point": [
        1359,
        1
      ],
      "content": "static void\nstopclock (void)\n{\n  gettimeofday (&tstop, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printstats": {
      "start_point": [
        1361,
        0
      ],
      "end_point": [
        1374,
        1
      ],
      "content": "static void\nprintstats (const char *direction, unsigned long amount)\n{\n  double delta;\n\n  /* compute delta in 1/10's second units */\n  delta = ((tstop.tv_sec * 10.) + (tstop.tv_usec / 100000)) -\n    ((tstart.tv_sec * 10.) + (tstart.tv_usec / 100000));\n  delta = delta / 10.;\t\t/* back to seconds */\n  printf (\"%s %d bytes in %.1f seconds\", direction, (int) amount, delta);\n  if (verbose)\n    printf (\" [%.0f bits/sec]\", (amount * 8.) / delta);\n  putchar ('\\n');\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "timer": {
      "start_point": [
        1376,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "static void\ntimer (int sig _GL_UNUSED_PARAMETER)\n{\n  timeout += rexmtval;\n  if (timeout >= maxtimeout)\n    {\n      printf (\"Transfer timed out.\\n\");\n      longjmp (toplevel, -1);\n    }\n  longjmp (timeoutbuf, 1);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/tftpd.c": {
    "parse_opt": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'l':\n      logging = 1;\n      break;\n\n    case 'g':\n      free (group);\n      group = xstrdup (arg);\n      break;\n\n    case 'n':\n      suppress_naks = 1;\n      break;\n\n    case 's':\n      chrootdir = xstrdup (arg);\n      break;\n\n    case 'u':\n      free (user);\n      user = xstrdup (arg);\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n  register struct tftphdr *tp;\n  int on, n;\n  struct sockaddr_storage sin;\n\n  user = xstrdup (DEFAULT_USER);\n\n  set_program_name (argv[0]);\n  iu_argp_init (\"tftpd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  openlog (\"tftpd\", LOG_PID, LOG_FTP);\n\n  if (index < argc)\n    {\n      struct dirlist *dirp;\n\n      /* Get list of directory prefixes. Skip relative pathnames. */\n      for (dirp = dirs; index < argc && dirp < &dirs[MAXDIRS]; index++)\n\t{\n\t  if (argv[index][0] == '/')\n\t    {\n\t      dirp->name = argv[index];\n\t      dirp->len = strlen (dirp->name);\n\t      dirp++;\n\t    }\n\t}\n    }\n\n  on = 1;\n  if (ioctl (0, FIONBIO, &on) < 0)\n    {\n      syslog (LOG_ERR, \"ioctl(FIONBIO): %m\");\n      exit (EXIT_FAILURE);\n    }\n\n  fromlen = sizeof (from);\n  n = recvfrom (0, buf, sizeof (buf), 0, (struct sockaddr *) &from, &fromlen);\n  if (n < 0)\n    {\n      syslog (LOG_ERR, \"recvfrom: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n  /*\n   * Now that we have read the message out of the UDP\n   * socket, we fork and exit.  Thus, inetd will go back\n   * to listening to the tftp port, and the next request\n   * to come in will start up a new instance of tftpd.\n   *\n   * We do this so that inetd can run tftpd in \"wait\" mode.\n   * The problem with tftpd running in \"nowait\" mode is that\n   * inetd may get one or more successful \"selects\" on the\n   * tftp port before we do our receive, so more than one\n   * instance of tftpd may be started up.  Worse, if tftpd\n   * break before doing the above \"recvfrom\", inetd would\n   * spawn endless instances, clogging the system.\n   */\n  {\n    int pid;\n    int i;\n    socklen_t j;\n\n    for (i = 1; i < 20; i++)\n      {\n\tpid = fork ();\n\tif (pid < 0)\n\t  {\n\t    sleep (i);\n\t    /*\n\t     * flush out to most recently sent request.\n\t     *\n\t     * This may drop some request, but those\n\t     * will be resent by the clients when\n\t     * they timeout.  The positive effect of\n\t     * this flush is to (try to) prevent more\n\t     * than one tftpd being started up to service\n\t     * a single request from a single client.\n\t     */\n\t    j = sizeof from;\n\t    i = recvfrom (0, buf, sizeof (buf), 0,\n\t\t\t  (struct sockaddr *) &from, &j);\n\t    if (i > 0)\n\t      {\n\t\tn = i;\n\t\tfromlen = j;\n\t      }\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    if (pid < 0)\n      {\n\tsyslog (LOG_ERR, \"fork: %m\\n\");\n\texit (EXIT_FAILURE);\n      }\n    else if (pid != 0)\n      {\n\texit (EXIT_SUCCESS);\n      }\n  }\n\n  alarm (0);\n  close (0);\n  close (1);\n\n  /* The peer's address 'from' is valid at this point.\n   * 'from.ss_family' contains the correct address\n   * family for any callback connection, and 'fromlen'\n   * is the length of the corresponding address structure.  */\n  peer = socket (from.ss_family, SOCK_DGRAM, 0);\n  if (peer < 0)\n    {\n      syslog (LOG_ERR, \"socket: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n  memset (&sin, 0, sizeof (sin));\n  sin.ss_family = from.ss_family;\n#if HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN\n  sin.ss_len = from.ss_len;\n#endif\n  if (bind (peer, (struct sockaddr *) &sin, fromlen) < 0)\n    {\n      syslog (LOG_ERR, \"bind: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (chrootdir && *chrootdir)\n    {\n      struct passwd *pwd = NULL;\n      struct group *grp = NULL;\n\n      /* Ignore user and group setting for non-root invocations.  */\n      if (!getuid())\n\t{\n\t  pwd = getpwnam (user);\n\t  if (!pwd)\n\t    {\n\t      syslog (LOG_ERR, \"getpwnam('%s'): %m\", user);\n\t      nak (ENOUSER);\n\t      exit (EXIT_FAILURE);\n\t    }\n\n\t  /* Group names are not portable enough to allow\n\t   * for a preset value.  The server inherits\n\t   * group membership from owner, in other cases.\n\t   */\n\t  if (group && *group)\n\t    {\n\t      grp = getgrnam (group);\n\t      if (!grp)\n\t\t{\n\t\t  syslog (LOG_ERR, \"getgrnam('%s'): %m\", group);\n\t\t  nak (ENOUSER);\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t    }\n\t}\n\n      if (chroot (chrootdir) || chdir (\"/\"))\n\t{\n\t  syslog (LOG_ERR, \"chroot('%s'): %m\", chrootdir);\n\t  nak (EACCESS);\n\t  exit (EXIT_FAILURE);\n\t}\n\n      if (pwd)\n\t{\n\t  if (grp)\n\t    {\n\t      if (setgid (grp->gr_gid))\n\t\t{\n\t\t  syslog (LOG_ERR, \"setgid: %m\");\n\t\t  nak (ENOUSER);\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (setgid (pwd->pw_gid))\n\t\t{\n\t\t  syslog (LOG_ERR, \"setgid: %m\");\n\t\t  nak (ENOUSER);\n\t\t  exit (EXIT_FAILURE);\n\t\t}\n\t    }\n\n\t  if (setuid (pwd->pw_uid))\n\t    {\n\t      syslog (LOG_ERR, \"setuid: %m\");\n\t      nak (ENOUSER);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n    }\n\n  tp = (struct tftphdr *) buf;\n  tp->th_opcode = ntohs (tp->th_opcode);\n  if (tp->th_opcode == RRQ || tp->th_opcode == WRQ)\n    tftp (tp, n);\n  exit (EXIT_FAILURE);\n}",
      "lines": 206,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "tftp": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "void\ntftp (struct tftphdr *tp, int size)\n{\n  register char *cp;\n  int first = 1, ecode;\n  register struct formats *pf;\n  char *filename, *mode;\n\n#if HAVE_STRUCT_TFTPHDR_TH_U\n  filename = cp = tp->th_stuff;\n#else\n  filename = cp = (char *) &(tp->th_stuff);\n#endif\nagain:\n  while (cp < buf + size)\n    {\n      if (*cp == '\\0')\n\tbreak;\n      cp++;\n    }\n  if (*cp != '\\0')\n    {\n      nak (EBADOP);\n      exit (EXIT_FAILURE);\n    }\n  if (first)\n    {\n      mode = ++cp;\n      first = 0;\n      goto again;\n    }\n  for (cp = mode; *cp; cp++)\n    if (isupper (*cp))\n      *cp = tolower (*cp);\n  for (pf = formats; pf->f_mode; pf++)\n    if (strcmp (pf->f_mode, mode) == 0)\n      break;\n  if (pf->f_mode == 0)\n    {\n      nak (EBADOP);\n      exit (EXIT_FAILURE);\n    }\n  ecode = (*pf->f_validate) (&filename, tp->th_opcode);\n  if (logging)\n    {\n      char *family;\n\n      switch (from.ss_family)\n\t{\n\tcase AF_INET:\n\t  family = \"IPv4\";\n\t  break;\n\tcase AF_INET6:\n\t  /* Should mapped IPv4 addresses be reported?  */\n\t  family = \"IPv6\";\n\t  break;\n\tdefault:\n\t  family = \"?\";\n\t}\n      syslog (LOG_INFO, \"%s (%s): %s request for %s: %s\",\n\t      verifyhost (&from, fromlen), family,\n\t      tp->th_opcode == WRQ ? \"write\" : \"read\",\n\t      filename, errtomsg (ecode));\n    }\n  if (ecode)\n    {\n      /*\n       * Avoid storms of naks to a RRQ broadcast for a relative\n       * bootfile pathname from a diskless Sun.\n       */\n      if (suppress_naks && *filename != '/' && ecode == ENOTFOUND)\n\texit (EXIT_SUCCESS);\n      nak (ecode);\n      exit (EXIT_FAILURE);\n    }\n  if (tp->th_opcode == WRQ)\n    (*pf->f_recv) (pf);\n  else\n    (*pf->f_send) (pf);\n  exit (EXIT_SUCCESS);\n}",
      "lines": 81,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "validate_access": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nvalidate_access (char **filep, int mode)\n{\n  struct stat stbuf;\n  int fd;\n  struct dirlist *dirp;\n  static char *pathname = 0;\n  char *filename = *filep;\n\n  /*\n   * Prevent tricksters from getting around the directory restrictions\n   */\n  if (strstr (filename, \"/../\"))\n    return (EACCESS);\n\n  if (*filename == '/')\n    {\n      /*\n       * Allow the request if it's in one of the approved locations.\n       * Special case: check the null prefix (\"/\") by looking\n       * for length = 1 and relying on the arg. processing that\n       * it's a /.\n       */\n      for (dirp = dirs; dirp->name != NULL; dirp++)\n\t{\n\t  if (dirp->len == 1 ||\n\t      (!strncmp (filename, dirp->name, dirp->len) &&\n\t       filename[dirp->len] == '/'))\n\t    break;\n\t}\n      /* If directory list is empty, allow access to any file */\n      if (dirp->name == NULL && dirp != dirs)\n\treturn (EACCESS);\n      if (stat (filename, &stbuf) < 0)\n\treturn (errno == ENOENT ? ENOTFOUND : EACCESS);\n      if ((stbuf.st_mode & S_IFMT) != S_IFREG)\n\treturn (ENOTFOUND);\n      if (mode == RRQ)\n\t{\n\t  if ((stbuf.st_mode & S_IROTH) == 0)\n\t    return (EACCESS);\n\t}\n      else\n\t{\n\t  if ((stbuf.st_mode & S_IWOTH) == 0)\n\t    return (EACCESS);\n\t}\n    }\n  else\n    {\n      int err;\n\n      /*\n       * Relative file name: search the approved locations for it.\n       * Don't allow write requests or ones that avoid directory\n       * restrictions.\n       */\n\n      if (mode != RRQ || !strncmp (filename, \"../\", 3))\n\treturn (EACCESS);\n\n      /*\n       * If the file exists in one of the directories and isn't\n       * readable, continue looking. However, change the error code\n       * to give an indication that the file exists.\n       */\n      err = ENOTFOUND;\n      for (dirp = dirs; dirp->name != NULL; dirp++)\n\t{\n\t  free (pathname);\n\t  pathname = malloc (strlen (dirp->name) + 1 + strlen (filename) + 1);\n\t  if (!pathname)\n\t    return ENOMEM;\n\t  sprintf (pathname, \"%s/%s\", dirp->name, filename);\n\t  if (stat (pathname, &stbuf) == 0 &&\n\t      (stbuf.st_mode & S_IFMT) == S_IFREG)\n\t    {\n\t      if ((stbuf.st_mode & S_IROTH) != 0)\n\t\t{\n\t\t  break;\n\t\t}\n\t      err = EACCESS;\n\t    }\n\t}\n      if (dirp->name == NULL)\n\treturn (err);\n      *filep = filename = pathname;\n    }\n  fd = open (filename, mode == RRQ ? O_RDONLY : (O_WRONLY | O_TRUNC));\n  if (fd < 0)\n    return (errno + 100);\n  file = fdopen (fd, (mode == RRQ) ? \"r\" : \"w\");\n  if (file == NULL)\n    {\n      return errno + 100;\n    }\n  return (0);\n}",
      "lines": 98,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "timer": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "void\ntimer (int sig _GL_UNUSED_PARAMETER)\n{\n\n  timeout += rexmtval;\n  if (timeout >= maxtimeout)\n    exit (EXIT_FAILURE);\n  siglongjmp (timeoutbuf, 1);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "send_file": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "void\nsend_file (struct formats *pf)\n{\n  struct tftphdr *dp, *r_init (void);\n  register struct tftphdr *ap;\t/* ack packet */\n  register int size, n;\n  volatile int block;\n\n  signal (SIGALRM, timer);\n  dp = r_init ();\n  ap = (struct tftphdr *) ackbuf;\n  block = 1;\n  do\n    {\n      size = readit (file, &dp, pf->f_convert);\n      if (size < 0)\n\t{\n\t  nak (errno + 100);\n\t  goto abort;\n\t}\n      dp->th_opcode = htons ((unsigned short) DATA);\n      dp->th_block = htons ((unsigned short) block);\n      timeout = 0;\n      sigsetjmp (timeoutbuf, SIGALRM);\n\n    send_data:\n      if (sendto (peer, (const char *) dp, size + 4, 0,\n\t\t (struct sockaddr *) &from, fromlen) != size + 4)\n\t{\n\t  syslog (LOG_ERR, \"tftpd: write: %m\\n\");\n\t  goto abort;\n\t}\n      read_ahead (file, pf->f_convert);\n      for (;;)\n\t{\n\t  alarm (rexmtval);\t/* read the ack */\n\t  n = recv (peer, ackbuf, sizeof (ackbuf), 0);\n\t  alarm (0);\n\t  if (n < 0)\n\t    {\n\t      syslog (LOG_ERR, \"tftpd: read: %m\\n\");\n\t      goto abort;\n\t    }\n\t  ap->th_opcode = ntohs ((unsigned short) ap->th_opcode);\n\t  ap->th_block = ntohs ((unsigned short) ap->th_block);\n\n\t  if (ap->th_opcode == ERROR)\n\t    goto abort;\n\n\t  if (ap->th_opcode == ACK)\n\t    {\n\t      if ((unsigned short) ap->th_block == (unsigned short) block)\n\t\tbreak;\n\t      /* Re-synchronize with the other side */\n\t      synchnet (peer);\n\t      if ((unsigned short) ap->th_block == (unsigned short) (block - 1))\n\t\tgoto send_data;\n\t    }\n\n\t}\n      block++;\n    }\n  while (size == SEGSIZE);\nabort:\n  fclose (file);\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "justquit": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        720,
        1
      ],
      "content": "void\njustquit (int sig _GL_UNUSED_PARAMETER)\n{\n  exit (EXIT_SUCCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "recvfile": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "void\nrecvfile (struct formats *pf)\n{\n  struct tftphdr *dp, *w_init (void);\n  register struct tftphdr *ap;\t/* ack buffer */\n  register int n, size;\n  volatile int block;\n\n  signal (SIGALRM, timer);\n  dp = w_init ();\n  ap = (struct tftphdr *) ackbuf;\n  block = 0;\n  do\n    {\n      timeout = 0;\n      ap->th_opcode = htons ((unsigned short) ACK);\n      ap->th_block = htons ((unsigned short) block);\n      block++;\n      sigsetjmp (timeoutbuf, SIGALRM);\n    send_ack:\n      if (sendto (peer, ackbuf, 4, 0, (struct sockaddr *) &from, fromlen) != 4)\n\t{\n\t  syslog (LOG_ERR, \"tftpd: write: %m\\n\");\n\t  goto abort;\n\t}\n      write_behind (file, pf->f_convert);\n      for (;;)\n\t{\n\t  alarm (rexmtval);\n\t  n = recv (peer, (char *) dp, PKTSIZE, 0);\n\t  alarm (0);\n\t  if (n < 0)\n\t    {\t\t\t/* really? */\n\t      syslog (LOG_ERR, \"tftpd: read: %m\\n\");\n\t      goto abort;\n\t    }\n\t  dp->th_opcode = ntohs ((unsigned short) dp->th_opcode);\n\t  dp->th_block = ntohs ((unsigned short) dp->th_block);\n\t  if (dp->th_opcode == ERROR)\n\t    goto abort;\n\t  if (dp->th_opcode == DATA)\n\t    {\n\t      if (dp->th_block == block)\n\t\t{\n\t\t  break;\t/* normal */\n\t\t}\n\t      /* Re-synchronize with the other side */\n\t      synchnet (peer);\n\t      if (dp->th_block == (block - 1))\n\t\tgoto send_ack;\t/* rexmit */\n\t    }\n\t}\n      /*  size = write(file, dp->th_data, n - 4); */\n      size = writeit (file, &dp, n - 4, pf->f_convert);\n      if (size != (n - 4))\n\t{\t\t\t/* ahem */\n\t  if (size < 0)\n\t    nak (errno + 100);\n\t  else\n\t    nak (ENOSPACE);\n\t  goto abort;\n\t}\n    }\n  while (size == SEGSIZE);\n  write_behind (file, pf->f_convert);\n  fclose (file);\t\t/* close data file */\n\n  ap->th_opcode = htons ((unsigned short) ACK);\t/* send the \"final\" ack */\n  ap->th_block = htons ((unsigned short) (block));\n  sendto (peer, ackbuf, 4, 0, (struct sockaddr *) &from, fromlen);\n\n  signal (SIGALRM, justquit);\t/* just quit on timeout */\n  alarm (rexmtval);\n  n = recv (peer, buf, sizeof (buf), 0);\t/* normally times out and quits */\n  alarm (0);\n  if (n >= 4 &&\t\t\t/* if read some data */\n      dp->th_opcode == DATA &&\t/* and got a data block */\n      block == dp->th_block)\n    {\t\t\t\t/* then my last ack was lost */\n      sendto (peer, ackbuf, 4, 0, (struct sockaddr *) &from, fromlen);\t/* resend final ack */\n    }\nabort:\n  return;\n}",
      "lines": 84,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "errtomsg": {
      "start_point": [
        828,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "static const char *\nerrtomsg (int error)\n{\n  static char buf[20];\n  register struct errmsg *pe;\n  if (error == 0)\n    return \"success\";\n  for (pe = errmsgs; pe->e_code >= 0; pe++)\n    if (pe->e_code == error)\n      return pe->e_msg;\n  sprintf (buf, \"error %d\", error);\n  return buf;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nerrtomsg (int error)",
        "*"
      ]
    },
    "nak": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "static void\nnak (int error)\n{\n  register struct tftphdr *tp;\n  int length;\n  register struct errmsg *pe;\n\n  tp = (struct tftphdr *) buf;\n  tp->th_opcode = htons ((unsigned short) ERROR);\n  tp->th_code = htons ((unsigned short) error);\n  for (pe = errmsgs; pe->e_code >= 0; pe++)\n    if (pe->e_code == error)\n      break;\n  if (pe->e_code < 0)\n    {\n      pe->e_msg = strerror (error - 100);\n      tp->th_code = EUNDEF;\t/* set 'undef' errorcode */\n    }\n  strcpy (tp->th_msg, pe->e_msg);\n  length = strlen (pe->e_msg);\n  tp->th_msg[length] = '\\0';\n  length += 5;\n  if (sendto (peer, buf, length, 0, (struct sockaddr *) &from, fromlen) != length)\n    syslog (LOG_ERR, \"nak: %m\\n\");\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "verifyhost": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        889,
        1
      ],
      "content": "static const char *\nverifyhost (struct sockaddr_storage *fromp, socklen_t frlen)\n{\n  int rc;\n  static char host[NI_MAXHOST];\n\n  rc = getnameinfo ((struct sockaddr *) fromp, frlen,\n\t\t    host, sizeof (host), NULL, 0, 0);\n  if (rc == 0)\n    return host;\n  else\n    {\n      syslog (LOG_ERR, \"getnameinfo: %s\\n\", gai_strerror(rc));\n      return \"0.0.0.0\";\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nverifyhost (struct sockaddr_storage *fromp, socklen_t frlen)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/traceroute.c": {
    "parse_opt": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  char *p;\n  static bool host_is_given = false;\n\n  switch (key)\n    {\n    case 'f':\n      opt_ttl = strtol (arg, &p, 0);\n      if (*p || opt_ttl <= 0 || opt_ttl > 255)\n        error (EXIT_FAILURE, 0, \"impossible distance `%s'\", arg);\n      break;\n\n#ifdef IP_OPTIONS\n    case 'g':\n      if (opt_gateways)\n\t{\n\t  size_t len = 0;\n\n\t  len = strlen (opt_gateways);\n\t  opt_gateways = xrealloc (opt_gateways, len + strlen (arg) + 3);\n\n\t  /* Append new gateways to old list,\n\t   * separating the two parts by a comma.\n\t   */\n\t  opt_gateways[len] = ',';\n\t  opt_gateways[len + 1] = '\\0';\n\t  strcat (opt_gateways, arg);\n\t}\n      else\n\topt_gateways = xstrdup (arg);\n      break;\n#endif /* IP_OPTIONS */\n\n    case 'I':\n      opt_type = TRACE_ICMP;\n      break;\n\n    case 'm':\n      opt_max_hops = strtol (arg, &p, 0);\n      if (*p || opt_max_hops <= 0 || opt_max_hops > 255)\n\terror (EXIT_FAILURE, 0, \"invalid hops value `%s'\", arg);\n      break;\n\n    case 'p':\n      opt_port = strtol (arg, &p, 0);\n      if (*p || opt_port <= 0 || opt_port > 65536)\n        error (EXIT_FAILURE, 0, \"invalid port number `%s'\", arg);\n      break;\n\n    case 'q':\n      opt_max_tries = (int) strtol (arg, &p, 10);\n      if (*p)\n        argp_error (state, \"invalid value (`%s' near `%s')\", arg, p);\n      if (opt_max_tries < 1 || opt_max_tries > 10)\n        error (EXIT_FAILURE, 0, \"number of tries should be between 1 and 10\");\n      break;\n\n    case 't':\n      opt_tos = strtol (arg, &p, 0);\n      if (*p || opt_tos < 0 || opt_tos > 255)\n\terror (EXIT_FAILURE, 0, \"invalid TOS value `%s'\", arg);\n      break;\n\n    case 'M':\n      if (strcmp (arg, \"icmp\") == 0)\n        opt_type = TRACE_ICMP;\n      else if (strcmp (arg, \"udp\") == 0)\n        opt_type = TRACE_UDP;\n      else\n        argp_error (state, \"invalid method\");\n      break;\n\n    case 'w':\n      opt_wait = strtol (arg, &p, 0);\n      if (*p || opt_wait < 0 || opt_wait > 60)\n\terror (EXIT_FAILURE, 0, \"ridiculous waiting time `%s'\", arg);\n      break;\n\n    case OPT_RESOLVE:\n      opt_resolve_hostnames = 1;\n      break;\n\n    case ARGP_KEY_ARG:\n      host_is_given = true;\n      hostname = xstrdup(arg);\n      break;\n\n    case ARGP_KEY_SUCCESS:\n      if (!host_is_given)\n        argp_error (state, \"missing host operand\");\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int hop, rc;\n  char *rhost;\n  struct addrinfo hints, *res;\n  trace_t trace;\n\n  set_program_name (argv[0]);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n\n  pid = getpid() & 0xffff;\n\n  /* Parse command line */\n  iu_argp_init (\"traceroute\", program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  if ((hostname == NULL) || (*hostname == '\\0'))\n    error (EXIT_FAILURE, 0, \"unknown host\");\n\n  /* Hostname lookup first for better information */\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_INET;\n  hints.ai_flags = AI_CANONNAME;\n#ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n# ifdef AI_CANONIDN\n  hints.ai_flags |= AI_CANONIDN;\n# endif\n#endif\n\n#ifdef HAVE_IDN\n  rc = idna_to_ascii_lz (hostname, &rhost, 0);\n  free (hostname);\n\n  if (rc)\n    error (EXIT_FAILURE, 0, \"unknown host\");\n#else /* !HAVE_IDN */\n  rhost = hostname;\n#endif\n\n  rc = getaddrinfo (rhost, NULL, &hints, &res);\n\n  if (rc)\n    error (EXIT_FAILURE, 0, \"unknown host\");\n\n  memcpy (&dest, res->ai_addr, res->ai_addrlen);\n  dest.sin_port = htons (opt_port);\n\n  getnameinfo (res->ai_addr, res->ai_addrlen, addrstr, sizeof (addrstr),\n\t       NULL, 0, NI_NUMERICHOST);\n\n  printf (\"traceroute to %s (%s), %d hops max\\n\",\n\t  res->ai_canonname ? res->ai_canonname : rhost,\n\t  addrstr, opt_max_hops);\n\n  free (rhost);\n  freeaddrinfo (res);\n\n  trace_ip_opts (&dest);\n\n  trace_init (&trace, dest, opt_type);\n\n  hop = 1;\n  seqno = -1;\t/* One less than first usable packet number 0.  */\n\n  while (!stop)\n    {\n      if (hop > opt_max_hops)\n\texit (EXIT_FAILURE);\n      do_try (&trace, hop, opt_max_hops, opt_max_tries);\n      trace_inc_ttl (&trace);\n      trace_inc_port (&trace);\n      hop++;\n    }\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 81,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "do_try": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "void\ndo_try (trace_t * trace, const int hop,\n\tconst int max_hops _GL_UNUSED_PARAMETER,\n\tconst int max_tries)\n{\n  fd_set readset;\n  int ret, tries, readonly = 0;\n  struct timeval now, time;\n  double triptime = 0.0;\n  uint32_t prev_addr = 0;\n\n  printf (\" %2d  \", hop);\n\n  for (tries = 0; tries < max_tries; tries++)\n    {\n      int save_errno;\n      int fd = trace_icmp_sock (trace);\n\n      FD_ZERO (&readset);\n      FD_SET (fd, &readset);\n\n      memset (&time, 0, sizeof (time));\t\t/* 64-bit issue.  */\n      time.tv_sec = opt_wait;\n      time.tv_usec = 0;\n\n      if (!readonly)\n\ttrace_write (trace);\n\n      errno = 0;\n      ret = select (fd + 1, &readset, NULL, NULL, &time);\n      save_errno = errno;\n\n      gettimeofday (&now, NULL);\n\n      now.tv_usec -= trace->tsent.tv_usec;\n      now.tv_sec -= trace->tsent.tv_sec;\n      if (now.tv_usec < 0)\n\t{\n\t  --now.tv_sec;\n\t  now.tv_usec += 1000000;\n\t}\n\n      if (ret < 0)\n\t{\n\t  switch (save_errno)\n\t    {\n\t    case EINTR:\n\t      /* was interrupted */\n\t      break;\n\t    default:\n\t      error (EXIT_FAILURE, errno, \"select failed\");\n\t      break;\n\t    }\n\t}\n      else if (ret == 0)\n\t{\n\t  /* time expired */\n\t  printf (\" * \");\n\t  fflush (stdout);\n\t}\n      else\n\t{\n\t  if (FD_ISSET (fd, &readset))\n\t    {\n\t      int rc, type, code;\n\n\t      triptime = ((double) now.tv_sec) * 1000.0 +\n\t\t((double) now.tv_usec) / 1000.0;\n\n\t      rc = trace_read (trace, &type, &code);\n\n\t      if (rc < 0)\n\t\t{\n\t\t  /* FIXME: printf (\"Some error ocurred\\n\"); */\n\t\t  tries--;\n\t\t  readonly = 1;\n\t\t  continue;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (tries == 0 || prev_addr != trace->from.sin_addr.s_addr)\n\t\t    {\n\t\t      printf (\" %s \", inet_ntoa (trace->from.sin_addr));\n\t\t      if (opt_resolve_hostnames)\n\t\t\tprintf (\"(%s) \",\n\t\t\t    get_hostname (&trace->from.sin_addr));\n\t\t    }\n\t\t  printf (\" %.3fms \", triptime);\n\n\t\t  /* Additional messages.  */\n\t\t  if (rc > 0 && type == ICMP_DEST_UNREACH)\n\t\t    printf (\"!%c \", unreach_sign[code & 0x0f]);\n\n\t\t}\n\t      prev_addr = trace->from.sin_addr.s_addr;\n\t    }\n\t}\n      readonly = 0;\n      fflush (stdout);\n    }\n  printf (\"\\n\");\n}",
      "lines": 102,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "get_hostname": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "char *\nget_hostname (struct in_addr *addr)\n{\n  struct hostent *info =\n\tgethostbyaddr ((char *) addr, sizeof (*addr), AF_INET);\n  if (info != NULL)\n    return info->h_name;\n\n  return inet_ntoa (*addr);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "char",
        "*\nget_hostname (struct in_addr *addr)",
        "*"
      ]
    },
    "trace_init": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "void\ntrace_init (trace_t * t, const struct sockaddr_in to,\n\t    const enum trace_type type)\n{\n  int fd;\n  const int *ttlp;\n\n  assert (t);\n  ttlp = &t->ttl;\n\n  t->type = type;\n  t->to = to;\n  t->ttl = opt_ttl;\n\n  if (t->type == TRACE_UDP)\n    {\n      t->udpfd = socket (PF_INET, SOCK_DGRAM, 0);\n      if (t->udpfd < 0)\n        error (EXIT_FAILURE, errno, \"socket\");\n\n      if (setsockopt (t->udpfd, IPPROTO_IP, IP_TTL, ttlp,\n\t\t      sizeof (*ttlp)) < 0)\n        error (EXIT_FAILURE, errno, \"setsockopt\");\n    }\n\n  if (t->type == TRACE_ICMP || t->type == TRACE_UDP)\n    {\n      struct protoent *protocol = getprotobyname (\"icmp\");\n      if (protocol)\n\t{\n\t  t->icmpfd = socket (PF_INET, SOCK_RAW, protocol->p_proto);\n\t  if (t->icmpfd < 0)\n\t    error (EXIT_FAILURE, errno, \"socket\");\n\n\t  if (setsockopt (t->icmpfd, IPPROTO_IP, IP_TTL,\n\t\t\t  ttlp, sizeof (*ttlp)) < 0)\n\t    error (EXIT_FAILURE, errno, \"setsockopt\");\n\t}\n      else\n\t{\n\t  /* FIXME: Should we error out? */\n\t  error (EXIT_FAILURE, 0, \"can't find supplied protocol 'icmp'\");\n\t}\n\n      /* free (protocol); ??? */\n      /* FIXME: ... */\n    }\n  else\n    {\n      /* FIXME: type according to RFC 1393 */\n    }\n\n  fd = (t->type == TRACE_UDP ? t->udpfd : t->icmpfd);\n\n  if (opt_tos >= 0)\n    if (setsockopt (fd, IPPROTO_IP, IP_TOS,\n\t\t    &opt_tos, sizeof (opt_tos)) < 0)\n      error (0, errno, \"setsockopt(IP_TOS)\");\n\n#ifdef IP_OPTIONS\n  if (len_ip_opts)\n    if (setsockopt (fd, IPPROTO_IP, IP_OPTIONS,\n\t\t    &ip_opts, len_ip_opts) < 0)\n      error (0, errno, \"setsockopt(IPOPT_LSRR)\");\n#endif /* IP_OPTIONS */\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "trace_port": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "void\ntrace_port (trace_t * t, const unsigned short int port)\n{\n  assert (t);\n  if (port < IPPORT_RESERVED)\n    t->to.sin_port = TRACE_UDP_PORT;\n  else\n    t->to.sin_port = port;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "trace_read": {
      "start_point": [
        551,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "int\ntrace_read (trace_t * t, int * type, int * code)\n{\n  int len, rc = 0;\n  unsigned char data[CAPTURE_LEN];\n  struct ip *ip;\n  icmphdr_t *ic;\n  socklen_t siz;\n\n  assert (t);\n\n  siz = sizeof (t->from);\n\n  len = recvfrom (t->icmpfd, (char *) data, sizeof (data), 0,\n\t\t  (struct sockaddr *) &t->from, &siz);\n  if (len < 0)\n    error (EXIT_FAILURE, errno, \"recvfrom\");\n\n  icmp_generic_decode (data, sizeof (data), &ip, &ic);\n\n  /* Pass type and code of incoming packet.  */\n  *type = ic->icmp_type;\n  *code = ic->icmp_code;\n\n  switch (t->type)\n    {\n    case TRACE_UDP:\n      {\n\tunsigned short *port;\n\tif ((ic->icmp_type != ICMP_TIME_EXCEEDED\n\t     && ic->icmp_type != ICMP_DEST_UNREACH))\n\t  return -1;\n\n\t/* check whether it's for us */\n        port = (unsigned short *) ((void *) &ic->icmp_ip +\n\t\t\t(ic->icmp_ip.ip_hl << 2) + sizeof (in_port_t));\n\tif (*port != t->to.sin_port)\t/* Network byte order!  */\n\t  return -1;\n\n\tif (ic->icmp_type == ICMP_DEST_UNREACH)\n\t  /* FIXME: Ugly hack. */\n\t  stop = 1;\n\n\t/* Only ICMP_PORT_UNREACH is an expected reply,\n\t * all other denials produce additional information.\n\t */\n\tif (ic->icmp_type == ICMP_DEST_UNREACH\n\t    && ic->icmp_code != ICMP_PORT_UNREACH)\n\t  rc = 1;\n      }\n      break;\n\n    case TRACE_ICMP:\n      if (! (ic->icmp_type == ICMP_TIME_EXCEEDED\n\t     || ic->icmp_type == ICMP_ECHOREPLY\n\t     || ic->icmp_type == ICMP_DEST_UNREACH) )\n\treturn -1;\n\n      if (ic->icmp_type == ICMP_ECHOREPLY\n\t  && (ntohs (ic->icmp_seq) != seqno\n\t      || ntohs (ic->icmp_id) != pid))\n\treturn -1;\n\n      if (ic->icmp_type == ICMP_TIME_EXCEEDED\n\t  || ic->icmp_type == ICMP_DEST_UNREACH)\n\t{\n\t  unsigned short seq, ident;\n\t  struct ip *old_ip;\n\t  icmphdr_t *old_icmp;\n\n\t  old_ip = (struct ip *) &ic->icmp_ip;\n\t  old_icmp = (icmphdr_t *) ((void *) old_ip + (old_ip->ip_hl <<2));\n\t  seq = ntohs (old_icmp->icmp_seq);\n\t  ident = ntohs (old_icmp->icmp_id);\n\n\t  /* An expired packet tests identity and sequence number,\n\t   * whereas an undeliverable packet only checks identity.\n\t   */\n\t  if (ident != pid\n\t      || (ic->icmp_type == ICMP_TIME_EXCEEDED\n\t\t  && seq != seqno))\n\t    return -1;\n\t}\n\n      if (ip->ip_src.s_addr == dest.sin_addr.s_addr\n\t  || ic->icmp_type == ICMP_DEST_UNREACH)\n\t/* FIXME: Ugly hack. */\n\tstop = 1;\n\n      if (ic->icmp_type == ICMP_DEST_UNREACH)\n\trc = 1;\n      break;\n\n      /* FIXME: Type according to RFC 1393. */\n\n    default:\n      break;\n    }\n\n  return rc;\n}",
      "lines": 101,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "trace_write": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "int\ntrace_write (trace_t * t)\n{\n  int len;\n\n  assert (t);\n\n  switch (t->type)\n    {\n    case TRACE_UDP:\n      {\n\tchar data[] = \"SUPERMAN\";\n\n\tlen = sendto (t->udpfd, (char *) data, sizeof (data),\n\t\t      0, (struct sockaddr *) &t->to, sizeof (t->to));\n\tif (len < 0)\n\t  {\n\t    switch (errno)\n\t      {\n\t      case ECONNRESET:\n\t\tbreak;\n\t      default:\n\t\terror (EXIT_FAILURE, errno, \"sendto\");\n\t      }\n\t  }\n\n\tif (gettimeofday (&t->tsent, NULL) < 0)\n\t  error (EXIT_FAILURE, errno, \"gettimeofday\");\n      }\n      break;\n\n    case TRACE_ICMP:\n      {\n\ticmphdr_t hdr;\n\n\t/* The sequence number is updated to a valid value!  */\n\tif (icmp_echo_encode ((unsigned char *) &hdr, sizeof (hdr),\n\t\t\t      pid, ++seqno))\n\t  return -1;\n\n\tlen = sendto (t->icmpfd, (char *) &hdr, sizeof (hdr),\n\t\t      0, (struct sockaddr *) &t->to, sizeof (t->to));\n\tif (len < 0)\n\t  {\n\t    switch (errno)\n\t      {\n\t      case ECONNRESET:\n\t\tbreak;\n\t      default:\n\t\terror (EXIT_FAILURE, errno, \"sendto\");\n\t      }\n\t  }\n\n\tif (gettimeofday (&t->tsent, NULL) < 0)\n\t  error (EXIT_FAILURE, errno, \"gettimeofday\");\n      }\n      break;\n\n      /* FIXME: type according to RFC 1393 */\n\n    default:\n      break;\n    }\n\n  return 0;\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "trace_udp_sock": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        724,
        1
      ],
      "content": "int\ntrace_udp_sock (trace_t * t)\n{\n  return (t != NULL ? t->udpfd : -1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "trace_icmp_sock": {
      "start_point": [
        726,
        0
      ],
      "end_point": [
        730,
        1
      ],
      "content": "int\ntrace_icmp_sock (trace_t * t)\n{\n  return (t != NULL ? t->icmpfd : -1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "trace_inc_ttl": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "void\ntrace_inc_ttl (trace_t * t)\n{\n  int fd;\n  const int *ttlp;\n\n  assert (t);\n\n  ttlp = &t->ttl;\n  t->ttl++;\n  fd = (t->type == TRACE_UDP ? t->udpfd : t->icmpfd);\n  if (setsockopt (fd, IPPROTO_IP, IP_TTL, ttlp, sizeof (*ttlp)) < 0)\n    error (EXIT_FAILURE, errno, \"setsockopt\");\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "trace_inc_port": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "void\ntrace_inc_port (trace_t * t)\n{\n  assert (t);\n  if (t->type == TRACE_UDP)\n    t->to.sin_port = htons (ntohs (t->to.sin_port) + 1);\n}",
      "lines": 7,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "trace_ip_opts": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "void\ntrace_ip_opts (struct sockaddr_in *to)\n{\n#ifdef IP_OPTIONS\n  if (opt_gateways && *opt_gateways)\n    {\n      char *gateway, *optbase;\n      struct addrinfo hints, *res;\n\n      memset (&hints, 0, sizeof (hints));\n      hints.ai_family = AF_INET;\n      hints.ai_socktype = SOCK_DGRAM;\n\n      memset (&ip_opts, 0, sizeof (ip_opts));\n      optbase = ip_opts;\n\n      /* Set up any desired options.  Keep\n       * `optbase' updated, pointing to the\n       * part presently under construction.\n       */\n\n      /* 1. Loose source routing.  */\n      gateway = opt_gateways;\n      optbase[IPOPT_OPTVAL] = IPOPT_LSRR;\n      optbase[IPOPT_OLEN] = IPOPT_MINOFF - 1;\t/* No payload yet.  */\n      optbase[IPOPT_OFFSET] = IPOPT_MINOFF;\t/* Empty payload.  */\n\n      /* Traverse the gateway list, inserting\n       * addresses in the stated order.  Take\n       * care not to overflow available space.\n       */\n      while (gateway && *gateway\n\t     && optbase[IPOPT_OFFSET]\n\t\t< (int) (MAX_IPOPTLEN - sizeof (struct in_addr)))\n\t{\n\t  int rc;\n\t  char *p;\n\n\t  p = strpbrk (gateway, \" ,;:\");\n\t  if (p)\n\t    *p++ = '\\0';\n\n\t  rc = getaddrinfo (gateway, NULL, &hints, &res);\n\t  if (rc)\n\t    error (EXIT_FAILURE, errno, \"gateway `%s' %s\",\n\t\t   gateway, gai_strerror(rc));\n\n\t  /* Put target into next unused slot.  */\n\t  memcpy (optbase + optbase[IPOPT_OLEN],\n\t\t  &((struct sockaddr_in *) res->ai_addr)->sin_addr,\n\t\t  sizeof (struct in_addr));\n\n\t  freeaddrinfo (res);\n\n\t  /* Option gained in length.  */\n\t  optbase[IPOPT_OLEN] += sizeof (struct in_addr);\n\n\t  gateway = p;\n\t}\n\n      if (gateway && *gateway)\n\terror (EXIT_FAILURE, 0, \"too many gateways specified\");\n\n      /* Append the final destination.  */\n      memcpy (optbase + optbase[IPOPT_OLEN],\n\t      &to->sin_addr, sizeof (to->sin_addr));\n      optbase[IPOPT_OLEN] += sizeof (to->sin_addr);\n\n      /* 2. There is an implicit IPOPT_EOL after\n       * IPOPT_LSRR, ensured by the call to memset().\n       * Use it!\n       */\n      len_ip_opts = optbase[IPOPT_OLEN] + 1;\n    }\n#endif /* IP_OPTIONS */\n}",
      "lines": 76,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/src/uucpd.c": {
    "parse_opt": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'u':\n      uucico_location = arg;\n      break;\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct sockaddr_storage hisctladdr;\n  socklen_t hisaddrlen = sizeof (hisctladdr);\n\n  set_program_name (argv[0]);\n  iu_argp_init (\"uucpd\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  /* Minimal environment, containing only USER.  */\n  environ = nenv;\n\n  /* Circumvent all descriptor trickery.  */\n  dup2 (STDIN_FILENO, STDOUT_FILENO);\n  dup2 (STDIN_FILENO, STDERR_FILENO);\n\n  hisaddrlen = sizeof (hisctladdr);\n  if (getpeername (STDIN_FILENO, (struct sockaddr *) &hisctladdr,\n\t\t   &hisaddrlen) < 0)\n    {\n      fprintf (stderr, \"%s: \", argv[0]);\n      perror (\"getpeername\");\n      _exit (EXIT_FAILURE);\n    }\n\n  if (fork () == 0)\n    doit ((struct sockaddr *) &hisctladdr, hisaddrlen);\n\n  dologout ();\n  exit (EXIT_FAILURE);\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "readline": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nreadline (register char *p, register int n)\n{\n  char c;\n\n  while (n-- > 0)\n    {\n      if (read (STDIN_FILENO, &c, 1) <= 0)\n\treturn (-1);\n      c &= 0177;\n      if (c == '\\n' || c == '\\r')\n\t{\n\t  *p = '\\0';\n\t  return (0);\n\t}\n      *p++ = c;\n    }\n  return (-1);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "doit": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\ndoit (struct sockaddr *sap, socklen_t salen)\n{\n  struct passwd *pw;\n  char user[64], passwd[64];\n  char *xpasswd;\n\n  alarm (60);\n  printf (\"login: \");\n  fflush (stdout);\n  if (readline (user, sizeof (user)) < 0)\n    {\n      fprintf (stderr, \"user read\\n\");\n      return;\n    }\n  user[sizeof (user) - 1] = '\\0';\n\n  pw = getpwnam (user);\n  if (pw == NULL)\n    {\n      /* Simulate continuation, in order not\n       * to disclose user name information.\n       */\n      printf (\"Password: \");\n      fflush (stdout);\n      if (readline (passwd, sizeof (passwd)) < 0)\n\t{\n\t  fprintf (stderr, \"passwd read\\n\");\n\t  return;\n\t}\n      fprintf (stderr, \"Login incorrect.\");\n      return;\n    }\n  if (pw->pw_passwd && *pw->pw_passwd != '\\0')\n    {\n      printf (\"Password: \");\n      fflush (stdout);\n      if (readline (passwd, sizeof (passwd)) < 0)\n\t{\n\t  fprintf (stderr, \"passwd read\\n\");\n\t  return;\n\t}\n      xpasswd = crypt (passwd, pw->pw_passwd);\n      if (strcmp (xpasswd, pw->pw_passwd))\n\t{\n\t  fprintf (stderr, \"Login incorrect.\");\n\t  return;\n\t}\n    }\n\n  /* XXX: Compare only shell base name to \"uucico\"?\n   * Calling execl(uucico_location) would still use\n   * the only acceptable binary.  */\n  if (strcmp (pw->pw_shell, uucico_location))\n    {\n      fprintf (stderr, \"Login incorrect.\");\n      return;\n    }\n\n  alarm (0);\n  sprintf (Username, \"USER=%s\", user);\n  sprintf (Logname, \"LOGNAME=%s\", user);\n  dologin (pw, sap, salen);\n  setgid (pw->pw_gid);\n#ifdef HAVE_INITGROUPS\n  initgroups (pw->pw_name, pw->pw_gid);\n#endif\n  if (chdir (pw->pw_dir) < 0)\n    {\n      fprintf (stderr, \"Login incorrect.\");\n      return;\n    }\n  setuid (pw->pw_uid);\n  execl (uucico_location, \"uucico\", NULL);\n  perror (\"uucico server: execl\");\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dologout": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "void\ndologout (void)\n{\n  int pid;\n\n#ifdef HAVE_WAITPID\n  while ((pid = waitpid (-1, 0, WNOHANG)) > 0)\n#else\n# ifdef HAVE_WAIT3\n  while ((pid = wait3 (0, WNOHANG, 0)) > 0)\n# else\n  while ((pid = wait (0)) > 0)\n# endif\t/* HAVE_WAIT3 */\n#endif /* HAVE_WAITPID */\n    {\n      char line[100];\n      sprintf (line, \"uucp%.4d\", (int) pid);\n#ifdef HAVE_LOGWTMPX\n      logwtmpx (line, \"\", \"\", 0, DEAD_PROCESS);\n#elif defined HAVE_LOGWTMP\n      logwtmp (line, \"\", \"\");\n#elif defined HAVE_PUTUTXLINE\n      {\n\t/* Novelty in FreeBSD 9.0.  */\n\tstruct utmpx ut;\n\tstruct timeval now;\n\n\tut.ut_type = DEAD_PROCESS;\n\tut.ut_pid = pid;\n\tstrncpy (ut.ut_line, line, sizeof (ut.ut_line));\n\tmemset (ut.ut_user, 0, sizeof (ut.ut_user));\n\tmemset (ut.ut_host, 0, sizeof (ut.ut_host));\n# ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN\n\tut.ut_syslen = 1;\n# endif\n\tgettimeofday (&now, NULL);\n\tut.ut_tv.tv_sec = now.tv_sec;\n\tut.ut_tv.tv_usec = now.tv_usec;\n\tpututxline (&ut);\n      }\n#endif /* HAVE_PUTUTXLINE && !HAVE_LOGWTMPX && !HAVE_LOGWTMP */\n    }\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "dologin": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "void\ndologin (struct passwd *pw, struct sockaddr *sap, socklen_t salen)\n{\n  char line[32];\n#if defined PATH_LASTLOG && defined HAVE_STRUCT_LASTLOG\n  int f;\n#endif\n#if HAVE_DECL_GETNAMEINFO\n  char remotehost[NI_MAXHOST];\n\n  if (getnameinfo (sap, salen, remotehost, sizeof (remotehost),\n\t\t   NULL, 0, 0))\n    (void) getnameinfo (sap, salen, remotehost, sizeof (remotehost),\n\t\t\tNULL, 0, NI_NUMERICHOST);\n#else\n  char remotehost[64];\n  struct hostent *hp;\n  void *addr;\n  socklen_t addrlen;\n\n  switch (sap->sa_family)\n    {\n#ifdef IPV6\n    case AF_INET6:\n      addr = (void *) &(((struct sockaddr_in6 *) sap)->sin6_addr);\n      addrlen = sizeof (struct in6_addr);\n      break;\n#endif\n    case AF_INET:\n    default:\n      addr = (void *) &(((struct sockaddr_in *) sap)->sin_addr);\n      addrlen = sizeof (struct in_addr);\n      break;\n    }\n\n  (void) salen;\t\t/* Silence warning.  */\n  hp = gethostbyaddr (addr, addrlen, sap->sa_family);\n\n  if (hp)\n    {\n      strncpy (remotehost, hp->h_name, sizeof (remotehost));\n      endhostent ();\n    }\n  else\n    {\n      remotehost[0] = '\\0';\n      (void) inet_ntop (sap->sa_family, addr,\n\t\t\tremotehost, sizeof (remotehost));\n    }\n#endif\n\n  sprintf (line, \"uucp%.4d\", (int) getpid ());\n\n#ifdef HAVE_LOGWTMPX\n  logwtmpx (line, pw->pw_name, remotehost, 0, USER_PROCESS);\n#elif defined HAVE_LOGWTMP\n  logwtmp (line, pw->pw_name, remotehost);\n#elif defined HAVE_PUTUTXLINE\n  {\n    /* Novelty in FreeBSD 9.0.  */\n    struct utmpx ut;\n    struct timeval now;\n\n    ut.ut_type = USER_PROCESS;\n    ut.ut_pid = getpid();\n    strncpy (ut.ut_line, line, sizeof (ut.ut_line));\n    strncpy (ut.ut_user, pw->pw_name, sizeof (ut.ut_user));\n    strncpy (ut.ut_host, remotehost, sizeof (ut.ut_host));\n# ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN\n    if (strlen (remotehost) < sizeof (ut.ut_host))\n      ut.ut_syslen = strlen (remotehost) + 1;\n    else\n      {\n\tut.ut_host[sizeof (ut.ut_host) - 1] = '\\0';\n\tut.ut_syslen = sizeof (ut.ut_host);\n      }\n# endif\n    gettimeofday (&now, NULL);\n    ut.ut_tv.tv_sec = now.tv_sec;\n    ut.ut_tv.tv_usec = now.tv_usec;\n    pututxline (&ut);\n  }\n#endif /* HAVE_PUTUTXLINE && !HAVE_LOGWTMPX && !HAVE_LOGWTMP */\n\n#if defined PATH_LASTLOG && defined HAVE_STRUCT_LASTLOG\n# define SCPYN(a, b)\tstrncpy(a, b, sizeof (a))\n  f = open (PATH_LASTLOG, O_RDWR);\n  if (f >= 0)\n    {\n      struct lastlog ll;\n      time_t t;\n\n      time (&t);\n      ll.ll_time = t;\n      lseek (f, (long) pw->pw_uid * sizeof (struct lastlog), 0);\n      strcpy (line, remotehost);\n      SCPYN (ll.ll_line, line);\n      SCPYN (ll.ll_host, remotehost);\n      write (f, (char *) &ll, sizeof (ll));\n      close (f);\n    }\n#endif\n}",
      "lines": 103,
      "depth": 19,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/ctl.c": {
    "open_sockt": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nopen_sockt (void)\n{\n  socklen_t length;\n\n  my_addr.sin_family = AF_INET;\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  my_addr.sin_len = sizeof (my_addr);\n#endif\n  my_addr.sin_addr = my_machine_addr;\n  my_addr.sin_port = 0;\n  sockt = socket (AF_INET, SOCK_STREAM, 0);\n  if (sockt <= 0)\n    p_error (\"Bad socket\");\n  if (bind (sockt, (struct sockaddr *) &my_addr, sizeof (my_addr)) != 0)\n    p_error (\"Binding local socket\");\n  length = sizeof (my_addr);\n  if (getsockname (sockt, (struct sockaddr *) &my_addr, &length) == -1)\n    p_error (\"Bad address for socket\");\n\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "open_ctl": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "int\nopen_ctl (void)\n{\n  socklen_t length;\n\n  ctl_addr.sin_family = AF_INET;\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  ctl_addr.sin_len = sizeof (ctl_addr);\n#endif\n  ctl_addr.sin_port = 0;\n  ctl_addr.sin_addr = my_machine_addr;\n  ctl_sockt = socket (AF_INET, SOCK_DGRAM, 0);\n  if (ctl_sockt <= 0)\n    p_error (\"Bad socket\");\n  if (bind (ctl_sockt, (struct sockaddr *) &ctl_addr, sizeof (ctl_addr)) != 0)\n    p_error (\"Couldn't bind to control socket\");\n  length = sizeof (ctl_addr);\n  if (getsockname (ctl_sockt, (struct sockaddr *) &ctl_addr, &length) == -1)\n    p_error (\"Bad address for ctl socket\");\n\n  return 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/ctl_transact.c": {
    "ctl_transact": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\nctl_transact (struct in_addr target, CTL_MSG msg, int type, CTL_RESPONSE * rp)\n{\n  int nready, cc;\n  fd_set read_mask, ctl_mask;\n  struct timeval wait;\n\n  msg.type = type;\n  daemon_addr.sin_family = AF_INET;\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  daemon_addr.sin_len = sizeof (daemon_addr);\n#endif\n  daemon_addr.sin_addr = target;\n  daemon_addr.sin_port = htons (daemon_port);\n  FD_ZERO (&ctl_mask);\n  FD_SET (ctl_sockt, &ctl_mask);\n\n  /*\n   * Keep sending the message until a response of\n   * the proper type is obtained.\n   */\n  do\n    {\n      wait.tv_sec = CTL_WAIT;\n      wait.tv_usec = 0;\n      /* resend message until a response is obtained */\n      do\n\t{\n\t  cc = sendto (ctl_sockt, (char *) &msg, sizeof (msg), 0,\n\t\t       (struct sockaddr *) &daemon_addr,\n\t\t       sizeof (daemon_addr));\n\t  if (cc != sizeof (msg))\n\t    {\n\t      if (errno == EINTR)\n\t\tcontinue;\n\t      p_error (\"Error on write to talk daemon\");\n\t    }\n\t  read_mask = ctl_mask;\n\t  nready = select (32, &read_mask, 0, 0, &wait);\n\t  if (nready < 0)\n\t    {\n\t      if (errno == EINTR)\n\t\tcontinue;\n\t      p_error (\"Error waiting for daemon response\");\n\t    }\n\t}\n      while (nready == 0);\n      /*\n       * Keep reading while there are queued messages\n       * (this is not necessary, it just saves extra\n       * request/acknowledgements being sent)\n       */\n      do\n\t{\n\t  cc = recv (ctl_sockt, (char *) rp, sizeof (*rp), 0);\n\t  if (cc < 0)\n\t    {\n\t      if (errno == EINTR)\n\t\tcontinue;\n\t      p_error (\"Error on read from talk daemon\");\n\t    }\n\t  read_mask = ctl_mask;\n\t  /* an immediate poll */\n\t  timerclear (&wait);\n\t  nready = select (32, &read_mask, 0, 0, &wait);\n\t}\n      while (nready > 0 && (rp->vers != TALK_VERSION || rp->type != type));\n    }\n  while (rp->vers != TALK_VERSION || rp->type != type);\n  rp->id_num = ntohl (rp->id_num);\n  rp->addr.sa_family = ntohs (rp->addr.sa_family);\n\n  return 0;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/display.c": {
    "max": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nmax (int a, int b)\n{\n  return a > b ? a : b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "readwin": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int\nreadwin (WINDOW * win, int line, int col)\n{\n  int oldline, oldcol;\n  register int c;\n\n  getyx (win, oldline, oldcol);\n  wmove (win, line, col);\n  c = winch (win);\n  wmove (win, oldline, oldcol);\n  return (c);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "xscroll": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nxscroll (register xwin_t * win, int flag)\n{\n  if (flag == -1)\n    {\n      wmove (win->x_win, 0, 0);\n      win->x_line = 0;\n      win->x_col = 0;\n      return;\n    }\n  win->x_line = (win->x_line + 1) % win->x_nlines;\n  win->x_col = 0;\n  wmove (win->x_win, win->x_line, win->x_col);\n  wclrtoeol (win->x_win);\n  wmove (win->x_win, (win->x_line + 1) % win->x_nlines, win->x_col);\n  wclrtoeol (win->x_win);\n  wmove (win->x_win, win->x_line, win->x_col);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int\ndisplay (register xwin_t * win, register char *text, int size)\n{\n  register int i;\n  unsigned char cch;\n\n  for (i = 0; i < size; i++)\n    {\n      if (*text == '\\n')\n\t{\n\t  xscroll (win, 0);\n\t  text++;\n\t  continue;\n\t}\n      if (*text == '\\a')\n\t{\n\t  beep ();\n\t  wrefresh (curscr);\n\t  text++;\n\t  continue;\n\t}\n      /* erase character */\n      if (*text == win->cerase)\n\t{\n\t  wmove (win->x_win, win->x_line, max (--win->x_col, 0));\n\t  getyx (win->x_win, win->x_line, win->x_col);\n\t  waddch (win->x_win, ' ');\n\t  wmove (win->x_win, win->x_line, win->x_col);\n\t  getyx (win->x_win, win->x_line, win->x_col);\n\t  text++;\n\t  continue;\n\t}\n      /*\n       * On word erase search backwards until we find\n       * the beginning of a word or the beginning of\n       * the line.\n       */\n      if (*text == win->werase)\n\t{\n\t  int endcol, xcol, i, c;\n\n\t  endcol = win->x_col;\n\t  xcol = endcol - 1;\n\t  while (xcol >= 0)\n\t    {\n\t      c = readwin (win->x_win, win->x_line, xcol);\n\t      if (c != ' ')\n\t\tbreak;\n\t      xcol--;\n\t    }\n\t  while (xcol >= 0)\n\t    {\n\t      c = readwin (win->x_win, win->x_line, xcol);\n\t      if (c == ' ')\n\t\tbreak;\n\t      xcol--;\n\t    }\n\t  wmove (win->x_win, win->x_line, xcol + 1);\n\t  for (i = xcol + 1; i < endcol; i++)\n\t    waddch (win->x_win, ' ');\n\t  wmove (win->x_win, win->x_line, xcol + 1);\n\t  getyx (win->x_win, win->x_line, win->x_col);\n\t  text++;\n\t  continue;\n\t}\n      /* line kill */\n      if (*text == win->kill)\n\t{\n\t  wmove (win->x_win, win->x_line, 0);\n\t  wclrtoeol (win->x_win);\n\t  getyx (win->x_win, win->x_line, win->x_col);\n\t  text++;\n\t  continue;\n\t}\n      /* Refresh screen with input ^L, Ctrl-L.\n       * Local trigger only.\n       */\n      if (*text == '\\f')\n\t{\n\t  if (win == &my_win)\n\t    wrefresh (curscr);\n\t  text++;\n\t  continue;\n\t}\n      /* Clear both windows with input ^D, Ctrl-D.\n       * Local trigger only.\n       */\n      if (*text == '\\04' && win == &my_win)\n\t{\n\t  wclear (my_win.x_win);\n\t  wclear (his_win.x_win);\n\t  wrefresh (my_win.x_win);\n\t  wrefresh (his_win.x_win);\n\t  text++;\n\t  continue;\n\t}\n      if (win->x_col == COLS - 1)\n\t{\n\t  /* check for wraparound */\n\t  xscroll (win, 0);\n\t}\n\n      /*\n       * Printable characters, SP, and TAB are printed\n       * verbatim.  Characters beyond the ASCII table\n       * must be handled.  Beware of sign extension!\n       *\n       * The locale setting is in effect when testing\n       * printability of any input character.\n       */\n      if (isprint (*text & 0xff) || *text == '\\t')\n\twaddch (win->x_win, *text & 0xff);\n      else\n\t{\n\t  waddch (win->x_win, '^');\n\t  getyx (win->x_win, win->x_line, win->x_col);\n\t  if (win->x_col == COLS - 1)\t/* check for wraparound */\n\t    xscroll (win, 0);\n\t  cch = (*text & 63) + 64;\n\t  waddch (win->x_win, cch);\n\t}\n\n      getyx (win->x_win, win->x_line, win->x_col);\n      text++;\n    }\n  wrefresh (win->x_win);\n\n  return 0;\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/get_addrs.c": {
    "get_addrs": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "int\nget_addrs (char *my_machine_name, char *his_machine_name)\n{\n#if HAVE_DECL_GETADDRINFO || defined HAVE_IDN\n  int err;\n#endif\n  char *lhost, *rhost;\n#if HAVE_DECL_GETADDRINFO\n  struct addrinfo hints, *res, *ai;\n#else /* !HAVE_DECL_GETADDRINFO */\n  struct hostent *hp;\n#endif\n  struct servent *sp;\n\n#ifdef HAVE_IDN\n  err = idna_to_ascii_lz (my_machine_name, &lhost, 0);\n  if (err)\n    {\n      fprintf (stderr, \"talk: %s: %s\\n\",\n\t       my_machine_name, idna_strerror (err));\n      exit (-1);\n    }\n\n  err = idna_to_ascii_lz (his_machine_name, &rhost, 0);\n  if (err)\n    {\n      fprintf (stderr, \"talk: %s: %s\\n\",\n\t       his_machine_name, idna_strerror (err));\n      exit (-1);\n    }\n#else /* !HAVE_IDN */\n  lhost = my_machine_name;\n  rhost = his_machine_name;\n#endif\n\n  msg.pid = htonl (getpid ());\n\n  /* Look up the address of the local host.  */\n\n#if HAVE_DECL_GETADDRINFO\n  memset (&hints, 0, sizeof (hints));\n\n  /* The talk-protocol is IPv4 only!  */\n  hints.ai_family = AF_INET;\n  hints.ai_socktype = SOCK_DGRAM;\n# ifdef AI_IDN\n  hints.ai_flags |= AI_IDN;\n# endif\n\n  err = getaddrinfo (lhost, NULL, &hints, &res);\n  if (err)\n    {\n      fprintf (stderr, \"talk: %s: %s\\n\", lhost, gai_strerror (err));\n      exit (-1);\n    }\n\n  /* Perform all sanity checks available.\n   * Reduction of tests?\n   */\n  for (ai = res; ai; ai = ai->ai_next)\n    {\n      int f;\n\n      if (ai->ai_family != AF_INET)\n\tcontinue;\n\n      f = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (f < 0)\n\tcontinue;\n\n      /* Attempt binding to this local address.  */\n      if (bind (f, ai->ai_addr, ai->ai_addrlen))\n        {\n\t  close (f);\n\t  f = -1;\n\t  continue;\n\t}\n\n      /* We have a usable address.  */\n      close (f);\n      break;\n    }\n\n  if (ai)\n    memcpy (&my_machine_addr,\n\t    &((struct sockaddr_in *) ai->ai_addr)->sin_addr,\n\t    sizeof (my_machine_addr));\n\n  freeaddrinfo (res);\n  if (!ai)\n    {\n      fprintf (stderr, \"talk: %s: %s\\n\", lhost, \"address not found\");\n      exit (-1);\n    }\n\n#else /* !HAVE_DECL_GETADDRINFO */\n  hp = gethostbyname (lhost);\n  if (hp == NULL)\n    {\n      fprintf (stderr, \"talk: %s(%s): \", lhost, my_machine_name);\n      herror ((char *) NULL);\n      exit (-1);\n    }\n  memmove (&my_machine_addr, hp->h_addr, hp->h_length);\n#endif /* !HAVE_DECL_GETADDRINFO */\n\n  /*\n   * If the callee is on-machine, just copy the\n   * network address, otherwise do a lookup...\n   */\n  if (strcmp (rhost, lhost))\n    {\n#if HAVE_DECL_GETADDRINFO\n      err = getaddrinfo (rhost, NULL, &hints, &res);\n      if (err)\n\t{\n\t  fprintf (stderr, \"talk: %s: %s\\n\", rhost, gai_strerror (err));\n\t  exit (-1);\n\t}\n\n      /* Perform all sanity checks available.  */\n      for (ai = res; ai; ai = ai->ai_next)\n\t{\n\t  int f;\n\n\t  if (ai->ai_family != AF_INET)\n\t    continue;\n\n\t  f = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t  if (f < 0)\n\t    continue;\n\n\t  /* We have a usable address family!  */\n\t  close (f);\n\t  break;\n\t}\n\n      if (ai)\n\tmemcpy (&his_machine_addr,\n\t\t&((struct sockaddr_in *) ai->ai_addr)->sin_addr,\n\t\tsizeof (his_machine_addr));\n\n      freeaddrinfo (res);\n      if (!ai)\n\t{\n\t  fprintf (stderr, \"talk: %s: %s\\n\", rhost, \"address not found\");\n\t  exit (-1);\n\t}\n\n#else /* !HAVE_DECL_GETADDRINFO */\n      hp = gethostbyname (rhost);\n      if (hp == NULL)\n\t{\n\t  fprintf (stderr, \"talk: %s(%s): \", rhost, his_machine_name);\n\t  herror ((char *) NULL);\n\t  exit (-1);\n\t}\n      memmove (&his_machine_addr, hp->h_addr, hp->h_length);\n#endif /* !HAVE_DECL_GETADDRINFO */\n    }\n  else\n    his_machine_addr = my_machine_addr;\n\n  /* Find the server's port.  */\n  sp = getservbyname (\"ntalk\", \"udp\");\n  if (sp == 0)\n    {\n      fprintf (stderr, \"talk: %s/%s: service is not registered.\\n\",\n\t       \"ntalk\", \"udp\");\n      exit (-1);\n    }\n  daemon_port = ntohs (sp->s_port);\n\n#ifdef HAVE_IDN\n  free (lhost);\n  free (rhost);\n#endif\n\n  return 0;\n}",
      "lines": 180,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/get_names.c": {
    "get_names": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "int\nget_names (int argc, char *argv[])\n{\n  char *his_name, *my_name;\n  char *my_machine_name, *his_machine_name;\n  char *his_tty;\n  register char *cp;\n\n  if ((my_name = getlogin ()) == NULL)\n    {\n      struct passwd *pw;\n\n      if ((pw = getpwuid (getuid ())) == NULL)\n\t{\n\t  printf (\"You don't exist. Go away.\\n\");\n\t  exit (-1);\n\t}\n      my_name = pw->pw_name;\n    }\n\n  my_machine_name = localhost ();\n  if (!my_machine_name)\n    {\n      perror (\"Cannot get local hostname\");\n      exit (-1);\n    }\n\n  /* check for, and strip out, the machine name of the target */\n  for (cp = argv[0]; *cp && !strchr (\"@:!.\", *cp); cp++)\n    ;\n  if (*cp == '\\0')\n    {\n      /* this is a local to local talk */\n      his_name = argv[0];\n      his_machine_name = my_machine_name;\n    }\n  else\n    {\n      if (*cp++ == '@')\n\t{\n\t  /* user@host */\n\t  his_name = argv[0];\n\t  his_machine_name = cp;\n\t}\n      else\n\t{\n\t  /* host.user or host!user or host:user */\n\t  his_name = cp;\n\t  his_machine_name = argv[0];\n\t}\n      *--cp = '\\0';\n    }\n  if (argc > 1)\n    his_tty = argv[1];\t\t/* tty name is arg 2 */\n  else\n    his_tty = \"\";\n  get_addrs (my_machine_name, his_machine_name);\n  /*\n   * Initialize the message template.\n   */\n  msg.vers = TALK_VERSION;\n  msg.addr.sa_family = htons (AF_INET);\n  msg.ctl_addr.sa_family = htons (AF_INET);\n  msg.id_num = htonl (0);\n  strncpy (msg.l_name, my_name, NAME_SIZE);\n  msg.l_name[NAME_SIZE - 1] = '\\0';\n  strncpy (msg.r_name, his_name, NAME_SIZE);\n  msg.r_name[NAME_SIZE - 1] = '\\0';\n  strncpy (msg.r_tty, his_tty, TTY_SIZE);\n  msg.r_tty[TTY_SIZE - 1] = '\\0';\n\n  free (my_machine_name);\n\n  return 0;\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/init_disp.c": {
    "sig_sent": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\nsig_sent (int sig _GL_UNUSED_PARAMETER)\n{\n\n  message (\"Connection closing. Exiting\");\n  quit ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_display": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\ninit_display (void)\n{\n#ifdef HAVE_SIGACTION\n  struct sigaction siga;\n#else\n# ifdef HAVE_SIGVEC\n  struct sigvec sigv;\n# endif\n#endif\n\n  if (initscr () == NULL)\n    error (EXIT_FAILURE, 0, \"Terminal type unset or lacking necessary features.\");\n\n#ifdef HAVE_SIGACTION\n  sigaction (SIGTSTP, (struct sigaction *) 0, &siga);\n  sigaddset (&siga.sa_mask, SIGALRM);\n  sigaction (SIGTSTP, &siga, (struct sigaction *) 0);\n#else /* !HAVE_SIGACTION */\n# ifdef HAVE_SIGVEC\n  sigvec (SIGTSTP, (struct sigvec *) 0, &sigv);\n  sigv.sv_mask |= sigmask (SIGALRM);\n  sigvec (SIGTSTP, &sigv, (struct sigvec *) 0);\n# endif\t/* HAVE_SIGVEC */\n#endif /* HAVE_SIGACTION */\n\n  curses_initialized = 1;\n  clear ();\n  refresh ();\n  noecho ();\n  crmode ();\n\n  signal (SIGQUIT, sig_sent);\n  signal (SIGINT, sig_sent);\n  signal (SIGPIPE, sig_sent);\n\n  /* curses takes care of ^Z */\n  my_win.x_nlines = LINES / 2;\n  my_win.x_ncols = COLS;\n  my_win.x_win = newwin (my_win.x_nlines, my_win.x_ncols, 0, 0);\n  scrollok (my_win.x_win, FALSE);\n  wclear (my_win.x_win);\n\n  his_win.x_nlines = LINES / 2 - 1;\n  his_win.x_ncols = COLS;\n  his_win.x_win = newwin (his_win.x_nlines, his_win.x_ncols,\n\t\t\t  my_win.x_nlines + 1, 0);\n  scrollok (his_win.x_win, FALSE);\n  wclear (his_win.x_win);\n\n  line_win = newwin (1, COLS, my_win.x_nlines, 0);\n  box (line_win, '-', '-');\n  wrefresh (line_win);\n\n  return 0;\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "set_edit_chars": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int\nset_edit_chars (void)\n{\n  int cc;\n  char buf[3];\n\n#ifdef HAVE_TCGETATTR\n  struct termios tty;\n  cc_t disable = (cc_t) - 1, erase, werase, kill;\n\n# if !defined _POSIX_VDISABLE && defined HAVE_FPATHCONF && defined _PC_VDISABLE\n  disable = fpathconf (0, _PC_VDISABLE);\n# endif\n\n  erase = werase = kill = disable;\n\n  if (tcgetattr (0, &tty) >= 0)\n    {\n      erase = tty.c_cc[VERASE];\n# ifdef VWERASE\n      werase = tty.c_cc[VWERASE];\n# endif\n      kill = tty.c_cc[VKILL];\n    }\n\n  if (erase == disable)\n    erase = '\\177';\t\t/* rubout */\n  if (werase == disable)\n    werase = '\\027';\t\t/* ^W */\n  if (kill == disable)\n    kill = '\\025';\t\t/* ^U */\n\n  my_win.cerase = erase;\n  my_win.werase = werase;\n  my_win.kill = kill;\n#else /* !HAVE_TCGETATTR */\n  struct sgttyb tty;\n  struct ltchars ltc;\n\n  ioctl (0, TIOCGETP, &tty);\n  ioctl (0, TIOCGLTC, (struct sgttyb *) &ltc);\n  my_win.cerase = tty.sg_erase;\n  my_win.kill = tty.sg_kill;\n  if (ltc.t_werasc == (char) -1)\n    my_win.werase = '\\027';\t/* control W */\n  else\n    my_win.werase = ltc.t_werasc;\n#endif /* HAVE_TCGETATTR */\n\n  buf[0] = my_win.cerase;\n  buf[1] = my_win.kill;\n  buf[2] = my_win.werase;\n  cc = write (sockt, buf, sizeof (buf));\n  if (cc != sizeof (buf))\n    p_error (\"Lost the connection\");\n  cc = read (sockt, buf, sizeof (buf));\n  if (cc != sizeof (buf))\n    p_error (\"Lost the connection\");\n  his_win.cerase = buf[0];\n  his_win.kill = buf[1];\n  his_win.werase = buf[2];\n\n  return 0;\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "quit": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "int\nquit (void)\n{\n\n  if (curses_initialized)\n    {\n      wmove (his_win.x_win, his_win.x_nlines - 1, 0);\n      wclrtoeol (his_win.x_win);\n      wrefresh (his_win.x_win);\n      endwin ();\n    }\n  if (invitation_waiting)\n    send_delete ();\n  exit (EXIT_SUCCESS);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/invite.c": {
    "announce_invite": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nannounce_invite (void)\n{\n  CTL_RESPONSE response;\n\n  current_state = \"Trying to connect to your party's talk daemon\";\n  ctl_transact (his_machine_addr, msg, ANNOUNCE, &response);\n  remote_id = response.id_num;\n  if (response.answer != SUCCESS)\n    {\n      if (response.answer < NANSWERS)\n\tmessage (answers[response.answer]);\n      quit ();\n    }\n  /* leave the actual invitation on my talk daemon */\n  ctl_transact (my_machine_addr, msg, LEAVE_INVITE, &response);\n  local_id = response.id_num;\n\n  return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "re_invite": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\nre_invite (int sig _GL_UNUSED_PARAMETER)\n{\n\n  message (\"Ringing your party again\");\n  current_line++;\n  /* force a re-announce */\n  msg.id_num = htonl (remote_id + 1);\n  announce_invite ();\n  longjmp (invitebuf, 1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "invite_remote": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\ninvite_remote (void)\n{\n  int new_sockt;\n  struct itimerval itimer;\n  CTL_RESPONSE response;\n\n  itimer.it_value.tv_sec = RING_WAIT;\n  itimer.it_value.tv_usec = 0;\n  itimer.it_interval = itimer.it_value;\n  if (listen (sockt, 5) != 0)\n    p_error (\"Error on attempt to listen for caller\");\n\n  msg.addr.sa_family = htons (my_addr.sin_family);\n  memcpy (msg.addr.sa_data,\n\t  ((struct sockaddr *) &my_addr)->sa_data,\n\t  sizeof ((struct sockaddr *) & my_addr)->sa_data);\n\n  msg.id_num = htonl (-1);\t/* an impossible id_num */\n  invitation_waiting = 1;\n  announce_invite ();\n  /*\n   * Shut off the automatic messages for a while,\n   * so we can use the interupt timer to resend the invitation\n   */\n  end_msgs ();\n  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);\n  message (\"Waiting for your party to respond\");\n  signal (SIGALRM, re_invite);\n  setjmp (invitebuf);\n  while ((new_sockt = accept (sockt, 0, 0)) < 0)\n    {\n      if (errno == EINTR)\n\tcontinue;\n      p_error (\"Unable to connect with your party\");\n    }\n  close (sockt);\n  sockt = new_sockt;\n\n  /*\n   * Have the daemons delete the invitations now that we\n   * have connected.\n   */\n  current_state = \"Waiting for your party to respond\";\n  start_msgs ();\n\n  msg.id_num = htonl (local_id);\n  ctl_transact (my_machine_addr, msg, DELETE, &response);\n  msg.id_num = htonl (remote_id);\n  ctl_transact (his_machine_addr, msg, DELETE, &response);\n  invitation_waiting = 0;\n\n  return 0;\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "send_delete": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsend_delete (void)\n{\n\n  msg.type = DELETE;\n  /*\n   * This is just a extra clean up, so just send it\n   * and don't wait for an answer\n   */\n  msg.id_num = htonl (remote_id);\n  daemon_addr.sin_family = AF_INET;\n#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN\n  daemon_addr.sin_len = sizeof (daemon_addr);\n#endif\n  daemon_addr.sin_addr = his_machine_addr;\n  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,\n\t      (struct sockaddr *) &daemon_addr,\n\t      sizeof (daemon_addr)) != sizeof (msg))\n    perror (\"send_delete (remote)\");\n  msg.id_num = htonl (local_id);\n  daemon_addr.sin_addr = my_machine_addr;\n  if (sendto (ctl_sockt, (const char *) &msg, sizeof (msg), 0,\n\t      (struct sockaddr *) &daemon_addr,\n\t      sizeof (daemon_addr)) != sizeof (msg))\n    perror (\"send_delete (local)\");\n\n  return 0;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/io.c": {
    "talk": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int\ntalk (void)\n{\n  fd_set read_template, read_set;\n  int stdin_fd = fileno (stdin);\n  int i, nb, num_fds;\n  char buf[BUFSIZ];\n  struct timeval wait;\n\n  message (\"Connection established\");\n  beep ();\n  current_line = 0;\n\n  /*\n   * Wait on both the other process (SOCKET) and stdin.\n   */\n  FD_ZERO (&read_template);\n  FD_SET (sockt, &read_template);\n  FD_SET (stdin_fd, &read_template);\n  num_fds = (stdin_fd > sockt ? stdin_fd : sockt) + 1;\n\n  for (;;)\n    {\n      read_set = read_template;\n      wait.tv_sec = A_LONG_TIME;\n      wait.tv_usec = 0;\n      nb = select (num_fds, &read_set, 0, 0, &wait);\n      if (nb <= 0)\n\t{\n\t  if (errno == EINTR)\n\t    {\n\t      read_set = read_template;\n\t      continue;\n\t    }\n\t  /* panic, we don't know what happened */\n\t  p_error (\"Unexpected error from select\");\n\t  quit ();\n\t}\n      if (FD_ISSET (sockt, &read_set))\n\t{\n\t  /* There is data on sockt */\n\t  nb = read (sockt, buf, sizeof buf);\n\t  if (nb <= 0)\n\t    {\n\t      message (\"Connection closed. Exiting\");\n\t      quit ();\n\t    }\n\t  display (&his_win, buf, nb);\n\t}\n      if (FD_ISSET (stdin_fd, &read_set))\n\t{\n\t  /*\n\t   * We can't make the tty non_blocking, because\n\t   * curses's output routines would screw up\n\t   */\n\t  ioctl (0, FIONREAD, (struct sgttyb *) &nb);\n\t  for (i = 0; i < nb; i++)\n\t    buf[i] = getch ();\n\t  display (&my_win, buf, nb);\n\t  /* might lose data here because sockt is non-blocking */\n\t  write (sockt, buf, nb);\n\t}\n    }\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "p_error": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\np_error (char *string)\n{\n  if (curses_initialized)\n    {\n      wmove (my_win.x_win, current_line % my_win.x_nlines, 0);\n      wprintw (my_win.x_win, \"[%s : %s (%d)]\\n\",\n\t       string, strerror (errno), errno);\n      wrefresh (my_win.x_win);\n      move (LINES - 1, 0);\n      refresh ();\n    }\n  else\n    perror (string);\n\n  quit ();\n\n  return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "message": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int\nmessage (char *string)\n{\n  if (curses_initialized)\n    {\n      wmove (my_win.x_win, current_line % my_win.x_nlines, 0);\n      wprintw (my_win.x_win, \"[%s]\", string);\n      wclrtoeol (my_win.x_win);\n      current_line++;\n      wmove (my_win.x_win, current_line % my_win.x_nlines, 0);\n      wrefresh (my_win.x_win);\n    }\n  else\n    if (string && string[0])\n      printf (\"[%s]\\n\", string);\n\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/look_up.c": {
    "look_for_invite": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static int\nlook_for_invite (CTL_RESPONSE *rp)\n{\n  current_state = \"Checking for invitation on caller's machine\";\n  ctl_transact (his_machine_addr, msg, LOOK_UP, rp);\n  /* the switch is for later options, such as multiple invitations */\n  switch (rp->answer)\n    {\n\n    case SUCCESS:\n      msg.id_num = htonl (rp->id_num);\n      return (1);\n\n    default:\n      /* there wasn't an invitation waiting for us */\n      return (0);\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_local": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\ncheck_local (void)\n{\n  CTL_RESPONSE response;\n  register CTL_RESPONSE *rp = &response;\n\n  /* the rest of msg was set up in get_names */\n  msg.ctl_addr.sa_family = htons (ctl_addr.sin_family);\n  memcpy (msg.ctl_addr.sa_data,\n\t  ((struct sockaddr *) &ctl_addr)->sa_data,\n\t  sizeof ((struct sockaddr *) & ctl_addr)->sa_data);\n\n  /* must be initiating a talk */\n  if (!look_for_invite (rp))\n    return (0);\n  /*\n   * There was an invitation waiting for us,\n   * so connect with the other (hopefully waiting) party\n   */\n  current_state = \"Waiting to connect with caller\";\n  do\n    {\n      struct sockaddr addr;\n\n      if (rp->addr.sa_family != AF_INET)\n\tp_error (\"Response uses invalid network address\");\n      errno = 0;\n      addr.sa_family = rp->addr.sa_family;\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n      addr.sa_len = sizeof (struct sockaddr_in);\n#endif\n      memcpy (&addr.sa_data, &rp->addr.sa_data, sizeof (addr.sa_data));\n\n      if (connect (sockt, &addr, sizeof (addr)) != -1)\n\treturn (1);\n    }\n  while (errno == EINTR);\n  if (errno == ECONNREFUSED)\n    {\n      /*\n       * The caller gave up, but his invitation somehow\n       * was not cleared. Clear it and initiate an\n       * invitation. (We know there are no newer invitations,\n       * the talkd works LIFO.)\n       */\n      ctl_transact (his_machine_addr, msg, DELETE, rp);\n      close (sockt);\n      open_sockt ();\n      return (0);\n    }\n  p_error (\"Unable to connect with initiator\");\n\n  return -1;\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/msgs.c": {
    "disp_msg": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ndisp_msg (int sig _GL_UNUSED_PARAMETER)\n{\n  message (current_state);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "start_msgs": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nstart_msgs (void)\n{\n  struct itimerval itimer;\n\n  message (current_state);\n  signal (SIGALRM, disp_msg);\n  itimer.it_value.tv_sec = itimer.it_interval.tv_sec = MSG_INTERVAL;\n  itimer.it_value.tv_usec = itimer.it_interval.tv_usec = 0;\n  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "end_msgs": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\nend_msgs (void)\n{\n  struct itimerval itimer;\n\n  timerclear (&itimer.it_value);\n  timerclear (&itimer.it_interval);\n  setitimer (ITIMER_REAL, &itimer, (struct itimerval *) 0);\n  signal (SIGALRM, SIG_DFL);\n\n  return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/talk.c": {
    "main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n\n  set_program_name (argv[0]);\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n  iu_argp_init (\"talk\", program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  argc -= index;\n  argv += index;\n\n  if (argc == 0)\n    {\n      printf (\"Usage: talk user [ttyname]\\n\");\n      exit (-1);\n    }\n  if (!isatty (0))\n    {\n      printf (\"Standard input must be a tty, not a pipe, nor a file.\\n\");\n      exit (-1);\n    }\n\n  get_names (argc, argv);\n\n  /* Let them know we are working on connections.  */\n  current_state = \"No connection yet.\";\n\n  open_ctl ();\n  open_sockt ();\n  current_state = \"Service connection established.\";\n\n  start_msgs ();\n  if (!check_local ())\n    invite_remote ();\n  end_msgs ();\n\n  /* Our party is responding.  Upgrade user interface.  */\n  init_display ();\n  set_edit_chars ();\n\n  talk ();\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "usage": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nusage (void)\n{\n  printf (\"%s\\n\" \"Send bug reports to <%s>.\\n\", usage_str, PACKAGE_BUGREPORT);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talk/talk.h": {},
  "inetutils/inetutils-1.9.4/talk/talk_ctl.h": {},
  "inetutils/inetutils-1.9.4/talkd/acl.c": {
    "read_address": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static int\nread_address (char **line_ptr, char *ptr)\n{\n  char *startp = *line_ptr;\n  char *endp;\n  int dotcount = 0;\n\n  for (endp = startp; *endp; endp++, ptr++)\n    if (!(isdigit (*endp) || *endp == '.'))\n      break;\n    else if (endp < startp + DOTTED_QUAD_LEN)\n      {\n\tif (*endp == '.')\n\t  dotcount++;\n\t*ptr = *endp;\n      }\n    else\n      break;\n  *line_ptr = endp;\n  *ptr = 0;\n  return dotcount;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "netdef_parse": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static netdef_t *\nnetdef_parse (char *str)\n{\n  in_addr_t ipaddr, netmask;\n  netdef_t *netdef;\n  char ipbuf[DOTTED_QUAD_LEN + 1];\n\n  if (strcmp (str, \"any\") == 0)\n    {\n      ipaddr = 0;\n      netmask = 0;\n    }\n  else\n    {\n      read_address (&str, ipbuf);\n      ipaddr = inet_addr (ipbuf);\n      if (ipaddr == INADDR_NONE)\n\treturn NULL;\n      if (*str == 0)\n\tnetmask = 0xfffffffful;\n      else if (*str != '/')\n\treturn NULL;\n      else\n\t{\n\t  str++;\n\t  if (read_address (&str, ipbuf) == 0)\n\t    {\n\t      /* netmask length */\n\t      unsigned int len = strtoul (ipbuf, NULL, 0);\n\t      if (len > 32)\n\t\treturn NULL;\n\t      netmask = 0xfffffffful >> (32 - len);\n\t      netmask <<= (32 - len);\n\t      /*FIXME: hostorder? */\n\t    }\n\t  else\n\t    netmask = inet_network (ipbuf);\n\t  netmask = htonl (netmask);\n\t}\n    }\n\n  netdef = malloc (sizeof *netdef);\n  if (!netdef)\n    {\n      syslog (LOG_ERR, \"Out of memory\");\n      exit (EXIT_FAILURE);\n    }\n\n  netdef->next = NULL;\n  netdef->ipaddr = ipaddr;\n  netdef->netmask = netmask;\n\n  return netdef;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "netdef_t",
        "*\nnetdef_parse (char *str)",
        "*"
      ]
    },
    "read_acl": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "void\nread_acl (char *config_file, int system)\n{\n  FILE *fp;\n  int line;\n  char buf[128];\n  char *ptr;\n\n  if (!config_file || !config_file[0])\n    return;\n\n  fp = fopen (config_file, \"r\");\n  if (!fp)\n    {\n      if (system > 0)\n\t{\n\t  /* A missing, yet specified, site-wide ACL is a serious error.\n\t   * Abort execution whenever this happens.\n\t   */\n\t  syslog (LOG_ERR, \"Cannot open config file %s: %m\", config_file);\n\t  exit (EXIT_FAILURE);\n\t}\n      return;\t/* User setting may fail to exist.  Just ignore.  */\n    }\n\n  if (system < 0)\n    {\n      /* Alarmed state, violating file access policy.\n       * Insert a single, general denial equivalent to\n       * a rule reading `deny .* any'.\n       */\n      const char any_user[] = \"^.*$\";\n      char any_host[] = \"any\";\n      acl_t *acl;\n      regex_t re;\n      netdef_t *cur;\n\n      fclose (fp);\n      acl = malloc (sizeof *acl);\n\n      if (!acl)\n\t{\n\t  syslog (LOG_ERR, \"Out of memory\");\n\t  exit (EXIT_FAILURE);\n\t}\n      if (regcomp (&re, any_user, 0) != 0)\n\t{\n\t  syslog (LOG_ERR, \"Bad regexp '%s'.\", any_user);\n\t  exit (EXIT_FAILURE);\n\t}\n      cur = netdef_parse (any_host);\n      if (!cur)\n\t{\n\t  syslog (LOG_ERR, \"Cannot parse netdef '%s'.\", any_host);\n\t  exit (EXIT_FAILURE);\n\t}\n\n      acl->next = NULL;\n      acl->action = ACL_DENY;\n      acl->system = 0;\n      acl->re = re;\n      acl->netlist = cur;\n\n      if (!acl_tail)\n\tacl_head = acl;\n      else\n\tacl_tail->next = acl;\n      acl_tail = acl;\n\n      return;\n    }\n\n  line = 0;\n  while ((ptr = fgets (buf, sizeof buf, fp)))\n    {\n      int len, i;\n      int argc;\n      char **argv;\n      int action;\n      regex_t re;\n      netdef_t *head, *tail;\n      acl_t *acl;\n\n      line++;\n      len = strlen (ptr);\n      if (len > 0 && ptr[len - 1] == '\\n')\n\tptr[--len] = 0;\n\n      while (*ptr && isspace (*ptr))\n\tptr++;\n      if (!*ptr || *ptr == '#')\n\tcontinue;\n\n      argcv_get (ptr, \"\", &argc, &argv);\n      if (argc < 2)\n\t{\n\t  syslog (LOG_ERR, \"%s:%d: too few fields\", config_file, line);\n\t  argcv_free (argc, argv);\n\t  continue;\n\t}\n\n      if (strcmp (argv[0], \"allow\") == 0)\n\taction = ACL_ALLOW;\n      else if (strcmp (argv[0], \"deny\") == 0)\n\taction = ACL_DENY;\n      else\n\t{\n\t  syslog (LOG_WARNING, \"%s:%d: unknown keyword\", config_file, line);\n\t  argcv_free (argc, argv);\n\t  continue;\n\t}\n\n      if (regcomp (&re, argv[1], 0) != 0)\n\t{\n\t  syslog (LOG_WARNING, \"%s:%d: bad regexp\", config_file, line);\n\t  argcv_free (argc, argv);\n\t  continue;\n\t}\n\n      head = tail = NULL;\n      for (i = 2; i < argc; i++)\n\t{\n\t  netdef_t *cur = netdef_parse (argv[i]);\n\t  if (!cur)\n\t    {\n\t      syslog (LOG_ERR, \"%s:%d: can't parse netdef: %s\",\n\t\t      config_file, line, argv[i]);\n\t      continue;\n\t    }\n\t  if (!tail)\n\t    head = cur;\n\t  else\n\t    tail->next = cur;\n\t  tail = cur;\n\t}\n\n      argcv_free (argc, argv);\n\n      acl = malloc (sizeof *acl);\n      if (!acl)\n\t{\n\t  syslog (LOG_ERR, \"Out of memory\");\n\t  exit (EXIT_FAILURE);\n\t}\n      acl->next = NULL;\n      acl->action = action;\n      acl->system = system;\n      acl->netlist = head;\n      acl->re = re;\n\n      if (!acl_tail)\n\tacl_head = acl;\n      else\n\tacl_tail->next = acl;\n      acl_tail = acl;\n    }\n\n  fclose (fp);\n}",
      "lines": 159,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "open_users_acl": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static acl_t *\nopen_users_acl (char *name)\n{\n  int level = 0;\t/* Private file, not mandatory.  */\n  int rc;\n  char *filename;\n  struct passwd *pw;\n  struct stat st;\n  acl_t *mark;\n\n  pw = getpwnam (name);\n  if (!pw)\n    return NULL;\n\n  filename =\n    malloc (strlen (pw->pw_dir) + sizeof (USER_ACL_NAME) +\n\t    2 /* Null and separator.  */ );\n  if (!filename)\n    {\n      syslog (LOG_ERR, \"Out of memory\");\n      return NULL;\n    }\n\n  sprintf (filename, \"%s/%s\", pw->pw_dir, USER_ACL_NAME);\n\n  /* The location must be a file, and must be owned by the\n   * indicated user and his corresponding group.  No write\n   * access by group or world.  Record a syslog warning,\n   * should either of these not be true.\n   */\n  rc = stat (filename, &st);\n  if (rc < 0)\n    return NULL;\n  if (!S_ISREG(st.st_mode)\n      || st.st_uid != pw->pw_uid\n      || st.st_gid != pw->pw_gid\n      || st.st_mode & S_IWGRP\n      || st.st_mode & S_IWOTH)\n    {\n      if (logging || debug)\n\tsyslog (LOG_WARNING, \"Discarding '%s': insecure access.\", filename);\n      level = -1;\t/* Enforce a deny rule.  */\n    }\n\n  mark = acl_tail;\n  read_acl (filename, level);\n  free (filename);\n\n  return mark;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "acl_t",
        "*\nopen_users_acl (char *name)",
        "*"
      ]
    },
    "netdef_free": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "static void\nnetdef_free (netdef_t * netdef)\n{\n  netdef_t *next;\n\n  while (netdef)\n    {\n      next = netdef->next;\n      free (netdef);\n      netdef = next;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "acl_free": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "static void\nacl_free (acl_t * acl)\n{\n  acl_t *next;\n\n  while (acl)\n    {\n      next = acl->next;\n      regfree (&acl->re);\n      netdef_free (acl->netlist);\n      free (acl);\n      acl = next;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "discard_acl": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "static void\ndiscard_acl (acl_t * mark)\n{\n  if (mark)\n    {\n      acl_free (mark->next);\n      acl_tail = mark;\n      acl_tail->next = NULL;\n    }\n  else\n    acl_head = acl_tail = NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "acl_match": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int\nacl_match (CTL_MSG * msg, struct sockaddr_in *sa_in)\n{\n  acl_t *acl, *mark;\n  in_addr_t ip;\n  int system_action = ACL_ALLOW, user_action = ACL_ALLOW;\n  int found_user_acl = 0;\n\n  if (strict_policy)\n    system_action = ACL_DENY;\n\n  mark = open_users_acl (msg->r_name);\n  ip = sa_in->sin_addr.s_addr;\n  if (mark && (mark != acl_tail))\n    found_user_acl = 1;\n\n  for (acl = acl_head; acl; acl = acl->next)\n    {\n      netdef_t *net;\n\n      for (net = acl->netlist; net; net = net->next)\n\t{\n\t  /* Help the administrator and his users\n\t   * to simplify net list syntax:\n\t   *\n\t   *   mask the address `net->ipaddr' with\n\t   *   `net->netmask' for less computations\n\t   *   within the ACL specification.\n\t   */\n\t  if ((net->ipaddr & net->netmask) == (ip & net->netmask))\n\t    {\n\t      /*\n\t       * Site-wide ACLs concern user's name on this machine,\n\t       * whereas user's rules concern the incoming client name.\n\t       */\n\t      if (acl->system &&\n\t\t  regexec (&acl->re, msg->r_name, 0, NULL, 0) == 0)\n\t\tsystem_action = acl->action;\n\t      else if (regexec (&acl->re, msg->l_name, 0, NULL, 0) == 0)\n\t\tuser_action = acl->action;\n\t    }\n\t}\n    }\n  discard_acl (mark);\n\n  if (system_action == ACL_ALLOW)\n    return user_action;\n\n  if (strict_policy)\n    return ACL_DENY;\t/* Equal to `system_action'.  */\n\n  /* At this point it is known that last activated site-wide\n   * ACL rule has set SYSTEM_ACTION to ACL_DENY.  Do we\n   * always want it to be overridable?\n   */\n\n  /* Override ACL_DENY only if there was a user specific file\n   * ~/.talkrc containing some active rules at all.  In other\n   * words, a site-policy claiming `deny' will need an act of\n   * will by the user in order that it be overridden.\n   */\n\n  return found_user_acl ? user_action : ACL_DENY;\n}",
      "lines": 64,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talkd/announce.c": {
    "init_line": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ninit_line (LINE * lp)\n{\n  memset (lp, 0, sizeof *lp);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "format_line": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\nformat_line (LINE * lp, const char *fmt, ...)\n{\n  va_list ap;\n  int i = lp->ind;\n\n  if (lp->ind >= N_LINES)\n    return;\n  lp->ind++;\n  va_start (ap, fmt);\n  lp->size[i] = vsnprintf (lp->line[i], sizeof lp->line[i], fmt, ap);\n  lp->max_size = MAX (lp->max_size, lp->size[i]);\n  va_end (ap);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "finish_line": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static char *\nfinish_line (LINE * lp)\n{\n  int i;\n  char *p;\n\n  p = lp->buf;\n  *p++ = '\\a';\n  *p++ = '\\r';\n  *p++ = '\\n';\n  for (i = 0; i < lp->ind; i++)\n    {\n      char *q;\n      int j;\n\n      for (q = lp->line[i]; *q; q++)\n\t*p++ = *q;\n      for (j = lp->size[i]; j < lp->max_size + 2; j++)\n\t*p++ = ' ';\n      *p++ = '\\r';\n      *p++ = '\\n';\n    }\n  *p = 0;\n  return lp->buf;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfinish_line (LINE * lp)",
        "*"
      ]
    },
    "print_mesg": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int\nprint_mesg (char *tty, CTL_MSG * request, char *remote_machine)\n{\n  time_t t;\n  LINE ln;\n  char *buf;\n  struct tm *tm;\n  struct iovec iovec;\n  char *cp;\n\n  time (&t);\n  tm = localtime (&t);\n  init_line (&ln);\n  format_line (&ln, \"\");\n  format_line (&ln, \"Message from Talk_Daemon@%s at %d:%02d ...\",\n\t       hostname, tm->tm_hour, tm->tm_min);\n  format_line (&ln, \"talk: connection requested by %s@%s\",\n\t       request->l_name, remote_machine);\n  format_line (&ln, \"talk: respond with:  talk %s@%s\",\n\t       request->l_name, remote_machine);\n  format_line (&ln, \"\");\n  format_line (&ln, \"\");\n  buf = finish_line (&ln);\n\n  iovec.iov_base = buf;\n  iovec.iov_len = strlen (buf);\n\n  if ((cp = ttymsg (&iovec, 1, tty, RING_WAIT - 5)) != NULL)\n    {\n      syslog (LOG_ERR, \"%s\", cp);\n      return FAILED;\n    }\n  return SUCCESS;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "announce": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nannounce (CTL_MSG * request, char *remote_machine)\n{\n  char *ttypath;\n  int len;\n  struct stat st;\n  int rc;\n\n  len = sizeof (PATH_TTY_PFX) + strlen (request->r_tty) + 2;\n  ttypath = malloc (len);\n  if (!ttypath)\n    {\n      syslog (LOG_ERR, \"Out of memory\");\n      exit (EXIT_FAILURE);\n    }\n  sprintf (ttypath, \"%s/%s\", PATH_TTY_PFX, request->r_tty);\n  rc = stat (ttypath, &st);\n  free (ttypath);\n  if (rc < 0 || (st.st_mode & S_IWGRP) == 0)\n    return PERMISSION_DENIED;\n  return print_mesg (request->r_tty, request, remote_machine);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talkd/intalkd.h": {},
  "inetutils/inetutils-1.9.4/talkd/print.c": {
    "_xlat_num": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static const char *\n_xlat_num (int num, const char *array[], int size)\n{\n  static char buf[64];\n\n  if (num >= size)\n    {\n      snprintf (buf, sizeof buf, \"%d\", num);\n      return buf;\n    }\n  else\n    return array[num];\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_xlat_num (int num, const char *array[], int size)",
        "*"
      ]
    },
    "print_request": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nprint_request (const char *cp, CTL_MSG * mp)\n{\n  syslog (LOG_DEBUG, \"%s: %s: id %d, l_user %s, r_user %s, r_tty %s\",\n\t  cp, _xlat_num (mp->type, message_types, NITEMS (message_types)),\n\t  mp->id_num, mp->l_name, mp->r_name, mp->r_tty);\n  return 0;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "print_response": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\nprint_response (const char *cp, CTL_RESPONSE * rp)\n{\n  syslog (LOG_DEBUG, \"%s: %s: %s, id %d\",\n\t  cp,\n\t  _xlat_num (rp->type, message_types, NITEMS (message_types)),\n\t  _xlat_num (rp->answer, answers, NITEMS (answers)),\n\t  ntohl (rp->id_num));\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talkd/process.c": {
    "process_request": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nprocess_request (CTL_MSG * msg, struct sockaddr_in *sa_in, CTL_RESPONSE * rp)\n{\n  CTL_MSG *ptr;\n\n  rp->vers = TALK_VERSION;\n  rp->type = msg->type;\n  rp->id_num = htonl (0);\n  if (msg->vers != TALK_VERSION)\n    {\n      if (logging || debug)\n\tsyslog (LOG_NOTICE, \"Bad protocol version %d\", msg->vers);\n      rp->answer = BADVERSION;\n      return 0;\n    }\n\n  /* Convert the machine independent represention\n   * of the talk protocol to the present architecture.\n   * In particular, `msg->addr.sa_family' will be\n   * valid for socket initialization.\n   */\n  msg->id_num = ntohl (msg->id_num);\n  msg->addr.sa_family = ntohs (msg->addr.sa_family);\n  if (msg->addr.sa_family != AF_INET)\n    {\n      if (logging || debug)\n\tsyslog (LOG_NOTICE, \"Bad address, family %d\", msg->addr.sa_family);\n      rp->answer = BADADDR;\n      return 0;\n    }\n  /* Convert to valid socket address for this architecture.  */\n  msg->ctl_addr.sa_family = ntohs (msg->ctl_addr.sa_family);\n  if (msg->ctl_addr.sa_family != AF_INET)\n    {\n      if (logging || debug)\n\tsyslog (LOG_NOTICE, \"Bad control address, family %d\",\n\t\tmsg->ctl_addr.sa_family);\n      rp->answer = BADCTLADDR;\n      return 0;\n    }\n  /* FIXME: compare address and sa_in? */\n\n  if (acl_match (msg, sa_in) == ACL_DENY)\n    {\n      /* This denial happens for each of LOOK_UP,\n       * ANNOUNCE, and DELETE, in this order.\n       * Make a syslog note only for the first of them.\n       */\n      if ((logging || debug) && msg->type == LOOK_UP)\n\tsyslog (LOG_NOTICE, \"dropping request: %s@%s\",\n\t\tmsg->l_name, inet_ntoa (sa_in->sin_addr));\n\n      /* The answer FAILED is returned to minimize the amount\n       * of information disclosure, since ACL has denied access.\n       */\n      rp->answer = FAILED;\n      return 0;\n    }\n\n  if (debug)\n    {\n      print_request (\"process_request\", msg);\n    }\n\n  msg->pid = ntohl (msg->pid);\n\n  switch (msg->type)\n    {\n    case ANNOUNCE:\n      do_announce (msg, rp);\n      if (logging && rp->answer == SUCCESS)\n\tsyslog (LOG_INFO, \"%s@%s called by %s@%s\",\n\t\tmsg->r_name,\n\t\t(msg->r_tty[0]\n\t\t  ? msg->r_tty\n\t\t  : inet_ntoa (sa_in->sin_addr)),\n\t\tmsg->l_name,\n\t\tinet_ntoa (os2sin_addr (msg->addr)));\n      break;\n\n    case LEAVE_INVITE:\n      ptr = find_request (msg);\n      if (ptr)\n\t{\n\t  rp->id_num = htonl (ptr->id_num);\n\t  rp->answer = SUCCESS;\n\t}\n      else\n\tinsert_table (msg, rp);\n      break;\n\n    case LOOK_UP:\n      ptr = find_match (msg);\n      if (ptr)\n\t{\n\t  rp->id_num = htonl (ptr->id_num);\n\t  rp->addr = ptr->addr;\n\t  rp->addr.sa_family = htons (ptr->addr.sa_family);\n\t  rp->answer = SUCCESS;\n\t  if (logging)\n\t    syslog (LOG_INFO, \"%s talks to %s@%s\",\n\t\tmsg->r_name, msg->l_name, inet_ntoa (sa_in->sin_addr));\n\t}\n      else\n\trp->answer = NOT_HERE;\n      break;\n\n    case DELETE:\n      rp->answer = delete_invite (msg->id_num);\n      break;\n\n    default:\n      rp->answer = UNKNOWN_REQUEST;\n      break;\n    }\n\n  if (debug)\n    print_response (\"process_request response\", rp);\n\n  return 0;\n}",
      "lines": 121,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "do_announce": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\ndo_announce (CTL_MSG * mp, CTL_RESPONSE * rp)\n{\n  struct hostent *hp;\n  CTL_MSG *ptr;\n  int result;\n\n  result = find_user (mp->r_name, mp->r_tty);\n  if (result != SUCCESS)\n    {\n      rp->answer = result;\n      return;\n    }\n\n  hp = gethostbyaddr ((char *) &os2sin_addr (mp->ctl_addr),\n\t\t      sizeof (struct in_addr), AF_INET);\n  if (!hp)\n    {\n      rp->answer = MACHINE_UNKNOWN;\n      return;\n    }\n  ptr = find_request (mp);\n  if (!ptr)\n    {\n      insert_table (mp, rp);\n      rp->answer = announce (mp, hp->h_name);\n      return;\n    }\n  if (mp->id_num > ptr->id_num)\n    {\n      /* Explicit re-announce: update the id_num to avoid duplicates\n         and re-announce the talk. */\n      ptr->id_num = new_id ();\n      rp->id_num = htonl (ptr->id_num);\n      rp->answer = announce (mp, hp->h_name);\n    }\n  else\n    {\n      /* a duplicated request, so ignore it */\n      rp->id_num = htonl (ptr->id_num);\n      rp->answer = SUCCESS;\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "find_user": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\nfind_user (char *name, char *tty)\n{\n  STRUCT_UTMP *uptr;\n#ifndef HAVE_GETUTXUSER\n  STRUCT_UTMP *utmpbuf;\n  size_t utmp_count;\n#endif /* HAVE_GETUTXUSER */\n  int status;\n  struct stat statb;\n  char ftty[sizeof (PATH_TTY_PFX) + sizeof (uptr->ut_line)];\n  time_t last_time = 0;\n  int notty;\n\n  notty = (*tty == '\\0');\n\n  status = NOT_HERE;\n  strcpy (ftty, PATH_TTY_PFX);\n\n#ifdef HAVE_GETUTXUSER\n  setutxent ();\n\n  while ((uptr = getutxuser (name)))\n#else /* !HAVE_GETUTXUSER */\n  if (read_utmp (UTMP_FILE, &utmp_count, &utmpbuf,\n\t\t READ_UTMP_USER_PROCESS | READ_UTMP_CHECK_PIDS) < 0)\n    return FAILED;\n\n  for (uptr = utmpbuf; uptr < utmpbuf + utmp_count; uptr++)\n    {\n      if (!strncmp (UT_USER (uptr), name, sizeof (UT_USER (uptr))))\n#endif /* !HAVE_GETUTXUSER */\n\t{\n\t  if (notty)\n\t    {\n\t      /* no particular tty was requested */\n\t      strncpy (ftty + sizeof (PATH_TTY_PFX) - 1,\n\t\t       uptr->ut_line,\n\t\t       sizeof (ftty) - sizeof (PATH_TTY_PFX) - 1);\n\t      ftty[sizeof (ftty) - 1] = 0;\n\n\t      if (stat (ftty, &statb) == 0)\n\t\t{\n\t\t  if (!(statb.st_mode & S_IWGRP))\n\t\t    {\n\t\t      if (status != SUCCESS)\n\t\t\tstatus = PERMISSION_DENIED;\n\t\t      continue;\n\t\t    }\n\t\t  if (statb.st_atime > last_time)\n\t\t    {\n\t\t      last_time = statb.st_atime;\n\t\t      strcpy (tty, uptr->ut_line);\n\t\t      status = SUCCESS;\n\t\t    }\n\t\t  continue;\n\t\t}\n\t    }\n\t  if (!strcmp (uptr->ut_line, tty))\n\t    {\n\t      status = SUCCESS;\n\t      break;\n\t    }\n\t}\n#ifndef HAVE_GETUTXUSER\n    }\n  free (utmpbuf);\n#else /* HAVE_GETUTXUSER */\n  endutxent ();\n#endif\n\n  return status;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talkd/table.c": {
    "table_delete": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\ntable_delete (table_t * ptr)\n{\n  table_t *t;\n\n  if ((t = ptr->prev) != NULL)\n    t->next = ptr->next;\n  else\n    table = ptr->next;\n  if ((t = ptr->next) != NULL)\n    t->prev = ptr->prev;\n  free (ptr);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lookup_request": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static CTL_MSG *\nlookup_request (CTL_MSG * request,\n\t\tint (*comp) (table_t *, CTL_MSG *, time_t *))\n{\n  table_t *ptr;\n  time_t now;\n\n  time (&now);\n\n  if (debug)\n    print_request (\"lookup_request\", request);\n\n  for (ptr = table; ptr; ptr = ptr->next)\n    {\n      if (debug)\n\tprint_request (\"comparing against: \", &ptr->request);\n\n      if ((ptr->time - now) > max_request_ttl)\n\t{\n\t  /* the entry is too old */\n\t  if (debug)\n\t    print_request (\"deleting expired entry\", &ptr->request);\n\t  table_delete (ptr);\n\t}\n      else\n\t{\n\t  if (comp (ptr, request, &now) == 0)\n\t    {\n\t      if (debug)\n\t\tprint_request (\"found\", &ptr->request);\n\t      return &ptr->request;\n\t    }\n\t}\n    }\n  if (debug)\n    syslog (LOG_DEBUG, \"not found\");\n  return NULL;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "CTL_MSG",
        "*\nlookup_request (CTL_MSG * request,\n\t\tint (*comp) (table_t *, CTL_MSG *, time_t *))",
        "*"
      ]
    },
    "fuzzy_comp": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\nfuzzy_comp (table_t * ptr, CTL_MSG * request,\n\t    time_t * unused _GL_UNUSED_PARAMETER)\n{\n  if (ptr->request.type == LEAVE_INVITE\n      && strcmp (request->l_name, ptr->request.r_name) == 0\n      && strcmp (request->r_name, ptr->request.l_name) == 0)\n    return 0;\n  return 1;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_match": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "CTL_MSG *\nfind_match (CTL_MSG * request)\n{\n  return lookup_request (request, fuzzy_comp);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "CTL_MSG",
        "*\nfind_match (CTL_MSG * request)",
        "*"
      ]
    },
    "exact_comp": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\nexact_comp (table_t * ptr, CTL_MSG * request, time_t * now)\n{\n  if (request->type == ptr->request.type\n      && request->pid == ptr->request.pid\n      && strcmp (request->r_name, ptr->request.r_name) == 0\n      && strcmp (request->l_name, ptr->request.l_name) == 0)\n    {\n      ptr->time = *now;\n      return 0;\n    }\n  return 1;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_request": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "CTL_MSG *\nfind_request (CTL_MSG * request)\n{\n  return lookup_request (request, exact_comp);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "CTL_MSG",
        "*\nfind_request (CTL_MSG * request)",
        "*"
      ]
    },
    "new_id": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\nnew_id (void)\n{\n  static int current_id = 0;\n\n  current_id = (current_id + 1) % MAX_ID;\n  /* 0 is reserved, helps to pick up bugs */\n  if (current_id == 0)\n    current_id = 1;\n  return current_id;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "insert_table": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "int\ninsert_table (CTL_MSG * request, CTL_RESPONSE * response)\n{\n  table_t *ptr;\n\n  ptr = malloc (sizeof *ptr);\n  if (!ptr)\n    {\n      syslog (LOG_ERR, \"Out of memory\");\n      exit (EXIT_FAILURE);\n    }\n\n  request->id_num = new_id ();\n\n  if (debug)\n    print_request (\"insert_table\", request);\n\n  response->id_num = htonl (request->id_num);\n\n  time (&ptr->time);\n  ptr->request = *request;\n  ptr->prev = NULL;\n  ptr->next = table;\n  table = ptr;\n  return 0;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "delete_invite": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\ndelete_invite (unsigned long id_num)\n{\n  table_t *ptr;\n\n  for (ptr = table; ptr; ptr = ptr->next)\n    if (ptr->request.id_num == id_num)\n      {\n\ttable_delete (ptr);\n\treturn SUCCESS;\n      }\n  return NOT_HERE;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/talkd/talkd.c": {
    "parse_opt": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg,\n\t   struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case 'a':\n      acl_file = arg;\n      break;\n\n    case 'd':\n      debug++;\n      break;\n\n    case 'i':\n      max_idle_time = strtoul (arg, NULL, 0);\n      break;\n\n    case 'l':\n      logging++;\n      break;\n\n    case 'r':\n      max_request_ttl = strtoul (arg, NULL, 0);\n      break;\n\n    case 'S':\n      strict_policy++;\n      break;\n\n    case 't':\n      timeout = strtoul (arg, NULL, 0);\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  set_program_name (argv[0]);\n  /* Parse command line */\n  iu_argp_init (\"talkd\", program_authors);\n  argp_parse (&argp, argc, argv, 0, NULL, NULL);\n\n  openlog (\"talkd\", LOG_PID, LOG_FACILITY);\n  read_acl (acl_file, 1);\t/* System wide ACL.  Can abort.  */\n  talkd_init ();\n  talkd_run (STDIN_FILENO);\n  return 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "talkd_init": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\ntalkd_init (void)\n{\n  hostname = localhost ();\n  if (!hostname)\n    {\n      syslog (LOG_ERR, \"Cannot determine my hostname: %m\");\n      exit (EXIT_FAILURE);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "alarm_handler": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static void\nalarm_handler (int err _GL_UNUSED_PARAMETER)\n{\n  int oerrno = errno;\n\n  if ((time (NULL) - last_msg_time) >= max_idle_time)\n    exit (EXIT_SUCCESS);\n  alarm (timeout);\n  errno = oerrno;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "talkd_run": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\ntalkd_run (int fd)\n{\n  struct sockaddr ctl_addr;\n\n  signal (SIGALRM, alarm_handler);\n  alarm (timeout);\n  while (1)\n    {\n      int rc;\n      struct sockaddr_in sa_in;\n      CTL_MSG msg;\n      CTL_RESPONSE resp;\n      socklen_t len;\n\n      len = sizeof sa_in;\n      rc =\n\trecvfrom (fd, &msg, sizeof msg, 0, (struct sockaddr *) &sa_in, &len);\n      if (rc != sizeof msg)\n\t{\n\t  if (rc < 0 && errno != EINTR && (logging || debug))\n\t    syslog (LOG_NOTICE, \"recvfrom: %m\");\n\t  continue;\n\t}\n      last_msg_time = time (NULL);\n      if (process_request (&msg, &sa_in, &resp) == 0)\n\t{\n\t  ctl_addr.sa_family = msg.ctl_addr.sa_family;\n#ifdef HAVE_STRUCT_SOCKADDR_SA_LEN\n\t  ctl_addr.sa_len = sizeof (struct sockaddr_in);\n#endif\n\t  memcpy (&ctl_addr.sa_data, &msg.ctl_addr.sa_data,\n\t\t  sizeof (ctl_addr.sa_data));\n\t  rc = sendto (fd, &resp, sizeof resp, 0,\n\t\t       &ctl_addr, sizeof (ctl_addr));\n\t  if (rc != sizeof resp && (logging || debug))\n\t    syslog (LOG_NOTICE, \"sendto: %m\");\n\t}\n    }\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/authenc.c": {
    "net_write": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nnet_write (unsigned char *str, int len)\n{\n  if (NETROOM () > len)\n    {\n      ring_supply_data (&netoring, str, len);\n      if (str[0] == IAC && str[1] == SE)\n\tprintsub ('>', &str[2], len - 2);\n      return (len);\n    }\n  return (0);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "net_encrypt": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\nnet_encrypt ()\n{\n# ifdef\tENCRYPTION\n  if (encrypt_output)\n    ring_encrypt (&netoring, encrypt_output);\n  else\n    ring_clearto (&netoring);\n# endif\t/* ENCRYPTION */\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "telnet_spin": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\ntelnet_spin ()\n{\n  return (-1);\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "telnet_getenv": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "char *\ntelnet_getenv (char *val)\n{\n  return ((char *) env_getvalue (val));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "char",
        "*\ntelnet_getenv (char *val)",
        "*"
      ]
    },
    "telnet_gets": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "char *\ntelnet_gets (char *prompt, char *result, int length, int echo)\n{\n# if !HAVE_DECL_GETPASS\n  extern char *getpass ();\n# endif\n  extern int globalmode;\n  int om = globalmode;\n  char *res;\n\n  TerminalNewMode (-1);\n  if (echo)\n    {\n      printf (\"%s\", prompt);\n      res = fgets (result, length, stdin);\n    }\n  else\n    {\n      res = getpass (prompt);\n      if (res)\n\t{\n\t  strncpy (result, res, length);\n\t  memset (res, 0, strlen (res));\n\t  res = result;\n\t}\n    }\n  TerminalNewMode (om);\n  return (res);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "char",
        "*\ntelnet_gets (char *prompt, char *result, int length, int echo)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/commands.c": {
    "makeargv": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nmakeargv (void)\n{\n  register char *cp, *cp2, c;\n  register char **argp = margv;\n\n  margc = 0;\n  cp = line;\n  if (*cp == '!')\n    {\t\t\t\t/* Special case shell escape */\n      strcpy (saveline, line);\t/* save for shell command */\n      *argp++ = \"!\";\t\t/* No room in string to get this */\n      margc++;\n      cp++;\n    }\n  while ((c = *cp))\n    {\n      register int inquote = 0;\n      while (isspace (c))\n\tc = *++cp;\n      if (c == '\\0')\n\tbreak;\n      *argp++ = cp;\n      margc += 1;\n      for (cp2 = cp; c != '\\0'; c = *++cp)\n\t{\n\t  if (inquote)\n\t    {\n\t      if (c == inquote)\n\t\t{\n\t\t  inquote = 0;\n\t\t  continue;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (c == '\\\\')\n\t\t{\n\t\t  if ((c = *++cp) == '\\0')\n\t\t    break;\n\t\t}\n\t      else if (c == '\"')\n\t\t{\n\t\t  inquote = '\"';\n\t\t  continue;\n\t\t}\n\t      else if (c == '\\'')\n\t\t{\n\t\t  inquote = '\\'';\n\t\t  continue;\n\t\t}\n\t      else if (isspace (c))\n\t\tbreak;\n\t    }\n\t  *cp2++ = c;\n\t}\n      *cp2 = '\\0';\n      if (c == '\\0')\n\tbreak;\n      cp++;\n    }\n  *argp++ = 0;\n}",
      "lines": 63,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "special": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static int\nspecial (register char *s)\n{\n  register char c;\n  char b;\n\n  switch (*s)\n    {\n    case '^':\n      b = *++s;\n      if (b == '?')\n\t{\n\t  c = b | 0x40;\t\t/* DEL */\n\t}\n      else\n\t{\n\t  c = b & 0x1f;\n\t}\n      break;\n    default:\n      c = *s;\n      break;\n    }\n  return c;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "control": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static const char *\ncontrol (register cc_t c)\n{\n  static char buf[5];\n  /*\n   * The only way I could get the Sun 3.5 compiler\n   * to shut up about\n   *      if ((unsigned int)c >= 0x80)\n   * was to assign \"c\" to an unsigned int variable...\n   * Arggg....\n   */\n  register unsigned int uic = (unsigned int) c;\n\n  if (uic == 0x7f)\n    return (\"^?\");\n  if (c == (cc_t) _POSIX_VDISABLE)\n    {\n      return \"off\";\n    }\n  if (uic >= 0x80)\n    {\n      buf[0] = '\\\\';\n      buf[1] = ((c >> 6) & 07) + '0';\n      buf[2] = ((c >> 3) & 07) + '0';\n      buf[3] = (c & 07) + '0';\n      buf[4] = 0;\n    }\n  else if (uic >= 0x20)\n    {\n      buf[0] = c;\n      buf[1] = 0;\n    }\n  else\n    {\n      buf[0] = '^';\n      buf[1] = '@' + c;\n      buf[2] = 0;\n    }\n  return (buf);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ncontrol (register cc_t c)",
        "*"
      ]
    },
    "sendcmd": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "static int\nsendcmd (int argc, char **argv)\n{\n  int count;\t\t\t/* how many bytes we are going to need to send */\n  int i;\n  struct sendlist *s;\t\t/* pointer to current command */\n  int success = 0;\n  int needconnect = 0;\n\n  if (argc < 2)\n    {\n      printf (\"need at least one argument for 'send' command\\n\");\n      printf (\"'send ?' for help\\n\");\n      return 0;\n    }\n  /*\n   * First, validate all the send arguments.\n   * In addition, we see how much space we are going to need, and\n   * whether or not we will be doing a \"SYNCH\" operation (which\n   * flushes the network queue).\n   */\n  count = 0;\n  for (i = 1; i < argc; i++)\n    {\n      s = GETSEND (argv[i]);\n      if (s == 0)\n\t{\n\t  printf (\"Unknown send argument '%s'\\n'send ?' for help.\\n\",\n\t\t  argv[i]);\n\t  return 0;\n\t}\n      else if (Ambiguous (s))\n\t{\n\t  printf (\"Ambiguous send argument '%s'\\n'send ?' for help.\\n\",\n\t\t  argv[i]);\n\t  return 0;\n\t}\n      if (i + s->narg >= argc)\n\t{\n\t  fprintf (stderr,\n\t\t   \"Need %d argument%s to 'send %s' command.  'send %s ?' for help.\\n\",\n\t\t   s->narg, s->narg == 1 ? \"\" : \"s\", s->name, s->name);\n\t  return 0;\n\t}\n      count += s->nbyte;\n      if (s->handler == send_help)\n\t{\n\t  send_help ();\n\t  return 0;\n\t}\n\n      i += s->narg;\n      needconnect += s->needconnect;\n    }\n  if (!connected && needconnect)\n    {\n      printf (\"?Need to be connected first.\\n\");\n      printf (\"'send ?' for help\\n\");\n      return 0;\n    }\n  /* Now, do we have enough room? */\n  if (NETROOM () < count)\n    {\n      printf (\"There is not enough room in the buffer TO the network\\n\");\n      printf (\"to process your request.  Nothing will be done.\\n\");\n      printf (\"('send synch' will throw away most data in the network\\n\");\n      printf (\"buffer, if this might help.)\\n\");\n      return 0;\n    }\n  /* OK, they are all OK, now go through again and actually send */\n  count = 0;\n  for (i = 1; i < argc; i++)\n    {\n      if ((s = GETSEND (argv[i])) == 0)\n\t{\n\t  fprintf (stderr, \"Telnet 'send' error - argument disappeared!\\n\");\n\t  quit ();\n\t}\n      if (s->handler)\n\t{\n\t  count++;\n\t  success += (*s->handler) ((s->narg > 0) ? argv[i + 1] : 0,\n\t\t\t\t    (s->narg > 1) ? argv[i + 2] : 0);\n\t  i += s->narg;\n\t}\n      else\n\t{\n\t  NET2ADD (IAC, s->what);\n\t  printoption (\"SENT\", IAC, s->what);\n\t}\n    }\n  return (count == success);\n}",
      "lines": 93,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_esc": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static int\nsend_esc (void)\n{\n  NETADD (escape);\n  return 1;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_tncmd": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "int\nsend_tncmd (void (*func) (), char *cmd, char *name)\n{\n  char **cpp;\n#if !HAVE_DECL_TELOPTS\n  extern char *telopts[];\n#endif\n  register int val = 0;\n\n  if (isprefix (name, \"help\") || isprefix (name, \"?\"))\n    {\n      register int col, len;\n\n      printf (\"Usage: send %s <value|option>\\n\", cmd);\n      printf (\"\\\"value\\\" must be from 0 to 255\\n\");\n      printf (\"Valid options are:\\n\\t\");\n\n      col = 8;\n      for (cpp = telopts; *cpp; cpp++)\n\t{\n\t  len = strlen (*cpp) + 3;\n\t  if (col + len > 65)\n\t    {\n\t      printf (\"\\n\\t\");\n\t      col = 8;\n\t    }\n\t  printf (\" \\\"%s\\\"\", *cpp);\n\t  col += len;\n\t}\n      printf (\"\\n\");\n      return 0;\n    }\n  cpp = (char **) genget (name, telopts, sizeof (char *));\n  if (Ambiguous (cpp))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('send %s ?' for help).\\n\",\n\t       name, cmd);\n      return 0;\n    }\n  if (cpp)\n    {\n#if HAVE_DECL_TELOPTS\n      val = cpp - (char **) telopts;\n#else /* !HAVE_DECL_TELOPTS */\n      val = cpp - telopts;\n#endif\n    }\n  else\n    {\n      register char *cp = name;\n\n      while (*cp >= '0' && *cp <= '9')\n\t{\n\t  val *= 10;\n\t  val += *cp - '0';\n\t  cp++;\n\t}\n      if (*cp != 0)\n\t{\n\t  fprintf (stderr, \"'%s': unknown argument ('send %s ?' for help).\\n\",\n\t\t   name, cmd);\n\t  return 0;\n\t}\n      else if (val < 0 || val > 255)\n\t{\n\t  fprintf (stderr, \"'%s': bad value ('send %s ?' for help).\\n\",\n\t\t   name, cmd);\n\t  return 0;\n\t}\n    }\n  if (!connected)\n    {\n      printf (\"?Need to be connected first.\\n\");\n      return 0;\n    }\n  (*func) (val, 1);\n  return 1;\n}",
      "lines": 78,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "send_docmd": {
      "start_point": [
        518,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static int\nsend_docmd (char *name)\n{\n  return (send_tncmd (send_do, \"do\", name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_dontcmd": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "static int\nsend_dontcmd (char *name)\n{\n  return (send_tncmd (send_dont, \"dont\", name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_willcmd": {
      "start_point": [
        530,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "static int\nsend_willcmd (char *name)\n{\n  return (send_tncmd (send_will, \"will\", name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_wontcmd": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "static int\nsend_wontcmd (char *name)\n{\n  return (send_tncmd (send_wont, \"wont\", name));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "send_help": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        552,
        1
      ],
      "content": "static int\nsend_help (void)\n{\n  struct sendlist *s;\t\t/* pointer to current command */\n  for (s = Sendlist; s->name; s++)\n    {\n      if (s->help)\n\tprintf (\"%-15s %s\\n\", s->name, s->help);\n    }\n  return (0);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lclchars": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "static int\nlclchars (void)\n{\n  donelclchars = 1;\n  return 1;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togdebug": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "static int\ntogdebug (void)\n{\n#ifndef NOT43\n  if (net > 0 && (SetSockOpt (net, SOL_SOCKET, SO_DEBUG, debug)) < 0)\n    {\n      perror (\"setsockopt (SO_DEBUG)\");\n    }\n#else /* NOT43 */\n  if (debug)\n    {\n      if (net > 0 && SetSockOpt (net, SOL_SOCKET, SO_DEBUG, 0, 0) < 0)\n\tperror (\"setsockopt (SO_DEBUG)\");\n    }\n  else\n    printf (\"Cannot turn off socket debugging\\n\");\n#endif /* NOT43 */\n  return 1;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togcrlf": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "static int\ntogcrlf (void)\n{\n  if (crlf)\n    {\n      printf (\"Will send carriage returns as telnet <CR><LF>.\\n\");\n    }\n  else\n    {\n      printf (\"Will send carriage returns as telnet <CR><NUL>.\\n\");\n    }\n  return 1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togbinary": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static int\ntogbinary (int val)\n{\n  donebinarytoggle = 1;\n\n  if (val >= 0)\n    {\n      binmode = val;\n    }\n  else\n    {\n      if (my_want_state_is_will (TELOPT_BINARY) &&\n\t  my_want_state_is_do (TELOPT_BINARY))\n\t{\n\t  binmode = 1;\n\t}\n      else if (my_want_state_is_wont (TELOPT_BINARY) &&\n\t       my_want_state_is_dont (TELOPT_BINARY))\n\t{\n\t  binmode = 0;\n\t}\n      val = binmode ? 0 : 1;\n    }\n\n  if (val == 1)\n    {\n      if (my_want_state_is_will (TELOPT_BINARY) &&\n\t  my_want_state_is_do (TELOPT_BINARY))\n\t{\n\t  printf (\"Already operating in binary mode with remote host.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating binary mode with remote host.\\n\");\n\t  tel_enter_binary (3);\n\t}\n    }\n  else\n    {\n      if (my_want_state_is_wont (TELOPT_BINARY) &&\n\t  my_want_state_is_dont (TELOPT_BINARY))\n\t{\n\t  printf (\"Already in network ascii mode with remote host.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating network ascii mode with remote host.\\n\");\n\t  tel_leave_binary (3);\n\t}\n    }\n  return 1;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togrbinary": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        689,
        1
      ],
      "content": "static int\ntogrbinary (int val)\n{\n  donebinarytoggle = 1;\n\n  if (val == -1)\n    val = my_want_state_is_do (TELOPT_BINARY) ? 0 : 1;\n\n  if (val == 1)\n    {\n      if (my_want_state_is_do (TELOPT_BINARY))\n\t{\n\t  printf (\"Already receiving in binary mode.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating binary mode on input.\\n\");\n\t  tel_enter_binary (1);\n\t}\n    }\n  else\n    {\n      if (my_want_state_is_dont (TELOPT_BINARY))\n\t{\n\t  printf (\"Already receiving in network ascii mode.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating network ascii mode on input.\\n\");\n\t  tel_leave_binary (1);\n\t}\n    }\n  return 1;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togxbinary": {
      "start_point": [
        691,
        0
      ],
      "end_point": [
        724,
        1
      ],
      "content": "static int\ntogxbinary (int val)\n{\n  donebinarytoggle = 1;\n\n  if (val == -1)\n    val = my_want_state_is_will (TELOPT_BINARY) ? 0 : 1;\n\n  if (val == 1)\n    {\n      if (my_want_state_is_will (TELOPT_BINARY))\n\t{\n\t  printf (\"Already transmitting in binary mode.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating binary mode on output.\\n\");\n\t  tel_enter_binary (2);\n\t}\n    }\n  else\n    {\n      if (my_want_state_is_wont (TELOPT_BINARY))\n\t{\n\t  printf (\"Already transmitting in network ascii mode.\\n\");\n\t}\n      else\n\t{\n\t  printf (\"Negotiating network ascii mode on output.\\n\");\n\t  tel_leave_binary (2);\n\t}\n    }\n  return 1;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togglehelp": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static int\ntogglehelp (void)\n{\n  struct togglelist *c;\n\n  for (c = Togglelist; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s toggle %s\\n\", c->name, c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n  printf (\"\\n\");\n  printf (\"%-15s %s\\n\", \"?\", \"display help information\");\n  return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "settogglehelp": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static void\nsettogglehelp (int set)\n{\n  struct togglelist *c;\n\n  for (c = Togglelist; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s %s %s\\n\", c->name, set ? \"enable\" : \"disable\",\n\t\t    c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "toggle": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        964,
        1
      ],
      "content": "static int\ntoggle (int argc, char *argv[])\n{\n  int retval = 1;\n  char *name;\n  struct togglelist *c;\n\n  if (argc < 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'toggle' command.  'toggle ?' for help.\\n\");\n      return 0;\n    }\n  argc--;\n  argv++;\n  while (argc--)\n    {\n      name = *argv++;\n      c = GETTOGGLE (name);\n      if (Ambiguous (c))\n\t{\n\t  fprintf (stderr,\n\t\t   \"'%s': ambiguous argument ('toggle ?' for help).\\n\", name);\n\t  return 0;\n\t}\n      else if (c == 0)\n\t{\n\t  fprintf (stderr, \"'%s': unknown argument ('toggle ?' for help).\\n\",\n\t\t   name);\n\t  return 0;\n\t}\n      else\n\t{\n\t  if (c->variable)\n\t    {\n\t      *c->variable = !*c->variable;\t/* invert it */\n\t      if (c->actionexplanation)\n\t\t{\n\t\t  printf (\"%s %s.\\n\", *c->variable ? \"Will\" : \"Won't\",\n\t\t\t  c->actionexplanation);\n\t\t}\n\t    }\n\t  if (c->handler)\n\t    {\n\t      retval &= (*c->handler) (-1);\n\t    }\n\t}\n    }\n  return retval;\n}",
      "lines": 50,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_setlist_init": {
      "start_point": [
        1014,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "void\n_setlist_init ()\n{\n# ifndef KLUDGELINEMODE\n#  define N 5\n# else\n#  define N 6\n# endif\n  Setlist[N + 0].charp = &termFlushChar;\n  Setlist[N + 1].charp = &termIntChar;\n  Setlist[N + 2].charp = &termQuitChar;\n  Setlist[N + 3].charp = &termEofChar;\n  Setlist[N + 6].charp = &termEraseChar;\n  Setlist[N + 7].charp = &termKillChar;\n  Setlist[N + 8].charp = &termLiteralNextChar;\n  Setlist[N + 9].charp = &termSuspChar;\n  Setlist[N + 10].charp = &termRprntChar;\n  Setlist[N + 11].charp = &termWerasChar;\n  Setlist[N + 12].charp = &termStartChar;\n  Setlist[N + 13].charp = &termStopChar;\n  Setlist[N + 14].charp = &termForw1Char;\n  Setlist[N + 15].charp = &termForw2Char;\n  Setlist[N + 16].charp = &termAytChar;\n# undef\tN\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "getset": {
      "start_point": [
        1041,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "static struct setlist *\ngetset (char *name)\n{\n  return (struct setlist *)\n    genget (name, (char **) Setlist, sizeof (struct setlist));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct setlist",
        "struct",
        "setlist",
        "*\ngetset (char *name)",
        "*"
      ]
    },
    "set_escape_char": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "void\nset_escape_char (char *s)\n{\n  if (rlogin != _POSIX_VDISABLE)\n    {\n      rlogin = (s && *s) ? special (s) : _POSIX_VDISABLE;\n      printf (\"Telnet rlogin escape character is '%s'.\\n\", control (rlogin));\n    }\n  else\n    {\n      escape = (s && *s) ? special (s) : _POSIX_VDISABLE;\n      printf (\"Telnet escape character is '%s'.\\n\", control (escape));\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "setcmd": {
      "start_point": [
        1063,
        0
      ],
      "end_point": [
        1153,
        1
      ],
      "content": "static int\nsetcmd (int argc, char *argv[])\n{\n  int value;\n  struct setlist *ct;\n  struct togglelist *c;\n\n  if (argc < 2 || argc > 3)\n    {\n      printf (\"Format is 'set Name Value'\\n'set ?' for help.\\n\");\n      return 0;\n    }\n  if ((argc == 2) && (isprefix (argv[1], \"?\") || isprefix (argv[1], \"help\")))\n    {\n      for (ct = Setlist; ct->name; ct++)\n\tprintf (\"%-15s %s\\n\", ct->name, ct->help);\n      printf (\"\\n\");\n      settogglehelp (1);\n      printf (\"%-15s %s\\n\", \"?\", \"display help information\");\n      return 0;\n    }\n\n  ct = getset (argv[1]);\n  if (ct == 0)\n    {\n      c = GETTOGGLE (argv[1]);\n      if (c == 0)\n\t{\n\t  fprintf (stderr, \"'%s': unknown argument ('set ?' for help).\\n\",\n\t\t   argv[1]);\n\t  return 0;\n\t}\n      else if (Ambiguous (c))\n\t{\n\t  fprintf (stderr, \"'%s': ambiguous argument ('set ?' for help).\\n\",\n\t\t   argv[1]);\n\t  return 0;\n\t}\n      if (c->variable)\n\t{\n\t  if ((argc == 2) || (strcmp (\"on\", argv[2]) == 0))\n\t    *c->variable = 1;\n\t  else if (strcmp (\"off\", argv[2]) == 0)\n\t    *c->variable = 0;\n\t  else\n\t    {\n\t      printf\n\t\t(\"Format is 'set togglename [on|off]'\\n'set ?' for help.\\n\");\n\t      return 0;\n\t    }\n\t  if (c->actionexplanation)\n\t    {\n\t      printf (\"%s %s.\\n\", *c->variable ? \"Will\" : \"Won't\",\n\t\t      c->actionexplanation);\n\t    }\n\t}\n      if (c->handler)\n\t(*c->handler) (1);\n    }\n  else if (argc != 3)\n    {\n      printf (\"Format is 'set Name Value'\\n'set ?' for help.\\n\");\n      return 0;\n    }\n  else if (Ambiguous (ct))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('set ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  else if (ct->handler)\n    {\n      (*ct->handler) (argv[2]);\n      printf (\"%s set to \\\"%s\\\".\\n\", ct->name, (char *) ct->charp);\n    }\n  else\n    {\n      if (strcmp (\"off\", argv[2]))\n\t{\n\t  value = special (argv[2]);\n\t}\n      else\n\t{\n\t  value = _POSIX_VDISABLE;\n\t}\n      *(ct->charp) = (cc_t) value;\n      printf (\"%s character is '%s'.\\n\", ct->name, control (*(ct->charp)));\n    }\n  slc_check ();\n  return 1;\n}",
      "lines": 91,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "unsetcmd": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "static int\nunsetcmd (int argc, char *argv[])\n{\n  struct setlist *ct;\n  struct togglelist *c;\n  register char *name;\n\n  if (argc < 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'unset' command.  'unset ?' for help.\\n\");\n      return 0;\n    }\n  if (isprefix (argv[1], \"?\") || isprefix (argv[1], \"help\"))\n    {\n      for (ct = Setlist; ct->name; ct++)\n\tprintf (\"%-15s %s\\n\", ct->name, ct->help);\n      printf (\"\\n\");\n      settogglehelp (0);\n      printf (\"%-15s %s\\n\", \"?\", \"display help information\");\n      return 0;\n    }\n\n  argc--;\n  argv++;\n  while (argc--)\n    {\n      name = *argv++;\n      ct = getset (name);\n      if (ct == 0)\n\t{\n\t  c = GETTOGGLE (name);\n\t  if (c == 0)\n\t    {\n\t      fprintf (stderr,\n\t\t       \"'%s': unknown argument ('unset ?' for help).\\n\",\n\t\t       name);\n\t      return 0;\n\t    }\n\t  else if (Ambiguous (c))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"'%s': ambiguous argument ('unset ?' for help).\\n\",\n\t\t       name);\n\t      return 0;\n\t    }\n\t  if (c->variable)\n\t    {\n\t      *c->variable = 0;\n\t      if (c->actionexplanation)\n\t\t{\n\t\t  printf (\"%s %s.\\n\", *c->variable ? \"Will\" : \"Won't\",\n\t\t\t  c->actionexplanation);\n\t\t}\n\t    }\n\t  if (c->handler)\n\t    (*c->handler) (0);\n\t}\n      else if (Ambiguous (ct))\n\t{\n\t  fprintf (stderr, \"'%s': ambiguous argument ('unset ?' for help).\\n\",\n\t\t   name);\n\t  return 0;\n\t}\n      else if (ct->handler)\n\t{\n\t  (*ct->handler) (0);\n\t  printf (\"%s reset to \\\"%s\\\".\\n\", ct->name, (char *) ct->charp);\n\t}\n      else\n\t{\n\t  *(ct->charp) = _POSIX_VDISABLE;\n\t  printf (\"%s character is '%s'.\\n\", ct->name,\n\t\t  control (*(ct->charp)));\n\t}\n    }\n  return 1;\n}",
      "lines": 78,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dokludgemode": {
      "start_point": [
        1241,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static int\ndokludgemode (void)\n{\n  kludgelinemode = 1;\n  send_wont (TELOPT_LINEMODE, 1);\n  send_dont (TELOPT_SGA, 1);\n  send_dont (TELOPT_ECHO, 1);\n  return 0;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dolinemode": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1262,
        1
      ],
      "content": "static int\ndolinemode (void)\n{\n#ifdef\tKLUDGELINEMODE\n  if (kludgelinemode)\n    send_dont (TELOPT_SGA, 1);\n#endif\n  send_will (TELOPT_LINEMODE, 1);\n  send_dont (TELOPT_ECHO, 1);\n  return 1;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "docharmode": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1275,
        1
      ],
      "content": "static int\ndocharmode (void)\n{\n#ifdef\tKLUDGELINEMODE\n  if (kludgelinemode)\n    send_do (TELOPT_SGA, 1);\n  else\n#endif\n    send_wont (TELOPT_LINEMODE, 1);\n  send_do (TELOPT_ECHO, 1);\n  return 1;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dolmmode": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1296,
        1
      ],
      "content": "static int\ndolmmode (int bit, int on)\n{\n  unsigned char c;\n  extern int linemode;\n\n  if (my_want_state_is_wont (TELOPT_LINEMODE))\n    {\n      printf (\"?Need to have LINEMODE option enabled first.\\n\");\n      printf (\"'mode ?' for help.\\n\");\n      return 0;\n    }\n\n  if (on)\n    c = (linemode | bit);\n  else\n    c = (linemode & ~bit);\n  lm_mode (&c, 1, 1);\n  return 1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_mode": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1302,
        1
      ],
      "content": "int\nset_mode (int bit)\n{\n  return dolmmode (bit, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "clear_mode": {
      "start_point": [
        1304,
        0
      ],
      "end_point": [
        1308,
        1
      ],
      "content": "int\nclear_mode (int bit)\n{\n  return dolmmode (bit, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "modehelp": {
      "start_point": [
        1355,
        0
      ],
      "end_point": [
        1372,
        1
      ],
      "content": "int\nmodehelp (void)\n{\n  struct modelist *mt;\n\n  printf (\"format is:  'mode Mode', where 'Mode' is one of:\\n\\n\");\n  for (mt = ModeList; mt->name; mt++)\n    {\n      if (mt->help)\n\t{\n\t  if (*mt->help)\n\t    printf (\"%-15s %s\\n\", mt->name, mt->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "modecmd": {
      "start_point": [
        1377,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "static int\nmodecmd (int argc, char *argv[])\n{\n  struct modelist *mt;\n\n  if (argc != 2)\n    {\n      printf (\"'mode' command requires an argument\\n\");\n      printf (\"'mode ?' for help.\\n\");\n    }\n  else if ((mt = GETMODECMD (argv[1])) == 0)\n    {\n      fprintf (stderr, \"Unknown mode '%s' ('mode ?' for help).\\n\", argv[1]);\n    }\n  else if (Ambiguous (mt))\n    {\n      fprintf (stderr, \"Ambiguous mode '%s' ('mode ?' for help).\\n\", argv[1]);\n    }\n  else if (mt->needconnect && !connected)\n    {\n      printf (\"?Need to be connected first.\\n\");\n      printf (\"'mode ?' for help.\\n\");\n    }\n  else if (mt->handler)\n    {\n      return (*mt->handler) (mt->arg1);\n    }\n  return 0;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "display": {
      "start_point": [
        1412,
        0
      ],
      "end_point": [
        1484,
        1
      ],
      "content": "static int\ndisplay (int argc, char *argv[])\n{\n  struct togglelist *tl;\n  struct setlist *sl;\n\n#define dotog(tl)\tif (tl->variable && tl->actionexplanation) { \\\n\t\t\t    if (*tl->variable) { \\\n\t\t\t\tprintf(\"will\"); \\\n\t\t\t    } else { \\\n\t\t\t\tprintf(\"won't\"); \\\n\t\t\t    } \\\n\t\t\t    printf(\" %s.\\n\", tl->actionexplanation); \\\n\t\t\t}\n\n#define doset(sl)   if (sl->name && *sl->name != ' ') { \\\n\t\t\tif (sl->handler == 0) \\\n\t\t\t    printf(\"%-15s [%s]\\n\", sl->name, control(*sl->charp)); \\\n\t\t\telse \\\n\t\t\t    printf(\"%-15s \\\"%s\\\"\\n\", sl->name, (char *)sl->charp); \\\n\t\t    }\n\n  if (argc == 1)\n    {\n      for (tl = Togglelist; tl->name; tl++)\n\t{\n\t  dotog (tl);\n\t}\n      printf (\"\\n\");\n      for (sl = Setlist; sl->name; sl++)\n\t{\n\t  doset (sl);\n\t}\n    }\n  else\n    {\n      int i;\n\n      for (i = 1; i < argc; i++)\n\t{\n\t  sl = getset (argv[i]);\n\t  tl = GETTOGGLE (argv[i]);\n\t  if (Ambiguous (sl) || Ambiguous (tl))\n\t    {\n\t      printf (\"?Ambiguous argument '%s'.\\n\", argv[i]);\n\t      return 0;\n\t    }\n\t  else if (!sl && !tl)\n\t    {\n\t      printf (\"?Unknown argument '%s'.\\n\", argv[i]);\n\t      return 0;\n\t    }\n\t  else\n\t    {\n\t      if (tl)\n\t\t{\n\t\t  dotog (tl);\n\t\t}\n\t      if (sl)\n\t\t{\n\t\t  doset (sl);\n\t\t}\n\t    }\n\t}\n    }\n/*@*/ optionstatus ();\n#ifdef\tENCRYPTION\n  EncryptStatus ();\n#endif /* ENCRYPTION */\n  return 1;\n#undef\tdoset\n#undef\tdotog\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setescape": {
      "start_point": [
        1494,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "static int\nsetescape (int argc, char *argv[])\n{\n  register char *arg;\n  char buf[50];\n\n  printf (\"Deprecated usage - please use 'set escape%s%s' in the future.\\n\",\n\t  (argc > 2) ? \" \" : \"\", (argc > 2) ? argv[1] : \"\");\n  if (argc > 2)\n    arg = argv[1];\n  else\n    {\n      printf (\"new escape character: \");\n      if (fgets (buf, sizeof (buf), stdin) == NULL)\n\t{\n\t  buf[0] = '\\0';\n\t  printf (\"\\n\");\n\t}\n      arg = buf;\n    }\n  if (arg[0] != '\\0')\n    escape = arg[0];\n  if (!In3270)\n    {\n      printf (\"Escape character is '%s'.\\n\", control (escape));\n    }\n  fflush (stdout);\n  return 1;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "togcrmod": {
      "start_point": [
        1524,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "static int\ntogcrmod (void)\n{\n  crmod = !crmod;\n  printf (\"Deprecated usage - please use 'toggle crmod' in the future.\\n\");\n  printf (\"%s map carriage return on output.\\n\", crmod ? \"Will\" : \"Won't\");\n  fflush (stdout);\n  return 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "suspend": {
      "start_point": [
        1534,
        0
      ],
      "end_point": [
        1562,
        1
      ],
      "content": "int\nsuspend (void)\n{\n#ifdef\tSIGTSTP\n  setcommandmode ();\n  {\n    long oldrows, oldcols, newrows, newcols, err;\n\n    err = (TerminalWindowSize (&oldrows, &oldcols) == 0) ? 1 : 0;\n    kill (0, SIGTSTP);\n    /*\n     * If we didn't get the window size before the SUSPEND, but we\n     * can get them now (?), then send the NAWS to make sure that\n     * we are set up for the right window size.\n     */\n    if (TerminalWindowSize (&newrows, &newcols) && connected &&\n\t(err || ((oldrows != newrows) || (oldcols != newcols))))\n      {\n\tsendnaws ();\n      }\n  }\n  /* reget parameters in case they were changed */\n  TerminalSaveState ();\n  setconnmode (0);\n#else\n  printf (\"Suspend is not supported.  Try the '!' command instead\\n\");\n#endif\n  return 1;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "shell": {
      "start_point": [
        1565,
        0
      ],
      "end_point": [
        1615,
        1
      ],
      "content": "int\nshell (int argc, char *argv[] _GL_UNUSED_PARAMETER)\n{\n  long oldrows, oldcols, newrows, newcols, err;\n\n  setcommandmode ();\n\n  err = (TerminalWindowSize (&oldrows, &oldcols) == 0) ? 1 : 0;\n  switch (vfork ())\n    {\n    case -1:\n      perror (\"Fork failed\\n\");\n      break;\n\n    case 0:\n      {\n\t/*\n\t * Fire up the shell in the child.\n\t */\n\tregister char *shellp, *shellname;\n# ifndef strrchr\n\textern char *strrchr (const char *, int);\n# endif\n\n\tshellp = getenv (\"SHELL\");\n\tif (shellp == NULL)\n\t  shellp = PATH_BSHELL;\n\tshellname = strrchr (shellp, '/');\n\tif (shellname == NULL)\n\t  shellname = shellp;\n\telse\n\t  shellname++;\n\tif (argc > 1)\n\t  execl (shellp, shellname, \"-c\", &saveline[1], NULL);\n\telse\n\t  execl (shellp, shellname, NULL);\n\tperror (\"Execl\");\n\t_exit (EXIT_FAILURE);\n      }\n    default:\n      wait ((int *) 0);\t\t/* Wait for the shell to complete */\n\n      if (TerminalWindowSize (&newrows, &newcols) && connected &&\n\t  (err || ((oldrows != newrows) || (oldcols != newcols))))\n\t{\n\t  sendnaws ();\n\t}\n      break;\n    }\n  return 1;\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "bye": {
      "start_point": [
        1623,
        0
      ],
      "end_point": [
        1649,
        1
      ],
      "content": "static int\nbye (int argc, char *argv[])\n{\n  extern int resettermname;\n\n  if (connected)\n    {\n      shutdown (net, 2);\n      printf (\"Connection closed.\\n\");\n      NetClose (net);\n      connected = 0;\n      resettermname = 1;\n#if defined AUTHENTICATION || defined ENCRYPTION\n      auth_encrypt_connect (connected);\n#endif /* defined(AUTHENTICATION) || defined(ENCRYPTION) */\n      /* reset options */\n      tninit ();\n#if defined TN3270\n      SetIn3270 ();\t\t/* Get out of 3270 mode */\n#endif /* defined(TN3270) */\n    }\n  if ((argc != 2) || (strcmp (argv[1], \"fromquit\") != 0))\n    {\n      longjmp (toplevel, 1);\n    }\n  return 1;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "quit": {
      "start_point": [
        1651,
        0
      ],
      "end_point": [
        1657,
        1
      ],
      "content": "int\nquit (void)\n{\n  call (bye, \"bye\", \"fromquit\", 0);\n  Exit (0);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "logout": {
      "start_point": [
        1659,
        0
      ],
      "end_point": [
        1665,
        1
      ],
      "content": "int\nlogout (void)\n{\n  send_do (TELOPT_LOGOUT, 1);\n  netflush ();\n  return 1;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "slc_help": {
      "start_point": [
        1694,
        0
      ],
      "end_point": [
        1709,
        1
      ],
      "content": "static void\nslc_help (void)\n{\n  struct slclist *c;\n\n  for (c = SlcList; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s %s\\n\", c->name, c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getslc": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1716,
        1
      ],
      "content": "static struct slclist *\ngetslc (char *name)\n{\n  return (struct slclist *)\n    genget (name, (char **) SlcList, sizeof (struct slclist));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct slclist",
        "struct",
        "slclist",
        "*\ngetslc (char *name)",
        "*"
      ]
    },
    "slccmd": {
      "start_point": [
        1718,
        0
      ],
      "end_point": [
        1745,
        1
      ],
      "content": "static int\nslccmd (int argc, char **argv)\n{\n  struct slclist *c;\n\n  if (argc != 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'slc' command.  'slc ?' for help.\\n\");\n      return 0;\n    }\n  c = getslc (argv[1]);\n  if (c == 0)\n    {\n      fprintf (stderr, \"'%s': unknown argument ('slc ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (Ambiguous (c))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('slc ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  (*c->handler) (c->arg);\n  slcstate ();\n  return 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "env_help": {
      "start_point": [
        1791,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "static void\nenv_help (void)\n{\n  struct envlist *c;\n\n  for (c = EnvList; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s %s\\n\", c->name, c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getenvcmd": {
      "start_point": [
        1808,
        0
      ],
      "end_point": [
        1813,
        1
      ],
      "content": "static struct envlist *\ngetenvcmd (char *name)\n{\n  return (struct envlist *)\n    genget (name, (char **) EnvList, sizeof (struct envlist));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct envlist",
        "struct",
        "envlist",
        "*\ngetenvcmd (char *name)",
        "*"
      ]
    },
    "env_cmd": {
      "start_point": [
        1815,
        0
      ],
      "end_point": [
        1849,
        1
      ],
      "content": "int\nenv_cmd (int argc, char *argv[])\n{\n  struct envlist *c;\n\n  if (argc < 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'environ' command.  'environ ?' for help.\\n\");\n      return 0;\n    }\n  c = getenvcmd (argv[1]);\n  if (c == 0)\n    {\n      fprintf (stderr, \"'%s': unknown argument ('environ ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (Ambiguous (c))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('environ ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (c->narg + 2 != argc)\n    {\n      fprintf (stderr,\n\t       \"Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\\n\",\n\t       c->narg < argc + 2 ? \"only \" : \"\",\n\t       c->narg, c->narg == 1 ? \"\" : \"s\", c->name);\n      return 0;\n    }\n  (*c->handler) (argv[2], argv[3]);\n  return 1;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "env_find": {
      "start_point": [
        1863,
        0
      ],
      "end_point": [
        1874,
        1
      ],
      "content": "struct env_lst *\nenv_find (const char *var)\n{\n  register struct env_lst *ep;\n\n  for (ep = envlisthead.next; ep; ep = ep->next)\n    {\n      if (strcmp ((char *) ep->var, var) == 0)\n\treturn (ep);\n    }\n  return (NULL);\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "struct env_lst",
        "struct",
        "env_lst",
        "*\nenv_find (const char *var)",
        "*"
      ]
    },
    "env_init": {
      "start_point": [
        1876,
        0
      ],
      "end_point": [
        1929,
        1
      ],
      "content": "void\nenv_init (void)\n{\n  extern char **environ;\n  register char **epp, *cp;\n  register struct env_lst *ep;\n#ifndef strchr\n  extern char *strchr (const char *, int);\n#endif\n\n  for (epp = environ; *epp; epp++)\n    {\n      cp = strchr (*epp, '=');\n      if (cp)\n\t{\n\t  *cp = '\\0';\n\t  ep = env_define (*epp, (unsigned char *) cp + 1);\n\t  ep->export = 0;\n\t  *cp = '=';\n\t}\n    }\n  /*\n   * Special case for DISPLAY variable.  If it is \":0.0\" or\n   * \"unix:0.0\", we have to get rid of \"unix\" and insert our\n   * hostname.\n   */\n  if ((ep = env_find (\"DISPLAY\"))\n      && ((*ep->value == ':')\n\t  || (strncmp ((char *) ep->value, \"unix:\", 5) == 0)))\n    {\n      char *hostname = localhost ();\n      char *cp2 = strchr ((char *) ep->value, ':');\n\n      cp = xmalloc (strlen (hostname) + strlen (cp2) + 1);\n      sprintf (cp, \"%s%s\", hostname, cp2);\n\n      free (ep->value);\n      ep->value = (unsigned char *) cp;\n\n      free (hostname);\n    }\n  /*\n   * If USER is not defined, but LOGNAME is, then add\n   * USER with the value from LOGNAME.  By default, we\n   * don't export the USER variable.\n   */\n  if ((env_find (\"USER\") == NULL) && (ep = env_find (\"LOGNAME\")))\n    {\n      env_define (\"USER\", ep->value);\n      env_unexport (\"USER\");\n    }\n  env_export (\"DISPLAY\");\n  env_export (\"PRINTER\");\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "env_define": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1954,
        1
      ],
      "content": "struct env_lst *\nenv_define (const char *var, unsigned char *value)\n{\n  register struct env_lst *ep = env_find (var);\n  if (ep)\n    {\n      free (ep->var);\n      free (ep->value);\n    }\n  else\n    {\n      ep = (struct env_lst *) xmalloc (sizeof (struct env_lst));\n      ep->next = envlisthead.next;\n      envlisthead.next = ep;\n      ep->prev = &envlisthead;\n      if (ep->next)\n\tep->next->prev = ep;\n    }\n  ep->welldefined = opt_welldefined ((char *)var);\n  ep->export = 1;\n  ep->var = (unsigned char *) strdup ((char *) var);\n  ep->value = (unsigned char *) strdup ((char *) value);\n  return (ep);\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "struct env_lst",
        "struct",
        "env_lst",
        "*\nenv_define (const char *var, unsigned char *value)",
        "*"
      ]
    },
    "env_undefine": {
      "start_point": [
        1956,
        0
      ],
      "end_point": [
        1969,
        1
      ],
      "content": "void\nenv_undefine (const char *var)\n{\n  register struct env_lst *ep = env_find (var);\n  if (ep)\n    {\n      ep->prev->next = ep->next;\n      if (ep->next)\n\tep->next->prev = ep->prev;\n      free (ep->var);\n      free (ep->value);\n      free (ep);\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "env_export": {
      "start_point": [
        1971,
        0
      ],
      "end_point": [
        1977,
        1
      ],
      "content": "void\nenv_export (const char *var)\n{\n  register struct env_lst *ep = env_find (var);\n  if (ep)\n    ep->export = 1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "env_unexport": {
      "start_point": [
        1979,
        0
      ],
      "end_point": [
        1985,
        1
      ],
      "content": "void\nenv_unexport (const char *var)\n{\n  register struct env_lst *ep = env_find (var);\n  if (ep)\n    ep->export = 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "env_send": {
      "start_point": [
        1987,
        0
      ],
      "end_point": [
        2011,
        1
      ],
      "content": "void\nenv_send (const char *var)\n{\n  register struct env_lst *ep;\n\n  if (my_state_is_wont (TELOPT_NEW_ENVIRON)\n#ifdef\tOLD_ENVIRON\n      && my_state_is_wont (TELOPT_OLD_ENVIRON)\n#endif\n    )\n    {\n      fprintf (stderr,\n\t       \"Cannot send '%s': Telnet ENVIRON option not enabled\\n\", var);\n      return;\n    }\n  ep = env_find (var);\n  if (ep == 0)\n    {\n      fprintf (stderr, \"Cannot send '%s': variable not defined\\n\", var);\n      return;\n    }\n  env_opt_start_info ();\n  env_opt_add (ep->var);\n  env_opt_end (0);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "env_list": {
      "start_point": [
        2013,
        0
      ],
      "end_point": [
        2022,
        1
      ],
      "content": "void\nenv_list (void)\n{\n  register struct env_lst *ep;\n\n  for (ep = envlisthead.next; ep; ep = ep->next)\n    {\n      printf (\"%c %-20s %s\\n\", ep->export ? '*' : ' ', ep->var, ep->value);\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "env_default": {
      "start_point": [
        2024,
        0
      ],
      "end_point": [
        2043,
        1
      ],
      "content": "unsigned char *\nenv_default (int init, int welldefined)\n{\n  static struct env_lst *nep = NULL;\n\n  if (init)\n    {\n      nep = &envlisthead;\n      return NULL;\n    }\n  if (nep)\n    {\n      while ((nep = nep->next))\n\t{\n\t  if (nep->export && (nep->welldefined == welldefined))\n\t    return (nep->var);\n\t}\n    }\n  return (NULL);\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char",
        "*\nenv_default (int init, int welldefined)",
        "*"
      ]
    },
    "env_getvalue": {
      "start_point": [
        2045,
        0
      ],
      "end_point": [
        2052,
        1
      ],
      "content": "unsigned char *\nenv_getvalue (const char *var)\n{\n  register struct env_lst *ep  = env_find (var);\n  if (ep)\n    return (ep->value);\n  return (NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char",
        "*\nenv_getvalue (const char *var)",
        "*"
      ]
    },
    "env_varval": {
      "start_point": [
        2055,
        0
      ],
      "end_point": [
        2098,
        1
      ],
      "content": "void\nenv_varval (const char *what)\n{\n  extern int old_env_var, old_env_value, env_auto;\n  int len = strlen (what);\n\n  if (len == 0)\n    goto unknown;\n\n  if (strncasecmp ((char *) what, \"status\", len) == 0)\n    {\n      if (env_auto)\n\tprintf (\"%s%s\", \"VAR and VALUE are/will be \",\n\t\t\"determined automatically\\n\");\n      if (old_env_var == OLD_ENV_VAR)\n\tprintf (\"VAR and VALUE set to correct definitions\\n\");\n      else\n\tprintf (\"VAR and VALUE definitions are reversed\\n\");\n    }\n  else if (strncasecmp ((char *) what, \"auto\", len) == 0)\n    {\n      env_auto = 1;\n      old_env_var = OLD_ENV_VALUE;\n      old_env_value = OLD_ENV_VAR;\n    }\n  else if (strncasecmp ((char *) what, \"right\", len) == 0)\n    {\n      env_auto = 0;\n      old_env_var = OLD_ENV_VAR;\n      old_env_value = OLD_ENV_VALUE;\n    }\n  else if (strncasecmp ((char *) what, \"wrong\", len) == 0)\n    {\n      env_auto = 0;\n      old_env_var = OLD_ENV_VALUE;\n      old_env_value = OLD_ENV_VAR;\n    }\n  else\n    {\n    unknown:\n      printf\n\t(\"Unknown \\\"varval\\\" command. (\\\"auto\\\", \\\"right\\\", \\\"wrong\\\", \\\"status\\\")\\n\");\n    }\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "auth_help": {
      "start_point": [
        2129,
        0
      ],
      "end_point": [
        2145,
        1
      ],
      "content": "static int\nauth_help ()\n{\n  struct authlist *c;\n\n  for (c = AuthList; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s %s\\n\", c->name, c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "auth_cmd": {
      "start_point": [
        2147,
        0
      ],
      "end_point": [
        2182,
        1
      ],
      "content": "int\nauth_cmd (int argc, char *argv[])\n{\n  struct authlist *c;\n\n  if (argc < 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'auth' command.  'auth ?' for help.\\n\");\n      return 0;\n    }\n\n  c = (struct authlist *)\n    genget (argv[1], (char **) AuthList, sizeof (struct authlist));\n  if (c == 0)\n    {\n      fprintf (stderr, \"'%s': unknown argument ('auth ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (Ambiguous (c))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('auth ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (c->narg + 2 != argc)\n    {\n      fprintf (stderr,\n\t       \"Need %s%d argument%s to 'auth %s' command.  'auth ?' for help.\\n\",\n\t       c->narg < argc + 2 ? \"only \" : \"\",\n\t       c->narg, c->narg == 1 ? \"\" : \"s\", c->name);\n      return 0;\n    }\n  return ((*c->handler) (argv[2], argv[3]));\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "EncryptHelp": {
      "start_point": [
        2238,
        0
      ],
      "end_point": [
        2254,
        1
      ],
      "content": "static int\nEncryptHelp ()\n{\n  struct encryptlist *c;\n\n  for (c = EncryptList; c->name; c++)\n    {\n      if (c->help)\n\t{\n\t  if (*c->help)\n\t    printf (\"%-15s %s\\n\", c->name, c->help);\n\t  else\n\t    printf (\"\\n\");\n\t}\n    }\n  return 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "encrypt_cmd": {
      "start_point": [
        2256,
        0
      ],
      "end_point": [
        2310,
        1
      ],
      "content": "int\nencrypt_cmd (int argc, char *argv[])\n{\n  struct encryptlist *c;\n\n  if (argc < 2)\n    {\n      fprintf (stderr,\n\t       \"Need an argument to 'encrypt' command.  'encrypt ?' for help.\\n\");\n      return 0;\n    }\n\n  c = (struct encryptlist *)\n    genget (argv[1], (char **) EncryptList, sizeof (struct encryptlist));\n  if (c == 0)\n    {\n      fprintf (stderr, \"'%s': unknown argument ('encrypt ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  if (Ambiguous (c))\n    {\n      fprintf (stderr, \"'%s': ambiguous argument ('encrypt ?' for help).\\n\",\n\t       argv[1]);\n      return 0;\n    }\n  argc -= 2;\n  if (argc < c->minarg || argc > c->maxarg)\n    {\n      if (c->minarg == c->maxarg)\n\t{\n\t  fprintf (stderr, \"Need %s%d argument%s \",\n\t\t   c->minarg < argc ? \"only \" : \"\", c->minarg,\n\t\t   c->minarg == 1 ? \"\" : \"s\");\n\t}\n      else\n\t{\n\t  fprintf (stderr, \"Need %s%d-%d arguments \",\n\t\t   c->maxarg < argc ? \"only \" : \"\", c->minarg, c->maxarg);\n\t}\n      fprintf (stderr, \"to 'encrypt %s' command.  'encrypt ?' for help.\\n\",\n\t       c->name);\n      return 0;\n    }\n  if (c->needconnect && !connected)\n    {\n      if (!(argc && (isprefix (argv[2], \"help\") || isprefix (argv[2], \"?\"))))\n\t{\n\t  printf (\"?Need to be connected first.\\n\");\n\t  return 0;\n\t}\n    }\n  return ((*c->handler) (argc > 0 ? argv[2] : 0,\n\t\t\t argc > 1 ? argv[3] : 0, argc > 2 ? argv[4] : 0));\n}",
      "lines": 55,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "filestuff": {
      "start_point": [
        2314,
        0
      ],
      "end_point": [
        2341,
        1
      ],
      "content": "static void\nfilestuff (int fd)\n{\n  int res;\n\n# ifdef\tF_GETOWN\n  setconnmode (0);\n  res = fcntl (fd, F_GETOWN, 0);\n  setcommandmode ();\n\n  if (res == -1)\n    {\n      perror (\"fcntl\");\n      return;\n    }\n  printf (\"\\tOwner is %d.\\n\", res);\n# endif\n\n  setconnmode (0);\n  res = fcntl (fd, F_GETFL, 0);\n  setcommandmode ();\n\n  if (res == -1)\n    {\n      perror (\"fcntl\");\n      return;\n    }\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "status": {
      "start_point": [
        2347,
        0
      ],
      "end_point": [
        3148,
        1
      ],
      "content": "static int\nstatus (int argc, char *argv[])\n{\n  if (connected)\n    {\n      printf (\"Connected to %s.\\n\", hostname);\n      if ((argc < 2) || strcmp (argv[1], \"notmuch\"))\n\t{\n\t  int mode = getconnmode ();\n\n\t  if (my_want_state_is_will (TELOPT_LINEMODE))\n\t    {\n\t      printf (\"Operating with LINEMODE option\\n\");\n\t      printf (\"%s line editing\\n\",\n\t\t      (mode & MODE_EDIT) ? \"Local\" : \"No\");\n\t      printf (\"%s catching of signals\\n\",\n\t\t      (mode & MODE_TRAPSIG) ? \"Local\" : \"No\");\n\t      slcstate ();\n#ifdef\tKLUDGELINEMODE\n\t    }\n\t  else if (kludgelinemode && my_want_state_is_dont (TELOPT_SGA))\n\t    {\n\t      printf (\"Operating in obsolete linemode\\n\");\n#endif\n\t    }\n\t  else\n\t    {\n\t      printf (\"Operating in single character mode\\n\");\n\t      if (localchars)\n\t\tprintf (\"Catching signals locally\\n\");\n\t    }\n\t  printf (\"%s character echo\\n\",\n\t\t  (mode & MODE_ECHO) ? \"Local\" : \"Remote\");\n\t  if (my_want_state_is_will (TELOPT_LFLOW))\n\t    printf (\"%s flow control\\n\", (mode & MODE_FLOW) ? \"Local\" : \"No\");\n#ifdef\tENCRYPTION\n\t  encrypt_display ();\n#endif /* ENCRYPTION */\n\t}\n    }\n  else\n    {\n      printf (\"No connection.\\n\");\n    }\n#if !defined TN3270\n  printf (\"Escape character is '%s'.\\n\", control (escape));\n  fflush (stdout);\n#else /* !defined(TN3270) */\n  if ((!In3270) && ((argc < 2) || strcmp (argv[1], \"notmuch\")))\n    {\n      printf (\"Escape character is '%s'.\\n\", control (escape));\n    }\n# if defined unix || defined __unix || defined __unix__\n  if ((argc >= 2) && !strcmp (argv[1], \"everything\"))\n    {\n      printf (\"SIGIO received %d time%s.\\n\",\n\t      sigiocount, (sigiocount == 1) ? \"\" : \"s\");\n      if (In3270)\n\t{\n\t  printf (\"Process ID %d, process group %d.\\n\",\n\t\t  getpid (), getpgrp (getpid ()));\n\t  printf (\"Terminal input:\\n\");\n\t  filestuff (tin);\n\t  printf (\"Terminal output:\\n\");\n\t  filestuff (tout);\n\t  printf (\"Network socket:\\n\");\n\t  filestuff (net);\n\t}\n    }\n  if (In3270 && transcom)\n    {\n      printf (\"Transparent mode command is '%s'.\\n\", transcom);\n    }\n# endif /* unix || __unix || __unix__ */\n  fflush (stdout);\n  if (In3270)\n    {\n      return 0;\n    }\n#endif /* defined(TN3270) */\n  return 1;\n}\n\n#ifdef\tSIGINFO\n/*\n * Function that gets called when SIGINFO is received.\n */\nint\nayt_status ()\n{\n  call (status, \"status\", \"notmuch\", 0);\n  return 1;\t/* not used */\n}\n#endif /* SIGINFO */\n\nstatic void cmdrc (char *m1, char *m2);\n\nint\ntn (int argc, char *argv[])\n{\n#ifdef IPV6\n  struct addrinfo *result, *aip, hints;\n#else\n  struct hostent *host = 0;\n  struct sockaddr_in sin;\n  struct servent *sp = 0;\n  in_addr_t temp;\n#endif\n  const int on = 1;\n  int err;\n  char *cmd, *hostp = 0, *portp = 0, *user = 0;\n#ifdef HAVE_IDN\n  char *hosttmp = 0;\n#endif\n\n#ifdef IPV6\n  memset (&hints, 0, sizeof (hints));\n#else\n  /* clear the socket address prior to use */\n  memset ((char *) &sin, 0, sizeof (sin));\n#endif\n\n  if (connected)\n    {\n      printf (\"?Already connected to %s\\n\", hostname);\n      return 0;\n    }\n  if (argc < 2)\n    {\n      strcpy (line, \"open \");\n      printf (\"(to) \");\n      if (fgets (&line[strlen (line)],\n\t\t sizeof (line) - strlen (line), stdin))\n\t{\n\t  makeargv ();\n\t  argc = margc;\n\t  argv = margv;\n\t}\n      else\n\tprintf (\"?Name of host was not understood.\\n\");\n    }\n  cmd = *argv;\n  --argc;\n  ++argv;\n  while (argc)\n    {\n      if (strcmp (*argv, \"help\") == 0 || isprefix (*argv, \"?\"))\n\tgoto usage;\n      if (strcmp (*argv, \"-l\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  if (argc == 0)\n\t    goto usage;\n\t  user = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-a\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  autologin = 1;\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-6\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n#ifdef IPV6\n\t  hints.ai_family = AF_INET6;\n#else\n\t  puts (\"IPv6 isn't supported\");\n#endif\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-4\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n#ifdef IPV6\n\t  hints.ai_family = AF_INET;\n#endif\n\t  continue;\n\t}\n      if (hostp == 0)\n\t{\n\t  hostp = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n      if (portp == 0)\n\t{\n\t  portp = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n    usage:\n      printf (\"usage: %s [-4] [-6] [-l user] [-a] host-name [port]\\n\", cmd);\n      return 0;\n    }\n  if (hostp == 0)\n    goto usage;\n\n  if (!portp)\n    {\n      portp = \"telnet\";\n      telnetport = 1;\n    }\n  else\n    {\n      if (*portp == '-')\n\t{\n\t  portp++;\n\t  telnetport = 1;\n\t}\n      else\n\ttelnetport = 0;\n      if (*portp >= '0' && *portp <= '9')\n\t{\n\t  long long int val;\n\t  char *endp;\n\n\t  val = strtoll (portp, &endp, 10);\n\n\t  if ((errno == ERANGE && (val == LLONG_MAX || val == LLONG_MIN))\n\t      || (*endp == '\\0' && (val < 1 || val > 65535)))\n\t    {\n\t      printf (\"Port number %s is out of range.\\n\", portp);\n\t      return 0;\n\t    }\n\t  else if (*endp)\n\t    {\n\t      printf (\"Invalid port name '%s'.\\n\", portp);\n\t      return 0;\n\t    }\n\t}\n    }\n\n  free (hostname);\n  hostname = malloc (strlen (hostp) + 1);\n  if (hostname)\n    strcpy (hostname, hostp);\n  else\n    {\n      printf (\"Can't allocate memory to copy hostname\\n\");\n      return 0;\n    }\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n  {\n    /* Extract instance name of server, eliminating\n     * the Kerberos principal prefix.\n     */\n    char *p = strchr (hostp, '/');\n\n    if (p)\n      hostp = ++p;\n  }\n#endif /* AUTHENTICATION || ENCRYPTION */\n\n#ifdef HAVE_IDN\n  err = idna_to_ascii_lz (hostp, &hosttmp, 0);\n  if (err)\n    {\n      printf (\"Server lookup failure:  %s:%s, %s\\n\",\n\t      hostp, portp, idna_strerror (err));\n      return 0;\n    }\n  hostp = hosttmp;\n#endif /* !HAVE_IDN */\n\n#ifdef IPV6\n  hints.ai_socktype = SOCK_STREAM;\n# ifdef AI_IDN\n  hints.ai_flags = AI_IDN;\n# endif\n\n  err = getaddrinfo (hostp, portp, &hints, &result);\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      printf (\"Server lookup failure:  %s:%s, %s\\n\", hostp, portp, errmsg);\n      return 0;\n    }\n\n  aip = result;\n\n  do\n    {\n      char buf[256];\n\n      err = getnameinfo (aip->ai_addr, aip->ai_addrlen, buf, sizeof (buf),\n\t\t\t NULL, 0, NI_NUMERICHOST);\n      if (err)\n\t{\n\t  /* I don't know how thing can happen, but we just handle it.  */\n\t  const char *errmsg;\n\n\t  if (err == EAI_SYSTEM)\n\t    errmsg = strerror (errno);\n\t  else\n\t    errmsg = gai_strerror (err);\n\n\t  printf (\"getnameinfo error: %s\\n\", errmsg);\n\t  return 0;\n\t}\n\n      printf (\"Trying %s...\\n\", buf);\n\n      net = socket (aip->ai_family, SOCK_STREAM, 0);\n      if (net < 0)\n\t{\n\t  perror (\"telnet: socket\");\n\t  return 0;\n\t}\n\n      if (debug)\n\t{\n\t  err = setsockopt (net, SOL_SOCKET, SO_DEBUG, &on, sizeof (on));\n\t  if (err < 0)\n\t    perror (\"setsockopt (SO_DEBUG)\");\n\t}\n\n      err = connect (net, (struct sockaddr *) aip->ai_addr, aip->ai_addrlen);\n      if (err < 0)\n\t{\n\t  if (aip->ai_next)\n\t    {\n\t      perror (\"Connection failed\");\n\t      aip = aip->ai_next;\n\t      close (net);\n\t      continue;\n\t    }\n\n\t  perror (\"telnet: Unable to connect to remote host\");\n\t  return 0;\n\t}\n\n      connected++;\n# if defined AUTHENTICATION || defined ENCRYPTION\n      auth_encrypt_connect (connected);\n# endif\t/* defined(AUTHENTICATION) || defined(ENCRYPTION) */\n    }\n  while (!connected);\n\n  freeaddrinfo (result);\n#else /* !IPV6 */\n  temp = inet_addr (hostp);\n  if (temp != (in_addr_t) - 1)\n    {\n      sin.sin_addr.s_addr = temp;\n      sin.sin_family = AF_INET;\n    }\n  else\n    {\n      host = gethostbyname (hostp);\n      if (host)\n\t{\n\t  sin.sin_family = host->h_addrtype;\n\t  memmove (&sin.sin_addr, host->h_addr_list[0], host->h_length);\n\t}\n      else\n\t{\n\t  printf (\"Can't lookup hostname %s\\n\", hostp);\n\t  return 0;\n\t}\n    }\n\n  sin.sin_port = atoi (portp);\n  if (sin.sin_port == 0)\n    {\n      sp = getservbyname (portp, \"tcp\");\n      if (sp == 0)\n\t{\n\t  printf (\"tcp/%s: unknown service\\n\", portp);\n\t  return 0;\n\t}\n      sin.sin_port = sp->s_port;\n    }\n  else\n    sin.sin_port = htons (sin.sin_port);\n\n  printf (\"Trying %s...\\n\", inet_ntoa (sin.sin_addr));\n  do\n    {\n      net = socket (AF_INET, SOCK_STREAM, 0);\n      if (net < 0)\n\t{\n\t  perror (\"telnet: socket\");\n\t  return 0;\n\t}\n# if defined IPPROTO_IP && defined IP_TOS\n      {\n#  ifdef IPTOS_LOWDELAY\n\tconst int tos = IPTOS_LOWDELAY;\n#  else\n\tconst int tos = 0x10;\n#  endif\n\n\terr = setsockopt (net, IPPROTO_IP, IP_TOS,\n\t\t\t  (char *) &tos, sizeof (tos));\n\tif (err < 0 && errno != ENOPROTOOPT)\n\t  perror (\"telnet: setsockopt (IP_TOS) (ignored)\");\n      }\n# endif\t/* defined(IPPROTO_IP) && defined(IP_TOS) */\n\n      if (debug\n\t  && setsockopt (net, SOL_SOCKET, SO_DEBUG, &on, sizeof (on)) < 0)\n\tperror (\"setsockopt (SO_DEBUG)\");\n\n      if (connect (net, (struct sockaddr *) &sin, sizeof (sin)) < 0)\n\t{\n\t  if (host && host->h_addr_list[1])\n\t    {\n\t      int oerrno = errno;\n\n\t      fprintf (stderr, \"telnet: connect to address %s: \",\n\t\t       inet_ntoa (sin.sin_addr));\n\t      errno = oerrno;\n\t      perror ((char *) 0);\n\t      host->h_addr_list++;\n\t      memmove ((caddr_t) & sin.sin_addr,\n\t\t       host->h_addr_list[0], host->h_length);\n\t      close (net);\n\t      continue;\n\t    }\n\t  perror (\"telnet: Unable to connect to remote host\");\n\t  return 0;\n\t}\n      connected++;\n# if defined AUTHENTICATION || defined ENCRYPTION\n      auth_encrypt_connect (connected);\n# endif\t/* defined(AUTHENTICATION) || defined(ENCRYPTION) */\n    }\n  while (connected == 0);\n#endif /* !IPV6 */\n\n  cmdrc (hostp, hostname);\n#ifdef HAVE_IDN\n  /* Last use of HOSTP, alias HOSTTMP.  */\n  free (hosttmp);\n#endif\n\n  if (autologin && user == NULL)\n    {\n      struct passwd *pw;\n\n      user = getenv (\"USER\");\n      if (user == NULL || ((pw = getpwnam (user)) && pw->pw_uid != getuid ()))\n\t{\n\t  if ((pw = getpwuid (getuid ())))\n\t    user = pw->pw_name;\n\t  else\n\t    user = NULL;\n\t}\n    }\n  if (user)\n    {\n      env_define (\"USER\", (unsigned char *) user);\n      env_export (\"USER\");\n    }\n  call (status, \"status\", \"notmuch\", 0);\n  err = 0;\n  if (setjmp (peerdied) == 0)\n    telnet (user);\n  else\n    err = 1;\n\n  close (net);\n  ExitString (\"Connection closed by foreign host.\\n\", err);\n  /* NOT REACHED */\n  return 0;\n}\n\n#define HELPINDENT (sizeof (\"connect\"))\n\nstatic char\n  openhelp[] = \"connect to a site\",\n  closehelp[] = \"close current connection\",\n  logouthelp[] = \"forcibly logout remote user and close the connection\",\n  quithelp[] = \"exit telnet\",\n  statushelp[] = \"print status information\",\n  helphelp[] = \"print help information\",\n  sendhelp[] = \"transmit special characters ('send ?' for more)\",\n  sethelp[] = \"set operating parameters ('set ?' for more)\",\n  unsethelp[] = \"unset operating parameters ('unset ?' for more)\",\n  togglestring[] = \"toggle operating parameters ('toggle ?' for more)\",\n  slchelp[] = \"change state of special characters ('slc ?' for more)\",\n  displayhelp[] = \"display operating parameters\",\n#if defined TN3270 && (defined unix || defined __unix || defined __unix__)\n  transcomhelp[] = \"specify Unix command for transparent mode pipe\",\n#endif /* TN3270 && (unix || __unix || __unix__) */\n#if defined AUTHENTICATION\n  authhelp[] = \"turn on (off) authentication ('auth ?' for more)\",\n#endif\n#ifdef\tENCRYPTION\n  encrypthelp[] = \"turn on (off) encryption ('encrypt ?' for more)\",\n#endif\n  /* ENCRYPTION */\n#if defined unix || defined __unix || defined __unix__\n  zhelp[] = \"suspend telnet\",\n#endif /* unix || __unix || __unix__ */\n  shellhelp[] = \"invoke a subshell\",\n  envhelp[] = \"change environment variables ('environ ?' for more)\",\n  modestring[] = \"try to enter line or character mode ('mode ?' for more)\";\n\nstatic int help (int argc, char **argv);\n\nstatic Command cmdtab[] = {\n  {\"close\", closehelp, bye, 1},\n  {\"logout\", logouthelp, logout, 1},\n  {\"display\", displayhelp, display, 0},\n  {\"mode\", modestring, modecmd, 0},\n  {\"open\", openhelp, tn, 0},\n  {\"quit\", quithelp, quit, 0},\n  {\"send\", sendhelp, sendcmd, 0},\n  {\"set\", sethelp, setcmd, 0},\n  {\"unset\", unsethelp, unsetcmd, 0},\n  {\"status\", statushelp, status, 0},\n  {\"toggle\", togglestring, toggle, 0},\n  {\"slc\", slchelp, slccmd, 0},\n#if defined TN3270 && (defined unix || defined __unix || defined __unix__)\n  {\"transcom\", transcomhelp, settranscom, 0},\n#endif /* TN3270 && (unix || __unix || __unix__) */\n#if defined AUTHENTICATION\n  {\"auth\", authhelp, auth_cmd, 0},\n#endif\n#ifdef\tENCRYPTION\n  {\"encrypt\", encrypthelp, encrypt_cmd, 0},\n#endif /* ENCRYPTION */\n#if defined unix || defined __unix || defined __unix__\n  {\"z\", zhelp, suspend, 0},\n#endif /* unix || __unix || __unix__ */\n#if defined TN3270\n  {\"!\", shellhelp, shell, 1},\n#else\n  {\"!\", shellhelp, shell, 0},\n#endif\n  {\"environ\", envhelp, env_cmd, 0},\n  {\"?\", helphelp, help, 0},\n  {NULL, NULL, NULL, 0}\n};\n\nstatic char crmodhelp[] = \"deprecated command -- use 'toggle crmod' instead\";\nstatic char escapehelp[] = \"deprecated command -- use 'set escape' instead\";\n\nstatic Command cmdtab2[] = {\n  {\"help\", 0, help, 0},\n  {\"escape\", escapehelp, setescape, 0},\n  {\"crmod\", crmodhelp, togcrmod, 0},\n  {NULL, NULL, NULL, 0}\n};\n\n\n/*\n * Call routine with argc, argv set from args (terminated by 0).\n */\n\nstatic int\ncall (intrtn_t routine, ...)\n{\n  va_list ap;\n  char *args[100];\n  int argno = 0;\n\n  va_start (ap, routine);\n  while ((args[argno++] = va_arg (ap, char *)) != 0)\n    {\n      ;\n    }\n  va_end (ap);\n  return (*routine) (argno - 1, args);\n}\n\n\nstatic Command *\ngetcmd (char *name)\n{\n  Command *cm;\n\n  if ((cm = (Command *) genget (name, (char **) cmdtab, sizeof (Command))))\n    return cm;\n  return (Command *) genget (name, (char **) cmdtab2, sizeof (Command));\n}\n\nvoid\ncommand (int top, char *tbuf, int cnt)\n{\n  register Command *c;\n\n  setcommandmode ();\n  if (!top)\n    {\n      putchar ('\\n');\n    }\n#if defined unix || defined __unix || defined __unix__\n  else\n    {\n      signal (SIGINT, SIG_DFL);\n      signal (SIGQUIT, SIG_DFL);\n    }\n#endif /* unix || __unix || __unix__ */\n  for (;;)\n    {\n      if (rlogin == _POSIX_VDISABLE)\n\tprintf (\"%s> \", prompt);\n      if (tbuf)\n\t{\n\t  register char *cp;\n\t  cp = line;\n\t  while (cnt > 0 && (*cp++ = *tbuf++) != '\\n')\n\t    cnt--;\n\t  tbuf = 0;\n\t  if (cp == line || *--cp != '\\n' || cp == line)\n\t    goto getline;\n\t  *cp = '\\0';\n\t  if (rlogin == _POSIX_VDISABLE)\n\t    printf (\"%s\\n\", line);\n\t}\n      else\n\t{\n\tgetline:\n\t  if (rlogin != _POSIX_VDISABLE)\n\t    printf (\"%s> \", prompt);\n\t  if (fgets (line, sizeof (line), stdin) == NULL)\n\t    {\n\t      if (feof (stdin) || ferror (stdin))\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  quit ();\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (line[0] == 0)\n\tbreak;\n      makeargv ();\n      if (margv[0] == 0)\n\t{\n\t  break;\n\t}\n      c = getcmd (margv[0]);\n      if (Ambiguous (c))\n\t{\n\t  printf (\"?Ambiguous command\\n\");\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command\\n\");\n\t  continue;\n\t}\n      if (c->needconnect && !connected)\n\t{\n\t  printf (\"?Need to be connected first.\\n\");\n\t  continue;\n\t}\n      if ((*c->handler) (margc, margv))\n\t{\n\t  break;\n\t}\n    }\n  if (!top)\n    {\n      if (!connected)\n\t{\n\t  longjmp (toplevel, 1);\n\t}\n#if defined TN3270\n      if (shell_active == 0)\n\t{\n\t  setconnmode (0);\n\t}\n#else /* defined(TN3270) */\n      setconnmode (0);\n#endif /* defined(TN3270) */\n    }\n}\n\f\n/*\n * Help command.\n */\nstatic int\nhelp (int argc, char *argv[])\n{\n  register Command *c;\n\n  if (argc == 1)\n    {\n      printf (\"Commands may be abbreviated.  Commands are:\\n\\n\");\n      for (c = cmdtab; c->name; c++)\n\tif (c->help)\n\t  {\n\t    printf (\"%-*s\\t%s\\n\", (int) HELPINDENT, c->name, c->help);\n\t  }\n      return 0;\n    }\n  while (--argc > 0)\n    {\n      register char *arg;\n      arg = *++argv;\n      c = getcmd (arg);\n      if (Ambiguous (c))\n\tprintf (\"?Ambiguous help command %s\\n\", arg);\n      else if (c == (Command *) 0)\n\tprintf (\"?Invalid help command %s\\n\", arg);\n      else\n\tprintf (\"%s\\n\", c->help);\n    }\n  return 0;\n}\n\nstatic char *rcname = 0;\n\nstatic void\ncmdrc (char *m1, char *m2)\n{\n  register Command *c;\n  FILE *rcfile;\n  int gotmachine = 0;\n  int l1 = strlen (m1);\n  int l2 = strlen (m2);\n\n  if (skiprc)\n    return;\n\n  if (rcname == 0)\n    {\n      const char *home = getenv (\"HOME\");\n      if (home)\n        rcname = xasprintf (\"%s/.telnetrc\", home);\n      else\n        rcname = xstrdup (\"/.telnetrc\");\n    }\n\n  if ((rcfile = fopen (rcname, \"r\")) == 0)\n    {\n      return;\n    }\n\n  for (;;)\n    {\n      if (fgets (line, sizeof (line), rcfile) == NULL)\n\tbreak;\n      if (line[0] == 0)\n\tbreak;\n      if (line[0] == '#')\n\tcontinue;\n      if (gotmachine)\n\t{\n\t  if (!isspace (line[0]))\n\t    gotmachine = 0;\n\t}\n      if (gotmachine == 0)\n\t{\n\t  if (isspace (line[0]))\n\t    continue;\n\t  if (strncasecmp (line, m1, l1) == 0)\n\t    strncpy (line, &line[l1], sizeof (line) - l1);\n\t  else if (strncasecmp (line, m2, l2) == 0)\n\t    strncpy (line, &line[l2], sizeof (line) - l2);\n\t  else if (strncasecmp (line, \"DEFAULT\", 7) == 0)\n\t    strncpy (line, &line[7], sizeof (line) - 7);\n\t  else\n\t    continue;\n\t  if (line[0] != ' ' && line[0] != '\\t' && line[0] != '\\n')\n\t    continue;\n\t  gotmachine = 1;\n\t}\n      makeargv ();\n      if (margv[0] == 0)\n\tcontinue;\n      c = getcmd (margv[0]);\n      if (Ambiguous (c))\n\t{\n\t  printf (\"?Ambiguous command: %s\\n\", margv[0]);\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command: %s\\n\", margv[0]);\n\t  continue;\n\t}\n      /*\n       * This should never happen...\n       */\n      if (c->needconnect && !connected)\n\t{\n\t  printf (\"?Need to be connected first for %s.\\n\", margv[0]);\n\t  continue;\n\t}\n      (*c->handler) (margc, margv);\n    }\n  fclose (rcfile);\n}",
      "lines": 802,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ayt_status": {
      "start_point": [
        2434,
        0
      ],
      "end_point": [
        2439,
        1
      ],
      "content": "int\nayt_status ()\n{\n  call (status, \"status\", \"notmuch\", 0);\n  return 1;\t/* not used */\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "tn": {
      "start_point": [
        2444,
        0
      ],
      "end_point": [
        2826,
        1
      ],
      "content": "int\ntn (int argc, char *argv[])\n{\n#ifdef IPV6\n  struct addrinfo *result, *aip, hints;\n#else\n  struct hostent *host = 0;\n  struct sockaddr_in sin;\n  struct servent *sp = 0;\n  in_addr_t temp;\n#endif\n  const int on = 1;\n  int err;\n  char *cmd, *hostp = 0, *portp = 0, *user = 0;\n#ifdef HAVE_IDN\n  char *hosttmp = 0;\n#endif\n\n#ifdef IPV6\n  memset (&hints, 0, sizeof (hints));\n#else\n  /* clear the socket address prior to use */\n  memset ((char *) &sin, 0, sizeof (sin));\n#endif\n\n  if (connected)\n    {\n      printf (\"?Already connected to %s\\n\", hostname);\n      return 0;\n    }\n  if (argc < 2)\n    {\n      strcpy (line, \"open \");\n      printf (\"(to) \");\n      if (fgets (&line[strlen (line)],\n\t\t sizeof (line) - strlen (line), stdin))\n\t{\n\t  makeargv ();\n\t  argc = margc;\n\t  argv = margv;\n\t}\n      else\n\tprintf (\"?Name of host was not understood.\\n\");\n    }\n  cmd = *argv;\n  --argc;\n  ++argv;\n  while (argc)\n    {\n      if (strcmp (*argv, \"help\") == 0 || isprefix (*argv, \"?\"))\n\tgoto usage;\n      if (strcmp (*argv, \"-l\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  if (argc == 0)\n\t    goto usage;\n\t  user = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-a\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n\t  autologin = 1;\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-6\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n#ifdef IPV6\n\t  hints.ai_family = AF_INET6;\n#else\n\t  puts (\"IPv6 isn't supported\");\n#endif\n\t  continue;\n\t}\n      if (strcmp (*argv, \"-4\") == 0)\n\t{\n\t  --argc;\n\t  ++argv;\n#ifdef IPV6\n\t  hints.ai_family = AF_INET;\n#endif\n\t  continue;\n\t}\n      if (hostp == 0)\n\t{\n\t  hostp = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n      if (portp == 0)\n\t{\n\t  portp = *argv++;\n\t  --argc;\n\t  continue;\n\t}\n    usage:\n      printf (\"usage: %s [-4] [-6] [-l user] [-a] host-name [port]\\n\", cmd);\n      return 0;\n    }\n  if (hostp == 0)\n    goto usage;\n\n  if (!portp)\n    {\n      portp = \"telnet\";\n      telnetport = 1;\n    }\n  else\n    {\n      if (*portp == '-')\n\t{\n\t  portp++;\n\t  telnetport = 1;\n\t}\n      else\n\ttelnetport = 0;\n      if (*portp >= '0' && *portp <= '9')\n\t{\n\t  long long int val;\n\t  char *endp;\n\n\t  val = strtoll (portp, &endp, 10);\n\n\t  if ((errno == ERANGE && (val == LLONG_MAX || val == LLONG_MIN))\n\t      || (*endp == '\\0' && (val < 1 || val > 65535)))\n\t    {\n\t      printf (\"Port number %s is out of range.\\n\", portp);\n\t      return 0;\n\t    }\n\t  else if (*endp)\n\t    {\n\t      printf (\"Invalid port name '%s'.\\n\", portp);\n\t      return 0;\n\t    }\n\t}\n    }\n\n  free (hostname);\n  hostname = malloc (strlen (hostp) + 1);\n  if (hostname)\n    strcpy (hostname, hostp);\n  else\n    {\n      printf (\"Can't allocate memory to copy hostname\\n\");\n      return 0;\n    }\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n  {\n    /* Extract instance name of server, eliminating\n     * the Kerberos principal prefix.\n     */\n    char *p = strchr (hostp, '/');\n\n    if (p)\n      hostp = ++p;\n  }\n#endif /* AUTHENTICATION || ENCRYPTION */\n\n#ifdef HAVE_IDN\n  err = idna_to_ascii_lz (hostp, &hosttmp, 0);\n  if (err)\n    {\n      printf (\"Server lookup failure:  %s:%s, %s\\n\",\n\t      hostp, portp, idna_strerror (err));\n      return 0;\n    }\n  hostp = hosttmp;\n#endif /* !HAVE_IDN */\n\n#ifdef IPV6\n  hints.ai_socktype = SOCK_STREAM;\n# ifdef AI_IDN\n  hints.ai_flags = AI_IDN;\n# endif\n\n  err = getaddrinfo (hostp, portp, &hints, &result);\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      printf (\"Server lookup failure:  %s:%s, %s\\n\", hostp, portp, errmsg);\n      return 0;\n    }\n\n  aip = result;\n\n  do\n    {\n      char buf[256];\n\n      err = getnameinfo (aip->ai_addr, aip->ai_addrlen, buf, sizeof (buf),\n\t\t\t NULL, 0, NI_NUMERICHOST);\n      if (err)\n\t{\n\t  /* I don't know how thing can happen, but we just handle it.  */\n\t  const char *errmsg;\n\n\t  if (err == EAI_SYSTEM)\n\t    errmsg = strerror (errno);\n\t  else\n\t    errmsg = gai_strerror (err);\n\n\t  printf (\"getnameinfo error: %s\\n\", errmsg);\n\t  return 0;\n\t}\n\n      printf (\"Trying %s...\\n\", buf);\n\n      net = socket (aip->ai_family, SOCK_STREAM, 0);\n      if (net < 0)\n\t{\n\t  perror (\"telnet: socket\");\n\t  return 0;\n\t}\n\n      if (debug)\n\t{\n\t  err = setsockopt (net, SOL_SOCKET, SO_DEBUG, &on, sizeof (on));\n\t  if (err < 0)\n\t    perror (\"setsockopt (SO_DEBUG)\");\n\t}\n\n      err = connect (net, (struct sockaddr *) aip->ai_addr, aip->ai_addrlen);\n      if (err < 0)\n\t{\n\t  if (aip->ai_next)\n\t    {\n\t      perror (\"Connection failed\");\n\t      aip = aip->ai_next;\n\t      close (net);\n\t      continue;\n\t    }\n\n\t  perror (\"telnet: Unable to connect to remote host\");\n\t  return 0;\n\t}\n\n      connected++;\n# if defined AUTHENTICATION || defined ENCRYPTION\n      auth_encrypt_connect (connected);\n# endif\t/* defined(AUTHENTICATION) || defined(ENCRYPTION) */\n    }\n  while (!connected);\n\n  freeaddrinfo (result);\n#else /* !IPV6 */\n  temp = inet_addr (hostp);\n  if (temp != (in_addr_t) - 1)\n    {\n      sin.sin_addr.s_addr = temp;\n      sin.sin_family = AF_INET;\n    }\n  else\n    {\n      host = gethostbyname (hostp);\n      if (host)\n\t{\n\t  sin.sin_family = host->h_addrtype;\n\t  memmove (&sin.sin_addr, host->h_addr_list[0], host->h_length);\n\t}\n      else\n\t{\n\t  printf (\"Can't lookup hostname %s\\n\", hostp);\n\t  return 0;\n\t}\n    }\n\n  sin.sin_port = atoi (portp);\n  if (sin.sin_port == 0)\n    {\n      sp = getservbyname (portp, \"tcp\");\n      if (sp == 0)\n\t{\n\t  printf (\"tcp/%s: unknown service\\n\", portp);\n\t  return 0;\n\t}\n      sin.sin_port = sp->s_port;\n    }\n  else\n    sin.sin_port = htons (sin.sin_port);\n\n  printf (\"Trying %s...\\n\", inet_ntoa (sin.sin_addr));\n  do\n    {\n      net = socket (AF_INET, SOCK_STREAM, 0);\n      if (net < 0)\n\t{\n\t  perror (\"telnet: socket\");\n\t  return 0;\n\t}\n# if defined IPPROTO_IP && defined IP_TOS\n      {\n#  ifdef IPTOS_LOWDELAY\n\tconst int tos = IPTOS_LOWDELAY;\n#  else\n\tconst int tos = 0x10;\n#  endif\n\n\terr = setsockopt (net, IPPROTO_IP, IP_TOS,\n\t\t\t  (char *) &tos, sizeof (tos));\n\tif (err < 0 && errno != ENOPROTOOPT)\n\t  perror (\"telnet: setsockopt (IP_TOS) (ignored)\");\n      }\n# endif\t/* defined(IPPROTO_IP) && defined(IP_TOS) */\n\n      if (debug\n\t  && setsockopt (net, SOL_SOCKET, SO_DEBUG, &on, sizeof (on)) < 0)\n\tperror (\"setsockopt (SO_DEBUG)\");\n\n      if (connect (net, (struct sockaddr *) &sin, sizeof (sin)) < 0)\n\t{\n\t  if (host && host->h_addr_list[1])\n\t    {\n\t      int oerrno = errno;\n\n\t      fprintf (stderr, \"telnet: connect to address %s: \",\n\t\t       inet_ntoa (sin.sin_addr));\n\t      errno = oerrno;\n\t      perror ((char *) 0);\n\t      host->h_addr_list++;\n\t      memmove ((caddr_t) & sin.sin_addr,\n\t\t       host->h_addr_list[0], host->h_length);\n\t      close (net);\n\t      continue;\n\t    }\n\t  perror (\"telnet: Unable to connect to remote host\");\n\t  return 0;\n\t}\n      connected++;\n# if defined AUTHENTICATION || defined ENCRYPTION\n      auth_encrypt_connect (connected);\n# endif\t/* defined(AUTHENTICATION) || defined(ENCRYPTION) */\n    }\n  while (connected == 0);\n#endif /* !IPV6 */\n\n  cmdrc (hostp, hostname);\n#ifdef HAVE_IDN\n  /* Last use of HOSTP, alias HOSTTMP.  */\n  free (hosttmp);\n#endif\n\n  if (autologin && user == NULL)\n    {\n      struct passwd *pw;\n\n      user = getenv (\"USER\");\n      if (user == NULL || ((pw = getpwnam (user)) && pw->pw_uid != getuid ()))\n\t{\n\t  if ((pw = getpwuid (getuid ())))\n\t    user = pw->pw_name;\n\t  else\n\t    user = NULL;\n\t}\n    }\n  if (user)\n    {\n      env_define (\"USER\", (unsigned char *) user);\n      env_export (\"USER\");\n    }\n  call (status, \"status\", \"notmuch\", 0);\n  err = 0;\n  if (setjmp (peerdied) == 0)\n    telnet (user);\n  else\n    err = 1;\n\n  close (net);\n  ExitString (\"Connection closed by foreign host.\\n\", err);\n  /* NOT REACHED */\n  return 0;\n}",
      "lines": 383,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "call": {
      "start_point": [
        2912,
        0
      ],
      "end_point": [
        2926,
        1
      ],
      "content": "static int\ncall (intrtn_t routine, ...)\n{\n  va_list ap;\n  char *args[100];\n  int argno = 0;\n\n  va_start (ap, routine);\n  while ((args[argno++] = va_arg (ap, char *)) != 0)\n    {\n      ;\n    }\n  va_end (ap);\n  return (*routine) (argno - 1, args);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getcmd": {
      "start_point": [
        2929,
        0
      ],
      "end_point": [
        2937,
        1
      ],
      "content": "static Command *\ngetcmd (char *name)\n{\n  Command *cm;\n\n  if ((cm = (Command *) genget (name, (char **) cmdtab, sizeof (Command))))\n    return cm;\n  return (Command *) genget (name, (char **) cmdtab2, sizeof (Command));\n}",
      "lines": 9,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "Command",
        "*\ngetcmd (char *name)",
        "*"
      ]
    },
    "command": {
      "start_point": [
        2939,
        0
      ],
      "end_point": [
        3031,
        1
      ],
      "content": "void\ncommand (int top, char *tbuf, int cnt)\n{\n  register Command *c;\n\n  setcommandmode ();\n  if (!top)\n    {\n      putchar ('\\n');\n    }\n#if defined unix || defined __unix || defined __unix__\n  else\n    {\n      signal (SIGINT, SIG_DFL);\n      signal (SIGQUIT, SIG_DFL);\n    }\n#endif /* unix || __unix || __unix__ */\n  for (;;)\n    {\n      if (rlogin == _POSIX_VDISABLE)\n\tprintf (\"%s> \", prompt);\n      if (tbuf)\n\t{\n\t  register char *cp;\n\t  cp = line;\n\t  while (cnt > 0 && (*cp++ = *tbuf++) != '\\n')\n\t    cnt--;\n\t  tbuf = 0;\n\t  if (cp == line || *--cp != '\\n' || cp == line)\n\t    goto getline;\n\t  *cp = '\\0';\n\t  if (rlogin == _POSIX_VDISABLE)\n\t    printf (\"%s\\n\", line);\n\t}\n      else\n\t{\n\tgetline:\n\t  if (rlogin != _POSIX_VDISABLE)\n\t    printf (\"%s> \", prompt);\n\t  if (fgets (line, sizeof (line), stdin) == NULL)\n\t    {\n\t      if (feof (stdin) || ferror (stdin))\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  quit ();\n\t\t}\n\t      break;\n\t    }\n\t}\n      if (line[0] == 0)\n\tbreak;\n      makeargv ();\n      if (margv[0] == 0)\n\t{\n\t  break;\n\t}\n      c = getcmd (margv[0]);\n      if (Ambiguous (c))\n\t{\n\t  printf (\"?Ambiguous command\\n\");\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command\\n\");\n\t  continue;\n\t}\n      if (c->needconnect && !connected)\n\t{\n\t  printf (\"?Need to be connected first.\\n\");\n\t  continue;\n\t}\n      if ((*c->handler) (margc, margv))\n\t{\n\t  break;\n\t}\n    }\n  if (!top)\n    {\n      if (!connected)\n\t{\n\t  longjmp (toplevel, 1);\n\t}\n#if defined TN3270\n      if (shell_active == 0)\n\t{\n\t  setconnmode (0);\n\t}\n#else /* defined(TN3270) */\n      setconnmode (0);\n#endif /* defined(TN3270) */\n    }\n}",
      "lines": 93,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "help": {
      "start_point": [
        3036,
        0
      ],
      "end_point": [
        3064,
        1
      ],
      "content": "static int\nhelp (int argc, char *argv[])\n{\n  register Command *c;\n\n  if (argc == 1)\n    {\n      printf (\"Commands may be abbreviated.  Commands are:\\n\\n\");\n      for (c = cmdtab; c->name; c++)\n\tif (c->help)\n\t  {\n\t    printf (\"%-*s\\t%s\\n\", (int) HELPINDENT, c->name, c->help);\n\t  }\n      return 0;\n    }\n  while (--argc > 0)\n    {\n      register char *arg;\n      arg = *++argv;\n      c = getcmd (arg);\n      if (Ambiguous (c))\n\tprintf (\"?Ambiguous help command %s\\n\", arg);\n      else if (c == (Command *) 0)\n\tprintf (\"?Invalid help command %s\\n\", arg);\n      else\n\tprintf (\"%s\\n\", c->help);\n    }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmdrc": {
      "start_point": [
        3068,
        0
      ],
      "end_point": [
        3148,
        1
      ],
      "content": "static void\ncmdrc (char *m1, char *m2)\n{\n  register Command *c;\n  FILE *rcfile;\n  int gotmachine = 0;\n  int l1 = strlen (m1);\n  int l2 = strlen (m2);\n\n  if (skiprc)\n    return;\n\n  if (rcname == 0)\n    {\n      const char *home = getenv (\"HOME\");\n      if (home)\n        rcname = xasprintf (\"%s/.telnetrc\", home);\n      else\n        rcname = xstrdup (\"/.telnetrc\");\n    }\n\n  if ((rcfile = fopen (rcname, \"r\")) == 0)\n    {\n      return;\n    }\n\n  for (;;)\n    {\n      if (fgets (line, sizeof (line), rcfile) == NULL)\n\tbreak;\n      if (line[0] == 0)\n\tbreak;\n      if (line[0] == '#')\n\tcontinue;\n      if (gotmachine)\n\t{\n\t  if (!isspace (line[0]))\n\t    gotmachine = 0;\n\t}\n      if (gotmachine == 0)\n\t{\n\t  if (isspace (line[0]))\n\t    continue;\n\t  if (strncasecmp (line, m1, l1) == 0)\n\t    strncpy (line, &line[l1], sizeof (line) - l1);\n\t  else if (strncasecmp (line, m2, l2) == 0)\n\t    strncpy (line, &line[l2], sizeof (line) - l2);\n\t  else if (strncasecmp (line, \"DEFAULT\", 7) == 0)\n\t    strncpy (line, &line[7], sizeof (line) - 7);\n\t  else\n\t    continue;\n\t  if (line[0] != ' ' && line[0] != '\\t' && line[0] != '\\n')\n\t    continue;\n\t  gotmachine = 1;\n\t}\n      makeargv ();\n      if (margv[0] == 0)\n\tcontinue;\n      c = getcmd (margv[0]);\n      if (Ambiguous (c))\n\t{\n\t  printf (\"?Ambiguous command: %s\\n\", margv[0]);\n\t  continue;\n\t}\n      if (c == 0)\n\t{\n\t  printf (\"?Invalid command: %s\\n\", margv[0]);\n\t  continue;\n\t}\n      /*\n       * This should never happen...\n       */\n      if (c->needconnect && !connected)\n\t{\n\t  printf (\"?Need to be connected first for %s.\\n\", margv[0]);\n\t  continue;\n\t}\n      (*c->handler) (margc, margv);\n    }\n  fclose (rcfile);\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/defines.h": {},
  "inetutils/inetutils-1.9.4/telnet/externs.h": {},
  "inetutils/inetutils-1.9.4/telnet/general.h": {},
  "inetutils/inetutils-1.9.4/telnet/main.c": {
    "tninit": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\ntninit (void)\n{\n  init_terminal ();\n\n  init_network ();\n\n  init_telnet ();\n\n  init_sys ();\n\n#if defined TN3270\n  init_3270 ();\n#endif\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "parse_opt": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n    case '4':\n      family = 4;\n      break;\n\n    case '6':\n      family = 6;\n      break;\n\n    case '8':\n      eight = 3;\t\t/* binary output and input */\n      break;\n\n    case 'E':\n      rlogin = escape = _POSIX_VDISABLE;\n      break;\n\n    case 'K':\n#ifdef\tAUTHENTICATION\n      autologin = 0;\n#endif\n      break;\n\n    case 'L':\n      eight |= 2;\t\t/* binary output only */\n      break;\n\n#ifdef\tAUTHENTICATION\n    case 'X':\n      auth_disable_name (arg);\n      break;\n#endif\n\n    case 'a':\n      autologin = 1;\n      break;\n\n    case 'c':\n      skiprc = 1;\n      break;\n\n    case 'd':\n      debug = 1;\n      break;\n\n    case 'e':\n      set_escape_char (arg);\n      break;\n\n#if defined AUTHENTICATION && defined KRB5 && defined FORWARD\n    case 'f':\n      if (forward_flags & OPTS_FORWARD_CREDS)\n\targp_error (state, \"Only one of -f and -F allowed.\", prompt);\n      forward_flags |= OPTS_FORWARD_CREDS;\n      break;\n\n    case 'F':\n      if (forward_flags & OPTS_FORWARD_CREDS)\n\targp_error (state, \"Only one of -f and -F allowed\");\n      forward_flags |= OPTS_FORWARD_CREDS;\n      forward_flags |= OPTS_FORWARDABLE_CREDS;\n      break;\n#endif\n\n#if defined AUTHENTICATION && \\\n      ( defined KERBEROS || defined SHISHI )\n    case 'k':\n      dest_realm = arg;\n      break;\n#endif\n\n    case 'l':\n      autologin = 1;\n      user = arg;\n      break;\n\n    case 'n':\n      SetNetTrace (arg);\n      break;\n\n    case 'r':\n      rlogin = '~';\n      break;\n\n#if defined TN3270 && (defined unix || defined __unix || defined __unix__)\n    case 't':\n      /* FIXME: Buffer!!! */\n      transcom = tline;\n      strcpy (transcom, arg);\n      break;\n\n    case OPTION_NOASYNCH:\n      noasynchtty = noasynchtty = 1;\n      break;\n\n    case OPTION_NOASYNCTTY:\n      noasynchtty = 1;\n      break;\n\n    case OPTION_NOASYNCNET:\n      noasynchnet = 1;\n      break;\n#endif /* TN3270 && (unix || __unix || __unix__) */\n\n#ifdef\tENCRYPTION\n    case 'x':\n      encrypt_auto (1);\n      decrypt_auto (1);\n      break;\n#endif\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 121,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n\n  set_program_name (argv[0]);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n\n  tninit ();\t\t\t/* Clear out things */\n#if defined CRAY && !defined __STDC__\n  _setlist_init ();\t\t/* Work around compiler bug */\n#endif\n\n  TerminalSaveState ();\n\n  if ((prompt = strrchr (argv[0], '/')))\n    ++prompt;\n  else\n    prompt = argv[0];\n\n  user = NULL;\n\n  rlogin = (strncmp (prompt, \"rlog\", 4) == 0) ? '~' : _POSIX_VDISABLE;\n  autologin = -1;\n\n  /* Parse command line */\n  iu_argp_init (\"telnet\", default_program_authors);\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  if (autologin == -1)\n    autologin = (rlogin == _POSIX_VDISABLE) ? 0 : 1;\n\n  argc -= index;\n  argv += index;\n\n  if (argc)\n    {\n      /* The command line contains at least one argument.\n       */\n      char *args[8], **argp = args;\n\n      if (argc > 2)\n\terror (EXIT_FAILURE, 0, \"too many arguments\");\n      *argp++ = prompt;\n      if (user)\n\t{\n\t  *argp++ = \"-l\";\n\t  *argp++ = user;\n\t}\n      if (family == 4)\n\t*argp++ = \"-4\";\n      else if (family == 6)\n\t*argp++ = \"-6\";\n\n      *argp++ = argv[0];\t/* host */\n      if (argc > 1)\n\t*argp++ = argv[1];\t/* port */\n      *argp = 0;\n\n      if (setjmp (toplevel) != 0)\n\tExit (0);\n      if (tn (argp - args, args) == 1)\t/* Returns only on error.  */\n\treturn (0);\n      else\n\treturn (1);\n      /* NOT REACHED */\n    }\n\n  /* Built-in parser loop; sub-commands jump to `toplevel' mark.  */\n  setjmp (toplevel);\n  for (;;)\n    {\n#ifdef TN3270\n      if (shell_active)\n\tshell_continue ();\n      else\n#endif\n\tcommand (1, 0, 0);\n    }\n  /* NOT REACHED */\n}",
      "lines": 84,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/network.c": {
    "init_network": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ninit_network (void)\n{\n  if (ring_init (&netoring, netobuf, sizeof netobuf) != 1)\n    {\n      exit (EXIT_FAILURE);\n    }\n  if (ring_init (&netiring, netibuf, sizeof netibuf) != 1)\n    {\n      exit (EXIT_FAILURE);\n    }\n  NetTrace = stdout;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "stilloob": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\nstilloob (void)\n{\n  static struct timeval timeout = { 0, 0 };\n  fd_set excepts;\n  int value;\n\n  do\n    {\n      FD_ZERO (&excepts);\n      FD_SET (net, &excepts);\n      value =\n\tselect (net + 1, (fd_set *) 0, (fd_set *) 0, &excepts, &timeout);\n    }\n  while ((value == -1) && (errno == EINTR));\n\n  if (value < 0)\n    {\n      perror (\"select\");\n      (void) quit ();\n    }\n  if (FD_ISSET (net, &excepts))\n    {\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "setneturg": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nsetneturg (void)\n{\n  ring_mark (&netoring);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "netflush": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "int\nnetflush (void)\n{\n  register int n, n1;\n\n#ifdef\tENCRYPTION\n  if (encrypt_output)\n    ring_encrypt (&netoring, encrypt_output);\n#endif /* ENCRYPTION */\n  if ((n1 = n = ring_full_consecutive (&netoring)) > 0)\n    {\n      if (!ring_at_mark (&netoring))\n\t{\n\t  n = send (net, (char *) netoring.consume, n, 0);\t/* normal write */\n\t}\n      else\n\t{\n\t  /*\n\t   * In 4.2 (and 4.3) systems, there is some question about\n\t   * what byte in a sendOOB operation is the \"OOB\" data.\n\t   * To make ourselves compatible, we only send ONE byte\n\t   * out of band, the one WE THINK should be OOB (though\n\t   * we really have more the TCP philosophy of urgent data\n\t   * rather than the Unix philosophy of OOB data).\n\t   */\n\t  n = send (net, (char *) netoring.consume, 1, MSG_OOB);\t/* URGENT data */\n\t}\n    }\n  if (n < 0)\n    {\n      if (errno != ENOBUFS && errno != EWOULDBLOCK)\n\t{\n\t  setcommandmode ();\n\t  perror (hostname);\n\t  (void) NetClose (net);\n\t  ring_clear_mark (&netoring);\n\t  longjmp (peerdied, -1);\n\t}\n      n = 0;\n    }\n  if (netdata && n)\n    {\n      Dump ('>', netoring.consume, n);\n    }\n  if (n)\n    {\n      ring_consumed (&netoring, n);\n      /*\n       * If we sent all, and more to send, then recurse to pick\n       * up the other half.\n       */\n      if ((n1 == n) && ring_full_consecutive (&netoring))\n\t{\n\t  (void) netflush ();\n\t}\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/ring.c": {
    "ring_init": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nring_init (Ring * ring, unsigned char *buffer, int count)\n{\n  memset ((char *) ring, 0, sizeof *ring);\n\n  ring->size = count;\n\n  ring->supply = ring->consume = ring->bottom = buffer;\n\n  ring->top = ring->bottom + ring->size;\n\n#ifdef\tENCRYPTION\n  ring->clearto = 0;\n#endif /* ENCRYPTION */\n\n  return 1;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ring_mark": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nring_mark (Ring * ring)\n{\n  ring->mark = ring_decrement (ring, ring->supply, 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ring_at_mark": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\nring_at_mark (Ring * ring)\n{\n  if (ring->mark == ring->consume)\n    {\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "ring_clear_mark": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nring_clear_mark (Ring * ring)\n{\n  ring->mark = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ring_supplied": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\nring_supplied (Ring * ring, int count)\n{\n  ring->supply = ring_increment (ring, ring->supply, count);\n  ring->supplytime = ++ring_clock;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ring_consumed": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "void\nring_consumed (Ring * ring, int count)\n{\n  if (count == 0)\t\t/* don't update anything */\n    return;\n\n  if (ring->mark && (ring_subtract (ring, ring->mark, ring->consume) < count))\n    {\n      ring->mark = 0;\n    }\n#ifdef\tENCRYPTION\n  if (ring->consume < ring->clearto && ring->clearto <= ring->consume + count)\n    ring->clearto = 0;\n  else if (ring->consume + count > ring->top &&\n\t   ring->bottom <= ring->clearto &&\n\t   ring->bottom + ((ring->consume + count) - ring->top))\n    ring->clearto = 0;\n#endif /* ENCRYPTION */\n  ring->consume = ring_increment (ring, ring->consume, count);\n  ring->consumetime = ++ring_clock;\n  /*\n   * Try to encourage \"ring_empty_consecutive()\" to be large.\n   */\n  if (ring_empty (ring))\n    {\n      ring->consume = ring->supply = ring->bottom;\n    }\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ring_empty_count": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int\nring_empty_count (Ring * ring)\n{\n  if (ring_empty (ring))\n    {\t\t\t\t/* if empty */\n      return ring->size;\n    }\n  else\n    {\n      return ring_subtract (ring, ring->consume, ring->supply);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ring_empty_consecutive": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "int\nring_empty_consecutive (Ring * ring)\n{\n  if ((ring->consume < ring->supply) || ring_empty (ring))\n    {\n      /*\n       * if consume is \"below\" supply, or empty, then\n       * return distance to the top\n       */\n      return ring_subtract (ring, ring->top, ring->supply);\n    }\n  else\n    {\n      /*\n       * else, return what we may.\n       */\n      return ring_subtract (ring, ring->consume, ring->supply);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "ring_full_count": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nring_full_count (Ring * ring)\n{\n  if ((ring->mark == 0) || (ring->mark == ring->consume))\n    {\n      if (ring_full (ring))\n\t{\n\t  return ring->size;\t/* nothing consumed, but full */\n\t}\n      else\n\t{\n\t  return ring_subtract (ring, ring->supply, ring->consume);\n\t}\n    }\n  else\n    {\n      return ring_subtract (ring, ring->mark, ring->consume);\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "ring_full_consecutive": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "int\nring_full_consecutive (Ring * ring)\n{\n  if ((ring->mark == 0) || (ring->mark == ring->consume))\n    {\n      if ((ring->supply < ring->consume) || ring_full (ring))\n\t{\n\t  return ring_subtract (ring, ring->top, ring->consume);\n\t}\n      else\n\t{\n\t  return ring_subtract (ring, ring->supply, ring->consume);\n\t}\n    }\n  else\n    {\n      if (ring->mark < ring->consume)\n\t{\n\t  return ring_subtract (ring, ring->top, ring->consume);\n\t}\n      else\n\t{\t\t\t/* Else, distance to mark */\n\t  return ring_subtract (ring, ring->mark, ring->consume);\n\t}\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "ring_supply_data": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nring_supply_data (Ring * ring, unsigned char *buffer, int count)\n{\n  int i;\n\n  while (count)\n    {\n      i = MIN (count, ring_empty_consecutive (ring));\n      memmove (ring->supply, buffer, i);\n      ring_supplied (ring, i);\n      count -= i;\n      buffer += i;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ring_encrypt": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "void\nring_encrypt (Ring * ring, void (*encryptor) ())\n{\n  unsigned char *s, *c;\n\n  if (ring_empty (ring) || ring->clearto == ring->supply)\n    return;\n\n  if (!(c = ring->clearto))\n    c = ring->consume;\n\n  s = ring->supply;\n\n  if (s <= c)\n    {\n      (*encryptor) (c, ring->top - c);\n      (*encryptor) (ring->bottom, s - ring->bottom);\n    }\n  else\n    (*encryptor) (c, s - c);\n\n  ring->clearto = ring->supply;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ring_clearto": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "void\nring_clearto (Ring * ring)\n{\n  if (!ring_empty (ring))\n    ring->clearto = ring->supply;\n  else\n    ring->clearto = 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/ring.h": {},
  "inetutils/inetutils-1.9.4/telnet/sys_bsd.c": {
    "init_sys": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\ninit_sys (void)\n{\n  tout = fileno (stdout);\n  tin = fileno (stdin);\n  FD_ZERO (&ibits);\n  FD_ZERO (&obits);\n  FD_ZERO (&xbits);\n\n  errno = 0;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "TerminalWrite": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nTerminalWrite (char *buf, int n)\n{\n  return write (tout, buf, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "TerminalRead": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nTerminalRead (char *buf, int n)\n{\n  return read (tin, buf, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "TerminalAutoFlush": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nTerminalAutoFlush (void)\n{\n#if defined LNOFLSH\n  int flush;\n\n  ioctl (0, TIOCLGET, (char *) &flush);\n  return !(flush & LNOFLSH);\t/* if LNOFLSH, no autoflush */\n#else /* LNOFLSH */\n  return 1;\n#endif /* LNOFLSH */\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "TerminalSpecialChars": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nTerminalSpecialChars (int c)\n{\n  if (c == termIntChar)\n    {\n      intp ();\n      return 0;\n    }\n  else if (c == termQuitChar)\n    {\n#ifdef\tKLUDGELINEMODE\n      if (kludgelinemode)\n\tsendbrk ();\n      else\n#endif\n\tsendabort ();\n      return 0;\n    }\n  else if (c == termEofChar)\n    {\n      if (my_want_state_is_will (TELOPT_LINEMODE))\n\t{\n\t  sendeof ();\n\t  return 0;\n\t}\n      return 1;\n    }\n  else if (c == termSuspChar)\n    {\n      sendsusp ();\n      return (0);\n    }\n  else if (c == termFlushChar)\n    {\n      xmitAO ();\t\t/* Transmit Abort Output */\n      return 0;\n    }\n  else if (!MODE_LOCAL_CHARS (globalmode))\n    {\n      if (c == termKillChar)\n\t{\n\t  xmitEL ();\n\t  return 0;\n\t}\n      else if (c == termEraseChar)\n\t{\n\t  xmitEC ();\t\t/* Transmit Erase Character */\n\t  return 0;\n\t}\n    }\n  return 1;\n}",
      "lines": 52,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "TerminalFlushOutput": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "void\nTerminalFlushOutput (void)\n{\n  int flags = 0;\n#ifdef\tTIOCFLUSH\n  ioctl (fileno (stdout), TIOCFLUSH, &flags);\n#else\n  ioctl (fileno (stdout), TCFLSH, &flags);\n#endif\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "TerminalSaveState": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "void\nTerminalSaveState (void)\n{\n#ifndef USE_TERMIO\n  ioctl (0, TIOCGETP, (char *) &ottyb);\n  ioctl (0, TIOCGETC, (char *) &otc);\n  ioctl (0, TIOCGLTC, (char *) &oltc);\n  ioctl (0, TIOCLGET, (char *) &olmode);\n\n  ntc = otc;\n  nltc = oltc;\n  nttyb = ottyb;\n\n#else /* USE_TERMIO */\n  tcgetattr (0, &old_tc);\n\n  new_tc = old_tc;\n\n# ifndef VDISCARD\n  termFlushChar = CONTROL ('O');\n# endif\n# ifndef VWERASE\n  termWerasChar = CONTROL ('W');\n# endif\n# ifndef VREPRINT\n  termRprntChar = CONTROL ('R');\n# endif\n# ifndef VLNEXT\n  termLiteralNextChar = CONTROL ('V');\n# endif\n# ifndef VSTART\n  termStartChar = CONTROL ('Q');\n# endif\n# ifndef VSTOP\n  termStopChar = CONTROL ('S');\n# endif\n# ifndef VSTATUS\n  termAytChar = CONTROL ('T');\n# endif\n#endif /* USE_TERMIO */\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "tcval": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "cc_t *\ntcval (register int func)\n{\n  switch (func)\n    {\n    case SLC_IP:\n      return (&termIntChar);\n    case SLC_ABORT:\n      return (&termQuitChar);\n    case SLC_EOF:\n      return (&termEofChar);\n    case SLC_EC:\n      return (&termEraseChar);\n    case SLC_EL:\n      return (&termKillChar);\n    case SLC_XON:\n      return (&termStartChar);\n    case SLC_XOFF:\n      return (&termStopChar);\n    case SLC_FORW1:\n      return (&termForw1Char);\n#ifdef\tUSE_TERMIO\n    case SLC_FORW2:\n      return (&termForw2Char);\n# ifdef\tVDISCARD\n    case SLC_AO:\n      return (&termFlushChar);\n# endif\n# ifdef\tVSUSP\n    case SLC_SUSP:\n      return (&termSuspChar);\n# endif\n# ifdef\tVWERASE\n    case SLC_EW:\n      return (&termWerasChar);\n# endif\n# ifdef\tVREPRINT\n    case SLC_RP:\n      return (&termRprntChar);\n# endif\n# ifdef\tVLNEXT\n    case SLC_LNEXT:\n      return (&termLiteralNextChar);\n# endif\n# ifdef\tVSTATUS\n    case SLC_AYT:\n      return (&termAytChar);\n# endif\n#endif\n\n    case SLC_SYNCH:\n    case SLC_BRK:\n    case SLC_EOR:\n    default:\n      return ((cc_t *) 0);\n    }\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "cc_t",
        "*\ntcval (register int func)",
        "*"
      ]
    },
    "TerminalDefaultChars": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "void\nTerminalDefaultChars (void)\n{\n#ifndef USE_TERMIO\n  ntc = otc;\n  nltc = oltc;\n  nttyb.sg_kill = ottyb.sg_kill;\n  nttyb.sg_erase = ottyb.sg_erase;\n#else /* USE_TERMIO */\n  memmove (new_tc.c_cc, old_tc.c_cc, sizeof (old_tc.c_cc));\n# ifndef VDISCARD\n  termFlushChar = CONTROL ('O');\n# endif\n# ifndef VWERASE\n  termWerasChar = CONTROL ('W');\n# endif\n# ifndef VREPRINT\n  termRprntChar = CONTROL ('R');\n# endif\n# ifndef VLNEXT\n  termLiteralNextChar = CONTROL ('V');\n# endif\n# ifndef VSTART\n  termStartChar = CONTROL ('Q');\n# endif\n# ifndef VSTOP\n  termStopChar = CONTROL ('S');\n# endif\n# ifndef VSTATUS\n  termAytChar = CONTROL ('T');\n# endif\n#endif /* USE_TERMIO */\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "TerminalNewMode": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "void\nTerminalNewMode (register int f)\n{\n  static int prevmode = 0;\n#ifndef USE_TERMIO\n  struct tchars tc;\n  struct ltchars ltc;\n  struct sgttyb sb;\n  int lmode;\n#else /* USE_TERMIO */\n  struct termio tmp_tc;\n#endif /* USE_TERMIO */\n  int onoff;\n  int old;\n  cc_t esc;\n\n  globalmode = f & ~MODE_FORCE;\n  if (prevmode == f)\n    return;\n\n  /*\n   * Write any outstanding data before switching modes\n   * ttyflush() returns 0 only when there is no more data\n   * left to write out, it returns -1 if it couldn't do\n   * anything at all, otherwise it returns 1 + the number\n   * of characters left to write.\n   #ifndef    USE_TERMIO\n   * We would really like ask the kernel to wait for the output\n   * to drain, like we can do with the TCSADRAIN, but we don't have\n   * that option.  The only ioctl that waits for the output to\n   * drain, TIOCSETP, also flushes the input queue, which is NOT\n   * what we want (TIOCSETP is like TCSADFLUSH).\n   #endif\n   */\n  old = ttyflush (SYNCHing | flushout);\n  if (old < 0 || old > 1)\n    {\n#ifdef\tUSE_TERMIO\n      tcgetattr (tin, &tmp_tc);\n#endif /* USE_TERMIO */\n      do\n\t{\n\t  /*\n\t   * Wait for data to drain, then flush again.\n\t   */\n#ifdef\tUSE_TERMIO\n\t  tcsetattr (tin, TCSADRAIN, &tmp_tc);\n#endif /* USE_TERMIO */\n\t  old = ttyflush (SYNCHing | flushout);\n\t}\n      while (old < 0 || old > 1);\n    }\n\n  old = prevmode;\n  prevmode = f & ~MODE_FORCE;\n#ifndef USE_TERMIO\n  sb = nttyb;\n  tc = ntc;\n  ltc = nltc;\n  lmode = olmode;\n#else\n  tmp_tc = new_tc;\n#endif\n\n  if (f & MODE_ECHO)\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags |= ECHO;\n#else\n      tmp_tc.c_lflag |= ECHO;\n      tmp_tc.c_oflag |= ONLCR;\n      if (crlf)\n\ttmp_tc.c_iflag |= ICRNL;\n#endif\n    }\n  else\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags &= ~ECHO;\n#else\n      tmp_tc.c_lflag &= ~ECHO;\n      tmp_tc.c_oflag &= ~ONLCR;\n#endif\n    }\n\n  if ((f & MODE_FLOW) == 0)\n    {\n#ifndef USE_TERMIO\n      tc.t_startc = _POSIX_VDISABLE;\n      tc.t_stopc = _POSIX_VDISABLE;\n#else\n      tmp_tc.c_iflag &= ~(IXOFF | IXON);\t/* Leave the IXANY bit alone */\n    }\n  else\n    {\n      if (restartany < 0)\n\t{\n\t  tmp_tc.c_iflag |= IXOFF | IXON;\t/* Leave the IXANY bit alone */\n\t}\n      else if (restartany > 0)\n\t{\n\t  tmp_tc.c_iflag |= IXOFF | IXON | IXANY;\n\t}\n      else\n\t{\n\t  tmp_tc.c_iflag |= IXOFF | IXON;\n\t  tmp_tc.c_iflag &= ~IXANY;\n\t}\n#endif\n    }\n\n  if ((f & MODE_TRAPSIG) == 0)\n    {\n#ifndef USE_TERMIO\n      tc.t_intrc = _POSIX_VDISABLE;\n      tc.t_quitc = _POSIX_VDISABLE;\n      tc.t_eofc = _POSIX_VDISABLE;\n      ltc.t_suspc = _POSIX_VDISABLE;\n      ltc.t_dsuspc = _POSIX_VDISABLE;\n#else\n      tmp_tc.c_lflag &= ~ISIG;\n#endif\n      localchars = 0;\n    }\n  else\n    {\n#ifdef\tUSE_TERMIO\n      tmp_tc.c_lflag |= ISIG;\n#endif\n      localchars = 1;\n    }\n\n  if (f & MODE_EDIT)\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags &= ~CBREAK;\n      sb.sg_flags |= CRMOD;\n#else\n      tmp_tc.c_lflag |= ICANON;\n#endif\n    }\n  else\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags |= CBREAK;\n      if (f & MODE_ECHO)\n\tsb.sg_flags |= CRMOD;\n      else\n\tsb.sg_flags &= ~CRMOD;\n#else\n      tmp_tc.c_lflag &= ~ICANON;\n      tmp_tc.c_iflag &= ~ICRNL;\n      tmp_tc.c_cc[VMIN] = 1;\n      tmp_tc.c_cc[VTIME] = 0;\n#endif\n    }\n\n  if ((f & (MODE_EDIT | MODE_TRAPSIG)) == 0)\n    {\n#ifndef USE_TERMIO\n      ltc.t_lnextc = _POSIX_VDISABLE;\n#else\n# ifdef VLNEXT\n      tmp_tc.c_cc[VLNEXT] = (cc_t) (_POSIX_VDISABLE);\n# endif\n#endif\n    }\n\n  if (f & MODE_SOFT_TAB)\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags |= XTABS;\n#else\n# ifdef\tOXTABS\n      tmp_tc.c_oflag |= OXTABS;\n# endif\n# ifdef\tTABDLY\n      tmp_tc.c_oflag &= ~TABDLY;\n      tmp_tc.c_oflag |= TAB3;\n# endif\n#endif\n    }\n  else\n    {\n#ifndef USE_TERMIO\n      sb.sg_flags &= ~XTABS;\n#else\n# ifdef\tOXTABS\n      tmp_tc.c_oflag &= ~OXTABS;\n# endif\n# ifdef\tTABDLY\n      tmp_tc.c_oflag &= ~TABDLY;\n# endif\n#endif\n    }\n\n  if (f & MODE_LIT_ECHO)\n    {\n#ifndef USE_TERMIO\n      lmode &= ~LCTLECH;\n#else\n# ifdef\tECHOCTL\n      tmp_tc.c_lflag &= ~ECHOCTL;\n# endif\n#endif\n    }\n  else\n    {\n#ifndef USE_TERMIO\n      lmode |= LCTLECH;\n#else\n# ifdef\tECHOCTL\n      tmp_tc.c_lflag |= ECHOCTL;\n# endif\n#endif\n    }\n\n  if (f == -1)\n    {\n      onoff = 0;\n    }\n  else\n    {\n#ifndef USE_TERMIO\n      if (f & MODE_OUTBIN)\n\tlmode |= LLITOUT;\n# if 0\t\t\t\t/* If not in binary mode, still allow all 8-bits.  */\n      else\n\tlmode &= ~LLITOUT;\n# endif\n\n      if (f & MODE_INBIN)\n\tlmode |= LPASS8;\n# if 0\t\t\t\t/* If not in binary mode, still allow all 8-bits.  */\n      else\n\tlmode &= ~LPASS8;\n# endif\n#else\n      if (f & MODE_INBIN)\n\ttmp_tc.c_iflag &= ~ISTRIP;\n# if 0\t\t\t\t/* If not in binary mode, still allow all 8-bits.  */\n      else\n\ttmp_tc.c_iflag |= ISTRIP;\n# endif\n      if (f & MODE_OUTBIN)\n\t{\n\t  tmp_tc.c_cflag &= ~(CSIZE | PARENB);\n\t  tmp_tc.c_cflag |= CS8;\n\t  tmp_tc.c_oflag &= ~OPOST;\n\t}\n      else\n\t{\n\t  tmp_tc.c_cflag &= ~(CSIZE | PARENB);\n\t  tmp_tc.c_cflag |= old_tc.c_cflag & (CSIZE | PARENB);\n\t  tmp_tc.c_oflag |= OPOST;\n\t}\n#endif\n      onoff = 1;\n    }\n\n  if (f != -1)\n    {\n#ifdef\tSIGTSTP\n      void susp (int sig);\n#endif /* SIGTSTP */\n#ifdef\tSIGINFO\n      void ayt ();\n#endif\n\n#ifdef\tSIGTSTP\n      signal (SIGTSTP, susp);\n#endif /* SIGTSTP */\n#ifdef\tSIGINFO\n      signal (SIGINFO, ayt);\n#endif\n#if defined USE_TERMIO && defined NOKERNINFO\n      tmp_tc.c_lflag |= NOKERNINFO;\n#endif\n      /*\n       * We don't want to process ^Y here.  It's just another\n       * character that we'll pass on to the back end.  It has\n       * to process it because it will be processed when the\n       * user attempts to read it, not when we send it.\n       */\n#ifndef USE_TERMIO\n      ltc.t_dsuspc = _POSIX_VDISABLE;\n#else\n# ifdef\tVDSUSP\n      tmp_tc.c_cc[VDSUSP] = (cc_t) (_POSIX_VDISABLE);\n# endif\n#endif\n#ifdef\tUSE_TERMIO\n      /*\n       * If the VEOL character is already set, then use VEOL2,\n       * otherwise use VEOL.\n       */\n      esc = (rlogin != _POSIX_VDISABLE) ? rlogin : escape;\n      if ((tmp_tc.c_cc[VEOL] != esc)\n# ifdef\tVEOL2\n\t  && (tmp_tc.c_cc[VEOL2] != esc)\n# endif\n\t)\n\t{\n\t  if (tmp_tc.c_cc[VEOL] == (cc_t) (_POSIX_VDISABLE))\n\t    tmp_tc.c_cc[VEOL] = esc;\n# ifdef\tVEOL2\n\t  else if (tmp_tc.c_cc[VEOL2] == (cc_t) (_POSIX_VDISABLE))\n\t    tmp_tc.c_cc[VEOL2] = esc;\n# endif\n\t}\n#else\n      if (tc.t_brkc == (cc_t) (_POSIX_VDISABLE))\n\ttc.t_brkc = esc;\n#endif\n    }\n  else\n    {\n#ifdef\tSIGINFO\n      void ayt_status ();\n\n      signal (SIGINFO, ayt_status);\n#endif\n#ifdef\tSIGTSTP\n      signal (SIGTSTP, SIG_DFL);\n# ifdef HAVE_SIGACTION\n      {\n\tsigset_t sigs;\n\tsigemptyset (&sigs);\n\tsigaddset (&sigs, SIGTSTP);\n\tsigprocmask (SIG_UNBLOCK, &sigs, 0);\n      }\n# else\n      sigsetmask (sigblock (0) & ~(1 << (SIGTSTP - 1)));\n# endif\t/* HAVE_SIGACTION */\n#endif /* SIGTSTP */\n#ifndef USE_TERMIO\n      ltc = oltc;\n      tc = otc;\n      sb = ottyb;\n      lmode = olmode;\n#else\n      tmp_tc = old_tc;\n#endif\n    }\n#ifndef USE_TERMIO\n  ioctl (tin, TIOCLSET, (char *) &lmode);\n  ioctl (tin, TIOCSLTC, (char *) &ltc);\n  ioctl (tin, TIOCSETC, (char *) &tc);\n  ioctl (tin, TIOCSETN, (char *) &sb);\n#else\n  if (tcsetattr (tin, TCSADRAIN, &tmp_tc) < 0)\n    tcsetattr (tin, TCSANOW, &tmp_tc);\n#endif\n\n#if  !defined TN3270 ||  (!defined NOT43 || defined PUTCHAR)\n# if !defined sysV88\n  ioctl (tin, FIONBIO, (char *) &onoff);\n  ioctl (tout, FIONBIO, (char *) &onoff);\n# endif\n#endif /* (!defined(TN3270)) || ((!defined(NOT43)) || defined(PUTCHAR)) */\n#if defined TN3270\n  if (noasynchtty == 0)\n    {\n      ioctl (tin, FIOASYNC, (char *) &onoff);\n    }\n#endif /* defined(TN3270) */\n\n}\n\n/*\n * Try to guess whether speeds are \"encoded\" (4.2BSD) or just numeric (4.4BSD).\n */\n#if B4800 != 4800\n# define DECODE_BAUD\n#endif\n\n#ifdef\tDECODE_BAUD\n# ifndef B7200\n#  define B7200   B4800\n# endif\n\n# ifndef B14400\n#  define B14400  B9600\n# endif\n\n# ifndef B19200\n#  define B19200 B14400\n# endif\n\n# ifndef B28800\n#  define B28800  B19200\n# endif\n\n# ifndef B38400\n#  define B38400 B28800\n# endif\n\n# ifndef B57600\n#  define B57600  B38400\n# endif\n\n# ifndef B76800\n#  define B76800  B57600\n# endif\n\n# ifndef B115200\n#  define B115200 B76800\n# endif\n\n# ifndef B230400\n#  define B230400 B115200\n# endif\n\n\n/*\n * This code assumes that the values B0, B50, B75...\n * are in ascending order.  They do not have to be\n * contiguous.\n */\nstruct termspeeds\n{\n  long speed;\n  long value;\n} termspeeds[] =\n  {\n    {0, B0},\n    {50, B50},\n    {75, B75},\n    {110, B110},\n    {134, B134},\n    {150, B150},\n    {200, B200},\n    {300, B300},\n    {600, B600},\n    {1200, B1200},\n    {1800, B1800},\n    {2400, B2400},\n    {4800, B4800},\n    {7200, B7200},\n    {9600, B9600},\n    {14400, B14400},\n    {19200, B19200},\n    {28800, B28800},\n    {38400, B38400},\n    {57600, B57600},\n    {115200, B115200},\n    {230400, B230400},\n    {-1, B230400}\n  };\n#endif /* DECODE_BAUD */\n\nvoid\nTerminalSpeeds (long *ispeed, long *ospeed)\n{\n#ifdef\tDECODE_BAUD\n  register struct termspeeds *tp;\n#endif /* DECODE_BAUD */\n  register long in, out;\n\n  out = cfgetospeed (&old_tc);\n  in = cfgetispeed (&old_tc);\n  if (in == 0)\n    in = out;\n\n#ifdef\tDECODE_BAUD\n  tp = termspeeds;\n  while ((tp->speed != -1) && (tp->value < in))\n    tp++;\n  *ispeed = tp->speed;\n\n  tp = termspeeds;\n  while ((tp->speed != -1) && (tp->value < out))\n    tp++;\n  *ospeed = tp->speed;\n#else /* DECODE_BAUD */\n  *ispeed = in;\n  *ospeed = out;\n#endif /* DECODE_BAUD */\n}\n\nint\nTerminalWindowSize (long *rows, long *cols)\n{\n#ifdef\tTIOCGWINSZ\n  struct winsize ws;\n\n  if (ioctl (fileno (stdin), TIOCGWINSZ, (char *) &ws) >= 0)\n    {\n      *rows = ws.ws_row;\n      *cols = ws.ws_col;\n      return 1;\n    }\n#endif /* TIOCGWINSZ */\n  return 0;\n}\n\nint\nNetClose (int fd)\n{\n  return close (fd);\n}\n\n\nvoid\nNetNonblockingIO (int fd, int onoff)\n{\n  ioctl (fd, FIONBIO, (char *) &onoff);\n}\n\n#if defined TN3270\nvoid\nNetSigIO (int fd, int onoff)\n{\n  ioctl (fd, FIOASYNC, (char *) &onoff);\t/* hear about input */\n}\n\nvoid\nNetSetPgrp (int fd)\n{\n  int myPid;\n\n  myPid = getpid ();\n  fcntl (fd, F_SETOWN, myPid);\n}\n#endif /*defined(TN3270) */\n\f\n/*\n * Various signal handling routines.\n */\n\nvoid\ndeadpeer (int sig _GL_UNUSED_PARAMETER)\n{\n  setcommandmode ();\n  longjmp (peerdied, -1);\n}\n\n\nvoid\nintr (int sig _GL_UNUSED_PARAMETER)\n{\n  if (localchars)\n    {\n      intp ();\n      return;\n    }\n  setcommandmode ();\n  longjmp (toplevel, -1);\n}\n\n\nvoid\nintr2 (int sig _GL_UNUSED_PARAMETER)\n{\n  if (localchars)\n    {\n#ifdef\tKLUDGELINEMODE\n      if (kludgelinemode)\n\tsendbrk ();\n      else\n#endif\n\tsendabort ();\n      return;\n    }\n}\n\n#ifdef\tSIGTSTP\nvoid\nsusp (int sig _GL_UNUSED_PARAMETER)\n{\n  if ((rlogin != _POSIX_VDISABLE) && rlogin_susp ())\n    return;\n  if (localchars)\n    sendsusp ();\n}\n#endif\n\n#ifdef\tSIGWINCH\nvoid\nsendwin (int sig _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    {\n      sendnaws ();\n    }\n}\n#endif\n\n#ifdef\tSIGINFO\nvoid\nayt (int sig _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    sendayt ();\n  else\n    ayt_status ();\n}\n#endif\n\f\n\nvoid\nsys_telnet_init (void)\n{\n  struct sigaction sa;\n\n  sa.sa_flags = SA_RESTART;\n  sigemptyset (&sa.sa_mask);\n\n  signal (SIGINT, intr);\n  signal (SIGQUIT, intr2);\n  signal (SIGPIPE, deadpeer);\n#ifdef\tSIGWINCH\n  sa.sa_handler = sendwin;\n  (void) sigaction (SIGWINCH, &sa, NULL);\n#endif\n#ifdef\tSIGTSTP\n  sa.sa_handler = susp;\n  (void) sigaction (SIGTSTP, &sa, NULL);\n#endif\n#ifdef\tSIGINFO\n  sa.sa_handler = ayt;\n  (void) sigaction (SIGINFO, &sa, NULL);\n#endif\n\n  setconnmode (0);\n\n  NetNonblockingIO (net, 1);\n\n#if defined TN3270\n  if (noasynchnet == 0)\n    {\t\t\t\t/* DBX can't handle! */\n      NetSigIO (net, 1);\n      NetSetPgrp (net);\n    }\n#endif /* defined(TN3270) */\n\n#if defined SO_OOBINLINE\n  if (SetSockOpt (net, SOL_SOCKET, SO_OOBINLINE, 1) == -1)\n    {\n      perror (\"SetSockOpt\");\n    }\n#endif /* defined(SO_OOBINLINE) */\n}\n\n/*\n * Process rings -\n *\n *\tThis routine tries to fill up/empty our various rings.\n *\n *\tThe parameter specifies whether this is a poll operation,\n *\tor a block-until-something-happens operation.\n *\n *\tThe return value is 1 if something happened, 0 if not.\n */\n\n/* poll; If 0, then block until something to do */\nint\nprocess_rings (int netin, int netout, int netex, int ttyin, int ttyout,\n\t       int poll)\n{\n  register int c;\n  /* One wants to be a bit careful about setting returnValue\n   * to one, since a one implies we did some useful work,\n   * and therefore probably won't be called to block next\n   * time (TN3270 mode only).\n   */\n  int returnValue = 0;\n  static struct timeval TimeValue = { 0, 0 };\n  int nfds = 0;\n\n  if (netout)\n    {\n      FD_SET (net, &obits);\n      if (net > nfds)\n        nfds = net;\n    }\n  if (ttyout)\n    {\n      FD_SET (tout, &obits);\n      if (tout > nfds)\n        nfds = tout;\n    }\n#if defined TN3270\n  if (ttyin)\n    {\n      FD_SET (tin, &ibits);\n      if (tin > nfds)\n        nfds = tin;\n    }\n#else /* defined(TN3270) */\n  if (ttyin)\n    {\n      FD_SET (tin, &ibits);\n      if (tin > nfds)\n        nfds = tin;\n    }\n#endif /* defined(TN3270) */\n#if defined TN3270\n  if (netin)\n    {\n      FD_SET (net, &ibits);\n      if (net > nfds)\n        nfds = net;\n    }\n#else /* !defined(TN3270) */\n  if (netin)\n    {\n      FD_SET (net, &ibits);\n      if (net > nfds)\n        nfds = net;\n    }\n#endif /* !defined(TN3270) */\n  if (netex)\n    {\n      FD_SET (net, &xbits);\n      if (net > nfds)\n        nfds = net;\n    }\n  if ((c = select (nfds+1, &ibits, &obits, &xbits,\n\t\t   (poll == 0) ? (struct timeval *) 0 : &TimeValue)) < 0)\n    {\n      if (c == -1)\n\t{\n\t  /*\n\t   * we can get EINTR if we are in line mode,\n\t   * and the user does an escape (TSTP), or\n\t   * some other signal generator.\n\t   */\n\t  if (errno == EINTR)\n\t    {\n\t      return 0;\n\t    }\n#if defined TN3270\n\t  /*\n\t   * we can get EBADF if we were in transparent\n\t   * mode, and the transcom process died.\n\t   */\n\t  if (errno == EBADF)\n\t    {\n\t      /*\n\t       * zero the bits (even though kernel does it)\n\t       * to make sure we are selecting on the right\n\t       * ones.\n\t       */\n\t      FD_ZERO (&ibits);\n\t      FD_ZERO (&obits);\n\t      FD_ZERO (&xbits);\n\t      return 0;\n\t    }\n#endif /* defined(TN3270) */\n\t  /* I don't like this, does it ever happen? */\n\t  printf (\"sleep(5) from telnet, after select\\r\\n\");\n\t  sleep (5);\n\t}\n      return 0;\n    }\n\n  /*\n   * Any urgent data?\n   */\n  if (FD_ISSET (net, &xbits))\n    {\n      FD_CLR (net, &xbits);\n      SYNCHing = 1;\n      ttyflush (1);\t\t/* flush already enqueued data */\n    }\n\n  /*\n   * Something to read from the network...\n   */\n  if (FD_ISSET (net, &ibits))\n    {\n      int canread;\n\n      FD_CLR (net, &ibits);\n      canread = ring_empty_consecutive (&netiring);\n#if !defined SO_OOBINLINE\n      /*\n       * In 4.2 (and some early 4.3) systems, the\n       * OOB indication and data handling in the kernel\n       * is such that if two separate TCP Urgent requests\n       * come in, one byte of TCP data will be overlaid.\n       * This is fatal for Telnet, but we try to live\n       * with it.\n       *\n       * In addition, in 4.2 (and...), a special protocol\n       * is needed to pick up the TCP Urgent data in\n       * the correct sequence.\n       *\n       * What we do is:  if we think we are in urgent\n       * mode, we look to see if we are \"at the mark\".\n       * If we are, we do an OOB receive.  If we run\n       * this twice, we will do the OOB receive twice,\n       * but the second will fail, since the second\n       * time we were \"at the mark\", but there wasn't\n       * any data there (the kernel doesn't reset\n       * \"at the mark\" until we do a normal read).\n       * Once we've read the OOB data, we go ahead\n       * and do normal reads.\n       *\n       * There is also another problem, which is that\n       * since the OOB byte we read doesn't put us\n       * out of OOB state, and since that byte is most\n       * likely the TELNET DM (data mark), we would\n       * stay in the TELNET SYNCH (SYNCHing) state.\n       * So, clocks to the rescue.  If we've \"just\"\n       * received a DM, then we test for the\n       * presence of OOB data when the receive OOB\n       * fails (and AFTER we did the normal mode read\n       * to clear \"at the mark\").\n       */\n      if (SYNCHing)\n\t{\n\t  int atmark;\n\t  static int bogus_oob = 0, first = 1;\n\n\t  ioctl (net, SIOCATMARK, (char *) &atmark);\n\t  if (atmark)\n\t    {\n\t      c = recv (net, netiring.supply, canread, MSG_OOB);\n\t      if ((c == -1) && (errno == EINVAL))\n\t\t{\n\t\t  c = recv (net, netiring.supply, canread, 0);\n\t\t  if (clocks.didnetreceive < clocks.gotDM)\n\t\t    {\n\t\t      SYNCHing = stilloob (net);\n\t\t    }\n\t\t}\n\t      else if (first && c > 0)\n\t\t{\n\t\t  /*\n\t\t   * Bogosity check.  Systems based on 4.2BSD\n\t\t   * do not return an error if you do a second\n\t\t   * recv(MSG_OOB).  So, we do one.  If it\n\t\t   * succeeds and returns exactly the same\n\t\t   * data, then assume that we are running\n\t\t   * on a broken system and set the bogus_oob\n\t\t   * flag.  (If the data was different, then\n\t\t   * we probably got some valid new data, so\n\t\t   * increment the count...)\n\t\t   */\n\t\t  int i;\n\t\t  i = recv (net, netiring.supply + c, canread - c, MSG_OOB);\n\t\t  if (i == c &&\n\t\t      memcmp (netiring.supply, netiring.supply + c, i) == 0)\n\t\t    {\n\t\t      bogus_oob = 1;\n\t\t      first = 0;\n\t\t    }\n\t\t  else if (i < 0)\n\t\t    {\n\t\t      bogus_oob = 0;\n\t\t      first = 0;\n\t\t    }\n\t\t  else\n\t\t    c += i;\n\t\t}\n\t      if (bogus_oob && c > 0)\n\t\t{\n\t\t  int i;\n\t\t  /*\n\t\t   * Bogosity.  We have to do the read\n\t\t   * to clear the atmark to get out of\n\t\t   * an infinate loop.\n\t\t   */\n\t\t  i = read (net, netiring.supply + c, canread - c);\n\t\t  if (i > 0)\n\t\t    c += i;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      c = recv (net, netiring.supply, canread, 0);\n\t    }\n\t}\n      else\n\t{\n\t  c = recv (net, netiring.supply, canread, 0);\n\t}\n      settimer (didnetreceive);\n#else /* !defined(SO_OOBINLINE) */\n      c = recv (net, (char *) netiring.supply, canread, 0);\n#endif /* !defined(SO_OOBINLINE) */\n      if (c < 0 && errno == EWOULDBLOCK)\n\t{\n\t  c = 0;\n\t}\n      else if (c <= 0)\n\t{\n\t  return -1;\n\t}\n      if (netdata)\n\t{\n\t  Dump ('<', netiring.supply, c);\n\t}\n      if (c)\n\tring_supplied (&netiring, c);\n      returnValue = 1;\n    }\n\n  /*\n   * Something to read from the tty...\n   */\n  if (FD_ISSET (tin, &ibits))\n    {\n      FD_CLR (tin, &ibits);\n      c = TerminalRead ((char *)ttyiring.supply,\n                        ring_empty_consecutive (&ttyiring));\n      if (c < 0 && errno == EIO)\n\tc = 0;\n      if (c < 0 && errno == EWOULDBLOCK)\n\t{\n\t  c = 0;\n\t}\n      else\n\t{\n\t  /* EOF detection for line mode!!!! */\n\t  if ((c == 0) && MODE_LOCAL_CHARS (globalmode) && isatty (tin))\n\t    {\n\t      /* must be an EOF... */\n\t      *ttyiring.supply = termEofChar;\n\t      c = 1;\n\t    }\n\t  if (c <= 0)\n\t    {\n\t      return -1;\n\t    }\n\t  if (termdata)\n\t    {\n\t      Dump ('<', ttyiring.supply, c);\n\t    }\n\t  ring_supplied (&ttyiring, c);\n\t}\n      returnValue = 1;\t\t/* did something useful */\n    }\n\n  if (FD_ISSET (net, &obits))\n    {\n      FD_CLR (net, &obits);\n      returnValue |= netflush ();\n    }\n  if (FD_ISSET (tout, &obits))\n    {\n      FD_CLR (tout, &obits);\n      returnValue |= (ttyflush (SYNCHing | flushout) > 0);\n    }\n\n  return returnValue;\n}",
      "lines": 949,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "TerminalSpeeds": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "void\nTerminalSpeeds (long *ispeed, long *ospeed)\n{\n#ifdef\tDECODE_BAUD\n  register struct termspeeds *tp;\n#endif /* DECODE_BAUD */\n  register long in, out;\n\n  out = cfgetospeed (&old_tc);\n  in = cfgetispeed (&old_tc);\n  if (in == 0)\n    in = out;\n\n#ifdef\tDECODE_BAUD\n  tp = termspeeds;\n  while ((tp->speed != -1) && (tp->value < in))\n    tp++;\n  *ispeed = tp->speed;\n\n  tp = termspeeds;\n  while ((tp->speed != -1) && (tp->value < out))\n    tp++;\n  *ospeed = tp->speed;\n#else /* DECODE_BAUD */\n  *ispeed = in;\n  *ospeed = out;\n#endif /* DECODE_BAUD */\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "TerminalWindowSize": {
      "start_point": [
        892,
        0
      ],
      "end_point": [
        906,
        1
      ],
      "content": "int\nTerminalWindowSize (long *rows, long *cols)\n{\n#ifdef\tTIOCGWINSZ\n  struct winsize ws;\n\n  if (ioctl (fileno (stdin), TIOCGWINSZ, (char *) &ws) >= 0)\n    {\n      *rows = ws.ws_row;\n      *cols = ws.ws_col;\n      return 1;\n    }\n#endif /* TIOCGWINSZ */\n  return 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "NetClose": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "int\nNetClose (int fd)\n{\n  return close (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "NetNonblockingIO": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "void\nNetNonblockingIO (int fd, int onoff)\n{\n  ioctl (fd, FIONBIO, (char *) &onoff);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "NetSigIO": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        926,
        1
      ],
      "content": "void\nNetSigIO (int fd, int onoff)\n{\n  ioctl (fd, FIOASYNC, (char *) &onoff);\t/* hear about input */\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "NetSetPgrp": {
      "start_point": [
        928,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "void\nNetSetPgrp (int fd)\n{\n  int myPid;\n\n  myPid = getpid ();\n  fcntl (fd, F_SETOWN, myPid);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "deadpeer": {
      "start_point": [
        942,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "void\ndeadpeer (int sig _GL_UNUSED_PARAMETER)\n{\n  setcommandmode ();\n  longjmp (peerdied, -1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "intr": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "void\nintr (int sig _GL_UNUSED_PARAMETER)\n{\n  if (localchars)\n    {\n      intp ();\n      return;\n    }\n  setcommandmode ();\n  longjmp (toplevel, -1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "intr2": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "void\nintr2 (int sig _GL_UNUSED_PARAMETER)\n{\n  if (localchars)\n    {\n#ifdef\tKLUDGELINEMODE\n      if (kludgelinemode)\n\tsendbrk ();\n      else\n#endif\n\tsendabort ();\n      return;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "susp": {
      "start_point": [
        979,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "void\nsusp (int sig _GL_UNUSED_PARAMETER)\n{\n  if ((rlogin != _POSIX_VDISABLE) && rlogin_susp ())\n    return;\n  if (localchars)\n    sendsusp ();\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sendwin": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "void\nsendwin (int sig _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    {\n      sendnaws ();\n    }\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ayt": {
      "start_point": [
        1001,
        0
      ],
      "end_point": [
        1008,
        1
      ],
      "content": "void\nayt (int sig _GL_UNUSED_PARAMETER)\n{\n  if (connected)\n    sendayt ();\n  else\n    ayt_status ();\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sys_telnet_init": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "void\nsys_telnet_init (void)\n{\n  struct sigaction sa;\n\n  sa.sa_flags = SA_RESTART;\n  sigemptyset (&sa.sa_mask);\n\n  signal (SIGINT, intr);\n  signal (SIGQUIT, intr2);\n  signal (SIGPIPE, deadpeer);\n#ifdef\tSIGWINCH\n  sa.sa_handler = sendwin;\n  (void) sigaction (SIGWINCH, &sa, NULL);\n#endif\n#ifdef\tSIGTSTP\n  sa.sa_handler = susp;\n  (void) sigaction (SIGTSTP, &sa, NULL);\n#endif\n#ifdef\tSIGINFO\n  sa.sa_handler = ayt;\n  (void) sigaction (SIGINFO, &sa, NULL);\n#endif\n\n  setconnmode (0);\n\n  NetNonblockingIO (net, 1);\n\n#if defined TN3270\n  if (noasynchnet == 0)\n    {\t\t\t\t/* DBX can't handle! */\n      NetSigIO (net, 1);\n      NetSetPgrp (net);\n    }\n#endif /* defined(TN3270) */\n\n#if defined SO_OOBINLINE\n  if (SetSockOpt (net, SOL_SOCKET, SO_OOBINLINE, 1) == -1)\n    {\n      perror (\"SetSockOpt\");\n    }\n#endif /* defined(SO_OOBINLINE) */\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "process_rings": {
      "start_point": [
        1068,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "int\nprocess_rings (int netin, int netout, int netex, int ttyin, int ttyout,\n\t       int poll)\n{\n  register int c;\n  /* One wants to be a bit careful about setting returnValue\n   * to one, since a one implies we did some useful work,\n   * and therefore probably won't be called to block next\n   * time (TN3270 mode only).\n   */\n  int returnValue = 0;\n  static struct timeval TimeValue = { 0, 0 };\n  int nfds = 0;\n\n  if (netout)\n    {\n      FD_SET (net, &obits);\n      if (net > nfds)\n        nfds = net;\n    }\n  if (ttyout)\n    {\n      FD_SET (tout, &obits);\n      if (tout > nfds)\n        nfds = tout;\n    }\n#if defined TN3270\n  if (ttyin)\n    {\n      FD_SET (tin, &ibits);\n      if (tin > nfds)\n        nfds = tin;\n    }\n#else /* defined(TN3270) */\n  if (ttyin)\n    {\n      FD_SET (tin, &ibits);\n      if (tin > nfds)\n        nfds = tin;\n    }\n#endif /* defined(TN3270) */\n#if defined TN3270\n  if (netin)\n    {\n      FD_SET (net, &ibits);\n      if (net > nfds)\n        nfds = net;\n    }\n#else /* !defined(TN3270) */\n  if (netin)\n    {\n      FD_SET (net, &ibits);\n      if (net > nfds)\n        nfds = net;\n    }\n#endif /* !defined(TN3270) */\n  if (netex)\n    {\n      FD_SET (net, &xbits);\n      if (net > nfds)\n        nfds = net;\n    }\n  if ((c = select (nfds+1, &ibits, &obits, &xbits,\n\t\t   (poll == 0) ? (struct timeval *) 0 : &TimeValue)) < 0)\n    {\n      if (c == -1)\n\t{\n\t  /*\n\t   * we can get EINTR if we are in line mode,\n\t   * and the user does an escape (TSTP), or\n\t   * some other signal generator.\n\t   */\n\t  if (errno == EINTR)\n\t    {\n\t      return 0;\n\t    }\n#if defined TN3270\n\t  /*\n\t   * we can get EBADF if we were in transparent\n\t   * mode, and the transcom process died.\n\t   */\n\t  if (errno == EBADF)\n\t    {\n\t      /*\n\t       * zero the bits (even though kernel does it)\n\t       * to make sure we are selecting on the right\n\t       * ones.\n\t       */\n\t      FD_ZERO (&ibits);\n\t      FD_ZERO (&obits);\n\t      FD_ZERO (&xbits);\n\t      return 0;\n\t    }\n#endif /* defined(TN3270) */\n\t  /* I don't like this, does it ever happen? */\n\t  printf (\"sleep(5) from telnet, after select\\r\\n\");\n\t  sleep (5);\n\t}\n      return 0;\n    }\n\n  /*\n   * Any urgent data?\n   */\n  if (FD_ISSET (net, &xbits))\n    {\n      FD_CLR (net, &xbits);\n      SYNCHing = 1;\n      ttyflush (1);\t\t/* flush already enqueued data */\n    }\n\n  /*\n   * Something to read from the network...\n   */\n  if (FD_ISSET (net, &ibits))\n    {\n      int canread;\n\n      FD_CLR (net, &ibits);\n      canread = ring_empty_consecutive (&netiring);\n#if !defined SO_OOBINLINE\n      /*\n       * In 4.2 (and some early 4.3) systems, the\n       * OOB indication and data handling in the kernel\n       * is such that if two separate TCP Urgent requests\n       * come in, one byte of TCP data will be overlaid.\n       * This is fatal for Telnet, but we try to live\n       * with it.\n       *\n       * In addition, in 4.2 (and...), a special protocol\n       * is needed to pick up the TCP Urgent data in\n       * the correct sequence.\n       *\n       * What we do is:  if we think we are in urgent\n       * mode, we look to see if we are \"at the mark\".\n       * If we are, we do an OOB receive.  If we run\n       * this twice, we will do the OOB receive twice,\n       * but the second will fail, since the second\n       * time we were \"at the mark\", but there wasn't\n       * any data there (the kernel doesn't reset\n       * \"at the mark\" until we do a normal read).\n       * Once we've read the OOB data, we go ahead\n       * and do normal reads.\n       *\n       * There is also another problem, which is that\n       * since the OOB byte we read doesn't put us\n       * out of OOB state, and since that byte is most\n       * likely the TELNET DM (data mark), we would\n       * stay in the TELNET SYNCH (SYNCHing) state.\n       * So, clocks to the rescue.  If we've \"just\"\n       * received a DM, then we test for the\n       * presence of OOB data when the receive OOB\n       * fails (and AFTER we did the normal mode read\n       * to clear \"at the mark\").\n       */\n      if (SYNCHing)\n\t{\n\t  int atmark;\n\t  static int bogus_oob = 0, first = 1;\n\n\t  ioctl (net, SIOCATMARK, (char *) &atmark);\n\t  if (atmark)\n\t    {\n\t      c = recv (net, netiring.supply, canread, MSG_OOB);\n\t      if ((c == -1) && (errno == EINVAL))\n\t\t{\n\t\t  c = recv (net, netiring.supply, canread, 0);\n\t\t  if (clocks.didnetreceive < clocks.gotDM)\n\t\t    {\n\t\t      SYNCHing = stilloob (net);\n\t\t    }\n\t\t}\n\t      else if (first && c > 0)\n\t\t{\n\t\t  /*\n\t\t   * Bogosity check.  Systems based on 4.2BSD\n\t\t   * do not return an error if you do a second\n\t\t   * recv(MSG_OOB).  So, we do one.  If it\n\t\t   * succeeds and returns exactly the same\n\t\t   * data, then assume that we are running\n\t\t   * on a broken system and set the bogus_oob\n\t\t   * flag.  (If the data was different, then\n\t\t   * we probably got some valid new data, so\n\t\t   * increment the count...)\n\t\t   */\n\t\t  int i;\n\t\t  i = recv (net, netiring.supply + c, canread - c, MSG_OOB);\n\t\t  if (i == c &&\n\t\t      memcmp (netiring.supply, netiring.supply + c, i) == 0)\n\t\t    {\n\t\t      bogus_oob = 1;\n\t\t      first = 0;\n\t\t    }\n\t\t  else if (i < 0)\n\t\t    {\n\t\t      bogus_oob = 0;\n\t\t      first = 0;\n\t\t    }\n\t\t  else\n\t\t    c += i;\n\t\t}\n\t      if (bogus_oob && c > 0)\n\t\t{\n\t\t  int i;\n\t\t  /*\n\t\t   * Bogosity.  We have to do the read\n\t\t   * to clear the atmark to get out of\n\t\t   * an infinate loop.\n\t\t   */\n\t\t  i = read (net, netiring.supply + c, canread - c);\n\t\t  if (i > 0)\n\t\t    c += i;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      c = recv (net, netiring.supply, canread, 0);\n\t    }\n\t}\n      else\n\t{\n\t  c = recv (net, netiring.supply, canread, 0);\n\t}\n      settimer (didnetreceive);\n#else /* !defined(SO_OOBINLINE) */\n      c = recv (net, (char *) netiring.supply, canread, 0);\n#endif /* !defined(SO_OOBINLINE) */\n      if (c < 0 && errno == EWOULDBLOCK)\n\t{\n\t  c = 0;\n\t}\n      else if (c <= 0)\n\t{\n\t  return -1;\n\t}\n      if (netdata)\n\t{\n\t  Dump ('<', netiring.supply, c);\n\t}\n      if (c)\n\tring_supplied (&netiring, c);\n      returnValue = 1;\n    }\n\n  /*\n   * Something to read from the tty...\n   */\n  if (FD_ISSET (tin, &ibits))\n    {\n      FD_CLR (tin, &ibits);\n      c = TerminalRead ((char *)ttyiring.supply,\n                        ring_empty_consecutive (&ttyiring));\n      if (c < 0 && errno == EIO)\n\tc = 0;\n      if (c < 0 && errno == EWOULDBLOCK)\n\t{\n\t  c = 0;\n\t}\n      else\n\t{\n\t  /* EOF detection for line mode!!!! */\n\t  if ((c == 0) && MODE_LOCAL_CHARS (globalmode) && isatty (tin))\n\t    {\n\t      /* must be an EOF... */\n\t      *ttyiring.supply = termEofChar;\n\t      c = 1;\n\t    }\n\t  if (c <= 0)\n\t    {\n\t      return -1;\n\t    }\n\t  if (termdata)\n\t    {\n\t      Dump ('<', ttyiring.supply, c);\n\t    }\n\t  ring_supplied (&ttyiring, c);\n\t}\n      returnValue = 1;\t\t/* did something useful */\n    }\n\n  if (FD_ISSET (net, &obits))\n    {\n      FD_CLR (net, &obits);\n      returnValue |= netflush ();\n    }\n  if (FD_ISSET (tout, &obits))\n    {\n      FD_CLR (tout, &obits);\n      returnValue |= (ttyflush (SYNCHing | flushout) > 0);\n    }\n\n  return returnValue;\n}",
      "lines": 293,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/telnet.c": {
    "init_telnet": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\ninit_telnet (void)\n{\n  env_init ();\n\n  SB_CLEAR ();\n\n  connected = In3270 = ISend = localflow = donebinarytoggle = 0;\n#if defined AUTHENTICATION || defined ENCRYPTION\n  auth_encrypt_connect (connected);\n#endif /* defined(AUTHENTICATION) || defined(ENCRYPTION)  */\n  restartany = -1;\n\n  SYNCHing = 0;\n\n  /* Don't change NetTrace */\n\n  escape = CONTROL (']');\n  rlogin = _POSIX_VDISABLE;\n#ifdef\tKLUDGELINEMODE\n  echoc = CONTROL ('E');\n#endif\n\n  flushline = 1;\n  telrcv_state = TS_DATA;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "send_do": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void\nsend_do (register int c, register int init)\n{\n  if (init)\n    {\n      if (((do_dont_resp[c] == 0) && my_state_is_do (c)) ||\n\t  my_want_state_is_do (c))\n\treturn;\n      set_my_want_state_do (c);\n      do_dont_resp[c]++;\n    }\n  NET2ADD (IAC, DO);\n  NETADD (c);\n  printoption (\"SENT\", DO, c);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "send_dont": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "void\nsend_dont (register int c, register int init)\n{\n  if (init)\n    {\n      if (((do_dont_resp[c] == 0) && my_state_is_dont (c)) ||\n\t  my_want_state_is_dont (c))\n\treturn;\n      set_my_want_state_dont (c);\n      do_dont_resp[c]++;\n    }\n  NET2ADD (IAC, DONT);\n  NETADD (c);\n  printoption (\"SENT\", DONT, c);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "send_will": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void\nsend_will (register int c, register int init)\n{\n  if (init)\n    {\n      if (((will_wont_resp[c] == 0) && my_state_is_will (c)) ||\n\t  my_want_state_is_will (c))\n\treturn;\n      set_my_want_state_will (c);\n      will_wont_resp[c]++;\n    }\n  NET2ADD (IAC, WILL);\n  NETADD (c);\n  printoption (\"SENT\", WILL, c);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "send_wont": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nsend_wont (register int c, register int init)\n{\n  if (init)\n    {\n      if (((will_wont_resp[c] == 0) && my_state_is_wont (c)) ||\n\t  my_want_state_is_wont (c))\n\treturn;\n      set_my_want_state_wont (c);\n      will_wont_resp[c]++;\n    }\n  NET2ADD (IAC, WONT);\n  NETADD (c);\n  printoption (\"SENT\", WONT, c);\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "willoption": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "void\nwilloption (int option)\n{\n  int new_state_ok = 0;\n\n  if (do_dont_resp[option])\n    {\n      --do_dont_resp[option];\n      if (do_dont_resp[option] && my_state_is_do (option))\n\t--do_dont_resp[option];\n    }\n\n  if ((do_dont_resp[option] == 0) && my_want_state_is_dont (option))\n    {\n\n      switch (option)\n\t{\n\n\tcase TELOPT_ECHO:\n#if defined TN3270\n\t  /*\n\t   * The following is a pain in the rear-end.\n\t   * Various IBM servers (some versions of Wiscnet,\n\t   * possibly Fibronics/Spartacus, and who knows who\n\t   * else) will NOT allow us to send \"DO SGA\" too early\n\t   * in the setup proceedings.  On the other hand,\n\t   * 4.2 servers (telnetd) won't set SGA correctly.\n\t   * So, we are stuck.  Empirically (but, based on\n\t   * a VERY small sample), the IBM servers don't send\n\t   * out anything about ECHO, so we postpone our sending\n\t   * \"DO SGA\" until we see \"WILL ECHO\" (which 4.2 servers\n\t   * DO send).\n\t   */\n\t  {\n\t    if (askedSGA == 0)\n\t      {\n\t\taskedSGA = 1;\n\t\tif (my_want_state_is_dont (TELOPT_SGA))\n\t\t  send_do (TELOPT_SGA, 1);\n\t      }\n\t  }\n\t  /* Fall through */\n\tcase TELOPT_EOR:\n#endif /* defined(TN3270) */\n\tcase TELOPT_BINARY:\n\tcase TELOPT_SGA:\n\t  settimer (modenegotiated);\n\t  /* FALL THROUGH */\n\tcase TELOPT_STATUS:\n#if defined AUTHENTICATION\n\tcase TELOPT_AUTHENTICATION:\n#endif\n#ifdef\tENCRYPTION\n\tcase TELOPT_ENCRYPT:\n#endif /* ENCRYPTION */\n\t  new_state_ok = 1;\n\t  break;\n\n\tcase TELOPT_TM:\n\t  if (flushout)\n\t    flushout = 0;\n\t  /*\n\t   * Special case for TM.  If we get back a WILL,\n\t   * pretend we got back a WONT.\n\t   */\n\t  set_my_want_state_dont (option);\n\t  set_my_state_dont (option);\n\t  return;\t\t/* Never reply to TM will's/wont's */\n\n\tcase TELOPT_LINEMODE:\n\tdefault:\n\t  break;\n\t}\n\n      if (new_state_ok)\n\t{\n\t  set_my_want_state_do (option);\n\t  send_do (option, 0);\n\t  setconnmode (0);\t/* possibly set new tty mode */\n\t}\n      else\n\t{\n\t  do_dont_resp[option]++;\n\t  send_dont (option, 0);\n\t}\n    }\n  set_my_state_do (option);\n#ifdef\tENCRYPTION\n  if (option == TELOPT_ENCRYPT)\n    encrypt_send_support ();\n#endif /* ENCRYPTION */\n}",
      "lines": 92,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "wontoption": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "void\nwontoption (int option)\n{\n  if (do_dont_resp[option])\n    {\n      --do_dont_resp[option];\n      if (do_dont_resp[option] && my_state_is_dont (option))\n\t--do_dont_resp[option];\n    }\n\n  if ((do_dont_resp[option] == 0) && my_want_state_is_do (option))\n    {\n\n      switch (option)\n\t{\n\n#ifdef\tKLUDGELINEMODE\n\tcase TELOPT_SGA:\n\t  if (!kludgelinemode)\n\t    break;\n\t  /* FALL THROUGH */\n#endif\n\tcase TELOPT_ECHO:\n\t  settimer (modenegotiated);\n\t  break;\n\n\tcase TELOPT_TM:\n\t  if (flushout)\n\t    flushout = 0;\n\t  set_my_want_state_dont (option);\n\t  set_my_state_dont (option);\n\t  return;\t\t/* Never reply to TM will's/wont's */\n\n\tdefault:\n\t  break;\n\t}\n      set_my_want_state_dont (option);\n      if (my_state_is_do (option))\n\tsend_dont (option, 0);\n      setconnmode (0);\t\t/* Set new tty mode */\n    }\n  else if (option == TELOPT_TM)\n    {\n      /*\n       * Special case for TM.\n       */\n      if (flushout)\n\tflushout = 0;\n      set_my_want_state_dont (option);\n    }\n  set_my_state_dont (option);\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dooption": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "static void\ndooption (int option)\n{\n  int new_state_ok = 0;\n\n  if (will_wont_resp[option])\n    {\n      --will_wont_resp[option];\n      if (will_wont_resp[option] && my_state_is_will (option))\n\t--will_wont_resp[option];\n    }\n\n  if (will_wont_resp[option] == 0)\n    {\n      if (my_want_state_is_wont (option))\n\t{\n\n\t  switch (option)\n\t    {\n\n\t    case TELOPT_TM:\n\t      /*\n\t       * Special case for TM.  We send a WILL, but pretend\n\t       * we sent WONT.\n\t       */\n\t      send_will (option, 0);\n\t      set_my_want_state_wont (TELOPT_TM);\n\t      set_my_state_wont (TELOPT_TM);\n\t      return;\n\n#if defined TN3270\n\t    case TELOPT_EOR:\t/* end of record */\n#endif /* defined(TN3270) */\n\t    case TELOPT_BINARY:\t/* binary mode */\n\t    case TELOPT_NAWS:\t/* window size */\n\t    case TELOPT_TSPEED:\t/* terminal speed */\n\t    case TELOPT_LFLOW:\t/* local flow control */\n\t    case TELOPT_TTYPE:\t/* terminal type option */\n\t    case TELOPT_SGA:\t/* no big deal */\n#ifdef\tENCRYPTION\n\t    case TELOPT_ENCRYPT:\t/* encryption variable option */\n#endif /* ENCRYPTION */\n\t      new_state_ok = 1;\n\t      break;\n\n\t    case TELOPT_NEW_ENVIRON:\t/* New environment variable option */\n#ifdef\tOLD_ENVIRON\n\t      if (my_state_is_will (TELOPT_OLD_ENVIRON))\n\t\tsend_wont (TELOPT_OLD_ENVIRON, 1);\t/* turn off the old */\n\t      goto env_common;\n\t    case TELOPT_OLD_ENVIRON:\t/* Old environment variable option */\n\t      if (my_state_is_will (TELOPT_NEW_ENVIRON))\n\t\tbreak;\t\t/* Don't enable if new one is in use! */\n\t    env_common:\n\t      telopt_environ = option;\n#endif\n\t      new_state_ok = 1;\n\t      break;\n\n#if defined AUTHENTICATION\n\t    case TELOPT_AUTHENTICATION:\n\t      if (autologin)\n\t\tnew_state_ok = 1;\n\t      break;\n#endif\n\n\t    case TELOPT_XDISPLOC:\t/* X Display location */\n\t      if (env_getvalue (\"DISPLAY\"))\n\t\tnew_state_ok = 1;\n\t      break;\n\n\t    case TELOPT_LINEMODE:\n#ifdef\tKLUDGELINEMODE\n\t      kludgelinemode = 0;\n\t      send_do (TELOPT_SGA, 1);\n#endif\n\t      set_my_want_state_will (TELOPT_LINEMODE);\n\t      send_will (option, 0);\n\t      set_my_state_will (TELOPT_LINEMODE);\n\t      slc_init ();\n\t      return;\n\n\t    case TELOPT_ECHO:\t/* We're never going to echo... */\n\t    default:\n\t      break;\n\t    }\n\n\t  if (new_state_ok)\n\t    {\n\t      set_my_want_state_will (option);\n\t      send_will (option, 0);\n\t      setconnmode (0);\t/* Set new tty mode */\n\t    }\n\t  else\n\t    {\n\t      will_wont_resp[option]++;\n\t      send_wont (option, 0);\n\t    }\n\t}\n      else\n\t{\n\t  /*\n\t   * Handle options that need more things done after the\n\t   * other side has acknowledged the option.\n\t   */\n\t  switch (option)\n\t    {\n\t    case TELOPT_LINEMODE:\n#ifdef\tKLUDGELINEMODE\n\t      kludgelinemode = 0;\n\t      send_do (TELOPT_SGA, 1);\n#endif\n\t      set_my_state_will (option);\n\t      slc_init ();\n\t      send_do (TELOPT_SGA, 0);\n\t      return;\n\t    }\n\t}\n    }\n  set_my_state_will (option);\n}",
      "lines": 121,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dontoption": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "static void\ndontoption (int option)\n{\n\n  if (will_wont_resp[option])\n    {\n      --will_wont_resp[option];\n      if (will_wont_resp[option] && my_state_is_wont (option))\n\t--will_wont_resp[option];\n    }\n\n  if ((will_wont_resp[option] == 0) && my_want_state_is_will (option))\n    {\n      switch (option)\n\t{\n\tcase TELOPT_LINEMODE:\n\t  linemode = 0;\t\t/* put us back to the default state */\n\t  break;\n#ifdef\tOLD_ENVIRON\n\tcase TELOPT_NEW_ENVIRON:\n\t  /*\n\t   * The new environ option wasn't recognized, try\n\t   * the old one.\n\t   */\n\t  send_will (TELOPT_OLD_ENVIRON, 1);\n\t  telopt_environ = TELOPT_OLD_ENVIRON;\n\t  break;\n#endif\n\t}\n      /* we always accept a DONT */\n      set_my_want_state_wont (option);\n      if (my_state_is_will (option))\n\tsend_wont (option, 0);\n      setconnmode (0);\t\t/* Set new tty mode */\n    }\n  set_my_state_wont (option);\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_unique": {
      "start_point": [
        591,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "int\nis_unique (register char *name, register char **as, register char **ae)\n{\n  register char **ap;\n  register int n;\n\n  n = strlen (name) + 1;\n  for (ap = as; ap < ae; ap++)\n    if (strncasecmp (*ap, name, n) == 0)\n      return (0);\n  return (1);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mklist": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        751,
        1
      ],
      "content": "char **\nmklist (char *buf, char *name)\n{\n  register int n;\n  register char c, *cp, **argvp, *cp2, **argv, **avt;\n\n  if (name)\n    {\n      if ((int) strlen (name) > 40)\n\t{\n\t  name = 0;\n\t  unknown[0] = name_unknown;\n\t}\n      else\n\t{\n\t  unknown[0] = name;\n\t  upcase (name);\n\t}\n    }\n  else\n    unknown[0] = name_unknown;\n\n  /*\n   * An empty capability buffer finishes the analysis.\n   */\n  if (!buf || !*buf)\n    return (unknown);\n\n  /*\n   * Count the number of alias names.\n   * Stop at the first field separator, a colon.\n   */\n  for (n = 1, cp = buf; *cp && *cp != ':'; cp++)\n    {\n      if (*cp == '|')\n\tn++;\n    }\n\n  /*\n   * Allocate an array to hold the name pointers.\n   */\n  argv = (char **) malloc ((n + 3) * sizeof (char *));\n  if (argv == 0)\n    return (unknown);\n\n  /*\n   * Fill the array of pointers with the established aliases.\n   * Reserve the first slot for the preferred name.\n   */\n  argvp = argv + 1;\n  *argv = *argvp = 0;\n  n = 0;\t\t/* Positive: name uses white space.  */\n\n  for (cp = cp2 = buf; (c = *cp); cp++)\n    {\n      if (c == '|' || c == ':')\t\t/* Delimiters */\n\t{\n\t  *cp++ = '\\0';\n\t  /*\n\t   * Skip entries that have spaces or are over 40\n\t   * characters long.  If this is our environment\n\t   * name, then put it up front.  Otherwise, as\n\t   * long as this is not a duplicate name (case\n\t   * insensitive) add it to the list.\n\t   */\n\t  if (n || (cp - cp2 > 41))\n\t    ;\t\t\t/* Ignore the just scanned name.  */\n\t  else if (name && (strncasecmp (name, cp2, cp - cp2) == 0))\n\t    *argv = cp2;\t/* Preferred name, exact match.  */\n\t  else if (is_unique (cp2, argv + 1, argvp))\n\t    {\n\t      *argvp++ = cp2;\n\t      *argvp = 0;\t/* Prevent looking forward.  */\n\t    }\n\n\t  /* Abort parsing at first field delimiter.  */\n\t  if (c == ':')\n\t    break;\n\n\t  /*\n\t   * Skip multiple delimiters. Reset CP2 to\n\t   * the beginning of the next name. Reset N,\n\t   * the flag for names with spaces.\n\t   */\n\t  while ((c = *cp) == '|')\n\t    cp++;\n\n\t  cp2 = cp;\t\t/* Proceed to next alias name.  */\n\t  n = 0;\n\t}\n      /*\n       * Skip entries with spaces or non-ascii values.\n       * Convert lower case letters to upper case.\n       */\n      if ((c == ' ') || !isascii (c))\n\tn = 1;\n      else if (islower (c))\n\t*cp = toupper (c);\n    }\n\n  /*\n   * Check for an old V6 2 character name.  If the second\n   * name points to the beginning of the buffer, and is\n   * only 2 characters long, move it to the end of the array.\n   */\n  if ((argv[1] == buf) && (strlen (argv[1]) == 2))\n    {\n      --argvp;\n      for (avt = &argv[1]; avt < argvp; avt++)\n\t*avt = *(avt + 1);\n      *argvp++ = buf;\n    }\n\n  /*\n   * Duplicate last name, for TTYPE option, and null\n   * terminate the array.  If we didn't find a match on\n   * our terminal name, put that name at the beginning.\n   */\n  cp = *(argvp - 1);\n  *argvp++ = cp;\n  *argvp = 0;\n\n  if (*argv == 0)\n    {\n      if (name)\n\t*argv = name;\n      else\n\t{\n\t  --argvp;\n\t  for (avt = argv; avt < argvp; avt++)\n\t    *avt = *(avt + 1);\n\t}\n    }\n  if (*argv)\n    return (argv);\n  else\n    return (unknown);\n}",
      "lines": 138,
      "depth": 16,
      "decorators": [
        "char",
        "**\nmklist (char *buf, char *name)",
        "*",
        "*\nmklist (char *buf, char *name)",
        "*"
      ]
    },
    "init_term": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        778,
        1
      ],
      "content": "static int\ninit_term (char *tname, int *errp)\n{\n  int err = -1;\n\n#ifdef HAVE_TGETENT\n  err = tgetent (termbuf, tname);\n  if (err == 1)\n    {\n      termbuf[sizeof (termbuf) - 1] = '\\0';\n      if (errp)\n\t*errp = 1;\n      return (0);\n    }\n#endif /* HAVE_TGETENT */\n  if (errp)\n    *errp = 0;\n  return (-1);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gettermname": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "char *\ngettermname (void)\n{\n  char *tname;\n  static char **tnamep = 0;\n  static char **next;\n  int err;\n\n  if (resettermname)\n    {\n      resettermname = 0;\n      if (tnamep && tnamep != unknown)\n\tfree (tnamep);\n      if ((tname = (char *) env_getvalue (\"TERM\")) &&\n\t  (init_term (tname, &err) == 0))\n\t{\n\t  tnamep = mklist (termbuf, tname);\n\t}\n      else\n\t{\n\t  if (tname && ((int) strlen (tname) <= 40))\n\t    {\n\t      unknown[0] = tname;\n\t      upcase (tname);\n\t    }\n\t  else\n\t    unknown[0] = name_unknown;\n\t  tnamep = unknown;\n\t}\n      next = tnamep;\n    }\n  if (*next == 0)\n    next = tnamep;\n  return (*next++);\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "char",
        "*\ngettermname (void)",
        "*"
      ]
    },
    "suboption": {
      "start_point": [
        832,
        0
      ],
      "end_point": [
        1114,
        1
      ],
      "content": "static void\nsuboption (void)\n{\n  unsigned char subchar;\n\n  printsub ('<', subbuffer, SB_LEN () + 2);\n  switch (subchar = SB_GET ())\n    {\n    case TELOPT_TTYPE:\n      if (my_want_state_is_wont (TELOPT_TTYPE))\n\treturn;\n      if (SB_EOF () || SB_GET () != TELQUAL_SEND)\n\t{\n\t  return;\n\t}\n      else\n\t{\n\t  char *name;\n\t  unsigned char temp[50];\n\t  int len;\n\n#if defined TN3270\n\t  if (tn3270_ttype ())\n\t    {\n\t      return;\n\t    }\n#endif /* defined(TN3270) */\n\t  name = gettermname ();\n\t  len = strlen (name) + 4 + 2;\n\t  if (len < NETROOM ())\n\t    {\n\t      sprintf ((char *) temp, \"%c%c%c%c%s%c%c\", IAC, SB, TELOPT_TTYPE,\n\t\t       TELQUAL_IS, name, IAC, SE);\n\t      ring_supply_data (&netoring, temp, len);\n\t      printsub ('>', &temp[2], len - 2);\n\t    }\n\t  else\n\t    {\n\t      ExitString (\"No room in buffer for terminal type.\\n\", 1);\n\t    }\n\t}\n      break;\n    case TELOPT_TSPEED:\n      if (my_want_state_is_wont (TELOPT_TSPEED))\n\treturn;\n      if (SB_EOF ())\n\treturn;\n      if (SB_GET () == TELQUAL_SEND)\n\t{\n\t  long ospeed, ispeed;\n\t  unsigned char temp[50];\n\t  int len;\n\n\t  TerminalSpeeds (&ispeed, &ospeed);\n\n\t  sprintf ((char *) temp, \"%c%c%c%c%d,%d%c%c\", IAC, SB, TELOPT_TSPEED,\n\t\t   TELQUAL_IS, (int) ospeed, (int) ispeed, IAC, SE);\n\t  len = strlen ((char *) temp + 4) + 4;\t/* temp[3] is 0 ... */\n\n\t  if (len < NETROOM ())\n\t    {\n\t      ring_supply_data (&netoring, temp, len);\n\t      printsub ('>', temp + 2, len - 2);\n\t    }\n/*@*/\n\t  else\n\t    printf (\"lm_will: not enough room in buffer\\n\");\n\t}\n      break;\n    case TELOPT_LFLOW:\n      if (my_want_state_is_wont (TELOPT_LFLOW))\n\treturn;\n      if (SB_EOF ())\n\treturn;\n      switch (SB_GET ())\n\t{\n\tcase LFLOW_RESTART_ANY:\n\t  restartany = 1;\n\t  break;\n\tcase LFLOW_RESTART_XON:\n\t  restartany = 0;\n\t  break;\n\tcase LFLOW_ON:\n\t  localflow = 1;\n\t  break;\n\tcase LFLOW_OFF:\n\t  localflow = 0;\n\t  break;\n\tdefault:\n\t  return;\n\t}\n      setcommandmode ();\n      setconnmode (0);\n      break;\n\n    case TELOPT_LINEMODE:\n      if (my_want_state_is_wont (TELOPT_LINEMODE))\n\treturn;\n      if (SB_EOF ())\n\treturn;\n      switch (SB_GET ())\n\t{\n\tcase WILL:\n\t  lm_will (subpointer, SB_LEN ());\n\t  break;\n\tcase WONT:\n\t  lm_wont (subpointer, SB_LEN ());\n\t  break;\n\tcase DO:\n\t  lm_do (subpointer, SB_LEN ());\n\t  break;\n\tcase DONT:\n\t  lm_dont (subpointer, SB_LEN ());\n\t  break;\n\tcase LM_SLC:\n\t  slc (subpointer, SB_LEN ());\n\t  break;\n\tcase LM_MODE:\n\t  lm_mode (subpointer, SB_LEN (), 0);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      break;\n\n#ifdef\tOLD_ENVIRON\n    case TELOPT_OLD_ENVIRON:\n#endif\n    case TELOPT_NEW_ENVIRON:\n      if (SB_EOF ())\n\treturn;\n      switch (SB_PEEK ())\n\t{\n\tcase TELQUAL_IS:\n\tcase TELQUAL_INFO:\n\t  if (my_want_state_is_dont (subchar))\n\t    return;\n\t  break;\n\tcase TELQUAL_SEND:\n\t  if (my_want_state_is_wont (subchar))\n\t    {\n\t      return;\n\t    }\n\t  break;\n\tdefault:\n\t  return;\n\t}\n      env_opt (subpointer, SB_LEN ());\n      break;\n\n    case TELOPT_XDISPLOC:\n      if (my_want_state_is_wont (TELOPT_XDISPLOC))\n\treturn;\n      if (SB_EOF ())\n\treturn;\n      if (SB_GET () == TELQUAL_SEND)\n\t{\n\t  unsigned char temp[50], *dp;\n\t  int len;\n\n\t  if ((dp = env_getvalue (\"DISPLAY\")) == NULL)\n\t    {\n\t      /*\n\t       * Something happened, we no longer have a DISPLAY\n\t       * variable.  So, turn off the option.\n\t       */\n\t      send_wont (TELOPT_XDISPLOC, 1);\n\t      break;\n\t    }\n\t  sprintf ((char *) temp, \"%c%c%c%c%s%c%c\", IAC, SB, TELOPT_XDISPLOC,\n\t\t   TELQUAL_IS, dp, IAC, SE);\n\t  len = strlen ((char *) temp + 4) + 4;\t/* temp[3] is 0 ... */\n\n\t  if (len < NETROOM ())\n\t    {\n\t      ring_supply_data (&netoring, temp, len);\n\t      printsub ('>', temp + 2, len - 2);\n\t    }\n/*@*/\n\t  else\n\t    printf (\"lm_will: not enough room in buffer\\n\");\n\t}\n      break;\n\n#if defined AUTHENTICATION\n    case TELOPT_AUTHENTICATION:\n      {\n\tif (!autologin)\n\t  break;\n\tif (SB_EOF ())\n\t  return;\n\tswitch (SB_GET ())\n\t  {\n\t  case TELQUAL_IS:\n\t    if (my_want_state_is_dont (TELOPT_AUTHENTICATION))\n\t      return;\n\t    auth_is (subpointer, SB_LEN ());\n\t    break;\n\t  case TELQUAL_SEND:\n\t    if (my_want_state_is_wont (TELOPT_AUTHENTICATION))\n\t      return;\n\t    auth_send (subpointer, SB_LEN ());\n\t    break;\n\t  case TELQUAL_REPLY:\n\t    if (my_want_state_is_wont (TELOPT_AUTHENTICATION))\n\t      return;\n\t    auth_reply (subpointer, SB_LEN ());\n\t    break;\n\t  case TELQUAL_NAME:\n\t    if (my_want_state_is_dont (TELOPT_AUTHENTICATION))\n\t      return;\n\t    auth_name (subpointer, SB_LEN ());\n\t    break;\n\t  }\n      }\n      break;\n#endif\n#ifdef\tENCRYPTION\n    case TELOPT_ENCRYPT:\n      if (SB_EOF ())\n\treturn;\n      switch (SB_GET ())\n\t{\n\tcase ENCRYPT_START:\n\t  if (my_want_state_is_dont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_start (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_END:\n\t  if (my_want_state_is_dont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_end ();\n\t  break;\n\tcase ENCRYPT_SUPPORT:\n\t  if (my_want_state_is_wont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_support (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_REQSTART:\n\t  if (my_want_state_is_wont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_request_start (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_REQEND:\n\t  if (my_want_state_is_wont (TELOPT_ENCRYPT))\n\t    return;\n\t  /*\n\t   * We can always send an REQEND so that we cannot\n\t   * get stuck encrypting.  We should only get this\n\t   * if we have been able to get in the correct mode\n\t   * anyhow.\n\t   */\n\t  encrypt_request_end ();\n\t  break;\n\tcase ENCRYPT_IS:\n\t  if (my_want_state_is_dont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_is (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_REPLY:\n\t  if (my_want_state_is_wont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_reply (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_ENC_KEYID:\n\t  if (my_want_state_is_dont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_enc_keyid (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_DEC_KEYID:\n\t  if (my_want_state_is_wont (TELOPT_ENCRYPT))\n\t    return;\n\t  encrypt_dec_keyid (subpointer, SB_LEN ());\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      break;\n#endif /* ENCRYPTION */\n    default:\n      break;\n    }\n}",
      "lines": 283,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lm_will": {
      "start_point": [
        1118,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "void\nlm_will (unsigned char *cmd, int len)\n{\n  if (len < 1)\n    {\n      /*@ */ printf (\"lm_will: no command!!!\\n\");\n      /* Should not happen... */\n      return;\n    }\n  switch (cmd[0])\n    {\n    case LM_FORWARDMASK:\t/* We shouldn't ever get this... */\n    default:\n      str_lm[3] = DONT;\n      str_lm[4] = cmd[0];\n      if (NETROOM () > (int) sizeof (str_lm))\n\t{\n\t  ring_supply_data (&netoring, str_lm, sizeof (str_lm));\n\t  printsub ('>', &str_lm[2], sizeof (str_lm) - 2);\n\t}\n/*@*/\n      else\n\tprintf (\"lm_will: not enough room in buffer\\n\");\n      break;\n    }\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "lm_wont": {
      "start_point": [
        1145,
        0
      ],
      "end_point": [
        1161,
        1
      ],
      "content": "void\nlm_wont (unsigned char *cmd, int len)\n{\n  if (len < 1)\n    {\n      /*@ */ printf (\"lm_wont: no command!!!\\n\");\n      /* Should not happen... */\n      return;\n    }\n  switch (cmd[0])\n    {\n    case LM_FORWARDMASK:\t/* We shouldn't ever get this... */\n    default:\n      /* We are always DONT, so don't respond */\n      return;\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lm_do": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1188,
        1
      ],
      "content": "void\nlm_do (unsigned char *cmd, int len)\n{\n  if (len < 1)\n    {\n      /*@ */ printf (\"lm_do: no command!!!\\n\");\n      /* Should not happen... */\n      return;\n    }\n  switch (cmd[0])\n    {\n    case LM_FORWARDMASK:\n    default:\n      str_lm[3] = WONT;\n      str_lm[4] = cmd[0];\n      if (NETROOM () > (int) sizeof (str_lm))\n\t{\n\t  ring_supply_data (&netoring, str_lm, sizeof (str_lm));\n\t  printsub ('>', &str_lm[2], sizeof (str_lm) - 2);\n\t}\n/*@*/\n      else\n\tprintf (\"lm_do: not enough room in buffer\\n\");\n      break;\n    }\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "lm_dont": {
      "start_point": [
        1190,
        0
      ],
      "end_point": [
        1206,
        1
      ],
      "content": "void\nlm_dont (unsigned char *cmd, int len)\n{\n  if (len < 1)\n    {\n      /*@ */ printf (\"lm_dont: no command!!!\\n\");\n      /* Should not happen... */\n      return;\n    }\n  switch (cmd[0])\n    {\n    case LM_FORWARDMASK:\n    default:\n      /* we are always WONT, so don't respond */\n      break;\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lm_mode": {
      "start_point": [
        1212,
        0
      ],
      "end_point": [
        1234,
        1
      ],
      "content": "void\nlm_mode (unsigned char *cmd, int len, int init)\n{\n  if (len != 1)\n    return;\n  if ((linemode & MODE_MASK & ~MODE_ACK) == *cmd)\n    return;\n  if (*cmd & MODE_ACK)\n    return;\n  linemode = *cmd & (MODE_MASK & ~MODE_ACK);\n  str_lm_mode[4] = linemode;\n  if (!init)\n    str_lm_mode[4] |= MODE_ACK;\n  if (NETROOM () > (int) sizeof (str_lm_mode))\n    {\n      ring_supply_data (&netoring, str_lm_mode, sizeof (str_lm_mode));\n      printsub ('>', &str_lm_mode[2], sizeof (str_lm_mode) - 2);\n    }\n/*@*/\n  else\n    printf (\"lm_mode: not enough room in buffer\\n\");\n  setconnmode (0);\t\t/* set changed mode */\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "slc_init": {
      "start_point": [
        1256,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "void\nslc_init (void)\n{\n  register struct spc *spcp;\n\n  localchars = 1;\n  for (spcp = spc_data; spcp < &spc_data[NSLC + 1]; spcp++)\n    {\n      spcp->val = 0;\n      spcp->valp = 0;\n      spcp->flags = spcp->mylevel = SLC_NOSUPPORT;\n    }\n\n#define initfunc(func, flags) { \\\n\t\t\t\t\tspcp = &spc_data[func]; \\\n\t\t\t\t\tif ((spcp->valp = tcval(func))) { \\\n\t\t\t\t\t    spcp->val = *spcp->valp; \\\n\t\t\t\t\t    spcp->mylevel = SLC_VARIABLE|flags; \\\n\t\t\t\t\t} else { \\\n\t\t\t\t\t    spcp->val = 0; \\\n\t\t\t\t\t    spcp->mylevel = SLC_DEFAULT; \\\n\t\t\t\t\t} \\\n\t\t\t\t    }\n\n  initfunc (SLC_SYNCH, 0);\n  /* No BRK */\n  initfunc (SLC_AO, 0);\n  initfunc (SLC_AYT, 0);\n  /* No EOR */\n  initfunc (SLC_ABORT, SLC_FLUSHIN | SLC_FLUSHOUT);\n  initfunc (SLC_EOF, 0);\n#ifndef SYSV_TERMIO\n  initfunc (SLC_SUSP, SLC_FLUSHIN);\n#endif\n  initfunc (SLC_EC, 0);\n  initfunc (SLC_EL, 0);\n#ifndef SYSV_TERMIO\n  initfunc (SLC_EW, 0);\n  initfunc (SLC_RP, 0);\n  initfunc (SLC_LNEXT, 0);\n#endif\n  initfunc (SLC_XON, 0);\n  initfunc (SLC_XOFF, 0);\n#ifdef\tSYSV_TERMIO\n  spc_data[SLC_XON].mylevel = SLC_CANTCHANGE;\n  spc_data[SLC_XOFF].mylevel = SLC_CANTCHANGE;\n#endif\n  initfunc (SLC_FORW1, 0);\n#ifdef\tUSE_TERMIO\n  initfunc (SLC_FORW2, 0);\n  /* No FORW2 */\n#endif\n\n  initfunc (SLC_IP, SLC_FLUSHIN | SLC_FLUSHOUT);\n#undef\tinitfunc\n\n  if (slc_mode == SLC_EXPORT)\n    slc_export ();\n  else\n    slc_import (1);\n\n}",
      "lines": 62,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "slcstate": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "void\nslcstate (void)\n{\n  printf (\"Special characters are %s values\\n\",\n\t  slc_mode == SLC_IMPORT ? \"remote default\" :\n\t  slc_mode == SLC_EXPORT ? \"local\" : \"remote\");\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "slc_mode_export": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1333,
        1
      ],
      "content": "void\nslc_mode_export (void)\n{\n  slc_mode = SLC_EXPORT;\n  if (my_state_is_will (TELOPT_LINEMODE))\n    slc_export ();\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "slc_mode_import": {
      "start_point": [
        1335,
        0
      ],
      "end_point": [
        1341,
        1
      ],
      "content": "void\nslc_mode_import (int def)\n{\n  slc_mode = def ? SLC_IMPORT : SLC_RVALUE;\n  if (my_state_is_will (TELOPT_LINEMODE))\n    slc_import (def);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "slc_import": {
      "start_point": [
        1350,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "void\nslc_import (int def)\n{\n  if (NETROOM () > (int) sizeof (slc_import_val))\n    {\n      if (def)\n\t{\n\t  ring_supply_data (&netoring, slc_import_def,\n\t\t\t    sizeof (slc_import_def));\n\t  printsub ('>', &slc_import_def[2], sizeof (slc_import_def) - 2);\n\t}\n      else\n\t{\n\t  ring_supply_data (&netoring, slc_import_val,\n\t\t\t    sizeof (slc_import_val));\n\t  printsub ('>', &slc_import_val[2], sizeof (slc_import_val) - 2);\n\t}\n    }\n/*@*/\n  else\n    printf (\"slc_import: not enough room\\n\");\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "slc_export": {
      "start_point": [
        1373,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "void\nslc_export (void)\n{\n  register struct spc *spcp;\n\n  TerminalDefaultChars ();\n\n  slc_start_reply ();\n  for (spcp = &spc_data[1]; spcp < &spc_data[NSLC + 1]; spcp++)\n    {\n      if (spcp->mylevel != SLC_NOSUPPORT)\n\t{\n\t  if (spcp->val == (cc_t) (_POSIX_VDISABLE))\n\t    spcp->flags = SLC_NOSUPPORT;\n\t  else\n\t    spcp->flags = spcp->mylevel;\n\t  if (spcp->valp)\n\t    spcp->val = *spcp->valp;\n\t  slc_add_reply (spcp - spc_data, spcp->flags, spcp->val);\n\t}\n    }\n  slc_end_reply ();\n  slc_update ();\n  setconnmode (1);\t\t/* Make sure the character values are set */\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "slc": {
      "start_point": [
        1399,
        0
      ],
      "end_point": [
        1473,
        1
      ],
      "content": "void\nslc (register unsigned char *cp, int len)\n{\n  register struct spc *spcp;\n  register int func, level;\n\n  slc_start_reply ();\n\n  for (; len >= 3; len -= 3, cp += 3)\n    {\n\n      func = cp[SLC_FUNC];\n\n      if (func == 0)\n\t{\n\t  /*\n\t   * Client side: always ignore 0 function.\n\t   */\n\t  continue;\n\t}\n      if (func > NSLC)\n\t{\n\t  if ((cp[SLC_FLAGS] & SLC_LEVELBITS) != SLC_NOSUPPORT)\n\t    slc_add_reply (func, SLC_NOSUPPORT, 0);\n\t  continue;\n\t}\n\n      spcp = &spc_data[func];\n\n      level = cp[SLC_FLAGS] & (SLC_LEVELBITS | SLC_ACK);\n\n      if ((cp[SLC_VALUE] == (unsigned char) spcp->val) &&\n\t  ((level & SLC_LEVELBITS) == (spcp->flags & SLC_LEVELBITS)))\n\t{\n\t  continue;\n\t}\n\n      if (level == (SLC_DEFAULT | SLC_ACK))\n\t{\n\t  /*\n\t   * This is an error condition, the SLC_ACK\n\t   * bit should never be set for the SLC_DEFAULT\n\t   * level.  Our best guess to recover is to\n\t   * ignore the SLC_ACK bit.\n\t   */\n\t  cp[SLC_FLAGS] &= ~SLC_ACK;\n\t}\n\n      if (level == ((spcp->flags & SLC_LEVELBITS) | SLC_ACK))\n\t{\n\t  spcp->val = (cc_t) cp[SLC_VALUE];\n\t  spcp->flags = cp[SLC_FLAGS];\t/* include SLC_ACK */\n\t  continue;\n\t}\n\n      level &= ~SLC_ACK;\n\n      if (level <= (spcp->mylevel & SLC_LEVELBITS))\n\t{\n\t  spcp->flags = cp[SLC_FLAGS] | SLC_ACK;\n\t  spcp->val = (cc_t) cp[SLC_VALUE];\n\t}\n      if (level == SLC_DEFAULT)\n\t{\n\t  if ((spcp->mylevel & SLC_LEVELBITS) != SLC_DEFAULT)\n\t    spcp->flags = spcp->mylevel;\n\t  else\n\t    spcp->flags = SLC_NOSUPPORT;\n\t}\n      slc_add_reply (func, spcp->flags, spcp->val);\n    }\n  slc_end_reply ();\n  if (slc_update ())\n    setconnmode (1);\t\t/* set the  new character values */\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "slc_check": {
      "start_point": [
        1475,
        0
      ],
      "end_point": [
        1495,
        1
      ],
      "content": "void\nslc_check (void)\n{\n  register struct spc *spcp;\n\n  slc_start_reply ();\n  for (spcp = &spc_data[1]; spcp < &spc_data[NSLC + 1]; spcp++)\n    {\n      if (spcp->valp && spcp->val != *spcp->valp)\n\t{\n\t  spcp->val = *spcp->valp;\n\t  if (spcp->val == (cc_t) (_POSIX_VDISABLE))\n\t    spcp->flags = SLC_NOSUPPORT;\n\t  else\n\t    spcp->flags = spcp->mylevel;\n\t  slc_add_reply (spcp - spc_data, spcp->flags, spcp->val);\n\t}\n    }\n  slc_end_reply ();\n  setconnmode (1);\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "slc_start_reply": {
      "start_point": [
        1501,
        0
      ],
      "end_point": [
        1509,
        1
      ],
      "content": "void\nslc_start_reply (void)\n{\n  slc_replyp = slc_reply;\n  *slc_replyp++ = IAC;\n  *slc_replyp++ = SB;\n  *slc_replyp++ = TELOPT_LINEMODE;\n  *slc_replyp++ = LM_SLC;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "slc_add_reply": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1520,
        1
      ],
      "content": "void\nslc_add_reply (unsigned char func, unsigned char flags, cc_t value)\n{\n  if ((*slc_replyp++ = func) == IAC)\n    *slc_replyp++ = IAC;\n  if ((*slc_replyp++ = flags) == IAC)\n    *slc_replyp++ = IAC;\n  if ((*slc_replyp++ = (unsigned char) value) == IAC)\n    *slc_replyp++ = IAC;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "slc_end_reply": {
      "start_point": [
        1522,
        0
      ],
      "end_point": [
        1540,
        1
      ],
      "content": "void\nslc_end_reply (void)\n{\n  register int len;\n\n  *slc_replyp++ = IAC;\n  *slc_replyp++ = SE;\n  len = slc_replyp - slc_reply;\n  if (len <= 6)\n    return;\n  if (NETROOM () > len)\n    {\n      ring_supply_data (&netoring, slc_reply, slc_replyp - slc_reply);\n      printsub ('>', &slc_reply[2], slc_replyp - slc_reply - 2);\n    }\n/*@*/\n  else\n    printf (\"slc_end_reply: not enough room\\n\");\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "slc_update": {
      "start_point": [
        1542,
        0
      ],
      "end_point": [
        1560,
        1
      ],
      "content": "int\nslc_update (void)\n{\n  register struct spc *spcp;\n  int need_update = 0;\n\n  for (spcp = &spc_data[1]; spcp < &spc_data[NSLC + 1]; spcp++)\n    {\n      if (!(spcp->flags & SLC_ACK))\n\tcontinue;\n      spcp->flags &= ~SLC_ACK;\n      if (spcp->valp && (*spcp->valp != spcp->val))\n\t{\n\t  *spcp->valp = spcp->val;\n\t  need_update = 1;\n\t}\n    }\n  return (need_update);\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "env_opt": {
      "start_point": [
        1582,
        0
      ],
      "end_point": [
        1655,
        1
      ],
      "content": "void\nenv_opt (register unsigned char *buf, register int len)\n{\n  register unsigned char *ep = 0, *epc = 0;\n  register int i;\n\n  switch (buf[0] & 0xff)\n    {\n    case TELQUAL_SEND:\n      env_opt_start ();\n      if (len == 1)\n\t{\n\t  env_opt_add (NULL);\n\t}\n      else\n\tfor (i = 1; i < len; i++)\n\t  {\n\t    switch (buf[i] & 0xff)\n\t      {\n#ifdef\tOLD_ENVIRON\n\t      case OLD_ENV_VAR:\n# ifdef\tENV_HACK\n\t\tif (telopt_environ == TELOPT_OLD_ENVIRON && env_auto)\n\t\t  {\n\t\t    /* Server has the same definitions */\n\t\t    old_env_var = OLD_ENV_VAR;\n\t\t    old_env_value = OLD_ENV_VALUE;\n\t\t  }\n\t\t/* FALL THROUGH */\n# endif\n\t      case OLD_ENV_VALUE:\n\t\t/*\n\t\t * Although OLD_ENV_VALUE is not legal, we will\n\t\t * still recognize it, just in case it is an\n\t\t * old server that has VAR & VALUE mixed up...\n\t\t */\n\t\t/* FALL THROUGH */\n#else\n\t      case NEW_ENV_VAR:\n#endif\n\t      case ENV_USERVAR:\n\t\tif (ep)\n\t\t  {\n\t\t    *epc = 0;\n\t\t    env_opt_add (ep);\n\t\t  }\n\t\tep = epc = &buf[i + 1];\n\t\tbreak;\n\t      case ENV_ESC:\n\t\ti++;\n\t\t/*FALL THROUGH */\n\t      default:\n\t\tif (epc)\n\t\t  *epc++ = buf[i];\n\t\tbreak;\n\t      }\n\t  }\n      if (ep)\n\t{\n\t  *epc = 0;\n\t  env_opt_add (ep);\n\t}\n      env_opt_end (1);\n      break;\n\n    case TELQUAL_IS:\n    case TELQUAL_INFO:\n      /* Ignore for now.  We shouldn't get it anyway. */\n      break;\n\n    default:\n      break;\n    }\n}",
      "lines": 74,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "env_opt_start": {
      "start_point": [
        1662,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "void\nenv_opt_start (void)\n{\n  if (opt_reply)\n    opt_reply = (unsigned char *) realloc (opt_reply, OPT_REPLY_SIZE);\n  else\n    opt_reply = (unsigned char *) malloc (OPT_REPLY_SIZE);\n  if (opt_reply == NULL)\n    {\n/*@*/ printf (\"env_opt_start: malloc()/realloc() failed!!!\\n\");\n      opt_reply = opt_replyp = opt_replyend = NULL;\n      return;\n    }\n  opt_replyp = opt_reply;\n  opt_replyend = opt_reply + OPT_REPLY_SIZE;\n  *opt_replyp++ = IAC;\n  *opt_replyp++ = SB;\n  *opt_replyp++ = telopt_environ;\n  *opt_replyp++ = TELQUAL_IS;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "env_opt_start_info": {
      "start_point": [
        1683,
        0
      ],
      "end_point": [
        1689,
        1
      ],
      "content": "void\nenv_opt_start_info (void)\n{\n  env_opt_start ();\n  if (opt_replyp)\n    opt_replyp[-1] = TELQUAL_INFO;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "env_opt_add": {
      "start_point": [
        1691,
        0
      ],
      "end_point": [
        1768,
        1
      ],
      "content": "void\nenv_opt_add (register unsigned char *ep)\n{\n  register unsigned char *vp, c;\n\n  if (opt_reply == NULL)\n     /*XXX*/ return;\n   /*XXX*/ if (ep == NULL || *ep == '\\0')\n    {\n      /* Send user defined variables first. */\n      env_default (1, 0);\n      while ((ep = env_default (0, 0)))\n\tenv_opt_add (ep);\n\n      /* Now add the list of well know variables.  */\n      env_default (1, 1);\n      while ((ep = env_default (0, 1)))\n\tenv_opt_add (ep);\n      return;\n    }\n  vp = env_getvalue ((char *)ep);\n  if (opt_replyp + (vp ? strlen ((char *) vp) : 0) +\n      strlen ((char *) ep) + 6 > opt_replyend)\n    {\n      register int len;\n      opt_replyend += OPT_REPLY_SIZE;\n      len = opt_replyend - opt_reply;\n      opt_reply = (unsigned char *) realloc (opt_reply, len);\n      if (opt_reply == NULL)\n\t{\n/*@*/ printf (\"env_opt_add: realloc() failed!!!\\n\");\n\t  opt_reply = opt_replyp = opt_replyend = NULL;\n\t  return;\n\t}\n      opt_replyp = opt_reply + len - (opt_replyend - opt_replyp);\n      opt_replyend = opt_reply + len;\n    }\n  if (opt_welldefined ((char *) ep))\n#ifdef\tOLD_ENVIRON\n    if (telopt_environ == TELOPT_OLD_ENVIRON)\n      *opt_replyp++ = old_env_var;\n    else\n#endif\n      *opt_replyp++ = NEW_ENV_VAR;\n  else\n    *opt_replyp++ = ENV_USERVAR;\n  for (;;)\n    {\n      while ((c = *ep++))\n\t{\n\t  switch (c & 0xff)\n\t    {\n\t    case IAC:\n\t      *opt_replyp++ = IAC;\n\t      break;\n\t    case NEW_ENV_VAR:\n\t    case NEW_ENV_VALUE:\n\t    case ENV_ESC:\n\t    case ENV_USERVAR:\n\t      *opt_replyp++ = ENV_ESC;\n\t      break;\n\t    }\n\t  *opt_replyp++ = c;\n\t}\n      if ((ep = vp))\n\t{\n#ifdef\tOLD_ENVIRON\n\t  if (telopt_environ == TELOPT_OLD_ENVIRON)\n\t    *opt_replyp++ = old_env_value;\n\t  else\n#endif\n\t    *opt_replyp++ = NEW_ENV_VALUE;\n\t  vp = NULL;\n\t}\n      else\n\tbreak;\n    }\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "opt_welldefined": {
      "start_point": [
        1770,
        0
      ],
      "end_point": [
        1780,
        1
      ],
      "content": "int\nopt_welldefined (char *ep)\n{\n  if ((strcmp (ep, \"USER\") == 0) ||\n      (strcmp (ep, \"DISPLAY\") == 0) ||\n      (strcmp (ep, \"PRINTER\") == 0) ||\n      (strcmp (ep, \"SYSTEMTYPE\") == 0) ||\n      (strcmp (ep, \"JOB\") == 0) || (strcmp (ep, \"ACCT\") == 0))\n    return (1);\n  return (0);\n}",
      "lines": 11,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "env_opt_end": {
      "start_point": [
        1782,
        0
      ],
      "end_point": [
        1806,
        1
      ],
      "content": "void\nenv_opt_end (register int emptyok)\n{\n  register int len;\n\n  len = opt_replyp - opt_reply + 2;\n  if (emptyok || len > 6)\n    {\n      *opt_replyp++ = IAC;\n      *opt_replyp++ = SE;\n      if (NETROOM () > len)\n\t{\n\t  ring_supply_data (&netoring, opt_reply, len);\n\t  printsub ('>', &opt_reply[2], len - 2);\n\t}\n/*@*/\n      else\n\tprintf (\"slc_end_reply: not enough room\\n\");\n    }\n  if (opt_reply)\n    {\n      free (opt_reply);\n      opt_reply = opt_replyp = opt_replyend = NULL;\n    }\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "telrcv": {
      "start_point": [
        1810,
        0
      ],
      "end_point": [
        2130,
        1
      ],
      "content": "int\ntelrcv (void)\n{\n  register int c;\n  register int scc;\n  register unsigned char *sbp;\n  int count;\n  int returnValue = 0;\n\n  scc = 0;\n  count = 0;\n  while (TTYROOM () > 2)\n    {\n      if (scc == 0)\n\t{\n\t  if (count)\n\t    {\n\t      ring_consumed (&netiring, count);\n\t      returnValue = 1;\n\t      count = 0;\n\t    }\n\t  sbp = netiring.consume;\n\t  scc = ring_full_consecutive (&netiring);\n\t  if (scc == 0)\n\t    {\n\t      /* No more data coming in */\n\t      break;\n\t    }\n\t}\n\n      c = *sbp++ & 0xff, scc--;\n      count++;\n#ifdef\tENCRYPTION\n      if (decrypt_input)\n\tc = (*decrypt_input) (c);\n#endif /* ENCRYPTION */\n\n      switch (telrcv_state)\n\t{\n\n\tcase TS_CR:\n\t  telrcv_state = TS_DATA;\n\t  if (c == '\\0')\n\t    {\n\t      break;\t\t/* Ignore \\0 after CR */\n\t    }\n\t  else if ((c == '\\n') && my_want_state_is_dont (TELOPT_ECHO)\n\t\t   && !crmod)\n\t    {\n\t      TTYADD (c);\n\t      break;\n\t    }\n\t  /* Else, fall through */\n\n\tcase TS_DATA:\n\t  if (c == IAC)\n\t    {\n\t      telrcv_state = TS_IAC;\n\t      break;\n\t    }\n#if defined TN3270\n\t  if (In3270)\n\t    {\n\t      *Ifrontp++ = c;\n\t      while (scc > 0)\n\t\t{\n\t\t  c = *sbp++ & 0377, scc--;\n\t\t  count++;\n# ifdef\tENCRYPTION\n\t\t  if (decrypt_input)\n\t\t    c = (*decrypt_input) (c);\n# endif\t/* ENCRYPTION */\n\t\t  if (c == IAC)\n\t\t    {\n\t\t      telrcv_state = TS_IAC;\n\t\t      break;\n\t\t    }\n\t\t  *Ifrontp++ = c;\n\t\t}\n\t    }\n\t  else\n#endif /* defined(TN3270) */\n\t    /*\n\t     * The 'crmod' hack (see following) is needed\n\t     * since we can't * set CRMOD on output only.\n\t     * Machines like MULTICS like to send \\r without\n\t     * \\n; since we must turn off CRMOD to get proper\n\t     * input, the mapping is done here (sigh).\n\t     */\n\t  if ((c == '\\r') && my_want_state_is_dont (TELOPT_BINARY))\n\t    {\n\t      if (scc > 0)\n\t\t{\n\t\t  c = *sbp & 0xff;\n#ifdef\tENCRYPTION\n\t\t  if (decrypt_input)\n\t\t    c = (*decrypt_input) (c);\n#endif /* ENCRYPTION */\n\t\t  if (c == 0)\n\t\t    {\n\t\t      sbp++, scc--;\n\t\t      count++;\n\t\t      /* a \"true\" CR */\n\t\t      TTYADD ('\\r');\n\t\t    }\n\t\t  else if (my_want_state_is_dont (TELOPT_ECHO) && (c == '\\n'))\n\t\t    {\n\t\t      sbp++, scc--;\n\t\t      count++;\n\t\t      TTYADD ('\\n');\n\t\t    }\n\t\t  else\n\t\t    {\n#ifdef\tENCRYPTION\n\t\t      if (decrypt_input)\n\t\t\t(*decrypt_input) (-1);\n#endif /* ENCRYPTION */\n\n\t\t      TTYADD ('\\r');\n\t\t      if (crmod)\n\t\t\t{\n\t\t\t  TTYADD ('\\n');\n\t\t\t}\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  telrcv_state = TS_CR;\n\t\t  TTYADD ('\\r');\n\t\t  if (crmod)\n\t\t    {\n\t\t      TTYADD ('\\n');\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      TTYADD (c);\n\t    }\n\t  continue;\n\n\tcase TS_IAC:\n\tprocess_iac:\n\t  switch (c)\n\t    {\n\n\t    case WILL:\n\t      telrcv_state = TS_WILL;\n\t      continue;\n\n\t    case WONT:\n\t      telrcv_state = TS_WONT;\n\t      continue;\n\n\t    case DO:\n\t      telrcv_state = TS_DO;\n\t      continue;\n\n\t    case DONT:\n\t      telrcv_state = TS_DONT;\n\t      continue;\n\n\t    case DM:\n\t      /*\n\t       * We may have missed an urgent notification,\n\t       * so make sure we flush whatever is in the\n\t       * buffer currently.\n\t       */\n\t      printoption (\"RCVD\", IAC, DM);\n\t      SYNCHing = 1;\n\t      ttyflush (1);\n\t      SYNCHing = stilloob ();\n\t      settimer (gotDM);\n\t      break;\n\n\t    case SB:\n\t      SB_CLEAR ();\n\t      telrcv_state = TS_SB;\n\t      continue;\n\n#if defined TN3270\n\t    case EOR:\n\t      if (In3270)\n\t\t{\n\t\t  if (Ibackp == Ifrontp)\n\t\t    {\n\t\t      Ibackp = Ifrontp = Ibuf;\n\t\t      ISend = 0;\t/* should have been! */\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      Ibackp += DataFromNetwork (Ibackp, Ifrontp - Ibackp, 1);\n\t\t      ISend = 1;\n\t\t    }\n\t\t}\n\t      printoption (\"RCVD\", IAC, EOR);\n\t      break;\n#endif /* defined(TN3270) */\n\n\t    case IAC:\n#if !defined TN3270\n\t      TTYADD (IAC);\n#else /* !defined(TN3270) */\n\t      if (In3270)\n\t\t{\n\t\t  *Ifrontp++ = IAC;\n\t\t}\n\t      else\n\t\t{\n\t\t  TTYADD (IAC);\n\t\t}\n#endif /* !defined(TN3270) */\n\t      break;\n\n\t    case NOP:\n\t    case GA:\n\t    default:\n\t      printoption (\"RCVD\", IAC, c);\n\t      break;\n\t    }\n\t  telrcv_state = TS_DATA;\n\t  continue;\n\n\tcase TS_WILL:\n\t  printoption (\"RCVD\", WILL, c);\n\t  willoption (c);\n\t  SetIn3270 ();\n\t  telrcv_state = TS_DATA;\n\t  continue;\n\n\tcase TS_WONT:\n\t  printoption (\"RCVD\", WONT, c);\n\t  wontoption (c);\n\t  SetIn3270 ();\n\t  telrcv_state = TS_DATA;\n\t  continue;\n\n\tcase TS_DO:\n\t  printoption (\"RCVD\", DO, c);\n\t  dooption (c);\n\t  SetIn3270 ();\n\t  if (c == TELOPT_NAWS)\n\t    {\n\t      sendnaws ();\n\t    }\n\t  else if (c == TELOPT_LFLOW)\n\t    {\n\t      localflow = 1;\n\t      setcommandmode ();\n\t      setconnmode (0);\n\t    }\n\t  telrcv_state = TS_DATA;\n\t  continue;\n\n\tcase TS_DONT:\n\t  printoption (\"RCVD\", DONT, c);\n\t  dontoption (c);\n\t  flushline = 1;\n\t  setconnmode (0);\t/* set new tty mode (maybe) */\n\t  SetIn3270 ();\n\t  telrcv_state = TS_DATA;\n\t  continue;\n\n\tcase TS_SB:\n\t  if (c == IAC)\n\t    {\n\t      telrcv_state = TS_SE;\n\t    }\n\t  else\n\t    {\n\t      SB_ACCUM (c);\n\t    }\n\t  continue;\n\n\tcase TS_SE:\n\t  if (c != SE)\n\t    {\n\t      if (c != IAC)\n\t\t{\n\t\t  /*\n\t\t   * This is an error.  We only expect to get\n\t\t   * \"IAC IAC\" or \"IAC SE\".  Several things may\n\t\t   * have happend.  An IAC was not doubled, the\n\t\t   * IAC SE was left off, or another option got\n\t\t   * inserted into the suboption are all possibilities.\n\t\t   * If we assume that the IAC was not doubled,\n\t\t   * and really the IAC SE was left off, we could\n\t\t   * get into an infinate loop here.  So, instead,\n\t\t   * we terminate the suboption, and process the\n\t\t   * partial suboption if we can.\n\t\t   */\n\t\t  SB_ACCUM (IAC);\n\t\t  SB_ACCUM (c);\n\t\t  subpointer -= 2;\n\t\t  SB_TERM ();\n\n\t\t  printoption (\"In SUBOPTION processing, RCVD\", IAC, c);\n\t\t  suboption ();\t/* handle sub-option */\n\t\t  SetIn3270 ();\n\t\t  telrcv_state = TS_IAC;\n\t\t  goto process_iac;\n\t\t}\n\t      SB_ACCUM (c);\n\t      telrcv_state = TS_SB;\n\t    }\n\t  else\n\t    {\n\t      SB_ACCUM (IAC);\n\t      SB_ACCUM (SE);\n\t      subpointer -= 2;\n\t      SB_TERM ();\n\t      suboption ();\t/* handle sub-option */\n\t      SetIn3270 ();\n\t      telrcv_state = TS_DATA;\n\t    }\n\t}\n    }\n  if (count)\n    ring_consumed (&netiring, count);\n  return returnValue || count;\n}",
      "lines": 321,
      "depth": 22,
      "decorators": [
        "int"
      ]
    },
    "rlogin_susp": {
      "start_point": [
        2134,
        0
      ],
      "end_point": [
        2145,
        1
      ],
      "content": "int\nrlogin_susp (void)\n{\n  if (local)\n    {\n      local = 0;\n      bol = 1;\n      command (0, \"z\\n\", 2);\n      return (1);\n    }\n  return (0);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "telsnd": {
      "start_point": [
        2147,
        0
      ],
      "end_point": [
        2324,
        1
      ],
      "content": "static int\ntelsnd (void)\n{\n  int tcc;\n  int count;\n  int returnValue = 0;\n  unsigned char *tbp;\n\n  tcc = 0;\n  count = 0;\n  while (NETROOM () > 2)\n    {\n      register int sc;\n      register int c;\n\n      if (tcc == 0)\n\t{\n\t  if (count)\n\t    {\n\t      ring_consumed (&ttyiring, count);\n\t      returnValue = 1;\n\t      count = 0;\n\t    }\n\t  tbp = ttyiring.consume;\n\t  tcc = ring_full_consecutive (&ttyiring);\n\t  if (tcc == 0)\n\t    {\n\t      break;\n\t    }\n\t}\n      c = *tbp++ & 0xff, sc = strip (c), tcc--;\n      count++;\n      if (rlogin != _POSIX_VDISABLE)\n\t{\n\t  if (bol)\n\t    {\n\t      bol = 0;\n\t      if (sc == rlogin)\n\t\t{\n\t\t  local = 1;\n\t\t  continue;\n\t\t}\n\t    }\n\t  else if (local)\n\t    {\n\t      local = 0;\n\t      if (sc == '.' || c == termEofChar)\n\t\t{\n\t\t  bol = 1;\n\t\t  command (0, \"close\\n\", 6);\n\t\t  continue;\n\t\t}\n\t      if (sc == termSuspChar)\n\t\t{\n\t\t  bol = 1;\n\t\t  command (0, \"z\\n\", 2);\n\t\t  continue;\n\t\t}\n\t      if (sc == escape)\n\t\t{\n\t\t  command (0, (char *) tbp, tcc);\n\t\t  bol = 1;\n\t\t  count += tcc;\n\t\t  tcc = 0;\n\t\t  flushline = 1;\n\t\t  break;\n\t\t}\n\t      if (sc != rlogin)\n\t\t{\n\t\t  ++tcc;\n\t\t  --tbp;\n\t\t  --count;\n\t\t  c = sc = rlogin;\n\t\t}\n\t    }\n\t  if ((sc == '\\n') || (sc == '\\r'))\n\t    bol = 1;\n\t}\n      else if (sc == escape)\n\t{\n\t  /*\n\t   * Double escape is a pass through of a single escape character.\n\t   */\n\t  if (tcc && strip (*tbp) == escape)\n\t    {\n\t      tbp++;\n\t      tcc--;\n\t      count++;\n\t      bol = 0;\n\t    }\n\t  else\n\t    {\n\t      command (0, (char *) tbp, tcc);\n\t      bol = 1;\n\t      count += tcc;\n\t      tcc = 0;\n\t      flushline = 1;\n\t      break;\n\t    }\n\t}\n      else\n\tbol = 0;\n#ifdef\tKLUDGELINEMODE\n      if (kludgelinemode && (globalmode & MODE_EDIT) && (sc == echoc))\n\t{\n\t  if (tcc > 0 && strip (*tbp) == echoc)\n\t    {\n\t      tcc--;\n\t      tbp++;\n\t      count++;\n\t    }\n\t  else\n\t    {\n\t      dontlecho = !dontlecho;\n\t      settimer (echotoggle);\n\t      setconnmode (0);\n\t      flushline = 1;\n\t      break;\n\t    }\n\t}\n#endif\n      if (MODE_LOCAL_CHARS (globalmode))\n\t{\n\t  if (TerminalSpecialChars (sc) == 0)\n\t    {\n\t      bol = 1;\n\t      break;\n\t    }\n\t}\n      if (my_want_state_is_wont (TELOPT_BINARY))\n\t{\n\t  switch (c)\n\t    {\n\t    case '\\n':\n\t      /*\n\t       * If we are in CRMOD mode (\\r ==> \\n)\n\t       * on our local machine, then probably\n\t       * a newline (unix) is CRLF (TELNET).\n\t       */\n\t      if (MODE_LOCAL_CHARS (globalmode))\n\t\t{\n\t\t  NETADD ('\\r');\n\t\t}\n\t      NETADD ('\\n');\n\t      bol = flushline = 1;\n\t      break;\n\t    case '\\r':\n\t      if (!crlf)\n\t\t{\n\t\t  NET2ADD ('\\r', '\\0');\n\t\t}\n\t      else\n\t\t{\n\t\t  NET2ADD ('\\r', '\\n');\n\t\t}\n\t      bol = flushline = 1;\n\t      break;\n\t    case IAC:\n\t      NET2ADD (IAC, IAC);\n\t      break;\n\t    default:\n\t      NETADD (c);\n\t      break;\n\t    }\n\t}\n      else if (c == IAC)\n\t{\n\t  NET2ADD (IAC, IAC);\n\t}\n      else\n\t{\n\t  NETADD (c);\n\t}\n    }\n  if (count)\n    ring_consumed (&ttyiring, count);\n  return returnValue || count;\t/* Non-zero if we did anything */\n}",
      "lines": 178,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "Scheduler": {
      "start_point": [
        2337,
        0
      ],
      "end_point": [
        2420,
        1
      ],
      "content": "int\nScheduler (int block)\n{\n  /* One wants to be a bit careful about setting returnValue\n   * to one, since a one implies we did some useful work,\n   * and therefore probably won't be called to block next\n   * time (TN3270 mode only).\n   */\n  int returnValue;\n  int netin, netout, netex, ttyin, ttyout;\n\n  /* Decide which rings should be processed */\n\n  netout = ring_full_count (&netoring) &&\n    (flushline || (my_want_state_is_wont (TELOPT_LINEMODE)\n#ifdef\tKLUDGELINEMODE\n\t\t   && (!kludgelinemode || my_want_state_is_do (TELOPT_SGA))\n#endif\n     ) || my_want_state_is_will (TELOPT_BINARY));\n  ttyout = ring_full_count (&ttyoring);\n\n#if defined TN3270\n  ttyin = ring_empty_count (&ttyiring) && (shell_active == 0);\n#else /* defined(TN3270) */\n  ttyin = ring_empty_count (&ttyiring);\n#endif /* defined(TN3270) */\n\n#if defined TN3270\n  netin = ring_empty_count (&netiring);\n#else /* !defined(TN3270) */\n  netin = !ISend && ring_empty_count (&netiring);\n#endif /* !defined(TN3270) */\n\n  netex = !SYNCHing;\n\n  /* If we have seen a signal recently, reset things */\n#if defined TN3270 && (defined unix || defined __unix || defined __unix__)\n  if (HaveInput)\n    {\n      HaveInput = 0;\n      signal (SIGIO, inputAvailable);\n    }\n#endif /* TN3270 && (unix || __unix || __unix__) */\n\n  /* Call to system code to process rings */\n\n  returnValue = process_rings (netin, netout, netex, ttyin, ttyout, !block);\n\n  /* Now, look at the input rings, looking for work to do. */\n\n  if (ring_full_count (&ttyiring))\n    {\n#if defined TN3270\n      if (In3270)\n\t{\n\t  int c;\n\n\t  c = DataFromTerminal (ttyiring.consume,\n\t\t\t\tring_full_consecutive (&ttyiring));\n\t  if (c)\n\t    {\n\t      returnValue = 1;\n\t      ring_consumed (&ttyiring, c);\n\t    }\n\t}\n      else\n\t{\n#endif /* defined(TN3270) */\n\t  returnValue |= telsnd ();\n#if defined TN3270\n\t}\n#endif /* defined(TN3270) */\n    }\n\n  if (ring_full_count (&netiring))\n    {\n#if !defined TN3270\n      returnValue |= telrcv ();\n#else /* !defined(TN3270) */\n      returnValue = Push3270 ();\n#endif /* !defined(TN3270) */\n    }\n  return returnValue;\n}",
      "lines": 84,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "telnet": {
      "start_point": [
        2425,
        0
      ],
      "end_point": [
        2542,
        1
      ],
      "content": "void\ntelnet (char *user)\n{\n  sys_telnet_init ();\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n  {\n    static char *local_host = 0;\n\n    if (!local_host)\n      local_host = localhost ();\n\n    auth_encrypt_init (local_host, hostname, NULL, \"TELNET\", 0);\n    auth_encrypt_user (user);\n  }\n#else /* !defined(AUTHENTICATION) && !defined(ENCRYPTION)  */\n  (void) user;\n#endif\n#if !defined TN3270\n  if (telnetport)\n    {\n# if defined AUTHENTICATION\n      if (autologin)\n\tsend_will (TELOPT_AUTHENTICATION, 1);\n# endif\n# ifdef\tENCRYPTION\n      send_do (TELOPT_ENCRYPT, 1);\n      send_will (TELOPT_ENCRYPT, 1);\n# endif\t/* ENCRYPTION */\n      send_do (TELOPT_SGA, 1);\n      send_will (TELOPT_TTYPE, 1);\n      send_will (TELOPT_NAWS, 1);\n      send_will (TELOPT_TSPEED, 1);\n      send_will (TELOPT_LFLOW, 1);\n      send_will (TELOPT_LINEMODE, 1);\n      send_will (TELOPT_NEW_ENVIRON, 1);\n      send_do (TELOPT_STATUS, 1);\n      if (env_getvalue (\"DISPLAY\"))\n\tsend_will (TELOPT_XDISPLOC, 1);\n      if (eight)\n\ttel_enter_binary (eight);\n    }\n#endif /* !defined(TN3270) */\n\n#if !defined TN3270\n  for (;;)\n    {\n      int schedValue;\n\n      while ((schedValue = Scheduler (0)) != 0)\n\t{\n\t  if (schedValue == -1)\n\t    {\n\t      setcommandmode ();\n\t      return;\n\t    }\n\t}\n\n      if (Scheduler (1) == -1)\n\t{\n\t  setcommandmode ();\n\t  return;\n\t}\n    }\n#else /* !defined(TN3270) */\n  for (;;)\n    {\n      int schedValue;\n\n      while (!In3270 && !shell_active)\n\t{\n\t  if (Scheduler (1) == -1)\n\t    {\n\t      setcommandmode ();\n\t      return;\n\t    }\n\t}\n\n      while ((schedValue = Scheduler (0)) != 0)\n\t{\n\t  if (schedValue == -1)\n\t    {\n\t      setcommandmode ();\n\t      return;\n\t    }\n\t}\n      /* If there is data waiting to go out to terminal, don't\n       * schedule any more data for the terminal.\n       */\n      if (ring_full_count (&ttyoring))\n\t{\n\t  schedValue = 1;\n\t}\n      else\n\t{\n\t  if (shell_active)\n\t    {\n\t      if (shell_continue () == 0)\n\t\t{\n\t\t  ConnectScreen ();\n\t\t}\n\t    }\n\t  else if (In3270)\n\t    {\n\t      schedValue = DoTerminalOutput ();\n\t    }\n\t}\n      if (schedValue && (shell_active == 0))\n\t{\n\t  if (Scheduler (1) == -1)\n\t    {\n\t      setcommandmode ();\n\t      return;\n\t    }\n\t}\n    }\n#endif /* !defined(TN3270) */\n}",
      "lines": 118,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "nextitem": {
      "start_point": [
        2556,
        0
      ],
      "end_point": [
        2588,
        1
      ],
      "content": "static char *\nnextitem (char *current)\n{\n  if ((*current & 0xff) != IAC)\n    {\n      return current + 1;\n    }\n  switch (*(current + 1) & 0xff)\n    {\n    case DO:\n    case DONT:\n    case WILL:\n    case WONT:\n      return current + 3;\n    case SB:\t\t\t/* loop forever looking for the SE */\n      {\n\tregister char *look = current + 2;\n\n\tfor (;;)\n\t  {\n\t    if ((*look++ & 0xff) == IAC)\n\t      {\n\t\tif ((*look++ & 0xff) == SE)\n\t\t  {\n\t\t    return look;\n\t\t  }\n\t      }\n\t  }\n      }\n    default:\n      return current + 2;\n    }\n}",
      "lines": 33,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nnextitem (char *current)",
        "*"
      ]
    },
    "netclear": {
      "start_point": [
        2608,
        0
      ],
      "end_point": [
        2652,
        1
      ],
      "content": "static void\nnetclear (void)\n{\n#if 0\t\t\t\t/* XXX */\n  register char *thisitem, *next;\n  char *good;\n# define wewant(p)\t((nfrontp > p) && ((*p&0xff) == IAC) && \\\n\t\t\t\t((*(p+1)&0xff) != EC) && ((*(p+1)&0xff) != EL))\n\n  thisitem = netobuf;\n\n  while ((next = nextitem (thisitem)) <= netobuf.send)\n    {\n      thisitem = next;\n    }\n\n  /* Now, thisitem is first before/at boundary. */\n\n  good = netobuf;\t\t/* where the good bytes go */\n\n  while (netoring.add > thisitem)\n    {\n      if (wewant (thisitem))\n\t{\n\t  int length;\n\n\t  next = thisitem;\n\t  do\n\t    {\n\t      next = nextitem (next);\n\t    }\n\t  while (wewant (next) && (nfrontp > next));\n\t  length = next - thisitem;\n\t  memmove (good, thisitem, length);\n\t  good += length;\n\t  thisitem = next;\n\t}\n      else\n\t{\n\t  thisitem = nextitem (thisitem);\n\t}\n    }\n\n#endif /* 0 */\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "doflush": {
      "start_point": [
        2658,
        0
      ],
      "end_point": [
        2668,
        1
      ],
      "content": "static void\ndoflush (void)\n{\n  NET2ADD (IAC, DO);\n  NETADD (TELOPT_TM);\n  flushline = 1;\n  flushout = 1;\n  ttyflush (1);\t\t\t/* Flush/drop output */\n  /* do printoption AFTER flush, otherwise the output gets tossed... */\n  printoption (\"SENT\", DO, TELOPT_TM);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xmitAO": {
      "start_point": [
        2670,
        0
      ],
      "end_point": [
        2679,
        1
      ],
      "content": "void\nxmitAO (void)\n{\n  NET2ADD (IAC, AO);\n  printoption (\"SENT\", IAC, AO);\n  if (autoflush)\n    {\n      doflush ();\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "xmitEL": {
      "start_point": [
        2682,
        0
      ],
      "end_point": [
        2687,
        1
      ],
      "content": "void\nxmitEL (void)\n{\n  NET2ADD (IAC, EL);\n  printoption (\"SENT\", IAC, EL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "xmitEC": {
      "start_point": [
        2689,
        0
      ],
      "end_point": [
        2694,
        1
      ],
      "content": "void\nxmitEC (void)\n{\n  NET2ADD (IAC, EC);\n  printoption (\"SENT\", IAC, EC);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dosynch": {
      "start_point": [
        2697,
        0
      ],
      "end_point": [
        2706,
        1
      ],
      "content": "int\ndosynch (void)\n{\n  netclear ();\t\t\t/* clear the path to the network */\n  NETADD (IAC);\n  setneturg ();\n  NETADD (DM);\n  printoption (\"SENT\", IAC, DM);\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "get_status": {
      "start_point": [
        2710,
        0
      ],
      "end_point": [
        2736,
        1
      ],
      "content": "int\nget_status (void)\n{\n  unsigned char tmp[16];\n  register unsigned char *cp;\n\n  if (my_want_state_is_dont (TELOPT_STATUS))\n    {\n      printf (\"Remote side does not support STATUS option\\n\");\n      return 0;\n    }\n  cp = tmp;\n\n  *cp++ = IAC;\n  *cp++ = SB;\n  *cp++ = TELOPT_STATUS;\n  *cp++ = TELQUAL_SEND;\n  *cp++ = IAC;\n  *cp++ = SE;\n  if (NETROOM () >= cp - tmp)\n    {\n      ring_supply_data (&netoring, tmp, cp - tmp);\n      printsub ('>', tmp + 2, cp - tmp - 2);\n    }\n  ++want_status_response;\n  return 1;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "intp": {
      "start_point": [
        2738,
        0
      ],
      "end_point": [
        2752,
        1
      ],
      "content": "void\nintp (void)\n{\n  NET2ADD (IAC, IP);\n  printoption (\"SENT\", IAC, IP);\n  flushline = 1;\n  if (autoflush)\n    {\n      doflush ();\n    }\n  if (autosynch)\n    {\n      dosynch ();\n    }\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sendbrk": {
      "start_point": [
        2754,
        0
      ],
      "end_point": [
        2768,
        1
      ],
      "content": "void\nsendbrk (void)\n{\n  NET2ADD (IAC, BREAK);\n  printoption (\"SENT\", IAC, BREAK);\n  flushline = 1;\n  if (autoflush)\n    {\n      doflush ();\n    }\n  if (autosynch)\n    {\n      dosynch ();\n    }\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sendabort": {
      "start_point": [
        2770,
        0
      ],
      "end_point": [
        2784,
        1
      ],
      "content": "void\nsendabort (void)\n{\n  NET2ADD (IAC, ABORT);\n  printoption (\"SENT\", IAC, ABORT);\n  flushline = 1;\n  if (autoflush)\n    {\n      doflush ();\n    }\n  if (autosynch)\n    {\n      dosynch ();\n    }\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sendsusp": {
      "start_point": [
        2786,
        0
      ],
      "end_point": [
        2800,
        1
      ],
      "content": "void\nsendsusp (void)\n{\n  NET2ADD (IAC, SUSP);\n  printoption (\"SENT\", IAC, SUSP);\n  flushline = 1;\n  if (autoflush)\n    {\n      doflush ();\n    }\n  if (autosynch)\n    {\n      dosynch ();\n    }\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sendeof": {
      "start_point": [
        2802,
        0
      ],
      "end_point": [
        2807,
        1
      ],
      "content": "void\nsendeof (void)\n{\n  NET2ADD (IAC, xEOF);\n  printoption (\"SENT\", IAC, xEOF);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sendayt": {
      "start_point": [
        2809,
        0
      ],
      "end_point": [
        2814,
        1
      ],
      "content": "void\nsendayt (void)\n{\n  NET2ADD (IAC, AYT);\n  printoption (\"SENT\", IAC, AYT);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sendnaws": {
      "start_point": [
        2820,
        0
      ],
      "end_point": [
        2852,
        1
      ],
      "content": "void\nsendnaws (void)\n{\n  long rows, cols;\n  unsigned char tmp[16];\n  register unsigned char *cp;\n\n  if (my_state_is_wont (TELOPT_NAWS))\n    return;\n\n#define PUTSHORT(cp, x) { if ((*cp++ = ((x)>>8)&0xff) == IAC) *cp++ = IAC; \\\n\t\t\t    if ((*cp++ = ((x))&0xff) == IAC) *cp++ = IAC; }\n\n  if (TerminalWindowSize (&rows, &cols) == 0)\n    {\t\t\t\t/* Failed */\n      return;\n    }\n\n  cp = tmp;\n\n  *cp++ = IAC;\n  *cp++ = SB;\n  *cp++ = TELOPT_NAWS;\n  PUTSHORT (cp, cols);\n  PUTSHORT (cp, rows);\n  *cp++ = IAC;\n  *cp++ = SE;\n  if (NETROOM () >= cp - tmp)\n    {\n      ring_supply_data (&netoring, tmp, cp - tmp);\n      printsub ('>', tmp + 2, cp - tmp - 2);\n    }\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "tel_enter_binary": {
      "start_point": [
        2854,
        0
      ],
      "end_point": [
        2861,
        1
      ],
      "content": "void\ntel_enter_binary (int rw)\n{\n  if (rw & 1)\n    send_do (TELOPT_BINARY, 1);\n  if (rw & 2)\n    send_will (TELOPT_BINARY, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "tel_leave_binary": {
      "start_point": [
        2863,
        0
      ],
      "end_point": [
        2870,
        1
      ],
      "content": "void\ntel_leave_binary (int rw)\n{\n  if (rw & 1)\n    send_dont (TELOPT_BINARY, 1);\n  if (rw & 2)\n    send_wont (TELOPT_BINARY, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/terminal.c": {
    "init_terminal": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void\ninit_terminal (void)\n{\n  if (ring_init (&ttyoring, ttyobuf, sizeof ttyobuf) != 1)\n    {\n      exit (EXIT_FAILURE);\n    }\n  if (ring_init (&ttyiring, ttyibuf, sizeof ttyibuf) != 1)\n    {\n      exit (EXIT_FAILURE);\n    }\n  autoflush = TerminalAutoFlush ();\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ttyflush": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\nttyflush (int drop)\n{\n  register int n, n0, n1;\n\n  n0 = ring_full_count (&ttyoring);\n  if ((n1 = n = ring_full_consecutive (&ttyoring)) > 0)\n    {\n      if (drop)\n\t{\n\t  TerminalFlushOutput ();\n\t  /* we leave 'n' alone! */\n\t}\n      else\n\t{\n\t  n = TerminalWrite ((char *) ttyoring.consume, n);\n\t}\n    }\n  if (n > 0)\n    {\n      if (termdata && n)\n\t{\n\t  Dump ('>', ttyoring.consume, n);\n\t}\n      /*\n       * If we wrote everything, and the full count is\n       * larger than what we wrote, then write the\n       * rest of the buffer.\n       */\n      if (n1 == n && n0 > n)\n\t{\n\t  n1 = n0 - n;\n\t  if (!drop)\n\t    n1 = TerminalWrite ((char *) ttyoring.bottom, n1);\n\t  if (n1 > 0)\n\t    n += n1;\n\t}\n      ring_consumed (&ttyoring, n);\n    }\n  if (n < 0)\n    return -1;\n  if (n == n0)\n    {\n      if (n0)\n\treturn -1;\n      return 0;\n    }\n  return n0 - n + 1;\n}",
      "lines": 49,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "getconnmode": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "int\ngetconnmode (void)\n{\n  extern int linemode;\n  int mode = 0;\n#ifdef\tKLUDGELINEMODE\n  extern int kludgelinemode;\n#endif\n\n  if (In3270)\n    return (MODE_FLOW);\n\n  if (my_want_state_is_dont (TELOPT_ECHO))\n    mode |= MODE_ECHO;\n\n  if (localflow)\n    mode |= MODE_FLOW;\n\n  if (my_want_state_is_will (TELOPT_BINARY))\n    mode |= MODE_INBIN;\n\n  if (his_want_state_is_will (TELOPT_BINARY))\n    mode |= MODE_OUTBIN;\n\n#ifdef\tKLUDGELINEMODE\n  if (kludgelinemode)\n    {\n      if (my_want_state_is_dont (TELOPT_SGA))\n\t{\n\t  mode |= (MODE_TRAPSIG | MODE_EDIT);\n\t  if (dontlecho && (clocks.echotoggle > clocks.modenegotiated))\n\t    {\n\t      mode &= ~MODE_ECHO;\n\t    }\n\t}\n      return (mode);\n    }\n#endif\n  if (my_want_state_is_will (TELOPT_LINEMODE))\n    mode |= linemode;\n  return (mode);\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "setconnmode": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\nsetconnmode (int force)\n{\n#ifdef\tENCRYPTION\n  static int enc_passwd = 0;\n#endif /* ENCRYPTION */\n  register int newmode;\n\n  newmode = getconnmode () | (force ? MODE_FORCE : 0);\n\n  TerminalNewMode (newmode);\n\n#ifdef  ENCRYPTION\n  if ((newmode & (MODE_ECHO | MODE_EDIT)) == MODE_EDIT)\n    {\n      if (my_want_state_is_will (TELOPT_ENCRYPT)\n\t  && (enc_passwd == 0) && !encrypt_output)\n\t{\n\t  encrypt_request_start (0, 0);\n\t  enc_passwd = 1;\n\t}\n    }\n  else\n    {\n      if (enc_passwd)\n\t{\n\t  encrypt_request_end ();\n\t  enc_passwd = 0;\n\t}\n    }\n#endif /* ENCRYPTION */\n\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "setcommandmode": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\nsetcommandmode (void)\n{\n  TerminalNewMode (-1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/tn3270.c": {
    "init_3270": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\ninit_3270 (void)\n{\n#if defined TN3270\n# if defined unix || defined __unix || defined __unix__\n  HaveInput = 0;\n  sigiocount = 0;\n# endif\t/* unix || __unix || __unix__ */\n  Sent3270TerminalType = 0;\n  Ifrontp = Ibackp = Ibuf;\n  init_ctlr ();\t\t\t/* Initialize some things */\n  init_keyboard ();\n  init_screen ();\n  init_system ();\n#endif /* defined(TN3270) */\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "DataToNetwork": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "int\nDataToNetwork (register char *buffer, register int count, int done)\n{\n  register int loop, c;\n  int origCount;\n\n  origCount = count;\n\n  while (count)\n    {\n      /* If not enough room for EORs, IACs, etc., wait */\n      if (NETROOM () < 6)\n\t{\n\t  fd_set o;\n\n\t  FD_ZERO (&o);\n\t  netflush ();\n\t  while (NETROOM () < 6)\n\t    {\n\t      FD_SET (net, &o);\n\t      select (net + 1, (fd_set *) 0, &o, (fd_set *) 0,\n\t\t      (struct timeval *) 0);\n\t      netflush ();\n\t    }\n\t}\n      c = ring_empty_count (&netoring);\n      if (c > count)\n\t{\n\t  c = count;\n\t}\n      loop = c;\n      while (loop)\n\t{\n\t  if (((unsigned char) *buffer) == IAC)\n\t    {\n\t      break;\n\t    }\n\t  buffer++;\n\t  loop--;\n\t}\n      if ((c = c - loop))\n\t{\n\t  ring_supply_data (&netoring, buffer - c, c);\n\t  count -= c;\n\t}\n      if (loop)\n\t{\n\t  NET2ADD (IAC, IAC);\n\t  count--;\n\t  buffer++;\n\t}\n    }\n\n  if (done)\n    {\n      NET2ADD (IAC, EOR);\n      netflush ();\t\t/* try to move along as quickly as ... */\n    }\n  return (origCount - count);\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "inputAvailable": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\ninputAvailable (int signo)\n{\n  HaveInput = 1;\n  sigiocount++;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "outputPurge": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\noutputPurge ()\n{\n  ttyflush (1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "DataToTerminal": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "int\nDataToTerminal (register char *buffer, register int count)\n{\n  register int c;\n  int origCount;\n\n  origCount = count;\n\n  while (count)\n    {\n      if (TTYROOM () == 0)\n\t{\n# if defined unix || defined __unix || defined __unix__\n\t  fd_set o;\n\n\t  FD_ZERO (&o);\n# endif\t/* unix || __unix || __unix__ */\n\t  ttyflush (0);\n\t  while (TTYROOM () == 0)\n\t    {\n# if defined unix || defined __unix || defined __unix__\n\t      FD_SET (tout, &o);\n\t      select (tout + 1, (fd_set *) 0, &o, (fd_set *) 0,\n\t\t      (struct timeval *) 0);\n# endif\t/* unix || __unix || __unix__ */\n\t      ttyflush (0);\n\t    }\n\t}\n      c = TTYROOM ();\n      if (c > count)\n\t{\n\t  c = count;\n\t}\n      ring_supply_data (&ttyoring, buffer, c);\n      count -= c;\n      buffer += c;\n    }\n  return (origCount);\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "Push3270": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "int\nPush3270 ()\n{\n  int save = ring_full_count (&netiring);\n\n  if (save)\n    {\n      if (Ifrontp + save > Ibuf + sizeof Ibuf)\n\t{\n\t  if (Ibackp != Ibuf)\n\t    {\n\t      memmove (Ibuf, Ibackp, Ifrontp - Ibackp);\n\t      Ifrontp -= (Ibackp - Ibuf);\n\t      Ibackp = Ibuf;\n\t    }\n\t}\n      if (Ifrontp + save < Ibuf + sizeof Ibuf)\n\t{\n\t  telrcv ();\n\t}\n    }\n  return save != ring_full_count (&netiring);\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "Finish3270": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nFinish3270 ()\n{\n  while (Push3270 () || !DoTerminalOutput ())\n    {\n# if defined unix || defined __unix || defined __unix__\n      HaveInput = 0;\n# endif\t/* unix || __unix || __unix__ */\n      ;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "StringToTerminal": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "void\nStringToTerminal (char *s)\n{\n  int count;\n\n  count = strlen (s);\n  if (count)\n    {\n      DataToTerminal (s, count);\t/* we know it always goes... */\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_putchar": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "void\n_putchar (char c)\n{\n#  if defined sun\t\t/* SunOS 4.0 bug */\n  c &= 0x7f;\n#  endif /* defined(sun) */\n  if (cursesdata)\n    {\n      Dump ('>', &c, 1);\n    }\n  if (!TTYROOM ())\n    {\n      DataToTerminal (&c, 1);\n    }\n  else\n    {\n      TTYADD (c);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "SetIn3270": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\nSetIn3270 ()\n{\n  if (Sent3270TerminalType && my_want_state_is_will (TELOPT_BINARY)\n      && my_want_state_is_do (TELOPT_BINARY) && !donebinarytoggle)\n    {\n      if (!In3270)\n\t{\n\t  In3270 = 1;\n\t  Init3270 ();\t\t/* Initialize 3270 functions */\n\t  /* initialize terminal key mapping */\n\t  InitTerminal ();\t/* Start terminal going */\n\t  setconnmode (0);\n\t}\n    }\n  else\n    {\n      if (In3270)\n\t{\n\t  StopScreen (1);\n\t  In3270 = 0;\n\t  Stop3270 ();\t\t/* Tell 3270 we aren't here anymore */\n\t  setconnmode (0);\n\t}\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "tn3270_ttype": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        431,
        1
      ],
      "content": "int\ntn3270_ttype ()\n{\n  /*\n   * Try to send a 3270 type terminal name.  Decide which one based\n   * on the format of our screen, and (in the future) color\n   * capaiblities.\n   */\n  InitTerminal ();\t\t/* Sets MaxNumberColumns, MaxNumberLines */\n  if ((MaxNumberLines >= 24) && (MaxNumberColumns >= 80))\n    {\n      Sent3270TerminalType = 1;\n      if ((MaxNumberLines >= 27) && (MaxNumberColumns >= 132))\n\t{\n\t  MaxNumberLines = 27;\n\t  MaxNumberColumns = 132;\n\t  sb_terminal[SBTERMMODEL] = '5';\n\t}\n      else if (MaxNumberLines >= 43)\n\t{\n\t  MaxNumberLines = 43;\n\t  MaxNumberColumns = 80;\n\t  sb_terminal[SBTERMMODEL] = '4';\n\t}\n      else if (MaxNumberLines >= 32)\n\t{\n\t  MaxNumberLines = 32;\n\t  MaxNumberColumns = 80;\n\t  sb_terminal[SBTERMMODEL] = '3';\n\t}\n      else\n\t{\n\t  MaxNumberLines = 24;\n\t  MaxNumberColumns = 80;\n\t  sb_terminal[SBTERMMODEL] = '2';\n\t}\n      NumberLines = 24;\t\t/* before we start out... */\n      NumberColumns = 80;\n      ScreenSize = NumberLines * NumberColumns;\n      if ((MaxNumberLines * MaxNumberColumns) > MAXSCREENSIZE)\n\t{\n\t  ExitString (\"Programming error:  MAXSCREENSIZE too small.\\n\", 1);\n\t}\n      printsub ('>', sb_terminal + 2, sizeof sb_terminal - 2);\n      ring_supply_data (&netoring, sb_terminal, sizeof sb_terminal);\n      return 1;\n    }\n  else\n    {\n      return 0;\n    }\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "settranscom": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "int\nsettranscom (int argc, char *argv[])\n{\n  int i;\n\n  if (argc == 1 && transcom)\n    {\n      transcom = 0;\n    }\n  if (argc == 1)\n    {\n      return 1;\n    }\n  transcom = tline;\n  strcpy (transcom, argv[1]);\n  for (i = 2; i < argc; ++i)\n    {\n      strcat (transcom, \" \");\n      strcat (transcom, argv[i]);\n    }\n  return 1;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnet/types.h": {},
  "inetutils/inetutils-1.9.4/telnet/utilities.c": {
    "upcase": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "void\nupcase (register char *argument)\n{\n  register int c;\n\n  while ((c = *argument) != 0)\n    {\n      if (islower (c))\n\t{\n\t  *argument = toupper (c);\n\t}\n      argument++;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "SetSockOpt": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nSetSockOpt (int fd, int level, int option, int yesno)\n{\n#ifndef NOT43\n  return setsockopt (fd, level, option, (char *) &yesno, sizeof yesno);\n#else /* NOT43 */\n  if (yesno == 0)\n    {\t\t\t\t/* Can't do that in 4.2! */\n      fprintf (stderr, \"Error: attempt to turn off an option 0x%x.\\n\",\n\t       option);\n      return -1;\n    }\n  return setsockopt (fd, level, option, 0, 0);\n#endif /* NOT43 */\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "SetNetTrace": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nSetNetTrace (register char *file)\n{\n  if (NetTrace && NetTrace != stdout)\n    fclose (NetTrace);\n  if (file && (strcmp (file, \"-\") != 0))\n    {\n      NetTrace = fopen (file, \"w\");\n      if (NetTrace)\n\t{\n\t  strncpy ((char *) NetTraceFile, file, sizeof (NetTraceFile));\n\t  NetTraceFile[sizeof (NetTraceFile) - 1] = 0;\n\t  return;\n\t}\n      fprintf (stderr, \"Cannot open %s.\\n\", file);\n    }\n  NetTrace = stdout;\n  strcpy ((char *) NetTraceFile, \"(standard output)\");\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "Dump": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "void\nDump (char direction, unsigned char *buffer, int length)\n{\n#define BYTES_PER_LINE\t32\n#define min(x,y)\t((x<y)? x:y)\n  unsigned char *pThis;\n  int offset;\n\n  offset = 0;\n\n  while (length)\n    {\n      /* print one line */\n      fprintf (NetTrace, \"%c 0x%x\\t\", direction, offset);\n      pThis = buffer;\n      if (prettydump)\n\t{\n\t  buffer = buffer + min (length, BYTES_PER_LINE / 2);\n\t  while (pThis < buffer)\n\t    {\n\t      fprintf (NetTrace, \"%c%.2x\",\n\t\t       (((*pThis) & 0xff) == 0xff) ? '*' : ' ',\n\t\t       (*pThis) & 0xff);\n\t      pThis++;\n\t    }\n\t  length -= BYTES_PER_LINE / 2;\n\t  offset += BYTES_PER_LINE / 2;\n\t}\n      else\n\t{\n\t  buffer = buffer + min (length, BYTES_PER_LINE);\n\t  while (pThis < buffer)\n\t    {\n\t      fprintf (NetTrace, \"%.2x\", (*pThis) & 0xff);\n\t      pThis++;\n\t    }\n\t  length -= BYTES_PER_LINE;\n\t  offset += BYTES_PER_LINE;\n\t}\n      if (NetTrace == stdout)\n\t{\n\t  fprintf (NetTrace, \"\\r\\n\");\n\t}\n      else\n\t{\n\t  fprintf (NetTrace, \"\\n\");\n\t}\n      if (length < 0)\n\t{\n\t  fflush (NetTrace);\n\t  return;\n\t}\n      /* find next unique line */\n    }\n  fflush (NetTrace);\n}",
      "lines": 56,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "printoption": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nprintoption (char *direction, int cmd, int option)\n{\n  if (!showoptions)\n    return;\n  if (cmd == IAC)\n    {\n      if (TELCMD_OK (option))\n\tfprintf (NetTrace, \"%s IAC %s\", direction, TELCMD (option));\n      else\n\tfprintf (NetTrace, \"%s IAC %d\", direction, option);\n    }\n  else\n    {\n      register char *fmt;\n      fmt = (cmd == WILL)\n\t    ? \"WILL\" : (cmd == WONT)\n\t\t       ? \"WONT\" : (cmd == DO)\n\t\t\t\t  ? \"DO\" : (cmd == DONT) ? \"DONT\" : 0;\n      if (fmt)\n\t{\n\t  fprintf (NetTrace, \"%s %s \", direction, fmt);\n\t  if (TELOPT_OK (option))\n\t    fprintf (NetTrace, \"%s\", TELOPT (option));\n\t  else if (option == TELOPT_EXOPL)\n\t    fprintf (NetTrace, \"EXOPL\");\n\t  else\n\t    fprintf (NetTrace, \"%d\", option);\n\t}\n      else\n\tfprintf (NetTrace, \"%s %d %d\", direction, cmd, option);\n    }\n  if (NetTrace == stdout)\n    {\n      fprintf (NetTrace, \"\\r\\n\");\n      fflush (NetTrace);\n    }\n  else\n    {\n      fprintf (NetTrace, \"\\n\");\n    }\n  return;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "optionstatus": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "void\noptionstatus (void)\n{\n  register int i;\n  extern char will_wont_resp[], do_dont_resp[];\n\n  for (i = 0; i < 256; i++)\n    {\n      if (do_dont_resp[i])\n\t{\n\t  if (TELOPT_OK (i))\n\t    printf (\"resp DO_DONT %s: %d\\n\", TELOPT (i), do_dont_resp[i]);\n\t  else if (TELCMD_OK (i))\n\t    printf (\"resp DO_DONT %s: %d\\n\", TELCMD (i), do_dont_resp[i]);\n\t  else\n\t    printf (\"resp DO_DONT %d: %d\\n\", i, do_dont_resp[i]);\n\t  if (my_want_state_is_do (i))\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"want DO   %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"want DO   %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"want DO   %d\\n\", i);\n\t    }\n\t  else\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"want DONT %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"want DONT %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"want DONT %d\\n\", i);\n\t    }\n\t}\n      else\n\t{\n\t  if (my_state_is_do (i))\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"     DO   %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"     DO   %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"     DO   %d\\n\", i);\n\t    }\n\t}\n      if (will_wont_resp[i])\n\t{\n\t  if (TELOPT_OK (i))\n\t    printf (\"resp WILL_WONT %s: %d\\n\", TELOPT (i), will_wont_resp[i]);\n\t  else if (TELCMD_OK (i))\n\t    printf (\"resp WILL_WONT %s: %d\\n\", TELCMD (i), will_wont_resp[i]);\n\t  else\n\t    printf (\"resp WILL_WONT %d: %d\\n\", i, will_wont_resp[i]);\n\t  if (my_want_state_is_will (i))\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"want WILL %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"want WILL %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"want WILL %d\\n\", i);\n\t    }\n\t  else\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"want WONT %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"want WONT %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"want WONT %d\\n\", i);\n\t    }\n\t}\n      else\n\t{\n\t  if (my_state_is_will (i))\n\t    {\n\t      if (TELOPT_OK (i))\n\t\tprintf (\"     WILL %s\\n\", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tprintf (\"     WILL %s\\n\", TELCMD (i));\n\t      else\n\t\tprintf (\"     WILL %d\\n\", i);\n\t    }\n\t}\n    }\n\n}",
      "lines": 89,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "printsub": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "void\nprintsub (char direction, unsigned char *pointer, int length)\n{\n  register int i;\n  extern int want_status_response;\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n  char buf[512];\n#endif\n\n  if (showoptions || direction == 0 ||\n      (want_status_response && (pointer[0] == TELOPT_STATUS)))\n    {\n      if (direction)\n\t{\n\t  fprintf (NetTrace, \"%s IAC SB \",\n\t\t   (direction == '<') ? \"RCVD\" : \"SENT\");\n\t  if (length >= 3)\n\t    {\n\t      register int j;\n\n\t      i = pointer[length - 2];\n\t      j = pointer[length - 1];\n\n\t      if (i != IAC || j != SE)\n\t\t{\n\t\t  fprintf (NetTrace, \"(terminated by \");\n\t\t  if (TELOPT_OK (i))\n\t\t    fprintf (NetTrace, \"%s \", TELOPT (i));\n\t\t  else if (TELCMD_OK (i))\n\t\t    fprintf (NetTrace, \"%s \", TELCMD (i));\n\t\t  else\n\t\t    fprintf (NetTrace, \"%d \", i);\n\t\t  if (TELOPT_OK (j))\n\t\t    fprintf (NetTrace, \"%s\", TELOPT (j));\n\t\t  else if (TELCMD_OK (j))\n\t\t    fprintf (NetTrace, \"%s\", TELCMD (j));\n\t\t  else\n\t\t    fprintf (NetTrace, \"%d\", j);\n\t\t  fprintf (NetTrace, \", not IAC SE!) \");\n\t\t}\n\t    }\n\t  length -= 2;\n\t}\n      if (length < 1)\n\t{\n\t  fprintf (NetTrace, \"(Empty suboption??\\?)\");\n\t  if (NetTrace == stdout)\n\t    fflush (NetTrace);\n\t  return;\n\t}\n      switch (pointer[0])\n\t{\n\tcase TELOPT_TTYPE:\n\t  fprintf (NetTrace, \"TERMINAL-TYPE \");\n\t  switch (pointer[1])\n\t    {\n\t    case TELQUAL_IS:\n\t      fprintf (NetTrace, \"IS \\\"%.*s\\\"\", length - 2,\n\t\t       (char *) pointer + 2);\n\t      break;\n\t    case TELQUAL_SEND:\n\t      fprintf (NetTrace, \"SEND\");\n\t      break;\n\t    default:\n\t      fprintf (NetTrace, \"- unknown qualifier %d (0x%x).\",\n\t\t       pointer[1], pointer[1]);\n\t    }\n\t  break;\n\tcase TELOPT_TSPEED:\n\t  fprintf (NetTrace, \"TERMINAL-SPEED\");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[1])\n\t    {\n\t    case TELQUAL_IS:\n\t      fprintf (NetTrace, \" IS \");\n\t      fprintf (NetTrace, \"%.*s\", length - 2, (char *) pointer + 2);\n\t      break;\n\t    default:\n\t      if (pointer[1] == 1)\n\t\tfprintf (NetTrace, \" SEND\");\n\t      else\n\t\tfprintf (NetTrace, \" %d (unknown)\", pointer[1]);\n\t      for (i = 2; i < length; i++)\n\t\tfprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t      break;\n\t    }\n\t  break;\n\n\tcase TELOPT_LFLOW:\n\t  fprintf (NetTrace, \"TOGGLE-FLOW-CONTROL\");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[1])\n\t    {\n\t    case LFLOW_OFF:\n\t      fprintf (NetTrace, \" OFF\");\n\t      break;\n\t    case LFLOW_ON:\n\t      fprintf (NetTrace, \" ON\");\n\t      break;\n\t    case LFLOW_RESTART_ANY:\n\t      fprintf (NetTrace, \" RESTART-ANY\");\n\t      break;\n\t    case LFLOW_RESTART_XON:\n\t      fprintf (NetTrace, \" RESTART-XON\");\n\t      break;\n\t    default:\n\t      fprintf (NetTrace, \" %d (unknown)\", pointer[1]);\n\t    }\n\t  for (i = 2; i < length; i++)\n\t    fprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t  break;\n\n\tcase TELOPT_NAWS:\n\t  fprintf (NetTrace, \"NAWS\");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  if (length == 2)\n\t    {\n\t      fprintf (NetTrace, \" ?%d?\", pointer[1]);\n\t      break;\n\t    }\n\t  fprintf (NetTrace, \" %d %d (%d)\",\n\t\t   pointer[1], pointer[2],\n\t\t   (int) ((((unsigned int) pointer[1]) << 8) |\n\t\t\t  ((unsigned int) pointer[2])));\n\t  if (length == 4)\n\t    {\n\t      fprintf (NetTrace, \" ?%d?\", pointer[3]);\n\t      break;\n\t    }\n\t  fprintf (NetTrace, \" %d %d (%d)\",\n\t\t   pointer[3], pointer[4],\n\t\t   (int) ((((unsigned int) pointer[3]) << 8) |\n\t\t\t  ((unsigned int) pointer[4])));\n\t  for (i = 5; i < length; i++)\n\t    fprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t  break;\n\n#if defined AUTHENTICATION\n\tcase TELOPT_AUTHENTICATION:\n\t  fprintf (NetTrace, \"AUTHENTICATION\");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[1])\n\t    {\n\t    case TELQUAL_REPLY:\n\t    case TELQUAL_IS:\n\t      fprintf (NetTrace, \" %s \",\n\t\t       (pointer[1] == TELQUAL_IS) ? \"IS\" : \"REPLY\");\n\t      if (AUTHTYPE_NAME_OK (pointer[2]) && AUTHTYPE_NAME (pointer[2]))\n\t\tfprintf (NetTrace, \"%s \", AUTHTYPE_NAME (pointer[2]));\n\t      else\n\t\tfprintf (NetTrace, \"%d \", pointer[2]);\n\t      if (length < 3)\n\t\t{\n\t\t  fprintf (NetTrace, \"(partial suboption??\\?)\");\n\t\t  break;\n\t\t}\n\t      fprintf (NetTrace, \"%s|%s\",\n\t\t       ((pointer[3] & AUTH_WHO_MASK) == AUTH_WHO_CLIENT)\n\t\t       ? \"CLIENT\" : \"SERVER\",\n\t\t       ((pointer[3] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t\t       ? \"MUTUAL\" : \"ONE-WAY\");\n\n\t      auth_printsub (&pointer[1], length - 1, buf, sizeof (buf));\n\t      fprintf (NetTrace, \"%s\", buf);\n\t      break;\n\n\t    case TELQUAL_SEND:\n\t      i = 2;\n\t      fprintf (NetTrace, \" SEND \");\n\t      while (i < length)\n\t\t{\n\t\t  if (AUTHTYPE_NAME_OK (pointer[i])\n\t\t      && AUTHTYPE_NAME (pointer[i]))\n\t\t    fprintf (NetTrace, \"%s \", AUTHTYPE_NAME (pointer[i]));\n\t\t  else\n\t\t    fprintf (NetTrace, \"%d \", pointer[i]);\n\t\t  if (++i >= length)\n\t\t    {\n\t\t      fprintf (NetTrace, \"(partial suboption??\\?)\");\n\t\t      break;\n\t\t    }\n\t\t  fprintf (NetTrace, \"%s|%s \",\n\t\t\t   ((pointer[i] & AUTH_WHO_MASK) == AUTH_WHO_CLIENT)\n\t\t\t   ? \"CLIENT\" : \"SERVER\",\n\t\t\t   ((pointer[i] & AUTH_HOW_MASK) == AUTH_HOW_MUTUAL)\n\t\t\t   ? \"MUTUAL\" : \"ONE-WAY\");\n\t\t  ++i;\n\t\t}\n\t      break;\n\n\t    case TELQUAL_NAME:\n\t      i = 2;\n\t      fprintf (NetTrace, \" NAME \\\"\");\n\t      while (i < length)\n\t\tputc (pointer[i++], NetTrace);\n\t      putc ('\"', NetTrace);\n\t      break;\n\n\t    default:\n\t      for (i = 2; i < length; i++)\n\t\tfprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t      break;\n\t    }\n\t  break;\n#endif\n\n#ifdef\tENCRYPTION\n\tcase TELOPT_ENCRYPT:\n\t  fprintf (NetTrace, \"ENCRYPT\");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[1])\n\t    {\n\t    case ENCRYPT_START:\n\t      fprintf (NetTrace, \" START\");\n\t      break;\n\n\t    case ENCRYPT_END:\n\t      fprintf (NetTrace, \" END\");\n\t      break;\n\n\t    case ENCRYPT_REQSTART:\n\t      fprintf (NetTrace, \" REQUEST-START\");\n\t      break;\n\n\t    case ENCRYPT_REQEND:\n\t      fprintf (NetTrace, \" REQUEST-END\");\n\t      break;\n\n\t    case ENCRYPT_IS:\n\t    case ENCRYPT_REPLY:\n\t      fprintf (NetTrace, \" %s \",\n\t\t       (pointer[1] == ENCRYPT_IS) ? \"IS\" : \"REPLY\");\n\t      if (length < 3)\n\t\t{\n\t\t  fprintf (NetTrace, \" (partial suboption??\\?)\");\n\t\t  break;\n\t\t}\n\t      if (ENCTYPE_NAME_OK (pointer[2]) && ENCTYPE_NAME (pointer[2]))\n\t\tfprintf (NetTrace, \"%s \", ENCTYPE_NAME (pointer[2]));\n\t      else\n\t\tfprintf (NetTrace, \" %d (unknown)\", pointer[2]);\n\n\t      encrypt_printsub (&pointer[1], length - 1, buf, sizeof (buf));\n\t      fprintf (NetTrace, \"%s\", buf);\n\t      break;\n\n\t    case ENCRYPT_SUPPORT:\n\t      i = 2;\n\t      fprintf (NetTrace, \" SUPPORT \");\n\t      while (i < length)\n\t\t{\n\t\t  if (ENCTYPE_NAME_OK (pointer[i]) && ENCTYPE_NAME (pointer[i]))\n\t\t    fprintf (NetTrace, \"%s \", ENCTYPE_NAME (pointer[i]));\n\t\t  else\n\t\t    fprintf (NetTrace, \"%d \", pointer[i]);\n\t\t  i++;\n\t\t}\n\t      break;\n\n\t    case ENCRYPT_ENC_KEYID:\n\t      fprintf (NetTrace, \" ENC_KEYID \");\n\t      goto encommon;\n\n\t    case ENCRYPT_DEC_KEYID:\n\t      fprintf (NetTrace, \" DEC_KEYID \");\n\t      goto encommon;\n\n\t    default:\n\t      fprintf (NetTrace, \" %d (unknown)\", pointer[1]);\n\t    encommon:\n\t      for (i = 2; i < length; i++)\n\t\tfprintf (NetTrace, \" %d\", pointer[i]);\n\t      break;\n\t    }\n\t  break;\n#endif /* ENCRYPTION */\n\n\tcase TELOPT_LINEMODE:\n\t  fprintf (NetTrace, \"LINEMODE \");\n\t  if (length < 2)\n\t    {\n\t      fprintf (NetTrace, \" (empty suboption??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[1])\n\t    {\n\t    case WILL:\n\t      fprintf (NetTrace, \"WILL \");\n\t      goto common;\n\t    case WONT:\n\t      fprintf (NetTrace, \"WONT \");\n\t      goto common;\n\t    case DO:\n\t      fprintf (NetTrace, \"DO \");\n\t      goto common;\n\t    case DONT:\n\t      fprintf (NetTrace, \"DONT \");\n\t    common:\n\t      if (length < 3)\n\t\t{\n\t\t  fprintf (NetTrace, \"(no option??\\?)\");\n\t\t  break;\n\t\t}\n\t      switch (pointer[2])\n\t\t{\n\t\tcase LM_FORWARDMASK:\n\t\t  fprintf (NetTrace, \"Forward Mask\");\n\t\t  for (i = 3; i < length; i++)\n\t\t    fprintf (NetTrace, \" %x\", pointer[i]);\n\t\t  break;\n\t\tdefault:\n\t\t  fprintf (NetTrace, \"%d (unknown)\", pointer[2]);\n\t\t  for (i = 3; i < length; i++)\n\t\t    fprintf (NetTrace, \" %d\", pointer[i]);\n\t\t  break;\n\t\t}\n\t      break;\n\n\t    case LM_SLC:\n\t      fprintf (NetTrace, \"SLC\");\n\t      for (i = 2; i < length - 2; i += 3)\n\t\t{\n\t\t  if (SLC_NAME_OK (pointer[i + SLC_FUNC]))\n\t\t    fprintf (NetTrace, \" %s\",\n\t\t\t     SLC_NAME (pointer[i + SLC_FUNC]));\n\t\t  else\n\t\t    fprintf (NetTrace, \" %d\", pointer[i + SLC_FUNC]);\n\t\t  switch (pointer[i + SLC_FLAGS] & SLC_LEVELBITS)\n\t\t    {\n\t\t    case SLC_NOSUPPORT:\n\t\t      fprintf (NetTrace, \" NOSUPPORT\");\n\t\t      break;\n\t\t    case SLC_CANTCHANGE:\n\t\t      fprintf (NetTrace, \" CANTCHANGE\");\n\t\t      break;\n\t\t    case SLC_VARIABLE:\n\t\t      fprintf (NetTrace, \" VARIABLE\");\n\t\t      break;\n\t\t    case SLC_DEFAULT:\n\t\t      fprintf (NetTrace, \" DEFAULT\");\n\t\t      break;\n\t\t    }\n\t\t  fprintf (NetTrace, \"%s%s%s\",\n\t\t\t   (pointer[i + SLC_FLAGS] & SLC_ACK)\n\t\t\t   ? \"|ACK\" : \"\",\n\t\t\t   (pointer[i + SLC_FLAGS] & SLC_FLUSHIN)\n\t\t\t   ? \"|FLUSHIN\" : \"\",\n\t\t\t   (pointer[i + SLC_FLAGS] & SLC_FLUSHOUT)\n\t\t\t   ?  \"|FLUSHOUT\" : \"\");\n\t\t  if (pointer[i + SLC_FLAGS] &\n\t\t      ~(SLC_ACK | SLC_FLUSHIN | SLC_FLUSHOUT | SLC_LEVELBITS))\n\t\t    fprintf (NetTrace, \"(0x%x)\", pointer[i + SLC_FLAGS]);\n\t\t  fprintf (NetTrace, \" %d;\", pointer[i + SLC_VALUE]);\n\t\t  if ((pointer[i + SLC_VALUE] == IAC) &&\n\t\t      (pointer[i + SLC_VALUE + 1] == IAC))\n\t\t    i++;\n\t\t}\n\t      for (; i < length; i++)\n\t\tfprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t      break;\n\n\t    case LM_MODE:\n\t      fprintf (NetTrace, \"MODE \");\n\t      if (length < 3)\n\t\t{\n\t\t  fprintf (NetTrace, \"(no mode??\\?)\");\n\t\t  break;\n\t\t}\n\t      {\n\t\tchar tbuf[64];\n\n\t\tsprintf (tbuf, \"%s%s%s%s%s\",\n\t\t\t pointer[2] & MODE_EDIT ? \"|EDIT\" : \"\",\n\t\t\t pointer[2] & MODE_TRAPSIG ? \"|TRAPSIG\" : \"\",\n\t\t\t pointer[2] & MODE_SOFT_TAB ? \"|SOFT_TAB\" : \"\",\n\t\t\t pointer[2] & MODE_LIT_ECHO ? \"|LIT_ECHO\" : \"\",\n\t\t\t pointer[2] & MODE_ACK ? \"|ACK\" : \"\");\n\t\tfprintf (NetTrace, \"%s\", tbuf[0] ? &tbuf[1] : \"0\");\n\t      }\n\t      if (pointer[2] & ~(MODE_MASK))\n\t\tfprintf (NetTrace, \" (0x%x)\", pointer[2]);\n\t      for (i = 3; i < length; i++)\n\t\tfprintf (NetTrace, \" ?0x%x?\", pointer[i]);\n\t      break;\n\t    default:\n\t      fprintf (NetTrace, \"%d (unknown)\", pointer[1]);\n\t      for (i = 2; i < length; i++)\n\t\tfprintf (NetTrace, \" %d\", pointer[i]);\n\t    }\n\t  break;\n\n\tcase TELOPT_STATUS:\n\t  {\n\t    register char *cp;\n\t    register int j, k;\n\n\t    fprintf (NetTrace, \"STATUS\");\n\n\t    switch (pointer[1])\n\t      {\n\t      default:\n\t\tif (pointer[1] == TELQUAL_SEND)\n\t\t  fprintf (NetTrace, \" SEND\");\n\t\telse\n\t\t  fprintf (NetTrace, \" %d (unknown)\", pointer[1]);\n\t\tfor (i = 2; i < length; i++)\n\t\t  fprintf (NetTrace, \" ?%d?\", pointer[i]);\n\t\tbreak;\n\t      case TELQUAL_IS:\n\t\tif (--want_status_response < 0)\n\t\t  want_status_response = 0;\n\t\tif (NetTrace == stdout)\n\t\t  fprintf (NetTrace, \" IS\\r\\n\");\n\t\telse\n\t\t  fprintf (NetTrace, \" IS\\n\");\n\n\t\tfor (i = 2; i < length; i++)\n\t\t  {\n\t\t    switch (pointer[i])\n\t\t      {\n\t\t      case DO:\n\t\t\tcp = \"DO\";\n\t\t\tgoto common2;\n\t\t      case DONT:\n\t\t\tcp = \"DONT\";\n\t\t\tgoto common2;\n\t\t      case WILL:\n\t\t\tcp = \"WILL\";\n\t\t\tgoto common2;\n\t\t      case WONT:\n\t\t\tcp = \"WONT\";\n\t\t\tgoto common2;\n\t\t      common2:\n\t\t\ti++;\n\t\t\tif (TELOPT_OK ((int) pointer[i]))\n\t\t\t  fprintf (NetTrace, \" %s %s\", cp,\n\t\t\t\t   TELOPT (pointer[i]));\n\t\t\telse\n\t\t\t  fprintf (NetTrace, \" %s %d\", cp, pointer[i]);\n\n\t\t\tif (NetTrace == stdout)\n\t\t\t  fprintf (NetTrace, \"\\r\\n\");\n\t\t\telse\n\t\t\t  fprintf (NetTrace, \"\\n\");\n\t\t\tbreak;\n\n\t\t      case SB:\n\t\t\tfprintf (NetTrace, \" SB \");\n\t\t\ti++;\n\t\t\tj = k = i;\n\t\t\twhile (j < length)\n\t\t\t  {\n\t\t\t    if (pointer[j] == SE)\n\t\t\t      {\n\t\t\t\tif (j + 1 == length)\n\t\t\t\t  break;\n\t\t\t\tif (pointer[j + 1] == SE)\n\t\t\t\t  j++;\n\t\t\t\telse\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t    pointer[k++] = pointer[j++];\n\t\t\t  }\n\t\t\tprintsub (0, &pointer[i], k - i);\n\t\t\tif (i < length)\n\t\t\t  {\n\t\t\t    fprintf (NetTrace, \" SE\");\n\t\t\t    i = j;\n\t\t\t  }\n\t\t\telse\n\t\t\t  i = j - 1;\n\n\t\t\tif (NetTrace == stdout)\n\t\t\t  fprintf (NetTrace, \"\\r\\n\");\n\t\t\telse\n\t\t\t  fprintf (NetTrace, \"\\n\");\n\n\t\t\tbreak;\n\n\t\t      default:\n\t\t\tfprintf (NetTrace, \" %d\", pointer[i]);\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\tbreak;\n\t      }\n\t    break;\n\t  }\n\n\tcase TELOPT_XDISPLOC:\n\t  fprintf (NetTrace, \"X-DISPLAY-LOCATION \");\n\t  switch (pointer[1])\n\t    {\n\t    case TELQUAL_IS:\n\t      fprintf (NetTrace, \"IS \\\"%.*s\\\"\", length - 2,\n\t\t       (char *) pointer + 2);\n\t      break;\n\t    case TELQUAL_SEND:\n\t      fprintf (NetTrace, \"SEND\");\n\t      break;\n\t    default:\n\t      fprintf (NetTrace, \"- unknown qualifier %d (0x%x).\",\n\t\t       pointer[1], pointer[1]);\n\t    }\n\t  break;\n\n\tcase TELOPT_NEW_ENVIRON:\n\t  fprintf (NetTrace, \"NEW-ENVIRON \");\n#ifdef\tOLD_ENVIRON\n\t  goto env_common1;\n\tcase TELOPT_OLD_ENVIRON:\n\t  fprintf (NetTrace, \"OLD-ENVIRON\");\n\tenv_common1:\n#endif\n\t  switch (pointer[1])\n\t    {\n\t    case TELQUAL_IS:\n\t      fprintf (NetTrace, \"IS \");\n\t      goto env_common;\n\t    case TELQUAL_SEND:\n\t      fprintf (NetTrace, \"SEND \");\n\t      goto env_common;\n\t    case TELQUAL_INFO:\n\t      fprintf (NetTrace, \"INFO \");\n\t    env_common:\n\t      {\n\t\tconst char *quote = \"\";\n#if defined ENV_HACK && defined OLD_ENVIRON\n\t\textern int old_env_var, old_env_value;\n#endif\n\t\tfor (i = 2; i < length; i++)\n\t\t  {\n\t\t    switch (pointer[i])\n\t\t      {\n\t\t      case NEW_ENV_VALUE:\n#ifdef OLD_ENVIRON\n\t\t\t/* case NEW_ENV_OVAR: */\n\t\t\tif (pointer[0] == TELOPT_OLD_ENVIRON)\n\t\t\t  {\n# ifdef\tENV_HACK\n\t\t\t    if (old_env_var == OLD_ENV_VALUE)\n\t\t\t      fprintf (NetTrace, \"%s(VALUE) \", quote);\n\t\t\t    else\n# endif\n\t\t\t      fprintf (NetTrace, \"%sVAR \", quote);\n\t\t\t  }\n\t\t\telse\n#endif /* OLD_ENVIRON */\n\t\t\t  fprintf (NetTrace, \"%sVALUE \", quote);\n\t\t\tquote = \"\";\n\t\t\tbreak;\n\n\t\t      case NEW_ENV_VAR:\n#ifdef OLD_ENVIRON\n\t\t\t/* case OLD_ENV_VALUE: */\n\t\t\tif (pointer[0] == TELOPT_OLD_ENVIRON)\n\t\t\t  {\n# ifdef\tENV_HACK\n\t\t\t    if (old_env_value == OLD_ENV_VAR)\n\t\t\t      fprintf (NetTrace, \"%s(VAR) \", quote);\n\t\t\t    else\n# endif\n\t\t\t      fprintf (NetTrace, \"%sVALUE \", quote);\n\t\t\t  }\n\t\t\telse\n#endif /* OLD_ENVIRON */\n\t\t\t  fprintf (NetTrace, \"%sVAR \", quote);\n\t\t\tquote = \"\";\n\t\t\tbreak;\n\n\t\t      case ENV_ESC:\n\t\t\tfprintf (NetTrace, \"%sESC \", quote);\n\t\t\tquote = \"\";\n\t\t\tbreak;\n\n\t\t      case ENV_USERVAR:\n\t\t\tfprintf (NetTrace, \"%sUSERVAR \", quote);\n\t\t\tquote = \"\";\n\t\t\tbreak;\n\n\t\t      default:\n\t\t\tif (isprint (pointer[i]) && pointer[i] != '\"')\n\t\t\t  {\n\t\t\t    if (quote[0] == '\\0')\n\t\t\t      {\n\t\t\t\tputc ('\"', NetTrace);\n\t\t\t\tquote = \"\\\" \";\n\t\t\t      }\n\t\t\t    putc (pointer[i], NetTrace);\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t    fprintf (NetTrace, \"%s%03o \", quote, pointer[i]);\n\t\t\t    quote = \"\";\n\t\t\t  }\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\tif (quote[0] != '\\0')\n\t\t  putc ('\"', NetTrace);\n\t\tbreak;\n\t      }\n\t    }\n\t  break;\n\n\tdefault:\n\t  if (TELOPT_OK (pointer[0]))\n\t    fprintf (NetTrace, \"%s (unknown)\", TELOPT (pointer[0]));\n\t  else\n\t    fprintf (NetTrace, \"%d (unknown)\", pointer[0]);\n\t  for (i = 1; i < length; i++)\n\t    fprintf (NetTrace, \" %d\", pointer[i]);\n\t  break;\n\t}\n      if (direction)\n\t{\n\t  if (NetTrace == stdout)\n\t    fprintf (NetTrace, \"\\r\\n\");\n\t  else\n\t    fprintf (NetTrace, \"\\n\");\n\t}\n      if (NetTrace == stdout)\n\tfflush (NetTrace);\n    }\n}",
      "lines": 646,
      "depth": 28,
      "decorators": [
        "void"
      ]
    },
    "EmptyTerminal": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1021,
        1
      ],
      "content": "void\nEmptyTerminal (void)\n{\n#if defined unix || defined __unix || defined __unix__\n  fd_set o;\n\n  FD_ZERO (&o);\n#endif /* unix || __unix || __unix__ */\n\n  if (TTYBYTES () == 0)\n    {\n#if defined unix || defined __unix || defined __unix__\n      FD_SET (tout, &o);\n      select (tout + 1, (fd_set *) 0, &o, (fd_set *) 0, (struct timeval *) 0);\t/* wait for TTLOWAT */\n#endif /* unix || __unix || __unix__ */\n    }\n  else\n    {\n      while (TTYBYTES ())\n\t{\n\t  ttyflush (0);\n#if defined unix || defined __unix || defined __unix__\n\t  FD_SET (tout, &o);\n\t  select (tout + 1, (fd_set *) 0, &o, (fd_set *) 0, (struct timeval *) 0);\t/* wait for TTLOWAT */\n#endif /* unix || __unix || __unix__ */\n\t}\n    }\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "SetForExit": {
      "start_point": [
        1023,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nSetForExit (void)\n{\n  setconnmode (0);\n#if defined TN3270\n  if (In3270)\n    {\n      Finish3270 ();\n    }\n#else /* defined(TN3270) */\n  do\n    {\n      telrcv ();\t\t/* Process any incoming data */\n      EmptyTerminal ();\n    }\n  while (ring_full_count (&netiring));\t/* While there is any */\n#endif /* defined(TN3270) */\n  setcommandmode ();\n  fflush (stdout);\n  fflush (stderr);\n#if defined TN3270\n  if (In3270)\n    {\n      StopScreen (1);\n    }\n#endif /* defined(TN3270) */\n  setconnmode (0);\n  EmptyTerminal ();\t\t/* Flush the path to the tty */\n  setcommandmode ();\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "Exit": {
      "start_point": [
        1054,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "void\nExit (int returnCode)\n{\n  SetForExit ();\n  exit (returnCode);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "ExitString": {
      "start_point": [
        1061,
        0
      ],
      "end_point": [
        1067,
        1
      ],
      "content": "void\nExitString (char *string, int returnCode)\n{\n  SetForExit ();\n  fwrite (string, 1, strlen (string), stderr);\n  exit (returnCode);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/pty.c": {
    "setup_utmp": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\nsetup_utmp (char *line, char *host)\n{\n  char *ut_id = utmp_ptsid (line, \"tn\");\n  utmp_init (line + sizeof (PATH_TTY_PFX) - 1, \".telnet\", ut_id, host);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "startslave": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\nstartslave (char *host, int autologin, char *autoname)\n{\n  pid_t pid;\n  int master;\n\n#ifdef AUTHENTICATION\n  if (!autoname || !autoname[0])\n    autologin = 0;\n\n  if (autologin < auth_level)\n    {\n      fatal (net, \"Authorization failed\");\n      exit (EXIT_FAILURE);\n    }\n#else /* !AUTHENTICATION */\n  (void) autoname;\t/* Silence warnings.  */\n#endif\n\n  pid = forkpty (&master, line, NULL, NULL);\n  if (pid < 0)\n    {\n      if (errno == ENOENT)\n\t{\n\t  syslog (LOG_ERR, \"Out of ptys\");\n\t  fatal (net, \"Out of ptys\");\n\t}\n      else\n\t{\n\t  syslog (LOG_ERR, \"forkpty: %m\");\n\t  fatal (net, \"Forkpty\");\n\t}\n    }\n\n  if (pid == 0)\n    {\n      /* Child */\n      if (net > 2)\n\tclose (net);\n\n      setup_utmp (line, host);\n      start_login (host, autologin, line);\n    }\n\n  /* Master */\n  return master;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "scrub_env": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void\nscrub_env (void)\n{\n  register char **cpp, **cpp2;\n\n  for (cpp2 = cpp = environ; *cpp; cpp++)\n    {\n      if (strncmp (*cpp, \"LD_\", 3)\n\t  && strncmp (*cpp, \"_RLD_\", 5)\n\t  && strncmp (*cpp, \"LIBPATH=\", 8) && strncmp (*cpp, \"IFS=\", 4))\n\t*cpp2++ = *cpp;\n    }\n  *cpp2 = 0;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "start_login": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\nstart_login (char *host, int autologin, char *name)\n{\n  char *cmd;\n  int argc;\n  char **argv;\n\n  (void) host;\t\t/* Silence warnings.  Diagnostic use?  */\n  (void) autologin;\n  (void) name;\n\n  scrub_env ();\n\n  /* Set the environment variable \"LINEMODE\" to indicate our linemode */\n  if (lmodetype == REAL_LINEMODE)\n    setenv (\"LINEMODE\", \"real\", 1);\n  else if (lmodetype == KLUDGE_LINEMODE || lmodetype == KLUDGE_OK)\n    setenv (\"LINEMODE\", \"kludge\", 1);\n\n  cmd = expand_line (login_invocation);\n  if (!cmd)\n    fatal (net, \"can't expand login command line\");\n  argcv_get (cmd, \"\", &argc, &argv);\n  execv (argv[0], argv);\n  syslog (LOG_ERR, \"%s: %m\\n\", cmd);\n  fatalperror (net, cmd);\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cleanup": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void\ncleanup (int sig)\n{\n  int status = EXIT_FAILURE;\n  char *p;\n\n  if (sig == SIGCHLD)\n    {\n      pid_t pid = waitpid ((pid_t) - 1, &status, WNOHANG);\n      syslog (LOG_INFO, \"child process %ld exited: %d\",\n\t      (long) pid, WEXITSTATUS (status));\n\n      status = WEXITSTATUS (status);\n    }\n  else if (sig == SIGHUP)\n    status = EXIT_SUCCESS;\t/* Response to TELOPT_LOGOUT.  */\n\n  p = line + sizeof (PATH_TTY_PFX) - 1;\n  utmp_logout (p);\n  chmod (line, 0644);\n  chown (line, 0, 0);\n  shutdown (net, 2);\n  exit (status);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/slc.c": {
    "send_slc": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\nsend_slc (void)\n{\n  register int i;\n\n  /*\n   * Send out list of triplets of special characters\n   * to client.  We only send info on the characters\n   * that are currently supported.\n   */\n  for (i = 1; i <= NSLC; i++)\n    {\n      if ((slctab[i].defset.flag & SLC_LEVELBITS) == SLC_NOSUPPORT)\n\tcontinue;\n      add_slc ((unsigned char) i, slctab[i].current.flag,\n\t       slctab[i].current.val);\n    }\n\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "default_slc": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\ndefault_slc (void)\n{\n  register int i;\n\n  for (i = 1; i <= NSLC; i++)\n    {\n      slctab[i].current.val = slctab[i].defset.val;\n      if (slctab[i].current.val == (cc_t) (_POSIX_VDISABLE))\n\tslctab[i].current.flag = SLC_NOSUPPORT;\n      else\n\tslctab[i].current.flag = slctab[i].defset.flag;\n      if (slctab[i].sptr)\n\t{\n\t  *(slctab[i].sptr) = slctab[i].defset.val;\n\t}\n    }\n  slcchange = 1;\n\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "get_slc_defaults": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\nget_slc_defaults (void)\n{\n  register int i;\n\n  init_termbuf ();\n\n  for (i = 1; i <= NSLC; i++)\n    {\n      slctab[i].defset.flag =\n\tspcset (i, &slctab[i].defset.val, &slctab[i].sptr);\n      slctab[i].current.flag = SLC_NOSUPPORT;\n      slctab[i].current.val = 0;\n    }\n\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "add_slc": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "void\nadd_slc (register char func, register char flag, register cc_t val)\n{\n\n  if ((*slcptr++ = (unsigned char) func) == 0xff)\n    *slcptr++ = 0xff;\n\n  if ((*slcptr++ = (unsigned char) flag) == 0xff)\n    *slcptr++ = 0xff;\n\n  if ((*slcptr++ = (unsigned char) val) == 0xff)\n    *slcptr++ = 0xff;\n\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "start_slc": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\nstart_slc (register int getit)\n{\n\n  slcchange = 0;\n  if (getit)\n    init_termbuf ();\n  sprintf ((char *) slcbuf, \"%c%c%c%c\", IAC, SB, TELOPT_LINEMODE, LM_SLC);\n  slcptr = slcbuf + 4;\n\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "end_slc": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int\nend_slc (register unsigned char **bufp)\n{\n  register int len;\n  void netflush (void);\n\n  /*\n   * If a change has occured, store the new terminal control\n   * structures back to the terminal driver.\n   */\n  if (slcchange)\n    {\n      set_termbuf ();\n    }\n\n  /*\n   * If the pty state has not yet been fully processed and there is a\n   * deferred slc request from the client, then do not send any\n   * sort of slc negotiation now.  We will respond to the client's\n   * request very soon.\n   */\n  if (def_slcbuf && (terminit () == 0))\n    {\n      return (0);\n    }\n\n  if (slcptr > (slcbuf + 4))\n    {\n      if (bufp)\n\t{\n\t  *bufp = &slcbuf[4];\n\t  return (slcptr - slcbuf - 4);\n\t}\n      else\n\t{\n\t  sprintf ((char *) slcptr, \"%c%c\", IAC, SE);\n\t  slcptr += 2;\n\t  len = slcptr - slcbuf;\n\t  net_output_datalen (slcbuf, len);\n\t  netflush ();\t\t/* force it out immediately */\n\t  DEBUG (debug_options, 1, printsub ('>', slcbuf + 2, len - 2));\n\t}\n    }\n  return (0);\n\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "process_slc": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "void\nprocess_slc (register unsigned char func, register unsigned char flag,\n\t     register cc_t val)\n{\n  register int hislevel, mylevel, ack;\n\n  /*\n   * Ensure that we know something about this function\n   */\n  if (func > NSLC)\n    {\n      add_slc (func, SLC_NOSUPPORT, 0);\n      return;\n    }\n\n  /*\n   * Process the special case requests of 0 SLC_DEFAULT 0\n   * and 0 SLC_VARIABLE 0.  Be a little forgiving here, don't\n   * worry about whether the value is actually 0 or not.\n   */\n  if (func == 0)\n    {\n      if ((flag = flag & SLC_LEVELBITS) == SLC_DEFAULT)\n\t{\n\t  default_slc ();\n\t  send_slc ();\n\t}\n      else if (flag == SLC_VARIABLE)\n\t{\n\t  send_slc ();\n\t}\n      return;\n    }\n\n  /*\n   * Appears to be a function that we know something about.  So\n   * get on with it and see what we know.\n   */\n\n  hislevel = flag & SLC_LEVELBITS;\n  mylevel = slctab[func].current.flag & SLC_LEVELBITS;\n  ack = flag & SLC_ACK;\n  /*\n   * ignore the command if:\n   * the function value and level are the same as what we already have;\n   * or the level is the same and the ack bit is set\n   */\n  if (hislevel == mylevel && (val == slctab[func].current.val || ack))\n    {\n      return;\n    }\n  else if (ack)\n    {\n      /*\n       * If we get here, we got an ack, but the levels don't match.\n       * This shouldn't happen.  If it does, it is probably because\n       * we have sent two requests to set a variable without getting\n       * a response between them, and this is the first response.\n       * So, ignore it, and wait for the next response.\n       */\n      return;\n    }\n  else\n    {\n      change_slc (func, flag, val);\n    }\n\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "change_slc": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "void\nchange_slc (register char func_c, register char flag, register cc_t val)\n{\n  register int func = func_c;\n  register int hislevel, mylevel;\n\n  hislevel = flag & SLC_LEVELBITS;\n  mylevel = slctab[func].defset.flag & SLC_LEVELBITS;\n  /*\n   * If client is setting a function to NOSUPPORT\n   * or DEFAULT, then we can easily and directly\n   * accomodate the request.\n   */\n  if (hislevel == SLC_NOSUPPORT)\n    {\n      slctab[func].current.flag = flag;\n      slctab[func].current.val = (cc_t) _POSIX_VDISABLE;\n      flag |= SLC_ACK;\n      add_slc (func, flag, val);\n      return;\n    }\n  if (hislevel == SLC_DEFAULT)\n    {\n      /*\n       * Special case here.  If client tells us to use\n       * the default on a function we don't support, then\n       * return NOSUPPORT instead of what we may have as a\n       * default level of DEFAULT.\n       */\n      if (mylevel == SLC_DEFAULT)\n\t{\n\t  slctab[func].current.flag = SLC_NOSUPPORT;\n\t}\n      else\n\t{\n\t  slctab[func].current.flag = slctab[func].defset.flag;\n\t}\n      slctab[func].current.val = slctab[func].defset.val;\n      add_slc (func, slctab[func].current.flag, slctab[func].current.val);\n      return;\n    }\n\n  /*\n   * Client wants us to change to a new value or he\n   * is telling us that he can't change to our value.\n   * Some of the slc's we support and can change,\n   * some we do support but can't change,\n   * and others we don't support at all.\n   * If we can change it then we have a pointer to\n   * the place to put the new value, so change it,\n   * otherwise, continue the negotiation.\n   */\n  if (slctab[func].sptr)\n    {\n      /*\n       * We can change this one.\n       */\n      slctab[func].current.val = val;\n      *(slctab[func].sptr) = val;\n      slctab[func].current.flag = flag;\n      flag |= SLC_ACK;\n      slcchange = 1;\n      add_slc (func, flag, val);\n    }\n  else\n    {\n      /*\n       * It is not possible for us to support this\n       * request as he asks.\n       *\n       * If our level is DEFAULT, then just ack whatever was\n       * sent.\n       *\n       * If he can't change and we can't change,\n       * then degenerate to NOSUPPORT.\n       *\n       * Otherwise we send our level back to him, (CANTCHANGE\n       * or NOSUPPORT) and if CANTCHANGE, send\n       * our value as well.\n       */\n      if (mylevel == SLC_DEFAULT)\n\t{\n\t  slctab[func].current.flag = flag;\n\t  slctab[func].current.val = val;\n\t  flag |= SLC_ACK;\n\t}\n      else if (hislevel == SLC_CANTCHANGE && mylevel == SLC_CANTCHANGE)\n\t{\n\t  flag &= ~SLC_LEVELBITS;\n\t  flag |= SLC_NOSUPPORT;\n\t  slctab[func].current.flag = flag;\n\t}\n      else\n\t{\n\t  flag &= ~SLC_LEVELBITS;\n\t  flag |= mylevel;\n\t  slctab[func].current.flag = flag;\n\t  if (mylevel == SLC_CANTCHANGE)\n\t    {\n\t      slctab[func].current.val = slctab[func].defset.val;\n\t      val = slctab[func].current.val;\n\t    }\n\t}\n      add_slc (func, flag, val);\n    }\n\n}",
      "lines": 107,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "check_slc": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        443,
        1
      ],
      "content": "void\ncheck_slc (void)\n{\n  register int i;\n\n  for (i = 1; i <= NSLC; i++)\n    {\n      if (i == SLC_EOF && term_change_eof ())\n\tcontinue;\n      if (slctab[i].sptr && (*(slctab[i].sptr) != slctab[i].current.val))\n\t{\n\t  slctab[i].current.val = *(slctab[i].sptr);\n\t  if (*(slctab[i].sptr) == (cc_t) _POSIX_VDISABLE)\n\t    slctab[i].current.flag = SLC_NOSUPPORT;\n\t  else\n\t    slctab[i].current.flag = slctab[i].defset.flag;\n\t  add_slc ((unsigned char) i, slctab[i].current.flag,\n\t\t   slctab[i].current.val);\n\t}\n    }\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "do_opt_slc": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "void\ndo_opt_slc (register unsigned char *ptr, register int len)\n{\n  register unsigned char func, flag;\n  cc_t val;\n  register unsigned char *end = ptr + len;\n\n  if (terminit ())\n    {\t\t\t\t/* go ahead */\n      while (ptr < end)\n\t{\n\t  func = *ptr++;\n\t  if (ptr >= end)\n\t    break;\n\t  flag = *ptr++;\n\t  if (ptr >= end)\n\t    break;\n\t  val = (cc_t) * ptr++;\n\n\t  process_slc (func, flag, val);\n\n\t}\n    }\n  else\n    {\n      /*\n       * save this slc buffer if it is the first, otherwise dump\n       * it.\n       */\n      if (def_slcbuf == (unsigned char *) 0)\n\t{\n\t  def_slclen = len;\n\t  def_slcbuf = (unsigned char *) malloc ((unsigned) len);\n\t  if (def_slcbuf == (unsigned char *) 0)\n\t    return;\t\t/* too bad */\n\t  memmove (def_slcbuf, ptr, len);\n\t}\n    }\n\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "deferslc": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "void\ndeferslc (void)\n{\n  if (def_slcbuf)\n    {\n      start_slc (1);\n      do_opt_slc (def_slcbuf, def_slclen);\n      end_slc (0);\n      free (def_slcbuf);\n      def_slcbuf = (unsigned char *) 0;\n      def_slclen = 0;\n    }\n\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/state.c": {
    "send_eof": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\nsend_eof (void)\n{\n  init_termbuf ();\n  term_send_eof ();\n  pty_output_byte (slctab[SLC_EOF].sptr ?\n\t\t   (unsigned char) *slctab[SLC_EOF].sptr : '\\004');\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recv_ayt": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static void\nrecv_ayt (void)\n{\n#if defined SIGINFO && defined TCSIG\n  if (slctab[SLC_AYT].sptr && *slctab[SLC_AYT].sptr != _POSIX_VDISABLE)\n    {\n      ioctl (pty, TCSIG, (char *) SIGINFO);\n      return;\n    }\n#endif\n  net_output_data (\"\\r\\n[Yes]\\r\\n\");\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_susp": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static void\nsend_susp (void)\n{\n#ifdef\tSIGTSTP\n  ptyflush ();\t\t\t/* half-hearted */\n# ifdef\tTCSIG\n  ioctl (pty, TCSIG, (char *) SIGTSTP);\n# else /* TCSIG */\n  pty_output_byte (slctab[SLC_SUSP].sptr ?\n\t\t   (unsigned char) *slctab[SLC_SUSP].sptr : '\\032');\n# endif\t/* TCSIG */\n#endif /* SIGTSTP */\n}",
      "lines": 13,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_brk": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void\nsend_brk (void)\n{\n  ptyflush ();\t\t\t/* half-hearted */\n#ifdef\tTCSIG\n  ioctl (pty, TCSIG, (char *) SIGQUIT);\n#else /* TCSIG */\n  init_termbuf ();\n  pty_output_byte (slctab[SLC_ABORT].sptr ?\n\t\t   (unsigned char) *slctab[SLC_ABORT].sptr : '\\034');\n#endif /* TCSIG */\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "send_intr": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static void\nsend_intr (void)\n{\n  ptyflush ();\t\t\t/* half-hearted */\n\n#if defined HAVE_STREAMSPTY && defined TIOCSIGNAL\n  /* Streams PTY style ioctl to post a signal */\n  {\n    int sig = SIGINT;\n    ioctl (pty, TIOCSIGNAL, &sig);\n    ioctl (pty, I_FLUSH, FLUSHR);\n  }\n#else\n# ifdef\tTCSIG\n  ioctl (pty, TCSIG, (char *) SIGINT);\n# else /* TCSIG */\n  init_termbuf ();\n  pty_output_byte (slctab[SLC_IP].sptr ?\n\t\t   (unsigned char) *slctab[SLC_IP].sptr : '\\177');\n# endif\t/* TCSIG */\n#endif\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "telrcv": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "void\ntelrcv (void)\n{\n  register int c;\n  static int state = TS_DATA;\n\n  while ((net_input_level () > 0) & !pty_buffer_is_full ())\n    {\n      c = net_get_char (0);\n#ifdef\tENCRYPTION\n      if (decrypt_input)\n\tc = (*decrypt_input) (c);\n#endif /* ENCRYPTION */\n      switch (state)\n\t{\n\n\tcase TS_CR:\n\t  state = TS_DATA;\n\t  /* Strip off \\n or \\0 after a \\r */\n\t  if ((c == 0) || (c == '\\n'))\n\t    break;\n\t  /* FALL THROUGH */\n\n\tcase TS_DATA:\n\t  if (c == IAC)\n\t    {\n\t      state = TS_IAC;\n\t      break;\n\t    }\n\t  /*\n\t   * We now map \\r\\n ==> \\r for pragmatic reasons.\n\t   * Many client implementations send \\r\\n when\n\t   * the user hits the CarriageReturn key.\n\t   *\n\t   * We USED to map \\r\\n ==> \\n, since \\r\\n says\n\t   * that we want to be in column 1 of the next\n\t   * printable line, and \\n is the standard\n\t   * unix way of saying that (\\r is only good\n\t   * if CRMOD is set, which it normally is).\n\t   */\n\t  if ((c == '\\r') && his_state_is_wont (TELOPT_BINARY))\n\t    {\n\t      int nc = net_get_char (1);\n#ifdef\tENCRYPTION\n\t      if (decrypt_input)\n\t\tnc = (*decrypt_input) (nc & 0xff);\n#endif /* ENCRYPTION */\n\t      /*\n\t       * If we are operating in linemode,\n\t       * convert to local end-of-line.\n\t       */\n\t      if (linemode\n\t\t  && net_input_level () > 0\n\t\t  && (('\\n' == nc) || (!nc && tty_iscrnl ())))\n\t\t{\n\t\t  net_get_char (0);\t/* Remove from the buffer */\n\t\t  c = '\\n';\n\t\t}\n\t      else\n\t\t{\n#ifdef\tENCRYPTION\n\t\t  if (decrypt_input)\n\t\t    (*decrypt_input) (-1);\n#endif /* ENCRYPTION */\n\t\t  state = TS_CR;\n\t\t}\n\t    }\n\t  pty_output_byte (c);\n\t  break;\n\n\tcase TS_IAC:\n\tgotiac:\n\t  switch (c)\n\t    {\n\n\t      /*\n\t       * Send the process on the pty side an\n\t       * interrupt.  Do this with a NULL or\n\t       * interrupt char; depending on the tty mode.\n\t       */\n\t    case IP:\n\t      DEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t      send_intr ();\n\t      break;\n\n\t    case BREAK:\n\t      DEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t      send_brk ();\n\t      break;\n\n\t      /*\n\t       * Are You There?\n\t       */\n\t    case AYT:\n\t      DEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t      recv_ayt ();\n\t      break;\n\n\t      /*\n\t       * Abort Output\n\t       */\n\t    case AO:\n\t      {\n\t\tDEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t\tptyflush ();\t/* half-hearted */\n\t\tinit_termbuf ();\n\n\t\tif (slctab[SLC_AO].sptr\n\t\t    && *slctab[SLC_AO].sptr != (cc_t) (_POSIX_VDISABLE))\n\t\t  pty_output_byte (*slctab[SLC_AO].sptr);\n\n\t\tnetclear ();\t/* clear buffer back */\n\t\tnet_output_data (\"%c%c\", IAC, DM);\n\t\tset_neturg ();\n\t\tDEBUG (debug_options, 1, printoption (\"td: send IAC\", DM));\n\t\tbreak;\n\t      }\n\n\t      /*\n\t       * Erase Character and\n\t       * Erase Line\n\t       */\n\t    case EC:\n\t    case EL:\n\t      {\n\t\tcc_t ch;\n\n\t\tDEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t\tptyflush ();\t/* half-hearted */\n\t\tinit_termbuf ();\n\t\tif (c == EC)\n\t\t  ch = *slctab[SLC_EC].sptr;\n\t\telse\n\t\t  ch = *slctab[SLC_EL].sptr;\n\t\tif (ch != (cc_t) (_POSIX_VDISABLE))\n\t\t  pty_output_byte ((unsigned char) ch);\n\t\tbreak;\n\t      }\n\n\t      /*\n\t       * Check for urgent data...\n\t       */\n\t    case DM:\n\t      DEBUG (debug_options, 1, printoption (\"td: recv IAC\", c));\n\t      SYNCHing = stilloob (net);\n\t      settimer (gotDM);\n\t      break;\n\n\t      /*\n\t       * Begin option subnegotiation...\n\t       */\n\t    case SB:\n\t      state = TS_SB;\n\t      SB_CLEAR ();\n\t      continue;\n\n\t    case WILL:\n\t      state = TS_WILL;\n\t      continue;\n\n\t    case WONT:\n\t      state = TS_WONT;\n\t      continue;\n\n\t    case DO:\n\t      state = TS_DO;\n\t      continue;\n\n\t    case DONT:\n\t      state = TS_DONT;\n\t      continue;\n\t    case EOR:\n\t      if (his_state_is_will (TELOPT_EOR))\n\t\tsend_eof ();\n\t      break;\n\n\t      /*\n\t       * Handle RFC 10xx Telnet linemode option additions\n\t       * to command stream (EOF, SUSP, ABORT).\n\t       */\n\t    case xEOF:\n\t      send_eof ();\n\t      break;\n\n\t    case SUSP:\n\t      send_susp ();\n\t      break;\n\n\t    case ABORT:\n\t      send_brk ();\n\t      break;\n\n\t    case IAC:\n\t      pty_output_byte (c);\n\t      break;\n\t    }\n\t  state = TS_DATA;\n\t  break;\n\n\tcase TS_SB:\n\t  if (c == IAC)\n\t    state = TS_SE;\n\t  else\n\t    SB_ACCUM (c);\n\t  break;\n\n\tcase TS_SE:\n\t  if (c != SE)\n\t    {\n\t      if (c != IAC)\n\t\t{\n\t\t  /*\n\t\t   * bad form of suboption negotiation.\n\t\t   * handle it in such a way as to avoid\n\t\t   * damage to local state.  Parse\n\t\t   * suboption buffer found so far,\n\t\t   * then treat remaining stream as\n\t\t   * another command sequence.\n\t\t   */\n\n\t\t  /* for DIAGNOSTICS */\n\t\t  SB_ACCUM (IAC);\n\t\t  SB_ACCUM (c);\n\t\t  subpointer -= 2;\n\n\t\t  SB_TERM ();\n\t\t  suboption ();\n\t\t  state = TS_IAC;\n\t\t  goto gotiac;\n\t\t}\n\t      SB_ACCUM (c);\n\t      state = TS_SB;\n\t    }\n\t  else\n\t    {\n\t      /* for DIAGNOSTICS */\n\t      SB_ACCUM (IAC);\n\t      SB_ACCUM (SE);\n\t      subpointer -= 2;\n\n\t      SB_TERM ();\n\t      suboption ();\t/* handle sub-option */\n\t      state = TS_DATA;\n\t    }\n\t  break;\n\n\tcase TS_WILL:\n\t  willoption (c);\n\t  state = TS_DATA;\n\t  continue;\n\n\tcase TS_WONT:\n\t  wontoption (c);\n\t  state = TS_DATA;\n\t  continue;\n\n\tcase TS_DO:\n\t  dooption (c);\n\t  state = TS_DATA;\n\t  continue;\n\n\tcase TS_DONT:\n\t  dontoption (c);\n\t  state = TS_DATA;\n\t  continue;\n\n\tdefault:\n\t  syslog (LOG_ERR, \"telnetd: panic state=%d\\n\", state);\n\t  printf (\"telnetd: panic state=%d\\n\", state);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n}",
      "lines": 273,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "send_do": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "void\nsend_do (int option, int init)\n{\n  if (init)\n    {\n      if ((do_dont_resp[option] == 0 && his_state_is_will (option)) ||\n\t  his_want_state_is_will (option))\n\treturn;\n      /*\n       * Special case for TELOPT_TM:  We send a DO, but pretend\n       * that we sent a DONT, so that we can send more DOs if\n       * we want to.\n       */\n      if (option == TELOPT_TM)\n\tset_his_want_state_wont (option);\n      else\n\tset_his_want_state_will (option);\n      do_dont_resp[option]++;\n    }\n  net_output_data (doopt, option);\n\n  DEBUG (debug_options, 1, printoption (\"td: send do\", option));\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "willoption": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "void\nwilloption (int option)\n{\n  int changeok = 0;\n  void (*func) () = 0;\n\n  /*\n   * process input from peer.\n   */\n\n  DEBUG (debug_options, 1, printoption (\"td: recv will\", option));\n\n  if (do_dont_resp[option])\n    {\n      do_dont_resp[option]--;\n      if (do_dont_resp[option] && his_state_is_will (option))\n\tdo_dont_resp[option]--;\n    }\n  if (do_dont_resp[option] == 0)\n    {\n      if (his_want_state_is_wont (option))\n\t{\n\t  switch (option)\n\t    {\n\n\t    case TELOPT_BINARY:\n\t      init_termbuf ();\n\t      tty_binaryin (1);\n\t      set_termbuf ();\n\t      changeok++;\n\t      break;\n\n\t    case TELOPT_ECHO:\n\t      /*\n\t       * See comments below for more info.\n\t       */\n\t      not42 = 0;\t/* looks like a 4.2 system */\n\t      break;\n\n\t    case TELOPT_TM:\n\t      /*\n\t       * This telnetd implementation does not really\n\t       * support timing marks, it just uses them to\n\t       * support the kludge linemode stuff.  If we\n\t       * receive a will or wont TM in response to our\n\t       * do TM request that may have been sent to\n\t       * determine kludge linemode support, process\n\t       * it, otherwise TM should get a negative\n\t       * response back.\n\t       */\n\t      /*\n\t       * Handle the linemode kludge stuff.\n\t       * If we are not currently supporting any\n\t       * linemode at all, then we assume that this\n\t       * is the client telling us to use kludge\n\t       * linemode in response to our query.  Set the\n\t       * linemode type that is to be supported, note\n\t       * that the client wishes to use linemode, and\n\t       * eat the will TM as though it never arrived.\n\t       */\n\t      if (lmodetype < KLUDGE_LINEMODE)\n\t\t{\n\t\t  lmodetype = KLUDGE_LINEMODE;\n\t\t  clientstat (TELOPT_LINEMODE, WILL, 0);\n\t\t  send_wont (TELOPT_SGA, 1);\n\t\t}\n\t      else if (lmodetype == NO_AUTOKLUDGE)\n\t\tlmodetype = KLUDGE_OK;\n\n\t      /*\n\t       * We never respond to a WILL TM, and\n\t       * we leave the state WONT.\n\t       */\n\t      return;\n\n\t    case TELOPT_LFLOW:\n\t      /*\n\t       * If we are going to support flow control\n\t       * option, then don't worry peer that we can't\n\t       * change the flow control characters.\n\t       */\n\t      slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;\n\t      slctab[SLC_XON].defset.flag |= SLC_DEFAULT;\n\t      slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;\n\t      slctab[SLC_XOFF].defset.flag |= SLC_DEFAULT;\n\t    case TELOPT_TTYPE:\n\t    case TELOPT_SGA:\n\t    case TELOPT_NAWS:\n\t    case TELOPT_TSPEED:\n\t    case TELOPT_XDISPLOC:\n\t    case TELOPT_NEW_ENVIRON:\n\t    case TELOPT_OLD_ENVIRON:\n\t      changeok++;\n\t      break;\n\n\t    case TELOPT_LINEMODE:\n\t      /*\n\t       * Note client's desire to use linemode.\n\t       */\n\t      lmodetype = REAL_LINEMODE;\n\t      func = doclientstat;\n\t      changeok++;\n\t      break;\n\n#ifdef\tAUTHENTICATION\n\t    case TELOPT_AUTHENTICATION:\n\t      func = auth_request;\n\t      changeok++;\n\t      break;\n#endif\n\n#ifdef\tENCRYPTION\n\t    case TELOPT_ENCRYPT:\n\t      func = encrypt_send_support;\n\t      changeok++;\n\t      break;\n#endif /* ENCRYPTION */\n\n\t    default:\n\t      break;\n\t    }\n\t  if (changeok)\n\t    {\n\t      set_his_want_state_will (option);\n\t      send_do (option, 0);\n\t    }\n\t  else\n\t    {\n\t      do_dont_resp[option]++;\n\t      send_dont (option, 0);\n\t    }\n\t}\n      else\n\t{\n\t  /*\n\t   * Option processing that should happen when\n\t   * we receive conformation of a change in\n\t   * state that we had requested.\n\t   */\n\t  switch (option)\n\t    {\n\t    case TELOPT_ECHO:\n\t      not42 = 0;\t/* looks like a 4.2 system */\n\t      /*\n\t       * Egads, he responded \"WILL ECHO\".  Turn\n\t       * it off right now!\n\t       */\n\t      send_dont (option, 1);\n\t      /*\n\t       * \"WILL ECHO\".  Kludge upon kludge!\n\t       * A 4.2 client is now echoing user input at\n\t       * the tty.  This is probably undesireable and\n\t       * it should be stopped.  The client will\n\t       * respond WONT TM to the DO TM that we send to\n\t       * check for kludge linemode.  When the WONT TM\n\t       * arrives, linemode will be turned off and a\n\t       * change propogated to the pty.  This change\n\t       * will cause us to process the new pty state\n\t       * in localstat(), which will notice that\n\t       * linemode is off and send a WILL ECHO\n\t       * so that we are properly in character mode and\n\t       * all is well.\n\t       */\n\t      break;\n\t    case TELOPT_LINEMODE:\n\t      /*\n\t       * Note client's desire to use linemode.\n\t       */\n\t      lmodetype = REAL_LINEMODE;\n\t      func = doclientstat;\n\t      break;\n\n#ifdef\tAUTHENTICATION\n\t    case TELOPT_AUTHENTICATION:\n\t      func = auth_request;\n\t      break;\n#endif\n\n#ifdef\tENCRYPTION\n\t    case TELOPT_ENCRYPT:\n\t      func = encrypt_send_support;\n\t      break;\n#endif /* ENCRYPTION */\n\t    case TELOPT_LFLOW:\n\t      func = flowstat;\n\t      break;\n\t    }\n\t}\n    }\n  set_his_state_will (option);\n  if (func)\n    (*func) ();\n}",
      "lines": 193,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "send_dont": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "void\nsend_dont (int option, int init)\n{\n  if (init)\n    {\n      if ((do_dont_resp[option] == 0 && his_state_is_wont (option)) ||\n\t  his_want_state_is_wont (option))\n\treturn;\n      set_his_want_state_wont (option);\n      do_dont_resp[option]++;\n    }\n  net_output_data (dont, option);\n\n  DEBUG (debug_options, 1, printoption (\"td: send dont\", option));\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wontoption": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "void\nwontoption (int option)\n{\n  /*\n   * Process client input.\n   */\n\n  DEBUG (debug_options, 1, printoption (\"td: recv wont\", option));\n\n  if (do_dont_resp[option])\n    {\n      do_dont_resp[option]--;\n      if (do_dont_resp[option] && his_state_is_wont (option))\n\tdo_dont_resp[option]--;\n    }\n  if (do_dont_resp[option] == 0)\n    {\n      if (his_want_state_is_will (option))\n\t{\n\t  /* it is always ok to change to negative state */\n\t  switch (option)\n\t    {\n\t    case TELOPT_ECHO:\n\t      not42 = 1;\t/* doesn't seem to be a 4.2 system */\n\t      break;\n\n\t    case TELOPT_BINARY:\n\t      init_termbuf ();\n\t      tty_binaryin (0);\n\t      set_termbuf ();\n\t      break;\n\n\t    case TELOPT_LINEMODE:\n\t      /*\n\t       * If real linemode is supported, then client is\n\t       * asking to turn linemode off.\n\t       */\n\t      if (lmodetype != REAL_LINEMODE)\n\t\tbreak;\n\t      clientstat (TELOPT_LINEMODE, WONT, 0);\n\t      break;\n\n\t    case TELOPT_TM:\n\t      /*\n\t       * If we get a WONT TM, and had sent a DO TM,\n\t       * don't respond with a DONT TM, just leave it\n\t       * as is.  Short circut the state machine to\n\t       * achive this.\n\t       */\n\t      set_his_want_state_wont (TELOPT_TM);\n\t      return;\n\n\t    case TELOPT_LFLOW:\n\t      /*\n\t       * If we are not going to support flow control\n\t       * option, then let peer know that we can't\n\t       * change the flow control characters.\n\t       */\n\t      slctab[SLC_XON].defset.flag &= ~SLC_LEVELBITS;\n\t      slctab[SLC_XON].defset.flag |= SLC_CANTCHANGE;\n\t      slctab[SLC_XOFF].defset.flag &= ~SLC_LEVELBITS;\n\t      slctab[SLC_XOFF].defset.flag |= SLC_CANTCHANGE;\n\t      break;\n\n#if defined AUTHENTICATION\n\t    case TELOPT_AUTHENTICATION:\n\t      auth_finished (0, AUTH_REJECT);\n\t      break;\n#endif\n\n\t      /*\n\t       * For options that we might spin waiting for\n\t       * sub-negotiation, if the client turns off the\n\t       * option rather than responding to the request,\n\t       * we have to treat it here as if we got a response\n\t       * to the sub-negotiation, (by updating the timers)\n\t       * so that we'll break out of the loop.\n\t       */\n\t    case TELOPT_TTYPE:\n\t      settimer (ttypesubopt);\n\t      break;\n\n\t    case TELOPT_TSPEED:\n\t      settimer (tspeedsubopt);\n\t      break;\n\n\t    case TELOPT_XDISPLOC:\n\t      settimer (xdisplocsubopt);\n\t      break;\n\n\t    case TELOPT_OLD_ENVIRON:\n\t      settimer (oenvironsubopt);\n\t      break;\n\n\t    case TELOPT_NEW_ENVIRON:\n\t      settimer (environsubopt);\n\t      break;\n\n\t    default:\n\t      break;\n\t    }\n\t  set_his_want_state_wont (option);\n\t  if (his_state_is_will (option))\n\t    send_dont (option, 0);\n\t}\n      else\n\t{\n\t  switch (option)\n\t    {\n\t    case TELOPT_TM:\n\t      if (lmodetype < NO_AUTOKLUDGE)\n\t\t{\n\t\t  lmodetype = NO_LINEMODE;\n\t\t  clientstat (TELOPT_LINEMODE, WONT, 0);\n\t\t  send_will (TELOPT_SGA, 1);\n\t\t  send_will (TELOPT_ECHO, 1);\n\t\t}\n\t      break;\n\n#if defined AUTHENTICATION\n\t    case TELOPT_AUTHENTICATION:\n\t      auth_finished (0, AUTH_REJECT);\n\t      break;\n#endif\n\t    default:\n\t      break;\n\t    }\n\t}\n    }\n  set_his_state_wont (option);\n\n}",
      "lines": 132,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "send_will": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "void\nsend_will (int option, int init)\n{\n  if (init)\n    {\n      if ((will_wont_resp[option] == 0 && my_state_is_will (option)) ||\n\t  my_want_state_is_will (option))\n\treturn;\n      set_my_want_state_will (option);\n      will_wont_resp[option]++;\n    }\n  net_output_data (will, option);\n\n  DEBUG (debug_options, 1, printoption (\"td: send will\", option));\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dooption": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "void\ndooption (int option)\n{\n  int changeok = 0;\n\n  /*\n   * Process client input.\n   */\n\n  DEBUG (debug_options, 1, printoption (\"td: recv do\", option));\n\n  if (will_wont_resp[option])\n    {\n      will_wont_resp[option]--;\n      if (will_wont_resp[option] && my_state_is_will (option))\n\twill_wont_resp[option]--;\n    }\n  if ((will_wont_resp[option] == 0) && (my_want_state_is_wont (option)))\n    {\n      switch (option)\n\t{\n\tcase TELOPT_ECHO:\n\t  if (lmodetype == NO_LINEMODE)\n\t    {\n\t      init_termbuf ();\n\t      tty_setecho (1);\n\t      set_termbuf ();\n\t    }\n\t  changeok++;\n\t  break;\n\n\tcase TELOPT_BINARY:\n\t  init_termbuf ();\n\t  tty_binaryout (1);\n\t  set_termbuf ();\n\t  changeok++;\n\t  break;\n\n\tcase TELOPT_SGA:\n\t  /*\n\t   * If kludge linemode is in use, then we must\n\t   * process an incoming do SGA for linemode\n\t   * purposes.\n\t   */\n\t  if (lmodetype == KLUDGE_LINEMODE)\n\t    {\n\t      /*\n\t       * Receipt of \"do SGA\" in kludge\n\t       * linemode is the peer asking us to\n\t       * turn off linemode.  Make note of\n\t       * the request.\n\t       */\n\t      clientstat (TELOPT_LINEMODE, WONT, 0);\n\t      /*\n\t       * If linemode did not get turned off\n\t       * then don't tell peer that we did.\n\t       * Breaking here forces a wont SGA to\n\t       * be returned.\n\t       */\n\t      if (linemode)\n\t\tbreak;\n\t    }\n\t  changeok++;\n\t  break;\n\n\tcase TELOPT_STATUS:\n\t  changeok++;\n\t  break;\n\n\tcase TELOPT_TM:\n\t  /*\n\t   * Special case for TM.  We send a WILL, but\n\t   * pretend we sent a WONT.\n\t   */\n\t  send_will (option, 0);\n\t  set_my_want_state_wont (option);\n\t  set_my_state_wont (option);\n\t  return;\n\n\tcase TELOPT_LOGOUT:\n\t  /*\n\t   * When we get a LOGOUT option, respond\n\t   * with a WILL LOGOUT, make sure that\n\t   * it gets written out to the network,\n\t   * and then just go away...\n\t   */\n\t  set_my_want_state_will (TELOPT_LOGOUT);\n\t  send_will (TELOPT_LOGOUT, 0);\n\t  set_my_state_will (TELOPT_LOGOUT);\n\t  netflush ();\n\t  cleanup (SIGHUP);\n\t  /* NOT REACHED */\n\t  break;\n\n#ifdef\tENCRYPTION\n\tcase TELOPT_ENCRYPT:\n\t  changeok++;\n\t  break;\n#endif /* ENCRYPTION */\n\tcase TELOPT_LINEMODE:\n\tcase TELOPT_TTYPE:\n\tcase TELOPT_NAWS:\n\tcase TELOPT_TSPEED:\n\tcase TELOPT_LFLOW:\n\tcase TELOPT_XDISPLOC:\n\tcase TELOPT_NEW_ENVIRON:\n\tcase TELOPT_OLD_ENVIRON:\n\tdefault:\n\t  break;\n\t}\n      if (changeok)\n\t{\n\t  set_my_want_state_will (option);\n\t  send_will (option, 0);\n\t}\n      else\n\t{\n\t  will_wont_resp[option]++;\n\t  send_wont (option, 0);\n\t}\n    }\n  set_my_state_will (option);\n\n}",
      "lines": 124,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "send_wont": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "void\nsend_wont (int option, int init)\n{\n  if (init)\n    {\n      if ((will_wont_resp[option] == 0 && my_state_is_wont (option)) ||\n\t  my_want_state_is_wont (option))\n\treturn;\n      set_my_want_state_wont (option);\n      will_wont_resp[option]++;\n    }\n  net_output_data (wont, option);\n\n  DEBUG (debug_options, 1, printoption (\"td: send wont\", option));\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dontoption": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1120,
        1
      ],
      "content": "void\ndontoption (int option)\n{\n  /*\n   * Process client input.\n   */\n\n  DEBUG (debug_options, 1, printoption (\"td: recv dont\", option));\n\n  if (will_wont_resp[option])\n    {\n      will_wont_resp[option]--;\n      if (will_wont_resp[option] && my_state_is_wont (option))\n\twill_wont_resp[option]--;\n    }\n  if ((will_wont_resp[option] == 0) && (my_want_state_is_will (option)))\n    {\n      switch (option)\n\t{\n\tcase TELOPT_BINARY:\n\t  init_termbuf ();\n\t  tty_binaryout (0);\n\t  set_termbuf ();\n\t  break;\n\n\tcase TELOPT_ECHO:\t/* we should stop echoing */\n\t  if ((lmodetype != REAL_LINEMODE) && (lmodetype != KLUDGE_LINEMODE))\n\t    {\n\t      init_termbuf ();\n\t      tty_setecho (0);\n\t      set_termbuf ();\n\t    }\n\t  break;\n\n\tcase TELOPT_SGA:\n\t  /*\n\t   * If kludge linemode is in use, then we\n\t   * must process an incoming do SGA for\n\t   * linemode purposes.\n\t   */\n\t  if ((lmodetype == KLUDGE_LINEMODE) || (lmodetype == KLUDGE_OK))\n\t    {\n\t      /*\n\t       * The client is asking us to turn\n\t       * linemode on.\n\t       */\n\t      lmodetype = KLUDGE_LINEMODE;\n\t      clientstat (TELOPT_LINEMODE, WILL, 0);\n\t      /*\n\t       * If we did not turn line mode on,\n\t       * then what do we say?  Will SGA?\n\t       * This violates design of telnet.\n\t       * Gross.  Very Gross.\n\t       */\n\t    }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n\n      set_my_want_state_wont (option);\n      if (my_state_is_will (option))\n\tsend_wont (option, 0);\n    }\n  set_my_state_wont (option);\n\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "suboption": {
      "start_point": [
        1143,
        0
      ],
      "end_point": [
        1587,
        1
      ],
      "content": "void\nsuboption (void)\n{\n  register int subchar;\n\n  DEBUG (debug_options, 1, printsub ('<', subpointer, SB_LEN () + 2));\n\n  subchar = SB_GET ();\n  switch (subchar)\n    {\n    case TELOPT_TSPEED:\n      {\n\tregister int xspeed, rspeed;\n\n\tif (his_state_is_wont (TELOPT_TSPEED))\t/* Ignore if option disabled */\n\t  break;\n\n\tsettimer (tspeedsubopt);\n\n\tif (SB_EOF () || SB_GET () != TELQUAL_IS)\n\t  return;\n\n\txspeed = atoi ((char *) subpointer);\n\n\twhile (SB_GET () != ',' && !SB_EOF ());\n\tif (SB_EOF ())\n\t  return;\n\n\trspeed = atoi ((char *) subpointer);\n\tclientstat (TELOPT_TSPEED, xspeed, rspeed);\n\n\tbreak;\n\n      }\t\t\t\t/* end of case TELOPT_TSPEED */\n\n    case TELOPT_TTYPE:\n      {\n\tstatic struct obstack stk;\n\tchar *p;\n\n\tif (his_state_is_wont (TELOPT_TTYPE))\t/* Ignore if option disabled */\n\t  break;\n\n\tsettimer (ttypesubopt);\n\n\tif (SB_EOF () || SB_GET () != TELQUAL_IS)\n\t  return;\t\t/* ??? XXX but, this is the most robust */\n\n\tfree (terminaltype);\n\n\tobstack_init (&stk);\n\twhile (!SB_EOF ())\n\t  {\n\t    int c = tolower (SB_GET ());\n\t    obstack_1grow (&stk, c);\n\t  }\n\tobstack_1grow (&stk, 0);\n\tp = obstack_finish (&stk);\n\tterminaltype = xstrdup (p);\n\tobstack_free (&stk, NULL);\n\tbreak;\n      }\t\t\t\t/* end of case TELOPT_TTYPE */\n\n    case TELOPT_NAWS:\n      {\n\tregister int xwinsize, ywinsize;\n\n\tif (his_state_is_wont (TELOPT_NAWS))\t/* Ignore if option disabled */\n\t  break;\n\n\tif (SB_EOF ())\n\t  return;\n\txwinsize = SB_GET () << 8;\n\tif (SB_EOF ())\n\t  return;\n\txwinsize |= SB_GET ();\n\tif (SB_EOF ())\n\t  return;\n\tywinsize = SB_GET () << 8;\n\tif (SB_EOF ())\n\t  return;\n\tywinsize |= SB_GET ();\n\tclientstat (TELOPT_NAWS, xwinsize, ywinsize);\n\n\tbreak;\n\n      }\t\t\t\t/* end of case TELOPT_NAWS */\n\n    case TELOPT_LINEMODE:\n      {\n\tregister int request;\n\n\t/* Ignore if option disabled */\n\tif (his_state_is_wont (TELOPT_LINEMODE))\n\t  break;\n\t/*\n\t * Process linemode suboptions.\n\t */\n\tif (SB_EOF ())\n\t  break;\t\t/* garbage was sent */\n\trequest = SB_GET ();\t/* get will/wont */\n\n\tif (SB_EOF ())\n\t  break;\t\t/* another garbage check */\n\n\tif (request == LM_SLC)\n\t  {\t\t\t/* SLC is not preceeded by WILL or WONT */\n\t    /*\n\t     * Process suboption buffer of slc's\n\t     */\n\t    start_slc (1);\n\t    do_opt_slc (subpointer, subend - subpointer);\n\t    end_slc (0);\n\t    break;\n\t  }\n\telse if (request == LM_MODE)\n\t  {\n\t    if (SB_EOF ())\n\t      return;\n\t    useeditmode = SB_GET ();\t/* get mode flag */\n\t    clientstat (LM_MODE, 0, 0);\n\t    break;\n\t  }\n\n\tif (SB_EOF ())\n\t  break;\n\tswitch (SB_GET ())\n\t  {\t\t\t/* what suboption? */\n\t  case LM_FORWARDMASK:\n\t    /*\n\t     * According to spec, only server can send request for\n\t     * forwardmask, and client can only return a positive response.\n\t     * So don't worry about it.\n\t     */\n\n\t  default:\n\t    break;\n\t  }\n\tbreak;\n      }\t\t\t\t/* end of case TELOPT_LINEMODE */\n\n    case TELOPT_STATUS:\n      {\n\tint mode;\n\n\tif (SB_EOF ())\n\t  break;\n\tmode = SB_GET ();\n\tswitch (mode)\n\t  {\n\t  case TELQUAL_SEND:\n\t    if (my_state_is_will (TELOPT_STATUS))\n\t      send_status ();\n\t    break;\n\n\t  case TELQUAL_IS:\n\t    break;\n\n\t  default:\n\t    break;\n\t  }\n\tbreak;\n      }\t\t\t\t/* end of case TELOPT_STATUS */\n\n    case TELOPT_XDISPLOC:\n      {\n\tif (SB_EOF () || SB_GET () != TELQUAL_IS)\n\t  return;\n\tsettimer (xdisplocsubopt);\n\tsubpointer[SB_LEN ()] = '\\0';\n\tsetenv (\"DISPLAY\", (char *) subpointer, 1);\n\tbreak;\n      }\t\t\t\t/* end of case TELOPT_XDISPLOC */\n\n    case TELOPT_NEW_ENVIRON:\n    case TELOPT_OLD_ENVIRON:\n      {\n\tregister int c;\n\tregister char *cp, *varp, *valp;\n\n\tif (SB_EOF ())\n\t  return;\n\tc = SB_GET ();\n\tif (c == TELQUAL_IS)\n\t  {\n\t    if (subchar == TELOPT_OLD_ENVIRON)\n\t      settimer (oenvironsubopt);\n\t    else\n\t      settimer (environsubopt);\n\t  }\n\telse if (c != TELQUAL_INFO)\n\t  return;\n\n\tif (subchar == TELOPT_NEW_ENVIRON)\n\t  {\n\t    while (!SB_EOF ())\n\t      {\n\t\tc = SB_GET ();\n\t\tif ((c == NEW_ENV_VAR) || (c == ENV_USERVAR))\n\t\t  break;\n\t      }\n\t  }\n\telse\n\t  {\n#ifdef\tENV_HACK\n\t    /*\n\t     * We only want to do this if we haven't already decided\n\t     * whether or not the other side has its VALUE and VAR\n\t     * reversed.\n\t     */\n\t    if (env_ovar < 0)\n\t      {\n\t\tregister int last = -1;\t/* invalid value */\n\t\tint empty = 0;\n\t\tint got_var = 0, got_value = 0, got_uservar = 0;\n\n\t\t/*\n\t\t * The other side might have its VALUE and VAR values\n\t\t * reversed.  To be interoperable, we need to determine\n\t\t * which way it is.  If the first recognized character\n\t\t * is a VAR or VALUE, then that will tell us what\n\t\t * type of client it is.  If the fist recognized\n\t\t * character is a USERVAR, then we continue scanning\n\t\t * the suboption looking for two consecutive\n\t\t * VAR or VALUE fields.  We should not get two\n\t\t * consecutive VALUE fields, so finding two\n\t\t * consecutive VALUE or VAR fields will tell us\n\t\t * what the client is.\n\t\t */\n\t\tSB_SAVE ();\n\t\twhile (!SB_EOF ())\n\t\t  {\n\t\t    c = SB_GET ();\n\t\t    switch (c)\n\t\t      {\n\t\t      case OLD_ENV_VAR:\n\t\t\tif (last < 0 || last == OLD_ENV_VAR\n\t\t\t    || (empty && (last == OLD_ENV_VALUE)))\n\t\t\t  goto env_ovar_ok;\n\t\t\tgot_var++;\n\t\t\tlast = OLD_ENV_VAR;\n\t\t\tbreak;\n\t\t      case OLD_ENV_VALUE:\n\t\t\tif (last < 0 || last == OLD_ENV_VALUE\n\t\t\t    || (empty && (last == OLD_ENV_VAR)))\n\t\t\t  goto env_ovar_wrong;\n\t\t\tgot_value++;\n\t\t\tlast = OLD_ENV_VALUE;\n\t\t\tbreak;\n\t\t      case ENV_USERVAR:\n\t\t\t/* count strings of USERVAR as one */\n\t\t\tif (last != ENV_USERVAR)\n\t\t\t  got_uservar++;\n\t\t\tif (empty)\n\t\t\t  {\n\t\t\t    if (last == OLD_ENV_VALUE)\n\t\t\t      goto env_ovar_ok;\n\t\t\t    if (last == OLD_ENV_VAR)\n\t\t\t      goto env_ovar_wrong;\n\t\t\t  }\n\t\t\tlast = ENV_USERVAR;\n\t\t\tbreak;\n\t\t      case ENV_ESC:\n\t\t\tif (!SB_EOF ())\n\t\t\t  c = SB_GET ();\n\t\t\t/* FALL THROUGH */\n\t\t      default:\n\t\t\tempty = 0;\n\t\t\tcontinue;\n\t\t      }\n\t\t    empty = 1;\n\t\t  }\n\t\tif (empty)\n\t\t  {\n\t\t    if (last == OLD_ENV_VALUE)\n\t\t      goto env_ovar_ok;\n\t\t    if (last == OLD_ENV_VAR)\n\t\t      goto env_ovar_wrong;\n\t\t  }\n\t\t/*\n\t\t * Ok, the first thing was a USERVAR, and there\n\t\t * are not two consecutive VAR or VALUE commands,\n\t\t * and none of the VAR or VALUE commands are empty.\n\t\t * If the client has sent us a well-formed option,\n\t\t * then the number of VALUEs received should always\n\t\t * be less than or equal to the number of VARs and\n\t\t * USERVARs received.\n\t\t *\n\t\t * If we got exactly as many VALUEs as VARs and\n\t\t * USERVARs, the client has the same definitions.\n\t\t *\n\t\t * If we got exactly as many VARs as VALUEs and\n\t\t * USERVARS, the client has reversed definitions.\n\t\t */\n\t\tif (got_uservar + got_var == got_value)\n\t\t  {\n\t\t  env_ovar_ok:\n\t\t    env_ovar = OLD_ENV_VAR;\n\t\t    env_ovalue = OLD_ENV_VALUE;\n\t\t  }\n\t\telse if (got_uservar + got_value == got_var)\n\t\t  {\n\t\t  env_ovar_wrong:\n\t\t    env_ovar = OLD_ENV_VALUE;\n\t\t    env_ovalue = OLD_ENV_VAR;\n\t\t    DEBUG (debug_options, 1,\n\t\t\t   debug_output_data\n\t\t\t   (\"ENVIRON VALUE and VAR are reversed!\\r\\n\"));\n\t\t  }\n\t      }\n\t    SB_RESTORE ();\n#endif\n\n\t    while (!SB_EOF ())\n\t      {\n\t\tc = SB_GET ();\n\t\tif ((c == env_ovar) || (c == ENV_USERVAR))\n\t\t  break;\n\t      }\n\t  }\n\n\tif (SB_EOF ())\n\t  return;\n\n\tcp = varp = (char *) subpointer;\n\tvalp = 0;\n\n\twhile (!SB_EOF ())\n\t  {\n\t    c = SB_GET ();\n\t    if (subchar == TELOPT_OLD_ENVIRON)\n\t      {\n\t\tif (c == env_ovar)\n\t\t  c = NEW_ENV_VAR;\n\t\telse if (c == env_ovalue)\n\t\t  c = NEW_ENV_VALUE;\n\t      }\n\t    switch (c)\n\t      {\n\n\t      case NEW_ENV_VALUE:\n\t\t*cp = '\\0';\n\t\tcp = valp = (char *) subpointer;\n\t\tbreak;\n\n\t      case NEW_ENV_VAR:\n\t      case ENV_USERVAR:\n\t\t*cp = '\\0';\n\t\tif (valp)\n\t\t  setenv (varp, valp, 1);\n\t\telse\n\t\t  unsetenv (varp);\n\t\tcp = varp = (char *) subpointer;\n\t\tvalp = 0;\n\t\tbreak;\n\n\t      case ENV_ESC:\n\t\tif (SB_EOF ())\n\t\t  break;\n\t\tc = SB_GET ();\n\t\t/* FALL THROUGH */\n\t      default:\n\t\t*cp++ = c;\n\t\tbreak;\n\t      }\n\t  }\n\t*cp = '\\0';\n\tif (valp)\n\t  setenv (varp, valp, 1);\n\telse\n\t  unsetenv (varp);\n\tbreak;\n      }\t\t\t\t/* end of case TELOPT_NEW_ENVIRON */\n#if defined AUTHENTICATION\n    case TELOPT_AUTHENTICATION:\n      if (SB_EOF ())\n\tbreak;\n      switch (SB_GET ())\n\t{\n\tcase TELQUAL_SEND:\n\tcase TELQUAL_REPLY:\n\t  /*\n\t   * These are sent by us and cannot be sent by\n\t   * the client.\n\t   */\n\t  break;\n\tcase TELQUAL_IS:\n\t  auth_is (subpointer, SB_LEN ());\n\t  break;\n\tcase TELQUAL_NAME:\n\t  auth_name (subpointer, SB_LEN ());\n\t  break;\n\t}\n      break;\n#endif\n#ifdef\tENCRYPTION\n    case TELOPT_ENCRYPT:\n      if (SB_EOF ())\n\tbreak;\n      switch (SB_GET ())\n\t{\n\tcase ENCRYPT_SUPPORT:\n\t  encrypt_support (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_IS:\n\t  encrypt_is (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_REPLY:\n\t  encrypt_reply (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_START:\n\t  encrypt_start (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_END:\n\t  encrypt_end ();\n\t  break;\n\tcase ENCRYPT_REQSTART:\n\t  encrypt_request_start (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_REQEND:\n\t  /*\n\t   * We can always send an REQEND so that we cannot\n\t   * get stuck encrypting.  We should only get this\n\t   * if we have been able to get in the correct mode\n\t   * anyhow.\n\t   */\n\t  encrypt_request_end ();\n\t  break;\n\tcase ENCRYPT_ENC_KEYID:\n\t  encrypt_enc_keyid (subpointer, SB_LEN ());\n\t  break;\n\tcase ENCRYPT_DEC_KEYID:\n\t  encrypt_dec_keyid (subpointer, SB_LEN ());\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      break;\n#endif /* ENCRYPTION */\n\n    default:\n      break;\n    }\t\t\t\t/* end of switch */\n\n}",
      "lines": 445,
      "depth": 24,
      "decorators": [
        "void"
      ]
    },
    "doclientstat": {
      "start_point": [
        1589,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "void\ndoclientstat (void)\n{\n  clientstat (TELOPT_LINEMODE, WILL, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "send_status": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1708,
        1
      ],
      "content": "void\nsend_status (void)\n{\n#define ADD(c) \\\n        do { \\\n                if (ep > ncp) \\\n                        *ncp++ = c; \\\n                else \\\n                        goto trunc; \\\n        } while (0)\n#define ADD_DATA(c) \\\n        do { \\\n                ADD(c); if (c == SE || c == IAC) ADD(c); \\\n        } while (0)\n\n  unsigned char statusbuf[256];\n  unsigned char *ep;\n  register unsigned char *ncp;\n  register unsigned char i;\n\n  ncp = statusbuf;\n  ep = statusbuf + sizeof (statusbuf);\n\n  netflush ();\t\t\t/* get rid of anything waiting to go out */\n\n  ADD (IAC);\n  ADD (SB);\n  ADD (TELOPT_STATUS);\n  ADD (TELQUAL_IS);\n\n  /*\n   * We check the want_state rather than the current state,\n   * because if we received a DO/WILL for an option that we\n   * don't support, and the other side didn't send a DONT/WONT\n   * in response to our WONT/DONT, then the \"state\" will be\n   * WILL/DO, and the \"want_state\" will be WONT/DONT.  We\n   * need to go by the latter.\n   */\n  for (i = 0; i < (unsigned char) NTELOPTS; i++)\n    {\n      if (my_want_state_is_will (i))\n\t{\n\t  ADD (WILL);\n\t  ADD_DATA (i);\n\t}\n      if (his_want_state_is_will (i))\n\t{\n\t  ADD (DO);\n\t  ADD_DATA (i);\n\t}\n    }\n\n  if (his_want_state_is_will (TELOPT_LFLOW))\n    {\n      ADD (SB);\n      ADD (TELOPT_LFLOW);\n      if (flowmode)\n\tADD (LFLOW_ON);\n      else\n\tADD (LFLOW_OFF);\n\n      ADD (SE);\n\n      if (restartany >= 0)\n\t{\n\t  ADD (SB);\n\t  ADD (TELOPT_LFLOW);\n\t  if (restartany)\n\t    ADD (LFLOW_RESTART_ANY);\n\t  else\n\t    ADD (LFLOW_RESTART_XON);\n\t  ADD (SE);\n\t}\n    }\n\n  if (his_want_state_is_will (TELOPT_LINEMODE))\n    {\n      unsigned char *cp, *cpe;\n      int len;\n\n      ADD (SB);\n      ADD (TELOPT_LINEMODE);\n      ADD (LM_MODE);\n      ADD_DATA (editmode);\n      ADD (SE);\n\n      ADD (SB);\n      ADD (TELOPT_LINEMODE);\n      ADD (LM_SLC);\n      start_slc (0);\n      send_slc ();\n      len = end_slc (&cp);\n      for (cpe = cp + len; cp < cpe; cp++)\n\tADD_DATA (*cp);\n      ADD (SE);\n    }\n\n  ADD (IAC);\n  ADD (SE);\n\n  net_output_datalen (statusbuf, ncp - statusbuf);\n  netflush ();\t\t\t/* Send it on its way */\n\n  /* Step over the initial IAC+SB, into suboption payload.  */\n  DEBUG (debug_options, 1, printsub ('>', statusbuf + 2,\n\t\t\t\t     ncp - statusbuf - 2));\n  return;\n\ntrunc:\n  /* XXX bark? */\n  return;\n#undef ADD\n#undef ADD_DATA\n}",
      "lines": 114,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/telnetd.c": {
    "parse_opt": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static error_t\nparse_opt (int key, char *arg, struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  switch (key)\n    {\n#ifdef  AUTHENTICATION\n    case 'a':\n      parse_authmode (arg);\n      break;\n#endif\n\n    case 'D':\n      parse_debug_level (arg);\n      break;\n\n    case 'E':\n      login_invocation = arg;\n      break;\n\n    case 'h':\n      hostinfo = 0;\n      break;\n\n    case 'l':\n      parse_linemode (arg);\n      break;\n\n    case 'n':\n      keepalive = 0;\n      break;\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n    case 'S':\n      principal = arg;\n      break;\n#endif\n\n    case 'U':\n      reverse_lookup = 1;\n      break;\n\n#ifdef\tAUTHENTICATION\n    case 'X':\n      auth_disable_name (arg);\n      break;\n#endif\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}",
      "lines": 53,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int index;\n\n  set_program_name (argv[0]);\n  iu_argp_init (\"telnetd\", default_program_authors);\n\n  openlog (\"telnetd\", LOG_PID | LOG_ODELAY, LOG_DAEMON);\n\n  argp_parse (&argp, argc, argv, 0, &index, NULL);\n\n  if (argc != index)\n    error (EXIT_FAILURE, 0, \"junk arguments in the command line\");\n\n  telnetd_setup (0);\n  return telnetd_run ();\t/* Never returning.  */\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "parse_linemode": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\nparse_linemode (char *str)\n{\n  if (!str)\n    alwayslinemode = 1;\n  else if (strcmp (str, \"nokludge\") == 0)\n    lmodetype = NO_AUTOKLUDGE;\n  else\n    syslog (LOG_NOTICE, \"invalid argument to --linemode: %s\", str);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "parse_authmode": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void\nparse_authmode (char *str)\n{\n  if (strcasecmp (str, \"none\") == 0)\n    auth_level = 0;\n  else if (strcasecmp (str, \"other\") == 0)\n    auth_level = AUTH_OTHER;\n  else if (strcasecmp (str, \"user\") == 0)\n    auth_level = AUTH_USER;\n  else if (strcasecmp (str, \"valid\") == 0)\n    auth_level = AUTH_VALID;\n  else if (strcasecmp (str, \"off\") == 0)\n    auth_level = -1;\n  else\n    syslog (LOG_NOTICE, \"unknown authorization level for -a: %s\", str);\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "parse_debug_level": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\nparse_debug_level (char *str)\n{\n  int i;\n  char *tok;\n\n  if (!str)\n    {\n      for (i = 0; i < debug_max_mode; i++)\n\tdebug_level[debug_mode[i].modnum] = MAX_DEBUG_LEVEL;\n      return;\n    }\n\n  for (tok = strtok (str, \",\"); tok; tok = strtok (NULL, \",\"))\n    {\n      int length, level;\n      char *p;\n\n      if (strcmp (tok, \"tcp\") == 0)\n\t{\n\t  debug_tcp = 1;\n\t  continue;\n\t}\n\n      p = strchr (tok, '=');\n      if (p)\n\t{\n\t  length = p - tok;\n\t  level = strtoul (p + 1, NULL, 0);\n\t}\n      else\n\t{\n\t  length = strlen (tok);\n\t  level = MAX_DEBUG_LEVEL;\n\t}\n\n      for (i = 0; i < debug_max_mode; i++)\n\tif (strncmp (debug_mode[i].name, tok, length) == 0)\n\t  {\n\t    debug_level[debug_mode[i].modnum] = level;\n\t    break;\n\t  }\n\n      if (i == debug_max_mode)\n\tsyslog (LOG_NOTICE, \"unknown debug mode: %s\", tok);\n    }\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "telnetd_setup": {
      "start_point": [
        323,
        11
      ],
      "end_point": [
        534,
        1
      ],
      "content": "void\ntelnetd_setup (int fd)\n{\n#ifdef IPV6\n  struct sockaddr_storage saddr;\n  char buf[256], buf2[256];\t/* FIXME: We should use dynamic allocation. */\n  int err;\n#else\n  struct sockaddr_in saddr;\n  struct hostent *hp;\n#endif\n  int true = 1;\n  socklen_t len;\n  char uname[256];\n   /*FIXME*/ int level;\n\n  len = sizeof (saddr);\n  if (getpeername (fd, (struct sockaddr *) &saddr, &len) < 0)\n    {\n      syslog (LOG_ERR, \"getpeername: %m\");\n      exit (EXIT_FAILURE);\n    }\n\n#ifdef IPV6\n  err = getnameinfo ((struct sockaddr *) &saddr, len, buf,\n\t\t     sizeof (buf), NULL, 0, NI_NUMERICHOST);\n  if (err)\n    {\n      const char *errmsg;\n\n      if (err == EAI_SYSTEM)\n\terrmsg = strerror (errno);\n      else\n\terrmsg = gai_strerror (err);\n\n      syslog (LOG_AUTH | LOG_NOTICE, \"Cannot get address: %s\", errmsg);\n      fatal (fd, \"Cannot get address.\");\n    }\n\n  /* We use a second buffer so we don't have to call getnameinfo again\n     if we need the numeric host below.  */\n  err = getnameinfo ((struct sockaddr *) &saddr, len, buf2,\n\t\t     sizeof (buf2), NULL, 0, NI_NAMEREQD);\n\n  if (reverse_lookup)\n    {\n      struct addrinfo *result, *aip;\n\n      if (err)\n\t{\n\t  const char *errmsg;\n\n\t  if (err == EAI_SYSTEM)\n\t    errmsg = strerror (errno);\n\t  else\n\t    errmsg = gai_strerror (err);\n\n\t  syslog (LOG_AUTH | LOG_NOTICE, \"Can't resolve %s: %s\", buf, errmsg);\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n\n      remote_hostname = xstrdup (buf2);\n\n      err = getaddrinfo (remote_hostname, NULL, NULL, &result);\n      if (err)\n\t{\n\t  const char *errmsg;\n\n\t  if (err == EAI_SYSTEM)\n\t    errmsg = strerror (errno);\n\t  else\n\t    errmsg = gai_strerror (err);\n\n\t  syslog (LOG_AUTH | LOG_NOTICE, \"Forward resolve of %s failed: %s\",\n\t\t  remote_hostname, errmsg);\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n\n      for (aip = result; aip; aip = aip->ai_next)\n\t{\n\t  if (aip->ai_family != saddr.ss_family)\n\t    continue;\n\n\t  /* Must compare the address part only.\n\t   * The ports are almost surely different!\n\t   */\n\t  if (aip->ai_family == AF_INET\n\t      && !memcmp (&((struct sockaddr_in *) aip->ai_addr)->sin_addr,\n\t\t\t  &((struct sockaddr_in *) &saddr)->sin_addr,\n\t\t\t  sizeof (struct in_addr)))\n\t    break;\n\t  if (aip->ai_family == AF_INET6\n\t      && !memcmp (&((struct sockaddr_in6 *) aip->ai_addr)->sin6_addr,\n\t\t\t  &((struct sockaddr_in6 *) &saddr)->sin6_addr,\n\t\t\t  sizeof (struct in6_addr)))\n\t    break;\n\t}\n\n      if (aip == NULL)\n\t{\n\t  syslog (LOG_AUTH | LOG_NOTICE,\n\t\t  \"No address of %s matched %s\", remote_hostname, buf);\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n\n      freeaddrinfo (result);\n    }\n  else\n    {\n      if (!err)\n\tremote_hostname = xstrdup (buf2);\n      else\n\tremote_hostname = xstrdup (buf);\n    }\n#else\n  hp = gethostbyaddr ((char *) &saddr.sin_addr.s_addr,\n\t\t      sizeof (saddr.sin_addr.s_addr), AF_INET);\n  if (reverse_lookup)\n    {\n      char **ap;\n\n      if (!hp)\n\t{\n\t  syslog (LOG_AUTH | LOG_NOTICE,\n\t\t  \"Can't resolve %s: %s\",\n\t\t  inet_ntoa (saddr.sin_addr), hstrerror (h_errno));\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n\n      remote_hostname = xstrdup (hp->h_name);\n\n      hp = gethostbyname (remote_hostname);\n      if (!hp)\n\t{\n\t  syslog (LOG_AUTH | LOG_NOTICE,\n\t\t  \"Forward resolve of %s failed: %s\",\n\t\t  remote_hostname, hstrerror (h_errno));\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n\n      for (ap = hp->h_addr_list; *ap; ap++)\n\tif (*(ip_addr_t *) ap == saddr.sin_addr.s_addr)\n\t  break;\n\n      if (ap == NULL)\n\t{\n\t  syslog (LOG_AUTH | LOG_NOTICE,\n\t\t  \"No address of %s matched %s\",\n\t\t  remote_hostname, inet_ntoa (saddr.sin_addr));\n\t  fatal (fd, \"Cannot resolve address.\");\n\t}\n    }\n  else\n    {\n      if (hp)\n\tremote_hostname = xstrdup (hp->h_name);\n      else\n\tremote_hostname = xstrdup (inet_ntoa (saddr.sin_addr));\n    }\n#endif\n\n  /* Set socket options */\n\n  if (keepalive\n      && setsockopt (fd, SOL_SOCKET, SO_KEEPALIVE,\n\t\t     (char *) &true, sizeof (true)) < 0)\n    syslog (LOG_WARNING, \"setsockopt (SO_KEEPALIVE): %m\");\n\n  if (debug_tcp\n      && setsockopt (fd, SOL_SOCKET, SO_DEBUG,\n\t\t     (char *) &true, sizeof (true)) < 0)\n    syslog (LOG_WARNING, \"setsockopt (SO_DEBUG): %m\");\n\n  net = fd;\n\n  local_hostname = localhost ();\n#if defined AUTHENTICATION || defined ENCRYPTION\n  auth_encrypt_init (local_hostname, remote_hostname, principal,\n\t\t     \"TELNETD\", 1);\n#endif\n\n  io_setup ();\n\n  /* get terminal type. */\n  uname[0] = 0;\n  level = getterminaltype (uname, sizeof (uname));\n  setenv (\"TERM\", terminaltype ? terminaltype : \"network\", 1);\n  if (uname[0])\n    user_name = xstrdup (uname);\n  pty = startslave (remote_hostname, level, user_name);\n\n#ifndef HAVE_STREAMSPTY\n  /* Turn on packet mode */\n  ioctl (pty, TIOCPKT, (char *) &true);\n#endif\n  ioctl (pty, FIONBIO, (char *) &true);\n  ioctl (net, FIONBIO, (char *) &true);\n\n#if defined SO_OOBINLINE\n  setsockopt (net, SOL_SOCKET, SO_OOBINLINE, (char *) &true, sizeof true);\n#endif\n\n#ifdef SIGTSTP\n  signal (SIGTSTP, SIG_IGN);\n#endif\n#ifdef\tSIGTTOU\n  signal (SIGTTOU, SIG_IGN);\n#endif\n\n  /* Activate SA_RESTART whenever available.  */\n  setsig (SIGCHLD, chld_is_done);\n}",
      "lines": 212,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "telnetd_run": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "int\ntelnetd_run (void)\n{\n  int nfd;\n\n  get_slc_defaults ();\n\n  if (my_state_is_wont (TELOPT_SGA))\n    send_will (TELOPT_SGA, 1);\n\n  /* Old BSD 4.2 clients are unable to deal with TCP out-of-band data.\n     To find out, we send out a \"DO ECHO\". If the remote side is\n     a BSD 4.2 it will answer \"WILL ECHO\". See the response processing\n     below. */\n  send_do (TELOPT_ECHO, 1);\n  if (his_state_is_wont (TELOPT_LINEMODE))\n    {\n      /* Query the peer for linemode support by trying to negotiate\n         the linemode option. */\n      linemode = 0;\n      editmode = 0;\n      send_do (TELOPT_LINEMODE, 1);\t/* send do linemode */\n    }\n\n  send_do (TELOPT_NAWS, 1);\n  send_will (TELOPT_STATUS, 1);\n  flowmode = 1;\t\t\t/* default flow control state */\n  restartany = -1;\t\t/* uninitialized... */\n  send_do (TELOPT_LFLOW, 1);\n\n  /* Wait for a response from the DO ECHO. Reportedly, some broken\n     clients might not respond to it. To work around this, we wait\n     for a response to NAWS, which should have been processed after\n     DO ECHO (most dumb telnets respond with WONT for a DO that\n     they don't understand).\n     On the other hand, the client might have sent WILL NAWS as\n     part of its startup code, in this case it surely should have\n     answered our DO ECHO, so the second loop is waiting for\n     the ECHO to settle down.  */\n  ttloop (his_will_wont_is_changing (TELOPT_NAWS));\n\n  if (his_want_state_is_will (TELOPT_ECHO) && his_state_is_will (TELOPT_NAWS))\n    ttloop (his_will_wont_is_changing (TELOPT_ECHO));\n\n  /* If the remote client is badly broken and did not respond to our\n     DO ECHO, we simulate the receipt of a will echo. This will also\n     send a WONT ECHO to the client, since we assume that the client\n     failed to respond because it believes that it is already in DO ECHO\n     mode, which we do not want. */\n\n  if (his_want_state_is_will (TELOPT_ECHO))\n    {\n      DEBUG (debug_options, 1, debug_output_data (\"td: simulating recv\\r\\n\"));\n      willoption (TELOPT_ECHO);\n    }\n\n  /* Turn on our echo */\n  if (my_state_is_wont (TELOPT_ECHO))\n    send_will (TELOPT_ECHO, 1);\n\n  /* Continuing line mode support.  If client does not support\n     real linemode, attempt to negotiate kludge linemode by sending\n     the do timing mark sequence. */\n  if (lmodetype < REAL_LINEMODE)\n    send_do (TELOPT_TM, 1);\n\n  /* Pick up anything received during the negotiations */\n  telrcv ();\n\n  if (hostinfo)\n    print_hostinfo ();\n\n  init_termbuf ();\n  localstat ();\n\n  DEBUG (debug_report, 1,\n\t debug_output_data (\"td: Entering processing loop\\r\\n\"));\n\n  nfd = ((net > pty) ? net : pty) + 1;\n\n  for (;;)\n    {\n      fd_set ibits, obits, xbits;\n      register int c;\n\n      if (net_input_level () < 0 && pty_input_level () < 0)\n\tbreak;\n\n      FD_ZERO (&ibits);\n      FD_ZERO (&obits);\n      FD_ZERO (&xbits);\n\n      /* Never look for input if there's still stuff in the corresponding\n         output buffer */\n      if (net_output_level () || pty_input_level () > 0)\n\tFD_SET (net, &obits);\n      else\n\tFD_SET (pty, &ibits);\n\n      if (pty_output_level () || net_input_level () > 0)\n\tFD_SET (pty, &obits);\n      else\n\tFD_SET (net, &ibits);\n\n      if (!SYNCHing)\n\tFD_SET (net, &xbits);\n\n      if ((c = select (nfd, &ibits, &obits, &xbits, NULL)) <= 0)\n\t{\n\t  if (c == -1 && errno == EINTR)\n\t    continue;\n\t  sleep (5);\n\t  continue;\n\t}\n\n      if (FD_ISSET (net, &xbits))\n\tSYNCHing = 1;\n\n      if (FD_ISSET (net, &ibits))\n\t{\n\t  /* Something to read from the network... */\n\t  /*FIXME: handle  !defined(SO_OOBINLINE) */\n\t  net_read ();\n\t}\n\n      if (FD_ISSET (pty, &ibits))\n\t{\n\t  /* Something to read from the pty... */\n\t  if (pty_read () <= 0)\n\t    break;\n\n\t  /* The first byte is now TIOCPKT data.  Peek at it.  */\n\t  c = pty_get_char (1);\n\n#if defined TIOCPKT_IOCTL\n\t  if (c & TIOCPKT_IOCTL)\n\t    {\n\t      pty_get_char (0);\n\t      copy_termbuf ();\t/* Pty buffer is now emptied.  */\n\t      localstat ();\n\t    }\n#endif\n\t  if (c & TIOCPKT_FLUSHWRITE)\n\t    {\n\t      static char flushdata[] = { IAC, DM };\n\t      pty_get_char (0);\n\t      netclear ();\t/* clear buffer back */\n\t      net_output_datalen (flushdata, sizeof (flushdata));\n\t      set_neturg ();\n\t      DEBUG (debug_options, 1, printoption (\"td: send IAC\", DM));\n\t    }\n\n\t  if (his_state_is_will (TELOPT_LFLOW)\n\t      && (c & (TIOCPKT_NOSTOP | TIOCPKT_DOSTOP)))\n\t    {\n\t      int newflow = (c & TIOCPKT_DOSTOP) ? 1 : 0;\n\t      if (newflow != flowmode)\n\t\t{\n\t\t  net_output_data (\"%c%c%c%c%c%c\",\n\t\t\t\t   IAC, SB, TELOPT_LFLOW,\n\t\t\t\t   flowmode ? LFLOW_ON : LFLOW_OFF, IAC, SE);\n\t\t}\n\t    }\n\n\t  pty_get_char (0);\t/* Discard the TIOCPKT preamble.  */\n\t}\n\n      while (pty_input_level () > 0)\n\t{\n\t  if (net_buffer_is_full ())\n\t    break;\n\t  c = pty_get_char (0);\n\t  if (c == IAC)\n\t    net_output_byte (c);\n\t  net_output_byte (c);\n\t  if (c == '\\r' && my_state_is_wont (TELOPT_BINARY))\n\t    {\n\t      if (pty_input_level () > 0 && pty_get_char (1) == '\\n')\n\t\tnet_output_byte (pty_get_char (0));\n\t      else\n\t\tnet_output_byte (0);\n\t    }\n\t}\n\n      if (FD_ISSET (net, &obits) && net_output_level () > 0)\n\tnetflush ();\n      if (net_input_level () > 0)\n\ttelrcv ();\n\n      if (FD_ISSET (pty, &obits) && pty_output_level () > 0)\n\tptyflush ();\n\n      /* Attending to the child must come last in the loop,\n       * so as to let pending data be flushed, mainly to the\n       * benefit of the remote and expecting client.\n       */\n      if (pending_sigchld) {\n\t/* Check for pending output, independently of OBITS.  */\n\tif (net_output_level () > 0)\n\t  netflush ();\n\n\tcleanup (SIGCHLD);\t/* Not returning from this.  */\n      }\n    }\n\n  cleanup (0);\n  /* NOT REACHED */\n\n  return 0;\n}",
      "lines": 210,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "print_hostinfo": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\nprint_hostinfo (void)\n{\n  char *im = NULL;\n  char *str;\n#ifdef HAVE_UNAME\n  struct utsname u;\n\n  if (uname (&u) >= 0)\n    {\n      im = malloc (strlen (UNAME_IM_PREFIX)\n\t\t   + strlen (u.sysname)\n\t\t   + 1 + strlen (u.release) + strlen (UNAME_IM_SUFFIX) + 1);\n      if (im)\n\tsprintf (im, \"%s%s %s%s\",\n\t\t UNAME_IM_PREFIX, u.sysname, u.release, UNAME_IM_SUFFIX);\n    }\n#endif /* HAVE_UNAME */\n  if (!im)\n    im = xstrdup (\"\\r\\n\\r\\nUNIX (%l) (%t)\\r\\n\\r\\n\");\n\n  str = expand_line (im);\n  free (im);\n\n  DEBUG (debug_pty_data, 1, debug_output_data (\"sending %s\", str));\n  pty_input_putback (str, strlen (str));\n  free (str);\n}",
      "lines": 28,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "chld_is_done": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "static void\nchld_is_done (int sig _GL_UNUSED_PARAMETER)\n{\n  pending_sigchld = 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/telnetd.h": {},
  "inetutils/inetutils-1.9.4/telnetd/term.c": {
    "_term_setattr": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "void\n_term_setattr (int fd, TERMDESC * tp)\n{\n  ioctl (fd, TIOCSETN, (char *) &tp->sg);\n  ioctl (fd, TIOCSETC, (char *) &tp->tc);\n  ioctl (fd, TIOCSLTC, (char *) &tp->ltc);\n  ioctl (fd, TIOCLSET, &tp->lflags);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "term_send_eof": [
      {
        "start_point": [
          40,
          0
        ],
        "end_point": [
          44,
          1
        ],
        "content": "void\nterm_send_eof ()\n{\n  /*nothing */\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          262,
          0
        ],
        "end_point": [
          269,
          1
        ],
        "content": "void\nterm_send_eof (void)\n{\n# if VEOF == VMIN\n  if (!tty_isediting ())\n    pty_output_byte (oldeofc);\n# endif\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "term_change_eof": [
      {
        "start_point": [
          46,
          0
        ],
        "end_point": [
          50,
          1
        ],
        "content": "int\nterm_change_eof ()\n{\n  return 0;\n}",
        "lines": 5,
        "depth": 4,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          271,
          0
        ],
        "end_point": [
          282,
          1
        ],
        "content": "int\nterm_change_eof (void)\n{\n# if VEOF == VMIN\n  if (!tty_isediting ())\n    return 1;\n  if (slctab[SLC_EOF].sptr)\n    oldeofc = *slctab[SLC_EOF].sptr;\n# endif\n\n  return 0;\n}",
        "lines": 12,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_linemode": [
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          56,
          1
        ],
        "content": "int\ntty_linemode ()\n{\n  return termbuf.state & TS_EXTPROC;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          284,
          0
        ],
        "end_point": [
          292,
          1
        ],
        "content": "int\ntty_linemode (void)\n{\n# ifdef EXTPROC\n  return (termbuf.c_lflag & EXTPROC);\n# else\n  return 0;\t\t\t/* Can't ever set it either. */\n# endif\t/* EXTPROC */\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setlinemode": [
      {
        "start_point": [
          58,
          0
        ],
        "end_point": [
          73,
          1
        ],
        "content": "void\ntty_setlinemode (int on)\n{\n# ifdef\tTIOCEXT\n  set_termbuf ();\n  ioctl (pty, TIOCEXT, (char *) &on);\n  init_termbuf ();\n# else /* !TIOCEXT */\n#  ifdef\tEXTPROC\n  if (on)\n    termbuf.c_lflag |= EXTPROC;\n  else\n    termbuf.c_lflag &= ~EXTPROC;\n#  endif\n# endif\t/* TIOCEXT */\n}",
        "lines": 16,
        "depth": 10,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          294,
          0
        ],
        "end_point": [
          311,
          1
        ],
        "content": "void\ntty_setlinemode (int on)\n{\n# ifdef\tTIOCEXT\n  set_termbuf ();\n  ioctl (pty, TIOCEXT, (char *) &on);\n  init_termbuf ();\n# else /* !TIOCEXT */\n#  ifdef\tEXTPROC\n  if (on)\n    termbuf.c_lflag |= EXTPROC;\n  else\n    termbuf.c_lflag &= ~EXTPROC;\n#  else /* !EXTPROC */\n  (void) on;\t\t/* Silence warnings.  */\n#  endif\n# endif\t/* TIOCEXT */\n}",
        "lines": 18,
        "depth": 10,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_isecho": [
      {
        "start_point": [
          75,
          0
        ],
        "end_point": [
          79,
          1
        ],
        "content": "int\ntty_isecho ()\n{\n  return termbuf.sg.sg_flags & ECHO;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          313,
          0
        ],
        "end_point": [
          317,
          1
        ],
        "content": "int\ntty_isecho (void)\n{\n  return termbuf.c_lflag & ECHO;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_flowmode": [
      {
        "start_point": [
          81,
          0
        ],
        "end_point": [
          85,
          1
        ],
        "content": "int\ntty_flowmode ()\n{\n  return ((termbuf.tc.t_startc) > 0 && (termbuf.tc.t_stopc) > 0) ? 1 : 0;\n}",
        "lines": 5,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          319,
          0
        ],
        "end_point": [
          323,
          1
        ],
        "content": "int\ntty_flowmode (void)\n{\n  return (termbuf.c_iflag & IXON) ? 1 : 0;\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_restartany": [
      {
        "start_point": [
          87,
          0
        ],
        "end_point": [
          95,
          1
        ],
        "content": "int\ntty_restartany ()\n{\n# ifdef\tDECCTQ\n  return (termbuf.lflags & DECCTQ) ? 0 : 1;\n# else\n  return -1;\n# endif\n}",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          325,
          0
        ],
        "end_point": [
          329,
          1
        ],
        "content": "int\ntty_restartany (void)\n{\n  return (termbuf.c_iflag & IXANY) ? 1 : 0;\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setecho": [
      {
        "start_point": [
          97,
          0
        ],
        "end_point": [
          104,
          1
        ],
        "content": "void\ntty_setecho (int on)\n{\n  if (on)\n    termbuf.sg.sg_flags |= ECHO | CRMOD;\n  else\n    termbuf.sg.sg_flags &= ~(ECHO | CRMOD);\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          331,
          0
        ],
        "end_point": [
          338,
          1
        ],
        "content": "void\ntty_setecho (int on)\n{\n  if (on)\n    termbuf.c_lflag |= ECHO;\n  else\n    termbuf.c_lflag &= ~ECHO;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_israw": [
      {
        "start_point": [
          106,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "int\ntty_israw ()\n{\n  return termbuf.sg.sg_flags & RAW;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          340,
          0
        ],
        "end_point": [
          344,
          1
        ],
        "content": "int\ntty_israw (void)\n{\n  return !(termbuf.c_lflag & ICANON);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setraw": [
      {
        "start_point": [
          113,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\ntty_setraw (int on)\n{\n  if (on)\n    termbuf.sg.sg_flags |= RAW;\n  else\n    termbuf.sg.sg_flags &= ~RAW;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          347,
          0
        ],
        "end_point": [
          354,
          1
        ],
        "content": "int\ntty_setraw (int on)\n{\n  if (on)\n    termbuf.c_lflag &= ~ICANON;\n  else\n    termbuf.c_lflag |= ICANON;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_binaryin": [
      {
        "start_point": [
          123,
          0
        ],
        "end_point": [
          130,
          1
        ],
        "content": "void\ntty_binaryin (int on)\n{\n  if (on)\n    termbuf.lflags |= LPASS8;\n  else\n    termbuf.lflags &= ~LPASS8;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          357,
          0
        ],
        "end_point": [
          364,
          1
        ],
        "content": "void\ntty_binaryin (int on)\n{\n  if (on)\n    termbuf.c_iflag &= ~ISTRIP;\n  else\n    termbuf.c_iflag |= ISTRIP;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_binaryout": [
      {
        "start_point": [
          132,
          0
        ],
        "end_point": [
          139,
          1
        ],
        "content": "void\ntty_binaryout (int on)\n{\n  if (on)\n    termbuf.lflags |= LLITOUT;\n  else\n    termbuf.lflags &= ~LLITOUT;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          366,
          0
        ],
        "end_point": [
          381,
          1
        ],
        "content": "void\ntty_binaryout (int on)\n{\n  if (on)\n    {\n      termbuf.c_cflag &= ~(CSIZE | PARENB);\n      termbuf.c_cflag |= CS8;\n      termbuf.c_oflag &= ~OPOST;\n    }\n  else\n    {\n      termbuf.c_cflag &= ~CSIZE;\n      termbuf.c_cflag |= CS7 | PARENB;\n      termbuf.c_oflag |= OPOST;\n    }\n}",
        "lines": 16,
        "depth": 10,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_isbinaryin": [
      {
        "start_point": [
          141,
          0
        ],
        "end_point": [
          145,
          1
        ],
        "content": "int\ntty_isbinaryin ()\n{\n  return termbuf.lflags & LPASS8;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          383,
          0
        ],
        "end_point": [
          387,
          1
        ],
        "content": "int\ntty_isbinaryin (void)\n{\n  return !(termbuf.c_iflag & ISTRIP);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_isbinaryout": [
      {
        "start_point": [
          147,
          0
        ],
        "end_point": [
          151,
          1
        ],
        "content": "int\ntty_isbinaryout ()\n{\n  return termbuf.lflags & LLITOUT;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          389,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "int\ntty_isbinaryout (void)\n{\n  return !(termbuf.c_oflag & OPOST);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_isediting": [
      {
        "start_point": [
          153,
          0
        ],
        "end_point": [
          157,
          1
        ],
        "content": "int\ntty_isediting ()\n{\n  return !(termbuf.sg.sg_flags & (CBREAK | RAW));\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          395,
          0
        ],
        "end_point": [
          399,
          1
        ],
        "content": "int\ntty_isediting (void)\n{\n  return termbuf.c_lflag & ICANON;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_istrapsig": [
      {
        "start_point": [
          159,
          0
        ],
        "end_point": [
          163,
          1
        ],
        "content": "int\ntty_istrapsig ()\n{\n  return !(termbuf.sg.sg_flags & RAW);\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          401,
          0
        ],
        "end_point": [
          405,
          1
        ],
        "content": "int\ntty_istrapsig (void)\n{\n  return termbuf.c_lflag & ISIG;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setedit": [
      {
        "start_point": [
          165,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "void\ntty_setedit (int on)\n{\n  if (on)\n    termbuf.sg.sg_flags &= ~CBREAK;\n  else\n    termbuf.sg.sg_flags |= CBREAK;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          407,
          0
        ],
        "end_point": [
          414,
          1
        ],
        "content": "void\ntty_setedit (int on)\n{\n  if (on)\n    termbuf.c_lflag |= ICANON;\n  else\n    termbuf.c_lflag &= ~ICANON;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_setsig": [
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          177,
          1
        ],
        "content": "void\ntty_setsig (int on)\n{\n}",
        "lines": 4,
        "depth": 5,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          416,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "void\ntty_setsig (int on)\n{\n  if (on)\n    termbuf.c_lflag |= ISIG;\n  else\n    termbuf.c_lflag &= ~ISIG;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_issofttab": [
      {
        "start_point": [
          179,
          0
        ],
        "end_point": [
          183,
          1
        ],
        "content": "int\ntty_issofttab ()\n{\n  return termbuf.sg.sg_flags & XTABS;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          434,
          1
        ],
        "content": "int\ntty_issofttab (void)\n{\n# ifdef\tOXTABS\n  return termbuf.c_oflag & OXTABS;\n# endif\n# ifdef\tTABDLY\n  return (termbuf.c_oflag & TABDLY) == TAB3;\n# endif\n}",
        "lines": 10,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setsofttab": [
      {
        "start_point": [
          185,
          0
        ],
        "end_point": [
          192,
          1
        ],
        "content": "void\ntty_setsofttab (int on)\n{\n  if (on)\n    termbuf.sg.sg_flags |= XTABS;\n  else\n    termbuf.sg.sg_flags &= ~XTABS;\n}",
        "lines": 8,
        "depth": 8,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          436,
          0
        ],
        "end_point": [
          459,
          1
        ],
        "content": "void\ntty_setsofttab (int on)\n{\n  if (on)\n    {\n# ifdef\tOXTABS\n      termbuf.c_oflag |= OXTABS;\n# endif\n# ifdef\tTABDLY\n      termbuf.c_oflag &= ~TABDLY;\n      termbuf.c_oflag |= TAB3;\n# endif\n    }\n  else\n    {\n# ifdef\tOXTABS\n      termbuf.c_oflag &= ~OXTABS;\n# endif\n# ifdef\tTABDLY\n      termbuf.c_oflag &= ~TABDLY;\n      termbuf.c_oflag |= TAB0;\n# endif\n    }\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_islitecho": [
      {
        "start_point": [
          194,
          0
        ],
        "end_point": [
          198,
          1
        ],
        "content": "int\ntty_islitecho ()\n{\n  return !(termbuf.lflags & LCTLECH);\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          461,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\ntty_islitecho (void)\n{\n# ifdef\tECHOCTL\n  return !(termbuf.c_lflag & ECHOCTL);\n# endif\n# ifdef\tTCTLECH\n  return !(termbuf.c_lflag & TCTLECH);\n# endif\n# if !defined ECHOCTL && !defined TCTLECH\n  return 0;\t\t\t/* assumes ctl chars are echoed '^x' */\n# endif\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "tty_setlitecho": [
      {
        "start_point": [
          200,
          0
        ],
        "end_point": [
          207,
          1
        ],
        "content": "void\ntty_setlitecho (int on)\n{\n  if (on)\n    termbuf.lflags &= ~LCTLECH;\n  else\n    termbuf.lflags |= LCTLECH;\n}",
        "lines": 8,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          475,
          0
        ],
        "end_point": [
          490,
          1
        ],
        "content": "void\ntty_setlitecho (int on)\n{\n# ifdef\tECHOCTL\n  if (on)\n    termbuf.c_lflag &= ~ECHOCTL;\n  else\n    termbuf.c_lflag |= ECHOCTL;\n# endif\n# ifdef\tTCTLECH\n  if (on)\n    termbuf.c_lflag &= ~TCTLECH;\n  else\n    termbuf.c_lflag |= TCTLECH;\n# endif\n}",
        "lines": 16,
        "depth": 8,
        "decorators": [
          "void"
        ]
      }
    ],
    "tty_iscrnl": [
      {
        "start_point": [
          209,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "int\ntty_iscrnl ()\n{\n  return termbuf.sg.sg_flags & CRMOD;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          492,
          0
        ],
        "end_point": [
          496,
          1
        ],
        "content": "int\ntty_iscrnl (void)\n{\n  return termbuf.c_iflag & ICRNL;\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "int"
        ]
      }
    ],
    "init_termbuf": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        505,
        1
      ],
      "content": "void\ninit_termbuf (void)\n{\n  _term_getattr (pty, &termbuf);\n  termbuf2 = termbuf;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "copy_termbuf": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "void\ncopy_termbuf ()\n{\n  size_t len = 0;\n  char *cp = (char *) &termbuf;\n\n  while (pty_input_level () > 0)\n    {\n      if (len >= sizeof (termbuf))\n\tbreak;\n      *cp++ = pty_get_char (0);\n      len++;\n    }\n  termbuf2 = termbuf;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "set_termbuf": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "void\nset_termbuf (void)\n{\n  if (memcmp (&termbuf, &termbuf2, sizeof (termbuf)))\n    _term_setattr (pty, &termbuf);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spcset": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "int\nspcset (int func, cc_t * valp, cc_t ** valpp)\n{\n  switch (func)\n    {\n    case SLC_EOF:\n      setval (termdesc_eofc, SLC_VARIABLE);\n\n    case SLC_EC:\n      setval (termdesc_erase, SLC_VARIABLE);\n\n    case SLC_EL:\n      setval (termdesc_kill, SLC_VARIABLE);\n\n    case SLC_IP:\n      setval (termdesc_ip, SLC_VARIABLE | SLC_FLUSHIN | SLC_FLUSHOUT);\n\n    case SLC_ABORT:\n      setval (termdesc_abort, SLC_VARIABLE | SLC_FLUSHIN | SLC_FLUSHOUT);\n\n    case SLC_XON:\n#ifdef termdesc_xon\n      setval (termdesc_xon, SLC_VARIABLE);\n#else\n      defval (0x13);\n#endif\n\n    case SLC_XOFF:\n#ifdef termdesc_xoff\n      setval (termdesc_xoff, SLC_VARIABLE);\n#else\n      defval (0x11);\n#endif\n\n    case SLC_EW:\n#ifdef termdesc_ew\n      setval (termdesc_ew, SLC_VARIABLE);\n#else\n      defval (0);\n#endif\n\n    case SLC_RP:\n#ifdef termdesc_rp\n      setval (termdesc_rp, SLC_VARIABLE);\n#else\n      defval (0);\n#endif\n\n    case SLC_LNEXT:\n#ifdef termdesc_lnext\n      setval (termdesc_lnext, SLC_VARIABLE);\n#else\n      defval (0);\n#endif\n\n    case SLC_AO:\n#ifdef termdesc_ao\n      setval (termdesc_ao, SLC_VARIABLE | SLC_FLUSHOUT);\n#else\n      defval (0);\n#endif\n\n    case SLC_SUSP:\n#ifdef termdesc_susp\n      setval (termdesc_susp, SLC_VARIABLE | SLC_FLUSHIN);\n#else\n      defval (0);\n#endif\n\n#ifdef termdesc_forw1\n    case SLC_FORW1:\n      setval (termdesc_forw1, SLC_VARIABLE);\n#endif\n\n#ifdef termdesc_forw2\n    case SLC_FORW2:\n      setval (termdesc_forw2, SLC_VARIABLE);\n#endif\n\n    case SLC_AYT:\n#ifdef termdesc_status\n      setval (termdesc_status, SLC_VARIABLE);\n#else\n      defval (0);\n#endif\n\n    case SLC_BRK:\n    case SLC_SYNCH:\n    case SLC_EOR:\n      defval (0);\n\n    default:\n      *valp = 0;\n      *valpp = 0;\n      return SLC_NOSUPPORT;\n    }\n}",
      "lines": 97,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "tty_tspeed": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "void\ntty_tspeed (int val)\n{\n#ifdef\tDECODE_BAUD\n  struct termspeeds *tp;\n\n  for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)\n    ;\n  if (tp->speed == -1)\t\t/* back up to last valid value */\n    --tp;\n  val = tp->value;\n#endif\n  cfsetospeed (&termbuf, val);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "tty_rspeed": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "void\ntty_rspeed (int val)\n{\n#ifdef\tDECODE_BAUD\n  struct termspeeds *tp;\n\n  for (tp = termspeeds; (tp->speed != -1) && (val > tp->speed); tp++)\n    ;\n  if (tp->speed == -1)\t\t/* back up to last valid value */\n    --tp;\n  val = tp->value;\n#endif\n  cfsetispeed (&termbuf, val);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/termstat.c": {
    "localstat": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "void\nlocalstat (void)\n{\n  void netflush (void);\n  int need_will_echo = 0;\n\n#if defined CRAY2 && defined UNICOS5\n  /*\n   * Keep track of that ol' CR/NL mapping while we're in the\n   * neighborhood.\n   */\n  newmap = tty_isnewmap ();\n#endif /* defined(CRAY2) && defined(UNICOS5) */\n\n  /*\n   * Check for state of BINARY options.\n   */\n  if (tty_isbinaryin ())\n    {\n      if (his_want_state_is_wont (TELOPT_BINARY))\n\tsend_do (TELOPT_BINARY, 1);\n    }\n  else\n    {\n      if (his_want_state_is_will (TELOPT_BINARY))\n\tsend_dont (TELOPT_BINARY, 1);\n    }\n\n  if (tty_isbinaryout ())\n    {\n      if (my_want_state_is_wont (TELOPT_BINARY))\n\tsend_will (TELOPT_BINARY, 1);\n    }\n  else\n    {\n      if (my_want_state_is_will (TELOPT_BINARY))\n\tsend_wont (TELOPT_BINARY, 1);\n    }\n\n  /*\n   * Check for changes to flow control if client supports it.\n   */\n  flowstat ();\n\n  /*\n   * Check linemode on/off state\n   */\n  uselinemode = tty_linemode ();\n\n  /*\n   * If alwayslinemode is on, and pty is changing to turn it off, then\n   * force linemode back on.\n   */\n  if (alwayslinemode && linemode && !uselinemode)\n    {\n      uselinemode = 1;\n      tty_setlinemode (uselinemode);\n    }\n\n#ifdef\tENCRYPTION\n  /*\n   * If the terminal is not echoing, but editing is enabled,\n   * something like password input is going to happen, so\n   * if we the other side is not currently sending encrypted\n   * data, ask the other side to start encrypting.\n   */\n  if (his_state_is_will (TELOPT_ENCRYPT))\n    {\n      static int enc_passwd = 0;\n      if (uselinemode && !tty_isecho () && tty_isediting ()\n\t  && (enc_passwd == 0) && !decrypt_input)\n\t{\n\t  encrypt_send_request_start ();\n\t  enc_passwd = 1;\n\t}\n      else if (enc_passwd)\n\t{\n\t  encrypt_send_request_end ();\n\t  enc_passwd = 0;\n\t}\n    }\n#endif /* ENCRYPTION */\n\n  /*\n   * Do echo mode handling as soon as we know what the\n   * linemode is going to be.\n   * If the pty has echo turned off, then tell the client that\n   * the server will echo.  If echo is on, then the server\n   * will echo if in character mode, but in linemode the\n   * client should do local echoing.  The state machine will\n   * not send anything if it is unnecessary, so don't worry\n   * about that here.\n   *\n   * If we need to send the WILL ECHO (because echo is off),\n   * then delay that until after we have changed the MODE.\n   * This way, when the user is turning off both editing\n   * and echo, the client will get editing turned off first.\n   * This keeps the client from going into encryption mode\n   * and then right back out if it is doing auto-encryption\n   * when passwords are being typed.\n   */\n  if (uselinemode)\n    {\n      if (tty_isecho ())\n\tsend_wont (TELOPT_ECHO, 1);\n      else\n\tneed_will_echo = 1;\n      if (lmodetype == KLUDGE_OK)\n\tlmodetype = KLUDGE_LINEMODE;\n    }\n\n  /*\n   * If linemode is being turned off, send appropriate\n   * command and then we're all done.\n   */\n  if (!uselinemode && linemode)\n    {\n      if (lmodetype == REAL_LINEMODE)\n\t{\n\t  send_dont (TELOPT_LINEMODE, 1);\n\t}\n      else if (lmodetype == KLUDGE_LINEMODE)\n\tsend_will (TELOPT_SGA, 1);\n      send_will (TELOPT_ECHO, 1);\n      linemode = uselinemode;\n      goto done;\n    }\n\n  /*\n   * If using real linemode check edit modes for possible later use.\n   * If we are in kludge linemode, do the SGA negotiation.\n   */\n  if (lmodetype == REAL_LINEMODE)\n    {\n      useeditmode = 0;\n      if (tty_isediting ())\n\tuseeditmode |= MODE_EDIT;\n      if (tty_istrapsig ())\n\tuseeditmode |= MODE_TRAPSIG;\n      if (tty_issofttab ())\n\tuseeditmode |= MODE_SOFT_TAB;\n      if (tty_islitecho ())\n\tuseeditmode |= MODE_LIT_ECHO;\n    }\n  else if (lmodetype == KLUDGE_LINEMODE)\n    {\n      if (tty_isediting () && uselinemode)\n\tsend_wont (TELOPT_SGA, 1);\n      else\n\tsend_will (TELOPT_SGA, 1);\n    }\n\n  /*\n   * Negotiate linemode on if pty state has changed to turn it on.\n   * Send appropriate command and send along edit mode, then all done.\n   */\n  if (uselinemode && !linemode)\n    {\n      if (lmodetype == KLUDGE_LINEMODE)\n\t{\n\t  send_wont (TELOPT_SGA, 1);\n\t}\n      else if (lmodetype == REAL_LINEMODE)\n\t{\n\t  send_do (TELOPT_LINEMODE, 1);\n\t  /* send along edit modes */\n\t  net_output_data (\"%c%c%c%c%c%c%c\", IAC, SB,\n\t\t\t   TELOPT_LINEMODE, LM_MODE, useeditmode, IAC, SE);\n\t  editmode = useeditmode;\n\t}\n      linemode = uselinemode;\n      goto done;\n    }\n\n  /*\n   * None of what follows is of any value if not using\n   * real linemode.\n   */\n  if (lmodetype < REAL_LINEMODE)\n    goto done;\n\n  if (linemode && his_state_is_will (TELOPT_LINEMODE))\n    {\n      /*\n       * If edit mode changed, send edit mode.\n       */\n      if (useeditmode != editmode)\n\t{\n\t  /*\n\t   * Send along appropriate edit mode mask.\n\t   */\n\t  net_output_data (\"%c%c%c%c%c%c%c\", IAC, SB,\n\t\t\t   TELOPT_LINEMODE, LM_MODE, useeditmode, IAC, SE);\n\t  editmode = useeditmode;\n\t}\n\n\n      /*\n       * Check for changes to special characters in use.\n       */\n      start_slc (0);\n      check_slc ();\n      end_slc (0);\n    }\n\ndone:\n  if (need_will_echo)\n    send_will (TELOPT_ECHO, 1);\n  /*\n   * Some things should be deferred until after the pty state has\n   * been set by the local process.  Do those things that have been\n   * deferred now.  This only happens once.\n   */\n  if (_terminit == 0)\n    {\n      _terminit = 1;\n      defer_terminit ();\n    }\n\n  netflush ();\n  set_termbuf ();\n  return;\n\n}",
      "lines": 224,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "flowstat": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "void\nflowstat (void)\n{\n  if (his_state_is_will (TELOPT_LFLOW))\n    {\n      if (tty_flowmode () != flowmode)\n\t{\n\t  flowmode = tty_flowmode ();\n\t  net_output_data (\"%c%c%c%c%c%c\",\n\t\t\t   IAC, SB, TELOPT_LFLOW,\n\t\t\t   flowmode ? LFLOW_ON : LFLOW_OFF, IAC, SE);\n\t}\n      if (tty_restartany () != restartany)\n\t{\n\t  restartany = tty_restartany ();\n\t  net_output_data (\"%c%c%c%c%c%c\",\n\t\t\t   IAC, SB, TELOPT_LFLOW,\n\t\t\t   restartany ? LFLOW_RESTART_ANY\n\t\t\t   : LFLOW_RESTART_XON, IAC, SE);\n\t}\n    }\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "clientstat": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "void\nclientstat (register int code, register int parm1, register int parm2)\n{\n  void netflush (void);\n\n  /*\n   * Get a copy of terminal characteristics.\n   */\n  init_termbuf ();\n\n  /*\n   * Process request from client. code tells what it is.\n   */\n  switch (code)\n    {\n    case TELOPT_LINEMODE:\n      /*\n       * Don't do anything unless client is asking us to change\n       * modes.\n       */\n      uselinemode = (parm1 == WILL);\n      if (uselinemode != linemode)\n\t{\n\t  /*\n\t   * If using kludge linemode, make sure that\n\t   * we can do what the client asks.\n\t   * We cannot turn off linemode if alwayslinemode\n\t   * and the ICANON bit is set.\n\t   */\n\t  if (lmodetype == KLUDGE_LINEMODE)\n\t    {\n\t      if (alwayslinemode && tty_isediting ())\n\t\t{\n\t\t  uselinemode = 1;\n\t\t}\n\t    }\n\n\t  /*\n\t   * Quit now if we can't do it.\n\t   */\n\t  if (uselinemode == linemode)\n\t    return;\n\n\t  /*\n\t   * If using real linemode and linemode is being\n\t   * turned on, send along the edit mode mask.\n\t   */\n\t  if (lmodetype == REAL_LINEMODE && uselinemode)\n\t    if (uselinemode)\n\t      {\n\t\tuseeditmode = 0;\n\t\tif (tty_isediting ())\n\t\t  useeditmode |= MODE_EDIT;\n\t\tif (tty_istrapsig ())\n\t\t  useeditmode |= MODE_TRAPSIG;\n\t\tif (tty_issofttab ())\n\t\t  useeditmode |= MODE_SOFT_TAB;\n\t\tif (tty_islitecho ())\n\t\t  useeditmode |= MODE_LIT_ECHO;\n\t\tnet_output_data (\"%c%c%c%c%c%c%c\", IAC,\n\t\t\t\t SB, TELOPT_LINEMODE, LM_MODE,\n\t\t\t\t useeditmode, IAC, SE);\n\t\teditmode = useeditmode;\n\t      }\n\n\n\t  tty_setlinemode (uselinemode);\n\n\t  linemode = uselinemode;\n\n\t  if (!linemode)\n\t    send_will (TELOPT_ECHO, 1);\n\t}\n      break;\n\n    case LM_MODE:\n      {\n\tregister int ack, changed;\n\n\t/*\n\t * Client has sent along a mode mask.  If it agrees with\n\t * what we are currently doing, ignore it; if not, it could\n\t * be viewed as a request to change.  Note that the server\n\t * will change to the modes in an ack if it is different from\n\t * what we currently have, but we will not ack the ack.\n\t */\n\tuseeditmode &= MODE_MASK;\n\tack = (useeditmode & MODE_ACK);\n\tuseeditmode &= ~MODE_ACK;\n\n\tif ((changed = (useeditmode ^ editmode)))\n\t  {\n\t    /*\n\t     * This check is for a timing problem.  If the\n\t     * state of the tty has changed (due to the user\n\t     * application) we need to process that info\n\t     * before we write in the state contained in the\n\t     * ack!!!  This gets out the new MODE request,\n\t     * and when the ack to that command comes back\n\t     * we'll set it and be in the right mode.\n\t     */\n\t    if (ack)\n\t      localstat ();\n\t    if (changed & MODE_EDIT)\n\t      tty_setedit (useeditmode & MODE_EDIT);\n\n\t    if (changed & MODE_TRAPSIG)\n\t      tty_setsig (useeditmode & MODE_TRAPSIG);\n\n\t    if (changed & MODE_SOFT_TAB)\n\t      tty_setsofttab (useeditmode & MODE_SOFT_TAB);\n\n\t    if (changed & MODE_LIT_ECHO)\n\t      tty_setlitecho (useeditmode & MODE_LIT_ECHO);\n\n\t    set_termbuf ();\n\n\t    if (!ack)\n\t      {\n\t\tnet_output_data (\"%c%c%c%c%c%c%c\", IAC,\n\t\t\t\t SB, TELOPT_LINEMODE, LM_MODE,\n\t\t\t\t useeditmode | MODE_ACK, IAC, SE);\n\t      }\n\n\t    editmode = useeditmode;\n\t  }\n\n\tbreak;\n\n      }\t\t\t\t/* end of case LM_MODE */\n\n    case TELOPT_NAWS:\n#ifdef\tTIOCSWINSZ\n      {\n\tstruct winsize ws;\n\n\tdef_col = parm1;\n\tdef_row = parm2;\n\t/*\n\t * Defer changing window size until after terminal is\n\t * initialized.\n\t */\n\tif (terminit () == 0)\n\t  return;\n\n\t/*\n\t * Change window size as requested by client.\n\t */\n\n\tws.ws_col = parm1;\n\tws.ws_row = parm2;\n\tioctl (pty, TIOCSWINSZ, (char *) &ws);\n      }\n#endif /* TIOCSWINSZ */\n\n      break;\n\n    case TELOPT_TSPEED:\n      {\n\tdef_tspeed = parm1;\n\tdef_rspeed = parm2;\n\t/*\n\t * Defer changing the terminal speed.\n\t */\n\tif (terminit () == 0)\n\t  return;\n\t/*\n\t * Change terminal speed as requested by client.\n\t * We set the receive speed first, so that if we can't\n\t * store seperate receive and transmit speeds, the transmit\n\t * speed will take precedence.\n\t */\n\ttty_rspeed (parm2);\n\ttty_tspeed (parm1);\n\tset_termbuf ();\n\n\tbreak;\n\n      }\t\t\t\t/* end of case TELOPT_TSPEED */\n\n    default:\n      /* What? */\n      break;\n    }\t\t\t\t/* end of switch */\n\n#if defined CRAY2 && defined UNICOS5\n  /*\n   * Just in case of the likely event that we changed the pty state.\n   */\n  rcv_ioctl ();\n#endif /* defined(CRAY2) && defined(UNICOS5) */\n\n  netflush ();\n\n}",
      "lines": 195,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "termstat": {
      "start_point": [
        600,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "void\ntermstat ()\n{\n  needtermstat = 1;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "_termstat": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        613,
        1
      ],
      "content": "void\n_termstat ()\n{\n  needtermstat = 0;\n  init_termbuf ();\n  localstat ();\n  rcv_ioctl ();\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "defer_terminit": {
      "start_point": [
        624,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "void\ndefer_terminit (void)\n{\n\n  /*\n   * local stuff that got deferred.\n   */\n  if (def_tspeed != -1)\n    {\n      clientstat (TELOPT_TSPEED, def_tspeed, def_rspeed);\n      def_tspeed = def_rspeed = 0;\n    }\n\n#ifdef\tTIOCSWINSZ\n  if (def_col || def_row)\n    {\n      struct winsize ws;\n\n      memset ((char *) &ws, 0, sizeof (ws));\n      ws.ws_col = def_col;\n      ws.ws_row = def_row;\n      ioctl (pty, TIOCSWINSZ, (char *) &ws);\n    }\n#endif\n\n  /*\n   * The only other module that currently defers anything.\n   */\n  deferslc ();\n\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "terminit": {
      "start_point": [
        661,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "int\nterminit (void)\n{\n  return (_terminit);\n\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/telnetd/utility.c": {
    "readstream": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\nreadstream (int p, char *ibuf, int bufsize)\n{\n#ifndef HAVE_STREAMSPTY\n  return read (p, ibuf, bufsize);\n#else\n  int flags = 0;\n  int ret = 0;\n  struct termios *tsp;\n#ifdef HAVE_TERMIO_H\n  struct termio *tp;\n#endif\n  struct iocblk *ip;\n  char vstop, vstart;\n  int ixon;\n  int newflow;\n  struct strbuf strbufc, strbufd;\n  unsigned char ctlbuf[BUFSIZ];\n  static int flowstate = -1;\n\n  strbufc.maxlen = BUFSIZ;\n  strbufc.buf = (char *) ctlbuf;\n  strbufd.maxlen = bufsize - 1;\n  strbufd.len = 0;\n  strbufd.buf = ibuf + 1;\n  ibuf[0] = 0;\n\n  ret = getmsg (p, &strbufc, &strbufd, &flags);\n  if (ret < 0)\t\t\t/* error of some sort -- probably EAGAIN */\n    return -1;\n\n  if (strbufc.len <= 0 || ctlbuf[0] == M_DATA)\n    {\n      /* data message */\n      if (strbufd.len > 0)\t/* real data */\n\treturn strbufd.len + 1;\t/* count header char */\n      else\n\t{\n\t  /* nothing there */\n\t  errno = EAGAIN;\n\t  return -1;\n\t}\n    }\n\n  /*\n   * It's a control message.  Return 1, to look at the flag we set\n   */\n\n  switch (ctlbuf[0])\n    {\n    case M_FLUSH:\n      if (ibuf[1] & FLUSHW)\n\tibuf[0] = TIOCPKT_FLUSHWRITE;\n      return 1;\n\n    case M_IOCTL:\n      ip = (struct iocblk *) (ibuf + 1);\n\n      switch (ip->ioc_cmd)\n\t{\n\tcase TCSETS:\n\tcase TCSETSW:\n\tcase TCSETSF:\n\t  tsp = (struct termios *) (ibuf + 1 + sizeof (struct iocblk));\n\t  vstop = tsp->c_cc[VSTOP];\n\t  vstart = tsp->c_cc[VSTART];\n\t  ixon = tsp->c_iflag & IXON;\n\t  break;\n\n#ifdef HAVE_TERMIO_H\n\tcase TCSETA:\n\tcase TCSETAW:\n\tcase TCSETAF:\n\t  tp = (struct termio *) (ibuf + 1 + sizeof (struct iocblk));\n\t  vstop = tp->c_cc[VSTOP];\n\t  vstart = tp->c_cc[VSTART];\n\t  ixon = tp->c_iflag & IXON;\n\t  break;\n#endif /* HAVE_TERMIO_H */\n\n\tdefault:\n\t  errno = EAGAIN;\n\t  return -1;\n\t}\n\n      newflow = (ixon && (vstart == 021) && (vstop == 023)) ? 1 : 0;\n      if (newflow != flowstate)\t/* it's a change */\n\t{\n\t  flowstate = newflow;\n\t  ibuf[0] = newflow ? TIOCPKT_DOSTOP : TIOCPKT_NOSTOP;\n\t  return 1;\n\t}\n    }\n\n  /* nothing worth doing anything about */\n  errno = EAGAIN;\n  return -1;\n#endif /* HAVE_STREAMSPTY */\n}",
      "lines": 99,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "io_setup": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void\nio_setup (void)\n{\n  pfrontp = pbackp = ptyobuf;\n  nfrontp = nbackp = netobuf;\n#ifdef  ENCRYPTION\n  nclearto = 0;\n#endif\n  netip = netibuf;\n  ptyip = ptyibuf;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "set_neturg": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "void\nset_neturg (void)\n{\n  neturg = nfrontp - 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "net_output_byte": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\nnet_output_byte (int c)\n{\n  *nfrontp++ = c;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "net_output_data": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nnet_output_data (const char *format, ...)\n{\n  va_list args;\n  size_t remaining, ret;\n\n  va_start (args, format);\n  remaining = BUFSIZ - (nfrontp - netobuf);\n  /* try a netflush() if the room is too low */\n  if (strlen (format) > remaining || BUFSIZ / 4 > remaining)\n    {\n      netflush ();\n      remaining = BUFSIZ - (nfrontp - netobuf);\n    }\n  ret = vsnprintf (nfrontp, remaining, format, args);\n  nfrontp += ((ret < remaining - 1) ? ret : remaining - 1);\n  va_end (args);\n  return ret;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "net_output_datalen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\nnet_output_datalen (const void *buf, size_t l)\n{\n  size_t remaining;\n\n  remaining = BUFSIZ - (nfrontp - netobuf);\n  if (remaining < l)\n    {\n      netflush ();\n      remaining = BUFSIZ - (nfrontp - netobuf);\n    }\n  if (remaining < l)\n    return -1;\n  memmove (nfrontp, buf, l);\n  nfrontp += l;\n  return (int) l;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "net_input_level": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "int\nnet_input_level (void)\n{\n  return ncc;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "net_output_level": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "int\nnet_output_level (void)\n{\n  return nfrontp - nbackp;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "net_buffer_is_full": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "int\nnet_buffer_is_full (void)\n{\n  return (&netobuf[BUFSIZ] - nfrontp) < 2;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "net_get_char": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "int\nnet_get_char (int peek)\n{\n  if (peek)\n    return *netip;\n  else if (ncc > 0)\n    {\n      ncc--;\n      return *netip++ & 0377;\n    }\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "net_read": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "int\nnet_read (void)\n{\n  ncc = read (net, netibuf, sizeof (netibuf));\n  if (ncc < 0 && errno == EWOULDBLOCK)\n    ncc = 0;\n  else if (ncc == 0)\n    {\n      syslog (LOG_INFO, \"telnetd:  peer died\");\n      cleanup (0);\n      /* NOT REACHED */\n    }\n  else if (ncc > 0)\n    {\n      netip = netibuf;\n      DEBUG (debug_report, 1,\n\t     debug_output_data (\"td: netread %d chars\\r\\n\", ncc));\n      DEBUG (debug_net_data, 1, printdata (\"nd\", netip, ncc));\n    }\n  return ncc;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "pty_buffer_is_full": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\npty_buffer_is_full (void)\n{\n  return (&ptyobuf[BUFSIZ] - pfrontp) < 2;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pty_output_byte": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void\npty_output_byte (int c)\n{\n  *pfrontp++ = c;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "pty_output_datalen": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void\npty_output_datalen (const void *data, size_t len)\n{\n  if ((size_t) (&ptyobuf[BUFSIZ] - pfrontp) > len)\n    ptyflush ();\n  memcpy (pfrontp, data, len);\n  pfrontp += len;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "pty_input_level": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int\npty_input_level (void)\n{\n  return pcc;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "pty_output_level": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "int\npty_output_level (void)\n{\n  return pfrontp - pbackp;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "ptyflush": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "void\nptyflush (void)\n{\n  int n;\n\n  if ((n = pfrontp - pbackp) > 0)\n    {\n      DEBUG (debug_report, 1,\n\t     debug_output_data (\"td: ptyflush %d chars\\r\\n\", n));\n      DEBUG (debug_pty_data, 1, printdata (\"pd\", pbackp, n));\n      n = write (pty, pbackp, n);\n    }\n\n  if (n < 0)\n    {\n      if (errno == EWOULDBLOCK || errno == EINTR)\n\treturn;\n      cleanup (0);\n      /* NOT REACHED */\n    }\n\n  pbackp += n;\n  if (pbackp == pfrontp)\n    pbackp = pfrontp = ptyobuf;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "pty_get_char": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "int\npty_get_char (int peek)\n{\n  if (peek)\n    return *ptyip;\n  else if (pcc > 0)\n    {\n      pcc--;\n      return *ptyip++ & 0377;\n    }\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "pty_input_putback": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int\npty_input_putback (const char *str, size_t len)\n{\n  if (len > (size_t) (&ptyibuf[BUFSIZ] - ptyip))\n    len = &ptyibuf[BUFSIZ] - ptyip;\n  strncpy (ptyip, str, len);\n  pcc += len;\n\n  return 0;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "pty_read": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int\npty_read (void)\n{\n  pcc = readstream (pty, ptyibuf, BUFSIZ);\n  if (pcc < 0 && (errno == EWOULDBLOCK\n#ifdef\tEAGAIN\n\t\t  || errno == EAGAIN\n#endif\n\t\t  || errno == EIO))\n    pcc = 0;\n  ptyip = ptyibuf;\n\n  DEBUG (debug_report, 1, debug_output_data (\"td: ptyread %d chars\\r\\n\", pcc));\n  DEBUG (debug_pty_data, 1, printdata (\"pd\", ptyip, pcc));\n  return pcc;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "io_drain": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "void\nio_drain (void)\n{\n  fd_set rfds;\n\n  DEBUG (debug_report, 1, debug_output_data (\"td: ttloop\\r\\n\"));\n  if (nfrontp - nbackp > 0)\n    netflush ();\n\n  FD_ZERO(&rfds);\n  FD_SET(net, &rfds);\n  if (1 != select(net + 1, &rfds, NULL, NULL, NULL))\n    {\n      syslog (LOG_INFO, \"ttloop:  select: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  ncc = read (net, netibuf, sizeof netibuf);\n  if (ncc < 0)\n    {\n      syslog (LOG_INFO, \"ttloop:  read: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n  else if (ncc == 0)\n    {\n      syslog (LOG_INFO, \"ttloop:  peer died: %m\\n\");\n      exit (EXIT_FAILURE);\n    }\n  DEBUG (debug_report, 1,\n\t debug_output_data (\"td: ttloop read %d chars\\r\\n\", ncc));\n  netip = netibuf;\n  telrcv ();\t\t\t/* state machine */\n  if (ncc > 0)\n    {\n      pfrontp = pbackp = ptyobuf;\n      telrcv ();\n    }\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "stilloob": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "int\nstilloob (int s)\n{\n  static struct timeval timeout = { 0, 0 };\n  fd_set excepts;\n  int value;\n\n  do\n    {\n      FD_ZERO (&excepts);\n      FD_SET (s, &excepts);\n      value = select (s + 1, (fd_set *) 0, (fd_set *) 0, &excepts, &timeout);\n    }\n  while (value == -1 && errno == EINTR);\n\n  if (value < 0)\n    fatalperror (pty, \"select\");\n\n  return FD_ISSET (s, &excepts);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "nextitem": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "char *\nnextitem (char *current)\n{\n  if ((*current & 0xff) != IAC)\n    return current + 1;\n\n  switch (*(current + 1) & 0xff)\n    {\n    case DO:\n    case DONT:\n    case WILL:\n    case WONT:\n      return current + 3;\n\n    case SB:\t\t\t/* loop forever looking for the SE */\n      {\n\tchar *look = current + 2;\n\n\tfor (;;)\n\t  if ((*look++ & 0xff) == IAC && (*look++ & 0xff) == SE)\n\t    return look;\n\n      default:\n\treturn current + 2;\n      }\n    }\n}",
      "lines": 27,
      "depth": 16,
      "decorators": [
        "char",
        "*\nnextitem (char *current)",
        "*"
      ]
    },
    "netclear": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "void\nnetclear (void)\n{\n  char *thisitem, *next;\n  char *good;\n\n#ifdef\tENCRYPTION\n  thisitem = nclearto > netobuf ? nclearto : netobuf;\n#else /* ENCRYPTION */\n  thisitem = netobuf;\n#endif /* ENCRYPTION */\n\n  while ((next = nextitem (thisitem)) <= nbackp)\n    thisitem = next;\n\n  /* Now, thisitem is first before/at boundary. */\n\n#ifdef\tENCRYPTION\n  good = nclearto > netobuf ? nclearto : netobuf;\n#else /* ENCRYPTION */\n  good = netobuf;\t\t/* where the good bytes go */\n#endif /* ENCRYPTION */\n\n  while (nfrontp > thisitem)\n    {\n      if (wewant (thisitem))\n\t{\n\t  int length;\n\n\t  for (next = thisitem; wewant (next) && nfrontp > next;\n\t       next = nextitem (next))\n\t    ;\n\n\t  length = next - thisitem;\n\t  memmove (good, thisitem, length);\n\t  good += length;\n\t  thisitem = next;\n\t}\n      else\n\t{\n\t  thisitem = nextitem (thisitem);\n\t}\n    }\n\n  nbackp = netobuf;\n  nfrontp = good;\t\t/* next byte to be sent */\n  neturg = 0;\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "netflush": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        639,
        1
      ],
      "content": "void\nnetflush (void)\n{\n  int n;\n\n  if ((n = nfrontp - nbackp) > 0)\n    {\n      NET_ENCRYPT ();\n\n      /*\n       * if no urgent data, or if the other side appears to be an\n       * old 4.2 client (and thus unable to survive TCP urgent data),\n       * write the entire buffer in non-OOB mode.\n       */\n      if (!neturg || !not42)\n\tn = write (net, nbackp, n);\t/* normal write */\n      else\n\t{\n\t  n = neturg - nbackp;\n\t  /*\n\t   * In 4.2 (and 4.3) systems, there is some question about\n\t   * what byte in a sendOOB operation is the \"OOB\" data.\n\t   * To make ourselves compatible, we only send ONE byte\n\t   * out of band, the one WE THINK should be OOB (though\n\t   * we really have more the TCP philosophy of urgent data\n\t   * rather than the Unix philosophy of OOB data).\n\t   */\n\t  if (n > 1)\n\t    n = send (net, nbackp, n - 1, 0);\t/* send URGENT all by itself */\n\t  else\n\t    n = send (net, nbackp, n, MSG_OOB);\t/* URGENT data */\n\t}\n    }\n  if (n < 0)\n    {\n      if (errno == EWOULDBLOCK || errno == EINTR)\n\treturn;\n      cleanup (0);\n      /* NOT REACHED */\n    }\n\n  nbackp += n;\n#ifdef\tENCRYPTION\n  if (nbackp > nclearto)\n    nclearto = 0;\n#endif /* ENCRYPTION */\n  if (nbackp >= neturg)\n    neturg = 0;\n\n  if (nbackp == nfrontp)\n    {\n      nbackp = nfrontp = netobuf;\n#ifdef\tENCRYPTION\n      nclearto = 0;\n#endif /* ENCRYPTION */\n    }\n  DEBUG (debug_report, 1, debug_output_data (\"td: netflush %d chars\\r\\n\", n));\n\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fatal": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "void\nfatal (int f, char *msg)\n{\n  char buf[BUFSIZ];\n\n  snprintf (buf, sizeof buf, \"telnetd: %s.\\r\\n\", msg);\n#ifdef\tENCRYPTION\n  if (encrypt_output)\n    {\n      /*\n       * Better turn off encryption first....\n       * Hope it flushes...\n       */\n      encrypt_send_end ();\n      netflush ();\n    }\n#endif /* ENCRYPTION */\n  write (f, buf, (int) strlen (buf));\n  sleep (1);\n  /*FIXME*/ exit (EXIT_FAILURE);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fatalperror": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "void\nfatalperror (int f, char *msg)\n{\n  char buf[BUFSIZ];\n\n  snprintf (buf, sizeof buf, \"%s: %s\", msg, strerror (errno));\n  fatal (f, buf);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_gettermname": {
      "start_point": [
        683,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void\n_gettermname (void)\n{\n  if (his_state_is_wont (TELOPT_TTYPE))\n    return;\n  settimer (baseline);\n  net_output_datalen (ttytype_sbbuf, sizeof ttytype_sbbuf);\n  ttloop (sequenceIs (ttypesubopt, baseline));\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getterminaltype": {
      "start_point": [
        696,
        0
      ],
      "end_point": [
        847,
        1
      ],
      "content": "int\ngetterminaltype (char *uname, size_t len)\n{\n  int retval = -1;\n\n  settimer (baseline);\n#if defined AUTHENTICATION\n  /*\n   * Handle the Authentication option before we do anything else.\n   * Distinguish the available modes by level:\n   *\n   *   off:\t\t\tAuthentication is forbidden.\n   *   none:\t\t\tVolontary authentication.\n   *   user, valid, other:\tMandatory authentication only.\n   */\n  if (auth_level < 0)\n    send_wont (TELOPT_AUTHENTICATION, 1);\n  else\n    {\n      if (auth_level > 0)\n\tsend_do (TELOPT_AUTHENTICATION, 1);\n      else\n\tsend_will (TELOPT_AUTHENTICATION, 1);\n\n      ttloop (his_will_wont_is_changing (TELOPT_AUTHENTICATION));\n\n      if (his_state_is_will (TELOPT_AUTHENTICATION))\n\tretval = auth_wait (uname, len);\n    }\n#else /* !AUTHENTICATION */\n  (void) uname;\t/* Silence warning.  */\n#endif\n\n#ifdef\tENCRYPTION\n  send_will (TELOPT_ENCRYPT, 1);\n#endif /* ENCRYPTION */\n  send_do (TELOPT_TTYPE, 1);\n  send_do (TELOPT_TSPEED, 1);\n  send_do (TELOPT_XDISPLOC, 1);\n  send_do (TELOPT_NEW_ENVIRON, 1);\n  send_do (TELOPT_OLD_ENVIRON, 1);\n\n#ifdef ENCRYPTION\n  ttloop (his_do_dont_is_changing (TELOPT_ENCRYPT)\n\t  || his_will_wont_is_changing (TELOPT_TTYPE)\n\t  || his_will_wont_is_changing (TELOPT_TSPEED)\n\t  || his_will_wont_is_changing (TELOPT_XDISPLOC)\n\t  || his_will_wont_is_changing (TELOPT_NEW_ENVIRON)\n\t  || his_will_wont_is_changing (TELOPT_OLD_ENVIRON));\n#else\n  ttloop (his_will_wont_is_changing (TELOPT_TTYPE)\n\t  || his_will_wont_is_changing (TELOPT_TSPEED)\n\t  || his_will_wont_is_changing (TELOPT_XDISPLOC)\n\t  || his_will_wont_is_changing (TELOPT_NEW_ENVIRON)\n\t  || his_will_wont_is_changing (TELOPT_OLD_ENVIRON));\n#endif\n\n#ifdef  ENCRYPTION\n  if (his_state_is_will (TELOPT_ENCRYPT))\n    encrypt_wait ();\n#endif\n\n  if (his_state_is_will (TELOPT_TSPEED))\n    {\n      static unsigned char sb[] =\n\t{ IAC, SB, TELOPT_TSPEED, TELQUAL_SEND, IAC, SE };\n\n      net_output_datalen (sb, sizeof sb);\n    }\n  if (his_state_is_will (TELOPT_XDISPLOC))\n    {\n      static unsigned char sb[] =\n\t{ IAC, SB, TELOPT_XDISPLOC, TELQUAL_SEND, IAC, SE };\n\n      net_output_datalen (sb, sizeof sb);\n    }\n  if (his_state_is_will (TELOPT_NEW_ENVIRON))\n    {\n      static unsigned char sb[] =\n\t{ IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_SEND, IAC, SE };\n\n      net_output_datalen (sb, sizeof sb);\n    }\n  else if (his_state_is_will (TELOPT_OLD_ENVIRON))\n    {\n      static unsigned char sb[] =\n\t{ IAC, SB, TELOPT_OLD_ENVIRON, TELQUAL_SEND, IAC, SE };\n\n      net_output_datalen (sb, sizeof sb);\n    }\n  if (his_state_is_will (TELOPT_TTYPE))\n    net_output_datalen (ttytype_sbbuf, sizeof ttytype_sbbuf);\n\n  if (his_state_is_will (TELOPT_TSPEED))\n    ttloop (sequenceIs (tspeedsubopt, baseline));\n  if (his_state_is_will (TELOPT_XDISPLOC))\n    ttloop (sequenceIs (xdisplocsubopt, baseline));\n  if (his_state_is_will (TELOPT_NEW_ENVIRON))\n    ttloop (sequenceIs (environsubopt, baseline));\n  if (his_state_is_will (TELOPT_OLD_ENVIRON))\n    ttloop (sequenceIs (oenvironsubopt, baseline));\n\n  if (his_state_is_will (TELOPT_TTYPE))\n    {\n      char *first = NULL, *last = NULL;\n\n      ttloop (sequenceIs (ttypesubopt, baseline));\n      /*\n       * If the other side has already disabled the option, then\n       * we have to just go with what we (might) have already gotten.\n       */\n      if (his_state_is_will (TELOPT_TTYPE) && !terminaltypeok (terminaltype))\n\t{\n\t  free (first);\n\t  first = xstrdup (terminaltype);\n\t  for (;;)\n\t    {\n\t      /* Save the unknown name, and request the next name. */\n\t      free (last);\n\t      last = xstrdup (terminaltype);\n\t      _gettermname ();\n\t      if (terminaltypeok (terminaltype))\n\t\tbreak;\n\t      if ((strcmp (last, terminaltype) == 0)\n\t\t  || his_state_is_wont (TELOPT_TTYPE))\n\t\t{\n\t\t  /*\n\t\t   * We've hit the end.  If this is the same as\n\t\t   * the first name, just go with it.\n\t\t   */\n\t\t  if (strcmp (first, terminaltype) == 0)\n\t\t    break;\n\t\t  /*\n\t\t   * Get the terminal name one more time, so that\n\t\t   * RFC1091 compliant telnets will cycle back to\n\t\t   * the start of the list.\n\t\t   */\n\t\t  _gettermname ();\n\t\t  if (strcmp (first, terminaltype) != 0)\n\t\t    {\n\t\t      free (terminaltype);\n\t\t      terminaltype = xstrdup (first);\n\t\t    }\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      free (first);\n      free (last);\n    }\n  return retval;\n}",
      "lines": 152,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "terminaltypeok": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "int\nterminaltypeok (char *s)\n{\n#ifdef HAVE_TGETENT\n  char buf[2048];\n\n  if (terminaltype == NULL)\n    return 1;\n\n  if (tgetent (buf, s) == 0)\n    return 0;\n#endif /* HAVE_TGETENT */\n\n  return 1;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "debug_open": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "static int\ndebug_open (void)\n{\n  int um = umask (077);\n  if (!debug_fp)\n    debug_fp = fopen (\"/tmp/telnet.debug\", \"a\");\n  umask (um);\n  return debug_fp == NULL;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "debug_close": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        895,
        1
      ],
      "content": "static int\ndebug_close (void)\n{\n  if (debug_fp)\n    fclose (debug_fp);\n  debug_fp = NULL;\n\n  return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "debug_output_datalen": {
      "start_point": [
        897,
        0
      ],
      "end_point": [
        905,
        1
      ],
      "content": "void\ndebug_output_datalen (const char *data, size_t len)\n{\n  if (debug_open ())\n    return;\n\n  fwrite (data, 1, len, debug_fp);\n  debug_close ();\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "debug_output_data": {
      "start_point": [
        907,
        0
      ],
      "end_point": [
        917,
        1
      ],
      "content": "void\ndebug_output_data (const char *fmt, ...)\n{\n  va_list ap;\n  if (debug_open ())\n    return;\n  va_start (ap, fmt);\n  vfprintf (debug_fp, fmt, ap);\n  va_end (ap);\n  debug_close ();\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "printoption": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "void\nprintoption (char *fmt, int option)\n{\n  if (TELOPT_OK (option))\n    debug_output_data (\"%s %s\\r\\n\", fmt, TELOPT (option));\n  else if (TELCMD_OK (option))\n    debug_output_data (\"%s %s\\r\\n\", fmt, TELCMD (option));\n  else\n    debug_output_data (\"%s %d\\r\\n\", fmt, option);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "printsub": {
      "start_point": [
        936,
        0
      ],
      "end_point": [
        1567,
        1
      ],
      "content": "void\nprintsub (int direction, unsigned char *pointer, int length)\n{\n  int i = 0;\n\n#if defined AUTHENTICATION || defined ENCRYPTION\n  char buf[512];\n#endif\n\n  /* Silence unwanted debugging to '/tmp/telnet.debug'.\n   *\n   * XXX: Better location?\n   */\n  if ((pointer[0] == TELOPT_AUTHENTICATION && debug_level[debug_auth] < 1)\n      || (pointer[0] == TELOPT_ENCRYPT && debug_level[debug_encr] < 1))\n    return;\n\n  if (direction)\n    {\n      debug_output_data (\"td: %s suboption \",\n\t\t\t direction == '<' ? \"recv\" : \"send\");\n      if (length >= 3)\n\t{\n\t  int j;\n\n\t  i = pointer[length - 2];\n\t  j = pointer[length - 1];\n\n\t  if (i != IAC || j != SE)\n\t    {\n\t      debug_output_data (\"(terminated by \");\n\t      if (TELOPT_OK (i))\n\t\tdebug_output_data (\"%s \", TELOPT (i));\n\t      else if (TELCMD_OK (i))\n\t\tdebug_output_data (\"%s \", TELCMD (i));\n\t      else\n\t\tdebug_output_data (\"%d \", i);\n\t      if (TELOPT_OK (j))\n\t\tdebug_output_data (\"%s\", TELOPT (j));\n\t      else if (TELCMD_OK (j))\n\t\tdebug_output_data (\"%s\", TELCMD (j));\n\t      else\n\t\tdebug_output_data (\"%d\", j);\n\t      debug_output_data (\", not IAC SE!) \");\n\t    }\n\t}\n      length -= 2;\n    }\n  if (length < 1)\n    {\n      debug_output_data (\"(Empty suboption??\\?)\");\n      return;\n    }\n\n  switch (pointer[0])\n    {\n    case TELOPT_TTYPE:\n      debug_output_data (\"TERMINAL-TYPE \");\n      switch (pointer[1])\n\t{\n\tcase TELQUAL_IS:\n\t  debug_output_data (\"IS \\\"%.*s\\\"\", length - 2, (char *) pointer + 2);\n\t  break;\n\n\tcase TELQUAL_SEND:\n\t  debug_output_data (\"SEND\");\n\t  break;\n\n\tdefault:\n\t  debug_output_data (\"- unknown qualifier %d (0x%x).\",\n\t\t\t     pointer[1], pointer[1]);\n\t}\n      break;\n\n    case TELOPT_TSPEED:\n      debug_output_data (\"TERMINAL-SPEED\");\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n\n      switch (pointer[1])\n\t{\n\tcase TELQUAL_IS:\n\t  debug_output_data (\" IS %.*s\", length - 2, (char *) pointer + 2);\n\t  break;\n\n\tdefault:\n\t  if (pointer[1] == 1)\n\t    debug_output_data (\" SEND\");\n\t  else\n\t    debug_output_data (\" %d (unknown)\", pointer[1]);\n\t  for (i = 2; i < length; i++)\n\t    {\n\t      debug_output_data (\" ?%d?\", pointer[i]);\n\t    }\n\t  break;\n\t}\n      break;\n\n    case TELOPT_LFLOW:\n      debug_output_data (\"TOGGLE-FLOW-CONTROL\");\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n\n      switch (pointer[1])\n\t{\n\tcase LFLOW_OFF:\n\t  debug_output_data (\" OFF\");\n\t  break;\n\n\tcase LFLOW_ON:\n\t  debug_output_data (\" ON\");\n\t  break;\n\n\tcase LFLOW_RESTART_ANY:\n\t  debug_output_data (\" RESTART-ANY\");\n\t  break;\n\n\tcase LFLOW_RESTART_XON:\n\t  debug_output_data (\" RESTART-XON\");\n\t  break;\n\n\tdefault:\n\t  debug_output_data (\" %d (unknown)\", pointer[1]);\n\t}\n\n      for (i = 2; i < length; i++)\n\tdebug_output_data (\" ?%d?\", pointer[i]);\n      break;\n\n    case TELOPT_NAWS:\n      debug_output_data (\"NAWS\");\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n      if (length == 2)\n\t{\n\t  debug_output_data (\" ?%d?\", pointer[1]);\n\t  break;\n\t}\n\n      debug_output_data (\" %d %d (%d)\",\n\t\t\t pointer[1], pointer[2],\n\t\t\t (int) ((((unsigned int) pointer[1]) << 8) |\n\t\t\t\t((unsigned int) pointer[2])));\n      if (length == 4)\n\t{\n\t  debug_output_data (\" ?%d?\", pointer[3]);\n\t  break;\n\t}\n\n      debug_output_data (\" %d %d (%d)\",\n\t\t\t pointer[3], pointer[4],\n\t\t\t (int) ((((unsigned int) pointer[3]) << 8) |\n\t\t\t\t((unsigned int) pointer[4])));\n      for (i = 5; i < length; i++)\n\tdebug_output_data (\" ?%d?\", pointer[i]);\n      break;\n\n    case TELOPT_LINEMODE:\n      debug_output_data (\"LINEMODE \");\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n\n      switch (pointer[1])\n\t{\n\tcase WILL:\n\t  debug_output_data (\"WILL \");\n\t  goto common;\n\n\tcase WONT:\n\t  debug_output_data (\"WONT \");\n\t  goto common;\n\n\tcase DO:\n\t  debug_output_data (\"DO \");\n\t  goto common;\n\n\tcase DONT:\n\t  debug_output_data (\"DONT \");\n\n\tcommon:\n\t  if (length < 3)\n\t    {\n\t      debug_output_data (\"(no option??\\?)\");\n\t      break;\n\t    }\n\t  switch (pointer[2])\n\t    {\n\t    case LM_FORWARDMASK:\n\t      debug_output_data (\"Forward Mask\");\n\t      for (i = 3; i < length; i++)\n\t\tdebug_output_data (\" %x\", pointer[i]);\n\t      break;\n\n\t    default:\n\t      debug_output_data (\"%d (unknown)\", pointer[2]);\n\t      for (i = 3; i < length; i++)\n\t\tdebug_output_data (\" %d\", pointer[i]);\n\t      break;\n\t    }\n\t  break;\n\n\tcase LM_SLC:\n\t  debug_output_data (\"SLC\");\n\t  for (i = 2; i < length - 2; i += 3)\n\t    {\n\t      if (SLC_NAME_OK (pointer[i + SLC_FUNC]))\n\t\tdebug_output_data (\" %s\", SLC_NAME (pointer[i + SLC_FUNC]));\n\t      else\n\t\tdebug_output_data (\" %d\", pointer[i + SLC_FUNC]);\n\t      switch (pointer[i + SLC_FLAGS] & SLC_LEVELBITS)\n\t\t{\n\t\tcase SLC_NOSUPPORT:\n\t\t  debug_output_data (\" NOSUPPORT\");\n\t\t  break;\n\n\t\tcase SLC_CANTCHANGE:\n\t\t  debug_output_data (\" CANTCHANGE\");\n\t\t  break;\n\n\t\tcase SLC_VARIABLE:\n\t\t  debug_output_data (\" VARIABLE\");\n\t\t  break;\n\n\t\tcase SLC_DEFAULT:\n\t\t  debug_output_data (\" DEFAULT\");\n\t\t  break;\n\t\t}\n\n\t      debug_output_data (\"%s%s%s\",\n\t\t\t\t pointer[i +\n\t\t\t\t\t SLC_FLAGS] & SLC_ACK ? \"|ACK\" : \"\",\n\t\t\t\t pointer[i +\n\t\t\t\t\t SLC_FLAGS] & SLC_FLUSHIN ? \"|FLUSHIN\"\n\t\t\t\t : \"\",\n\t\t\t\t pointer[i +\n\t\t\t\t\t SLC_FLAGS] & SLC_FLUSHOUT ?\n\t\t\t\t \"|FLUSHOUT\" : \"\");\n\t      if (pointer[i + SLC_FLAGS] &\n\t\t  ~(SLC_ACK | SLC_FLUSHIN | SLC_FLUSHOUT | SLC_LEVELBITS))\n\t\tdebug_output_data (\"(0x%x)\", pointer[i + SLC_FLAGS]);\n\t      debug_output_data (\" %d;\", pointer[i + SLC_VALUE]);\n\n\t      if ((pointer[i + SLC_VALUE] == IAC) &&\n\t\t  (pointer[i + SLC_VALUE + 1] == IAC))\n\t\ti++;\n\t    }\n\n\t  for (; i < length; i++)\n\t    debug_output_data (\" ?%d?\", pointer[i]);\n\t  break;\n\n\tcase LM_MODE:\n\t  debug_output_data (\"MODE \");\n\t  if (length < 3)\n\t    {\n\t      debug_output_data (\"(no mode??\\?)\");\n\t      break;\n\t    }\n\t  {\n\t    char tbuf[32];\n\t    snprintf (tbuf, sizeof (tbuf), \"%s%s%s%s%s\",\n\t\t      pointer[2] & MODE_EDIT ? \"|EDIT\" : \"\",\n\t\t      pointer[2] & MODE_TRAPSIG ? \"|TRAPSIG\" : \"\",\n\t\t      pointer[2] & MODE_SOFT_TAB ? \"|SOFT_TAB\" : \"\",\n\t\t      pointer[2] & MODE_LIT_ECHO ? \"|LIT_ECHO\" : \"\",\n\t\t      pointer[2] & MODE_ACK ? \"|ACK\" : \"\");\n\t    debug_output_data (\"%s\", tbuf[1] ? &tbuf[1] : \"0\");\n\t  }\n\n\t  if (pointer[2] & ~(MODE_EDIT | MODE_TRAPSIG | MODE_ACK))\n\t    debug_output_data (\" (0x%x)\", pointer[2]);\n\n\t  for (i = 3; i < length; i++)\n\t    debug_output_data (\" ?0x%x?\", pointer[i]);\n\t  break;\n\n\tdefault:\n\t  debug_output_data (\"%d (unknown)\", pointer[1]);\n\t  for (i = 2; i < length; i++)\n\t    debug_output_data (\" %d\", pointer[i]);\n\t}\n      break;\n\n    case TELOPT_STATUS:\n      {\n\tchar *cp;\n\tint j, k;\n\n\tdebug_output_data (\"STATUS\");\n\n\tswitch (pointer[1])\n\t  {\n\t  default:\n\t    if (pointer[1] == TELQUAL_SEND)\n\t      debug_output_data (\" SEND\");\n\t    else\n\t      debug_output_data (\" %d (unknown)\", pointer[1]);\n\t    for (i = 2; i < length; i++)\n\t      debug_output_data (\" ?%d?\", pointer[i]);\n\t    break;\n\n\t  case TELQUAL_IS:\n\t    debug_output_data (\" IS\\r\\n\");\n\n\t    for (i = 2; i < length; i++)\n\t      {\n\t\tswitch (pointer[i])\n\t\t  {\n\t\t  case DO:\n\t\t    cp = \"DO\";\n\t\t    goto common2;\n\n\t\t  case DONT:\n\t\t    cp = \"DONT\";\n\t\t    goto common2;\n\n\t\t  case WILL:\n\t\t    cp = \"WILL\";\n\t\t    goto common2;\n\n\t\t  case WONT:\n\t\t    cp = \"WONT\";\n\t\t    goto common2;\n\n\t\t  common2:\n\t\t    i++;\n\t\t    if (TELOPT_OK (pointer[i]))\n\t\t      debug_output_data (\" %s %s\\r\\n\", cp,\n\t\t\t\t\t TELOPT (pointer[i]));\n\t\t    else\n\t\t      debug_output_data (\" %s %d\\r\\n\", cp, pointer[i]);\n\t\t    break;\n\n\t\t  case SB:\n\t\t    debug_output_data (\" SB \");\n\t\t    i++;\n\t\t    j = k = i;\n\t\t    while (j < length)\n\t\t      {\n\t\t\tif (pointer[j] == SE)\n\t\t\t  {\n\t\t\t    if (j + 1 == length)\n\t\t\t      break;\n\t\t\t    if (pointer[j + 1] == SE)\n\t\t\t      j++;\n\t\t\t    else\n\t\t\t      break;\n\t\t\t  }\n\t\t\tpointer[k++] = pointer[j++];\n\t\t      }\n\t\t    printsub (0, &pointer[i], k - i);\n\t\t    if (i < length)\n\t\t      {\n\t\t\tdebug_output_data (\" SE\");\n\t\t\ti = j;\n\t\t      }\n\t\t    else\n\t\t      i = j - 1;\n\n\t\t    debug_output_data (\"\\r\\n\");\n\t\t    break;\n\n\t\t  default:\n\t\t    debug_output_data (\" %d\", pointer[i]);\n\t\t    break;\n\t\t  }\n\t      }\n\t    break;\n\t  }\n\tbreak;\n      }\n\n    case TELOPT_XDISPLOC:\n      debug_output_data (\"X-DISPLAY-LOCATION \");\n      switch (pointer[1])\n\t{\n\tcase TELQUAL_IS:\n\t  debug_output_data (\"IS \\\"%.*s\\\"\", length - 2, (char *) pointer + 2);\n\t  break;\n\tcase TELQUAL_SEND:\n\t  debug_output_data (\"SEND\");\n\t  break;\n\tdefault:\n\t  debug_output_data (\"- unknown qualifier %d (0x%x).\",\n\t\t\t     pointer[1], pointer[1]);\n\t}\n      break;\n\n    case TELOPT_NEW_ENVIRON:\n      debug_output_data (\"NEW-ENVIRON \");\n      goto env_common1;\n\n    case TELOPT_OLD_ENVIRON:\n      debug_output_data (\"OLD-ENVIRON\");\n    env_common1:\n      switch (pointer[1])\n\t{\n\tcase TELQUAL_IS:\n\t  debug_output_data (\"IS \");\n\t  goto env_common;\n\n\tcase TELQUAL_SEND:\n\t  debug_output_data (\"SEND \");\n\t  goto env_common;\n\n\tcase TELQUAL_INFO:\n\t  debug_output_data (\"INFO \");\n\n\tenv_common:\n\t  {\n\t    char *quote = \"\";\n\t    for (i = 2; i < length; i++)\n\t      {\n\t\tswitch (pointer[i])\n\t\t  {\n\t\t  case NEW_ENV_VAR:\n\t\t    debug_output_data (\"%sVAR \", quote);\n\t\t    quote = \"\";\n\t\t    break;\n\n\t\t  case NEW_ENV_VALUE:\n\t\t    debug_output_data (\"%sVALUE \", quote);\n\t\t    quote = \"\";\n\t\t    break;\n\n\t\t  case ENV_ESC:\n\t\t    debug_output_data (\"%sESC \", quote);\n\t\t    quote = \"\";\n\t\t    break;\n\n\t\t  case ENV_USERVAR:\n\t\t    debug_output_data (\"%sUSERVAR \", quote);\n\t\t    quote = \"\";\n\t\t    break;\n\n\t\t  default:\n\t\t    if (isprint (pointer[i]) && pointer[i] != '\"')\n\t\t      {\n                        if (strcmp (quote, \"\") == 0)\n\t\t\t  {\n\t\t\t    debug_output_data (\"\\\"\");\n\t\t\t    quote = \"\\\" \";\n\t\t\t  }\n\t\t\tdebug_output_datalen ((char*) &pointer[i], 1);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tdebug_output_data (\"%s%03o \", quote, pointer[i]);\n\t\t\tquote = \"\";\n\t\t      }\n\t\t    break;\n\t\t  }\n\t      }\n\t    if (strcmp (quote, \"\\\" \") == 0)\n\t      debug_output_data (\"\\\"\");\n\t    break;\n\t  }\n\t}\n      break;\n\n#if defined AUTHENTICATION\n    case TELOPT_AUTHENTICATION:\n      debug_output_data (\"AUTHENTICATION\");\n\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n      switch (pointer[1])\n\t{\n\tcase TELQUAL_REPLY:\n\tcase TELQUAL_IS:\n\t  debug_output_data (\" %s \", (pointer[1] == TELQUAL_IS) ?\n\t\t\t     \"IS\" : \"REPLY\");\n\t  if (AUTHTYPE_NAME_OK (pointer[2]) && AUTHTYPE_NAME (pointer[2]))\n\t    debug_output_data (\"%s \", AUTHTYPE_NAME (pointer[2]));\n\t  else\n\t    debug_output_data (\"%d \", pointer[2]);\n\t  if (length < 3)\n\t    {\n\t      debug_output_data (\"(partial suboption??\\?)\");\n\t      break;\n\t    }\n\t  debug_output_data (\"%s|%s\",\n\t\t\t     ((pointer[3] & AUTH_WHO_MASK) ==\n\t\t\t      AUTH_WHO_CLIENT) ? \"CLIENT\" : \"SERVER\",\n\t\t\t     ((pointer[3] & AUTH_HOW_MASK) ==\n\t\t\t      AUTH_HOW_MUTUAL) ? \"MUTUAL\" : \"ONE-WAY\");\n\n\t  auth_printsub (&pointer[1], length - 1, buf, sizeof (buf));\n\t  debug_output_data (\"%s\", buf);\n\t  break;\n\n\tcase TELQUAL_SEND:\n\t  i = 2;\n\t  debug_output_data (\" SEND \");\n\t  while (i < length)\n\t    {\n\t      if (AUTHTYPE_NAME_OK (pointer[i])\n\t\t  && AUTHTYPE_NAME (pointer[i]))\n\t\tdebug_output_data (\"%s \", AUTHTYPE_NAME (pointer[i]));\n\t      else\n\t\tdebug_output_data (\"%d \", pointer[i]);\n\t      if (++i >= length)\n\t\t{\n\t\t  debug_output_data (\"(partial suboption??\\?)\");\n\t\t  break;\n\t\t}\n\t      debug_output_data (\"%s|%s \",\n\t\t\t\t ((pointer[i] & AUTH_WHO_MASK) ==\n\t\t\t\t  AUTH_WHO_CLIENT) ? \"CLIENT\" : \"SERVER\",\n\t\t\t\t ((pointer[i] & AUTH_HOW_MASK) ==\n\t\t\t\t  AUTH_HOW_MUTUAL) ? \"MUTUAL\" : \"ONE-WAY\");\n\t      ++i;\n\t    }\n\t  break;\n\n\tcase TELQUAL_NAME:\n\t  i = 2;\n\t  debug_output_data (\" NAME \\\"\");\n\t  debug_output_datalen ((char *) &pointer[i], length);\n\t  i += length;\n\t  debug_output_data (\"\\\"\");\n\t  break;\n\n\tdefault:\n\t  for (i = 2; i < length; i++)\n\t    debug_output_data (\" ?%d?\", pointer[i]);\n\t  break;\n\t}\n      break;\n#endif\n\n#ifdef\tENCRYPTION\n    case TELOPT_ENCRYPT:\n      debug_output_data (\"ENCRYPT\");\n      if (length < 2)\n\t{\n\t  debug_output_data (\" (empty suboption??\\?)\");\n\t  break;\n\t}\n      switch (pointer[1])\n\t{\n\tcase ENCRYPT_START:\n\t  debug_output_data (\" START\");\n\t  break;\n\n\tcase ENCRYPT_END:\n\t  debug_output_data (\" END\");\n\t  break;\n\n\tcase ENCRYPT_REQSTART:\n\t  debug_output_data (\" REQUEST-START\");\n\t  break;\n\n\tcase ENCRYPT_REQEND:\n\t  debug_output_data (\" REQUEST-END\");\n\t  break;\n\n\tcase ENCRYPT_IS:\n\tcase ENCRYPT_REPLY:\n\t  debug_output_data (\" %s \", (pointer[1] == ENCRYPT_IS) ?\n\t\t\t     \"IS\" : \"REPLY\");\n\t  if (length < 3)\n\t    {\n\t      debug_output_data (\" (partial suboption??\\?)\");\n\t      break;\n\t    }\n\t  if (ENCTYPE_NAME_OK (pointer[2]) && ENCTYPE_NAME (pointer[2]))\n\t    debug_output_data (\"%s \", ENCTYPE_NAME (pointer[2]));\n\t  else\n\t    debug_output_data (\" %d (unknown)\", pointer[2]);\n\n\t  encrypt_printsub (&pointer[1], length - 1, buf, sizeof (buf));\n\t  debug_output_data (\"%s\", buf);\n\t  break;\n\n\tcase ENCRYPT_SUPPORT:\n\t  i = 2;\n\t  debug_output_data (\" SUPPORT \");\n\t  while (i < length)\n\t    {\n\t      if (ENCTYPE_NAME_OK (pointer[i]) && ENCTYPE_NAME (pointer[i]))\n\t\tdebug_output_data (\"%s \", ENCTYPE_NAME (pointer[i]));\n\t      else\n\t\tdebug_output_data (\"%d \", pointer[i]);\n\t      i++;\n\t    }\n\t  break;\n\n\tcase ENCRYPT_ENC_KEYID:\n\t  debug_output_data (\" ENC_KEYID\", pointer[1]);\n\t  goto encommon;\n\n\tcase ENCRYPT_DEC_KEYID:\n\t  debug_output_data (\" DEC_KEYID\", pointer[1]);\n\t  goto encommon;\n\n\tdefault:\n\t  debug_output_data (\" %d (unknown)\", pointer[1]);\n\tencommon:\n\t  for (i = 2; i < length; i++)\n\t    debug_output_data (\" %d\", pointer[i]);\n\t  break;\n\t}\n      break;\n#endif /* ENCRYPTION */\n\n    default:\n      if (TELOPT_OK (pointer[0]))\n\tdebug_output_data (\"%s (unknown)\", TELOPT (pointer[0]));\n      else\n\tdebug_output_data (\"%d (unknown)\", pointer[0]);\n      for (i = 1; i < length; i++)\n\tdebug_output_data (\" %d\", pointer[i]);\n      break;\n    }\n  debug_output_data (\"\\r\\n\");\n}",
      "lines": 632,
      "depth": 25,
      "decorators": [
        "void"
      ]
    },
    "printdata": {
      "start_point": [
        1572,
        0
      ],
      "end_point": [
        1596,
        1
      ],
      "content": "void\nprintdata (char *tag, char *ptr, int cnt)\n{\n  int i;\n  char xbuf[30];\n\n  while (cnt)\n    {\n      /* add a line of output */\n      debug_output_data (\"%s: \", tag);\n      for (i = 0; i < 20 && cnt; i++)\n\t{\n\t  debug_output_data (\"%02x\", (unsigned char) *ptr);\n\t  xbuf[i] = isprint ((int) *ptr) ? *ptr : '.';\n\n\t  if (i % 2)\n\t    debug_output_data (\" \");\n\t  cnt--;\n\t  ptr++;\n\t}\n\n      xbuf[i] = '\\0';\n      debug_output_data (\" %s\\r\\n\", xbuf);\n    }\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "net_write": {
      "start_point": [
        1600,
        0
      ],
      "end_point": [
        1604,
        1
      ],
      "content": "int\nnet_write (unsigned char *str, int len)\n{\n  return net_output_datalen (str, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "net_encrypt": {
      "start_point": [
        1606,
        0
      ],
      "end_point": [
        1615,
        1
      ],
      "content": "void\nnet_encrypt ()\n{\n# ifdef\tENCRYPTION\n  char *s = (nclearto > nbackp) ? nclearto : nbackp;\n  if (s < nfrontp && encrypt_output)\n    (*encrypt_output) ((unsigned char *) s, nfrontp - s);\n  nclearto = nfrontp;\n# endif\t/* ENCRYPTION */\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "telnet_spin": {
      "start_point": [
        1617,
        0
      ],
      "end_point": [
        1622,
        1
      ],
      "content": "int\ntelnet_spin ()\n{\n  io_drain ();\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "_var_short_name": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1706,
        1
      ],
      "content": "char *\n_var_short_name (struct line_expander *exp)\n{\n  char *q;\n  char timebuf[64];\n  time_t t;\n\n  switch (*exp->cp++)\n    {\n    case 'a':\n#ifdef AUTHENTICATION\n      if (auth_level >= 0 && autologin == AUTH_VALID)\n\treturn xstrdup (\"ok\");\n#endif\n      return NULL;\n\n    case 'd':\n      time (&t);\n      strftime (timebuf, sizeof (timebuf),\n\t\t\"%l:%M%p on %A, %d %B %Y\", localtime (&t));\n      return xstrdup (timebuf);\n\n    case 'h':\n      return xstrdup (remote_hostname);\n\n    case 'l':\n      return xstrdup (local_hostname);\n\n    case 'L':\n      return xstrdup (line);\n\n    case 't':\n      q = strchr (line + 1, '/');\n      if (q)\n\tq++;\n      else\n\tq = line;\n      return xstrdup (q);\n\n    case 'T':\n      return terminaltype ? xstrdup (terminaltype) : NULL;\n\n    case 'u':\n      return user_name ? xstrdup (user_name) : NULL;\n\n    case 'U':\n      return getenv (\"USER\") ? xstrdup (getenv (\"USER\")) : xstrdup (\"\");\n\n    default:\n      exp->state = EXP_STATE_ERROR;\n      return NULL;\n    }\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "char",
        "*\n_var_short_name (struct line_expander *exp)",
        "*"
      ]
    },
    "_var_long_name": {
      "start_point": [
        1711,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "char *\n_var_long_name (struct line_expander *exp, char *start, int length)\n{\n  (void) start;\t\t/* Silence warnings until implemented.  */\n  (void) length;\n  exp->state = EXP_STATE_ERROR;\n  return NULL;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\n_var_long_name (struct line_expander *exp, char *start, int length)",
        "*"
      ]
    },
    "_expand_var": {
      "start_point": [
        1722,
        0
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "char *\n_expand_var (struct line_expander *exp)\n{\n  char *p;\n  switch (*exp->cp)\n    {\n    case '{':\n      /* Collect variable name */\n      for (p = ++exp->cp; *exp->cp && *exp->cp != '}'; exp->cp++)\n\t;\n      if (*exp->cp == 0)\n\t{\n\t  exp->cp = p;\n\t  exp->state = EXP_STATE_ERROR;\n\t  break;\n\t}\n      p = _var_long_name (exp, p, exp->cp - p);\n      exp->cp++;\n      break;\n\n    default:\n      p = _var_short_name (exp);\n      break;\n    }\n  return p;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "char",
        "*\n_expand_var (struct line_expander *exp)",
        "*"
      ]
    },
    "_expand_cond": {
      "start_point": [
        1754,
        0
      ],
      "end_point": [
        1783,
        1
      ],
      "content": "void\n_expand_cond (struct line_expander *exp)\n{\n  char *p;\n\n  if (*++exp->cp == '?')\n    {\n      /* condition */\n      exp->cp++;\n      p = _expand_var (exp);\n      if (p)\n\t{\n\t  _expand_block (exp);\n\t  _skip_block (exp);\n\t}\n      else\n\t{\n\t  _skip_block (exp);\n\t  _expand_block (exp);\n\t}\n      free (p);\n    }\n  else\n    {\n      p = _expand_var (exp);\n      if (p)\n\tobstack_grow (&exp->stk, p, strlen (p));\n      free (p);\n    }\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "_skip_block": {
      "start_point": [
        1787,
        0
      ],
      "end_point": [
        1810,
        1
      ],
      "content": "void\n_skip_block (struct line_expander *exp)\n{\n  int level = exp->level;\n  if (*exp->cp != '{')\n    return;\n  for (; *exp->cp; exp->cp++)\n    {\n      switch (*exp->cp)\n\t{\n\tcase '{':\n\t  exp->level++;\n\t  break;\n\n\tcase '}':\n\t  exp->level--;\n\t  if (exp->level == level)\n\t    {\n\t      exp->cp++;\n\t      return;\n\t    }\n\t}\n    }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_expand_block": {
      "start_point": [
        1814,
        0
      ],
      "end_point": [
        1864,
        1
      ],
      "content": "void\n_expand_block (struct line_expander *exp)\n{\n  int level = exp->level;\n  if (*exp->cp == '{')\n    {\n      exp->level++;\n      exp->cp++;\t\t/*FIXME? */\n    }\n  while (exp->state == EXP_STATE_CONTINUE)\n    {\n      for (; *exp->cp && *exp->cp != '%'; exp->cp++)\n\t{\n\t  switch (*exp->cp)\n\t    {\n\t    case '{':\n\t      exp->level++;\n\t      break;\n\n\t    case '}':\n\t      exp->level--;\n\t      if (exp->level == level)\n\t\t{\n\t\t  exp->cp++;\n\t\t  return;\n\t\t}\n\t      break;\n\n\t    case '\\\\':\n\t      exp->cp++;\n\t      break;\n\t    }\n\t  obstack_1grow (&exp->stk, *exp->cp);\n\t}\n\n      if (*exp->cp == 0)\n\t{\n\t  obstack_1grow (&exp->stk, 0);\n\t  exp->state = EXP_STATE_SUCCESS;\n\t  break;\n\t}\n      else if (*exp->cp == '%' && exp->cp[1] == '%')\n\t{\n\t  obstack_1grow (&exp->stk, *exp->cp);\n\t  exp->cp += 2;\n\t  continue;\n\t}\n\n      _expand_cond (exp);\n    }\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "expand_line": {
      "start_point": [
        1867,
        0
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "char *\nexpand_line (const char *line)\n{\n  char *p = NULL;\n  struct line_expander exp;\n\n  exp.state = EXP_STATE_CONTINUE;\n  exp.level = 0;\n  exp.source = (char *) line;\n  exp.cp = (char *) line;\n  obstack_init (&exp.stk);\n  _expand_block (&exp);\n  if (exp.state == EXP_STATE_SUCCESS)\n    p = xstrdup (obstack_finish (&exp.stk));\n  else\n    {\n      syslog (LOG_ERR, \"can't expand line: %s\", line);\n      syslog (LOG_ERR, \"stopped near %s\", exp.cp ? exp.cp : \"(END)\");\n    }\n  obstack_free (&exp.stk, NULL);\n  return p;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "char",
        "*\nexpand_line (const char *line)",
        "*"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/addrpeek.c": {
    "write_address": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\nwrite_address (int fd)\n{\n  int type;\n  size_t len;\n  socklen_t sslen;\n  char addr[INET6_ADDRSTRLEN], answer[128];\n  struct sockaddr_storage ss;\n\n  sslen = sizeof (type);\n  getsockopt (fd, SOL_SOCKET, SO_TYPE, &type, &sslen);\n\n  if (type == SOCK_STREAM)\n    {\n      sslen = sizeof (ss);\n      getpeername (fd, (struct sockaddr *) &ss, &sslen);\n    }\n  else if (type == SOCK_DGRAM)\n    {\n      sslen = sizeof (ss);\n      recvfrom (fd, answer, sizeof (answer), 0,\n                  (struct sockaddr *) &ss, &sslen);\n      shutdown (fd, SHUT_RD);\n    }\n  else\n      return;\n\n  getnameinfo ((struct sockaddr *) &ss, sslen, addr, sizeof (addr),\n                NULL, 0, NI_NUMERICHOST);\n\n  len = snprintf (answer, sizeof (answer),\n                  \"Your address is %s.\" SEPARATOR, addr);\n\n  sendto (fd, answer, len, 0, (struct sockaddr *) &ss, sslen);\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_environment": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nwrite_environment (int fd, char *envp[])\n{\n  for ( ; *envp; ++envp)\n    {\n      write (fd, *envp, strlen (*envp));\n      write (fd, SEPARATOR, strlen (SEPARATOR));\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int j;\n  set_program_name (argv[0]);\n  for (j = 1; j < argc; ++j)\n    {\n      if (strncmp (argv[j], \"addr\", strlen (\"addr\")) == 0)\n        {\n          write_address (STDOUT_FILENO);\n          continue;\n        }\n\n      if (strncmp (argv[j], \"env\", strlen (\"env\")) == 0)\n        {\n          write_environment (STDOUT_FILENO, environ);\n          continue;\n        }\n    }\n\n  close (STDIN_FILENO);\n  close (STDOUT_FILENO);\n  close (STDERR_FILENO);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/identify.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (void)\n{\n  int a, ux;\n  struct utsname uts;\n  struct sockaddr_un su;\n\n  if (uname (&uts) < 0)\n    {\n      fprintf (stderr, \"Not able to identify running system.\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  /* Identify the hardware.  */\n  printf (\"Running system: %s, %s\\n\",\n\t  uts.sysname, uts.machine);\n  printf (\" Variant: %s\\n\", uts.release);\n  printf (\" Variant: %s\\n\", uts.version);\n  puts (\"\");\n\n  /*\n   * Report on macros that determine alternate code.\n   * These depend on toolchains and hardware.\n   */\n  ux = 0;\n#ifdef unix\n  ux = 1;\n#endif\n  tell_macro (\"unix\", ux);\n\n  ux = 0;\n#ifdef __unix\n  ux = 1;\n#endif\n  tell_macro (\"__unix\", ux);\n\n  ux = 0;\n#ifdef __unix__\n  ux = 1;\n#endif\n  tell_macro (\"__unix__\", ux);\n\n  ux = 0;\n#ifdef __sun\n  ux = 1;\n#endif\n  tell_macro (\"__sun\", ux);\n\n  ux = 0;\n#ifdef __sun__\n  ux = 1;\n#endif\n  tell_macro (\"__sun__\", ux);\n\n  a = 0;\n#ifdef TN3270\n  a = 1;\n#endif\n  tell_macro (\"TN3270\", a);\n\n  /*\n   * Implementation specific charateristica.\n   */\n  puts (\"\");\n\n  a = 0;\n#ifdef BSD\n  a = 1;\n#endif\n  tell_macro (\"BSD\", a);\n\n  printf (\"Size of 'struct sockaddr_un.sun_path': %zu\\n\",\n\t  sizeof (su.sun_path));\n  return 0;\n}",
      "lines": 75,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/localhost.c": {
    "main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED_PARAMETER, char **argv)\n{\n  char *p = localhost ();\n  set_program_name (argv[0]);\n  if (!p)\n    return 1;\n\n  printf (\"localhost: %s\\n\", p);\n  free (p);\n\n  return 0;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/ls.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  return ls_main(argc, argv);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/readutmp.c": {
    "main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n#ifndef HAVE_GETUTXUSER\n  STRUCT_UTMP *utmpp, *uptr;\n  size_t count;\n#endif\n  struct passwd *pw;\n  char *name;\n  int found = 0;\n\n  set_program_name (argv[0]);\n\n  if (argc > 1)\n    pw = getpwnam (argv[1]);\n  else\n    pw = getpwuid (getuid ());\n\n  if (pw)\n    name = xstrdup (pw->pw_name);\n  else\n    {\n      fprintf (stderr, \"Unknown user '%s'.\\n\",\n\t       (argc > 1) ? argv[1] : \"my own UID\");\n      return EXIT_FAILURE;\n    }\n\n#ifdef HAVE_GETUTXUSER\n  setutxent ();\n  found = (getutxuser (name) != 0);\n  endutxent ();\n#else /* !HAVE_GETUTXUSER */\n  if (read_utmp (UTMP_FILE, &count, &utmpp, READ_UTMP_USER_PROCESS))\n    {\n      perror (\"read_utmp\");\n      return EXIT_FAILURE;\n    }\n\n  for (uptr = utmpp; uptr < utmpp + count; uptr++)\n    if (!strncmp (name, UT_USER (uptr), sizeof (UT_USER (uptr))))\n      {\n\tfound = 1;\n\tbreak;\n      }\n\n  free (utmpp);\n#endif /* HAVE_GETUTXUSER */\n\n  if (found)\n    return EXIT_SUCCESS;\n\n  fprintf (stderr, \"User '%s' is not logged in.\\n\", name);\n  return EXIT_FAILURE;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/tcpget.c": {
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int fd, opt, rc;\n  int timeout = 5;\t/* Defaulting to five seconds of waiting time.  */\n  char buffer[256];\n  struct addrinfo hints, *ai, *res;\n\n  set_program_name (argv[0]);\n\n#ifdef HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n\n  while ((opt = getopt (argc, argv, \"t:\")) != -1)\n    {\n      int t;\n\n      switch (opt)\n\t{\n\tcase 't':\n\t  t = atoi (optarg);\n\t  if (t > 0 && t <= 3600 /* on hour */)\n\t    timeout = t;\n\t  break;\n\n\tdefault:\n\t  fprintf (stderr, \"Usage: %s [-t secs] host port\\n\", argv[0]);\n\t  exit (EXIT_FAILURE);\n\t}\n    }\n\n  if (argc < optind + 2)\n    return (EXIT_FAILURE);\n\n  memset (&hints, 0, sizeof (hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n\n  rc = getaddrinfo (argv[optind], argv[optind + 1], &hints, &res);\n\n  if (rc)\n    {\n      fprintf (stderr, \"%s: %s\\n\", argv[0], gai_strerror (rc));\n      return (EXIT_FAILURE);\n    }\n\n  for (ai = res; ai; ai = ai->ai_next)\n    {\n      fd = socket (ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      if (connect (fd, ai->ai_addr, ai->ai_addrlen) >= 0)\n\tbreak;\n\n      close (fd);\n    }\n\n  freeaddrinfo (res);\n\n  if (ai && (fd >= 0))\n    {\n      ssize_t n;\n\n      alarm (timeout);\n\n      while ((n = recv (fd, buffer, sizeof (buffer), 0)))\n\twrite (STDOUT_FILENO, buffer, n);\n\n      close (fd);\n    }\n\n  close (STDIN_FILENO);\n  close (STDOUT_FILENO);\n  close (STDERR_FILENO);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/tests/waitdaemon.c": {
    "doexit": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ndoexit (int signo _GL_UNUSED_PARAMETER)\n{\n  _exit (EXIT_SUCCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nmain (int argc _GL_UNUSED_PARAMETER, char *argv[])\n{\n  pid_t ppid;\n\n  set_program_name (argv[0]);\n\n  signal (SIGTERM, doexit);\t/* Parent exits nicely at SIGTERM.  */\n\n  ppid = waitdaemon (0, 0, 5);\t/* Five seconds of delay.  */\n\n  /* Child should return here before parent.  */\n  if (ppid > 0)\n    kill (ppid, SIGTERM);\t/* Bless the parent process.  */\n\n  /* Only grand child reaches this statement.  */\n  return EXIT_FAILURE;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/whois/as_del.h": {},
  "inetutils/inetutils-1.9.4/whois/data.h": {},
  "inetutils/inetutils-1.9.4/whois/ip_del.h": {},
  "inetutils/inetutils-1.9.4/whois/tld_serv.h": {},
  "inetutils/inetutils-1.9.4/whois/whois.c": {
    "ripe_argp_parser": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static error_t\nripe_argp_parser (int key, char *arg,\n\t\t  struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  if (key > 0 && (unsigned) key < 128)\n    {\n      if (key == 't' || key == 'v' || key == 'q')\n\tnopar = 1;\n\n      obstack_1grow (&query_stk, '-');\n      obstack_1grow (&query_stk, key);\n      if (arg)\n\t{\n\t  obstack_1grow (&query_stk, ' ');\n\t  obstack_grow (&query_stk, arg, strlen (arg));\n\t}\n      return 0;\n    }\n  return ARGP_ERR_UNKNOWN;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "gwhois_argp_parser": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static error_t\ngwhois_argp_parser (int key, char *arg,\n\t\t    struct argp_state *state _GL_UNUSED_PARAMETER)\n{\n  char *p, *q;\n\n  switch (key)\n    {\n    case 'h':\n      server = q = xmalloc (strlen (arg) + 1);\n      for (p = arg; *p != '\\0' && *p != ':'; *q++ = tolower (*p++));\n      if (*p == ':')\n\tport = p + 1;\n      *q = '\\0';\n      break;\n\n    case 'H':\n      hide_discl = 0;\t/* enable disclaimers hiding */\n      break;\n\n    case 'p':\n      port = arg;\n      break;\n\n    case 'V':\n      verb = 1;\n      break;\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n  return 0;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "error_t"
      ]
    },
    "main": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int index;\n  char *fstring;\n  char *qstring;\n  char *p;\n\n  set_program_name (argv[0]);\n\n#ifdef ENABLE_NLS\n  setlocale (LC_MESSAGES, \"\");\n  bindtextdomain (NLS_CAT_NAME, LOCALEDIR);\n  textdomain (NLS_CAT_NAME);\n#endif\n\n  obstack_init (&query_stk);\n  iu_argp_init (\"whois\", program_authors);\n  argp_parse (&gwhois_argp, argc, argv, ARGP_IN_ORDER, &index, NULL);\n  obstack_1grow (&query_stk, 0);\n  fstring = obstack_finish (&query_stk);\n  argc -= index;\n  argv += index;\n\n  if (argc == 0 && !nopar)\t/* there is no parameter */\n    error (EXIT_FAILURE, 0, \"not enough arguments\");\n\n  /* parse other parameters, if any */\n  if (!nopar)\n    {\n      while (argc--)\n\t{\n\t  const char *arg = *argv++;\n\t  obstack_grow (&query_stk, arg, strlen (arg));\n\t  if (argc)\n\t    obstack_1grow (&query_stk, ' ');\n\t}\n    }\n  obstack_1grow (&query_stk, 0);\n  qstring = obstack_finish (&query_stk);\n\n  if (!server && domfind (qstring, gtlds))\n    {\n      if (verb)\n\tputs (_(\"Connecting to whois.internic.net.\"));\n      sockfd = openconn (\"whois.internic.net\", NULL);\n      server = query_crsnic (sockfd, qstring);\n      closeconn (sockfd);\n      if (!server)\n\texit (EXIT_SUCCESS);\n      printf (_(\"\\nFound InterNIC referral to %s.\\n\\n\"), server);\n    }\n\n  if (!server)\n    {\n      server = whichwhois (qstring);\n      switch (server[0])\n\t{\n\tcase 0:\n\t  if (!(server = getenv (\"WHOIS_SERVER\")))\n\t    server = DEFAULTSERVER;\n\t  if (verb)\n\t    printf (_(\"Using default server %s.\\n\"), server);\n\t  break;\n\tcase 1:\n\t  puts (_(\"This TLD has no whois server, but you can access the \"\n\t\t  \"whois database at\"));\n\tcase 2:\n\t  puts (server + 1);\n\t  exit (EXIT_SUCCESS);\n\tcase 3:\n\t  puts (_(\"This TLD has no whois server.\"));\n\t  exit (EXIT_SUCCESS);\n\tdefault:\n\t  if (verb)\n\t    printf (_(\"Using server %s.\\n\"), server);\n\t}\n    }\n\n  if (getenv (\"WHOIS_HIDE\"))\n    hide_discl = 0;\n\n  p = queryformat (server, fstring, qstring);\n  if (verb)\n    printf (_(\"Query string: \\\"%s\\\"\\n\\n\"), p);\n  strcat (p, \"\\r\\n\");\n\n  signal (SIGTERM, sighandler);\n  signal (SIGINT, sighandler);\n\n  sockfd = openconn (server, port);\n  do_query (sockfd, p);\n  closeconn (sockfd);\n\n  exit (EXIT_SUCCESS);\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "whichwhois": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "const char *\nwhichwhois (const char *s)\n{\n  unsigned long ip;\n  unsigned int i;\n\n  /* -v or -t has been used */\n  if (*s == '\\0')\n    return \"whois.ripe.net\";\n\n  /* IPv6 address */\n  if (strchr (s, ':'))\n    {\n      if (strncasecmp (s, \"2001:2\", 6) == 0)\t/* XXX ugly hack! */\n\treturn \"whois.apnic.net\";\n      if (strncasecmp (s, \"2001:4\", 6) == 0)\n\treturn \"whois.arin.net\";\n      if (strncasecmp (s, \"2001:6\", 6) == 0)\n\treturn \"whois.ripe.net\";\n      /* if (strncasecmp(s, \"3ffe\", 4) == 0) */\n      return \"whois.6bone.net\";\n    }\n\n  /* email address */\n  if (strchr (s, '@'))\n    return \"\";\n\n  /* no dot and no hyphen means it's a NSI NIC handle or ASN (?) */\n  if (!strpbrk (s, \".-\"))\n    {\n      const char *p;\n\n      for (p = s; *p != '\\0'; p++);\t/* go to the end of s */\n      if (strncasecmp (s, \"as\", 2) == 0 &&\t/* it's an AS */\n\t  ((s[2] >= '0' && s[2] <= '9') || s[2] == ' '))\n\treturn whereas (atoi (s + 2), as_assign);\n      else if (strncasecmp (p - 2, \"jp\", 2) == 0)\t/* JP NIC handle */\n\treturn \"whois.nic.ad.jp\";\n      if (*p == '!')\t\t/* NSI NIC handle */\n\treturn \"whois.networksolutions.com\";\n      else\t\t\t/* it's a NSI NIC handle or something we don't know about */\n\treturn \"\";\n    }\n\n  /* smells like an IP? */\n  if ((ip = myinet_aton (s)))\n    {\n      for (i = 0; ip_assign[i].serv; i++)\n\tif ((ip & ip_assign[i].mask) == ip_assign[i].net)\n\t  return ip_assign[i].serv;\n      if (verb)\n\tputs (_(\"I don't know where this IP has been delegated.\\n\"\n\t\t\"I'll try ARIN and hope for the best...\"));\n      return \"whois.arin.net\";\n    }\n\n  /* check TLD list */\n  for (i = 0; tld_serv[i]; i += 2)\n    if (domcmp (s, tld_serv[i]))\n      return tld_serv[i + 1];\n\n  /* no dot but hyphen */\n  if (!strchr (s, '.'))\n    {\n      /* search for strings at the start of the word */\n      for (i = 0; nic_handles[i]; i += 2)\n\tif (strncasecmp (s, nic_handles[i], strlen (nic_handles[i])) == 0)\n\t  return nic_handles[i + 1];\n      if (verb)\n\tputs (_(\"I guess it's a netblock name but I don't know where to\"\n\t\t\" look it up.\"));\n      return \"whois.arin.net\";\n    }\n\n  /* has dot and hypen and it's not in tld_serv[], WTF is it? */\n  if (verb)\n    puts (_(\"I guess it's a domain but I don't know where to look it\"\n\t    \" up.\"));\n  return \"\";\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwhichwhois (const char *s)",
        "*"
      ]
    },
    "whereas": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "const char *\nwhereas (int asn, struct as_del aslist[])\n{\n  int i;\n\n  if (asn > 16383)\n    puts (_(\"Unknown AS number. Please upgrade this program.\"));\n  for (i = 0; aslist[i].serv; i++)\n    if (asn >= aslist[i].first && asn <= aslist[i].last)\n      return aslist[i].serv;\n  return \"whois.arin.net\";\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwhereas (int asn, struct as_del aslist[])",
        "*"
      ]
    },
    "is_ripe_server": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "int\nis_ripe_server (const char * const *srvtab, const char *name)\n{\n  struct in_addr addr;\n  int isip = 0;\n\n  isip = inet_aton (name, &addr);\n\n  for (; *srvtab; ++srvtab)\n    {\n      const char *server = *srvtab;\n      struct hostent *hp;\n\n      if (strcmp (server, name) == 0)\n\treturn 1;\n      if (isip && (hp = gethostbyname (server)) != NULL)\n\t{\n\t  char **pa;\n\t  for (pa = hp->h_addr_list; *pa; pa++)\n\t    if (*(unsigned long*)*pa == addr.s_addr)\n\t      return 1;\n\t}\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "queryformat": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "char *\nqueryformat (const char *server, const char *flags, const char *query)\n{\n  char *buf;\n  int isripe = 0;\n\n  /* +10 for CORE; +2 for \\r\\n; +1 for NULL */\n  buf = xmalloc (strlen (flags) + strlen (query) + 10 + 2 + 1);\n  *buf = '\\0';\n\n  isripe = is_ripe_server (ripe_servers, server)\n            || is_ripe_server (ripe_servers_old, server);\n  if (isripe)\n    strcat (buf, \"-V\" IDSTRING \" \");\n\n  if (*flags != '\\0')\n    {\n      if (!isripe && strcmp (server, \"whois.corenic.net\") != 0)\n\tputs (_(\"Warning: RIPE flags ignored for a traditional server.\"));\n      else\n\tstrcat (buf, flags);\n    }\n  if (!isripe &&\n      (strcmp (server, \"whois.arin.net\") == 0 ||\n       strcmp (server, \"whois.nic.mil\") == 0) &&\n      strncasecmp (query, \"AS\", 2) == 0 && query[2] >= '0' && query[2] <= '9')\n    sprintf (buf, \"AS %s\", query + 2);\t/* fix query for ARIN */\n  else if (!isripe && strcmp (server, \"whois.corenic.net\") == 0)\n    sprintf (buf, \"--machine %s\", query);\t/* machine readable output */\n  else if (!isripe && strcmp (server, \"whois.ncst.ernet.in\") == 0 &&\n\t   !strchr (query, ' '))\n    sprintf (buf, \"domain %s\", query);\t/* ask for a domain */\n  else if (!isripe && strcmp (server, \"whois.nic.ad.jp\") == 0)\n    {\n      char *lang = getenv (\"LANG\");\t/* not a perfect check, but... */\n      if (!lang || (strncmp (lang, \"ja\", 2) != 0))\n\tsprintf (buf, \"%s/e\", query);\t/* ask for english text */\n      else\n\tstrcat (buf, query);\n    }\n  else\n    strcat (buf, query);\n  return buf;\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "char",
        "*\nqueryformat (const char *server, const char *flags, const char *query)",
        "*"
      ]
    },
    "do_query": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "void\ndo_query (const int sock, const char *query)\n{\n  char buf[200], *p;\n  FILE *fi;\n  int i = 0, hide = hide_discl;\n\n  fi = fdopen (sock, \"r\");\n  if (write (sock, query, strlen (query)) < 0)\n    err_sys (\"write\");\n\n  while (fgets (buf, 200, fi))\n    {\t\t\t\t/* XXX errors? */\n      if (hide == 1)\n\t{\n\t  if (strncmp (buf, hide_strings[i + 1], strlen (hide_strings[i + 1]))\n\t      == 0)\n\t    hide = 2;\t\t/* stop hiding */\n\t  continue;\t\t/* hide this line */\n\t}\n      if (hide == 0)\n\t{\n\t  for (i = 0; hide_strings[i] != NULL; i += 2)\n\t    {\n\t      if (strncmp (buf, hide_strings[i], strlen (hide_strings[i])) ==\n\t\t  0)\n\t\t{\n\t\t  hide = 1;\t/* start hiding */\n\t\t  break;\n\t\t}\n\t    }\n\t  if (hide == 1)\n\t    continue;\t\t/* hide the first line */\n\t}\n#ifdef EXT_6BONE\n      /* % referto: whois -h whois.arin.net -p 43 as 1 */\n      if (strncmp (buf, \"% referto:\", 10) == 0)\n\t{\n\t  char nh[256], np[16], nq[1024];\n\n\t  if (sscanf (buf, REFERTO_FORMAT, nh, np, nq) == 3)\n\t    {\n\t      int fd;\n\n\t      if (verb)\n\t\tprintf (_(\"Detected referral to %s on %s.\\n\"), nq, nh);\n\t      strcat (nq, \"\\r\\n\");\n\t      fd = openconn (nh, np);\n\t      do_query (fd, nq);\n\t      closeconn (fd);\n\t      continue;\n\t    }\n\t}\n#endif\n      for (p = buf; *p && *p != '\\r' && *p != '\\n'; p++);\n      *p = '\\0';\n      fprintf (stdout, \"%s\\n\", buf);\n    }\n  if (ferror (fi))\n    err_sys (\"fgets\");\n\n  if (hide == 1)\n    err_quit (_(\"Catastrophic error: disclaimer text has been changed.\\n\"\n\t\t\"Please upgrade this program.\\n\"));\n}",
      "lines": 65,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "query_crsnic": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        565,
        1
      ],
      "content": "const char *\nquery_crsnic (const int sock, const char *query)\n{\n  char *temp, buf[100], *ret = NULL;\n  FILE *fi;\n\n  temp = xmalloc (strlen (query) + 1 + 2 + 1);\n  *temp = '=';\n  strcpy (temp + 1, query);\n  strcat (temp, \"\\r\\n\");\n\n  fi = fdopen (sock, \"r\");\n  if (write (sock, temp, strlen (temp)) < 0)\n    err_sys (\"write\");\n\n  while (fgets (buf, 100, fi))\n    {\n      /* If there are multiple matches only the server of the first record\n         is queried */\n      if (strncmp (buf, \"   Whois Server:\", 16) == 0 && !ret)\n\t{\n\t  char *p, *q;\n\n\t  for (p = buf; *p != ':'; p++);\t/* skip until colon */\n\t  for (p++; *p == ' '; p++);\t/* skip colon and spaces */\n\t  ret = xmalloc (strlen (p) + 1);\n\t  for (q = ret; *p != '\\n' && *p != '\\r'; *q++ = *p++);\t/*copy data */\n\t  *q = '\\0';\n\t}\n      fputs (buf, stdout);\n    }\n  if (ferror (fi))\n    err_sys (\"fgets\");\n\n  free (temp);\n  return ret;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nquery_crsnic (const int sock, const char *query)",
        "*"
      ]
    },
    "openconn": {
      "start_point": [
        567,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "int\nopenconn (const char *server, const char *port)\n{\n  int fd;\n  int i;\n  struct addrinfo hints, *res, *ressave;\n\n  memset (&hints, 0, sizeof (struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n\n  if ((i = getaddrinfo (server, port ? port : \"whois\", &hints, &res)) != 0)\n    err_quit (\"getaddrinfo: %s\", gai_strerror (i));\n\n  for (ressave = res; res; res = res->ai_next)\n    {\n      if ((fd =\n\t   socket (res->ai_family, res->ai_socktype, res->ai_protocol)) < 0)\n\tcontinue;\t\t/* ignore */\n      if (connect (fd, res->ai_addr, res->ai_addrlen) == 0)\n\tbreak;\t\t\t/* success */\n      close (fd);\n    }\n\n  if (!res)\n    err_sys (\"connect\");\n  freeaddrinfo (ressave);\n  return (fd);\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "closeconn": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        601,
        1
      ],
      "content": "void\ncloseconn (const int fd)\n{\n  close (fd);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sighandler": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "void\nsighandler (int signum)\n{\n  closeconn (sockfd);\n  err_quit (_(\"Interrupted by signal %d...\"), signum);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "domcmp": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        628,
        1
      ],
      "content": "int\ndomcmp (const char *dom, const char *tld)\n{\n  const char *p, *q;\n\n  for (p = dom; *p != '\\0'; p++);\n  p--;\t\t\t\t/* move to the last char */\n  for (q = tld; *q != '\\0'; q++);\n  q--;\n  while (p >= dom && q >= tld && tolower (*p) == *q)\n    {\t\t\t\t/* compare backwards */\n      if (q == tld)\t\t/* start of the second word? */\n\treturn 1;\n      p--;\n      q--;\n    }\n  return 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "domfind": {
      "start_point": [
        631,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "int\ndomfind (const char *dom, const char *tldlist[])\n{\n  int i;\n\n  for (i = 0; tldlist[i]; i++)\n    if (domcmp (dom, tldlist[i]))\n      return 1;\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "myinet_aton": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "unsigned long\nmyinet_aton (const char *s)\n{\n  int a, b, c, d;\n\n  if (!s)\n    return 0;\n  if (sscanf (s, \"%d.%d.%d.%d\", &a, &b, &c, &d) != 4)\n    return 0;\n  return (a << 24) + (b << 16) + (c << 8) + d;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "err_sys": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "void\nerr_sys (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  fprintf (stderr, \": %s\\n\", strerror (errno));\n  va_end (ap);\n  exit (EXIT_FAILURE);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "err_quit": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "void\nerr_quit (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  fputs (\"\\n\", stderr);\n  va_end (ap);\n  exit (EXIT_FAILURE);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "inetutils/inetutils-1.9.4/whois/whois.h": {}
}