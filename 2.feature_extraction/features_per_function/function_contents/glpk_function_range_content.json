{
  "glpk/glpk-4.65/examples/glpsol.c": {
    "str2int": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int str2int(const char *s, int *x)\n{     /* convert string to integer */\n      long t;\n      char *endptr;\n      t = strtol(s, &endptr, 10);\n      if (*endptr != '\\0')\n         return 2;\n      if (!(INT_MIN <= t && t <= INT_MAX))\n         return 1;\n      *x = t;\n#if 0\n      xprintf(\"str2int: x = %d\\n\", *x);\n#endif\n      return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "str2num": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static int str2num(const char *s, double *x)\n{     /* convert string to floating point */\n      double t;\n      char *endptr;\n      t = strtod(s, &endptr);\n      if (*endptr != '\\0')\n         return 2;\n      if (!(-DBL_MAX <= t && t <= +DBL_MAX))\n         return 1;\n      *x = t;\n#if 0\n      xprintf(\"str2num: x = %g\\n\", *x);\n#endif\n      return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_help": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        430,
        1
      ],
      "content": "static void print_help(const char *my_name)\n{     /* print help information */\n      xprintf(\"Usage: %s [options...] filename\\n\", my_name);\n      xprintf(\"\\n\");\n      xprintf(\"General options:\\n\");\n      xprintf(\"   --mps             read LP/MIP problem in fixed MPS fo\"\n         \"rmat\\n\");\n      xprintf(\"   --freemps         read LP/MIP problem in free MPS for\"\n         \"mat (default)\\n\");\n      xprintf(\"   --lp              read LP/MIP problem in CPLEX LP for\"\n         \"mat\\n\");\n      xprintf(\"   --glp             read LP/MIP problem in GLPK format \"\n         \"\\n\");\n      xprintf(\"   --math            read LP/MIP model written in GNU Ma\"\n         \"thProg modeling\\n\");\n      xprintf(\"                     language\\n\");\n      xprintf(\"   -m filename, --model filename\\n\");\n      xprintf(\"                     read model section and optional dat\"\n         \"a section from\\n\");\n      xprintf(\"                     filename (same as --math)\\n\");\n      xprintf(\"   -d filename, --data filename\\n\");\n      xprintf(\"                     read data section from filename (fo\"\n         \"r --math only);\\n\");\n      xprintf(\"                     if model file also has data section\"\n         \", it is ignored\\n\");\n      xprintf(\"   -y filename, --display filename\\n\");\n      xprintf(\"                     send display output to filename (fo\"\n         \"r --math only);\\n\");\n      xprintf(\"                     by default the output is sent to te\"\n         \"rminal\\n\");\n      xprintf(\"   --seed value      initialize pseudo-random number gen\"\n         \"erator used in\\n\");\n      xprintf(\"                     MathProg model with specified seed \"\n         \"(any integer);\\n\");\n      xprintf(\"                     if seed value is ?, some random see\"\n         \"d will be used\\n\");\n      xprintf(\"   --mincost         read min-cost flow problem in DIMAC\"\n         \"S format\\n\");\n      xprintf(\"   --maxflow         read maximum flow problem in DIMACS\"\n         \" format\\n\");\n#if 1 /* 06/VIII-2011 */\n      xprintf(\"   --cnf             read CNF-SAT problem in DIMACS form\"\n         \"at\\n\");\n#endif\n      xprintf(\"   --simplex         use simplex method (default)\\n\");\n      xprintf(\"   --interior        use interior point method (LP only)\"\n         \"\\n\");\n      xprintf(\"   -r filename, --read filename\\n\");\n      xprintf(\"                     read solution from filename rather \"\n         \"to find it with\\n\");\n      xprintf(\"                     the solver\\n\");\n      xprintf(\"   --min             minimization\\n\");\n      xprintf(\"   --max             maximization\\n\");\n      xprintf(\"   --scale           scale problem (default)\\n\");\n      xprintf(\"   --noscale         do not scale problem\\n\");\n      xprintf(\"   -o filename, --output filename\\n\");\n      xprintf(\"                     write solution to filename in print\"\n         \"able format\\n\");\n      xprintf(\"   -w filename, --write filename\\n\");\n      xprintf(\"                     write solution to filename in plain\"\n         \" text format\\n\");\n      xprintf(\"   --ranges filename\\n\");\n      xprintf(\"                     write sensitivity analysis report t\"\n         \"o filename in\\n\");\n      xprintf(\"                     printable format (simplex only)\\n\");\n      xprintf(\"   --tmlim nnn       limit solution time to nnn seconds \"\n         \"\\n\");\n      xprintf(\"   --memlim nnn      limit available memory to nnn megab\"\n         \"ytes\\n\");\n      xprintf(\"   --check           do not solve problem, check input d\"\n         \"ata only\\n\");\n      xprintf(\"   --name probname   change problem name to probname\\n\");\n#if 1 /* 18/I-2018 */\n      xprintf(\"   --hide            remove all symbolic names from prob\"\n         \"lem object\\n\");\n#endif\n      xprintf(\"   --wmps filename   write problem to filename in fixed \"\n         \"MPS format\\n\");\n      xprintf(\"   --wfreemps filename\\n\");\n      xprintf(\"                     write problem to filename in free M\"\n         \"PS format\\n\");\n      xprintf(\"   --wlp filename    write problem to filename in CPLEX \"\n         \"LP format\\n\");\n      xprintf(\"   --wglp filename   write problem to filename in GLPK f\"\n         \"ormat\\n\");\n#if 0\n      xprintf(\"   --wpb filename    write problem to filename in OPB fo\"\n         \"rmat\\n\");\n      xprintf(\"   --wnpb filename   write problem to filename in normal\"\n         \"ized OPB format\\n\");\n#endif\n#if 1 /* 06/VIII-2011 */\n      xprintf(\"   --wcnf filename   write problem to filename in DIMACS\"\n         \" CNF-SAT format\\n\");\n#endif\n      xprintf(\"   --log filename    write copy of terminal output to fi\"\n         \"lename\\n\");\n      xprintf(\"   -h, --help        display this help information and e\"\n         \"xit\\n\");\n      xprintf(\"   -v, --version     display program version and exit\\n\")\n         ;\n      xprintf(\"\\n\");\n      xprintf(\"LP basis factorization options:\\n\");\n#if 0 /* 08/III-2014 */\n      xprintf(\"   --luf             LU + Forrest-Tomlin update\\n\");\n      xprintf(\"                     (faster, less stable; default)\\n\");\n      xprintf(\"   --cbg             LU + Schur complement + Bartels-Gol\"\n         \"ub update\\n\");\n      xprintf(\"                     (slower, more stable)\\n\");\n      xprintf(\"   --cgr             LU + Schur complement + Givens rota\"\n         \"tion update\\n\");\n      xprintf(\"                     (slower, more stable)\\n\");\n#else\n      xprintf(\"   --luf             plain LU-factorization (default)\\n\")\n         ;\n      xprintf(\"   --btf             block triangular LU-factorization\\n\"\n         );\n      xprintf(\"   --ft              Forrest-Tomlin update (requires --l\"\n         \"uf; default)\\n\");\n      xprintf(\"   --cbg             Schur complement + Bartels-Golub up\"\n         \"date\\n\");\n      xprintf(\"   --cgr             Schur complement + Givens rotation \"\n         \"update\\n\");\n#endif\n      xprintf(\"\\n\");\n      xprintf(\"Options specific to simplex solver:\\n\");\n      xprintf(\"   --primal          use primal simplex (default)\\n\");\n      xprintf(\"   --dual            use dual simplex\\n\");\n      xprintf(\"   --std             use standard initial basis of all s\"\n         \"lacks\\n\");\n      xprintf(\"   --adv             use advanced initial basis (default\"\n         \")\\n\");\n      xprintf(\"   --bib             use Bixby's initial basis\\n\");\n      xprintf(\"   --ini filename    use as initial basis previously sav\"\n         \"ed with -w\\n\");\n      xprintf(\"                     (disables LP presolver)\\n\");\n      xprintf(\"   --steep           use steepest edge technique (defaul\"\n         \"t)\\n\");\n      xprintf(\"   --nosteep         use standard \\\"textbook\\\" pricing\\n\"\n         );\n      xprintf(\"   --relax           use Harris' two-pass ratio test (de\"\n         \"fault)\\n\");\n      xprintf(\"   --norelax         use standard \\\"textbook\\\" ratio tes\"\n         \"t\\n\");\n#if 0 /* 23/VI-2017 */\n#if 1 /* 28/III-2016 */\n      xprintf(\"   --flip            use flip-flop ratio test (assumes -\"\n         \"-dual)\\n\");\n#endif\n#else\n      /* now this option is implemented in both primal and dual */\n      xprintf(\"   --flip            use long-step ratio test\\n\");\n#endif\n      xprintf(\"   --presol          use presolver (default; assumes --s\"\n         \"cale and --adv)\\n\");\n      xprintf(\"   --nopresol        do not use presolver\\n\");\n      xprintf(\"   --exact           use simplex method based on exact a\"\n         \"rithmetic\\n\");\n      xprintf(\"   --xcheck          check final basis using exact arith\"\n         \"metic\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"Options specific to interior-point solver:\\n\");\n      xprintf(\"   --nord            use natural (original) ordering\\n\");\n      xprintf(\"   --qmd             use quotient minimum degree orderin\"\n         \"g\\n\");\n      xprintf(\"   --amd             use approximate minimum degree orde\"\n         \"ring (default)\\n\");\n      xprintf(\"   --symamd          use approximate minimum degree orde\"\n         \"ring\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"Options specific to MIP solver:\\n\");\n      xprintf(\"   --nomip           consider all integer variables as c\"\n         \"ontinuous\\n\");\n      xprintf(\"                     (allows solving MIP as pure LP)\\n\");\n      xprintf(\"   --first           branch on first integer variable\\n\")\n         ;\n      xprintf(\"   --last            branch on last integer variable\\n\");\n      xprintf(\"   --mostf           branch on most fractional variable \"\n         \"\\n\");\n      xprintf(\"   --drtom           branch using heuristic by Driebeck \"\n         \"and Tomlin\\n\");\n      xprintf(\"                     (default)\\n\");\n      xprintf(\"   --pcost           branch using hybrid pseudocost heur\"\n         \"istic (may be\\n\");\n      xprintf(\"                     useful for hard instances)\\n\");\n      xprintf(\"   --dfs             backtrack using depth first search \"\n         \"\\n\");\n      xprintf(\"   --bfs             backtrack using breadth first searc\"\n         \"h\\n\");\n      xprintf(\"   --bestp           backtrack using the best projection\"\n         \" heuristic\\n\");\n      xprintf(\"   --bestb           backtrack using node with best loca\"\n         \"l bound\\n\");\n      xprintf(\"                     (default)\\n\");\n      xprintf(\"   --intopt          use MIP presolver (default)\\n\");\n      xprintf(\"   --nointopt        do not use MIP presolver\\n\");\n      xprintf(\"   --binarize        replace general integer variables b\"\n         \"y binary ones\\n\");\n      xprintf(\"                     (assumes --intopt)\\n\");\n      xprintf(\"   --fpump           apply feasibility pump heuristic\\n\")\n         ;\n#if 1 /* 29/VI-2013 */\n      xprintf(\"   --proxy [nnn]     apply proximity search heuristic (n\"\n         \"nn is time limit\\n\");\n      xprintf(\"                     in seconds; default is 60)\\n\");\n#endif\n      xprintf(\"   --gomory          generate Gomory's mixed integer cut\"\n         \"s\\n\");\n      xprintf(\"   --mir             generate MIR (mixed integer roundin\"\n         \"g) cuts\\n\");\n      xprintf(\"   --cover           generate mixed cover cuts\\n\");\n      xprintf(\"   --clique          generate clique cuts\\n\");\n      xprintf(\"   --cuts            generate all cuts above\\n\");\n      xprintf(\"   --mipgap tol      set relative mip gap tolerance to t\"\n         \"ol\\n\");\n#if 1 /* 15/VIII-2011 */\n      xprintf(\"   --minisat         translate integer feasibility probl\"\n         \"em to CNF-SAT\\n\");\n      xprintf(\"                     and solve it with MiniSat solver\\n\")\n         ;\n      xprintf(\"   --objbnd bound    add inequality obj <= bound (minimi\"\n         \"zation) or\\n\");\n      xprintf(\"                     obj >= bound (maximization) to inte\"\n         \"ger feasibility\\n\");\n      xprintf(\"                     problem (assumes --minisat)\\n\");\n#endif\n      xprintf(\"\\n\");\n      xprintf(\"For description of the MPS and CPLEX LP formats see Refe\"\n         \"rence Manual.\\n\");\n      xprintf(\"For description of the modeling language see \\\"GLPK: Mod\"\n         \"eling Language\\n\");\n      xprintf(\"GNU MathProg\\\". Both documents are included in the GLPK \"\n         \"distribution.\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"See GLPK web page at <http://www.gnu.org/software/glpk/g\"\n         \"lpk.html>.\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"Please report bugs to <bug-glpk@gnu.org>.\\n\");\n      return;\n}",
      "lines": 240,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_version": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "static void print_version(int briefly)\n{     /* print version information */\n      xprintf(\"GLPSOL: GLPK LP/MIP Solver, v%s\\n\", glp_version());\n      if (briefly) goto done;\n      xprintf(\"Copyright (C) 2000-2017 Andrew Makhorin, Department for \"\n         \"Applied\\n\");\n      xprintf(\"Informatics, Moscow Aviation Institute, Moscow, Russia. \"\n         \"All rights\\n\");\n      xprintf(\"reserved. E-mail: <mao@gnu.org>.\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"This program has ABSOLUTELY NO WARRANTY.\\n\");\n      xprintf(\"\\n\");\n      xprintf(\"This program is free software; you may re-distribute it \"\n         \"under the terms\\n\");\n      xprintf(\"of the GNU General Public License version 3 or later.\\n\")\n         ;\ndone: return;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_cmdline": {
      "start_point": [
        451,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "static int parse_cmdline(struct csa *csa, int argc, char *argv[])\n{     /* parse command-line parameters */\n      int k;\n#define p(str) (strcmp(argv[k], str) == 0)\n      for (k = 1; k < argc; k++)\n      {  if (p(\"--mps\"))\n            csa->format = FMT_MPS_DECK;\n         else if (p(\"--freemps\"))\n            csa->format = FMT_MPS_FILE;\n         else if (p(\"--lp\") || p(\"--cpxlp\"))\n            csa->format = FMT_LP;\n         else if (p(\"--glp\"))\n            csa->format = FMT_GLP;\n         else if (p(\"--math\") || p(\"-m\") || p(\"--model\"))\n            csa->format = FMT_MATHPROG;\n         else if (p(\"-d\") || p(\"--data\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No input data file specified\\n\");\n               return 1;\n            }\n            if (csa->ndf == DATA_MAX)\n            {  xprintf(\"Too many input data files\\n\");\n               return 1;\n            }\n            csa->in_data[++(csa->ndf)] = argv[k];\n         }\n         else if (p(\"-y\") || p(\"--display\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No display output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_dpy != NULL)\n            {  xprintf(\"Only one display output file allowed\\n\");\n               return 1;\n            }\n            csa->out_dpy = argv[k];\n         }\n         else if (p(\"--seed\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' ||\n               argv[k][0] == '-' && !isdigit((unsigned char)argv[k][1]))\n            {  xprintf(\"No seed value specified\\n\");\n               return 1;\n            }\n            if (strcmp(argv[k], \"?\") == 0)\n               csa->seed = 0x80000000;\n            else if (str2int(argv[k], &csa->seed))\n            {  xprintf(\"Invalid seed value '%s'\\n\", argv[k]);\n               return 1;\n            }\n         }\n         else if (p(\"--mincost\"))\n            csa->format = FMT_MIN_COST;\n         else if (p(\"--maxflow\"))\n            csa->format = FMT_MAX_FLOW;\n#if 1 /* 06/VIII-2011 */\n         else if (p(\"--cnf\"))\n            csa->format = FMT_CNF;\n#endif\n         else if (p(\"--simplex\"))\n            csa->solution = SOL_BASIC;\n         else if (p(\"--interior\"))\n            csa->solution = SOL_INTERIOR;\n#if 1 /* 28/V-2010 */\n         else if (p(\"--alien\"))\n            csa->iocp.alien = GLP_ON;\n#endif\n         else if (p(\"-r\") || p(\"--read\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No input solution file specified\\n\");\n               return 1;\n            }\n            if (csa->in_res != NULL)\n            {  xprintf(\"Only one input solution file allowed\\n\");\n               return 1;\n            }\n            csa->in_res = argv[k];\n         }\n         else if (p(\"--min\"))\n            csa->dir = GLP_MIN;\n         else if (p(\"--max\"))\n            csa->dir = GLP_MAX;\n         else if (p(\"--scale\"))\n            csa->scale = 1;\n         else if (p(\"--noscale\"))\n            csa->scale = 0;\n         else if (p(\"-o\") || p(\"--output\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No output solution file specified\\n\");\n               return 1;\n            }\n            if (csa->out_sol != NULL)\n            {  xprintf(\"Only one output solution file allowed\\n\");\n               return 1;\n            }\n            csa->out_sol = argv[k];\n         }\n         else if (p(\"-w\") || p(\"--write\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No output solution file specified\\n\");\n               return 1;\n            }\n            if (csa->out_res != NULL)\n            {  xprintf(\"Only one output solution file allowed\\n\");\n               return 1;\n            }\n            csa->out_res = argv[k];\n         }\n         else if (p(\"--ranges\") || p(\"--bounds\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No output file specified to write sensitivity a\"\n                  \"nalysis report\\n\");\n               return 1;\n            }\n            if (csa->out_ranges != NULL)\n            {  xprintf(\"Only one output file allowed to write sensitivi\"\n                  \"ty analysis report\\n\");\n               return 1;\n            }\n            csa->out_ranges = argv[k];\n         }\n         else if (p(\"--tmlim\"))\n         {  int tm_lim;\n            k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No time limit specified\\n\");\n               return 1;\n            }\n            if (str2int(argv[k], &tm_lim) || tm_lim < 0)\n            {  xprintf(\"Invalid time limit '%s'\\n\", argv[k]);\n               return 1;\n            }\n            if (tm_lim <= INT_MAX / 1000)\n               csa->smcp.tm_lim = csa->iocp.tm_lim = 1000 * tm_lim;\n            else\n               csa->smcp.tm_lim = csa->iocp.tm_lim = INT_MAX;\n         }\n         else if (p(\"--memlim\"))\n         {  int mem_lim;\n            k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No memory limit specified\\n\");\n               return 1;\n            }\n            if (str2int(argv[k], &mem_lim) || mem_lim < 1)\n            {  xprintf(\"Invalid memory limit '%s'\\n\", argv[k]);\n               return 1;\n            }\n            glp_mem_limit(mem_lim);\n         }\n         else if (p(\"--check\"))\n            csa->check = 1;\n         else if (p(\"--name\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No problem name specified\\n\");\n               return 1;\n            }\n            if (csa->new_name != NULL)\n            {  xprintf(\"Only one problem name allowed\\n\");\n               return 1;\n            }\n            csa->new_name = argv[k];\n         }\n#if 1 /* 18/I-2018 */\n         else if (p(\"--hide\"))\n            csa->hide = 1;\n#endif\n         else if (p(\"--wmps\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No fixed MPS output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_mps != NULL)\n            {  xprintf(\"Only one fixed MPS output file allowed\\n\");\n               return 1;\n            }\n            csa->out_mps = argv[k];\n         }\n         else if (p(\"--wfreemps\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No free MPS output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_freemps != NULL)\n            {  xprintf(\"Only one free MPS output file allowed\\n\");\n               return 1;\n            }\n            csa->out_freemps = argv[k];\n         }\n         else if (p(\"--wlp\") || p(\"--wcpxlp\") || p(\"--wlpt\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No CPLEX LP output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_cpxlp != NULL)\n            {  xprintf(\"Only one CPLEX LP output file allowed\\n\");\n               return 1;\n            }\n            csa->out_cpxlp = argv[k];\n         }\n         else if (p(\"--wglp\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No GLPK LP/MIP output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_glp != NULL)\n            {  xprintf(\"Only one GLPK LP/MIP output file allowed\\n\");\n               return 1;\n            }\n            csa->out_glp = argv[k];\n         }\n#if 0\n         else if (p(\"--wpb\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No problem output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_pb != NULL)\n            {  xprintf(\"Only one OPB output file allowed\\n\");\n               return 1;\n            }\n            csa->out_pb = argv[k];\n         }\n         else if (p(\"--wnpb\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No problem output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_npb != NULL)\n            {  xprintf(\"Only one normalized OPB output file allowed\\n\");\n               return 1;\n            }\n            csa->out_npb = argv[k];\n         }\n#endif\n#if 1 /* 06/VIII-2011 */\n         else if (p(\"--wcnf\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No problem output file specified\\n\");\n               return 1;\n            }\n            if (csa->out_cnf != NULL)\n            {  xprintf(\"Only one output DIMACS CNF-SAT file allowed\\n\");\n               return 1;\n            }\n            csa->out_cnf = argv[k];\n         }\n#endif\n         else if (p(\"--log\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No log file specified\\n\");\n               return 1;\n            }\n            if (csa->log_file != NULL)\n            {  xprintf(\"Only one log file allowed\\n\");\n               return 1;\n            }\n            csa->log_file = argv[k];\n         }\n         else if (p(\"-h\") || p(\"--help\"))\n         {  print_help(argv[0]);\n            return -1;\n         }\n         else if (p(\"-v\") || p(\"--version\"))\n         {  print_version(0);\n            return -1;\n         }\n#if 0 /* 08/III-2014 */\n         else if (p(\"--luf\"))\n            csa->bfcp.type = GLP_BF_FT;\n         else if (p(\"--cbg\"))\n            csa->bfcp.type = GLP_BF_BG;\n         else if (p(\"--cgr\"))\n            csa->bfcp.type = GLP_BF_GR;\n#else\n         else if (p(\"--luf\"))\n         {  csa->bfcp.type &= 0x0F;\n            csa->bfcp.type |= GLP_BF_LUF;\n         }\n         else if (p(\"--btf\"))\n         {  csa->bfcp.type &= 0x0F;\n            csa->bfcp.type |= GLP_BF_BTF;\n         }\n         else if (p(\"--ft\"))\n         {  csa->bfcp.type &= 0xF0;\n            csa->bfcp.type |= GLP_BF_FT;\n         }\n         else if (p(\"--cbg\"))\n         {  csa->bfcp.type &= 0xF0;\n            csa->bfcp.type |= GLP_BF_BG;\n         }\n         else if (p(\"--cgr\"))\n         {  csa->bfcp.type &= 0xF0;\n            csa->bfcp.type |= GLP_BF_GR;\n         }\n#endif\n         else if (p(\"--primal\"))\n            csa->smcp.meth = GLP_PRIMAL;\n         else if (p(\"--dual\"))\n            csa->smcp.meth = GLP_DUAL;\n         else if (p(\"--std\"))\n            csa->crash = USE_STD_BASIS;\n         else if (p(\"--adv\"))\n            csa->crash = USE_ADV_BASIS;\n         else if (p(\"--bib\"))\n            csa->crash = USE_CPX_BASIS;\n         else if (p(\"--ini\"))\n         {  csa->crash = USE_INI_BASIS;\n            csa->smcp.presolve = GLP_OFF;\n            k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No initial basis file specified\\n\");\n               return 1;\n            }\n            if (csa->ini_file != NULL)\n            {  xprintf(\"Only one initial basis file allowed\\n\");\n               return 1;\n            }\n            csa->ini_file = argv[k];\n         }\n         else if (p(\"--steep\"))\n            csa->smcp.pricing = GLP_PT_PSE;\n         else if (p(\"--nosteep\"))\n            csa->smcp.pricing = GLP_PT_STD;\n         else if (p(\"--relax\"))\n            csa->smcp.r_test = GLP_RT_HAR;\n         else if (p(\"--norelax\"))\n            csa->smcp.r_test = GLP_RT_STD;\n#if 1 /* 28/III-2016 */\n         else if (p(\"--flip\"))\n#if 0 /* 23/VI-2017 */\n         {  csa->smcp.meth = GLP_DUAL;\n#else\n         /* now this option is implemented in both primal and dual */\n         {\n#endif\n            csa->smcp.r_test = GLP_RT_FLIP;\n            csa->iocp.flip = GLP_ON;\n         }\n#endif\n         else if (p(\"--presol\"))\n            csa->smcp.presolve = GLP_ON;\n         else if (p(\"--nopresol\"))\n            csa->smcp.presolve = GLP_OFF;\n         else if (p(\"--exact\"))\n            csa->exact = 1;\n         else if (p(\"--xcheck\"))\n            csa->xcheck = 1;\n         else if (p(\"--nord\"))\n            csa->iptcp.ord_alg = GLP_ORD_NONE;\n         else if (p(\"--qmd\"))\n            csa->iptcp.ord_alg = GLP_ORD_QMD;\n         else if (p(\"--amd\"))\n            csa->iptcp.ord_alg = GLP_ORD_AMD;\n         else if (p(\"--symamd\"))\n            csa->iptcp.ord_alg = GLP_ORD_SYMAMD;\n         else if (p(\"--nomip\"))\n            csa->nomip = 1;\n         else if (p(\"--first\"))\n            csa->iocp.br_tech = GLP_BR_FFV;\n         else if (p(\"--last\"))\n            csa->iocp.br_tech = GLP_BR_LFV;\n         else if (p(\"--drtom\"))\n            csa->iocp.br_tech = GLP_BR_DTH;\n         else if (p(\"--mostf\"))\n            csa->iocp.br_tech = GLP_BR_MFV;\n         else if (p(\"--pcost\"))\n            csa->iocp.br_tech = GLP_BR_PCH;\n         else if (p(\"--dfs\"))\n            csa->iocp.bt_tech = GLP_BT_DFS;\n         else if (p(\"--bfs\"))\n            csa->iocp.bt_tech = GLP_BT_BFS;\n         else if (p(\"--bestp\"))\n            csa->iocp.bt_tech = GLP_BT_BPH;\n         else if (p(\"--bestb\"))\n            csa->iocp.bt_tech = GLP_BT_BLB;\n         else if (p(\"--intopt\"))\n            csa->iocp.presolve = GLP_ON;\n         else if (p(\"--nointopt\"))\n            csa->iocp.presolve = GLP_OFF;\n         else if (p(\"--binarize\"))\n            csa->iocp.presolve = csa->iocp.binarize = GLP_ON;\n         else if (p(\"--fpump\"))\n            csa->iocp.fp_heur = GLP_ON;\n#if 1 /* 29/VI-2013 */\n         else if (p(\"--proxy\"))\n         {  csa->iocp.ps_heur = GLP_ON;\n            if (argv[k+1] && isdigit((unsigned char)argv[k+1][0]))\n            {  int nnn;\n               k++;\n               if (str2int(argv[k], &nnn) || nnn < 1)\n               {  xprintf(\"Invalid proxy time limit '%s'\\n\", argv[k]);\n                  return 1;\n               }\n               csa->iocp.ps_tm_lim = 1000 * nnn;\n            }\n         }\n#endif\n         else if (p(\"--gomory\"))\n            csa->iocp.gmi_cuts = GLP_ON;\n         else if (p(\"--mir\"))\n            csa->iocp.mir_cuts = GLP_ON;\n         else if (p(\"--cover\"))\n            csa->iocp.cov_cuts = GLP_ON;\n         else if (p(\"--clique\"))\n            csa->iocp.clq_cuts = GLP_ON;\n         else if (p(\"--cuts\"))\n            csa->iocp.gmi_cuts = csa->iocp.mir_cuts =\n            csa->iocp.cov_cuts = csa->iocp.clq_cuts = GLP_ON;\n         else if (p(\"--mipgap\"))\n         {  double mip_gap;\n            k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No relative gap tolerance specified\\n\");\n               return 1;\n            }\n            if (str2num(argv[k], &mip_gap) || mip_gap < 0.0)\n            {  xprintf(\"Invalid relative mip gap tolerance '%s'\\n\",\n                  argv[k]);\n               return 1;\n            }\n            csa->iocp.mip_gap = mip_gap;\n         }\n#if 1 /* 15/VIII-2011 */\n         else if (p(\"--minisat\"))\n            csa->minisat = 1;\n         else if (p(\"--objbnd\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' ||\n               argv[k][0] == '-' && !isdigit((unsigned char)argv[k][1]))\n            {  xprintf(\"No objective bound specified\\n\");\n               return 1;\n            }\n            csa->minisat = 1;\n            csa->use_bnd = 1;\n            if (str2int(argv[k], &csa->obj_bnd))\n            {  xprintf(\"Invalid objective bound '%s' (should be integer\"\n                  \" value)\\n\", argv[k]);\n               return 1;\n            }\n         }\n#endif\n#if 1 /* 11/VII-2013 */\n         else if (p(\"--use\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No input MIP solution file specified\\n\");\n               return 1;\n            }\n            if (csa->use_sol != NULL)\n            {  xprintf(\"Only one input MIP solution file allowed\\n\");\n               return 1;\n            }\n            csa->use_sol = argv[k];\n         }\n         else if (p(\"--save\"))\n         {  k++;\n            if (k == argc || argv[k][0] == '\\0' || argv[k][0] == '-')\n            {  xprintf(\"No output MIP solution file specified\\n\");\n               return 1;\n            }\n            if (csa->iocp.save_sol != NULL)\n            {  xprintf(\"Only one output MIP solution file allowed\\n\");\n               return 1;\n            }\n            csa->iocp.save_sol = argv[k];\n         }\n#endif\n         else if (argv[k][0] == '-' ||\n                 (argv[k][0] == '-' && argv[k][1] == '-'))\n         {  xprintf(\"Invalid option '%s'; try %s --help\\n\",\n               argv[k], argv[0]);\n            return 1;\n         }\n         else\n         {  if (csa->in_file != NULL)\n            {  xprintf(\"Only one input problem file allowed\\n\");\n               return 1;\n            }\n            csa->in_file = argv[k];\n         }\n      }\n#undef p\n      return 0;\n}",
      "lines": 500,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        1581,
        1
      ],
      "content": "int __cdecl main(int argc, char *argv[])\n#endif\n{     /* stand-alone LP/MIP solver */\n      struct csa _csa, *csa = &_csa;\n      int ret;\n#if 0 /* 10/VI-2013 */\n      glp_long start;\n#else\n      double start;\n#endif\n      /* perform initialization */\n      csa->prob = glp_create_prob();\n      glp_get_bfcp(csa->prob, &csa->bfcp);\n      glp_init_smcp(&csa->smcp);\n      csa->smcp.presolve = GLP_ON;\n      glp_init_iptcp(&csa->iptcp);\n      glp_init_iocp(&csa->iocp);\n      csa->iocp.presolve = GLP_ON;\n      csa->tran = NULL;\n      csa->graph = NULL;\n      csa->format = FMT_MPS_FILE;\n      csa->in_file = NULL;\n      csa->ndf = 0;\n      csa->out_dpy = NULL;\n      csa->seed = 1;\n      csa->solution = SOL_BASIC;\n      csa->in_res = NULL;\n      csa->dir = 0;\n      csa->scale = 1;\n      csa->out_sol = NULL;\n      csa->out_res = NULL;\n      csa->out_ranges = NULL;\n      csa->check = 0;\n      csa->new_name = NULL;\n#if 1 /* 18/I-2018 */\n      csa->hide = 0;\n#endif\n      csa->out_mps = NULL;\n      csa->out_freemps = NULL;\n      csa->out_cpxlp = NULL;\n      csa->out_glp = NULL;\n#if 0\n      csa->out_pb = NULL;\n      csa->out_npb = NULL;\n#endif\n#if 1 /* 06/VIII-2011 */\n      csa->out_cnf = NULL;\n#endif\n      csa->log_file = NULL;\n      csa->crash = USE_ADV_BASIS;\n      csa->ini_file = NULL;\n      csa->exact = 0;\n      csa->xcheck = 0;\n      csa->nomip = 0;\n#if 1 /* 15/VIII-2011 */\n      csa->minisat = 0;\n      csa->use_bnd = 0;\n      csa->obj_bnd = 0;\n#endif\n#if 1 /* 11/VII-2013 */\n      csa->use_sol = NULL;\n#endif\n      /* parse command-line parameters */\n      ret = parse_cmdline(csa, argc, argv);\n      if (ret < 0)\n      {  ret = EXIT_SUCCESS;\n         goto done;\n      }\n      if (ret > 0)\n      {  ret = EXIT_FAILURE;\n         goto done;\n      }\n      /*--------------------------------------------------------------*/\n      /* remove all output files specified in the command line */\n      if (csa->out_dpy != NULL) remove(csa->out_dpy);\n      if (csa->out_sol != NULL) remove(csa->out_sol);\n      if (csa->out_res != NULL) remove(csa->out_res);\n      if (csa->out_ranges != NULL) remove(csa->out_ranges);\n      if (csa->out_mps != NULL) remove(csa->out_mps);\n      if (csa->out_freemps != NULL) remove(csa->out_freemps);\n      if (csa->out_cpxlp != NULL) remove(csa->out_cpxlp);\n      if (csa->out_glp != NULL) remove(csa->out_glp);\n#if 0\n      if (csa->out_pb != NULL) remove(csa->out_pb);\n      if (csa->out_npb != NULL) remove(csa->out_npb);\n#endif\n#if 1 /* 06/VIII-2011 */\n      if (csa->out_cnf != NULL) remove(csa->out_cnf);\n#endif\n      if (csa->log_file != NULL) remove(csa->log_file);\n      /*--------------------------------------------------------------*/\n      /* open log file, if required */\n      if (csa->log_file != NULL)\n      {  if (glp_open_tee(csa->log_file))\n         {  xprintf(\"Unable to create log file\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /*--------------------------------------------------------------*/\n      /* print version information */\n      print_version(1);\n      /*--------------------------------------------------------------*/\n      /* print parameters specified in the command line */\n      if (argc > 1)\n      {  int k, len = INT_MAX;\n         xprintf(\"Parameter(s) specified in the command line:\");\n         for (k = 1; k < argc; k++)\n         {  if (len > 72)\n               xprintf(\"\\n\"), len = 0;\n            xprintf(\" %s\", argv[k]);\n            len += 1 + strlen(argv[k]);\n         }\n         xprintf(\"\\n\");\n      }\n      /*--------------------------------------------------------------*/\n      /* read problem data from the input file */\n      if (csa->in_file == NULL)\n      {  xprintf(\"No input problem file specified; try %s --help\\n\",\n            argv[0]);\n         ret = EXIT_FAILURE;\n         goto done;\n      }\n      if (csa->format == FMT_MPS_DECK)\n      {  ret = glp_read_mps(csa->prob, GLP_MPS_DECK, NULL,\n            csa->in_file);\n         if (ret != 0)\nerr1:    {  xprintf(\"MPS file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      else if (csa->format == FMT_MPS_FILE)\n      {  ret = glp_read_mps(csa->prob, GLP_MPS_FILE, NULL,\n            csa->in_file);\n         if (ret != 0) goto err1;\n      }\n      else if (csa->format == FMT_LP)\n      {  ret = glp_read_lp(csa->prob, NULL, csa->in_file);\n         if (ret != 0)\n         {  xprintf(\"CPLEX LP file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      else if (csa->format == FMT_GLP)\n      {  ret = glp_read_prob(csa->prob, 0, csa->in_file);\n         if (ret != 0)\n         {  xprintf(\"GLPK LP/MIP file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      else if (csa->format == FMT_MATHPROG)\n      {  int k;\n         /* allocate the translator workspace */\n         csa->tran = glp_mpl_alloc_wksp();\n         /* set seed value */\n         if (csa->seed == 0x80000000)\n#if 0 /* 10/VI-2013 */\n         {  csa->seed = glp_time().lo;\n#else\n         {  csa->seed = (int)fmod(glp_time(), 1000000000.0);\n#endif\n            xprintf(\"Seed value %d will be used\\n\", csa->seed);\n         }\n         glp_mpl_init_rand(csa->tran, csa->seed);\n         /* read model section and optional data section */\n         if (glp_mpl_read_model(csa->tran, csa->in_file, csa->ndf > 0))\nerr2:    {  xprintf(\"MathProg model processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         /* read optional data section(s), if necessary */\n         for (k = 1; k <= csa->ndf; k++)\n         {  if (glp_mpl_read_data(csa->tran, csa->in_data[k]))\n               goto err2;\n         }\n         /* generate the model */\n         if (glp_mpl_generate(csa->tran, csa->out_dpy)) goto err2;\n         /* build the problem instance from the model */\n         glp_mpl_build_prob(csa->tran, csa->prob);\n      }\n      else if (csa->format == FMT_MIN_COST)\n      {  csa->graph = glp_create_graph(sizeof(v_data), sizeof(a_data));\n         ret = glp_read_mincost(csa->graph, offsetof(v_data, rhs),\n            offsetof(a_data, low), offsetof(a_data, cap),\n            offsetof(a_data, cost), csa->in_file);\n         if (ret != 0)\n         {  xprintf(\"DIMACS file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         glp_mincost_lp(csa->prob, csa->graph, GLP_ON,\n            offsetof(v_data, rhs), offsetof(a_data, low),\n            offsetof(a_data, cap), offsetof(a_data, cost));\n         glp_set_prob_name(csa->prob, csa->in_file);\n      }\n      else if (csa->format == FMT_MAX_FLOW)\n      {  int s, t;\n         csa->graph = glp_create_graph(sizeof(v_data), sizeof(a_data));\n         ret = glp_read_maxflow(csa->graph, &s, &t,\n            offsetof(a_data, cap), csa->in_file);\n         if (ret != 0)\n         {  xprintf(\"DIMACS file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         glp_maxflow_lp(csa->prob, csa->graph, GLP_ON, s, t,\n            offsetof(a_data, cap));\n         glp_set_prob_name(csa->prob, csa->in_file);\n      }\n#if 1 /* 06/VIII-2011 */\n      else if (csa->format == FMT_CNF)\n      {  ret = glp_read_cnfsat(csa->prob, csa->in_file);\n         if (ret != 0)\n         {  xprintf(\"DIMACS file processing error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         glp_set_prob_name(csa->prob, csa->in_file);\n      }\n#endif\n      else\n         xassert(csa != csa);\n      /*--------------------------------------------------------------*/\n      /* change problem name, if required */\n      if (csa->new_name != NULL)\n         glp_set_prob_name(csa->prob, csa->new_name);\n      /* change optimization direction, if required */\n      if (csa->dir != 0)\n         glp_set_obj_dir(csa->prob, csa->dir);\n      /* sort elements of the constraint matrix */\n      glp_sort_matrix(csa->prob);\n#if 1 /* 18/I-2018 */\n      /*--------------------------------------------------------------*/\n      /* remove all symbolic names from problem object, if required */\n      if (csa->hide)\n      {  int i, j;\n         glp_set_obj_name(csa->prob, NULL);\n         glp_delete_index(csa->prob);\n         for (i = glp_get_num_rows(csa->prob); i >= 1; i--)\n            glp_set_row_name(csa->prob, i, NULL);\n         for (j = glp_get_num_cols(csa->prob); j >= 1; j--)\n            glp_set_col_name(csa->prob, j, NULL);\n      }\n#endif\n      /*--------------------------------------------------------------*/\n      /* write problem data in fixed MPS format, if required */\n      if (csa->out_mps != NULL)\n      {  ret = glp_write_mps(csa->prob, GLP_MPS_DECK, NULL,\n            csa->out_mps);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem in fixed MPS format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write problem data in free MPS format, if required */\n      if (csa->out_freemps != NULL)\n      {  ret = glp_write_mps(csa->prob, GLP_MPS_FILE, NULL,\n            csa->out_freemps);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem in free MPS format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write problem data in CPLEX LP format, if required */\n      if (csa->out_cpxlp != NULL)\n      {  ret = glp_write_lp(csa->prob, NULL, csa->out_cpxlp);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem in CPLEX LP format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write problem data in GLPK format, if required */\n      if (csa->out_glp != NULL)\n      {  ret = glp_write_prob(csa->prob, 0, csa->out_glp);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem in GLPK format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n#if 0\n      /* write problem data in OPB format, if required */\n      if (csa->out_pb != NULL)\n      {  ret = lpx_write_pb(csa->prob, csa->out_pb, 0, 0);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem in OPB format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write problem data in normalized OPB format, if required */\n      if (csa->out_npb != NULL)\n      {  ret = lpx_write_pb(csa->prob, csa->out_npb, 1, 1);\n         if (ret != 0)\n         {  xprintf(\n               \"Unable to write problem in normalized OPB format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n#endif\n#if 1 /* 06/VIII-2011 */\n      /* write problem data in DIMACS CNF-SAT format, if required */\n      if (csa->out_cnf != NULL)\n      {  ret = glp_write_cnfsat(csa->prob, csa->out_cnf);\n         if (ret != 0)\n         {  xprintf(\n               \"Unable to write problem in DIMACS CNF-SAT format\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n#endif\n      /*--------------------------------------------------------------*/\n      /* if only problem data check is required, skip computations */\n      if (csa->check)\n      {\n#if 1 /* 29/III-2016 */\n         /* report problem characteristics */\n         int j, cnt = 0;\n         xprintf(\"--- Problem Characteristics ---\\n\");\n         xprintf(\"Number of rows               = %8d\\n\",\n            glp_get_num_rows(csa->prob));\n         xprintf(\"Number of columns            = %8d\\n\",\n            glp_get_num_cols(csa->prob));\n         xprintf(\"Number of non-zeros (matrix) = %8d\\n\",\n            glp_get_num_nz(csa->prob));\n         for (j = glp_get_num_cols(csa->prob); j >= 1; j--)\n         {  if (glp_get_obj_coef(csa->prob, j) != 0.0)\n               cnt++;\n         }\n         xprintf(\"Number of non-zeros (objrow) = %8d\\n\",\n            cnt);\n#endif\n         ret = EXIT_SUCCESS;\n         goto done;\n      }\n      /*--------------------------------------------------------------*/\n      /* determine the solution type */\n      if (!csa->nomip &&\n          glp_get_num_int(csa->prob) + glp_get_num_bin(csa->prob) > 0)\n      {  if (csa->solution == SOL_INTERIOR)\n         {  xprintf(\"Interior-point method is not able to solve MIP pro\"\n               \"blem; use --simplex\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         csa->solution = SOL_INTEGER;\n      }\n      /*--------------------------------------------------------------*/\n      /* if solution is provided, read it and skip computations */\n      if (csa->in_res != NULL)\n      {  if (csa->solution == SOL_BASIC)\n            ret = glp_read_sol(csa->prob, csa->in_res);\n         else if (csa->solution == SOL_INTERIOR)\n            ret = glp_read_ipt(csa->prob, csa->in_res);\n         else if (csa->solution == SOL_INTEGER)\n            ret = glp_read_mip(csa->prob, csa->in_res);\n         else\n            xassert(csa != csa);\n         if (ret != 0)\n         {  xprintf(\"Unable to read problem solution\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         goto skip;\n      }\n#if 1 /* 11/VII-2013 */\n      /*--------------------------------------------------------------*/\n      /* if initial MIP solution is provided, read it */\n      if (csa->solution == SOL_INTEGER && csa->use_sol != NULL)\n      {  ret = glp_read_mip(csa->prob, csa->use_sol);\n         if (ret != 0)\n         {  xprintf(\"Unable to read initial MIP solution\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n         csa->iocp.use_sol = GLP_ON;\n      }\n#endif\n      /*--------------------------------------------------------------*/\n      /* scale the problem data, if required */\n      if (csa->scale)\n      {  if (csa->solution == SOL_BASIC && !csa->smcp.presolve ||\n             csa->solution == SOL_INTERIOR ||\n             csa->solution == SOL_INTEGER && !csa->iocp.presolve)\n            glp_scale_prob(csa->prob, GLP_SF_AUTO);\n      }\n      /*--------------------------------------------------------------*/\n      /* construct starting LP basis */\n      if (csa->solution == SOL_BASIC && !csa->smcp.presolve ||\n          csa->solution == SOL_INTEGER && !csa->iocp.presolve)\n      {  if (csa->crash == USE_STD_BASIS)\n            glp_std_basis(csa->prob);\n         else if (csa->crash == USE_ADV_BASIS)\n            glp_adv_basis(csa->prob, 0);\n         else if (csa->crash == USE_CPX_BASIS)\n            glp_cpx_basis(csa->prob);\n         else if (csa->crash == USE_INI_BASIS)\n         {  ret = glp_read_sol(csa->prob, csa->ini_file);\n            if (ret != 0)\n            {  xprintf(\"Unable to read initial basis\\n\");\n               ret = EXIT_FAILURE;\n               goto done;\n            }\n         }\n         else\n            xassert(csa != csa);\n      }\n      /*--------------------------------------------------------------*/\n      /* solve the problem */\n      start = glp_time();\n      if (csa->solution == SOL_BASIC)\n      {  if (!csa->exact)\n         {  glp_set_bfcp(csa->prob, &csa->bfcp);\n            glp_simplex(csa->prob, &csa->smcp);\n            if (csa->xcheck)\n            {  if (csa->smcp.presolve &&\n                   glp_get_status(csa->prob) != GLP_OPT)\n                  xprintf(\"If you need to check final basis for non-opt\"\n                     \"imal solution, use --nopresol\\n\");\n               else\n                  glp_exact(csa->prob, &csa->smcp);\n            }\n            if (csa->out_sol != NULL || csa->out_res != NULL)\n            {  if (csa->smcp.presolve &&\n                   glp_get_status(csa->prob) != GLP_OPT)\n               xprintf(\"If you need actual output for non-optimal solut\"\n                  \"ion, use --nopresol\\n\");\n            }\n         }\n         else\n            glp_exact(csa->prob, &csa->smcp);\n      }\n      else if (csa->solution == SOL_INTERIOR)\n         glp_interior(csa->prob, &csa->iptcp);\n#if 1 /* 15/VIII-2011 */\n      else if (csa->solution == SOL_INTEGER && csa->minisat)\n      {  if (glp_check_cnfsat(csa->prob) == 0)\n            glp_minisat1(csa->prob);\n         else\n            glp_intfeas1(csa->prob, csa->use_bnd, csa->obj_bnd);\n      }\n#endif\n      else if (csa->solution == SOL_INTEGER)\n      {  glp_set_bfcp(csa->prob, &csa->bfcp);\n         if (!csa->iocp.presolve)\n            glp_simplex(csa->prob, &csa->smcp);\n#if 0\n         csa->iocp.msg_lev = GLP_MSG_DBG;\n         csa->iocp.pp_tech = GLP_PP_NONE;\n#endif\n#ifdef GLP_CB_FUNC /* 05/IV-2016 */\n         {  extern void GLP_CB_FUNC(glp_tree *, void *);\n            csa->iocp.cb_func = GLP_CB_FUNC;\n            csa->iocp.cb_info = NULL;\n         }\n#endif\n         glp_intopt(csa->prob, &csa->iocp);\n      }\n      else\n         xassert(csa != csa);\n      /*--------------------------------------------------------------*/\n      /* display statistics */\n      xprintf(\"Time used:   %.1f secs\\n\", glp_difftime(glp_time(),\n         start));\n#if 0 /* 16/II-2012 */\n      {  glp_long tpeak;\n         char buf[50];\n         glp_mem_usage(NULL, NULL, NULL, &tpeak);\n         xprintf(\"Memory used: %.1f Mb (%s bytes)\\n\",\n            xltod(tpeak) / 1048576.0, xltoa(tpeak, buf));\n      }\n#else\n      {  size_t tpeak;\n         glp_mem_usage(NULL, NULL, NULL, &tpeak);\n         xprintf(\"Memory used: %.1f Mb (%.0f bytes)\\n\",\n            (double)tpeak / 1048576.0, (double)tpeak);\n      }\n#endif\n      /*--------------------------------------------------------------*/\nskip: /* postsolve the model, if necessary */\n      if (csa->tran != NULL)\n      {  if (csa->solution == SOL_BASIC)\n         {  if (!(glp_get_status(csa->prob) == GLP_OPT ||\n                  glp_get_status(csa->prob) == GLP_FEAS))\n               ret = -1;\n            else\n               ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_SOL);\n         }\n         else if (csa->solution == SOL_INTERIOR)\n         {  if (!(glp_ipt_status(csa->prob) == GLP_OPT ||\n                  glp_ipt_status(csa->prob) == GLP_FEAS))\n               ret = -1;\n            else\n               ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_IPT);\n         }\n         else if (csa->solution == SOL_INTEGER)\n         {  if (!(glp_mip_status(csa->prob) == GLP_OPT ||\n                  glp_mip_status(csa->prob) == GLP_FEAS))\n               ret = -1;\n            else\n               ret = glp_mpl_postsolve(csa->tran, csa->prob, GLP_MIP);\n         }\n         else\n            xassert(csa != csa);\n         if (ret > 0)\n         {  xprintf(\"Model postsolving error\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /*--------------------------------------------------------------*/\n      /* write problem solution in printable format, if required */\n      if (csa->out_sol != NULL)\n      {  if (csa->solution == SOL_BASIC)\n            ret = glp_print_sol(csa->prob, csa->out_sol);\n         else if (csa->solution == SOL_INTERIOR)\n            ret = glp_print_ipt(csa->prob, csa->out_sol);\n         else if (csa->solution == SOL_INTEGER)\n            ret = glp_print_mip(csa->prob, csa->out_sol);\n         else\n            xassert(csa != csa);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem solution\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write problem solution in printable format, if required */\n      if (csa->out_res != NULL)\n      {  if (csa->solution == SOL_BASIC)\n            ret = glp_write_sol(csa->prob, csa->out_res);\n         else if (csa->solution == SOL_INTERIOR)\n            ret = glp_write_ipt(csa->prob, csa->out_res);\n         else if (csa->solution == SOL_INTEGER)\n            ret = glp_write_mip(csa->prob, csa->out_res);\n         else\n            xassert(csa != csa);\n         if (ret != 0)\n         {  xprintf(\"Unable to write problem solution\\n\");\n            ret = EXIT_FAILURE;\n            goto done;\n         }\n      }\n      /* write sensitivity analysis report, if required */\n      if (csa->out_ranges != NULL)\n      {  if (csa->solution == SOL_BASIC)\n         {  if (glp_get_status(csa->prob) == GLP_OPT)\n            {  if (glp_bf_exists(csa->prob))\nranges:        {  ret = glp_print_ranges(csa->prob, 0, NULL, 0,\n                     csa->out_ranges);\n                  if (ret != 0)\n                  {  xprintf(\"Unable to write sensitivity analysis repo\"\n                        \"rt\\n\");\n                     ret = EXIT_FAILURE;\n                     goto done;\n                  }\n               }\n               else\n               {  ret = glp_factorize(csa->prob);\n                  if (ret == 0) goto ranges;\n                  xprintf(\"Cannot produce sensitivity analysis report d\"\n                     \"ue to error in basis factorization (glp_factorize\"\n                     \" returned %d); try --nopresol\\n\", ret);\n               }\n            }\n            else\n               xprintf(\"Cannot produce sensitivity analysis report for \"\n                  \"non-optimal basic solution\\n\");\n         }\n         else\n            xprintf(\"Cannot produce sensitivity analysis report for int\"\n               \"erior-point or MIP solution\\n\");\n      }\n      /*--------------------------------------------------------------*/\n      /* all seems to be ok */\n      ret = EXIT_SUCCESS;\n      /*--------------------------------------------------------------*/\ndone: /* delete the LP/MIP problem object */\n      if (csa->prob != NULL)\n         glp_delete_prob(csa->prob);\n      /* free the translator workspace, if necessary */\n      if (csa->tran != NULL)\n         glp_mpl_free_wksp(csa->tran);\n      /* delete the network problem object, if necessary */\n      if (csa->graph != NULL)\n         glp_delete_graph(csa->graph);\n#if 0 /* 23/XI-2015 */\n      xassert(gmp_pool_count() == 0);\n      gmp_free_mem();\n#endif\n      /* close log file, if necessary */\n      if (csa->log_file != NULL) glp_close_tee();\n      /* check that no memory blocks are still allocated */\n#if 0 /* 16/II-2012 */\n      {  int count;\n         glp_long total;\n         glp_mem_usage(&count, NULL, &total, NULL);\n         if (count != 0)\n            xerror(\"Error: %d memory block(s) were lost\\n\", count);\n         xassert(count == 0);\n         xassert(total.lo == 0 && total.hi == 0);\n      }\n#else\n      {  int count;\n         size_t total;\n         glp_mem_usage(&count, NULL, &total, NULL);\n         if (count != 0)\n            xerror(\"Error: %d memory block(s) were lost\\n\", count);\n         xassert(total == 0);\n      }\n#endif\n      /* free the GLPK environment */\n      glp_free_env();\n      /* return to the control program */\n      return ret;\n}",
      "lines": 624,
      "depth": 19,
      "decorators": [
        "int",
        "__cdecl",
        "__cdecl"
      ]
    }
  },
  "glpk/glpk-4.65/examples/iptsamp.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        14,
        1
      ],
      "content": "int main(void)\n{     glp_prob *P;\n      P = glp_create_prob();\n      glp_read_mps(P, GLP_MPS_DECK, NULL, \"25fv47.mps\");\n      glp_interior(P, NULL);\n      glp_print_ipt(P, \"25fv47.txt\");\n      glp_delete_prob(P);\n      return 0;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/mplsamp1.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int main(void)\n{     glp_prob *lp;\n      glp_tran *tran;\n      int ret;\n      lp = glp_create_prob();\n      tran = glp_mpl_alloc_wksp();\n      ret = glp_mpl_read_model(tran, \"egypt.mod\", 0);\n      if (ret != 0)\n      {  fprintf(stderr, \"Error on translating model\\n\");\n         goto skip;\n      }\n      ret = glp_mpl_generate(tran, NULL);\n      if (ret != 0)\n      {  fprintf(stderr, \"Error on generating model\\n\");\n         goto skip;\n      }\n      glp_mpl_build_prob(tran, lp);\n      ret = glp_write_mps(lp, GLP_MPS_FILE, NULL, \"egypt.mps\");\n      if (ret != 0)\n         fprintf(stderr, \"Error on writing MPS file\\n\");\nskip: glp_mpl_free_wksp(tran);\n      glp_delete_prob(lp);\n      return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/mplsamp2.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int main(void)\n{     glp_prob *mip;\n      glp_tran *tran;\n      int ret;\n      mip = glp_create_prob();\n      tran = glp_mpl_alloc_wksp();\n      ret = glp_mpl_read_model(tran, \"sudoku.mod\", 1);\n      if (ret != 0)\n      {  fprintf(stderr, \"Error on translating model\\n\");\n         goto skip;\n      }\n      ret = glp_mpl_read_data(tran, \"sudoku.dat\");\n      if (ret != 0)\n      {  fprintf(stderr, \"Error on translating data\\n\");\n         goto skip;\n      }\n      ret = glp_mpl_generate(tran, NULL);\n      if (ret != 0)\n      {  fprintf(stderr, \"Error on generating model\\n\");\n         goto skip;\n      }\n      glp_mpl_build_prob(tran, mip);\n      glp_simplex(mip, NULL);\n      glp_intopt(mip, NULL);\n      ret = glp_mpl_postsolve(tran, mip, GLP_MIP);\n      if (ret != 0)\n         fprintf(stderr, \"Error on postsolving model\\n\");\nskip: glp_mpl_free_wksp(tran);\n      glp_delete_prob(mip);\n      return 0;\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/netgen.c": {
    "main": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "int main(void)\n{     glp_graph *G;\n      int k;\n      char fname[100+1];\n      G = glp_create_graph(sizeof(v_data), sizeof(a_data));\n      for (k = 1; k <= 50; k++)\n      {  sprintf(fname, \"netgn%03d.min\", parm[k-1][1]);\n         glp_netgen(G, offsetof(v_data, rhs), offsetof(a_data, cap),\n            offsetof(a_data, cost), &parm[k-1][-1]);\n         glp_write_mincost(G, offsetof(v_data, rhs), -1,\n            offsetof(a_data, cap), offsetof(a_data, cost), fname);\n      }\n      glp_delete_graph(G);\n      return 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/nppsamp.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int main(void)\n{     glp_prep *prep;\n      glp_prob *P, *Q;\n      int ret;\n      prep = glp_npp_alloc_wksp();\n      P = glp_create_prob();\n      ret = glp_read_mps(P, GLP_MPS_DECK, NULL, \"murtagh.mps\");\n      if (ret != 0)\n      {  printf(\"Error on reading problem data\\n\");\n         goto skip;\n      }\n      glp_set_obj_dir(P, GLP_MAX);\n      glp_npp_load_prob(prep, P, GLP_SOL, GLP_ON);\n      ret = glp_npp_preprocess1(prep, 0);\n      switch (ret)\n      {  case 0:\n            break;\n         case GLP_ENOPFS:\n            printf(\"LP has no primal feasible solution\\n\");\n            goto skip;\n         case GLP_ENODFS:\n            printf(\"LP has no dual feasible solution\\n\");\n            goto skip;\n         default:\n            glp_assert(ret != ret);\n      }\n      Q = glp_create_prob();\n      glp_npp_build_prob(prep, Q);\n      ret = glp_simplex(Q, NULL);\n      if (ret == 0 && glp_get_status(Q) == GLP_OPT)\n      {  glp_npp_postprocess(prep, Q);\n         glp_npp_obtain_sol(prep, P);\n      }\n      else\n         printf(\"Unable to recover non-optimal solution\\n\");\n      glp_delete_prob(Q);\nskip: glp_npp_free_wksp(prep);\n      glp_delete_prob(P);\n      return 0;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/sample.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int main(void)\n{     glp_prob *lp;\n      int ia[1+1000], ja[1+1000];\n      double ar[1+1000], z, x1, x2, x3;\ns1:   lp = glp_create_prob();\ns2:   glp_set_prob_name(lp, \"sample\");\ns3:   glp_set_obj_dir(lp, GLP_MAX);\ns4:   glp_add_rows(lp, 3);\ns5:   glp_set_row_name(lp, 1, \"p\");\ns6:   glp_set_row_bnds(lp, 1, GLP_UP, 0.0, 100.0);\ns7:   glp_set_row_name(lp, 2, \"q\");\ns8:   glp_set_row_bnds(lp, 2, GLP_UP, 0.0, 600.0);\ns9:   glp_set_row_name(lp, 3, \"r\");\ns10:  glp_set_row_bnds(lp, 3, GLP_UP, 0.0, 300.0);\ns11:  glp_add_cols(lp, 3);\ns12:  glp_set_col_name(lp, 1, \"x1\");\ns13:  glp_set_col_bnds(lp, 1, GLP_LO, 0.0, 0.0);\ns14:  glp_set_obj_coef(lp, 1, 10.0);\ns15:  glp_set_col_name(lp, 2, \"x2\");\ns16:  glp_set_col_bnds(lp, 2, GLP_LO, 0.0, 0.0);\ns17:  glp_set_obj_coef(lp, 2, 6.0);\ns18:  glp_set_col_name(lp, 3, \"x3\");\ns19:  glp_set_col_bnds(lp, 3, GLP_LO, 0.0, 0.0);\ns20:  glp_set_obj_coef(lp, 3, 4.0);\ns21:  ia[1] = 1, ja[1] = 1, ar[1] =  1.0; /* a[1,1] =  1 */\ns22:  ia[2] = 1, ja[2] = 2, ar[2] =  1.0; /* a[1,2] =  1 */\ns23:  ia[3] = 1, ja[3] = 3, ar[3] =  1.0; /* a[1,3] =  1 */\ns24:  ia[4] = 2, ja[4] = 1, ar[4] = 10.0; /* a[2,1] = 10 */\ns25:  ia[5] = 3, ja[5] = 1, ar[5] =  2.0; /* a[3,1] =  2 */\ns26:  ia[6] = 2, ja[6] = 2, ar[6] =  4.0; /* a[2,2] =  4 */\ns27:  ia[7] = 3, ja[7] = 2, ar[7] =  2.0; /* a[3,2] =  2 */\ns28:  ia[8] = 2, ja[8] = 3, ar[8] =  5.0; /* a[2,3] =  5 */\ns29:  ia[9] = 3, ja[9] = 3, ar[9] =  6.0; /* a[3,3] =  6 */\ns30:  glp_load_matrix(lp, 9, ia, ja, ar);\ns31:  glp_simplex(lp, NULL);\ns32:  z = glp_get_obj_val(lp);\ns33:  x1 = glp_get_col_prim(lp, 1);\ns34:  x2 = glp_get_col_prim(lp, 2);\ns35:  x3 = glp_get_col_prim(lp, 3);\ns36:  printf(\"\\nz = %g; x1 = %g; x2 = %g; x3 = %g\\n\",\n         z, x1, x2, x3);\ns37:  glp_delete_prob(lp);\n      return 0;\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/spxsamp1.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "int main(void)\n{     glp_prob *P;\n      P = glp_create_prob();\n      glp_read_mps(P, GLP_MPS_DECK, NULL, \"25fv47.mps\");\n      glp_adv_basis(P, 0);\n      glp_simplex(P, NULL);\n      glp_print_sol(P, \"25fv47.txt\");\n      glp_delete_prob(P);\n      return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/spxsamp2.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        17,
        1
      ],
      "content": "int main(void)\n{     glp_prob *P;\n      glp_smcp parm;\n      P = glp_create_prob();\n      glp_read_mps(P, GLP_MPS_DECK, NULL, \"25fv47.mps\");\n      glp_init_smcp(&parm);\n      parm.meth = GLP_DUAL;\n      glp_simplex(P, &parm);\n      glp_print_sol(P, \"25fv47.txt\");\n      glp_delete_prob(P);\n      return 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/cplex/cplex.c": {
    "findintparam": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int findintparam(int whichparam)\n{     int k, card;\n      card = sizeof(intparam) / sizeof(struct intparam);\n      for (k = 0; k < card; k++)\n         if (intparam[k].which == whichparam) return k;\n      return -1;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getintparam": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static int getintparam(CPXENV *env, int whichparam)\n{     int k;\n      xassert(env != NULL);\n      k = findintparam(whichparam);\n      xassert(k >= 0);\n      return env->intparam[k];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "finddblparam": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static int finddblparam(int whichparam)\n{     int k, card;\n      card = sizeof(dblparam) / sizeof(struct dblparam);\n      for (k = 0; k < card; k++)\n         if (dblparam[k].which == whichparam) return k;\n      return -1;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdblparam": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static double getdblparam(CPXENV *env, int whichparam)\n{     int k;\n      xassert(env != NULL);\n      k = finddblparam(whichparam);\n      xassert(k >= 0);\n      return env->dblparam[k];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "finderrstring": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static const char *finderrstring(int errcode)\n{     int k, card;\n      card = sizeof(errstring) / sizeof(struct errstring);\n      for (k = 0; k < card; k++)\n      {  if (errstring[k].code == errcode)\n            return errstring[k].string;\n      }\n      return NULL;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*finderrstring(int errcode)",
        "*"
      ]
    },
    "error": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "static int error(CPXENV *env, int errcode, ...)\n{     va_list arg;\n      char buffer[510];\n      xassert(env != NULL);\n      if (getintparam(env, CPX_PARAM_SCRIND) == CPX_ON)\n      {  xassert(CPXgeterrorstring(env, errcode, buffer) == buffer);\n         va_start(arg, errcode);\n         vprintf(buffer, arg);\n         va_end(arg);\n      }\n      return errcode;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "checkenv": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static int checkenv(CPXENV *env)\n{     int errcode;\n      if (env == NULL)\n         errcode = CPXERR_NO_ENVIRONMENT;\n      else\n         errcode = 0;\n      return errcode;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "invalidate": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static void invalidate(CPXLP *lp)\n{     lp->stat = 0;\n      lp->meth = CPX_ALG_NONE;\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "enlargerflag": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static void enlargerflag(CPXLP *lp)\n{     int m;\n      xassert(lp != NULL);\n      m = glp_get_num_rows(lp->prob);\n      if (lp->rflen < m)\n      {  int rflen = lp->rflen;\n         char *rflag = lp->rflag;\n         while (lp->rflen < m)\n         {  lp->rflen += lp->rflen;\n            xassert(lp->rflen > 0);\n         }\n         lp->rflag = xcalloc(lp->rflen, sizeof(char));\n         memcpy(lp->rflag, rflag, rflen);\n         xfree(rflag);\n      }\n      return;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "enlargeiwork": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static void enlargeiwork(CPXLP *lp, int len)\n{     xassert(len >= 0);\n      if (lp->iwlen < len)\n      {  xfree(lp->iwork);\n         while (lp->iwlen < len)\n         {  lp->iwlen += lp->iwlen;\n            xassert(lp->iwlen > 0);\n         }\n         lp->iwork = xcalloc(lp->iwlen, sizeof(int));\n         memset(lp->iwork, 0, lp->iwlen * sizeof(int));\n      }\n      return;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "CPXaddcols": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "int CPXaddcols(CPXENV *env, CPXLP *lp, int ccnt, int nzcnt,\n      const double obj[], const int cmatbeg[], const int cmatind[],\n      const double cmatval[], const double lb[], const double ub[],\n      char *colname[])\n{     int j, k, m, n, beg, end, type, errcode;\n      double lbnd, ubnd;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (ccnt < 0 || nzcnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (ccnt > 0)\n      {  if (cmatbeg == NULL || cmatind == NULL || cmatval == NULL)\n         {  errcode = error(env, CPXERR_NULL_POINTER);\n            goto done;\n         }\n      }\n      m = glp_get_num_rows(lp->prob);\n      n = glp_get_num_cols(lp->prob);\n      enlargeiwork(lp, m);\n      for (j = 0; j < ccnt; j++)\n      {  beg = cmatbeg[j];\n         if (j > 0 && !(cmatbeg[j-1] <= beg))\n         {  errcode = error(env, CPXERR_ARRAY_NOT_ASCENDING, j);\n            goto done;\n         }\n         if (!(0 <= beg && beg <= nzcnt))\n         {  errcode = error(env, CPXERR_INDEX_RANGE);\n            goto done;\n         }\n         end = (j < ccnt-1 ? cmatbeg[j+1] : nzcnt);\n         for (k = beg; k < end; k++)\n         {  if (!(0 <= cmatind[k] && cmatind[k] < m))\n            {  errcode = error(env, CPXERR_ROW_INDEX_RANGE, k);\n               goto done;\n            }\n         }\n         errcode = 0;\n         for (k = beg; k < end; k++)\n         {  if (lp->iwork[cmatind[k]])\n            {  errcode = error(env, CPXERR_DUP_ENTRY);\n               break;\n            }\n            lp->iwork[cmatind[k]] = 1;\n         }\n         for (k = beg; k < end; k++)\n            lp->iwork[cmatind[k]] = 0;\n         if (errcode) goto done;\n         if (colname != NULL)\n         {  if (colname[j] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, j);\n               goto done;\n            }\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      if (ccnt > 0)\n         glp_add_cols(lp->prob, ccnt);\n      for (j = 0; j < ccnt; j++)\n      {  if (colname != NULL)\n            glp_set_col_name(lp->prob, n+j+1, colname[j]);\n         lbnd = (lb == NULL ? 0.0 : lb[j]);\n         ubnd = (ub == NULL ? +CPX_INFBOUND : ub[j]);\n         if (lbnd <= -CPX_INFBOUND && ubnd >= +CPX_INFBOUND)\n            type = GLP_FR;\n         else if (ubnd >= +CPX_INFBOUND)\n            type = GLP_LO;\n         else if (lbnd <= -CPX_INFBOUND)\n            type = GLP_UP;\n         else if (lbnd != ubnd)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(lp->prob, n+j+1, type, lbnd, ubnd);\n         if (obj != NULL)\n            glp_set_obj_coef(lp->prob, n+j+1, obj[j]);\n         beg = cmatbeg[j];\n         end = (j < ccnt-1 ? cmatbeg[j+1] : nzcnt);\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = cmatind[k]+1;\n         glp_set_mat_col(lp->prob, n+j+1, end-beg, lp->iwork-1,\n            cmatval+beg-1);\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = 0;\n      }\ndone: return errcode;\n}",
      "lines": 89,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "CPXaddrows": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "int CPXaddrows(CPXENV *env, CPXLP *lp, int ccnt, int rcnt, int nzcnt,\n      const double rhs[], const char sense[], const int rmatbeg[],\n      const int rmatind[], const double rmatval[], char *colname[],\n      char *rowname[])\n{     int i, j, k, m, n, beg, end, type, errcode;\n      double temp;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (ccnt < 0 || rcnt < 0 || nzcnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (rcnt > 0)\n      {  if (rmatbeg == NULL || rmatind == NULL || rmatval == NULL)\n         {  errcode = error(env, CPXERR_NULL_POINTER);\n            goto done;\n         }\n      }\n      m = glp_get_num_rows(lp->prob);\n      n = glp_get_num_cols(lp->prob);\n      enlargeiwork(lp, n+ccnt);\n      for (i = 0; i < rcnt; i++)\n      {  if (sense != NULL)\n         {  if (!(sense[i] == 'L' || sense[i] == 'E' ||\n                  sense[i] == 'G' || sense[i] == 'R'))\n            {  errcode = error(env, CPXERR_BAD_SENSE, i);\n               goto done;\n            }\n         }\n         beg = rmatbeg[i];\n         if (i > 0 && !(rmatbeg[i-1] <= beg))\n         {  errcode = error(env, CPXERR_ARRAY_NOT_ASCENDING, i);\n            goto done;\n         }\n         if (!(0 <= beg && beg <= nzcnt))\n         {  errcode = error(env, CPXERR_INDEX_RANGE);\n            goto done;\n         }\n         end = (i < rcnt-1 ? rmatbeg[i+1] : nzcnt);\n         for (k = beg; k < end; k++)\n         {  if (!(0 <= rmatind[k] && rmatind[k] < n+ccnt))\n            {  errcode = error(env, CPXERR_COL_INDEX_RANGE, k);\n               goto done;\n            }\n         }\n         errcode = 0;\n         for (k = beg; k < end; k++)\n         {  if (lp->iwork[rmatind[k]])\n            {  errcode = error(env, CPXERR_DUP_ENTRY);\n               break;\n            }\n            lp->iwork[rmatind[k]] = 1;\n         }\n         for (k = beg; k < end; k++)\n            lp->iwork[rmatind[k]] = 0;\n         if (errcode) goto done;\n         if (rowname != NULL)\n         {  if (rowname[i] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, i);\n               goto done;\n            }\n         }\n      }\n      for (j = 0; j < ccnt; j++)\n      {  if (colname != NULL)\n         {  if (colname[j] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, j);\n               goto done;\n            }\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      if (rcnt > 0)\n         glp_add_rows(lp->prob, rcnt);\n      if (ccnt > 0)\n         glp_add_cols(lp->prob, ccnt);\n      enlargerflag(lp);\n      for (i = 0; i < rcnt; i++)\n      {  if (rowname != NULL)\n            glp_set_row_name(lp->prob, m+i+1, rowname[i]);\n         temp = (rhs == NULL ? 0.0 : rhs[i]);\n         if (sense == NULL || sense[i] == 'E')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_FX;\n         }\n         else if (sense[i] == 'L')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_UP;\n         }\n         else if (sense[i] == 'G')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_LO;\n         }\n         else if (sense[i] == 'R')\n         {  lp->rflag[m+i] = RF_RANGED_POS;\n            type = GLP_FX;\n         }\n         else\n            xassert(sense != sense);\n         glp_set_row_bnds(lp->prob, m+i+1, type, temp, temp);\n         beg = rmatbeg[i];\n         end = (i < rcnt-1 ? rmatbeg[i+1] : nzcnt);\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = rmatind[k]+1;\n         glp_set_mat_row(lp->prob, m+i+1, end-beg, lp->iwork-1,\n            rmatval+beg-1);\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = 0;\n      }\n      for (j = 0; j < ccnt; j++)\n      {  if (colname != NULL)\n            glp_set_col_name(lp->prob, n+j+1, colname[j]);\n         glp_set_col_bnds(lp->prob, n+j+1, GLP_LO, 0.0, 0.0);\n      }\ndone: return errcode;\n}",
      "lines": 117,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "CPXbaropt": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "int CPXbaropt(CPXENV *env, CPXLP *lp)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xprintf(\"CPXbaropt: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXbinvrow": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "int CPXbinvrow(CPXENV *env, CPXLP *lp, int i, double y[])\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(i == i);\n      xassert(y == y);\n      xprintf(\"CPXbinvrow: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXchgbds": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "int CPXchgbds(CPXENV *env, CPXLP *lp, int cnt, const int indices[],\n      const char lu[], const double bd[])\n{     int j, n, type, errcode;\n      double lbnd, ubnd;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (cnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (cnt > 0)\n      {  if (indices == NULL || lu == NULL || bd == NULL)\n         {  errcode = error(env, CPXERR_NULL_POINTER);\n            goto done;\n         }\n      }\n      n = glp_get_num_cols(lp->prob);\n      for (j = 0; j < cnt; j++)\n      {  if (!(0 <= indices[j] && indices[j] < n))\n         {  errcode = error(env, CPXERR_COL_INDEX_RANGE, j);\n            goto done;\n         }\n         if (!(lu[j] == 'L' || lu[j] == 'U' || lu[j] == 'B'))\n         {  errcode = error(env, CPXERR_BAD_LUB, j);\n            goto done;\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      for (j = 0; j < cnt; j++)\n      {  type = glp_get_col_type(lp->prob, indices[j]+1);\n         lbnd = glp_get_col_lb(lp->prob, indices[j]+1);\n         ubnd = glp_get_col_ub(lp->prob, indices[j]+1);\n         if (type == GLP_FR || type == GLP_UP)\n            lbnd = -CPX_INFBOUND;\n         if (type == GLP_FR || type == GLP_LO)\n            ubnd = +CPX_INFBOUND;\n         if (lu[j] == 'L')\n            lbnd = bd[j];\n         else if (lu[j] == 'U')\n            ubnd = bd[j];\n         else if (lu[j] == 'B')\n            lbnd = ubnd = bd[j];\n         else\n            xassert(lu != lu);\n         if (lbnd <= -CPX_INFBOUND && ubnd >= +CPX_INFBOUND)\n            type = GLP_FR;\n         else if (ubnd >= +CPX_INFBOUND)\n            type = GLP_LO;\n         else if (lbnd <= -CPX_INFBOUND)\n            type = GLP_UP;\n         else if (lbnd != ubnd)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(lp->prob, indices[j]+1, type, lbnd, ubnd);\n      }\ndone: return errcode;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXchgcoeflist": {
      "start_point": [
        555,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "int CPXchgcoeflist(CPXENV *env, CPXLP *lp, int numcoefs,\n      const int rowlist[], const int collist[], const double vallist[])\n{     int i, j, k, m, n, rcnt, ccnt, len, ptr, errcode;\n      int *head, *next, *ind;\n      double *val;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (numcoefs < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (numcoefs == 0)\n      {  errcode = 0;\n         goto done;\n      }\n      if (rowlist == NULL || collist == NULL || vallist == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      /* check triplets and determine the number of rows and columns\n         to be changed */\n      m = glp_get_num_rows(lp->prob);\n      n = glp_get_num_cols(lp->prob);\n      enlargeiwork(lp, m);\n      enlargeiwork(lp, n);\n      rcnt = ccnt = 0;\n      for (k = 0; k < numcoefs; k++)\n      {  i = rowlist[k];\n         if (!(0 <= i && i < m))\n         {  errcode = error(env, CPXERR_ROW_INDEX_RANGE, i);\n            goto done;\n         }\n         if (!(lp->iwork[i] & 0x01))\n            rcnt++, lp->iwork[i] |= 0x01;\n         j = collist[k];\n         if (!(0 <= j && j < n))\n         {  errcode = error(env, CPXERR_COL_INDEX_RANGE, j);\n            goto done;\n         }\n         if (!(lp->iwork[j] & 0x02))\n            ccnt++, lp->iwork[j] |= 0x02;\n      }\n      memset(lp->iwork, 0, m * sizeof(int));\n      memset(lp->iwork, 0, n * sizeof(int));\n      errcode = 0;\n      invalidate(lp);\n      if (rcnt <= ccnt)\n      {  /* change the matrix by rows */\n         /* build the linked list of triplets:\n            head[i] is a pointer to first triplet for row i\n            next[k] is a pointer to next triplet for the same row */\n         head = xcalloc(m, sizeof(int));\n         for (i = 0; i < m; i++)\n            head[i] = -1;\n         next = xcalloc(numcoefs, sizeof(int));\n         for (k = 0; k < numcoefs; k++)\n         {  i = rowlist[k];\n            next[k] = head[i];\n            head[i] = k;\n         }\n         /* check duplicate columns */\n         for (i = 0; i < m; i++)\n         {  for (k = head[i]; k >= 0; k = next[k])\n            {  j = collist[k];\n               if (lp->iwork[j])\n               {  xfree(head);\n                  xfree(next);\n                  errcode = error(env, CPXERR_DUP_ENTRY);\n                  goto done;\n               }\n               lp->iwork[j] = 1;\n            }\n            for (k = head[i]; k >= 0; k = next[k])\n               lp->iwork[collist[k]] = 0;\n         }\n         /* perform operation */\n         ind = xcalloc(1+n, sizeof(int));\n         val = xcalloc(1+n, sizeof(double));\n         for (i = 0; i < m; i++)\n         {  if (head[i] < 0) continue;\n            len = glp_get_mat_row(lp->prob, i+1, ind, val);\n            for (ptr = 1; ptr <= len; ptr++)\n            {  j = ind[ptr]-1;\n               xassert(lp->iwork[j] == 0);\n               lp->iwork[j] = ptr;\n            }\n            for (k = head[i]; k >= 0; k = next[k])\n            {  j = collist[k];\n               if (lp->iwork[j] == 0)\n                  lp->iwork[j] = ++len;\n               ptr = lp->iwork[j];\n               ind[ptr] = j+1, val[ptr] = vallist[k];\n            }\n            glp_set_mat_row(lp->prob, i+1, len, ind, val);\n            for (ptr = 1; ptr <= len; ptr++)\n               lp->iwork[ind[ptr]-1] = 0;\n         }\n      }\n      else\n      {  /* change the matrix by columns */\n         /* build the linked lists of triplets:\n            head[j] is a pointer to first triplet for column j\n            next[k] is a pointer to next triplet for the same column */\n         head = xcalloc(n, sizeof(int));\n         for (j = 0; j < n; j++)\n            head[j] = -1;\n         next = xcalloc(numcoefs, sizeof(int));\n         for (k = 0; k < numcoefs; k++)\n         {  j = collist[k];\n            next[k] = head[j];\n            head[j] = k;\n         }\n         /* check duplicate rows */\n         for (j = 0; j < n; j++)\n         {  for (k = head[j]; k >= 0; k = next[k])\n            {  i = rowlist[k];\n               if (lp->iwork[i])\n               {  xfree(head);\n                  xfree(next);\n                  errcode = error(env, CPXERR_DUP_ENTRY);\n                  goto done;\n               }\n               lp->iwork[i] = 1;\n            }\n            for (k = head[j]; k >= 0; k = next[k])\n               lp->iwork[rowlist[k]] = 0;\n         }\n         /* perform operation */\n         ind = xcalloc(1+m, sizeof(int));\n         val = xcalloc(1+m, sizeof(double));\n         for (j = 0; j < n; j++)\n         {  if (head[j] < 0) continue;\n            len = glp_get_mat_col(lp->prob, j+1, ind, val);\n            for (ptr = 1; ptr <= len; ptr++)\n            {  i = ind[ptr]-1;\n               xassert(lp->iwork[i] == 0);\n               lp->iwork[i] = ptr;\n            }\n            for (k = head[j]; k >= 0; k = next[k])\n            {  i = rowlist[k];\n               if (lp->iwork[i] == 0)\n                  lp->iwork[i] = ++len;\n               ptr = lp->iwork[i];\n               ind[ptr] = i+1, val[ptr] = vallist[k];\n            }\n            glp_set_mat_col(lp->prob, j+1, len, ind, val);\n            for (ptr = 1; ptr <= len; ptr++)\n               lp->iwork[ind[ptr]-1] = 0;\n         }\n      }\n      xfree(head);\n      xfree(next);\n      xfree(ind);\n      xfree(val);\ndone: return errcode;\n}",
      "lines": 156,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "CPXchgobjsen": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        728,
        1
      ],
      "content": "void CPXchgobjsen(CPXENV *env, CPXLP *lp, int maxormin)\n{     int errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (!(maxormin == CPX_MIN || maxormin == CPX_MAX))\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      errcode = 0;\n      invalidate(lp);\n      if (maxormin == CPX_MIN)\n         glp_set_obj_dir(lp->prob, GLP_MIN);\n      else\n         glp_set_obj_dir(lp->prob, GLP_MAX);\ndone: xassert(errcode == errcode);\n      return;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "CPXchgsense": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "int CPXchgsense(CPXENV *env, CPXLP *lp, int cnt, const int indices[],\n      const char sense[])\n{     int i, m, type, errcode;\n      double rhs;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (cnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (cnt > 0 && (indices == NULL || sense == NULL))\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      m = glp_get_num_rows(lp->prob);\n      for (i = 0; i < cnt; i++)\n      {  if (!(0 <= indices[i] && indices[i] < m))\n         {  errcode = error(env, CPXERR_ROW_INDEX_RANGE, i);\n            goto done;\n         }\n         if (!(sense[i] == 'L' || sense[i] == 'E' || sense[i] == 'G' ||\n               sense[i] == 'R'))\n         {  errcode = error(env, CPXERR_BAD_SENSE, i);\n            goto done;\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      for (i = 0; i < cnt; i++)\n      {  type = glp_get_row_type(lp->prob, indices[i]+1);\n         if (lp->rflag[indices[i]] == RF_NOT_RANGED)\n         {  if (type == GLP_LO || type == GLP_FX)\n               rhs = glp_get_row_lb(lp->prob, indices[i]+1);\n            else if (type == GLP_UP)\n               rhs = glp_get_row_ub(lp->prob, indices[i]+1);\n            else\n               xassert(type != type);\n         }\n         else if (lp->rflag[indices[i]] == RF_RANGED_POS)\n         {  xassert(type == GLP_DB || type == GLP_FX);\n            rhs = glp_get_row_lb(lp->prob, indices[i]+1);\n         }\n         else if (lp->rflag[indices[i]] == RF_RANGED_NEG)\n         {  xassert(type == GLP_DB);\n            rhs = glp_get_row_ub(lp->prob, indices[i]+1);\n         }\n         else\n            xassert(lp != lp);\n         if (sense[i] == 'L')\n         {  lp->rflag[indices[i]] = RF_NOT_RANGED;\n            type = GLP_UP;\n         }\n         else if (sense[i] == 'E')\n         {  lp->rflag[indices[i]] = RF_NOT_RANGED;\n            type = GLP_FX;\n         }\n         else if (sense[i] == 'G')\n         {  lp->rflag[indices[i]] = RF_NOT_RANGED;\n            type = GLP_LO;\n         }\n         else if (sense[i] == 'R')\n         {  lp->rflag[indices[i]] = RF_RANGED_POS;\n            type = GLP_FX;\n         }\n         else\n            xassert(sense != sense);\n         glp_set_row_bnds(lp->prob, indices[i]+1, type, rhs, rhs);\n      }\ndone: return errcode;\n}",
      "lines": 70,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "CPXcloseCPLEX": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "int CPXcloseCPLEX(CPXENV **_env)\n{     CPXENV *env;\n      CPXLP *lp;\n      int errcode;\n      if (_env == NULL)\n      {  errcode = CPXERR_NULL_POINTER;\n         goto done;\n      }\n      env = *_env;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      while (env->list != NULL)\n      {  lp = env->list;\n         errcode = CPXfreeprob(env, &lp);\n         xassert(!errcode);\n      }\n      xfree(env->intparam);\n      xfree(env->dblparam);\n      xfree(env);\n      *_env = NULL;\n      errcode = 0;\ndone: return errcode;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "CPXcopybase": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "int CPXcopybase(CPXENV *env, CPXLP *lp, const int cstat[],\n      const int rstat[])\n{     int i, j, m, n, stat, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      m = glp_get_num_rows(lp->prob);\n      n = glp_get_num_cols(lp->prob);\n      if (m > 0 && rstat == NULL || n > 0 && cstat == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      for (i = 0; i < m; i++)\n      {  if (!(rstat[i] == CPX_AT_LOWER || rstat[i] == CPX_BASIC ||\n               rstat[i] == CPX_AT_UPPER))\n         {  errcode = error(env, CPXERR_BAD_STATUS, i);\n            goto done;\n         }\n      }\n      for (j = 0; j < n; j++)\n      {  if (!(cstat[j] == CPX_AT_LOWER || cstat[j] == CPX_BASIC ||\n               cstat[j] == CPX_AT_UPPER || cstat[j] == CPX_FREE_SUPER))\n         {  errcode = error(env, CPXERR_BAD_STATUS, j);\n            goto done;\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      for (i = 0; i < m; i++)\n      {  if (rstat[i] == CPX_AT_LOWER)\n            stat = GLP_NL;\n         else if (rstat[i] == CPX_BASIC)\n            stat = GLP_BS;\n         else if (rstat[i] == CPX_AT_UPPER)\n            stat = GLP_NU;\n         else\n            xassert(rstat != rstat);\n         glp_set_row_stat(lp->prob, i+1, stat);\n      }\n      for (j = 0; j < n; j++)\n      {  if (cstat[j] == CPX_AT_LOWER)\n            stat = GLP_NL;\n         else if (cstat[j] == CPX_BASIC)\n            stat = GLP_BS;\n         else if (cstat[j] == CPX_AT_UPPER)\n            stat = GLP_NU;\n         else if (cstat[j] == CPX_FREE_SUPER)\n            stat = GLP_NF;\n         else\n            xassert(cstat != cstat);\n         glp_set_col_stat(lp->prob, j+1, stat);\n      }\ndone: return errcode;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "CPXcopybasednorms": {
      "start_point": [
        879,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "int CPXcopybasednorms(CPXENV *env, CPXLP *lp, const int cstat[],\n      const int rstat[], const double dnorm[])\n{     int errcode;\n      errcode = CPXcopybase(env, lp, cstat, rstat);\n      xassert(dnorm == dnorm);\n      return errcode;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXcopylp": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        897,
        1
      ],
      "content": "int CPXcopylp(CPXENV *env, CPXLP *lp, int numcols, int numrows,\n      int objsen, const double obj[], const double rhs[],\n      const char sense[], const int matbeg[], const int matcnt[],\n      const int matind[], const double matval[], const double lb[],\n      const double ub[], const double rngval[])\n{     int errcode;\n      errcode = CPXcopylpwnames(env, lp, numcols, numrows, objsen, obj,\n         rhs, sense, matbeg, matcnt, matind, matval, lb, ub, rngval,\n         NULL, NULL);\n      return errcode;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXcopylpwnames": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        1063,
        1
      ],
      "content": "int CPXcopylpwnames(CPXENV *env, CPXLP *lp, int numcols, int numrows,\n      int objsen, const double obj[], const double rhs[],\n      const char sense[], const int matbeg[], const int matcnt[],\n      const int matind[], const double matval[], const double lb[],\n      const double ub[], const double rngval[], char *colname[],\n      char *rowname[])\n{     int i, j, k, beg, end, type, errcode;\n      double lbnd, ubnd;\n      char name[255+1];\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (numcols < 0 || numrows < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (!(objsen == CPX_MIN || objsen == CPX_MAX))\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (numcols > 0)\n      {  if (matbeg == NULL || matcnt == NULL || matind == NULL ||\n               matval == NULL)\n         {  errcode = error(env, CPXERR_NULL_POINTER);\n            goto done;\n         }\n      }\n      for (i = 0; i < numrows; i++)\n      {  if (sense != NULL)\n         {  if (!(sense[i] == 'L' || sense[i] == 'E' ||\n                  sense[i] == 'G' || sense[i] == 'R'))\n            {  errcode = error(env, CPXERR_BAD_SENSE, i);\n               goto done;\n            }\n         }\n         if (rowname != NULL)\n         {  if (rowname[i] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, i);\n               goto done;\n            }\n         }\n      }\n      enlargeiwork(lp, numrows);\n      for (j = 0; j < numcols; j++)\n      {  beg = matbeg[j];\n         if (j > 0 && !(matbeg[j-1] <= beg))\n         {  errcode = error(env, CPXERR_ARRAY_NOT_ASCENDING, j);\n            goto done;\n         }\n         if (beg < 0)\n         {  errcode = error(env, CPXERR_INDEX_RANGE);\n            goto done;\n         }\n         end = beg + matcnt[j];\n         if (!(beg <= end) || j < numcols-1 && !(end <= matbeg[j+1]))\n         {  errcode = error(env, CPXERR_COUNT_RANGE, j);\n            goto done;\n         }\n         for (k = beg; k < end; k++)\n         {  if (!(0 <= matind[k] && matind[k] < numrows))\n            {  errcode = error(env, CPXERR_ROW_INDEX_RANGE, k);\n               goto done;\n            }\n         }\n         errcode = 0;\n         for (k = beg; k < end; k++)\n         {  if (lp->iwork[matind[k]])\n            {  errcode = error(env, CPXERR_DUP_ENTRY);\n               break;\n            }\n            lp->iwork[matind[k]] = 1;\n         }\n         for (k = beg; k < end; k++)\n            lp->iwork[matind[k]] = 0;\n         if (errcode) goto done;\n         if (colname != NULL)\n         {  if (colname[j] != NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, j);\n               goto done;\n            }\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      if (glp_get_prob_name(lp->prob) == NULL)\n         name[0] = '\\0';\n      else\n         strcpy(name, glp_get_prob_name(lp->prob));\n      glp_erase_prob(lp->prob);\n      glp_set_prob_name(lp->prob, name);\n      if (objsen == CPX_MIN)\n         glp_set_obj_dir(lp->prob, GLP_MIN);\n      else if (objsen == CPX_MAX)\n         glp_set_obj_dir(lp->prob, GLP_MAX);\n      else\n         xassert(objsen != objsen);\n      if (numrows > 0)\n         glp_add_rows(lp->prob, numrows);\n      enlargerflag(lp);\n      for (i = 0; i < numrows; i++)\n      {  if (rowname != NULL)\n            glp_set_row_name(lp->prob, i+1, rowname[i]);\n         lbnd = ubnd = (rhs == NULL ? 0.0 : rhs[i]);\n         if (sense == NULL || sense[i] == 'E')\n         {  lp->rflag[i] = RF_NOT_RANGED;\n            type = GLP_FX;\n         }\n         else if (sense[i] == 'L')\n         {  lp->rflag[i] = RF_NOT_RANGED;\n            type = GLP_UP;\n         }\n         else if (sense[i] == 'G')\n         {  lp->rflag[i] = RF_NOT_RANGED;\n            type = GLP_LO;\n         }\n         else if (sense[i] == 'R')\n         {  if (rngval == NULL || rngval[i] == 0.0)\n            {  lp->rflag[i] = RF_RANGED_POS;\n               type = GLP_FX;\n            }\n            else if (rngval[i] > 0.0)\n            {  lp->rflag[i] = RF_RANGED_POS;\n               type = GLP_DB;\n               ubnd += rngval[i];\n            }\n            else /* rngval[i] < 0.0 */\n            {  lp->rflag[i] = RF_RANGED_NEG;\n               type = GLP_DB;\n               lbnd += rngval[i];\n            }\n         }\n         else\n            xassert(sense != sense);\n         glp_set_row_bnds(lp->prob, i+1, type, lbnd, ubnd);\n      }\n      if (numcols > 0)\n         glp_add_cols(lp->prob, numcols);\n      for (j = 0; j < numcols; j++)\n      {  if (colname != NULL)\n            glp_set_col_name(lp->prob, j+1, colname[j]);\n         lbnd = (lb == NULL ? 0.0 : lb[j]);\n         ubnd = (ub == NULL ? +CPX_INFBOUND : ub[j]);\n         if (lbnd <= -CPX_INFBOUND && ubnd >= +CPX_INFBOUND)\n            type = GLP_FR;\n         else if (ubnd >= +CPX_INFBOUND)\n            type = GLP_LO;\n         else if (lbnd <= -CPX_INFBOUND)\n            type = GLP_UP;\n         else if (lbnd != ubnd)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(lp->prob, j+1, type, lbnd, ubnd);\n         if (obj != NULL)\n            glp_set_obj_coef(lp->prob, j+1, obj[j]);\n         beg = matbeg[j];\n         end = beg + matcnt[j];\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = matind[k]+1;\n         glp_set_mat_col(lp->prob, j+1, end-beg, lp->iwork-1,\n            matval+beg-1);\n         for (k = beg; k < end; k++)\n            lp->iwork[k-beg] = 0;\n      }\ndone: return errcode;\n}",
      "lines": 165,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "CPXcreateprob": {
      "start_point": [
        1065,
        0
      ],
      "end_point": [
        1084,
        1
      ],
      "content": "CPXLP *CPXcreateprob(CPXENV *env, int *status, const char *probname)\n{     CPXLP *lp = NULL;\n      int errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      lp = xmalloc(sizeof(struct CPXLP));\n      lp->env = env;\n      lp->prob = glp_create_prob();\n      glp_set_prob_name(lp->prob, probname);\n      lp->rflen = 100;\n      lp->rflag = xcalloc(lp->rflen, sizeof(char));\n      lp->iwlen = 100;\n      lp->iwork = xcalloc(lp->iwlen, sizeof(int));\n      memset(lp->iwork, 0, lp->iwlen * sizeof(int));\n      lp->link = env->list;\n      env->list = lp;\n      invalidate(lp);\ndone: if (status != NULL) *status = errcode;\n      return lp;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "CPXLP",
        "*CPXcreateprob(CPXENV *env, int *status, const char *probname)",
        "*"
      ]
    },
    "CPXdelcols": {
      "start_point": [
        1086,
        0
      ],
      "end_point": [
        1104,
        1
      ],
      "content": "int CPXdelcols(CPXENV *env, CPXLP *lp, int begin, int end)\n{     int j, n, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      n = glp_get_num_cols(lp->prob);\n      if (!(0 <= begin && begin <= end && end < n))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      errcode = 0;\n      invalidate(lp);\n      enlargeiwork(lp, end-begin+1);\n      for (j = begin; j <= end; j++)\n         lp->iwork[j-begin] = j+1;\n      glp_del_cols(lp->prob, end-begin+1, lp->iwork-1);\n      for (j = begin; j <= end; j++)\n         lp->iwork[j-begin] = 0;\ndone: return errcode;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "CPXdelrows": {
      "start_point": [
        1106,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "int CPXdelrows(CPXENV *env, CPXLP *lp, int begin, int end)\n{     int i, m, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      m = glp_get_num_rows(lp->prob);\n      if (!(0 <= begin && begin <= end && end < m))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      errcode = 0;\n      invalidate(lp);\n      enlargeiwork(lp, end-begin+1);\n      for (i = begin; i <= end; i++)\n         lp->iwork[i-begin] = i+1;\n      glp_del_rows(lp->prob, end-begin+1, lp->iwork-1);\n      for (i = begin; i <= end; i++)\n         lp->iwork[i-begin] = 0;\n      for (i = end+1; i < m; i++)\n         lp->rflag[i-(end-begin+1)] = lp->rflag[i];\ndone: return errcode;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "CPXdelsetcols": {
      "start_point": [
        1128,
        0
      ],
      "end_point": [
        1135,
        1
      ],
      "content": "int CPXdelsetcols(CPXENV *env, CPXLP *lp, int delstat[])\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(delstat == delstat);\n      xprintf(\"CPXdelsetcols: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXdelsetrows": {
      "start_point": [
        1137,
        0
      ],
      "end_point": [
        1165,
        1
      ],
      "content": "int CPXdelsetrows(CPXENV *env, CPXLP *lp, int delstat[])\n{     int i, m, cnt, ind, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      m = glp_get_num_rows(lp->prob);\n      if (m > 0 && delstat == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      errcode = 0;\n      invalidate(lp);\n      enlargeiwork(lp, m);\n      cnt = ind = 0;\n      for (i = 0; i < m; i++)\n      {  if (delstat[i] == 1)\n         {  delstat[i] = -1;\n            lp->iwork[cnt++] = i+1;\n         }\n         else\n         {  delstat[i] = ind;\n            lp->rflag[ind++] = lp->rflag[i];\n         }\n      }\n      if (cnt > 0)\n         glp_del_rows(lp->prob, cnt, lp->iwork-1);\n      for (i = 0; i < cnt; i++)\n         lp->iwork[i] = 0;\ndone: return errcode;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "CPXfreeprob": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1198,
        1
      ],
      "content": "int CPXfreeprob(CPXENV *env, CPXLP **_lp)\n{     CPXLP *lp;\n      int errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      if (_lp == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      lp = *_lp;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      errcode = 0;\n      env = lp->env;\n      if (env->list == lp)\n         env->list = lp->link;\n      else\n      {  CPXLP *pp;\n         for (pp = env->list; pp != NULL; pp = pp->link)\n            if (pp->link == lp) break;\n         xassert(pp != NULL);\n         pp->link = lp->link;\n      }\n      glp_delete_prob(lp->prob);\n      xfree(lp->rflag);\n      xfree(lp->iwork);\n      xfree(lp);\n      *_lp = NULL;\ndone: return errcode;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "CPXgetbase": {
      "start_point": [
        1200,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "int CPXgetbase(CPXENV *env, CPXLP *lp, int cstat[], int rstat[])\n{     int i, j, m, n, stat, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n         ;\n      else\n      {  errcode = error(env, CPXERR_NO_BASIC_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (rstat != NULL)\n      {  m = glp_get_num_rows(lp->prob);\n         for (i = 0; i < m; i++)\n         {  stat = glp_get_row_stat(lp->prob, i+1);\n            if (stat == GLP_BS)\n               rstat[i] = CPX_BASIC;\n            else if (lp->rflag[i] == RF_NOT_RANGED || stat != GLP_NU)\n               rstat[i] = CPX_AT_LOWER;\n            else\n               rstat[i] = CPX_AT_UPPER;\n         }\n      }\n      if (cstat != NULL)\n      {  n = glp_get_num_cols(lp->prob);\n         for (j = 0; j < n; j++)\n         {  stat = glp_get_col_stat(lp->prob, j+1);\n            if (stat == GLP_BS)\n               cstat[j] = CPX_BASIC;\n            else if (stat == GLP_NU)\n               cstat[j] = CPX_AT_UPPER;\n            else if (stat == GLP_NF)\n               cstat[j] = CPX_FREE_SUPER;\n            else\n               cstat[j] = CPX_AT_LOWER;\n         }\n      }\ndone: return errcode;\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "CPXgetbasednorms": {
      "start_point": [
        1244,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "int CPXgetbasednorms(CPXENV *env, CPXLP *lp, int cstat[], int rstat[],\n      double dnorm[])\n{     int i, m, errcode;\n      errcode = CPXgetbase(env, lp, cstat, rstat);\n      if (errcode) goto done;\n      if (dnorm != NULL)\n      {  m = glp_get_num_rows(lp->prob);\n         for (i = 0; i < m; i++) dnorm[i] = 1.0;\n      }\ndone: return errcode;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "CPXgetbhead": {
      "start_point": [
        1256,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "int CPXgetbhead(CPXENV *env, CPXLP *lp, int head[], double x[])\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(head == head);\n      xassert(x == x);\n      xprintf(\"CPXgetbhead: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetdblparam": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1279,
        1
      ],
      "content": "int CPXgetdblparam(CPXENV *env, int whichparam, double *value)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = finddblparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      errcode = 0;\n      if (value != NULL)\n         *value = env->dblparam[k];\ndone: return errcode;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXgetdj": {
      "start_point": [
        1281,
        0
      ],
      "end_point": [
        1304,
        1
      ],
      "content": "int CPXgetdj(CPXENV *env, CPXLP *lp, double dj[], int begin, int end)\n{     int j, n, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      n = glp_get_num_cols(lp->prob);\n      if (!(0 <= begin && begin <= end && end < n))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (dj != NULL)\n         {  for (j = begin; j <= end; j++)\n               dj[j-begin] = glp_get_col_dual(lp->prob, j+1);\n         }\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXgeterrorstring": {
      "start_point": [
        1306,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "char *CPXgeterrorstring(CPXENV *env, int errcode, char *buffer)\n{     const char *string;\n      xassert(env == env);\n      string = finderrstring(errcode);\n      if (string == NULL)\n         buffer = NULL;\n      else\n         sprintf(buffer, \"CPLEX Error %5d:  %s.\\n\", errcode, string);\n      return buffer;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "char",
        "*CPXgeterrorstring(CPXENV *env, int errcode, char *buffer)",
        "*"
      ]
    },
    "CPXgetijdiv": {
      "start_point": [
        1317,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "int CPXgetijdiv(CPXENV *env, CPXLP *lp, int *idiv, int *jdiv)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(idiv == idiv);\n      xassert(jdiv == jdiv);\n      xprintf(\"CPXgetijdiv: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetintparam": {
      "start_point": [
        1327,
        0
      ],
      "end_point": [
        1340,
        1
      ],
      "content": "int CPXgetintparam(CPXENV *env, int whichparam, int *value)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = findintparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      errcode = 0;\n      if (value != NULL)\n         *value = env->intparam[k];\ndone: return errcode;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXgetlb": {
      "start_point": [
        1342,
        0
      ],
      "end_point": [
        1351,
        1
      ],
      "content": "int CPXgetlb(CPXENV *env, CPXLP *lp, double lb[], int begin, int end)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(lb == lb);\n      xassert(begin == begin);\n      xassert(end == end);\n      xprintf(\"CPXgetlb: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetmethod": {
      "start_point": [
        1353,
        0
      ],
      "end_point": [
        1360,
        1
      ],
      "content": "int CPXgetmethod(CPXENV *env, CPXLP *lp)\n{     int method;\n      if (checklp(env, lp))\n         method = CPX_ALG_NONE;\n      else\n         method = lp->meth;\n      return method;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetnumcols": {
      "start_point": [
        1362,
        0
      ],
      "end_point": [
        1369,
        1
      ],
      "content": "int CPXgetnumcols(CPXENV *env, CPXLP *lp)\n{     int numcols;\n      if (checklp(env, lp))\n         numcols = 0;\n      else\n         numcols = glp_get_num_cols(lp->prob);\n      return numcols;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXgetnumnz": {
      "start_point": [
        1371,
        0
      ],
      "end_point": [
        1378,
        1
      ],
      "content": "int CPXgetnumnz(CPXENV *env, CPXLP *lp)\n{     int numnz;\n      if (checklp(env, lp))\n         numnz = 0;\n      else\n         numnz = glp_get_num_nz(lp->prob);\n      return numnz;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXgetnumrows": {
      "start_point": [
        1380,
        0
      ],
      "end_point": [
        1387,
        1
      ],
      "content": "int CPXgetnumrows(CPXENV *env, CPXLP *lp)\n{     int numrows;\n      if (checklp(env, lp))\n         numrows = 0;\n      else\n         numrows = glp_get_num_rows(lp->prob);\n      return numrows;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXgetobjval": {
      "start_point": [
        1389,
        0
      ],
      "end_point": [
        1405,
        1
      ],
      "content": "int CPXgetobjval(CPXENV *env, CPXLP *lp, double *objval)\n{     int errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (objval != NULL)\n            *objval = glp_get_obj_val(lp->prob);\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "CPXgetpi": {
      "start_point": [
        1407,
        0
      ],
      "end_point": [
        1430,
        1
      ],
      "content": "int CPXgetpi(CPXENV *env, CPXLP *lp, double pi[], int begin, int end)\n{     int i, m, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      m = glp_get_num_rows(lp->prob);\n      if (!(0 <= begin && begin <= end && end < m))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (pi != NULL)\n         {  for (i = begin; i <= end; i++)\n               pi[i-begin] = glp_get_row_dual(lp->prob, i+1);\n         }\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXgetsense": {
      "start_point": [
        1432,
        0
      ],
      "end_point": [
        1442,
        1
      ],
      "content": "int CPXgetsense(CPXENV *env, CPXLP *lp, char sense[], int begin,\n      int end)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(sense == sense);\n      xassert(begin == begin);\n      xassert(end == end);\n      xprintf(\"CPXgetsense: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetslack": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1493,
        1
      ],
      "content": "int CPXgetslack(CPXENV *env, CPXLP *lp, double slack[], int begin,\n      int end)\n{     int i, m, type, errcode;\n      double temp;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      m = glp_get_num_rows(lp->prob);\n      if (!(0 <= begin && begin <= end && end < m))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (slack != NULL)\n         {  for (i = begin; i <= end; i++)\n            {  type = glp_get_row_type(lp->prob, i+1);\n               temp = glp_get_row_prim(lp->prob, i+1);\n               if (lp->rflag[i] == RF_NOT_RANGED)\n               {  if (type == GLP_LO || type == GLP_FX)\n                     slack[i-begin] =\n                        glp_get_row_lb(lp->prob, i+1) - temp;\n                  else if (type == GLP_UP)\n                     slack[i-begin] =\n                        glp_get_row_ub(lp->prob, i+1) - temp;\n                  else\n                     xassert(type != type);\n               }\n               else if (lp->rflag[i] == RF_RANGED_POS)\n               {  xassert(type == GLP_DB || type == GLP_FX);\n                  slack[i-begin] =\n                     temp - glp_get_row_lb(lp->prob, i+1);\n               }\n               else if (lp->rflag[i] == RF_RANGED_NEG)\n               {  xassert(type == GLP_DB);\n                  slack[i-begin] =\n                     temp - glp_get_row_ub(lp->prob, i+1);\n               }\n               else\n                  xassert(lp != lp);\n            }\n         }\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 50,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "CPXgetstat": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "int CPXgetstat(CPXENV *env, CPXLP *lp)\n{     int stat;\n      if (checklp(env, lp))\n         stat = 0;\n      else\n         stat = lp->stat;\n      return stat;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetub": {
      "start_point": [
        1504,
        0
      ],
      "end_point": [
        1513,
        1
      ],
      "content": "int CPXgetub(CPXENV *env, CPXLP *lp, double ub[], int begin, int end)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(ub == ub);\n      xassert(begin == begin);\n      xassert(end == end);\n      xprintf(\"CPXgetub: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetweight": {
      "start_point": [
        1515,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "int CPXgetweight(CPXENV *env, CPXLP *lp, int rcnt, const int rmatbeg[],\n      const int rmatind[], const double rmatval[], double weight[],\n      int dpriind)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(rcnt == rcnt);\n      xassert(rmatbeg == rmatbeg);\n      xassert(rmatind == rmatind);\n      xassert(rmatval == rmatval);\n      xassert(weight == weight);\n      xassert(dpriind == dpriind);\n      xprintf(\"CPXgetweight: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 15,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXgetx": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1554,
        1
      ],
      "content": "int CPXgetx(CPXENV *env, CPXLP *lp, double x[], int begin, int end)\n{     int j, n, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      n = glp_get_num_cols(lp->prob);\n      if (!(0 <= begin && begin <= end && end < n))\n      {  errcode = error(env, CPXERR_INDEX_RANGE);\n         goto done;\n      }\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (x != NULL)\n         {  for (j = begin; j <= end; j++)\n               x[j-begin] = glp_get_col_prim(lp->prob, j+1);\n         }\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXinfodblparam": {
      "start_point": [
        1556,
        0
      ],
      "end_point": [
        1574,
        1
      ],
      "content": "int CPXinfodblparam(CPXENV *env, int whichparam, double *defvalue,\n      double *minvalue, double *maxvalue)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = finddblparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      errcode = 0;\n      if (defvalue != NULL)\n         *defvalue = dblparam[k].defv;\n      if (minvalue != NULL)\n         *minvalue = dblparam[k].minv;\n      if (maxvalue != NULL)\n         *maxvalue = dblparam[k].maxv;\ndone: return errcode;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXinfointparam": {
      "start_point": [
        1576,
        0
      ],
      "end_point": [
        1594,
        1
      ],
      "content": "int CPXinfointparam(CPXENV *env, int whichparam, int *defvalue,\n      int *minvalue, int *maxvalue)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = findintparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      errcode = 0;\n      if (defvalue != NULL)\n         *defvalue = intparam[k].defv;\n      if (minvalue != NULL)\n         *minvalue = intparam[k].minv;\n      if (maxvalue != NULL)\n         *maxvalue = intparam[k].maxv;\ndone: return errcode;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXmdleave": {
      "start_point": [
        1596,
        0
      ],
      "end_point": [
        1609,
        1
      ],
      "content": "int CPXmdleave(const CPXENV *env, CPXLP *lp, const int goodlist[],\n      int goodlen, double downratio[], double upratio[])\n{     int k;\n      xassert(env == env);\n      xassert(lp == lp);\n      xassert(goodlist == goodlist);\n      xassert(goodlen >= 0);\n      xassert(downratio != NULL);\n      xassert(upratio != NULL);\n      /* not implemented yet */\n      for (k = 0; k < goodlen; k++)\n         downratio[k] = upratio[k] = 0.0;\n      return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "CPXnewcols": {
      "start_point": [
        1611,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "int CPXnewcols(CPXENV *env, CPXLP *lp, int ccnt, const double obj[],\n      const double lb[], const double ub[], const char ctype[],\n      char *colname[])\n{     int j, n, kind, type, errcode;\n      double lbnd, ubnd;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (ccnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      for (j = 0; j < ccnt; j++)\n      {  if (ctype != NULL)\n         {  if (!(ctype[j] == 'C' || ctype[j] == 'B' ||\n                  ctype[j] == 'I'))\n            {  errcode = error(env, CPXERR_BAD_CTYPE, j);\n               goto done;\n            }\n         }\n         if (colname != NULL)\n         {  if (colname[j] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, j);\n               goto done;\n            }\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      n = glp_get_num_cols(lp->prob);\n      if (ccnt > 0)\n         glp_add_cols(lp->prob, ccnt);\n      for (j = 0; j < ccnt; j++)\n      {  if (colname != NULL)\n            glp_set_col_name(lp->prob, n+j+1, colname[j]);\n         if (obj != NULL)\n            glp_set_obj_coef(lp->prob, n+j+1, obj[j]);\n         lbnd = (lb == NULL ? 0.0 : lb[j]);\n         ubnd = (ub == NULL ? 0.0 : ub[j]);\n         if (lbnd <= -CPX_INFBOUND && ubnd >= +CPX_INFBOUND)\n            type = GLP_FR;\n         else if (ubnd >= +CPX_INFBOUND)\n            type = GLP_LO;\n         else if (lbnd <= -CPX_INFBOUND)\n            type = GLP_UP;\n         else if (lbnd != ubnd)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(lp->prob, n+j+1, type, lbnd, ubnd);\n         if (ctype != NULL)\n         {  if (ctype[j] == 'C')\n               kind = GLP_CV;\n            else if (ctype[j] == 'B')\n               kind = GLP_BV;\n            else if (ctype[j] == 'I')\n               kind = GLP_IV;\n            else\n               xassert(ctype != ctype);\n            glp_set_col_kind(lp->prob, n+j+1, kind);\n         }\n      }\ndone: return errcode;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "CPXnewrows": {
      "start_point": [
        1675,
        0
      ],
      "end_point": [
        1743,
        1
      ],
      "content": "int CPXnewrows(CPXENV *env, CPXLP *lp, int rcnt, const double rhs[],\n      const char sense[], const double rngval[], char *rowname[])\n{     int i, m, type, errcode;\n      double lbnd, ubnd;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (rcnt < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      for (i = 0; i < rcnt; i++)\n      {  if (sense != NULL)\n         {  if (!(sense[i] == 'L' || sense[i] == 'E' ||\n                  sense[i] == 'G' || sense[i] == 'R'))\n            {  errcode = error(env, CPXERR_BAD_SENSE, i);\n               goto done;\n            }\n         }\n         if (rowname != NULL)\n         {  if (rowname[i] == NULL)\n            {  errcode = error(env, CPXERR_NULL_NAME, i);\n               goto done;\n            }\n         }\n      }\n      errcode = 0;\n      invalidate(lp);\n      m = glp_get_num_rows(lp->prob);\n      if (rcnt > 0)\n         glp_add_rows(lp->prob, rcnt);\n      enlargerflag(lp);\n      for (i = 0; i < rcnt; i++)\n      {  if (rowname != NULL)\n            glp_set_row_name(lp->prob, m+i+1, rowname[i]);\n         lbnd = ubnd = (rhs == NULL ? 0.0 : rhs[i]);\n         if (sense == NULL || sense[i] == 'E')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_FX;\n         }\n         else if (sense[i] == 'L')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_UP;\n         }\n         else if (sense[i] == 'G')\n         {  lp->rflag[m+i] = RF_NOT_RANGED;\n            type = GLP_LO;\n         }\n         else if (sense[i] == 'R')\n         {  if (rngval == NULL || rngval[i] == 0.0)\n            {  lp->rflag[m+i] = RF_RANGED_POS;\n               type = GLP_FX;\n            }\n            else if (rngval[i] > 0.0)\n            {  lp->rflag[m+i] = RF_RANGED_POS;\n               type = GLP_DB;\n               ubnd += rngval[i];\n            }\n            else /* rngval[i] < 0.0 */\n            {  lp->rflag[m+i] = RF_RANGED_NEG;\n               type = GLP_DB;\n               lbnd += rngval[i];\n            }\n         }\n         else\n            xassert(sense != sense);\n         glp_set_row_bnds(lp->prob, m+i+1, type, lbnd, ubnd);\n      }\ndone: return errcode;\n}",
      "lines": 69,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "CPXopenCPLEX": {
      "start_point": [
        1745,
        0
      ],
      "end_point": [
        1760,
        1
      ],
      "content": "CPXENV *CPXopenCPLEX(int *status)\n{     CPXENV *env;\n      int k, card;\n      env = xmalloc(sizeof(CPXENV));\n      env->list = NULL;\n      card = sizeof(intparam) / sizeof(struct intparam);\n      env->intparam = xcalloc(card, sizeof(int));\n      for (k = 0; k < card; k++)\n         env->intparam[k] = intparam[k].defv;\n      card = sizeof(dblparam) / sizeof(struct dblparam);\n      env->dblparam = xcalloc(card, sizeof(double));\n      for (k = 0; k < card; k++)\n         env->dblparam[k] = dblparam[k].defv;\n      if (status != NULL) *status = 0;\n      return env;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "CPXENV",
        "*CPXopenCPLEX(int *status)",
        "*"
      ]
    },
    "CPXpivotin": {
      "start_point": [
        1762,
        0
      ],
      "end_point": [
        1791,
        1
      ],
      "content": "int CPXpivotin(CPXENV *env, CPXLP *lp, const int rlist[], int rlen)\n{     int i, m, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (rlen < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (rlen > 0 && rlist == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      m = glp_get_num_rows(lp->prob);\n      for (i = 0; i < rlen; i++)\n      {  if (!(0 <= rlist[i] && rlist[i] < m))\n         {  errcode = error(env, CPXERR_ROW_INDEX_RANGE, i);\n            goto done;\n         }\n      }\n      errcode = 0;\n      for (i = 0; i < rlen; i++)\n      {  if (glp_get_row_type(lp->prob, rlist[i]+1) != GLP_FX)\n         {  if (glp_get_row_stat(lp->prob, rlist[i]+1) != GLP_BS)\n            {  /* not implemented yet */\n               break;\n            }\n         }\n      }\ndone: return errcode;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "CPXpivotout": {
      "start_point": [
        1793,
        0
      ],
      "end_point": [
        1824,
        1
      ],
      "content": "int CPXpivotout(CPXENV *env, CPXLP *lp, const int clist[], int clen)\n{     int j, n, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (clen < 0)\n      {  errcode = error(env, CPXERR_BAD_ARGUMENT);\n         goto done;\n      }\n      if (clen > 0 && clist == NULL)\n      {  errcode = error(env, CPXERR_NULL_POINTER);\n         goto done;\n      }\n      n = glp_get_num_cols(lp->prob);\n      for (j = 0; j < clen; j++)\n      {  if (!(0 <= clist[j] && clist[j] < n))\n         {  errcode = error(env, CPXERR_COL_INDEX_RANGE, j);\n            goto done;\n         }\n         if (glp_get_col_type(lp->prob, clist[j]+1) != GLP_FX)\n         {  errcode = error(env, CPXERR_NOT_FIXED);\n            goto done;\n         }\n      }\n      errcode = 0;\n      for (j = 0; j < clen; j++)\n      {  if (glp_get_col_stat(lp->prob, clist[j]+1) == GLP_BS)\n         {  /* not implemented yet */\n            break;\n         }\n      }\ndone: return errcode;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "CPXsavwrite": {
      "start_point": [
        1828,
        0
      ],
      "end_point": [
        1835,
        1
      ],
      "content": "int CPXsavwrite(CPXENV *env, CPXLP *lp, const char *filename)\n{     xassert(env == env);\n      xassert(lp == lp);\n      xassert(filename == filename);\n      xprintf(\"CPXsavwrite: not implemented yet\\n\");\n      exit(EXIT_FAILURE);\n      return -1;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXsetdblparam": {
      "start_point": [
        1837,
        0
      ],
      "end_point": [
        1857,
        1
      ],
      "content": "int CPXsetdblparam(CPXENV *env, int whichparam, double newvalue)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = finddblparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      if (newvalue < dblparam[k].minv)\n      {  errcode = error(env, CPXERR_PARAM_TOO_SMALL);\n         goto done;\n      }\n      if (newvalue > dblparam[k].maxv)\n      {  errcode = error(env, CPXERR_PARAM_TOO_BIG);\n         goto done;\n      }\n      errcode = 0;\n      env->dblparam[k] = newvalue;\ndone: return errcode;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXsetintparam": {
      "start_point": [
        1859,
        0
      ],
      "end_point": [
        1879,
        1
      ],
      "content": "int CPXsetintparam(CPXENV *env, int whichparam, int newvalue)\n{     int k, errcode;\n      errcode = checkenv(env);\n      if (errcode) goto done;\n      k = findintparam(whichparam);\n      if (k < 0)\n      {  errcode = error(env, CPXERR_BAD_PARAM_NUM);\n         goto done;\n      }\n      if (newvalue < intparam[k].minv)\n      {  errcode = error(env, CPXERR_PARAM_TOO_SMALL);\n         goto done;\n      }\n      if (newvalue > intparam[k].maxv)\n      {  errcode = error(env, CPXERR_PARAM_TOO_BIG);\n         goto done;\n      }\n      errcode = 0;\n      env->intparam[k] = newvalue;\ndone: return errcode;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "CPXsolninfo": {
      "start_point": [
        1881,
        0
      ],
      "end_point": [
        1905,
        1
      ],
      "content": "int CPXsolninfo(CPXENV *env, CPXLP *lp, int *solnmethod, int *solntype,\n      int *pfeasind, int *dfeasind)\n{     int type, pfeas, dfeas, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      errcode = 0;\n      if (!lp->stat)\n         type = CPX_NO_SOLN, pfeas = dfeas = 0;\n      else if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  type = CPX_BASIC_SOLN;\n         pfeas = (glp_get_prim_stat(lp->prob) == GLP_FEAS);\n         dfeas = (glp_get_dual_stat(lp->prob) == GLP_FEAS);\n      }\n      else\n         xassert(lp != lp);\n      if (solnmethod != NULL)\n         *solnmethod = lp->meth;\n      if (solntype != NULL)\n         *solntype = type;\n      if (pfeasind != NULL)\n         *pfeasind = pfeas;\n      if (dfeasind != NULL)\n         *dfeasind = dfeas;\ndone: return errcode;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXsolution": {
      "start_point": [
        1907,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "int CPXsolution(CPXENV *env, CPXLP *lp, int *lpstat, double *objval,\n      double x[], double pi[], double slack[], double dj[])\n{     int m, n, errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (!lp->stat)\n      {  errcode = error(env, CPXERR_NO_SOLN);\n         goto done;\n      }\n      errcode = 0;\n      m = glp_get_num_rows(lp->prob);\n      n = glp_get_num_cols(lp->prob);\n      if (lp->meth == CPX_ALG_PRIMAL || lp->meth == CPX_ALG_DUAL)\n      {  if (lpstat != NULL)\n            *lpstat = CPXgetstat(env, lp);\n         if (objval != NULL)\n            xassert(CPXgetobjval(env, lp, objval) == 0);\n         if (x != NULL)\n            xassert(CPXgetx(env, lp, x, 0, n-1) == 0);\n         if (pi != NULL)\n            xassert(CPXgetpi(env, lp, pi, 0, m-1) == 0);\n         if (slack != NULL)\n            xassert(CPXgetslack(env, lp, slack, 0, m-1) == 0);\n         if (dj != NULL)\n            xassert(CPXgetdj(env, lp, dj, 0, n-1) == 0);\n      }\n      else\n         xassert(lp != lp);\ndone: return errcode;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "CPXstrongbranch": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        1952,
        1
      ],
      "content": "int CPXstrongbranch(CPXENV *env, CPXLP *lp, const int goodlist[],\n      int goodlen, double downpen[], double uppen[], int itlim)\n{     int k;\n      xassert(env == env);\n      xassert(lp == lp);\n      xassert(goodlist == goodlist);\n      xassert(goodlen >= 0);\n      xassert(downpen != NULL);\n      xassert(uppen != NULL);\n      xassert(itlim == itlim);\n      /* not implemented yet */\n      for (k = 0; k < goodlen; k++)\n         downpen[k] = uppen[k] = 0.0;\n      return 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "xstrcasecmp": {
      "start_point": [
        1954,
        0
      ],
      "end_point": [
        1962,
        1
      ],
      "content": "static int xstrcasecmp(const char *s1, const char *s2)\n{     int c1, c2;\n      for (;;)\n      {  c1 = toupper((unsigned char)*s1++);\n         c2 = toupper((unsigned char)*s2++);\n         if (c1 == '\\0' || c1 != c2) break;\n      }\n      return c1 - c2;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getfiletype": {
      "start_point": [
        1964,
        0
      ],
      "end_point": [
        1983,
        1
      ],
      "content": "static void getfiletype(const char *filename, char type[3+1])\n{     /* determine filetype from filename */\n      int beg, end;\n      beg = end = strlen(filename);\n      while (beg > 0 && filename[beg-1] != '.' && end - beg < 3)\n         beg--;\n      if (beg > 0 && filename[beg-1] == '.' &&\n          xstrcasecmp(&filename[beg], \"gz\") == 0)\n      {  end = --beg;\n         while (beg > 0 && filename[beg-1] != '.' && end - beg < 3)\n            beg--;\n      }\n      if (beg > 0 && filename[beg-1] == '.')\n      {  memcpy(type, &filename[beg], end - beg);\n         type[end - beg] = '\\0';\n      }\n      else\n         type[0] = '\\0';\n      return;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "CPXwriteprob": {
      "start_point": [
        1985,
        0
      ],
      "end_point": [
        2033,
        1
      ],
      "content": "int CPXwriteprob(CPXENV *env, CPXLP *lp, const char *filename,\n      const char *filetype)\n{     glp_prob *copy;\n      int errcode;\n      char type[3+1];\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      if (filename == NULL)\n      {  errcode = error(env, CPXERR_NO_FILENAME);\n         goto done;\n      }\n      if (filetype == NULL)\n         getfiletype(filename, type), filetype = type;\n      if (xstrcasecmp(filetype, \"MPS\") == 0)\n      {  glp_term_out(GLP_OFF);\n         errcode = glp_write_mps(lp->prob, GLP_MPS_FILE, NULL, filename)\n            ;\n         glp_term_out(GLP_ON);\n      }\n      else if (xstrcasecmp(filetype, \"LP\") == 0)\n      {  glp_term_out(GLP_OFF);\n         errcode = glp_write_lp(lp->prob, NULL, filename);\n         glp_term_out(GLP_ON);\n      }\n      else if (xstrcasecmp(filetype, \"RMP\") == 0 ||\n               xstrcasecmp(filetype, \"REW\") == 0)\n      {  copy = glp_create_prob();\n         glp_copy_prob(copy, lp->prob, GLP_OFF);\n         glp_term_out(GLP_OFF);\n         errcode = glp_write_mps(copy, GLP_MPS_DECK, NULL, filename);\n         glp_term_out(GLP_ON);\n         glp_delete_prob(copy);\n      }\n      else if (xstrcasecmp(filetype, \"RLP\") == 0)\n      {  copy = glp_create_prob();\n         glp_copy_prob(copy, lp->prob, GLP_OFF);\n         glp_term_out(GLP_OFF);\n         errcode = glp_write_lp(copy, NULL, filename);\n         glp_term_out(GLP_ON);\n         glp_delete_prob(copy);\n      }\n      else\n      {  errcode = error(env, CPXERR_BAD_FILETYPE);\n         goto done;\n      }\n      if (errcode)\n         errcode = error(env, CPXERR_FAIL_OPEN_WRITE, filename);\ndone: return errcode;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "solvelp": {
      "start_point": [
        2037,
        0
      ],
      "end_point": [
        2109,
        1
      ],
      "content": "static int solvelp(CPXENV *env, CPXLP *lp, int meth)\n{     glp_smcp parm;\n      int errcode;\n      errcode = checklp(env, lp);\n      if (errcode) goto done;\n      errcode = 0;\n      invalidate(lp);\n      glp_init_smcp(&parm);\n      switch (meth)\n      {  case CPX_ALG_PRIMAL:\n            parm.meth = GLP_PRIMAL;\n            break;\n         case CPX_ALG_DUAL:\n            parm.meth = GLP_DUAL;\n            break;\n         default:\n            xassert(meth != meth);\n      }\n      switch (getintparam(env, CPX_PARAM_SIMDISPLAY))\n      {  case 0:\n            parm.msg_lev = GLP_MSG_OFF;\n            break;\n         case 1:\n            parm.msg_lev = GLP_MSG_ALL;\n            break;\n         case 2:\n            parm.msg_lev = GLP_MSG_ALL;\n            parm.out_frq = 1;\n            break;\n         default:\n            xassert(env != env);\n      }\n      xassert(getdblparam == getdblparam);\n      switch (getintparam(env, CPX_PARAM_ADVIND))\n      {  case 0:\n            glp_term_out(GLP_OFF);\n            glp_adv_basis(lp->prob, 0);\n            glp_term_out(GLP_ON);\n            break;\n         case 1:\n         case 2:\n            break;\n         default:\n            xassert(env != env);\n      }\n      if (!glp_bf_exists(lp->prob))\n      {  if (glp_factorize(lp->prob) != 0)\n         {  glp_term_out(GLP_OFF);\n            glp_adv_basis(lp->prob, 0);\n            glp_term_out(GLP_ON);\n            if (glp_factorize(lp->prob) != 0)\n               glp_std_basis(lp->prob);\n         }\n      }\n      xassert(glp_simplex(lp->prob, &parm) == 0);\n      switch (glp_get_status(lp->prob))\n      {  case GLP_OPT:\n            lp->stat = CPX_STAT_OPTIMAL;\n            lp->meth = meth;\n            break;\n         case GLP_NOFEAS:\n            lp->stat = CPX_STAT_INFEASIBLE;\n            lp->meth = meth;\n            break;\n         case GLP_UNBND:\n            lp->stat = CPX_STAT_UNBOUNDED;\n            lp->meth = meth;\n            break;\n         default:\n            xassert(lp != lp);\n      }\ndone: return errcode;\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "CPXprimopt": {
      "start_point": [
        2111,
        0
      ],
      "end_point": [
        2115,
        1
      ],
      "content": "int CPXprimopt(CPXENV *env, CPXLP *lp)\n{     int errcode;\n      errcode = solvelp(env, lp, CPX_ALG_PRIMAL);\n      return errcode;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXdualopt": {
      "start_point": [
        2117,
        0
      ],
      "end_point": [
        2121,
        1
      ],
      "content": "int CPXdualopt(CPXENV *env, CPXLP *lp)\n{     int errcode;\n      errcode = solvelp(env, lp, CPX_ALG_DUAL);\n      return errcode;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "CPXlpopt": {
      "start_point": [
        2123,
        0
      ],
      "end_point": [
        2127,
        1
      ],
      "content": "int CPXlpopt(CPXENV *env, CPXLP *lp)\n{     int errcode;\n      errcode = solvelp(env, lp, CPX_ALG_PRIMAL);\n      return errcode;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/cplex/cplex.h": {},
  "glpk/glpk-4.65/examples/oldapi/lpx.c": {
    "find_cps": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static struct CPS *find_cps(LPX *lp)\n{     /* find CPS for specified problem object */\n      struct CPS *cps;\n      for (cps = cps_ptr; cps != NULL; cps = cps->link)\n         if (cps->lp == lp) break;\n      /* if cps is NULL (not found), the problem object was created\n         with glp_create_prob rather than with lpx_create_prob */\n      xassert(cps != NULL);\n      return cps;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct CPS",
        "struct",
        "CPS",
        "*find_cps(LPX *lp)",
        "*"
      ]
    },
    "reset_cps": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void reset_cps(struct CPS *cps)\n{     /* reset control parameters to default values */\n      cps->msg_lev  = 3;\n      cps->scale    = 1;\n      cps->dual     = 0;\n      cps->price    = 1;\n      cps->relax    = 0.07;\n      cps->tol_bnd  = 1e-7;\n      cps->tol_dj   = 1e-7;\n      cps->tol_piv  = 1e-9;\n      cps->round    = 0;\n      cps->obj_ll   = -DBL_MAX;\n      cps->obj_ul   = +DBL_MAX;\n      cps->it_lim   = -1;\n      cps->tm_lim   = -1.0;\n      cps->out_frq  = 200;\n      cps->out_dly  = 0.0;\n      cps->branch   = 2;\n      cps->btrack   = 3;\n      cps->tol_int  = 1e-5;\n      cps->tol_obj  = 1e-7;\n      cps->mps_info = 1;\n      cps->mps_obj  = 2;\n      cps->mps_orig = 0;\n      cps->mps_wide = 1;\n      cps->mps_free = 0;\n      cps->mps_skip = 0;\n      cps->lpt_orig = 0;\n      cps->presol   = 0;\n      cps->binarize = 0;\n      cps->use_cuts = 0;\n      cps->mip_gap  = 0.0;\n      return;\n}",
      "lines": 34,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lpx_create_prob": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "LPX *lpx_create_prob(void)\n{     /* create problem object */\n      LPX *lp;\n      struct CPS *cps;\n      lp = glp_create_prob();\n      cps = glp_alloc(1, sizeof(struct CPS));\n      cps->lp = lp;\n      reset_cps(cps);\n      cps->link = cps_ptr;\n      cps_ptr = cps;\n      return lp;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "LPX",
        "*lpx_create_prob(void)",
        "*"
      ]
    },
    "lpx_set_prob_name": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "void lpx_set_prob_name(LPX *lp, const char *name)\n{     /* assign (change) problem name */\n      glp_set_prob_name(lp, name);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_obj_name": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        236,
        1
      ],
      "content": "void lpx_set_obj_name(LPX *lp, const char *name)\n{     /* assign (change) objective function name */\n      glp_set_obj_name(lp, name);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_obj_dir": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void lpx_set_obj_dir(LPX *lp, int dir)\n{     /* set (change) optimization direction flag */\n      glp_set_obj_dir(lp, dir - LPX_MIN + GLP_MIN);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_add_rows": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int lpx_add_rows(LPX *lp, int nrs)\n{     /* add new rows to problem object */\n      return glp_add_rows(lp, nrs);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_add_cols": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int lpx_add_cols(LPX *lp, int ncs)\n{     /* add new columns to problem object */\n      return glp_add_cols(lp, ncs);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_set_row_name": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "void lpx_set_row_name(LPX *lp, int i, const char *name)\n{     /* assign (change) row name */\n      glp_set_row_name(lp, i, name);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_col_name": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "void lpx_set_col_name(LPX *lp, int j, const char *name)\n{     /* assign (change) column name */\n      glp_set_col_name(lp, j, name);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_row_bnds": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void lpx_set_row_bnds(LPX *lp, int i, int type, double lb, double ub)\n{     /* set (change) row bounds */\n      glp_set_row_bnds(lp, i, type - LPX_FR + GLP_FR, lb, ub);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_col_bnds": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void lpx_set_col_bnds(LPX *lp, int j, int type, double lb, double ub)\n{     /* set (change) column bounds */\n      glp_set_col_bnds(lp, j, type - LPX_FR + GLP_FR, lb, ub);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_obj_coef": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void lpx_set_obj_coef(glp_prob *lp, int j, double coef)\n{     /* set (change) obj. coefficient or constant term */\n      glp_set_obj_coef(lp, j, coef);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_mat_row": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "void lpx_set_mat_row(LPX *lp, int i, int len, const int ind[],\n      const double val[])\n{     /* set (replace) row of the constraint matrix */\n      glp_set_mat_row(lp, i, len, ind, val);\n      return;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_mat_col": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "void lpx_set_mat_col(LPX *lp, int j, int len, const int ind[],\n      const double val[])\n{     /* set (replace) column of the constraint matrix */\n      glp_set_mat_col(lp, j, len, ind, val);\n      return;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_load_matrix": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "void lpx_load_matrix(LPX *lp, int ne, const int ia[], const int ja[],\n      const double ar[])\n{     /* load (replace) the whole constraint matrix */\n      glp_load_matrix(lp, ne, ia, ja, ar);\n      return;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_del_rows": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void lpx_del_rows(LPX *lp, int nrs, const int num[])\n{     /* delete specified rows from problem object */\n      glp_del_rows(lp, nrs, num);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_del_cols": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void lpx_del_cols(LPX *lp, int ncs, const int num[])\n{     /* delete specified columns from problem object */\n      glp_del_cols(lp, ncs, num);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_delete_prob": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void lpx_delete_prob(LPX *lp)\n{     /* delete problem object */\n      struct CPS *cps = find_cps(lp);\n      if (cps_ptr == cps)\n         cps_ptr = cps->link;\n      else\n      {  struct CPS *prev;\n         for (prev = cps_ptr; prev != NULL; prev = prev->link)\n            if (prev->link == cps) break;\n         xassert(prev != NULL);\n         prev->link = cps->link;\n      }\n      glp_free(cps);\n      glp_delete_prob(lp);\n      return;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_prob_name": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "const char *lpx_get_prob_name(LPX *lp)\n{     /* retrieve problem name */\n      return glp_get_prob_name(lp);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*lpx_get_prob_name(LPX *lp)",
        "*"
      ]
    },
    "lpx_get_obj_name": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "const char *lpx_get_obj_name(LPX *lp)\n{     /* retrieve objective function name */\n      return glp_get_obj_name(lp);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*lpx_get_obj_name(LPX *lp)",
        "*"
      ]
    },
    "lpx_get_obj_dir": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int lpx_get_obj_dir(LPX *lp)\n{     /* retrieve optimization direction flag */\n      return glp_get_obj_dir(lp) - GLP_MIN + LPX_MIN;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_num_rows": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        352,
        1
      ],
      "content": "int lpx_get_num_rows(LPX *lp)\n{     /* retrieve number of rows */\n      return glp_get_num_rows(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_num_cols": {
      "start_point": [
        354,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "int lpx_get_num_cols(LPX *lp)\n{     /* retrieve number of columns */\n      return glp_get_num_cols(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_row_name": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "const char *lpx_get_row_name(LPX *lp, int i)\n{     /* retrieve row name */\n      return glp_get_row_name(lp, i);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*lpx_get_row_name(LPX *lp, int i)",
        "*"
      ]
    },
    "lpx_get_col_name": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "const char *lpx_get_col_name(LPX *lp, int j)\n{     /* retrieve column name */\n      return glp_get_col_name(lp, j);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*lpx_get_col_name(LPX *lp, int j)",
        "*"
      ]
    },
    "lpx_get_row_type": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "int lpx_get_row_type(LPX *lp, int i)\n{     /* retrieve row type */\n      return glp_get_row_type(lp, i) - GLP_FR + LPX_FR;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_row_lb": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        380,
        1
      ],
      "content": "double lpx_get_row_lb(glp_prob *lp, int i)\n{     /* retrieve row lower bound */\n      double lb;\n      lb = glp_get_row_lb(lp, i);\n      if (lb == -DBL_MAX) lb = 0.0;\n      return lb;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_row_ub": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "double lpx_get_row_ub(glp_prob *lp, int i)\n{     /* retrieve row upper bound */\n      double ub;\n      ub = glp_get_row_ub(lp, i);\n      if (ub == +DBL_MAX) ub = 0.0;\n      return ub;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_row_bnds": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void lpx_get_row_bnds(glp_prob *lp, int i, int *typx, double *lb,\n      double *ub)\n{     /* retrieve row bounds */\n      if (typx != NULL) *typx = lpx_get_row_type(lp, i);\n      if (lb != NULL) *lb = lpx_get_row_lb(lp, i);\n      if (ub != NULL) *ub = lpx_get_row_ub(lp, i);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_col_type": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "int lpx_get_col_type(LPX *lp, int j)\n{     /* retrieve column type */\n      return glp_get_col_type(lp, j) - GLP_FR + LPX_FR;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_col_lb": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "double lpx_get_col_lb(glp_prob *lp, int j)\n{     /* retrieve column lower bound */\n      double lb;\n      lb = glp_get_col_lb(lp, j);\n      if (lb == -DBL_MAX) lb = 0.0;\n      return lb;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_col_ub": {
      "start_point": [
        412,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "double lpx_get_col_ub(glp_prob *lp, int j)\n{     /* retrieve column upper bound */\n      double ub;\n      ub = glp_get_col_ub(lp, j);\n      if (ub == +DBL_MAX) ub = 0.0;\n      return ub;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_col_bnds": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void lpx_get_col_bnds(glp_prob *lp, int j, int *typx, double *lb,\n      double *ub)\n{     /* retrieve column bounds */\n      if (typx != NULL) *typx = lpx_get_col_type(lp, j);\n      if (lb != NULL) *lb = lpx_get_col_lb(lp, j);\n      if (ub != NULL) *ub = lpx_get_col_ub(lp, j);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_obj_coef": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "double lpx_get_obj_coef(LPX *lp, int j)\n{     /* retrieve obj. coefficient or constant term */\n      return glp_get_obj_coef(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_num_nz": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "int lpx_get_num_nz(LPX *lp)\n{     /* retrieve number of constraint coefficients */\n      return glp_get_num_nz(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_mat_row": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "int lpx_get_mat_row(LPX *lp, int i, int ind[], double val[])\n{     /* retrieve row of the constraint matrix */\n      return glp_get_mat_row(lp, i, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_mat_col": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "int lpx_get_mat_col(LPX *lp, int j, int ind[], double val[])\n{     /* retrieve column of the constraint matrix */\n      return glp_get_mat_col(lp, j, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_create_index": {
      "start_point": [
        449,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "void lpx_create_index(LPX *lp)\n{     /* create the name index */\n      glp_create_index(lp);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_find_row": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "int lpx_find_row(LPX *lp, const char *name)\n{     /* find row by its name */\n      return glp_find_row(lp, name);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_find_col": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "int lpx_find_col(LPX *lp, const char *name)\n{     /* find column by its name */\n      return glp_find_col(lp, name);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_delete_index": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void lpx_delete_index(LPX *lp)\n{     /* delete the name index */\n      glp_delete_index(lp);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_scale_prob": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "void lpx_scale_prob(LPX *lp)\n{     /* scale problem data */\n      switch (lpx_get_int_parm(lp, LPX_K_SCALE))\n      {  case 0:\n            /* no scaling */\n            glp_unscale_prob(lp);\n            break;\n         case 1:\n            /* equilibration scaling */\n            glp_scale_prob(lp, GLP_SF_EQ);\n            break;\n         case 2:\n            /* geometric mean scaling */\n            glp_scale_prob(lp, GLP_SF_GM);\n            break;\n         case 3:\n            /* geometric mean scaling, then equilibration scaling */\n            glp_scale_prob(lp, GLP_SF_GM | GLP_SF_EQ);\n            break;\n         default:\n            xassert(lp != lp);\n      }\n      return;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "lpx_unscale_prob": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "void lpx_unscale_prob(LPX *lp)\n{     /* unscale problem data */\n      glp_unscale_prob(lp);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_row_stat": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        506,
        1
      ],
      "content": "void lpx_set_row_stat(LPX *lp, int i, int stat)\n{     /* set (change) row status */\n      glp_set_row_stat(lp, i, stat - LPX_BS + GLP_BS);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_col_stat": {
      "start_point": [
        508,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "void lpx_set_col_stat(LPX *lp, int j, int stat)\n{     /* set (change) column status */\n      glp_set_col_stat(lp, j, stat - LPX_BS + GLP_BS);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_std_basis": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "void lpx_std_basis(LPX *lp)\n{     /* construct standard initial LP basis */\n      glp_std_basis(lp);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_adv_basis": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        524,
        1
      ],
      "content": "void lpx_adv_basis(LPX *lp)\n{     /* construct advanced initial LP basis */\n      glp_adv_basis(lp, 0);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "lpx_cpx_basis": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "void lpx_cpx_basis(LPX *lp)\n{     /* construct Bixby's initial LP basis */\n      glp_cpx_basis(lp);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "fill_smcp": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "static void fill_smcp(LPX *lp, glp_smcp *parm)\n{     glp_init_smcp(parm);\n      switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\n      {  case 0:  parm->msg_lev = GLP_MSG_OFF;   break;\n         case 1:  parm->msg_lev = GLP_MSG_ERR;   break;\n         case 2:  parm->msg_lev = GLP_MSG_ON;    break;\n         case 3:  parm->msg_lev = GLP_MSG_ALL;   break;\n         default: xassert(lp != lp);\n      }\n      switch (lpx_get_int_parm(lp, LPX_K_DUAL))\n      {  case 0:  parm->meth = GLP_PRIMAL;       break;\n         case 1:  parm->meth = GLP_DUAL;         break;\n         default: xassert(lp != lp);\n      }\n      switch (lpx_get_int_parm(lp, LPX_K_PRICE))\n      {  case 0:  parm->pricing = GLP_PT_STD;    break;\n         case 1:  parm->pricing = GLP_PT_PSE;    break;\n         default: xassert(lp != lp);\n      }\n      if (lpx_get_real_parm(lp, LPX_K_RELAX) == 0.0)\n         parm->r_test = GLP_RT_STD;\n      else\n         parm->r_test = GLP_RT_HAR;\n      parm->tol_bnd = lpx_get_real_parm(lp, LPX_K_TOLBND);\n      parm->tol_dj  = lpx_get_real_parm(lp, LPX_K_TOLDJ);\n      parm->tol_piv = lpx_get_real_parm(lp, LPX_K_TOLPIV);\n      parm->obj_ll  = lpx_get_real_parm(lp, LPX_K_OBJLL);\n      parm->obj_ul  = lpx_get_real_parm(lp, LPX_K_OBJUL);\n      if (lpx_get_int_parm(lp, LPX_K_ITLIM) < 0)\n         parm->it_lim = INT_MAX;\n      else\n         parm->it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);\n      if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0)\n         parm->tm_lim = INT_MAX;\n      else\n         parm->tm_lim =\n            (int)(1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM));\n      parm->out_frq = lpx_get_int_parm(lp, LPX_K_OUTFRQ);\n      parm->out_dly =\n            (int)(1000.0 * lpx_get_real_parm(lp, LPX_K_OUTDLY));\n      switch (lpx_get_int_parm(lp, LPX_K_PRESOL))\n      {  case 0:  parm->presolve = GLP_OFF;      break;\n         case 1:  parm->presolve = GLP_ON;       break;\n         default: xassert(lp != lp);\n      }\n      return;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lpx_simplex": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "int lpx_simplex(LPX *lp)\n{     /* easy-to-use driver to the simplex method */\n      glp_smcp parm;\n      int ret;\n      fill_smcp(lp, &parm);\n      ret = glp_simplex(lp, &parm);\n      switch (ret)\n      {  case 0:           ret = LPX_E_OK;      break;\n         case GLP_EBADB:\n         case GLP_ESING:\n         case GLP_ECOND:\n         case GLP_EBOUND:  ret = LPX_E_FAULT;   break;\n         case GLP_EFAIL:   ret = LPX_E_SING;    break;\n         case GLP_EOBJLL:  ret = LPX_E_OBJLL;   break;\n         case GLP_EOBJUL:  ret = LPX_E_OBJUL;   break;\n         case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\n         case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\n         case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\n         case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\n         default:          xassert(ret != ret);\n      }\n      return ret;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_exact": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "int lpx_exact(LPX *lp)\n{     /* easy-to-use driver to the exact simplex method */\n      glp_smcp parm;\n      int ret;\n      fill_smcp(lp, &parm);\n      ret = glp_exact(lp, &parm);\n      switch (ret)\n      {  case 0:           ret = LPX_E_OK;      break;\n         case GLP_EBADB:\n         case GLP_ESING:\n         case GLP_EBOUND:\n         case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\n         case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\n         case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\n         default:          xassert(ret != ret);\n      }\n      return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_status": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "int lpx_get_status(glp_prob *lp)\n{     /* retrieve generic status of basic solution */\n      int status;\n      switch (glp_get_status(lp))\n      {  case GLP_OPT:    status = LPX_OPT;    break;\n         case GLP_FEAS:   status = LPX_FEAS;   break;\n         case GLP_INFEAS: status = LPX_INFEAS; break;\n         case GLP_NOFEAS: status = LPX_NOFEAS; break;\n         case GLP_UNBND:  status = LPX_UNBND;  break;\n         case GLP_UNDEF:  status = LPX_UNDEF;  break;\n         default:         xassert(lp != lp);\n      }\n      return status;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_prim_stat": {
      "start_point": [
        638,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "int lpx_get_prim_stat(glp_prob *lp)\n{     /* retrieve status of primal basic solution */\n      return glp_get_prim_stat(lp) - GLP_UNDEF + LPX_P_UNDEF;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_dual_stat": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "int lpx_get_dual_stat(glp_prob *lp)\n{     /* retrieve status of dual basic solution */\n      return glp_get_dual_stat(lp) - GLP_UNDEF + LPX_D_UNDEF;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_obj_val": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "double lpx_get_obj_val(LPX *lp)\n{     /* retrieve objective value (basic solution) */\n      return glp_get_obj_val(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_row_stat": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "int lpx_get_row_stat(LPX *lp, int i)\n{     /* retrieve row status (basic solution) */\n      return glp_get_row_stat(lp, i) - GLP_BS + LPX_BS;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_row_prim": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "double lpx_get_row_prim(LPX *lp, int i)\n{     /* retrieve row primal value (basic solution) */\n      return glp_get_row_prim(lp, i);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_row_dual": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "double lpx_get_row_dual(LPX *lp, int i)\n{     /* retrieve row dual value (basic solution) */\n      return glp_get_row_dual(lp, i);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_row_info": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "void lpx_get_row_info(glp_prob *lp, int i, int *tagx, double *vx,\n      double *dx)\n{     /* obtain row solution information */\n      if (tagx != NULL) *tagx = lpx_get_row_stat(lp, i);\n      if (vx != NULL) *vx = lpx_get_row_prim(lp, i);\n      if (dx != NULL) *dx = lpx_get_row_dual(lp, i);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_col_stat": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "int lpx_get_col_stat(LPX *lp, int j)\n{     /* retrieve column status (basic solution) */\n      return glp_get_col_stat(lp, j) - GLP_BS + LPX_BS;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_col_prim": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "double lpx_get_col_prim(LPX *lp, int j)\n{     /* retrieve column primal value (basic solution) */\n      return glp_get_col_prim(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_col_dual": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        690,
        1
      ],
      "content": "double lpx_get_col_dual(glp_prob *lp, int j)\n{     /* retrieve column dual value (basic solution) */\n      return glp_get_col_dual(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_get_col_info": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "void lpx_get_col_info(glp_prob *lp, int j, int *tagx, double *vx,\n      double *dx)\n{     /* obtain column solution information */\n      if (tagx != NULL) *tagx = lpx_get_col_stat(lp, j);\n      if (vx != NULL) *vx = lpx_get_col_prim(lp, j);\n      if (dx != NULL) *dx = lpx_get_col_dual(lp, j);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_ray_info": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "int lpx_get_ray_info(LPX *lp)\n{     /* determine what causes primal unboundness */\n      return glp_get_unbnd_ray(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_check_kkt": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        778,
        1
      ],
      "content": "void lpx_check_kkt(LPX *lp, int scaled, LPXKKT *kkt)\n{     /* check Karush-Kuhn-Tucker conditions */\n      int m = glp_get_num_rows(lp);\n      int ae_ind, re_ind;\n      double ae_max, re_max;\n      xassert(scaled == scaled);\n      glp_check_kkt(lp, GLP_SOL, GLP_KKT_PE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->pe_ae_max = ae_max;\n      kkt->pe_ae_row = ae_ind;\n      kkt->pe_re_max = re_max;\n      kkt->pe_re_row = re_ind;\n      if (re_max <= 1e-9)\n         kkt->pe_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->pe_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->pe_quality = 'L';\n      else\n         kkt->pe_quality = '?';\n      glp_check_kkt(lp, GLP_SOL, GLP_KKT_PB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->pb_ae_max = ae_max;\n      kkt->pb_ae_ind = ae_ind;\n      kkt->pb_re_max = re_max;\n      kkt->pb_re_ind = re_ind;\n      if (re_max <= 1e-9)\n         kkt->pb_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->pb_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->pb_quality = 'L';\n      else\n         kkt->pb_quality = '?';\n      glp_check_kkt(lp, GLP_SOL, GLP_KKT_DE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->de_ae_max = ae_max;\n      if (ae_ind == 0)\n         kkt->de_ae_col = 0;\n      else\n         kkt->de_ae_col = ae_ind - m;\n      kkt->de_re_max = re_max;\n      if (re_ind == 0)\n         kkt->de_re_col = 0;\n      else\n         kkt->de_re_col = ae_ind - m;\n      if (re_max <= 1e-9)\n         kkt->de_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->de_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->de_quality = 'L';\n      else\n         kkt->de_quality = '?';\n      glp_check_kkt(lp, GLP_SOL, GLP_KKT_DB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->db_ae_max = ae_max;\n      kkt->db_ae_ind = ae_ind;\n      kkt->db_re_max = re_max;\n      kkt->db_re_ind = re_ind;\n      if (re_max <= 1e-9)\n         kkt->db_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->db_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->db_quality = 'L';\n      else\n         kkt->db_quality = '?';\n      kkt->cs_ae_max = 0.0, kkt->cs_ae_ind = 0;\n      kkt->cs_re_max = 0.0, kkt->cs_re_ind = 0;\n      kkt->cs_quality = 'H';\n      return;\n}",
      "lines": 73,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lpx_warm_up": {
      "start_point": [
        780,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "int lpx_warm_up(LPX *lp)\n{     /* \"warm up\" LP basis */\n      int ret;\n      ret = glp_warm_up(lp);\n      if (ret == 0)\n         ret = LPX_E_OK;\n      else if (ret == GLP_EBADB)\n         ret = LPX_E_BADB;\n      else if (ret == GLP_ESING)\n         ret = LPX_E_SING;\n      else if (ret == GLP_ECOND)\n         ret = LPX_E_SING;\n      else\n         xassert(ret != ret);\n      return ret;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "lpx_eval_tab_row": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "int lpx_eval_tab_row(LPX *lp, int k, int ind[], double val[])\n{     /* compute row of the simplex tableau */\n      return glp_eval_tab_row(lp, k, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_eval_tab_col": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "int lpx_eval_tab_col(LPX *lp, int k, int ind[], double val[])\n{     /* compute column of the simplex tableau */\n      return glp_eval_tab_col(lp, k, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_transform_row": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "int lpx_transform_row(LPX *lp, int len, int ind[], double val[])\n{     /* transform explicitly specified row */\n      return glp_transform_row(lp, len, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_transform_col": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "int lpx_transform_col(LPX *lp, int len, int ind[], double val[])\n{     /* transform explicitly specified column */\n      return glp_transform_col(lp, len, ind, val);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_prim_ratio_test": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "int lpx_prim_ratio_test(LPX *lp, int len, const int ind[],\n      const double val[], int how, double tol)\n{     /* perform primal ratio test */\n      int piv;\n      piv = glp_prim_rtest(lp, len, ind, val, how, tol);\n      xassert(0 <= piv && piv <= len);\n      return piv == 0 ? 0 : ind[piv];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_dual_ratio_test": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "int lpx_dual_ratio_test(LPX *lp, int len, const int ind[],\n      const double val[], int how, double tol)\n{     /* perform dual ratio test */\n      int piv;\n      piv = glp_dual_rtest(lp, len, ind, val, how, tol);\n      xassert(0 <= piv && piv <= len);\n      return piv == 0 ? 0 : ind[piv];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_interior": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        849,
        1
      ],
      "content": "int lpx_interior(LPX *lp)\n{     /* easy-to-use driver to the interior-point method */\n      int ret;\n      ret = glp_interior(lp, NULL);\n      switch (ret)\n      {  case 0:           ret = LPX_E_OK;      break;\n         case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\n         case GLP_ENOFEAS: ret = LPX_E_NOFEAS;  break;\n         case GLP_ENOCVG:  ret = LPX_E_NOCONV;  break;\n         case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\n         case GLP_EINSTAB: ret = LPX_E_INSTAB;  break;\n         default:          xassert(ret != ret);\n      }\n      return ret;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_ipt_status": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        860,
        1
      ],
      "content": "int lpx_ipt_status(glp_prob *lp)\n{     /* retrieve status of interior-point solution */\n      int status;\n      switch (glp_ipt_status(lp))\n      {  case GLP_UNDEF:  status = LPX_T_UNDEF;  break;\n         case GLP_OPT:    status = LPX_T_OPT;    break;\n         default:         xassert(lp != lp);\n      }\n      return status;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_ipt_obj_val": {
      "start_point": [
        862,
        0
      ],
      "end_point": [
        865,
        1
      ],
      "content": "double lpx_ipt_obj_val(LPX *lp)\n{     /* retrieve objective value (interior point) */\n      return glp_ipt_obj_val(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_ipt_row_prim": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "double lpx_ipt_row_prim(LPX *lp, int i)\n{     /* retrieve row primal value (interior point) */\n      return glp_ipt_row_prim(lp, i);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_ipt_row_dual": {
      "start_point": [
        872,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "double lpx_ipt_row_dual(LPX *lp, int i)\n{     /* retrieve row dual value (interior point) */\n      return glp_ipt_row_dual(lp, i);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_ipt_col_prim": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        880,
        1
      ],
      "content": "double lpx_ipt_col_prim(LPX *lp, int j)\n{     /* retrieve column primal value (interior point) */\n      return glp_ipt_col_prim(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_ipt_col_dual": {
      "start_point": [
        882,
        0
      ],
      "end_point": [
        885,
        1
      ],
      "content": "double lpx_ipt_col_dual(LPX *lp, int j)\n{     /* retrieve column dual value (interior point) */\n      return glp_ipt_col_dual(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_set_class": {
      "start_point": [
        887,
        0
      ],
      "end_point": [
        893,
        1
      ],
      "content": "void lpx_set_class(LPX *lp, int klass)\n{     /* set problem class */\n      xassert(lp == lp);\n      if (!(klass == LPX_LP || klass == LPX_MIP))\n         xerror(\"lpx_set_class: invalid problem class\\n\");\n      return;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_class": {
      "start_point": [
        895,
        0
      ],
      "end_point": [
        898,
        1
      ],
      "content": "int lpx_get_class(LPX *lp)\n{     /* determine problem klass */\n      return glp_get_num_int(lp) == 0 ? LPX_LP : LPX_MIP;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_set_col_kind": {
      "start_point": [
        900,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "void lpx_set_col_kind(LPX *lp, int j, int kind)\n{     /* set (change) column kind */\n      glp_set_col_kind(lp, j, kind - LPX_CV + GLP_CV);\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_col_kind": {
      "start_point": [
        906,
        0
      ],
      "end_point": [
        909,
        1
      ],
      "content": "int lpx_get_col_kind(LPX *lp, int j)\n{     /* retrieve column kind */\n      return glp_get_col_kind(lp, j) == GLP_CV ? LPX_CV : LPX_IV;\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_num_int": {
      "start_point": [
        911,
        0
      ],
      "end_point": [
        914,
        1
      ],
      "content": "int lpx_get_num_int(LPX *lp)\n{     /* retrieve number of integer columns */\n      return glp_get_num_int(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_get_num_bin": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        919,
        1
      ],
      "content": "int lpx_get_num_bin(LPX *lp)\n{     /* retrieve number of binary columns */\n      return glp_get_num_bin(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "solve_mip": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "static int solve_mip(LPX *lp, int presolve)\n{     glp_iocp parm;\n      int ret;\n      glp_init_iocp(&parm);\n      switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\n      {  case 0:  parm.msg_lev = GLP_MSG_OFF;   break;\n         case 1:  parm.msg_lev = GLP_MSG_ERR;   break;\n         case 2:  parm.msg_lev = GLP_MSG_ON;    break;\n         case 3:  parm.msg_lev = GLP_MSG_ALL;   break;\n         default: xassert(lp != lp);\n      }\n      switch (lpx_get_int_parm(lp, LPX_K_BRANCH))\n      {  case 0:  parm.br_tech = GLP_BR_FFV;    break;\n         case 1:  parm.br_tech = GLP_BR_LFV;    break;\n         case 2:  parm.br_tech = GLP_BR_DTH;    break;\n         case 3:  parm.br_tech = GLP_BR_MFV;    break;\n         default: xassert(lp != lp);\n      }\n      switch (lpx_get_int_parm(lp, LPX_K_BTRACK))\n      {  case 0:  parm.bt_tech = GLP_BT_DFS;    break;\n         case 1:  parm.bt_tech = GLP_BT_BFS;    break;\n         case 2:  parm.bt_tech = GLP_BT_BPH;    break;\n         case 3:  parm.bt_tech = GLP_BT_BLB;    break;\n         default: xassert(lp != lp);\n      }\n      parm.tol_int = lpx_get_real_parm(lp, LPX_K_TOLINT);\n      parm.tol_obj = lpx_get_real_parm(lp, LPX_K_TOLOBJ);\n      if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0 ||\n          lpx_get_real_parm(lp, LPX_K_TMLIM) > 1e6)\n         parm.tm_lim = INT_MAX;\n      else\n         parm.tm_lim =\n            (int)(1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM));\n      parm.mip_gap = lpx_get_real_parm(lp, LPX_K_MIPGAP);\n      if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_GOMORY)\n         parm.gmi_cuts = GLP_ON;\n      else\n         parm.gmi_cuts = GLP_OFF;\n      if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_MIR)\n         parm.mir_cuts = GLP_ON;\n      else\n         parm.mir_cuts = GLP_OFF;\n      if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_COVER)\n         parm.cov_cuts = GLP_ON;\n      else\n         parm.cov_cuts = GLP_OFF;\n      if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_CLIQUE)\n         parm.clq_cuts = GLP_ON;\n      else\n         parm.clq_cuts = GLP_OFF;\n      parm.presolve = presolve;\n      if (lpx_get_int_parm(lp, LPX_K_BINARIZE))\n         parm.binarize = GLP_ON;\n      ret = glp_intopt(lp, &parm);\n      switch (ret)\n      {  case 0:           ret = LPX_E_OK;      break;\n         case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\n         case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\n         case GLP_EBOUND:\n         case GLP_EROOT:   ret = LPX_E_FAULT;   break;\n         case GLP_EFAIL:   ret = LPX_E_SING;    break;\n         case GLP_EMIPGAP: ret = LPX_E_MIPGAP;  break;\n         case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\n         default:          xassert(ret != ret);\n      }\n      return ret;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lpx_integer": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        992,
        1
      ],
      "content": "int lpx_integer(LPX *lp)\n{     /* easy-to-use driver to the branch-and-bound method */\n      return solve_mip(lp, GLP_OFF);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_intopt": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        997,
        1
      ],
      "content": "int lpx_intopt(LPX *lp)\n{     /* easy-to-use driver to the branch-and-bound method */\n      return solve_mip(lp, GLP_ON);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_mip_status": {
      "start_point": [
        999,
        0
      ],
      "end_point": [
        1010,
        1
      ],
      "content": "int lpx_mip_status(glp_prob *lp)\n{     /* retrieve status of MIP solution */\n      int status;\n      switch (glp_mip_status(lp))\n      {  case GLP_UNDEF:  status = LPX_I_UNDEF;  break;\n         case GLP_OPT:    status = LPX_I_OPT;    break;\n         case GLP_FEAS:   status = LPX_I_FEAS;   break;\n         case GLP_NOFEAS: status = LPX_I_NOFEAS; break;\n         default:         xassert(lp != lp);\n      }\n      return status;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "lpx_mip_obj_val": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1015,
        1
      ],
      "content": "double lpx_mip_obj_val(LPX *lp)\n{     /* retrieve objective value (MIP solution) */\n      return glp_mip_obj_val(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_mip_row_val": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "double lpx_mip_row_val(LPX *lp, int i)\n{     /* retrieve row value (MIP solution) */\n      return glp_mip_row_val(lp, i);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_mip_col_val": {
      "start_point": [
        1022,
        0
      ],
      "end_point": [
        1025,
        1
      ],
      "content": "double lpx_mip_col_val(LPX *lp, int j)\n{     /* retrieve column value (MIP solution) */\n      return glp_mip_col_val(lp, j);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "lpx_check_int": {
      "start_point": [
        1027,
        0
      ],
      "end_point": [
        1060,
        1
      ],
      "content": "void lpx_check_int(LPX *lp, LPXKKT *kkt)\n{     /* check integer feasibility conditions */\n      int ae_ind, re_ind;\n      double ae_max, re_max;\n      glp_check_kkt(lp, GLP_MIP, GLP_KKT_PE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->pe_ae_max = ae_max;\n      kkt->pe_ae_row = ae_ind;\n      kkt->pe_re_max = re_max;\n      kkt->pe_re_row = re_ind;\n      if (re_max <= 1e-9)\n         kkt->pe_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->pe_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->pe_quality = 'L';\n      else\n         kkt->pe_quality = '?';\n      glp_check_kkt(lp, GLP_MIP, GLP_KKT_PB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      kkt->pb_ae_max = ae_max;\n      kkt->pb_ae_ind = ae_ind;\n      kkt->pb_re_max = re_max;\n      kkt->pb_re_ind = re_ind;\n      if (re_max <= 1e-9)\n         kkt->pb_quality = 'H';\n      else if (re_max <= 1e-6)\n         kkt->pb_quality = 'M';\n      else if (re_max <= 1e-3)\n         kkt->pb_quality = 'L';\n      else\n         kkt->pb_quality = '?';\n      return;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "lpx_reset_parms": {
      "start_point": [
        1062,
        0
      ],
      "end_point": [
        1067,
        1
      ],
      "content": "void lpx_reset_parms(LPX *lp)\n{     /* reset control parameters to default values */\n      struct CPS *cps = find_cps(lp);\n      reset_cps(cps);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "lpx_set_int_parm": {
      "start_point": [
        1069,
        0
      ],
      "end_point": [
        1209,
        1
      ],
      "content": "void lpx_set_int_parm(LPX *lp, int parm, int val)\n{     /* set (change) integer control parameter */\n      struct CPS *cps = find_cps(lp);\n      switch (parm)\n      {  case LPX_K_MSGLEV:\n            if (!(0 <= val && val <= 3))\n               xerror(\"lpx_set_int_parm: MSGLEV = %d; invalid value\\n\",\n                  val);\n            cps->msg_lev = val;\n            break;\n         case LPX_K_SCALE:\n            if (!(0 <= val && val <= 3))\n               xerror(\"lpx_set_int_parm: SCALE = %d; invalid value\\n\",\n                  val);\n            cps->scale = val;\n            break;\n         case LPX_K_DUAL:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: DUAL = %d; invalid value\\n\",\n                  val);\n            cps->dual = val;\n            break;\n         case LPX_K_PRICE:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: PRICE = %d; invalid value\\n\",\n                  val);\n            cps->price = val;\n            break;\n         case LPX_K_ROUND:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: ROUND = %d; invalid value\\n\",\n                  val);\n            cps->round = val;\n            break;\n         case LPX_K_ITLIM:\n            cps->it_lim = val;\n            break;\n         case LPX_K_ITCNT:\n            glp_set_it_cnt(lp, val);\n            break;\n         case LPX_K_OUTFRQ:\n            if (!(val > 0))\n               xerror(\"lpx_set_int_parm: OUTFRQ = %d; invalid value\\n\",\n                  val);\n            cps->out_frq = val;\n            break;\n         case LPX_K_BRANCH:\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\n               xerror(\"lpx_set_int_parm: BRANCH = %d; invalid value\\n\",\n                  val);\n            cps->branch = val;\n            break;\n         case LPX_K_BTRACK:\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\n               xerror(\"lpx_set_int_parm: BTRACK = %d; invalid value\\n\",\n                  val);\n            cps->btrack = val;\n            break;\n         case LPX_K_MPSINFO:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: MPSINFO = %d; invalid value\\n\",\n                  val);\n            cps->mps_info = val;\n            break;\n         case LPX_K_MPSOBJ:\n            if (!(val == 0 || val == 1 || val == 2))\n               xerror(\"lpx_set_int_parm: MPSOBJ = %d; invalid value\\n\",\n                  val);\n            cps->mps_obj = val;\n            break;\n         case LPX_K_MPSORIG:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: MPSORIG = %d; invalid value\\n\",\n                  val);\n            cps->mps_orig = val;\n            break;\n         case LPX_K_MPSWIDE:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: MPSWIDE = %d; invalid value\\n\",\n                  val);\n            cps->mps_wide = val;\n            break;\n         case LPX_K_MPSFREE:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: MPSFREE = %d; invalid value\\n\",\n                  val);\n            cps->mps_free = val;\n            break;\n         case LPX_K_MPSSKIP:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: MPSSKIP = %d; invalid value\\n\",\n                  val);\n            cps->mps_skip = val;\n            break;\n         case LPX_K_LPTORIG:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: LPTORIG = %d; invalid value\\n\",\n                  val);\n            cps->lpt_orig = val;\n            break;\n         case LPX_K_PRESOL:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: PRESOL = %d; invalid value\\n\",\n                  val);\n            cps->presol = val;\n            break;\n         case LPX_K_BINARIZE:\n            if (!(val == 0 || val == 1))\n               xerror(\"lpx_set_int_parm: BINARIZE = %d; invalid value\\n\"\n                  , val);\n            cps->binarize = val;\n            break;\n         case LPX_K_USECUTS:\n            if (val & ~LPX_C_ALL)\n            xerror(\"lpx_set_int_parm: USECUTS = 0x%X; invalid value\\n\",\n                  val);\n            cps->use_cuts = val;\n            break;\n         case LPX_K_BFTYPE:\n            {  glp_bfcp parm;\n               glp_get_bfcp(lp, &parm);\n               switch (val)\n               {  case 1:\n                     parm.type = GLP_BF_FT; break;\n                  case 2:\n                     parm.type = GLP_BF_BG; break;\n                  case 3:\n                     parm.type = GLP_BF_GR; break;\n                  default:\n                     xerror(\"lpx_set_int_parm: BFTYPE = %d; invalid val\"\n                        \"ue\\n\", val);\n               }\n               glp_set_bfcp(lp, &parm);\n            }\n            break;\n         default:\n            xerror(\"lpx_set_int_parm: parm = %d; invalid parameter\\n\",\n               parm);\n      }\n      return;\n}",
      "lines": 141,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_int_parm": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1276,
        1
      ],
      "content": "int lpx_get_int_parm(LPX *lp, int parm)\n{     /* query integer control parameter */\n      struct CPS *cps = find_cps(lp);\n      int val = 0;\n      switch (parm)\n      {  case LPX_K_MSGLEV:\n            val = cps->msg_lev; break;\n         case LPX_K_SCALE:\n            val = cps->scale; break;\n         case LPX_K_DUAL:\n            val = cps->dual; break;\n         case LPX_K_PRICE:\n            val = cps->price; break;\n         case LPX_K_ROUND:\n            val = cps->round; break;\n         case LPX_K_ITLIM:\n            val = cps->it_lim; break;\n         case LPX_K_ITCNT:\n            val = glp_get_it_cnt(lp); break;\n         case LPX_K_OUTFRQ:\n            val = cps->out_frq; break;\n         case LPX_K_BRANCH:\n            val = cps->branch; break;\n         case LPX_K_BTRACK:\n            val = cps->btrack; break;\n         case LPX_K_MPSINFO:\n            val = cps->mps_info; break;\n         case LPX_K_MPSOBJ:\n            val = cps->mps_obj; break;\n         case LPX_K_MPSORIG:\n            val = cps->mps_orig; break;\n         case LPX_K_MPSWIDE:\n            val = cps->mps_wide; break;\n         case LPX_K_MPSFREE:\n            val = cps->mps_free; break;\n         case LPX_K_MPSSKIP:\n            val = cps->mps_skip; break;\n         case LPX_K_LPTORIG:\n            val = cps->lpt_orig; break;\n         case LPX_K_PRESOL:\n            val = cps->presol; break;\n         case LPX_K_BINARIZE:\n            val = cps->binarize; break;\n         case LPX_K_USECUTS:\n            val = cps->use_cuts; break;\n         case LPX_K_BFTYPE:\n            {  glp_bfcp parm;\n               glp_get_bfcp(lp, &parm);\n               switch (parm.type)\n               {  case GLP_BF_FT:\n                     val = 1; break;\n                  case GLP_BF_BG:\n                     val = 2; break;\n                  case GLP_BF_GR:\n                     val = 3; break;\n                  default:\n                     xassert(lp != lp);\n               }\n            }\n            break;\n         default:\n            xerror(\"lpx_get_int_parm: parm = %d; invalid parameter\\n\",\n               parm);\n      }\n      return val;\n}",
      "lines": 66,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "lpx_set_real_parm": {
      "start_point": [
        1278,
        0
      ],
      "end_point": [
        1341,
        1
      ],
      "content": "void lpx_set_real_parm(LPX *lp, int parm, double val)\n{     /* set (change) real control parameter */\n      struct CPS *cps = find_cps(lp);\n      switch (parm)\n      {  case LPX_K_RELAX:\n            if (!(0.0 <= val && val <= 1.0))\n               xerror(\"lpx_set_real_parm: RELAX = %g; invalid value\\n\",\n                  val);\n            cps->relax = val;\n            break;\n         case LPX_K_TOLBND:\n            if (!(DBL_EPSILON <= val && val <= 0.001))\n               xerror(\"lpx_set_real_parm: TOLBND = %g; invalid value\\n\",\n                  val);\n            cps->tol_bnd = val;\n            break;\n         case LPX_K_TOLDJ:\n            if (!(DBL_EPSILON <= val && val <= 0.001))\n               xerror(\"lpx_set_real_parm: TOLDJ = %g; invalid value\\n\",\n                  val);\n            cps->tol_dj = val;\n            break;\n         case LPX_K_TOLPIV:\n            if (!(DBL_EPSILON <= val && val <= 0.001))\n               xerror(\"lpx_set_real_parm: TOLPIV = %g; invalid value\\n\",\n                  val);\n            cps->tol_piv = val;\n            break;\n         case LPX_K_OBJLL:\n            cps->obj_ll = val;\n            break;\n         case LPX_K_OBJUL:\n            cps->obj_ul = val;\n            break;\n         case LPX_K_TMLIM:\n            cps->tm_lim = val;\n            break;\n         case LPX_K_OUTDLY:\n            cps->out_dly = val;\n            break;\n         case LPX_K_TOLINT:\n            if (!(DBL_EPSILON <= val && val <= 0.001))\n               xerror(\"lpx_set_real_parm: TOLINT = %g; invalid value\\n\",\n                  val);\n            cps->tol_int = val;\n            break;\n         case LPX_K_TOLOBJ:\n            if (!(DBL_EPSILON <= val && val <= 0.001))\n               xerror(\"lpx_set_real_parm: TOLOBJ = %g; invalid value\\n\",\n                  val);\n            cps->tol_obj = val;\n            break;\n         case LPX_K_MIPGAP:\n            if (val < 0.0)\n               xerror(\"lpx_set_real_parm: MIPGAP = %g; invalid value\\n\",\n                  val);\n            cps->mip_gap = val;\n            break;\n         default:\n            xerror(\"lpx_set_real_parm: parm = %d; invalid parameter\\n\",\n               parm);\n      }\n      return;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "lpx_get_real_parm": {
      "start_point": [
        1343,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "double lpx_get_real_parm(LPX *lp, int parm)\n{     /* query real control parameter */\n      struct CPS *cps = find_cps(lp);\n      double val = 0.0;\n      switch (parm)\n      {  case LPX_K_RELAX:\n            val = cps->relax;\n            break;\n         case LPX_K_TOLBND:\n            val = cps->tol_bnd;\n            break;\n         case LPX_K_TOLDJ:\n            val = cps->tol_dj;\n            break;\n         case LPX_K_TOLPIV:\n            val = cps->tol_piv;\n            break;\n         case LPX_K_OBJLL:\n            val = cps->obj_ll;\n            break;\n         case LPX_K_OBJUL:\n            val = cps->obj_ul;\n            break;\n         case LPX_K_TMLIM:\n            val = cps->tm_lim;\n            break;\n         case LPX_K_OUTDLY:\n            val = cps->out_dly;\n            break;\n         case LPX_K_TOLINT:\n            val = cps->tol_int;\n            break;\n         case LPX_K_TOLOBJ:\n            val = cps->tol_obj;\n            break;\n         case LPX_K_MIPGAP:\n            val = cps->mip_gap;\n            break;\n         default:\n            xerror(\"lpx_get_real_parm: parm = %d; invalid parameter\\n\",\n               parm);\n      }\n      return val;\n}",
      "lines": 44,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "lpx_read_mps": {
      "start_point": [
        1388,
        0
      ],
      "end_point": [
        1394,
        1
      ],
      "content": "LPX *lpx_read_mps(const char *fname)\n{     /* read problem data in fixed MPS format */\n      LPX *lp = lpx_create_prob();\n      if (glp_read_mps(lp, GLP_MPS_DECK, NULL, fname))\n         lpx_delete_prob(lp), lp = NULL;\n      return lp;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "LPX",
        "*lpx_read_mps(const char *fname)",
        "*"
      ]
    },
    "lpx_write_mps": {
      "start_point": [
        1396,
        0
      ],
      "end_point": [
        1399,
        1
      ],
      "content": "int lpx_write_mps(LPX *lp, const char *fname)\n{     /* write problem data in fixed MPS format */\n      return glp_write_mps(lp, GLP_MPS_DECK, NULL, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_read_bas": {
      "start_point": [
        1401,
        0
      ],
      "end_point": [
        1407,
        1
      ],
      "content": "int lpx_read_bas(LPX *lp, const char *fname)\n{     /* read LP basis in fixed MPS format */\n      xassert(lp == lp);\n      xassert(fname == fname);\n      xerror(\"lpx_read_bas: operation not supported\\n\");\n      return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "lpx_write_bas": {
      "start_point": [
        1409,
        0
      ],
      "end_point": [
        1415,
        1
      ],
      "content": "int lpx_write_bas(LPX *lp, const char *fname)\n{     /* write LP basis in fixed MPS format */\n      xassert(lp == lp);\n      xassert(fname == fname);\n      xerror(\"lpx_write_bas: operation not supported\\n\");\n      return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "lpx_read_freemps": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1423,
        1
      ],
      "content": "LPX *lpx_read_freemps(const char *fname)\n{     /* read problem data in free MPS format */\n      LPX *lp = lpx_create_prob();\n      if (glp_read_mps(lp, GLP_MPS_FILE, NULL, fname))\n         lpx_delete_prob(lp), lp = NULL;\n      return lp;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "LPX",
        "*lpx_read_freemps(const char *fname)",
        "*"
      ]
    },
    "lpx_write_freemps": {
      "start_point": [
        1425,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "int lpx_write_freemps(LPX *lp, const char *fname)\n{     /* write problem data in free MPS format */\n      return glp_write_mps(lp, GLP_MPS_FILE, NULL, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_read_cpxlp": {
      "start_point": [
        1430,
        0
      ],
      "end_point": [
        1437,
        1
      ],
      "content": "LPX *lpx_read_cpxlp(const char *fname)\n{     /* read problem data in CPLEX LP format */\n      LPX *lp;\n      lp = lpx_create_prob();\n      if (glp_read_lp(lp, NULL, fname))\n         lpx_delete_prob(lp), lp = NULL;\n      return lp;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "LPX",
        "*lpx_read_cpxlp(const char *fname)",
        "*"
      ]
    },
    "lpx_write_cpxlp": {
      "start_point": [
        1439,
        0
      ],
      "end_point": [
        1442,
        1
      ],
      "content": "int lpx_write_cpxlp(LPX *lp, const char *fname)\n{     /* write problem data in CPLEX LP format */\n      return glp_write_lp(lp, NULL, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_read_model": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1465,
        1
      ],
      "content": "LPX *lpx_read_model(const char *model, const char *data, const char\n      *output)\n{     /* read LP/MIP model written in GNU MathProg language */\n      LPX *lp = NULL;\n      glp_tran *tran;\n      /* allocate the translator workspace */\n      tran = glp_mpl_alloc_wksp();\n      /* read model section and optional data section */\n      if (glp_mpl_read_model(tran, model, data != NULL)) goto done;\n      /* read separate data section, if required */\n      if (data != NULL)\n         if (glp_mpl_read_data(tran, data)) goto done;\n      /* generate the model */\n      if (glp_mpl_generate(tran, output)) goto done;\n      /* build the problem instance from the model */\n      lp = lpx_create_prob();\n      glp_mpl_build_prob(tran, lp);\ndone: /* free the translator workspace */\n      glp_mpl_free_wksp(tran);\n      /* bring the problem object to the calling program */\n      return lp;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "LPX",
        "*lpx_read_model(const char *model, const char *data, const char\n      *output)",
        "*"
      ]
    },
    "lpx_print_prob": {
      "start_point": [
        1467,
        0
      ],
      "end_point": [
        1470,
        1
      ],
      "content": "int lpx_print_prob(LPX *lp, const char *fname)\n{     /* write problem data in plain text format */\n      return glp_write_lp(lp, NULL, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_print_sol": {
      "start_point": [
        1472,
        0
      ],
      "end_point": [
        1475,
        1
      ],
      "content": "int lpx_print_sol(LPX *lp, const char *fname)\n{     /* write LP problem solution in printable format */\n      return glp_print_sol(lp, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_print_sens_bnds": {
      "start_point": [
        1477,
        0
      ],
      "end_point": [
        1482,
        1
      ],
      "content": "int lpx_print_sens_bnds(LPX *lp, const char *fname)\n{     /* write bounds sensitivity information */\n      if (glp_get_status(lp) == GLP_OPT && !glp_bf_exists(lp))\n         glp_factorize(lp);\n      return glp_print_ranges(lp, 0, NULL, 0, fname);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "lpx_print_ips": {
      "start_point": [
        1484,
        0
      ],
      "end_point": [
        1487,
        1
      ],
      "content": "int lpx_print_ips(LPX *lp, const char *fname)\n{     /* write interior point solution in printable format */\n      return glp_print_ipt(lp, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_print_mip": {
      "start_point": [
        1489,
        0
      ],
      "end_point": [
        1492,
        1
      ],
      "content": "int lpx_print_mip(LPX *lp, const char *fname)\n{     /* write MIP problem solution in printable format */\n      return glp_print_mip(lp, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_is_b_avail": {
      "start_point": [
        1494,
        0
      ],
      "end_point": [
        1497,
        1
      ],
      "content": "int lpx_is_b_avail(glp_prob *lp)\n{     /* check if LP basis is available */\n      return glp_bf_exists(lp);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "lpx_main": {
      "start_point": [
        1499,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "int lpx_main(int argc, const char *argv[])\n{     /* stand-alone LP/MIP solver */\n      return glp_main(argc, argv);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/oldapi/lpx.h": {},
  "glpk/glpk-4.65/examples/oldapi/lpxsamp.c": {
    "main": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int main(void)\n{     LPX *lp;\n      int ia[1+1000], ja[1+1000];\n      double ar[1+1000], Z, x1, x2, x3;\ns1:   lp = lpx_create_prob();\ns2:   lpx_set_prob_name(lp, \"sample\");\ns3:   lpx_set_obj_dir(lp, LPX_MAX);\ns4:   lpx_add_rows(lp, 3);\ns5:   lpx_set_row_name(lp, 1, \"p\");\ns6:   lpx_set_row_bnds(lp, 1, LPX_UP, 0.0, 100.0);\ns7:   lpx_set_row_name(lp, 2, \"q\");\ns8:   lpx_set_row_bnds(lp, 2, LPX_UP, 0.0, 600.0);\ns9:   lpx_set_row_name(lp, 3, \"r\");\ns10:  lpx_set_row_bnds(lp, 3, LPX_UP, 0.0, 300.0);\ns11:  lpx_add_cols(lp, 3);\ns12:  lpx_set_col_name(lp, 1, \"x1\");\ns13:  lpx_set_col_bnds(lp, 1, LPX_LO, 0.0, 0.0);\ns14:  lpx_set_obj_coef(lp, 1, 10.0);\ns15:  lpx_set_col_name(lp, 2, \"x2\");\ns16:  lpx_set_col_bnds(lp, 2, LPX_LO, 0.0, 0.0);\ns17:  lpx_set_obj_coef(lp, 2, 6.0);\ns18:  lpx_set_col_name(lp, 3, \"x3\");\ns19:  lpx_set_col_bnds(lp, 3, LPX_LO, 0.0, 0.0);\ns20:  lpx_set_obj_coef(lp, 3, 4.0);\ns21:  ia[1] = 1, ja[1] = 1, ar[1] =  1.0; /* a[1,1] =  1 */\ns22:  ia[2] = 1, ja[2] = 2, ar[2] =  1.0; /* a[1,2] =  1 */\ns23:  ia[3] = 1, ja[3] = 3, ar[3] =  1.0; /* a[1,3] =  1 */\ns24:  ia[4] = 2, ja[4] = 1, ar[4] = 10.0; /* a[2,1] = 10 */\ns25:  ia[5] = 3, ja[5] = 1, ar[5] =  2.0; /* a[3,1] =  2 */\ns26:  ia[6] = 2, ja[6] = 2, ar[6] =  4.0; /* a[2,2] =  4 */\ns27:  ia[7] = 3, ja[7] = 2, ar[7] =  2.0; /* a[3,2] =  2 */\ns28:  ia[8] = 2, ja[8] = 3, ar[8] =  5.0; /* a[2,3] =  5 */\ns29:  ia[9] = 3, ja[9] = 3, ar[9] =  6.0; /* a[3,3] =  6 */\ns30:  lpx_load_matrix(lp, 9, ia, ja, ar);\ns31:  lpx_simplex(lp);\ns32:  Z = lpx_get_obj_val(lp);\ns33:  x1 = lpx_get_col_prim(lp, 1);\ns34:  x2 = lpx_get_col_prim(lp, 2);\ns35:  x3 = lpx_get_col_prim(lp, 3);\ns36:  printf(\"\\nZ = %g; x1 = %g; x2 = %g; x3 = %g\\n\", Z, x1, x2, x3);\ns37:  lpx_delete_prob(lp);\n      return 0;\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/threads/multiseed.c": {
    "term_hook": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int term_hook(void *info, const char *text)\n{\n   struct task *task = (struct task *) info;\n   size_t len = strlen(text);\n\n   /* Lock mutex so this is the only task creating console output. */\n   pthread_mutex_lock(&mutex);\n\n   /* Append the new text to the buffer. */\n   if (task->pos + len > BUFLEN) {\n      printf(\"%02d-%05d %s%s\", task->seed, ++task->line, task->buf, text);\n      task->pos = 0;\n      task->buf[0] = 0;\n   } else {\n      strcpy(task->buf + task->pos, text);\n      task->pos += len;\n   }\n\n   /* If a complete line is available, send it to the console. */\n   if (strchr(task->buf, '\\n')) {\n      printf(\"%02d-%05d %s\", task->seed, ++task->line, task->buf);\n      task->pos = 0;\n      task->buf[0] = 0;\n   }\n\n   /* Unlock the mutex. */\n   pthread_mutex_unlock(&mutex);\n\n   /* Disable default output. */\n   return -1;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "error_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void error_hook(void *info)\n{\n   struct task *task = (struct task *) info;\n\n   term_hook(task, \"Error caught\\n\");\n   glp_free_env();\n   longjmp(task->jmp, 1);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "worker": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void worker(void *arg)\n{\n   struct task *task = (struct task *) arg;\n   int ret;\n   glp_prob *lp;\n   glp_tran *tran;\n   glp_iocp iocp;\n\n   if (setjmp(task->jmp)) {\n      /* If an error is caught leave the function. */\n      return;\n   }\n\n   /* Set the error handler. */\n   glp_error_hook(error_hook, task);\n\n   /* Set the console output handler. */\n   glp_term_hook(term_hook, arg);\n\n   glp_printf(\"Seed %02d\\n\", task->seed);\n\n   /* Create the problem object. */\n   lp = glp_create_prob();\n   if (!lp) {\n      glp_error(\"Out of memory\\n\");\n   }\n\n   /* Create the MathProg translator workspace. */\n   tran = glp_mpl_alloc_wksp();\n   if (!lp) {\n      glp_error(\"Out of memory\\n\");\n   }\n\n   /* Set the pseudo random number generator seed. */\n   glp_mpl_init_rand(tran, task->seed);\n\n   /* Read the model file. */\n   ret = glp_mpl_read_model (tran, task->filename, GLP_OFF);\n   if (ret != 0) {\n      glp_error(\"Model %s is not valid\\n\", task->filename);\n   }\n\n   /* Generate the model. */\n   ret = glp_mpl_generate(tran, NULL);\n   if (ret != 0) {\n      glp_error(\"Cannot generate model %s\\n\", task->filename);\n   }\n\n   /* Build the problem. */\n   glp_mpl_build_prob(tran, lp);\n\n   /* Solve the problem. */\n   glp_init_iocp(&iocp);\n   iocp.presolve = GLP_ON;\n   ret = glp_intopt(lp, &iocp);\n   if (ret == 0) {\n      /* Execute the post solve part of the model. */\n      glp_mpl_postsolve(tran, lp, GLP_MIP);\n   }\n\n   /* Release the memory. */\n   glp_mpl_free_wksp (tran);\n   glp_delete_prob(lp);\n\n   if (0 == task->seed % 3) {\n      glp_error(\"Voluntarily throwing an error in %s at line %d\\n\",\n                __FILE__, __LINE__);\n   }\n\n   glp_term_hook(NULL, NULL);\n\n   glp_error_hook(NULL, NULL);\n\n   glp_free_env();\n}",
      "lines": 75,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "run": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void *run(void *arg)\n{\n#endif\n   worker(arg);\n   pthread_exit(NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void",
        "*run(void *arg)",
        "*"
      ]
    },
    "main": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "int main(int argc, char *argv[])\n{\n   int i, n, rc;\n   struct task *tasks;\n\n   /* Make sure thread local memory is used by the GLPK library. */\n   if (!glp_config(\"TLS\")) {\n      printf(\"The loaded GLPK library does not support thread local memory.\\n\"\n        \"You need a version of the library configured with \"\n\t\"--enable-reentrant=yes to run this program.\\n\");\n      exit(EXIT_FAILURE);\n   }\n\n   /* Check program arguments. */\n   if (argc != 3) {\n      printf(\"Usage %s filename threads\\n\"\n             \"  filename - MathProg model file\\n\"\n             \"  threads  - number of threads\\n\",\n             argv[0]);\n      exit(EXIT_FAILURE);\n   }\n\n   /* Parse the arguments. */\n   n = atoi(argv[2]);\n   if (n > 50) {\n      printf(\"Number of threads is to high (> 50).\\n\");\n      exit(EXIT_FAILURE);\n   }\n   if (n <= 1) {\n      printf(\"Need positive number of threads\\n\");\n      exit(EXIT_FAILURE);\n   }\n\n   /* Allocate memory for the task descriptors. */\n   tasks = calloc(n, sizeof(struct task));\n   if (!tasks) {\n      printf(\"Out of memory\");\n      exit(EXIT_FAILURE);\n   }\n\n   /* Create a mutex for console output. */\n   pthread_mutex_init(&mutex, NULL);\n\n   /* Create the threads. */\n   for (i = 0; i < n; ++i) {\n      tasks[i].filename = argv[1];\n      tasks[i].seed = i + 1;\n      tasks[i].pos = 0;\n      tasks[i].buf[0] = 0;\n      tasks[i].line = 0;\n      rc = pthread_create(&tasks[i].tid, NULL, run, &tasks[i]);\n      if (rc) {\n         printf(\"ERROR; return code from pthread_create() is %d\\n\", rc);\n         exit(EXIT_FAILURE);\n      }\n   }\n\n   /* Wait for all threads to complete. */\n   for (i = 0; i < n; ++i) {\n      pthread_join(tasks[i].tid, NULL);\n   }\n\n   /* Destroy the mutex. */\n   pthread_mutex_destroy(&mutex);\n\n   return EXIT_SUCCESS;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/threads/thread.h": {},
  "glpk/glpk-4.65/examples/tsp/main.c": {
    "loc": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int loc(int i, int j)\n{     xassert(1 <= i && i <= n);\n      xassert(1 <= j && j <= n);\n      xassert(i != j);\n      if (i < j)\n         return ((n - 1) + (n - i + 1)) * (i - 1) / 2 + (j - i);\n      else\n         return loc(j, i);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "read_data": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void read_data(const char *fname)\n{     TSP *tsp;\n      int i, j;\n      tsp = tsp_read_data(fname);\n      if (tsp == NULL)\n      {  xprintf(\"TSP data file processing error\\n\");\n         exit(EXIT_FAILURE);\n      }\n      if (tsp->type != TSP_TSP)\n      {  xprintf(\"Invalid TSP data type\\n\");\n         exit(EXIT_FAILURE);\n      }\n      n = tsp->dimension;\n      xassert(n >= 2);\n      if (n > 32768)\n      {  xprintf(\"TSP instance too large\\n\");\n         exit(EXIT_FAILURE);\n      }\n      c = xalloc(1+loc(n-1, n), sizeof(int));\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n            c[loc(i, j)] = tsp_distance(tsp, i, j);\n      }\n      tsp_free_data(tsp);\n      return;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "build_prob": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void build_prob(void)\n{     int i, j, k, *ind;\n      double *val;\n      char name[50];\n      /* create problem object */\n      P = glp_create_prob();\n      /* add all binary variables (6) */\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n         {  k = glp_add_cols(P, 1);\n            xassert(k == loc(i,j));\n            sprintf(name, \"x[%d,%d]\", i, j);\n            glp_set_col_name(P, k, name);\n            glp_set_col_kind(P, k, GLP_BV);\n            /* set objective coefficient (3) */\n            glp_set_obj_coef(P, k, c[k]);\n         }\n      }\n      /* add all degree constraints (4) */\n      ind = xalloc(1+n, sizeof(int));\n      val = xalloc(1+n, sizeof(double));\n      for (i = 1; i <= n; i++)\n      {  k = glp_add_rows(P, 1);\n         xassert(k == i);\n         sprintf(name, \"v[%d]\", i);\n         glp_set_row_name(P, i, name);\n         glp_set_row_bnds(P, i, GLP_FX, 2, 2);\n         k = 0;\n         for (j = 1; j <= n; j++)\n         {  if (i != j)\n               k++, ind[k] = loc(i,j), val[k] = 1;\n         }\n         xassert(k == n-1);\n         glp_set_mat_row(P, i, n-1, ind, val);\n      }\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "build_tour": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "void build_tour(void)\n{     int i, j, k, kk, *beg, *end;\n      /* solution to MIP should be feasible */\n      switch (glp_mip_status(P))\n      {  case GLP_FEAS:\n         case GLP_OPT:\n            break;\n         default:\n            xassert(P != P);\n      }\n      /* build the list of edges included in the tour */\n      beg = xalloc(1+n, sizeof(int));\n      end = xalloc(1+n, sizeof(int));\n      k = 0;\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n         {  double x;\n            x = glp_mip_col_val(P, loc(i,j));\n            xassert(x == 0 || x == 1);\n            if (x)\n            {  k++;\n               xassert(k <= n);\n               beg[k] = i, end[k] = j;\n            }\n         }\n      }\n      xassert(k == n);\n      /* reorder edges in the list as they follow in the tour */\n      for (k = 1; k <= n; k++)\n      {  /* find k-th edge of the tour */\n         j = (k == 1 ? 1 : end[k-1]);\n         for (kk = k; kk <= n; kk++)\n         {  if (beg[kk] == j)\n               break;\n            if (end[kk] == j)\n            {  end[kk] = beg[kk], beg[kk] = j;\n               break;\n            }\n         }\n         xassert(kk <= n);\n         /* put the edge to k-th position in the list */\n         i = beg[k], beg[k] = beg[kk], beg[kk] = i;\n         j = end[k], end[k] = end[kk], end[kk] = j;\n      }\n      /* build the tour starting from node 1 */\n      xassert(beg[1] == 1);\n      for (k = 1; k <= n; k++)\n      {  if (k > 1)\n            xassert(end[k-1] == beg[k]);\n         tour[k] = beg[k];\n      }\n      xassert(end[n] == 1);\n      xfree(beg);\n      xfree(end);\n      return;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "tour_length": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "int tour_length(const int tour[/*1+n*/])\n{     int i, j, sum;\n      sum = 0;\n      for (i = 1; i <= n; i++)\n      {  j = (i < n ? i+1 : 1);\n         sum += c[loc(tour[i], tour[j])];\n      }\n      return sum;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "write_tour": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void write_tour(const char *fname, const int tour[/*1+n*/])\n{     FILE *fp;\n      int i;\n      xprintf(\"Writing TSP solution to '%s'...\\n\", fname);\n      fp = fopen(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname,\n            strerror(errno));\n         return;\n      }\n      fprintf(fp, \"NAME : %s\\n\", fname);\n      fprintf(fp, \"COMMENT : Tour length is %d\\n\", tour_length(tour));\n      fprintf(fp, \"TYPE : TOUR\\n\");\n      fprintf(fp, \"DIMENSION : %d\\n\", n);\n      fprintf(fp, \"TOUR_SECTION\\n\");\n      for (i = 1; i <= n; i++)\n         fprintf(fp, \"%d\\n\", tour[i]);\n      fprintf(fp, \"-1\\n\");\n      fprintf(fp, \"EOF\\n\");\n      fclose(fp);\n      return;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "gen_subt": {
      "start_point": [
        330,
        0
      ],
      "end_point": [
        410,
        1
      ],
      "content": "void gen_subt(glp_tree *T)\n{     int i, j, ne, nz, *beg, *end, *cap, *cut, *ind;\n      double sum, *val;\n      /* MIP preprocessor should not be used */\n      xassert(glp_ios_get_prob(T) == P);\n      /* if some variable x[i,j] is zero in basic solution, then the\n       * capacity of corresponding edge in the associated network is\n       * zero, so we may not include such edge in the network */\n      /* count number of edges having non-zero capacity */\n      ne = 0;\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n         {  if (glp_get_col_prim(P, loc(i,j)) >= .001)\n               ne++;\n         }\n      }\n      /* build the capacitated network */\n      beg = xalloc(1+ne, sizeof(int));\n      end = xalloc(1+ne, sizeof(int));\n      cap = xalloc(1+ne, sizeof(int));\n      nz = 0;\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n         {  if (glp_get_col_prim(P, loc(i,j)) >= .001)\n            {  nz++;\n               xassert(nz <= ne);\n               beg[nz] = i, end[nz] = j;\n               /* scale all edge capacities to make them integral */\n               cap[nz] = ceil(1000 * glp_get_col_prim(P, loc(i,j)));\n            }\n         }\n      }\n      xassert(nz == ne);\n      /* find minimal cut in the capacitated network */\n      cut = xalloc(1+n, sizeof(int));\n      min_cut(n, ne, beg, end, cap, cut);\n      /* determine the number of non-zero coefficients in the subtour\n       * elimination constraint and calculate its left-hand side which\n       * is the (unscaled) capacity of corresponding min cut */\n      ne = 0, sum = 0;\n      for (i = 1; i <= n; i++)\n      {  for (j = i+1; j <= n; j++)\n         {  if (cut[i] && !cut[j] || !cut[i] && cut[j])\n            {  ne++;\n               sum += glp_get_col_prim(P, loc(i,j));\n            }\n         }\n      }\n      /* if the (unscaled) capacity of min cut is less than 2, the\n       * corresponding subtour elimination constraint is violated */\n      if (sum <= 1.999)\n      {  /* build the list of non-zero coefficients */\n         ind = xalloc(1+ne, sizeof(int));\n         val = xalloc(1+ne, sizeof(double));\n         nz = 0;\n         for (i = 1; i <= n; i++)\n         {  for (j = i+1; j <= n; j++)\n            {  if (cut[i] && !cut[j] || !cut[i] && cut[j])\n               {  nz++;\n                  xassert(nz <= ne);\n                  ind[nz] = loc(i,j);\n                  val[nz] = 1;\n               }\n            }\n         }\n         xassert(nz == ne);\n         /* add violated tour elimination constraint to the current\n          * subproblem */\n         i = glp_add_rows(P, 1);\n         glp_set_row_bnds(P, i, GLP_LO, 2, 0);\n         glp_set_mat_row(P, i, nz, ind, val);\n         xfree(ind);\n         xfree(val);\n      }\n      /* free working arrays */\n      xfree(beg);\n      xfree(end);\n      xfree(cap);\n      xfree(cut);\n      return;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "cb_func": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void cb_func(glp_tree *T, void *info)\n{     xassert(info == info);\n      switch (glp_ios_reason(T))\n      {  case GLP_IROWGEN:\n            /* generate one violated subtour elimination constraint */\n            gen_subt(T);\n            break;\n      }\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "int main(int argc, char *argv[])\n{     int j;\n      char *in_file = NULL, *out_file = NULL;\n      time_t start;\n      glp_iocp iocp;\n      /* parse command-line arguments */\n#     define p(str) (strcmp(argv[j], str) == 0)\n      for (j = 1; j < argc; j++)\n      {  if (p(\"--output\") || p(\"-o\"))\n         {  j++;\n            if (j == argc || argv[j][0] == '\\0' || argv[j][0] == '-')\n            {  xprintf(\"No solution output file specified\\n\");\n               exit(EXIT_FAILURE);\n            }\n            if (out_file != NULL)\n            {  xprintf(\"Only one solution output file allowed\\n\");\n               exit(EXIT_FAILURE);\n            }\n            out_file = argv[j];\n         }\n         else if (p(\"--help\") || p(\"-h\"))\n         {  xprintf(\"Usage: %s [options...] tsp-file\\n\", argv[0]);\n            xprintf(\"\\n\");\n            xprintf(\"Options:\\n\");\n            xprintf(\"   -o filename, --output filename\\n\");\n            xprintf(\"                     write solution to filename\\n\")\n               ;\n            xprintf(\"   -h, --help        display this help information\"\n               \" and exit\\n\");\n            exit(EXIT_SUCCESS);\n         }\n         else if (argv[j][0] == '-' ||\n                 (argv[j][0] == '-' && argv[j][1] == '-'))\n         {  xprintf(\"Invalid option '%s'; try %s --help\\n\", argv[j],\n               argv[0]);\n            exit(EXIT_FAILURE);\n         }\n         else\n         {  if (in_file != NULL)\n            {  xprintf(\"Only one input file allowed\\n\");\n               exit(EXIT_FAILURE);\n            }\n            in_file = argv[j];\n         }\n      }\n      if (in_file == NULL)\n      {  xprintf(\"No input file specified; try %s --help\\n\", argv[0]);\n         exit(EXIT_FAILURE);\n      }\n#     undef p\n      /* display program banner */\n      xprintf(\"TSP Solver for GLPK %s\\n\", glp_version());\n      /* remove output solution file specified in command-line */\n      if (out_file != NULL)\n         remove(out_file);\n      /* read TSP instance from input data file */\n      read_data(in_file);\n      /* build initial IP problem */\n      start = time(NULL);\n      build_prob();\n      tour = xalloc(1+n, sizeof(int));\n      /* solve LP relaxation of initial IP problem */\n      xprintf(\"Solving initial LP relaxation...\\n\");\n      xassert(glp_simplex(P, NULL) == 0);\n      xassert(glp_get_status(P) == GLP_OPT);\n      /* solve IP problem with \"lazy\" constraints */\n      glp_init_iocp(&iocp);\n      iocp.br_tech = GLP_BR_MFV; /* most fractional variable */\n      iocp.bt_tech = GLP_BT_BLB; /* best local bound */\n      iocp.sr_heur = GLP_OFF; /* disable simple rounding heuristic */\n      iocp.gmi_cuts = GLP_ON; /* enable Gomory cuts */\n      iocp.cb_func = cb_func;\n      glp_intopt(P, &iocp);\n      build_tour();\n      /* display some statistics */\n      xprintf(\"Time used:   %.1f secs\\n\", difftime(time(NULL), start));\n      {  size_t tpeak;\n         glp_mem_usage(NULL, NULL, NULL, &tpeak);\n         xprintf(\"Memory used: %.1f Mb (%.0f bytes)\\n\",\n            (double)tpeak / 1048576.0, (double)tpeak);\n      }\n      /* write solution to output file, if required */\n      if (out_file != NULL)\n         write_tour(out_file, tour);\n      /* deallocate working objects */\n      xfree(c);\n      xfree(tour);\n      glp_delete_prob(P);\n      /* check that no memory blocks are still allocated */\n      {  int count;\n         size_t total;\n         glp_mem_usage(&count, NULL, &total, NULL);\n         if (count != 0)\n            xerror(\"Error: %d memory block(s) were lost\\n\", count);\n         xassert(total == 0);\n      }\n      return 0;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/tsp/maxflow.c": {
    "max_flow": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int max_flow(int nn, int ne, const int beg[/*1+ne*/],\n      const int end[/*1+ne*/], const int cap[/*1+ne*/], int s, int t,\n      int x[/*1+ne*/])\n{     int k;\n      /* sanity checks */\n      xassert(nn >= 2);\n      xassert(ne >= 0);\n      xassert(1 <= s && s <= nn);\n      xassert(1 <= t && t <= nn);\n      xassert(s != t);\n      for (k = 1; k <= ne; k++)\n      {  xassert(1 <= beg[k] && beg[k] < end[k] && end[k] <= nn);\n         xassert(cap[k] > 0);\n      }\n      /* find max flow */\n      return max_flow_lp(nn, ne, beg, end, cap, s, t, x);\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "max_flow_lp": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int max_flow_lp(int nn, int ne, const int beg[/*1+ne*/],\n      const int end[/*1+ne*/], const int cap[/*1+ne*/], int s, int t,\n      int x[/*1+ne*/])\n{     glp_prob *lp;\n      glp_smcp smcp;\n      int i, k, nz, flow, *rn, *cn;\n      double temp, *aa;\n      /* create LP problem instance */\n      lp = glp_create_prob();\n      /* create LP rows; i-th row is the conservation condition of the\n       * flow at i-th node, i = 1, ..., nn */\n      glp_add_rows(lp, nn);\n      for (i = 1; i <= nn; i++)\n         glp_set_row_bnds(lp, i, GLP_FX, 0.0, 0.0);\n      /* create LP columns; k-th column is the elementary flow thru\n       * k-th edge, k = 1, ..., ne; the last column with the number\n       * ne+1 is the total flow through the network, which goes along\n       * a dummy feedback edge from the sink to the source */\n      glp_add_cols(lp, ne+1);\n      for (k = 1; k <= ne; k++)\n      {  xassert(cap[k] > 0);\n         glp_set_col_bnds(lp, k, GLP_DB, -cap[k], +cap[k]);\n      }\n      glp_set_col_bnds(lp, ne+1, GLP_FR, 0.0, 0.0);\n      /* build the constraint matrix; structurally this matrix is the\n       * incidence matrix of the network, so each its column (including\n       * the last column for the dummy edge) has exactly two non-zero\n       * entries */\n      rn = xalloc(1+2*(ne+1), sizeof(int));\n      cn = xalloc(1+2*(ne+1), sizeof(int));\n      aa = xalloc(1+2*(ne+1), sizeof(double));\n      nz = 0;\n      for (k = 1; k <= ne; k++)\n      {  /* x[k] > 0 means the elementary flow thru k-th edge goes from\n          * node beg[k] to node end[k] */\n         nz++, rn[nz] = beg[k], cn[nz] = k, aa[nz] = -1.0;\n         nz++, rn[nz] = end[k], cn[nz] = k, aa[nz] = +1.0;\n      }\n      /* total flow thru the network goes from the sink to the source\n       * along the dummy feedback edge */\n      nz++, rn[nz] = t, cn[nz] = ne+1, aa[nz] = -1.0;\n      nz++, rn[nz] = s, cn[nz] = ne+1, aa[nz] = +1.0;\n      /* check the number of non-zero entries */\n      xassert(nz == 2*(ne+1));\n      /* load the constraint matrix into the LP problem object */\n      glp_load_matrix(lp, nz, rn, cn, aa);\n      xfree(rn);\n      xfree(cn);\n      xfree(aa);\n      /* objective function is the total flow through the network to\n       * be maximized */\n      glp_set_obj_dir(lp, GLP_MAX);\n      glp_set_obj_coef(lp, ne + 1, 1.0);\n      /* solve LP instance with the (primal) simplex method */\n      glp_term_out(0);\n      glp_adv_basis(lp, 0);\n      glp_term_out(1);\n      glp_init_smcp(&smcp);\n      smcp.msg_lev = GLP_MSG_ON;\n      smcp.out_dly = 5000;\n      xassert(glp_simplex(lp, &smcp) == 0);\n      xassert(glp_get_status(lp) == GLP_OPT);\n      /* obtain optimal elementary flows thru edges of the network */\n      /* (note that the constraint matrix is unimodular and the data\n       * are integral, so all elementary flows in basic solution should\n       * also be integral) */\n      for (k = 1; k <= ne; k++)\n      {  temp = glp_get_col_prim(lp, k);\n         x[k] = (int)floor(temp + .5);\n         xassert(fabs(x[k] - temp) <= 1e-6);\n      }\n      /* obtain the maximum flow thru the original network which is the\n       * flow thru the dummy feedback edge */\n      temp = glp_get_col_prim(lp, ne+1);\n      flow = (int)floor(temp + .5);\n      xassert(fabs(flow - temp) <= 1e-6);\n      /* delete LP problem instance */\n      glp_delete_prob(lp);\n      /* return to the calling program */\n      return flow;\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/tsp/maxflow.h": {},
  "glpk/glpk-4.65/examples/tsp/mincut.c": {
    "min_cut": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int min_cut(int nn, int ne, const int beg[/*1+ne*/],\n      const int end[/*1+ne*/], const cap[/*1+ne*/], int cut[/*1+nn*/])\n{     int k;\n      /* sanity checks */\n      xassert(nn >= 2);\n      xassert(ne >= 0);\n      for (k = 1; k <= ne; k++)\n      {  xassert(1 <= beg[k] && beg[k] < end[k] && end[k] <= nn);\n         xassert(cap[k] > 0);\n      }\n      /* find min cut */\n      return min_cut_sw(nn, ne, beg, end, cap, cut);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "min_st_cut": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int min_st_cut(int nn, int ne, const int beg[/*1+ne*/],\n      const int end[/*1+ne*/], const int cap[/*1+ne*/], int s, int t,\n      const int x[/*1+ne*/], int cut[/*1+nn*/])\n{     int i, j, k, p, q, temp, *head1, *next1, *head2, *next2, *list;\n      /* head1[i] points to the first edge with beg[k] = i\n       * next1[k] points to the next edge with the same beg[k]\n       * head2[i] points to the first edge with end[k] = i\n       * next2[k] points to the next edge with the same end[k] */\n      head1 = xalloc(1+nn, sizeof(int));\n      head2 = xalloc(1+nn, sizeof(int));\n      next1 = xalloc(1+ne, sizeof(int));\n      next2 = xalloc(1+ne, sizeof(int));\n      for (i = 1; i <= nn; i++)\n         head1[i] = head2[i] = 0;\n      for (k = 1; k <= ne; k++)\n      {  i = beg[k], next1[k] = head1[i], head1[i] = k;\n         j = end[k], next2[k] = head2[j], head2[j] = k;\n      }\n      /* on constructing the set V(s) list[1], ..., list[p-1] contain\n       * nodes, which can be reached from source node and have been\n       * visited, and list[p], ..., list[q] contain nodes, which can be\n       * reached from source node but havn't been visited yet */\n      list = xalloc(1+nn, sizeof(int));\n      for (i = 1; i <= nn; i++)\n         cut[i] = 0;\n      p = q = 1, list[1] = s, cut[s] = 1;\n      while (p <= q)\n      {  /* pick next node, which is reachable from the source node and\n          * has not visited yet, and visit it */\n         i = list[p++];\n         /* walk through edges with beg[k] = i */\n         for (k = head1[i]; k != 0; k = next1[k])\n         {  j = end[k];\n            xassert(beg[k] == i);\n            /* from v[i] we can reach v[j], if the elementary flow from\n             * v[i] to v[j] is non-saturated */\n            if (cut[j] == 0 && x[k] < +cap[k])\n               list[++q] = j, cut[j] = 1;\n         }\n         /* walk through edges with end[k] = i */\n         for (k = head2[i]; k != 0; k = next2[k])\n         {  j = beg[k];\n            xassert(end[k] == i);\n            /* from v[i] we can reach v[j], if the elementary flow from\n             * v[i] to v[j] is non-saturated */\n            if (cut[j] == 0 && x[k] > -cap[k])\n               list[++q] = j, cut[j] = 1;\n         }\n      }\n      /* sink cannot belong to V(s) */\n      xassert(!cut[t]);\n      /* free working arrays */\n      xfree(head1);\n      xfree(head2);\n      xfree(next1);\n      xfree(next2);\n      xfree(list);\n      /* compute capacity of the minimal (s,t)-cut found */\n      temp = 0;\n      for (k = 1; k <= ne; k++)\n      {  i = beg[k], j = end[k];\n         if (cut[i] && !cut[j] || !cut[i] && cut[j])\n            temp += cap[k];\n      }\n      /* return to the calling program */\n      return temp;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "min_cut_sw": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "int min_cut_sw(int nn, int ne, const int beg[/*1+ne*/],\n      const int end[/*1+ne*/], const cap[/*1+ne*/], int cut[/*1+nn*/])\n{     int i, j, k, min_cut, flow, temp, *head1, *next1, *head2, *next2;\n      int I, J, K, S, T, DEG, NV, NE, *HEAD, *NEXT, *NUMB, *BEG, *END,\n         *CAP, *X, *ADJ, *SUM, *CUT;\n      /* head1[i] points to the first edge with beg[k] = i\n       * next1[k] points to the next edge with the same beg[k]\n       * head2[i] points to the first edge with end[k] = i\n       * next2[k] points to the next edge with the same end[k] */\n      head1 = xalloc(1+nn, sizeof(int));\n      head2 = xalloc(1+nn, sizeof(int));\n      next1 = xalloc(1+ne, sizeof(int));\n      next2 = xalloc(1+ne, sizeof(int));\n      for (i = 1; i <= nn; i++)\n         head1[i] = head2[i] = 0;\n      for (k = 1; k <= ne; k++)\n      {  i = beg[k], next1[k] = head1[i], head1[i] = k;\n         j = end[k], next2[k] = head2[j], head2[j] = k;\n      }\n      /* an auxiliary network used in the algorithm is resulted from\n       * the original network by merging some nodes into one supernode;\n       * all variables and arrays related to this auxiliary network are\n       * denoted in CAPS */\n      /* HEAD[I] points to the first node of the original network that\n       * belongs to the I-th supernode\n       * NEXT[i] points to the next node of the original network that\n       * belongs to the same supernode as the i-th node\n       * NUMB[i] is a supernode, which the i-th node belongs to */\n      /* initially the auxiliary network is equivalent to the original\n       * network, i.e. each supernode consists of one node */\n      NV = nn;\n      HEAD = xalloc(1+nn, sizeof(int));\n      NEXT = xalloc(1+nn, sizeof(int));\n      NUMB = xalloc(1+nn, sizeof(int));\n      for (i = 1; i <= nn; i++)\n         HEAD[i] = i, NEXT[i] = 0, NUMB[i] = i;\n      /* number of edges in the auxiliary network is never greater than\n       * in the original one */\n      BEG = xalloc(1+ne, sizeof(int));\n      END = xalloc(1+ne, sizeof(int));\n      CAP = xalloc(1+ne, sizeof(int));\n      X = xalloc(1+ne, sizeof(int));\n      /* allocate some auxiliary arrays */\n      ADJ = xalloc(1+nn, sizeof(int));\n      SUM = xalloc(1+nn, sizeof(int));\n      CUT = xalloc(1+nn, sizeof(int));\n      /* currently no min cut is found so far */\n      min_cut = INT_MAX;\n      /* main loop starts here */\n      while (NV > 1)\n      {  /* build the set of edges of the auxiliary network */\n         NE = 0;\n         /* multiple edges are not allowed in the max flow algorithm,\n          * so we can replace each multiple edge, which is the result\n          * of merging nodes into supernodes, by a single edge, whose\n          * capacity is the sum of capacities of particular edges;\n          * these summary capacities will be stored in the array SUM */\n         for (I = 1; I <= NV; I++)\n            SUM[I] = 0.0;\n         for (I = 1; I <= NV; I++)\n         {  /* DEG is number of single edges, which connects I-th\n             * supernode and some J-th supernode, where I < J */\n            DEG = 0;\n            /* walk thru nodes that belong to I-th supernode */\n            for (i = HEAD[I]; i != 0; i = NEXT[i])\n            {  /* i-th node belongs to I-th supernode */\n               /* walk through edges with beg[k] = i */\n               for (k = head1[i]; k != 0; k = next1[k])\n               {  j = end[k];\n                  /* j-th node belongs to J-th supernode */\n                  J = NUMB[j];\n                  /* ignore loops and edges with I > J */\n                  if (I >= J)\n                     continue;\n                  /* add an edge that connects I-th and J-th supernodes\n                   * (if not added yet) */\n                  if (SUM[J] == 0.0)\n                     ADJ[++DEG] = J;\n                  /* sum up the capacity of the original edge */\n                  xassert(cap[k] > 0.0);\n                  SUM[J] += cap[k];\n               }\n               /* walk through edges with end[k] = i */\n               for (k = head2[i]; k != 0; k = next2[k])\n               {  j = beg[k];\n                  /* j-th node belongs to J-th supernode */\n                  J = NUMB[j];\n                  /* ignore loops and edges with I > J */\n                  if (I >= J)\n                     continue;\n                  /* add an edge that connects I-th and J-th supernodes\n                   * (if not added yet) */\n                  if (SUM[J] == 0.0)\n                     ADJ[++DEG] = J;\n                  /* sum up the capacity of the original edge */\n                  xassert(cap[k] > 0.0);\n                  SUM[J] += cap[k];\n               }\n            }\n            /* add single edges connecting I-th supernode with other\n             * supernodes to the auxiliary network; restore the array\n             * SUM for subsequent use */\n            for (K = 1; K <= DEG; K++)\n            {  NE++;\n               xassert(NE <= ne);\n               J = ADJ[K];\n               BEG[NE] = I, END[NE] = J, CAP[NE] = SUM[J];\n               SUM[J] = 0.0;\n            }\n         }\n         /* choose two arbitrary supernodes of the auxiliary network,\n          * one of which is the source and other is the sink */\n         S = 1, T = NV;\n         /* determine max flow from S to T */\n         flow = max_flow(NV, NE, BEG, END, CAP, S, T, X);\n         /* if the min cut that separates supernodes S and T is less\n          * than the currently known, remember it */\n         if (min_cut > flow)\n         {  min_cut = flow;\n            /* find min (s,t)-cut in the auxiliary network */\n            temp = min_st_cut(NV, NE, BEG, END, CAP, S, T, X, CUT);\n            /* (Ford and Fulkerson insist on this) */\n            xassert(flow == temp);\n            /* build corresponding min cut in the original network */\n            for (i = 1; i <= nn; i++) cut[i] = CUT[NUMB[i]];\n            /* if the min cut capacity is zero (i.e. the network has\n             * unconnected components), the search can be prematurely\n             * terminated */\n            if (min_cut == 0)\n               break;\n         }\n         /* now merge all nodes of the original network, which belong\n          * to the supernodes S and T, into one new supernode; this is\n          * attained by carrying all nodes from T to S (for the sake of\n          * convenience T should be the last supernode) */\n         xassert(T == NV);\n         /* assign new references to nodes from T */\n         for (i = HEAD[T]; i != 0; i = NEXT[i])\n            NUMB[i] = S;\n         /* find last entry in the node list of S */\n         i = HEAD[S];\n         xassert(i != 0);\n         while (NEXT[i] != 0)\n            i = NEXT[i];\n         /* and attach to it the node list of T */\n         NEXT[i] = HEAD[T];\n         /* decrease number of nodes in the auxiliary network */\n         NV--;\n      }\n      /* free working arrays */\n      xfree(HEAD);\n      xfree(NEXT);\n      xfree(NUMB);\n      xfree(BEG);\n      xfree(END);\n      xfree(CAP);\n      xfree(X);\n      xfree(ADJ);\n      xfree(SUM);\n      xfree(CUT);\n      xfree(head1);\n      xfree(head2);\n      xfree(next1);\n      xfree(next2);\n      /* return to the calling program */\n      return min_cut;\n}",
      "lines": 167,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/tsp/mincut.h": {},
  "glpk/glpk-4.65/examples/tsp/misc.c": {
    "str2int": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int str2int(const char *str, int *val_)\n{     int d, k, s, val = 0;\n      /* scan optional sign */\n      if (str[0] == '+')\n         s = +1, k = 1;\n      else if (str[0] == '-')\n         s = -1, k = 1;\n      else\n         s = +1, k = 0;\n      /* check for the first digit */\n      if (!isdigit((unsigned char)str[k]))\n         return 2;\n      /* scan digits */\n      while (isdigit((unsigned char)str[k]))\n      {  d = str[k++] - '0';\n         if (s > 0)\n         {  if (val > INT_MAX / 10)\n               return 1;\n            val *= 10;\n            if (val > INT_MAX - d)\n               return 1;\n            val += d;\n         }\n         else /* s < 0 */\n         {  if (val < INT_MIN / 10)\n               return 1;\n            val *= 10;\n            if (val < INT_MIN + d)\n               return 1;\n            val -= d;\n         }\n      }\n      /* check for terminator */\n      if (str[k] != '\\0')\n         return 2;\n      /* conversion has been done */\n      *val_ = val;\n      return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "str2num": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int str2num(const char *str, double *val_)\n{     int k;\n      double val;\n      /* scan optional sign */\n      k = (str[0] == '+' || str[0] == '-' ? 1 : 0);\n      /* check for decimal point */\n      if (str[k] == '.')\n      {  k++;\n         /* a digit should follow it */\n         if (!isdigit((unsigned char)str[k]))\n            return 2;\n         k++;\n         goto frac;\n      }\n      /* integer part should start with a digit */\n      if (!isdigit((unsigned char)str[k]))\n         return 2;\n      /* scan integer part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for decimal point */\n      if (str[k] == '.') k++;\nfrac: /* scan optional fraction part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for decimal exponent */\n      if (str[k] == 'E' || str[k] == 'e')\n      {  k++;\n         /* scan optional sign */\n         if (str[k] == '+' || str[k] == '-')\n            k++;\n         /* a digit should follow E, E+ or E- */\n         if (!isdigit((unsigned char)str[k]))\n            return 2;\n      }\n      /* scan optional exponent part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for terminator */\n      if (str[k] != '\\0')\n         return 2;\n      /* perform conversion */\n      {  char *endptr;\n         val = strtod(str, &endptr);\n         if (*endptr != '\\0')\n            return 2;\n      }\n      /* check for overflow */\n      if (!(-DBL_MAX <= val && val <= +DBL_MAX))\n         return 1;\n      /* check for underflow */\n      if (-DBL_MIN < val && val < +DBL_MIN)\n         val = 0.0;\n      /* conversion has been done */\n      *val_ = val;\n      return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/examples/tsp/misc.h": {},
  "glpk/glpk-4.65/examples/tsp/tsplib.c": {
    "get_char": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int get_char(struct csa *csa)\n{     csa->c = fgetc(csa->fp);\n      if (ferror(csa->fp))\n      {  xprintf(\"%s:%d: read error - %s\\n\", csa->fname, csa->seqn,\n            strerror(errno));\n         return 1;\n      }\n      if (feof(csa->fp))\n         csa->c = EOF;\n      else if (csa->c == '\\n')\n         csa->seqn++;\n      else if (isspace(csa->c))\n         csa->c = ' ';\n      else if (iscntrl(csa->c))\n      {  xprintf(\"%s:%d: invalid control character 0x%02X\\n\",\n            csa->fname, csa->seqn, csa->c);\n         return 1;\n      }\n      return 0;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_spaces": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static int skip_spaces(struct csa *csa, int across)\n{     while (csa->c == ' ' || (across && csa->c == '\\n'))\n         if (get_char(csa)) return 1;\n      return 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_keyword": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int scan_keyword(struct csa *csa)\n{     int len = 0;\n      if (skip_spaces(csa, 0))\n         return 1;\n      if (csa->c == EOF)\n      {  xprintf(\"%s:%d: warning: missing EOF inserted\\n\", csa->fname,\n            csa->seqn);\n         strcpy(csa->token, \"EOF\");\n         return 0;\n      }\n      csa->token[0] = '\\0';\n      while (isalnum(csa->c) || csa->c == '_')\n      {  if (len == 31)\n         {  xprintf(\"%s:%d: keyword '%s...' too long\\n\", csa->fname,\n               csa->seqn, csa->token);\n            return 1;\n         }\n         csa->token[len++] = (char)csa->c, csa->token[len] = '\\0';\n         if (get_char(csa))\n            return 1;\n      }\n      if (len == 0)\n      {  xprintf(\"%s:%d: missing keyword\\n\", csa->fname, csa->seqn);\n         return 1;\n      }\n      return 0;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_colon": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static int check_colon(struct csa *csa)\n{     if (skip_spaces(csa, 0))\n         return 1;\n      if (csa->c != ':')\n      {  xprintf(\"%s:%d: missing colon after '%s'\\n\", csa->fname,\n            csa->seqn, csa->token);\n         return 1;\n      }\n      if (get_char(csa))\n         return 1;\n      return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_token": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static int scan_token(struct csa *csa, int across)\n{     int len = 0;\n      if (skip_spaces(csa, across))\n         return 1;\n      csa->token[0] = '\\0';\n      while (!(csa->c == EOF || csa->c == '\\n' || csa->c == ' '))\n      {  if (len == 255)\n         {  csa->token[31] = '\\0';\n            xprintf(\"%s:%d: token '%s...' too long\\n\", csa->fname,\n               csa->seqn, csa->token);\n            return 1;\n         }\n         csa->token[len++] = (char)csa->c, csa->token[len] = '\\0';\n         if (get_char(csa))\n            return 1;\n      }\n      return 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_newline": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int check_newline(struct csa *csa)\n{     if (skip_spaces(csa, 0))\n         return 1;\n      if (!(csa->c == EOF || csa->c == '\\n'))\n      {  xprintf(\"%s:%d: extra symbols detected\\n\", csa->fname,\n            csa->seqn);\n         return 1;\n      }\n      if (get_char(csa))\n         return 1;\n      return 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_comment": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static int scan_comment(struct csa *csa)\n{     int len = 0;\n      if (skip_spaces(csa, 0))\n         return 1;\n      csa->token[0] = '\\0';\n      while (!(csa->c == EOF || csa->c == '\\n'))\n      {  if (len == 255)\n         {  xprintf(\"%s:%d: comment too long\\n\", csa->fname, csa->seqn);\n            return 1;\n         }\n         csa->token[len++] = (char)csa->c, csa->token[len] = '\\0';\n         if (get_char(csa))\n            return 1;\n      }\n      return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_integer": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static int scan_integer(struct csa *csa, int across, int *val)\n{     if (scan_token(csa, across))\n         return 1;\n      if (strlen(csa->token) == 0)\n      {  xprintf(\"%s:%d: missing integer\\n\", csa->fname, csa->seqn);\n         return 1;\n      }\n      if (str2int(csa->token, val))\n      {  xprintf(\"%s:%d: integer '%s' invalid\\n\", csa->fname, csa->seqn,\n            csa->token);\n         return 1;\n      }\n      return 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_number": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static int scan_number(struct csa *csa, int across, double *val)\n{     if (scan_token(csa, across))\n         return 1;\n      if (strlen(csa->token) == 0)\n      {  xprintf(\"%s:%d: missing number\\n\", csa->fname, csa->seqn);\n         return 1;\n      }\n      if (str2num(csa->token, val))\n      {  xprintf(\"%s:%d: number '%s' invalid\\n\", csa->fname, csa->seqn,\n            csa->token);\n         return 1;\n      }\n      return 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "tsp_read_data": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        597,
        1
      ],
      "content": "TSP *tsp_read_data(const char *fname)\n{     struct csa _dsa, *csa = &_dsa;\n      TSP *tsp = NULL;\n      csa->fname = fname;\n      xprintf(\"Reading TSP data from '%s'...\\n\", csa->fname);\n      csa->fp = fopen(csa->fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", csa->fname,\n            strerror(errno));\n         goto fail;\n      }\n      tsp = xalloc(1, sizeof(TSP));\n      tsp->name = NULL;\n      tsp->type = TSP_UNDEF;\n      tsp->comment = NULL;\n      tsp->dimension = 0;\n      tsp->edge_weight_type = TSP_UNDEF;\n      tsp->edge_weight_format = TSP_UNDEF;\n      tsp->display_data_type = TSP_UNDEF;\n      tsp->node_x_coord = NULL;\n      tsp->node_y_coord = NULL;\n      tsp->dply_x_coord = NULL;\n      tsp->dply_y_coord = NULL;\n      tsp->tour = NULL;\n      tsp->edge_weight = NULL;\n      csa->seqn = 1;\n      if (get_char(csa))\n         goto fail;\nloop: if (scan_keyword(csa))\n         goto fail;\n      if (strcmp(csa->token, \"NAME\") == 0)\n      {  if (tsp->name != NULL)\n         {  xprintf(\"%s:%d: NAME entry multiply defined\\n\", csa->fname,\n               csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_token(csa, 0))\n            goto fail;\n         if (strlen(csa->token) == 0)\n         {  xprintf(\"%s:%d: NAME entry incomplete\\n\", csa->fname,\n               csa->seqn);\n            goto fail;\n         }\n         tsp->name = xalloc(strlen(csa->token)+1, sizeof(char));\n         strcpy(tsp->name, csa->token);\n         xprintf(\"NAME: %s\\n\", tsp->name);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"TYPE\") == 0)\n      {  if (tsp->type != TSP_UNDEF)\n         {  xprintf(\"%s:%d: TYPE entry multiply defined\\n\", csa->fname,\n               csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_keyword(csa))\n            goto fail;\n         if (strcmp(csa->token, \"TSP\") == 0)\n            tsp->type = TSP_TSP;\n         else if (strcmp(csa->token, \"ATSP\") == 0)\n            tsp->type = TSP_ATSP;\n         else if (strcmp(csa->token, \"TOUR\") == 0)\n            tsp->type = TSP_TOUR;\n         else\n         {  xprintf(\"%s:%d: data type '%s' not recognized\\n\",\n               csa->fname, csa->seqn, csa->token);\n            goto fail;\n         }\n         xprintf(\"TYPE: %s\\n\", csa->token);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"COMMENT\") == 0)\n      {  if (check_colon(csa))\n            goto fail;\n         if (scan_comment(csa))\n            goto fail;\n         xprintf(\"COMMENT: %s\\n\", csa->token);\n         if (tsp->comment == NULL)\n         {  tsp->comment = xalloc(strlen(csa->token)+1, sizeof(char));\n            strcpy(tsp->comment, csa->token);\n         }\n         else\n         {  xprintf(\"%s:%d: warning: extra COMMENT entry ignored\\n\",\n               csa->fname, csa->seqn);\n         }\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"DIMENSION\") == 0)\n      {  if (tsp->dimension != 0)\n         {  xprintf(\"%s:%d: DIMENSION entry multiply defined\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_integer(csa, 0, &tsp->dimension))\n            goto fail;\n         if (tsp->dimension < 1)\n         {  xprintf(\"%s:%d: invalid dimension\\n\", csa->fname,\n               csa->seqn);\n            goto fail;\n         }\n         xprintf(\"DIMENSION: %d\\n\", tsp->dimension);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"EDGE_WEIGHT_TYPE\") == 0)\n      {  if (tsp->edge_weight_type != TSP_UNDEF)\n         {  xprintf(\"%s:%d: EDGE_WEIGHT_TYPE entry multiply defined\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_keyword(csa))\n            goto fail;\n         if (strcmp(csa->token, \"GEO\") == 0)\n            tsp->edge_weight_type = TSP_GEO;\n         else if (strcmp(csa->token, \"EUC_2D\") == 0)\n            tsp->edge_weight_type = TSP_EUC_2D;\n         else if (strcmp(csa->token, \"ATT\") == 0)\n            tsp->edge_weight_type = TSP_ATT;\n         else if (strcmp(csa->token, \"EXPLICIT\") == 0)\n            tsp->edge_weight_type = TSP_EXPLICIT;\n         else if (strcmp(csa->token, \"CEIL_2D\") == 0)\n            tsp->edge_weight_type = TSP_CEIL_2D;\n         else\n         {  xprintf(\"%s:%d: edge weight type '%s' not recognized\\n\",\n               csa->fname, csa->seqn, csa->token);\n            goto fail;\n         }\n         xprintf(\"EDGE_WEIGHT_TYPE: %s\\n\", csa->token);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"EDGE_WEIGHT_FORMAT\") == 0)\n      {  if (tsp->edge_weight_format != TSP_UNDEF)\n         {  xprintf(\"%s:%d: EDGE_WEIGHT_FORMAT entry multiply defined\\n\"\n               , csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_keyword(csa))\n            goto fail;\n         if (strcmp(csa->token, \"UPPER_ROW\") == 0)\n            tsp->edge_weight_format = TSP_UPPER_ROW;\n         else if (strcmp(csa->token, \"FULL_MATRIX\") == 0)\n            tsp->edge_weight_format = TSP_FULL_MATRIX;\n         else if (strcmp(csa->token, \"FUNCTION\") == 0)\n            tsp->edge_weight_format = TSP_FUNCTION;\n         else if (strcmp(csa->token, \"LOWER_DIAG_ROW\") == 0)\n            tsp->edge_weight_format = TSP_LOWER_DIAG_ROW;\n         else\n         {  xprintf(\"%s:%d: edge weight format '%s' not recognized\\n\",\n               csa->fname, csa->seqn, csa->token);\n            goto fail;\n         }\n         xprintf(\"EDGE_WEIGHT_FORMAT: %s\\n\", csa->token);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"DISPLAY_DATA_TYPE\") == 0)\n      {  if (tsp->display_data_type != TSP_UNDEF)\n         {  xprintf(\"%s:%d: DISPLAY_DATA_TYPE entry multiply defined\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_colon(csa))\n            goto fail;\n         if (scan_keyword(csa))\n            goto fail;\n         if (strcmp(csa->token, \"COORD_DISPLAY\") == 0)\n            tsp->display_data_type = TSP_COORD_DISPLAY;\n         else if (strcmp(csa->token, \"TWOD_DISPLAY\") == 0)\n            tsp->display_data_type = TSP_TWOD_DISPLAY;\n         else\n         {  xprintf(\"%s:%d: display data type '%s' not recognized\\n\",\n               csa->fname, csa->seqn, csa->token);\n            goto fail;\n         }\n         xprintf(\"DISPLAY_DATA_TYPE: %s\\n\", csa->token);\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"NODE_COORD_SECTION\") == 0)\n      {  int n = tsp->dimension, k, node;\n         if (n == 0)\n         {  xprintf(\"%s:%d: DIMENSION entry not specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (tsp->node_x_coord != NULL)\n         {  xprintf(\"%s:%d: NODE_COORD_SECTION multiply specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n         tsp->node_x_coord = xalloc(1+n, sizeof(double));\n         tsp->node_y_coord = xalloc(1+n, sizeof(double));\n         for (node = 1; node <= n; node++)\n            tsp->node_x_coord[node] = tsp->node_y_coord[node] = DBL_MAX;\n         for (k = 1; k <= n; k++)\n         {  if (scan_integer(csa, 0, &node))\n               goto fail;\n            if (!(1 <= node && node <= n))\n            {  xprintf(\"%s:%d: invalid node number %d\\n\", csa->fname,\n                  csa->seqn, node);\n               goto fail;\n            }\n            if (tsp->node_x_coord[node] != DBL_MAX)\n            {  xprintf(\"%s:%d: node number %d multiply specified\\n\",\n                  csa->fname, csa->seqn, node);\n               goto fail;\n            }\n            if (scan_number(csa, 0, &tsp->node_x_coord[node]))\n               goto fail;\n            if (scan_number(csa, 0, &tsp->node_y_coord[node]))\n               goto fail;\n            if (check_newline(csa))\n               goto fail;\n         }\n      }\n      else if (strcmp(csa->token, \"DISPLAY_DATA_SECTION\") == 0)\n      {  int n = tsp->dimension, k, node;\n         if (n == 0)\n         {  xprintf(\"%s:%d: DIMENSION entry not specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (tsp->dply_x_coord != NULL)\n         {  xprintf(\"%s:%d: DISPLAY_DATA_SECTION multiply specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n         tsp->dply_x_coord = xalloc(1+n, sizeof(double));\n         tsp->dply_y_coord = xalloc(1+n, sizeof(double));\n         for (node = 1; node <= n; node++)\n            tsp->dply_x_coord[node] = tsp->dply_y_coord[node] = DBL_MAX;\n         for (k = 1; k <= n; k++)\n         {  if (scan_integer(csa, 0, &node))\n               goto fail;\n            if (!(1 <= node && node <= n))\n            {  xprintf(\"%s:%d: invalid node number %d\\n\", csa->fname,\n                  csa->seqn, node);\n               goto fail;\n            }\n            if (tsp->dply_x_coord[node] != DBL_MAX)\n            {  xprintf(\"%s:%d: node number %d multiply specified\\n\",\n                  csa->fname, csa->seqn, node);\n               goto fail;\n            }\n            if (scan_number(csa, 0, &tsp->dply_x_coord[node]))\n               goto fail;\n            if (scan_number(csa, 0, &tsp->dply_y_coord[node]))\n               goto fail;\n            if (check_newline(csa))\n               goto fail;\n         }\n      }\n      else if (strcmp(csa->token, \"TOUR_SECTION\") == 0)\n      {  int n = tsp->dimension, k, node;\n         if (n == 0)\n         {  xprintf(\"%s:%d: DIMENSION entry not specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (tsp->tour != NULL)\n         {  xprintf(\"%s:%d: TOUR_SECTION multiply specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n         tsp->tour = xalloc(1+n, sizeof(int));\n         for (k = 1; k <= n; k++)\n         {  if (scan_integer(csa, 1, &node))\n               goto fail;\n            if (!(1 <= node && node <= n))\n            {  xprintf(\"%s:%d: invalid node number %d\\n\", csa->fname,\n                  csa->seqn, node);\n               goto fail;\n            }\n            tsp->tour[k] = node;\n         }\n         if (scan_integer(csa, 1, &node))\n            goto fail;\n         if (node != -1)\n         {  xprintf(\"%s:%d: extra node(s) detected\\n\", csa->fname,\n               csa->seqn);\n            goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"EDGE_WEIGHT_SECTION\") == 0)\n      {  int n = tsp->dimension, i, j, temp;\n         if (n == 0)\n         {  xprintf(\"%s:%d: DIMENSION entry not specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (tsp->edge_weight_format == TSP_UNDEF)\n         {  xprintf(\"%s:%d: EDGE_WEIGHT_FORMAT entry not specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (tsp->edge_weight != NULL)\n         {  xprintf(\"%s:%d: EDGE_WEIGHT_SECTION multiply specified\\n\",\n               csa->fname, csa->seqn);\n            goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n         tsp->edge_weight = xalloc(1+n*n, sizeof(int));\n         switch (tsp->edge_weight_format)\n         {  case TSP_FULL_MATRIX:\n               for (i = 1; i <= n; i++)\n               {  for (j = 1; j <= n; j++)\n                  {  if (scan_integer(csa, 1, &temp))\n                        goto fail;\n                     tsp->edge_weight[(i - 1) * n + j] = temp;\n                  }\n               }\n               break;\n            case TSP_UPPER_ROW:\n               for (i = 1; i <= n; i++)\n               {  tsp->edge_weight[(i - 1) * n + i] = 0;\n                  for (j = i + 1; j <= n; j++)\n                  {  if (scan_integer(csa, 1, &temp))\n                        goto fail;\n                     tsp->edge_weight[(i - 1) * n + j] = temp;\n                     tsp->edge_weight[(j - 1) * n + i] = temp;\n                  }\n               }\n               break;\n            case TSP_LOWER_DIAG_ROW:\n               for (i = 1; i <= n; i++)\n               {  for (j = 1; j <= i; j++)\n                  {  if (scan_integer(csa, 1, &temp))\n                        goto fail;\n                     tsp->edge_weight[(i - 1) * n + j] = temp;\n                     tsp->edge_weight[(j - 1) * n + i] = temp;\n                  }\n               }\n               break;\n            default:\n               goto fail;\n         }\n         if (check_newline(csa))\n            goto fail;\n      }\n      else if (strcmp(csa->token, \"EOF\") == 0)\n      {  if (check_newline(csa))\n            goto fail;\n         goto done;\n      }\n      else\n      {  xprintf(\"%s:%d: keyword '%s' not recognized\\n\", csa->fname,\n            csa->seqn, csa->token);\n         goto fail;\n      }\n      goto loop;\ndone: xprintf(\"%d lines were read\\n\", csa->seqn-1);\n      fclose(csa->fp);\n      return tsp;\nfail: if (tsp != NULL)\n      {  if (tsp->name != NULL)\n            xfree(tsp->name);\n         if (tsp->comment != NULL)\n            xfree(tsp->comment);\n         if (tsp->node_x_coord != NULL)\n            xfree(tsp->node_x_coord);\n         if (tsp->node_y_coord != NULL)\n            xfree(tsp->node_y_coord);\n         if (tsp->dply_x_coord != NULL)\n            xfree(tsp->dply_x_coord);\n         if (tsp->dply_y_coord != NULL)\n            xfree(tsp->dply_y_coord);\n         if (tsp->tour != NULL)\n            xfree(tsp->tour);\n         if (tsp->edge_weight != NULL)\n            xfree(tsp->edge_weight);\n         xfree(tsp);\n      }\n      if (csa->fp != NULL)\n         fclose(csa->fp);\n      return NULL;\n}",
      "lines": 398,
      "depth": 29,
      "decorators": [
        "TSP",
        "*tsp_read_data(const char *fname)",
        "*"
      ]
    },
    "rad": {
      "start_point": [
        620,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "static double rad(double x)\n{     /* convert input coordinate to longitude/latitude, in radians */\n      double pi = 3.141592, deg, min;\n      deg = (int)x;\n      min = x - deg;\n      return pi * (deg + 5.0 * min / 3.0) / 180.0;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "tsp_distance": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "int tsp_distance(const TSP *tsp, int i, int j)\n{     int n = tsp->dimension, dij;\n      if (!(tsp->type == TSP_TSP || tsp->type == TSP_ATSP))\n         xerror(\"tsp_distance: invalid TSP instance\\n\");\n      if (!(1 <= i && i <= n && 1 <= j && j <= n))\n         xerror(\"tsp_distance: node number out of range\\n\");\n      switch (tsp->edge_weight_type)\n      {  case TSP_UNDEF:\n            xerror(\"tsp_distance: edge weight type not specified\\n\");\n         case TSP_EXPLICIT:\n            if (tsp->edge_weight == NULL)\n               xerror(\"tsp_distance: edge weights not specified\\n\");\n            dij = tsp->edge_weight[(i - 1) * n + j];\n            break;\n         case TSP_EUC_2D:\n            if (tsp->node_x_coord == NULL || tsp->node_y_coord == NULL)\n               xerror(\"tsp_distance: node coordinates not specified\\n\");\n            {  double xd, yd;\n               xd = tsp->node_x_coord[i] - tsp->node_x_coord[j];\n               yd = tsp->node_y_coord[i] - tsp->node_y_coord[j];\n               dij = nint(sqrt(xd * xd + yd * yd));\n            }\n            break;\n         case TSP_CEIL_2D:\n            if (tsp->node_x_coord == NULL || tsp->node_y_coord == NULL)\n               xerror(\"tsp_distance: node coordinates not specified\\n\");\n            {  double xd, yd;\n               xd = tsp->node_x_coord[i] - tsp->node_x_coord[j];\n               yd = tsp->node_y_coord[i] - tsp->node_y_coord[j];\n               dij = (int)ceil(sqrt(xd * xd + yd * yd));\n            }\n            break;\n         case TSP_GEO:\n            if (tsp->node_x_coord == NULL || tsp->node_y_coord == NULL)\n               xerror(\"tsp_distance: node coordinates not specified\\n\");\n            {  double rrr = 6378.388;\n               double latitude_i = rad(tsp->node_x_coord[i]);\n               double latitude_j = rad(tsp->node_x_coord[j]);\n               double longitude_i = rad(tsp->node_y_coord[i]);\n               double longitude_j = rad(tsp->node_y_coord[j]);\n               double q1 = cos(longitude_i - longitude_j);\n               double q2 = cos(latitude_i - latitude_j);\n               double q3 = cos(latitude_i + latitude_j);\n               dij = (int)(rrr * acos(0.5 * ((1.0 + q1) * q2 -\n                  (1.0 - q1) *q3)) + 1.0);\n            }\n            break;\n         case TSP_ATT:\n            if (tsp->node_x_coord == NULL || tsp->node_y_coord == NULL)\n               xerror(\"tsp_distance: node coordinates not specified\\n\");\n            {  int tij;\n               double xd, yd, rij;\n               xd = tsp->node_x_coord[i] - tsp->node_x_coord[j];\n               yd = tsp->node_y_coord[i] - tsp->node_y_coord[j];\n               rij = sqrt((xd * xd + yd * yd) / 10.0);\n               tij = nint(rij);\n               if (tij < rij) dij = tij + 1; else dij = tij;\n            }\n            break;\n         default:\n            xassert(tsp->edge_weight_type != tsp->edge_weight_type);\n      }\n      return dij;\n}",
      "lines": 64,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "tsp_free_data": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "void tsp_free_data(TSP *tsp)\n{     if (tsp->name != NULL)\n         xfree(tsp->name);\n      if (tsp->comment != NULL)\n         xfree(tsp->comment);\n      if (tsp->node_x_coord != NULL)\n         xfree(tsp->node_x_coord);\n      if (tsp->node_y_coord != NULL)\n         xfree(tsp->node_y_coord);\n      if (tsp->dply_x_coord != NULL)\n         xfree(tsp->dply_x_coord);\n      if (tsp->dply_y_coord != NULL)\n         xfree(tsp->dply_y_coord);\n      if (tsp->tour != NULL)\n         xfree(tsp->tour);\n      if (tsp->edge_weight != NULL)\n         xfree(tsp->edge_weight);\n      xfree(tsp);\n      return;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/examples/tsp/tsplib.h": {},
  "glpk/glpk-4.65/src/glpk.h": {},
  "glpk/glpk-4.65/src/amd/amd.h": {},
  "glpk/glpk-4.65/src/amd/amd_1.c": {
    "AMD_1": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "GLOBAL void AMD_1\n(\n    Int n,              /* n > 0 */\n    const Int Ap [ ],   /* input of size n+1, not modified */\n    const Int Ai [ ],   /* input of size nz = Ap [n], not modified */\n    Int P [ ],          /* size n output permutation */\n    Int Pinv [ ],       /* size n output inverse permutation */\n    Int Len [ ],        /* size n input, undefined on output */\n    Int slen,           /* slen >= sum (Len [0..n-1]) + 7n,\n                         * ideally slen = 1.2 * sum (Len) + 8n */\n    Int S [ ],          /* size slen workspace */\n    double Control [ ], /* input array of size AMD_CONTROL */\n    double Info [ ]     /* output array of size AMD_INFO */\n)\n{\n    Int i, j, k, p, pfree, iwlen, pj, p1, p2, pj2, *Iw, *Pe, *Nv, *Head,\n        *Elen, *Degree, *s, *W, *Sp, *Tp ;\n\n    /* --------------------------------------------------------------------- */\n    /* construct the matrix for AMD_2 */\n    /* --------------------------------------------------------------------- */\n\n    ASSERT (n > 0) ;\n\n    iwlen = slen - 6*n ;\n    s = S ;\n    Pe = s ;        s += n ;\n    Nv = s ;        s += n ;\n    Head = s ;      s += n ;\n    Elen = s ;      s += n ;\n    Degree = s ;    s += n ;\n    W = s ;         s += n ;\n    Iw = s ;        s += iwlen ;\n\n    ASSERT (AMD_valid (n, n, Ap, Ai) == AMD_OK) ;\n\n    /* construct the pointers for A+A' */\n    Sp = Nv ;                   /* use Nv and W as workspace for Sp and Tp [ */\n    Tp = W ;\n    pfree = 0 ;\n    for (j = 0 ; j < n ; j++)\n    {\n        Pe [j] = pfree ;\n        Sp [j] = pfree ;\n        pfree += Len [j] ;\n    }\n\n    /* Note that this restriction on iwlen is slightly more restrictive than\n     * what is strictly required in AMD_2.  AMD_2 can operate with no elbow\n     * room at all, but it will be very slow.  For better performance, at\n     * least size-n elbow room is enforced. */\n    ASSERT (iwlen >= pfree + n) ;\n\n#ifndef NDEBUG\n    for (p = 0 ; p < iwlen ; p++) Iw [p] = EMPTY ;\n#endif\n\n    for (k = 0 ; k < n ; k++)\n    {\n        AMD_DEBUG1 ((\"Construct row/column k= \"ID\" of A+A'\\n\", k))  ;\n        p1 = Ap [k] ;\n        p2 = Ap [k+1] ;\n\n        /* construct A+A' */\n        for (p = p1 ; p < p2 ; )\n        {\n            /* scan the upper triangular part of A */\n            j = Ai [p] ;\n            ASSERT (j >= 0 && j < n) ;\n            if (j < k)\n            {\n                /* entry A (j,k) in the strictly upper triangular part */\n                ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;\n                ASSERT (Sp [k] < (k == n-1 ? pfree : Pe [k+1])) ;\n                Iw [Sp [j]++] = k ;\n                Iw [Sp [k]++] = j ;\n                p++ ;\n            }\n            else if (j == k)\n            {\n                /* skip the diagonal */\n                p++ ;\n                break ;\n            }\n            else /* j > k */\n            {\n                /* first entry below the diagonal */\n                break ;\n            }\n            /* scan lower triangular part of A, in column j until reaching\n             * row k.  Start where last scan left off. */\n            ASSERT (Ap [j] <= Tp [j] && Tp [j] <= Ap [j+1]) ;\n            pj2 = Ap [j+1] ;\n            for (pj = Tp [j] ; pj < pj2 ; )\n            {\n                i = Ai [pj] ;\n                ASSERT (i >= 0 && i < n) ;\n                if (i < k)\n                {\n                    /* A (i,j) is only in the lower part, not in upper */\n                    ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;\n                    ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;\n                    Iw [Sp [i]++] = j ;\n                    Iw [Sp [j]++] = i ;\n                    pj++ ;\n                }\n                else if (i == k)\n                {\n                    /* entry A (k,j) in lower part and A (j,k) in upper */\n                    pj++ ;\n                    break ;\n                }\n                else /* i > k */\n                {\n                    /* consider this entry later, when k advances to i */\n                    break ;\n                }\n            }\n            Tp [j] = pj ;\n        }\n        Tp [k] = p ;\n    }\n\n    /* clean up, for remaining mismatched entries */\n    for (j = 0 ; j < n ; j++)\n    {\n        for (pj = Tp [j] ; pj < Ap [j+1] ; pj++)\n        {\n            i = Ai [pj] ;\n            ASSERT (i >= 0 && i < n) ;\n            /* A (i,j) is only in the lower part, not in upper */\n            ASSERT (Sp [i] < (i == n-1 ? pfree : Pe [i+1])) ;\n            ASSERT (Sp [j] < (j == n-1 ? pfree : Pe [j+1])) ;\n            Iw [Sp [i]++] = j ;\n            Iw [Sp [j]++] = i ;\n        }\n    }\n\n#ifndef NDEBUG\n    for (j = 0 ; j < n-1 ; j++) ASSERT (Sp [j] == Pe [j+1]) ;\n    ASSERT (Sp [n-1] == pfree) ;\n#endif\n\n    /* Tp and Sp no longer needed ] */\n\n    /* --------------------------------------------------------------------- */\n    /* order the matrix */\n    /* --------------------------------------------------------------------- */\n\n    AMD_2 (n, Pe, Iw, Len, iwlen, pfree,\n        Nv, Pinv, P, Head, Elen, Degree, W, Control, Info) ;\n}",
      "lines": 152,
      "depth": 19,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_2.c": {
    "clear_flag": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static Int clear_flag (Int wflg, Int wbig, Int W [ ], Int n)\n{\n    Int x ;\n    if (wflg < 2 || wflg >= wbig)\n    {\n        for (x = 0 ; x < n ; x++)\n        {\n            if (W [x] != 0) W [x] = 1 ;\n        }\n        wflg = 2 ;\n    }\n    /*  at this point, W [0..n-1] < wflg holds */\n    return (wflg) ;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Int"
      ]
    },
    "AMD_2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        1841,
        1
      ],
      "content": "GLOBAL void AMD_2\n(\n    Int n,              /* A is n-by-n, where n > 0 */\n    Int Pe [ ],         /* Pe [0..n-1]: index in Iw of row i on input */\n    Int Iw [ ],         /* workspace of size iwlen. Iw [0..pfree-1]\n                         * holds the matrix on input */\n    Int Len [ ],        /* Len [0..n-1]: length for row/column i on input */\n    Int iwlen,          /* length of Iw. iwlen >= pfree + n */\n    Int pfree,          /* Iw [pfree ... iwlen-1] is empty on input */\n\n    /* 7 size-n workspaces, not defined on input: */\n    Int Nv [ ],         /* the size of each supernode on output */\n    Int Next [ ],       /* the output inverse permutation */\n    Int Last [ ],       /* the output permutation */\n    Int Head [ ],\n    Int Elen [ ],       /* the size columns of L for each supernode */\n    Int Degree [ ],\n    Int W [ ],\n\n    /* control parameters and output statistics */\n    double Control [ ], /* array of size AMD_CONTROL */\n    double Info [ ]     /* array of size AMD_INFO */\n)\n{\n\n/*\n * Given a representation of the nonzero pattern of a symmetric matrix, A,\n * (excluding the diagonal) perform an approximate minimum (UMFPACK/MA38-style)\n * degree ordering to compute a pivot order such that the introduction of\n * nonzeros (fill-in) in the Cholesky factors A = LL' is kept low.  At each\n * step, the pivot selected is the one with the minimum UMFAPACK/MA38-style\n * upper-bound on the external degree.  This routine can optionally perform\n * aggresive absorption (as done by MC47B in the Harwell Subroutine\n * Library).\n *\n * The approximate degree algorithm implemented here is the symmetric analog of\n * the degree update algorithm in MA38 and UMFPACK (the Unsymmetric-pattern\n * MultiFrontal PACKage, both by Davis and Duff).  The routine is based on the\n * MA27 minimum degree ordering algorithm by Iain Duff and John Reid.\n *\n * This routine is a translation of the original AMDBAR and MC47B routines,\n * in Fortran, with the following modifications:\n *\n * (1) dense rows/columns are removed prior to ordering the matrix, and placed\n *      last in the output order.  The presence of a dense row/column can\n *      increase the ordering time by up to O(n^2), unless they are removed\n *      prior to ordering.\n *\n * (2) the minimum degree ordering is followed by a postordering (depth-first\n *      search) of the assembly tree.  Note that mass elimination (discussed\n *      below) combined with the approximate degree update can lead to the mass\n *      elimination of nodes with lower exact degree than the current pivot\n *      element.  No additional fill-in is caused in the representation of the\n *      Schur complement.  The mass-eliminated nodes merge with the current\n *      pivot element.  They are ordered prior to the current pivot element.\n *      Because they can have lower exact degree than the current element, the\n *      merger of two or more of these nodes in the current pivot element can\n *      lead to a single element that is not a \"fundamental supernode\".  The\n *      diagonal block can have zeros in it.  Thus, the assembly tree used here\n *      is not guaranteed to be the precise supernodal elemination tree (with\n *      \"funadmental\" supernodes), and the postordering performed by this\n *      routine is not guaranteed to be a precise postordering of the\n *      elimination tree.\n *\n * (3) input parameters are added, to control aggressive absorption and the\n *      detection of \"dense\" rows/columns of A.\n *\n * (4) additional statistical information is returned, such as the number of\n *      nonzeros in L, and the flop counts for subsequent LDL' and LU\n *      factorizations.  These are slight upper bounds, because of the mass\n *      elimination issue discussed above.\n *\n * (5) additional routines are added to interface this routine to MATLAB\n *      to provide a simple C-callable user-interface, to check inputs for\n *      errors, compute the symmetry of the pattern of A and the number of\n *      nonzeros in each row/column of A+A', to compute the pattern of A+A',\n *      to perform the assembly tree postordering, and to provide debugging\n *      ouput.  Many of these functions are also provided by the Fortran\n *      Harwell Subroutine Library routine MC47A.\n *\n * (6) both int and UF_long versions are provided.  In the descriptions below\n *      and integer is and int or UF_long depending on which version is\n *      being used.\n\n **********************************************************************\n ***** CAUTION:  ARGUMENTS ARE NOT CHECKED FOR ERRORS ON INPUT.  ******\n **********************************************************************\n ** If you want error checking, a more versatile input format, and a **\n ** simpler user interface, use amd_order or amd_l_order instead.    **\n ** This routine is not meant to be user-callable.                   **\n **********************************************************************\n\n * ----------------------------------------------------------------------------\n * References:\n * ----------------------------------------------------------------------------\n *\n *  [1] Timothy A. Davis and Iain Duff, \"An unsymmetric-pattern multifrontal\n *      method for sparse LU factorization\", SIAM J. Matrix Analysis and\n *      Applications, vol. 18, no. 1, pp. 140-158.  Discusses UMFPACK / MA38,\n *      which first introduced the approximate minimum degree used by this\n *      routine.\n *\n *  [2] Patrick Amestoy, Timothy A. Davis, and Iain S. Duff, \"An approximate\n *      minimum degree ordering algorithm,\" SIAM J. Matrix Analysis and\n *      Applications, vol. 17, no. 4, pp. 886-905, 1996.  Discusses AMDBAR and\n *      MC47B, which are the Fortran versions of this routine.\n *\n *  [3] Alan George and Joseph Liu, \"The evolution of the minimum degree\n *      ordering algorithm,\" SIAM Review, vol. 31, no. 1, pp. 1-19, 1989.\n *      We list below the features mentioned in that paper that this code\n *      includes:\n *\n *      mass elimination:\n *          Yes.  MA27 relied on supervariable detection for mass elimination.\n *\n *      indistinguishable nodes:\n *          Yes (we call these \"supervariables\").  This was also in the MA27\n *          code - although we modified the method of detecting them (the\n *          previous hash was the true degree, which we no longer keep track\n *          of).  A supervariable is a set of rows with identical nonzero\n *          pattern.  All variables in a supervariable are eliminated together.\n *          Each supervariable has as its numerical name that of one of its\n *          variables (its principal variable).\n *\n *      quotient graph representation:\n *          Yes.  We use the term \"element\" for the cliques formed during\n *          elimination.  This was also in the MA27 code.  The algorithm can\n *          operate in place, but it will work more efficiently if given some\n *          \"elbow room.\"\n *\n *      element absorption:\n *          Yes.  This was also in the MA27 code.\n *\n *      external degree:\n *          Yes.  The MA27 code was based on the true degree.\n *\n *      incomplete degree update and multiple elimination:\n *          No.  This was not in MA27, either.  Our method of degree update\n *          within MC47B is element-based, not variable-based.  It is thus\n *          not well-suited for use with incomplete degree update or multiple\n *          elimination.\n *\n * Authors, and Copyright (C) 2004 by:\n * Timothy A. Davis, Patrick Amestoy, Iain S. Duff, John K. Reid.\n *\n * Acknowledgements: This work (and the UMFPACK package) was supported by the\n * National Science Foundation (ASC-9111263, DMS-9223088, and CCR-0203270).\n * The UMFPACK/MA38 approximate degree update algorithm, the unsymmetric analog\n * which forms the basis of AMD, was developed while Tim Davis was supported by\n * CERFACS (Toulouse, France) in a post-doctoral position.  This C version, and\n * the etree postorder, were written while Tim Davis was on sabbatical at\n * Stanford University and Lawrence Berkeley National Laboratory.\n\n * ----------------------------------------------------------------------------\n * INPUT ARGUMENTS (unaltered):\n * ----------------------------------------------------------------------------\n\n * n:  The matrix order.  Restriction:  n >= 1.\n *\n * iwlen:  The size of the Iw array.  On input, the matrix is stored in\n *      Iw [0..pfree-1].  However, Iw [0..iwlen-1] should be slightly larger\n *      than what is required to hold the matrix, at least iwlen >= pfree + n.\n *      Otherwise, excessive compressions will take place.  The recommended\n *      value of iwlen is 1.2 * pfree + n, which is the value used in the\n *      user-callable interface to this routine (amd_order.c).  The algorithm\n *      will not run at all if iwlen < pfree.  Restriction: iwlen >= pfree + n.\n *      Note that this is slightly more restrictive than the actual minimum\n *      (iwlen >= pfree), but AMD_2 will be very slow with no elbow room.\n *      Thus, this routine enforces a bare minimum elbow room of size n.\n *\n * pfree: On input the tail end of the array, Iw [pfree..iwlen-1], is empty,\n *      and the matrix is stored in Iw [0..pfree-1].  During execution,\n *      additional data is placed in Iw, and pfree is modified so that\n *      Iw [pfree..iwlen-1] is always the unused part of Iw.\n *\n * Control:  A double array of size AMD_CONTROL containing input parameters\n *      that affect how the ordering is computed.  If NULL, then default\n *      settings are used.\n *\n *      Control [AMD_DENSE] is used to determine whether or not a given input\n *      row is \"dense\".  A row is \"dense\" if the number of entries in the row\n *      exceeds Control [AMD_DENSE] times sqrt (n), except that rows with 16 or\n *      fewer entries are never considered \"dense\".  To turn off the detection\n *      of dense rows, set Control [AMD_DENSE] to a negative number, or to a\n *      number larger than sqrt (n).  The default value of Control [AMD_DENSE]\n *      is AMD_DEFAULT_DENSE, which is defined in amd.h as 10.\n *\n *      Control [AMD_AGGRESSIVE] is used to determine whether or not aggressive\n *      absorption is to be performed.  If nonzero, then aggressive absorption\n *      is performed (this is the default).\n\n * ----------------------------------------------------------------------------\n * INPUT/OUPUT ARGUMENTS:\n * ----------------------------------------------------------------------------\n *\n * Pe:  An integer array of size n.  On input, Pe [i] is the index in Iw of\n *      the start of row i.  Pe [i] is ignored if row i has no off-diagonal\n *      entries.  Thus Pe [i] must be in the range 0 to pfree-1 for non-empty\n *      rows.\n *\n *      During execution, it is used for both supervariables and elements:\n *\n *      Principal supervariable i:  index into Iw of the description of\n *          supervariable i.  A supervariable represents one or more rows of\n *          the matrix with identical nonzero pattern.  In this case,\n *          Pe [i] >= 0.\n *\n *      Non-principal supervariable i:  if i has been absorbed into another\n *          supervariable j, then Pe [i] = FLIP (j), where FLIP (j) is defined\n *          as (-(j)-2).  Row j has the same pattern as row i.  Note that j\n *          might later be absorbed into another supervariable j2, in which\n *          case Pe [i] is still FLIP (j), and Pe [j] = FLIP (j2) which is\n *          < EMPTY, where EMPTY is defined as (-1) in amd_internal.h.\n *\n *      Unabsorbed element e:  the index into Iw of the description of element\n *          e, if e has not yet been absorbed by a subsequent element.  Element\n *          e is created when the supervariable of the same name is selected as\n *          the pivot.  In this case, Pe [i] >= 0.\n *\n *      Absorbed element e:  if element e is absorbed into element e2, then\n *          Pe [e] = FLIP (e2).  This occurs when the pattern of e (which we\n *          refer to as Le) is found to be a subset of the pattern of e2 (that\n *          is, Le2).  In this case, Pe [i] < EMPTY.  If element e is \"null\"\n *          (it has no nonzeros outside its pivot block), then Pe [e] = EMPTY,\n *          and e is the root of an assembly subtree (or the whole tree if\n *          there is just one such root).\n *\n *      Dense variable i:  if i is \"dense\", then Pe [i] = EMPTY.\n *\n *      On output, Pe holds the assembly tree/forest, which implicitly\n *      represents a pivot order with identical fill-in as the actual order\n *      (via a depth-first search of the tree), as follows.  If Nv [i] > 0,\n *      then i represents a node in the assembly tree, and the parent of i is\n *      Pe [i], or EMPTY if i is a root.  If Nv [i] = 0, then (i, Pe [i])\n *      represents an edge in a subtree, the root of which is a node in the\n *      assembly tree.  Note that i refers to a row/column in the original\n *      matrix, not the permuted matrix.\n *\n * Info:  A double array of size AMD_INFO.  If present, (that is, not NULL),\n *      then statistics about the ordering are returned in the Info array.\n *      See amd.h for a description.\n\n * ----------------------------------------------------------------------------\n * INPUT/MODIFIED (undefined on output):\n * ----------------------------------------------------------------------------\n *\n * Len:  An integer array of size n.  On input, Len [i] holds the number of\n *      entries in row i of the matrix, excluding the diagonal.  The contents\n *      of Len are undefined on output.\n *\n * Iw:  An integer array of size iwlen.  On input, Iw [0..pfree-1] holds the\n *      description of each row i in the matrix.  The matrix must be symmetric,\n *      and both upper and lower triangular parts must be present.  The\n *      diagonal must not be present.  Row i is held as follows:\n *\n *          Len [i]:  the length of the row i data structure in the Iw array.\n *          Iw [Pe [i] ... Pe [i] + Len [i] - 1]:\n *              the list of column indices for nonzeros in row i (simple\n *              supervariables), excluding the diagonal.  All supervariables\n *              start with one row/column each (supervariable i is just row i).\n *              If Len [i] is zero on input, then Pe [i] is ignored on input.\n *\n *          Note that the rows need not be in any particular order, and there\n *          may be empty space between the rows.\n *\n *      During execution, the supervariable i experiences fill-in.  This is\n *      represented by placing in i a list of the elements that cause fill-in\n *      in supervariable i:\n *\n *          Len [i]:  the length of supervariable i in the Iw array.\n *          Iw [Pe [i] ... Pe [i] + Elen [i] - 1]:\n *              the list of elements that contain i.  This list is kept short\n *              by removing absorbed elements.\n *          Iw [Pe [i] + Elen [i] ... Pe [i] + Len [i] - 1]:\n *              the list of supervariables in i.  This list is kept short by\n *              removing nonprincipal variables, and any entry j that is also\n *              contained in at least one of the elements (j in Le) in the list\n *              for i (e in row i).\n *\n *      When supervariable i is selected as pivot, we create an element e of\n *      the same name (e=i):\n *\n *          Len [e]:  the length of element e in the Iw array.\n *          Iw [Pe [e] ... Pe [e] + Len [e] - 1]:\n *              the list of supervariables in element e.\n *\n *      An element represents the fill-in that occurs when supervariable i is\n *      selected as pivot (which represents the selection of row i and all\n *      non-principal variables whose principal variable is i).  We use the\n *      term Le to denote the set of all supervariables in element e.  Absorbed\n *      supervariables and elements are pruned from these lists when\n *      computationally convenient.\n *\n *  CAUTION:  THE INPUT MATRIX IS OVERWRITTEN DURING COMPUTATION.\n *  The contents of Iw are undefined on output.\n\n * ----------------------------------------------------------------------------\n * OUTPUT (need not be set on input):\n * ----------------------------------------------------------------------------\n *\n * Nv:  An integer array of size n.  During execution, ABS (Nv [i]) is equal to\n *      the number of rows that are represented by the principal supervariable\n *      i.  If i is a nonprincipal or dense variable, then Nv [i] = 0.\n *      Initially, Nv [i] = 1 for all i.  Nv [i] < 0 signifies that i is a\n *      principal variable in the pattern Lme of the current pivot element me.\n *      After element me is constructed, Nv [i] is set back to a positive\n *      value.\n *\n *      On output, Nv [i] holds the number of pivots represented by super\n *      row/column i of the original matrix, or Nv [i] = 0 for non-principal\n *      rows/columns.  Note that i refers to a row/column in the original\n *      matrix, not the permuted matrix.\n *\n * Elen:  An integer array of size n.  See the description of Iw above.  At the\n *      start of execution, Elen [i] is set to zero for all rows i.  During\n *      execution, Elen [i] is the number of elements in the list for\n *      supervariable i.  When e becomes an element, Elen [e] = FLIP (esize) is\n *      set, where esize is the size of the element (the number of pivots, plus\n *      the number of nonpivotal entries).  Thus Elen [e] < EMPTY.\n *      Elen (i) = EMPTY set when variable i becomes nonprincipal.\n *\n *      For variables, Elen (i) >= EMPTY holds until just before the\n *      postordering and permutation vectors are computed.  For elements,\n *      Elen [e] < EMPTY holds.\n *\n *      On output, Elen [i] is the degree of the row/column in the Cholesky\n *      factorization of the permuted matrix, corresponding to the original row\n *      i, if i is a super row/column.  It is equal to EMPTY if i is\n *      non-principal.  Note that i refers to a row/column in the original\n *      matrix, not the permuted matrix.\n *\n *      Note that the contents of Elen on output differ from the Fortran\n *      version (Elen holds the inverse permutation in the Fortran version,\n *      which is instead returned in the Next array in this C version,\n *      described below).\n *\n * Last: In a degree list, Last [i] is the supervariable preceding i, or EMPTY\n *      if i is the head of the list.  In a hash bucket, Last [i] is the hash\n *      key for i.\n *\n *      Last [Head [hash]] is also used as the head of a hash bucket if\n *      Head [hash] contains a degree list (see the description of Head,\n *      below).\n *\n *      On output, Last [0..n-1] holds the permutation.  That is, if\n *      i = Last [k], then row i is the kth pivot row (where k ranges from 0 to\n *      n-1).  Row Last [k] of A is the kth row in the permuted matrix, PAP'.\n *\n * Next: Next [i] is the supervariable following i in a link list, or EMPTY if\n *      i is the last in the list.  Used for two kinds of lists:  degree lists\n *      and hash buckets (a supervariable can be in only one kind of list at a\n *      time).\n *\n *      On output Next [0..n-1] holds the inverse permutation.  That is, if\n *      k = Next [i], then row i is the kth pivot row. Row i of A appears as\n *      the (Next[i])-th row in the permuted matrix, PAP'.\n *\n *      Note that the contents of Next on output differ from the Fortran\n *      version (Next is undefined on output in the Fortran version).\n\n * ----------------------------------------------------------------------------\n * LOCAL WORKSPACE (not input or output - used only during execution):\n * ----------------------------------------------------------------------------\n *\n * Degree:  An integer array of size n.  If i is a supervariable, then\n *      Degree [i] holds the current approximation of the external degree of\n *      row i (an upper bound).  The external degree is the number of nonzeros\n *      in row i, minus ABS (Nv [i]), the diagonal part.  The bound is equal to\n *      the exact external degree if Elen [i] is less than or equal to two.\n *\n *      We also use the term \"external degree\" for elements e to refer to\n *      |Le \\ Lme|.  If e is an element, then Degree [e] is |Le|, which is the\n *      degree of the off-diagonal part of the element e (not including the\n *      diagonal part).\n *\n * Head:   An integer array of size n.  Head is used for degree lists.\n *      Head [deg] is the first supervariable in a degree list.  All\n *      supervariables i in a degree list Head [deg] have the same approximate\n *      degree, namely, deg = Degree [i].  If the list Head [deg] is empty then\n *      Head [deg] = EMPTY.\n *\n *      During supervariable detection Head [hash] also serves as a pointer to\n *      a hash bucket.  If Head [hash] >= 0, there is a degree list of degree\n *      hash.  The hash bucket head pointer is Last [Head [hash]].  If\n *      Head [hash] = EMPTY, then the degree list and hash bucket are both\n *      empty.  If Head [hash] < EMPTY, then the degree list is empty, and\n *      FLIP (Head [hash]) is the head of the hash bucket.  After supervariable\n *      detection is complete, all hash buckets are empty, and the\n *      (Last [Head [hash]] = EMPTY) condition is restored for the non-empty\n *      degree lists.\n *\n * W:  An integer array of size n.  The flag array W determines the status of\n *      elements and variables, and the external degree of elements.\n *\n *      for elements:\n *          if W [e] = 0, then the element e is absorbed.\n *          if W [e] >= wflg, then W [e] - wflg is the size of the set\n *              |Le \\ Lme|, in terms of nonzeros (the sum of ABS (Nv [i]) for\n *              each principal variable i that is both in the pattern of\n *              element e and NOT in the pattern of the current pivot element,\n *              me).\n *          if wflg > W [e] > 0, then e is not absorbed and has not yet been\n *              seen in the scan of the element lists in the computation of\n *              |Le\\Lme| in Scan 1 below.\n *\n *      for variables:\n *          during supervariable detection, if W [j] != wflg then j is\n *          not in the pattern of variable i.\n *\n *      The W array is initialized by setting W [i] = 1 for all i, and by\n *      setting wflg = 2.  It is reinitialized if wflg becomes too large (to\n *      ensure that wflg+n does not cause integer overflow).\n\n * ----------------------------------------------------------------------------\n * LOCAL INTEGERS:\n * ----------------------------------------------------------------------------\n */\n\n    Int deg, degme, dext, lemax, e, elenme, eln, i, ilast, inext, j,\n        jlast, jnext, k, knt1, knt2, knt3, lenj, ln, me, mindeg, nel, nleft,\n        nvi, nvj, nvpiv, slenme, wbig, we, wflg, wnvi, ok, ndense, ncmpa,\n        dense, aggressive ;\n\n    unsigned Int hash ;     /* unsigned, so that hash % n is well defined.*/\n\n/*\n * deg:         the degree of a variable or element\n * degme:       size, |Lme|, of the current element, me (= Degree [me])\n * dext:        external degree, |Le \\ Lme|, of some element e\n * lemax:       largest |Le| seen so far (called dmax in Fortran version)\n * e:           an element\n * elenme:      the length, Elen [me], of element list of pivotal variable\n * eln:         the length, Elen [...], of an element list\n * hash:        the computed value of the hash function\n * i:           a supervariable\n * ilast:       the entry in a link list preceding i\n * inext:       the entry in a link list following i\n * j:           a supervariable\n * jlast:       the entry in a link list preceding j\n * jnext:       the entry in a link list, or path, following j\n * k:           the pivot order of an element or variable\n * knt1:        loop counter used during element construction\n * knt2:        loop counter used during element construction\n * knt3:        loop counter used during compression\n * lenj:        Len [j]\n * ln:          length of a supervariable list\n * me:          current supervariable being eliminated, and the current\n *                  element created by eliminating that supervariable\n * mindeg:      current minimum degree\n * nel:         number of pivots selected so far\n * nleft:       n - nel, the number of nonpivotal rows/columns remaining\n * nvi:         the number of variables in a supervariable i (= Nv [i])\n * nvj:         the number of variables in a supervariable j (= Nv [j])\n * nvpiv:       number of pivots in current element\n * slenme:      number of variables in variable list of pivotal variable\n * wbig:        = INT_MAX - n for the int version, UF_long_max - n for the\n *                  UF_long version.  wflg is not allowed to be >= wbig.\n * we:          W [e]\n * wflg:        used for flagging the W array.  See description of Iw.\n * wnvi:        wflg - Nv [i]\n * x:           either a supervariable or an element\n *\n * ok:          true if supervariable j can be absorbed into i\n * ndense:      number of \"dense\" rows/columns\n * dense:       rows/columns with initial degree > dense are considered \"dense\"\n * aggressive:  true if aggressive absorption is being performed\n * ncmpa:       number of garbage collections\n\n * ----------------------------------------------------------------------------\n * LOCAL DOUBLES, used for statistical output only (except for alpha):\n * ----------------------------------------------------------------------------\n */\n\n    double f, r, ndiv, s, nms_lu, nms_ldl, dmax, alpha, lnz, lnzme ;\n\n/*\n * f:           nvpiv\n * r:           degme + nvpiv\n * ndiv:        number of divisions for LU or LDL' factorizations\n * s:           number of multiply-subtract pairs for LU factorization, for the\n *                  current element me\n * nms_lu       number of multiply-subtract pairs for LU factorization\n * nms_ldl      number of multiply-subtract pairs for LDL' factorization\n * dmax:        the largest number of entries in any column of L, including the\n *                  diagonal\n * alpha:       \"dense\" degree ratio\n * lnz:         the number of nonzeros in L (excluding the diagonal)\n * lnzme:       the number of nonzeros in L (excl. the diagonal) for the\n *                  current element me\n\n * ----------------------------------------------------------------------------\n * LOCAL \"POINTERS\" (indices into the Iw array)\n * ----------------------------------------------------------------------------\n*/\n\n    Int p, p1, p2, p3, p4, pdst, pend, pj, pme, pme1, pme2, pn, psrc ;\n\n/*\n * Any parameter (Pe [...] or pfree) or local variable starting with \"p\" (for\n * Pointer) is an index into Iw, and all indices into Iw use variables starting\n * with \"p.\"  The only exception to this rule is the iwlen input argument.\n *\n * p:           pointer into lots of things\n * p1:          Pe [i] for some variable i (start of element list)\n * p2:          Pe [i] + Elen [i] -  1 for some variable i\n * p3:          index of first supervariable in clean list\n * p4:\n * pdst:        destination pointer, for compression\n * pend:        end of memory to compress\n * pj:          pointer into an element or variable\n * pme:         pointer into the current element (pme1...pme2)\n * pme1:        the current element, me, is stored in Iw [pme1...pme2]\n * pme2:        the end of the current element\n * pn:          pointer into a \"clean\" variable, also used to compress\n * psrc:        source pointer, for compression\n*/\n\n/* ========================================================================= */\n/*  INITIALIZATIONS */\n/* ========================================================================= */\n\n    /* Note that this restriction on iwlen is slightly more restrictive than\n     * what is actually required in AMD_2.  AMD_2 can operate with no elbow\n     * room at all, but it will be slow.  For better performance, at least\n     * size-n elbow room is enforced. */\n    ASSERT (iwlen >= pfree + n) ;\n    ASSERT (n > 0) ;\n\n    /* initialize output statistics */\n    lnz = 0 ;\n    ndiv = 0 ;\n    nms_lu = 0 ;\n    nms_ldl = 0 ;\n    dmax = 1 ;\n    me = EMPTY ;\n\n    mindeg = 0 ;\n    ncmpa = 0 ;\n    nel = 0 ;\n    lemax = 0 ;\n\n    /* get control parameters */\n    if (Control != (double *) NULL)\n    {\n        alpha = Control [AMD_DENSE] ;\n        aggressive = (Control [AMD_AGGRESSIVE] != 0) ;\n    }\n    else\n    {\n        alpha = AMD_DEFAULT_DENSE ;\n        aggressive = AMD_DEFAULT_AGGRESSIVE ;\n    }\n    /* Note: if alpha is NaN, this is undefined: */\n    if (alpha < 0)\n    {\n        /* only remove completely dense rows/columns */\n        dense = n-2 ;\n    }\n    else\n    {\n        dense = alpha * sqrt ((double) n) ;\n    }\n    dense = MAX (16, dense) ;\n    dense = MIN (n,  dense) ;\n    AMD_DEBUG1 ((\"\\n\\nAMD (debug), alpha %g, aggr. \"ID\"\\n\",\n        alpha, aggressive)) ;\n\n    for (i = 0 ; i < n ; i++)\n    {\n        Last [i] = EMPTY ;\n        Head [i] = EMPTY ;\n        Next [i] = EMPTY ;\n        /* if separate Hhead array is used for hash buckets: *\n        Hhead [i] = EMPTY ;\n        */\n        Nv [i] = 1 ;\n        W [i] = 1 ;\n        Elen [i] = 0 ;\n        Degree [i] = Len [i] ;\n    }\n\n#ifndef NDEBUG\n    AMD_DEBUG1 ((\"\\n======Nel \"ID\" initial\\n\", nel)) ;\n    AMD_dump (n, Pe, Iw, Len, iwlen, pfree, Nv, Next, Last,\n                Head, Elen, Degree, W, -1) ;\n#endif\n\n    /* initialize wflg */\n    wbig = Int_MAX - n ;\n    wflg = clear_flag (0, wbig, W, n) ;\n\n    /* --------------------------------------------------------------------- */\n    /* initialize degree lists and eliminate dense and empty rows */\n    /* --------------------------------------------------------------------- */\n\n    ndense = 0 ;\n\n    for (i = 0 ; i < n ; i++)\n    {\n        deg = Degree [i] ;\n        ASSERT (deg >= 0 && deg < n) ;\n        if (deg == 0)\n        {\n\n            /* -------------------------------------------------------------\n             * we have a variable that can be eliminated at once because\n             * there is no off-diagonal non-zero in its row.  Note that\n             * Nv [i] = 1 for an empty variable i.  It is treated just\n             * the same as an eliminated element i.\n             * ------------------------------------------------------------- */\n\n            Elen [i] = FLIP (1) ;\n            nel++ ;\n            Pe [i] = EMPTY ;\n            W [i] = 0 ;\n\n        }\n        else if (deg > dense)\n        {\n\n            /* -------------------------------------------------------------\n             * Dense variables are not treated as elements, but as unordered,\n             * non-principal variables that have no parent.  They do not take\n             * part in the postorder, since Nv [i] = 0.  Note that the Fortran\n             * version does not have this option.\n             * ------------------------------------------------------------- */\n\n            AMD_DEBUG1 ((\"Dense node \"ID\" degree \"ID\"\\n\", i, deg)) ;\n            ndense++ ;\n            Nv [i] = 0 ;                /* do not postorder this node */\n            Elen [i] = EMPTY ;\n            nel++ ;\n            Pe [i] = EMPTY ;\n\n        }\n        else\n        {\n\n            /* -------------------------------------------------------------\n             * place i in the degree list corresponding to its degree\n             * ------------------------------------------------------------- */\n\n            inext = Head [deg] ;\n            ASSERT (inext >= EMPTY && inext < n) ;\n            if (inext != EMPTY) Last [inext] = i ;\n            Next [i] = inext ;\n            Head [deg] = i ;\n\n        }\n    }\n\n/* ========================================================================= */\n/* WHILE (selecting pivots) DO */\n/* ========================================================================= */\n\n    while (nel < n)\n    {\n\n#ifndef NDEBUG\n        AMD_DEBUG1 ((\"\\n======Nel \"ID\"\\n\", nel)) ;\n        if (AMD_debug >= 2)\n        {\n            AMD_dump (n, Pe, Iw, Len, iwlen, pfree, Nv, Next,\n                    Last, Head, Elen, Degree, W, nel) ;\n        }\n#endif\n\n/* ========================================================================= */\n/* GET PIVOT OF MINIMUM DEGREE */\n/* ========================================================================= */\n\n        /* ----------------------------------------------------------------- */\n        /* find next supervariable for elimination */\n        /* ----------------------------------------------------------------- */\n\n        ASSERT (mindeg >= 0 && mindeg < n) ;\n        for (deg = mindeg ; deg < n ; deg++)\n        {\n            me = Head [deg] ;\n            if (me != EMPTY) break ;\n        }\n        mindeg = deg ;\n        ASSERT (me >= 0 && me < n) ;\n        AMD_DEBUG1 ((\"=================me: \"ID\"\\n\", me)) ;\n\n        /* ----------------------------------------------------------------- */\n        /* remove chosen variable from link list */\n        /* ----------------------------------------------------------------- */\n\n        inext = Next [me] ;\n        ASSERT (inext >= EMPTY && inext < n) ;\n        if (inext != EMPTY) Last [inext] = EMPTY ;\n        Head [deg] = inext ;\n\n        /* ----------------------------------------------------------------- */\n        /* me represents the elimination of pivots nel to nel+Nv[me]-1. */\n        /* place me itself as the first in this set. */\n        /* ----------------------------------------------------------------- */\n\n        elenme = Elen [me] ;\n        nvpiv = Nv [me] ;\n        ASSERT (nvpiv > 0) ;\n        nel += nvpiv ;\n\n/* ========================================================================= */\n/* CONSTRUCT NEW ELEMENT */\n/* ========================================================================= */\n\n        /* -----------------------------------------------------------------\n         * At this point, me is the pivotal supervariable.  It will be\n         * converted into the current element.  Scan list of the pivotal\n         * supervariable, me, setting tree pointers and constructing new list\n         * of supervariables for the new element, me.  p is a pointer to the\n         * current position in the old list.\n         * ----------------------------------------------------------------- */\n\n        /* flag the variable \"me\" as being in Lme by negating Nv [me] */\n        Nv [me] = -nvpiv ;\n        degme = 0 ;\n        ASSERT (Pe [me] >= 0 && Pe [me] < iwlen) ;\n\n        if (elenme == 0)\n        {\n\n            /* ------------------------------------------------------------- */\n            /* construct the new element in place */\n            /* ------------------------------------------------------------- */\n\n            pme1 = Pe [me] ;\n            pme2 = pme1 - 1 ;\n\n            for (p = pme1 ; p <= pme1 + Len [me] - 1 ; p++)\n            {\n                i = Iw [p] ;\n                ASSERT (i >= 0 && i < n && Nv [i] >= 0) ;\n                nvi = Nv [i] ;\n                if (nvi > 0)\n                {\n\n                    /* ----------------------------------------------------- */\n                    /* i is a principal variable not yet placed in Lme. */\n                    /* store i in new list */\n                    /* ----------------------------------------------------- */\n\n                    /* flag i as being in Lme by negating Nv [i] */\n                    degme += nvi ;\n                    Nv [i] = -nvi ;\n                    Iw [++pme2] = i ;\n\n                    /* ----------------------------------------------------- */\n                    /* remove variable i from degree list. */\n                    /* ----------------------------------------------------- */\n\n                    ilast = Last [i] ;\n                    inext = Next [i] ;\n                    ASSERT (ilast >= EMPTY && ilast < n) ;\n                    ASSERT (inext >= EMPTY && inext < n) ;\n                    if (inext != EMPTY) Last [inext] = ilast ;\n                    if (ilast != EMPTY)\n                    {\n                        Next [ilast] = inext ;\n                    }\n                    else\n                    {\n                        /* i is at the head of the degree list */\n                        ASSERT (Degree [i] >= 0 && Degree [i] < n) ;\n                        Head [Degree [i]] = inext ;\n                    }\n                }\n            }\n        }\n        else\n        {\n\n            /* ------------------------------------------------------------- */\n            /* construct the new element in empty space, Iw [pfree ...] */\n            /* ------------------------------------------------------------- */\n\n            p = Pe [me] ;\n            pme1 = pfree ;\n            slenme = Len [me] - elenme ;\n\n            for (knt1 = 1 ; knt1 <= elenme + 1 ; knt1++)\n            {\n\n                if (knt1 > elenme)\n                {\n                    /* search the supervariables in me. */\n                    e = me ;\n                    pj = p ;\n                    ln = slenme ;\n                    AMD_DEBUG2 ((\"Search sv: \"ID\" \"ID\" \"ID\"\\n\", me,pj,ln)) ;\n                }\n                else\n                {\n                    /* search the elements in me. */\n                    e = Iw [p++] ;\n                    ASSERT (e >= 0 && e < n) ;\n                    pj = Pe [e] ;\n                    ln = Len [e] ;\n                    AMD_DEBUG2 ((\"Search element e \"ID\" in me \"ID\"\\n\", e,me)) ;\n                    ASSERT (Elen [e] < EMPTY && W [e] > 0 && pj >= 0) ;\n                }\n                ASSERT (ln >= 0 && (ln == 0 || (pj >= 0 && pj < iwlen))) ;\n\n                /* ---------------------------------------------------------\n                 * search for different supervariables and add them to the\n                 * new list, compressing when necessary. this loop is\n                 * executed once for each element in the list and once for\n                 * all the supervariables in the list.\n                 * --------------------------------------------------------- */\n\n                for (knt2 = 1 ; knt2 <= ln ; knt2++)\n                {\n                    i = Iw [pj++] ;\n                    ASSERT (i >= 0 && i < n && (i == me || Elen [i] >= EMPTY));\n                    nvi = Nv [i] ;\n                    AMD_DEBUG2 ((\": \"ID\" \"ID\" \"ID\" \"ID\"\\n\",\n                                i, Elen [i], Nv [i], wflg)) ;\n\n                    if (nvi > 0)\n                    {\n\n                        /* ------------------------------------------------- */\n                        /* compress Iw, if necessary */\n                        /* ------------------------------------------------- */\n\n                        if (pfree >= iwlen)\n                        {\n\n                            AMD_DEBUG1 ((\"GARBAGE COLLECTION\\n\")) ;\n\n                            /* prepare for compressing Iw by adjusting pointers\n                             * and lengths so that the lists being searched in\n                             * the inner and outer loops contain only the\n                             * remaining entries. */\n\n                            Pe [me] = p ;\n                            Len [me] -= knt1 ;\n                            /* check if nothing left of supervariable me */\n                            if (Len [me] == 0) Pe [me] = EMPTY ;\n                            Pe [e] = pj ;\n                            Len [e] = ln - knt2 ;\n                            /* nothing left of element e */\n                            if (Len [e] == 0) Pe [e] = EMPTY ;\n\n                            ncmpa++ ;   /* one more garbage collection */\n\n                            /* store first entry of each object in Pe */\n                            /* FLIP the first entry in each object */\n                            for (j = 0 ; j < n ; j++)\n                            {\n                                pn = Pe [j] ;\n                                if (pn >= 0)\n                                {\n                                    ASSERT (pn >= 0 && pn < iwlen) ;\n                                    Pe [j] = Iw [pn] ;\n                                    Iw [pn] = FLIP (j) ;\n                                }\n                            }\n\n                            /* psrc/pdst point to source/destination */\n                            psrc = 0 ;\n                            pdst = 0 ;\n                            pend = pme1 - 1 ;\n\n                            while (psrc <= pend)\n                            {\n                                /* search for next FLIP'd entry */\n                                j = FLIP (Iw [psrc++]) ;\n                                if (j >= 0)\n                                {\n                                    AMD_DEBUG2 ((\"Got object j: \"ID\"\\n\", j)) ;\n                                    Iw [pdst] = Pe [j] ;\n                                    Pe [j] = pdst++ ;\n                                    lenj = Len [j] ;\n                                    /* copy from source to destination */\n                                    for (knt3 = 0 ; knt3 <= lenj - 2 ; knt3++)\n                                    {\n                                        Iw [pdst++] = Iw [psrc++] ;\n                                    }\n                                }\n                            }\n\n                            /* move the new partially-constructed element */\n                            p1 = pdst ;\n                            for (psrc = pme1 ; psrc <= pfree-1 ; psrc++)\n                            {\n                                Iw [pdst++] = Iw [psrc] ;\n                            }\n                            pme1 = p1 ;\n                            pfree = pdst ;\n                            pj = Pe [e] ;\n                            p = Pe [me] ;\n\n                        }\n\n                        /* ------------------------------------------------- */\n                        /* i is a principal variable not yet placed in Lme */\n                        /* store i in new list */\n                        /* ------------------------------------------------- */\n\n                        /* flag i as being in Lme by negating Nv [i] */\n                        degme += nvi ;\n                        Nv [i] = -nvi ;\n                        Iw [pfree++] = i ;\n                        AMD_DEBUG2 ((\"     s: \"ID\"     nv \"ID\"\\n\", i, Nv [i]));\n\n                        /* ------------------------------------------------- */\n                        /* remove variable i from degree link list */\n                        /* ------------------------------------------------- */\n\n                        ilast = Last [i] ;\n                        inext = Next [i] ;\n                        ASSERT (ilast >= EMPTY && ilast < n) ;\n                        ASSERT (inext >= EMPTY && inext < n) ;\n                        if (inext != EMPTY) Last [inext] = ilast ;\n                        if (ilast != EMPTY)\n                        {\n                            Next [ilast] = inext ;\n                        }\n                        else\n                        {\n                            /* i is at the head of the degree list */\n                            ASSERT (Degree [i] >= 0 && Degree [i] < n) ;\n                            Head [Degree [i]] = inext ;\n                        }\n                    }\n                }\n\n                if (e != me)\n                {\n                    /* set tree pointer and flag to indicate element e is\n                     * absorbed into new element me (the parent of e is me) */\n                    AMD_DEBUG1 ((\" Element \"ID\" => \"ID\"\\n\", e, me)) ;\n                    Pe [e] = FLIP (me) ;\n                    W [e] = 0 ;\n                }\n            }\n\n            pme2 = pfree - 1 ;\n        }\n\n        /* ----------------------------------------------------------------- */\n        /* me has now been converted into an element in Iw [pme1..pme2] */\n        /* ----------------------------------------------------------------- */\n\n        /* degme holds the external degree of new element */\n        Degree [me] = degme ;\n        Pe [me] = pme1 ;\n        Len [me] = pme2 - pme1 + 1 ;\n        ASSERT (Pe [me] >= 0 && Pe [me] < iwlen) ;\n\n        Elen [me] = FLIP (nvpiv + degme) ;\n        /* FLIP (Elen (me)) is now the degree of pivot (including\n         * diagonal part). */\n\n#ifndef NDEBUG\n        AMD_DEBUG2 ((\"New element structure: length= \"ID\"\\n\", pme2-pme1+1)) ;\n        for (pme = pme1 ; pme <= pme2 ; pme++) AMD_DEBUG3 ((\" \"ID\"\", Iw[pme]));\n        AMD_DEBUG3 ((\"\\n\")) ;\n#endif\n\n        /* ----------------------------------------------------------------- */\n        /* make sure that wflg is not too large. */\n        /* ----------------------------------------------------------------- */\n\n        /* With the current value of wflg, wflg+n must not cause integer\n         * overflow */\n\n        wflg = clear_flag (wflg, wbig, W, n) ;\n\n/* ========================================================================= */\n/* COMPUTE (W [e] - wflg) = |Le\\Lme| FOR ALL ELEMENTS */\n/* ========================================================================= */\n\n        /* -----------------------------------------------------------------\n         * Scan 1:  compute the external degrees of previous elements with\n         * respect to the current element.  That is:\n         *       (W [e] - wflg) = |Le \\ Lme|\n         * for each element e that appears in any supervariable in Lme.  The\n         * notation Le refers to the pattern (list of supervariables) of a\n         * previous element e, where e is not yet absorbed, stored in\n         * Iw [Pe [e] + 1 ... Pe [e] + Len [e]].  The notation Lme\n         * refers to the pattern of the current element (stored in\n         * Iw [pme1..pme2]).   If aggressive absorption is enabled, and\n         * (W [e] - wflg) becomes zero, then the element e will be absorbed\n         * in Scan 2.\n         * ----------------------------------------------------------------- */\n\n        AMD_DEBUG2 ((\"me: \")) ;\n        for (pme = pme1 ; pme <= pme2 ; pme++)\n        {\n            i = Iw [pme] ;\n            ASSERT (i >= 0 && i < n) ;\n            eln = Elen [i] ;\n            AMD_DEBUG3 ((\"\"ID\" Elen \"ID\": \\n\", i, eln)) ;\n            if (eln > 0)\n            {\n                /* note that Nv [i] has been negated to denote i in Lme: */\n                nvi = -Nv [i] ;\n                ASSERT (nvi > 0 && Pe [i] >= 0 && Pe [i] < iwlen) ;\n                wnvi = wflg - nvi ;\n                for (p = Pe [i] ; p <= Pe [i] + eln - 1 ; p++)\n                {\n                    e = Iw [p] ;\n                    ASSERT (e >= 0 && e < n) ;\n                    we = W [e] ;\n                    AMD_DEBUG4 ((\"    e \"ID\" we \"ID\" \", e, we)) ;\n                    if (we >= wflg)\n                    {\n                        /* unabsorbed element e has been seen in this loop */\n                        AMD_DEBUG4 ((\"    unabsorbed, first time seen\")) ;\n                        we -= nvi ;\n                    }\n                    else if (we != 0)\n                    {\n                        /* e is an unabsorbed element */\n                        /* this is the first we have seen e in all of Scan 1 */\n                        AMD_DEBUG4 ((\"    unabsorbed\")) ;\n                        we = Degree [e] + wnvi ;\n                    }\n                    AMD_DEBUG4 ((\"\\n\")) ;\n                    W [e] = we ;\n                }\n            }\n        }\n        AMD_DEBUG2 ((\"\\n\")) ;\n\n/* ========================================================================= */\n/* DEGREE UPDATE AND ELEMENT ABSORPTION */\n/* ========================================================================= */\n\n        /* -----------------------------------------------------------------\n         * Scan 2:  for each i in Lme, sum up the degree of Lme (which is\n         * degme), plus the sum of the external degrees of each Le for the\n         * elements e appearing within i, plus the supervariables in i.\n         * Place i in hash list.\n         * ----------------------------------------------------------------- */\n\n        for (pme = pme1 ; pme <= pme2 ; pme++)\n        {\n            i = Iw [pme] ;\n            ASSERT (i >= 0 && i < n && Nv [i] < 0 && Elen [i] >= 0) ;\n            AMD_DEBUG2 ((\"Updating: i \"ID\" \"ID\" \"ID\"\\n\", i, Elen[i], Len [i]));\n            p1 = Pe [i] ;\n            p2 = p1 + Elen [i] - 1 ;\n            pn = p1 ;\n            hash = 0 ;\n            deg = 0 ;\n            ASSERT (p1 >= 0 && p1 < iwlen && p2 >= -1 && p2 < iwlen) ;\n\n            /* ------------------------------------------------------------- */\n            /* scan the element list associated with supervariable i */\n            /* ------------------------------------------------------------- */\n\n            /* UMFPACK/MA38-style approximate degree: */\n            if (aggressive)\n            {\n                for (p = p1 ; p <= p2 ; p++)\n                {\n                    e = Iw [p] ;\n                    ASSERT (e >= 0 && e < n) ;\n                    we = W [e] ;\n                    if (we != 0)\n                    {\n                        /* e is an unabsorbed element */\n                        /* dext = | Le \\ Lme | */\n                        dext = we - wflg ;\n                        if (dext > 0)\n                        {\n                            deg += dext ;\n                            Iw [pn++] = e ;\n                            hash += e ;\n                            AMD_DEBUG4 ((\" e: \"ID\" hash = \"ID\"\\n\",e,hash)) ;\n                        }\n                        else\n                        {\n                            /* external degree of e is zero, absorb e into me*/\n                            AMD_DEBUG1 ((\" Element \"ID\" =>\"ID\" (aggressive)\\n\",\n                                e, me)) ;\n                            ASSERT (dext == 0) ;\n                            Pe [e] = FLIP (me) ;\n                            W [e] = 0 ;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for (p = p1 ; p <= p2 ; p++)\n                {\n                    e = Iw [p] ;\n                    ASSERT (e >= 0 && e < n) ;\n                    we = W [e] ;\n                    if (we != 0)\n                    {\n                        /* e is an unabsorbed element */\n                        dext = we - wflg ;\n                        ASSERT (dext >= 0) ;\n                        deg += dext ;\n                        Iw [pn++] = e ;\n                        hash += e ;\n                        AMD_DEBUG4 ((\"  e: \"ID\" hash = \"ID\"\\n\",e,hash)) ;\n                    }\n                }\n            }\n\n            /* count the number of elements in i (including me): */\n            Elen [i] = pn - p1 + 1 ;\n\n            /* ------------------------------------------------------------- */\n            /* scan the supervariables in the list associated with i */\n            /* ------------------------------------------------------------- */\n\n            /* The bulk of the AMD run time is typically spent in this loop,\n             * particularly if the matrix has many dense rows that are not\n             * removed prior to ordering. */\n            p3 = pn ;\n            p4 = p1 + Len [i] ;\n            for (p = p2 + 1 ; p < p4 ; p++)\n            {\n                j = Iw [p] ;\n                ASSERT (j >= 0 && j < n) ;\n                nvj = Nv [j] ;\n                if (nvj > 0)\n                {\n                    /* j is unabsorbed, and not in Lme. */\n                    /* add to degree and add to new list */\n                    deg += nvj ;\n                    Iw [pn++] = j ;\n                    hash += j ;\n                    AMD_DEBUG4 ((\"  s: \"ID\" hash \"ID\" Nv[j]= \"ID\"\\n\",\n                                j, hash, nvj)) ;\n                }\n            }\n\n            /* ------------------------------------------------------------- */\n            /* update the degree and check for mass elimination */\n            /* ------------------------------------------------------------- */\n\n            /* with aggressive absorption, deg==0 is identical to the\n             * Elen [i] == 1 && p3 == pn test, below. */\n            ASSERT (IMPLIES (aggressive, (deg==0) == (Elen[i]==1 && p3==pn))) ;\n\n            if (Elen [i] == 1 && p3 == pn)\n            {\n\n                /* --------------------------------------------------------- */\n                /* mass elimination */\n                /* --------------------------------------------------------- */\n\n                /* There is nothing left of this node except for an edge to\n                 * the current pivot element.  Elen [i] is 1, and there are\n                 * no variables adjacent to node i.  Absorb i into the\n                 * current pivot element, me.  Note that if there are two or\n                 * more mass eliminations, fillin due to mass elimination is\n                 * possible within the nvpiv-by-nvpiv pivot block.  It is this\n                 * step that causes AMD's analysis to be an upper bound.\n                 *\n                 * The reason is that the selected pivot has a lower\n                 * approximate degree than the true degree of the two mass\n                 * eliminated nodes.  There is no edge between the two mass\n                 * eliminated nodes.  They are merged with the current pivot\n                 * anyway.\n                 *\n                 * No fillin occurs in the Schur complement, in any case,\n                 * and this effect does not decrease the quality of the\n                 * ordering itself, just the quality of the nonzero and\n                 * flop count analysis.  It also means that the post-ordering\n                 * is not an exact elimination tree post-ordering. */\n\n                AMD_DEBUG1 ((\"  MASS i \"ID\" => parent e \"ID\"\\n\", i, me)) ;\n                Pe [i] = FLIP (me) ;\n                nvi = -Nv [i] ;\n                degme -= nvi ;\n                nvpiv += nvi ;\n                nel += nvi ;\n                Nv [i] = 0 ;\n                Elen [i] = EMPTY ;\n\n            }\n            else\n            {\n\n                /* --------------------------------------------------------- */\n                /* update the upper-bound degree of i */\n                /* --------------------------------------------------------- */\n\n                /* the following degree does not yet include the size\n                 * of the current element, which is added later: */\n\n                Degree [i] = MIN (Degree [i], deg) ;\n\n                /* --------------------------------------------------------- */\n                /* add me to the list for i */\n                /* --------------------------------------------------------- */\n\n                /* move first supervariable to end of list */\n                Iw [pn] = Iw [p3] ;\n                /* move first element to end of element part of list */\n                Iw [p3] = Iw [p1] ;\n                /* add new element, me, to front of list. */\n                Iw [p1] = me ;\n                /* store the new length of the list in Len [i] */\n                Len [i] = pn - p1 + 1 ;\n\n                /* --------------------------------------------------------- */\n                /* place in hash bucket.  Save hash key of i in Last [i]. */\n                /* --------------------------------------------------------- */\n\n                /* NOTE: this can fail if hash is negative, because the ANSI C\n                 * standard does not define a % b when a and/or b are negative.\n                 * That's why hash is defined as an unsigned Int, to avoid this\n                 * problem. */\n                hash = hash % n ;\n                ASSERT (((Int) hash) >= 0 && ((Int) hash) < n) ;\n\n                /* if the Hhead array is not used: */\n                j = Head [hash] ;\n                if (j <= EMPTY)\n                {\n                    /* degree list is empty, hash head is FLIP (j) */\n                    Next [i] = FLIP (j) ;\n                    Head [hash] = FLIP (i) ;\n                }\n                else\n                {\n                    /* degree list is not empty, use Last [Head [hash]] as\n                     * hash head. */\n                    Next [i] = Last [j] ;\n                    Last [j] = i ;\n                }\n\n                /* if a separate Hhead array is used: *\n                Next [i] = Hhead [hash] ;\n                Hhead [hash] = i ;\n                */\n\n                Last [i] = hash ;\n            }\n        }\n\n        Degree [me] = degme ;\n\n        /* ----------------------------------------------------------------- */\n        /* Clear the counter array, W [...], by incrementing wflg. */\n        /* ----------------------------------------------------------------- */\n\n        /* make sure that wflg+n does not cause integer overflow */\n        lemax =  MAX (lemax, degme) ;\n        wflg += lemax ;\n        wflg = clear_flag (wflg, wbig, W, n) ;\n        /*  at this point, W [0..n-1] < wflg holds */\n\n/* ========================================================================= */\n/* SUPERVARIABLE DETECTION */\n/* ========================================================================= */\n\n        AMD_DEBUG1 ((\"Detecting supervariables:\\n\")) ;\n        for (pme = pme1 ; pme <= pme2 ; pme++)\n        {\n            i = Iw [pme] ;\n            ASSERT (i >= 0 && i < n) ;\n            AMD_DEBUG2 ((\"Consider i \"ID\" nv \"ID\"\\n\", i, Nv [i])) ;\n            if (Nv [i] < 0)\n            {\n                /* i is a principal variable in Lme */\n\n                /* ---------------------------------------------------------\n                 * examine all hash buckets with 2 or more variables.  We do\n                 * this by examing all unique hash keys for supervariables in\n                 * the pattern Lme of the current element, me\n                 * --------------------------------------------------------- */\n\n                /* let i = head of hash bucket, and empty the hash bucket */\n                ASSERT (Last [i] >= 0 && Last [i] < n) ;\n                hash = Last [i] ;\n\n                /* if Hhead array is not used: */\n                j = Head [hash] ;\n                if (j == EMPTY)\n                {\n                    /* hash bucket and degree list are both empty */\n                    i = EMPTY ;\n                }\n                else if (j < EMPTY)\n                {\n                    /* degree list is empty */\n                    i = FLIP (j) ;\n                    Head [hash] = EMPTY ;\n                }\n                else\n                {\n                    /* degree list is not empty, restore Last [j] of head j */\n                    i = Last [j] ;\n                    Last [j] = EMPTY ;\n                }\n\n                /* if separate Hhead array is used: *\n                i = Hhead [hash] ;\n                Hhead [hash] = EMPTY ;\n                */\n\n                ASSERT (i >= EMPTY && i < n) ;\n                AMD_DEBUG2 ((\"----i \"ID\" hash \"ID\"\\n\", i, hash)) ;\n\n                while (i != EMPTY && Next [i] != EMPTY)\n                {\n\n                    /* -----------------------------------------------------\n                     * this bucket has one or more variables following i.\n                     * scan all of them to see if i can absorb any entries\n                     * that follow i in hash bucket.  Scatter i into w.\n                     * ----------------------------------------------------- */\n\n                    ln = Len [i] ;\n                    eln = Elen [i] ;\n                    ASSERT (ln >= 0 && eln >= 0) ;\n                    ASSERT (Pe [i] >= 0 && Pe [i] < iwlen) ;\n                    /* do not flag the first element in the list (me) */\n                    for (p = Pe [i] + 1 ; p <= Pe [i] + ln - 1 ; p++)\n                    {\n                        ASSERT (Iw [p] >= 0 && Iw [p] < n) ;\n                        W [Iw [p]] = wflg ;\n                    }\n\n                    /* ----------------------------------------------------- */\n                    /* scan every other entry j following i in bucket */\n                    /* ----------------------------------------------------- */\n\n                    jlast = i ;\n                    j = Next [i] ;\n                    ASSERT (j >= EMPTY && j < n) ;\n\n                    while (j != EMPTY)\n                    {\n                        /* ------------------------------------------------- */\n                        /* check if j and i have identical nonzero pattern */\n                        /* ------------------------------------------------- */\n\n                        AMD_DEBUG3 ((\"compare i \"ID\" and j \"ID\"\\n\", i,j)) ;\n\n                        /* check if i and j have the same Len and Elen */\n                        ASSERT (Len [j] >= 0 && Elen [j] >= 0) ;\n                        ASSERT (Pe [j] >= 0 && Pe [j] < iwlen) ;\n                        ok = (Len [j] == ln) && (Elen [j] == eln) ;\n                        /* skip the first element in the list (me) */\n                        for (p = Pe [j] + 1 ; ok && p <= Pe [j] + ln - 1 ; p++)\n                        {\n                            ASSERT (Iw [p] >= 0 && Iw [p] < n) ;\n                            if (W [Iw [p]] != wflg) ok = 0 ;\n                        }\n                        if (ok)\n                        {\n                            /* --------------------------------------------- */\n                            /* found it!  j can be absorbed into i */\n                            /* --------------------------------------------- */\n\n                            AMD_DEBUG1 ((\"found it! j \"ID\" => i \"ID\"\\n\", j,i));\n                            Pe [j] = FLIP (i) ;\n                            /* both Nv [i] and Nv [j] are negated since they */\n                            /* are in Lme, and the absolute values of each */\n                            /* are the number of variables in i and j: */\n                            Nv [i] += Nv [j] ;\n                            Nv [j] = 0 ;\n                            Elen [j] = EMPTY ;\n                            /* delete j from hash bucket */\n                            ASSERT (j != Next [j]) ;\n                            j = Next [j] ;\n                            Next [jlast] = j ;\n\n                        }\n                        else\n                        {\n                            /* j cannot be absorbed into i */\n                            jlast = j ;\n                            ASSERT (j != Next [j]) ;\n                            j = Next [j] ;\n                        }\n                        ASSERT (j >= EMPTY && j < n) ;\n                    }\n\n                    /* -----------------------------------------------------\n                     * no more variables can be absorbed into i\n                     * go to next i in bucket and clear flag array\n                     * ----------------------------------------------------- */\n\n                    wflg++ ;\n                    i = Next [i] ;\n                    ASSERT (i >= EMPTY && i < n) ;\n\n                }\n            }\n        }\n        AMD_DEBUG2 ((\"detect done\\n\")) ;\n\n/* ========================================================================= */\n/* RESTORE DEGREE LISTS AND REMOVE NONPRINCIPAL SUPERVARIABLES FROM ELEMENT */\n/* ========================================================================= */\n\n        p = pme1 ;\n        nleft = n - nel ;\n        for (pme = pme1 ; pme <= pme2 ; pme++)\n        {\n            i = Iw [pme] ;\n            ASSERT (i >= 0 && i < n) ;\n            nvi = -Nv [i] ;\n            AMD_DEBUG3 ((\"Restore i \"ID\" \"ID\"\\n\", i, nvi)) ;\n            if (nvi > 0)\n            {\n                /* i is a principal variable in Lme */\n                /* restore Nv [i] to signify that i is principal */\n                Nv [i] = nvi ;\n\n                /* --------------------------------------------------------- */\n                /* compute the external degree (add size of current element) */\n                /* --------------------------------------------------------- */\n\n                deg = Degree [i] + degme - nvi ;\n                deg = MIN (deg, nleft - nvi) ;\n                ASSERT (IMPLIES (aggressive, deg > 0) && deg >= 0 && deg < n) ;\n\n                /* --------------------------------------------------------- */\n                /* place the supervariable at the head of the degree list */\n                /* --------------------------------------------------------- */\n\n                inext = Head [deg] ;\n                ASSERT (inext >= EMPTY && inext < n) ;\n                if (inext != EMPTY) Last [inext] = i ;\n                Next [i] = inext ;\n                Last [i] = EMPTY ;\n                Head [deg] = i ;\n\n                /* --------------------------------------------------------- */\n                /* save the new degree, and find the minimum degree */\n                /* --------------------------------------------------------- */\n\n                mindeg = MIN (mindeg, deg) ;\n                Degree [i] = deg ;\n\n                /* --------------------------------------------------------- */\n                /* place the supervariable in the element pattern */\n                /* --------------------------------------------------------- */\n\n                Iw [p++] = i ;\n\n            }\n        }\n        AMD_DEBUG2 ((\"restore done\\n\")) ;\n\n/* ========================================================================= */\n/* FINALIZE THE NEW ELEMENT */\n/* ========================================================================= */\n\n        AMD_DEBUG2 ((\"ME = \"ID\" DONE\\n\", me)) ;\n        Nv [me] = nvpiv ;\n        /* save the length of the list for the new element me */\n        Len [me] = p - pme1 ;\n        if (Len [me] == 0)\n        {\n            /* there is nothing left of the current pivot element */\n            /* it is a root of the assembly tree */\n            Pe [me] = EMPTY ;\n            W [me] = 0 ;\n        }\n        if (elenme != 0)\n        {\n            /* element was not constructed in place: deallocate part of */\n            /* it since newly nonprincipal variables may have been removed */\n            pfree = p ;\n        }\n\n        /* The new element has nvpiv pivots and the size of the contribution\n         * block for a multifrontal method is degme-by-degme, not including\n         * the \"dense\" rows/columns.  If the \"dense\" rows/columns are included,\n         * the frontal matrix is no larger than\n         * (degme+ndense)-by-(degme+ndense).\n         */\n\n        if (Info != (double *) NULL)\n        {\n            f = nvpiv ;\n            r = degme + ndense ;\n            dmax = MAX (dmax, f + r) ;\n\n            /* number of nonzeros in L (excluding the diagonal) */\n            lnzme = f*r + (f-1)*f/2 ;\n            lnz += lnzme ;\n\n            /* number of divide operations for LDL' and for LU */\n            ndiv += lnzme ;\n\n            /* number of multiply-subtract pairs for LU */\n            s = f*r*r + r*(f-1)*f + (f-1)*f*(2*f-1)/6 ;\n            nms_lu += s ;\n\n            /* number of multiply-subtract pairs for LDL' */\n            nms_ldl += (s + lnzme)/2 ;\n        }\n\n#ifndef NDEBUG\n        AMD_DEBUG2 ((\"finalize done nel \"ID\" n \"ID\"\\n   ::::\\n\", nel, n)) ;\n        for (pme = Pe [me] ; pme <= Pe [me] + Len [me] - 1 ; pme++)\n        {\n              AMD_DEBUG3 ((\" \"ID\"\", Iw [pme])) ;\n        }\n        AMD_DEBUG3 ((\"\\n\")) ;\n#endif\n\n    }\n\n/* ========================================================================= */\n/* DONE SELECTING PIVOTS */\n/* ========================================================================= */\n\n    if (Info != (double *) NULL)\n    {\n\n        /* count the work to factorize the ndense-by-ndense submatrix */\n        f = ndense ;\n        dmax = MAX (dmax, (double) ndense) ;\n\n        /* number of nonzeros in L (excluding the diagonal) */\n        lnzme = (f-1)*f/2 ;\n        lnz += lnzme ;\n\n        /* number of divide operations for LDL' and for LU */\n        ndiv += lnzme ;\n\n        /* number of multiply-subtract pairs for LU */\n        s = (f-1)*f*(2*f-1)/6 ;\n        nms_lu += s ;\n\n        /* number of multiply-subtract pairs for LDL' */\n        nms_ldl += (s + lnzme)/2 ;\n\n        /* number of nz's in L (excl. diagonal) */\n        Info [AMD_LNZ] = lnz ;\n\n        /* number of divide ops for LU and LDL' */\n        Info [AMD_NDIV] = ndiv ;\n\n        /* number of multiply-subtract pairs for LDL' */\n        Info [AMD_NMULTSUBS_LDL] = nms_ldl ;\n\n        /* number of multiply-subtract pairs for LU */\n        Info [AMD_NMULTSUBS_LU] = nms_lu ;\n\n        /* number of \"dense\" rows/columns */\n        Info [AMD_NDENSE] = ndense ;\n\n        /* largest front is dmax-by-dmax */\n        Info [AMD_DMAX] = dmax ;\n\n        /* number of garbage collections in AMD */\n        Info [AMD_NCMPA] = ncmpa ;\n\n        /* successful ordering */\n        Info [AMD_STATUS] = AMD_OK ;\n    }\n\n/* ========================================================================= */\n/* POST-ORDERING */\n/* ========================================================================= */\n\n/* -------------------------------------------------------------------------\n * Variables at this point:\n *\n * Pe: holds the elimination tree.  The parent of j is FLIP (Pe [j]),\n *      or EMPTY if j is a root.  The tree holds both elements and\n *      non-principal (unordered) variables absorbed into them.\n *      Dense variables are non-principal and unordered.\n *\n * Elen: holds the size of each element, including the diagonal part.\n *      FLIP (Elen [e]) > 0 if e is an element.  For unordered\n *      variables i, Elen [i] is EMPTY.\n *\n * Nv: Nv [e] > 0 is the number of pivots represented by the element e.\n *      For unordered variables i, Nv [i] is zero.\n *\n * Contents no longer needed:\n *      W, Iw, Len, Degree, Head, Next, Last.\n *\n * The matrix itself has been destroyed.\n *\n * n: the size of the matrix.\n * No other scalars needed (pfree, iwlen, etc.)\n * ------------------------------------------------------------------------- */\n\n    /* restore Pe */\n    for (i = 0 ; i < n ; i++)\n    {\n        Pe [i] = FLIP (Pe [i]) ;\n    }\n\n    /* restore Elen, for output information, and for postordering */\n    for (i = 0 ; i < n ; i++)\n    {\n        Elen [i] = FLIP (Elen [i]) ;\n    }\n\n/* Now the parent of j is Pe [j], or EMPTY if j is a root.  Elen [e] > 0\n * is the size of element e.  Elen [i] is EMPTY for unordered variable i. */\n\n#ifndef NDEBUG\n    AMD_DEBUG2 ((\"\\nTree:\\n\")) ;\n    for (i = 0 ; i < n ; i++)\n    {\n        AMD_DEBUG2 ((\" \"ID\" parent: \"ID\"   \", i, Pe [i])) ;\n        ASSERT (Pe [i] >= EMPTY && Pe [i] < n) ;\n        if (Nv [i] > 0)\n        {\n            /* this is an element */\n            e = i ;\n            AMD_DEBUG2 ((\" element, size is \"ID\"\\n\", Elen [i])) ;\n            ASSERT (Elen [e] > 0) ;\n        }\n        AMD_DEBUG2 ((\"\\n\")) ;\n    }\n    AMD_DEBUG2 ((\"\\nelements:\\n\")) ;\n    for (e = 0 ; e < n ; e++)\n    {\n        if (Nv [e] > 0)\n        {\n            AMD_DEBUG3 ((\"Element e= \"ID\" size \"ID\" nv \"ID\" \\n\", e,\n                Elen [e], Nv [e])) ;\n        }\n    }\n    AMD_DEBUG2 ((\"\\nvariables:\\n\")) ;\n    for (i = 0 ; i < n ; i++)\n    {\n        Int cnt ;\n        if (Nv [i] == 0)\n        {\n            AMD_DEBUG3 ((\"i unordered: \"ID\"\\n\", i)) ;\n            j = Pe [i] ;\n            cnt = 0 ;\n            AMD_DEBUG3 ((\"  j: \"ID\"\\n\", j)) ;\n            if (j == EMPTY)\n            {\n                AMD_DEBUG3 ((\"  i is a dense variable\\n\")) ;\n            }\n            else\n            {\n                ASSERT (j >= 0 && j < n) ;\n                while (Nv [j] == 0)\n                {\n                    AMD_DEBUG3 ((\"      j : \"ID\"\\n\", j)) ;\n                    j = Pe [j] ;\n                    AMD_DEBUG3 ((\"      j:: \"ID\"\\n\", j)) ;\n                    cnt++ ;\n                    if (cnt > n) break ;\n                }\n                e = j ;\n                AMD_DEBUG3 ((\"  got to e: \"ID\"\\n\", e)) ;\n            }\n        }\n    }\n#endif\n\n/* ========================================================================= */\n/* compress the paths of the variables */\n/* ========================================================================= */\n\n    for (i = 0 ; i < n ; i++)\n    {\n        if (Nv [i] == 0)\n        {\n\n            /* -------------------------------------------------------------\n             * i is an un-ordered row.  Traverse the tree from i until\n             * reaching an element, e.  The element, e, was the principal\n             * supervariable of i and all nodes in the path from i to when e\n             * was selected as pivot.\n             * ------------------------------------------------------------- */\n\n            AMD_DEBUG1 ((\"Path compression, i unordered: \"ID\"\\n\", i)) ;\n            j = Pe [i] ;\n            ASSERT (j >= EMPTY && j < n) ;\n            AMD_DEBUG3 ((\"      j: \"ID\"\\n\", j)) ;\n            if (j == EMPTY)\n            {\n                /* Skip a dense variable.  It has no parent. */\n                AMD_DEBUG3 ((\"      i is a dense variable\\n\")) ;\n                continue ;\n            }\n\n            /* while (j is a variable) */\n            while (Nv [j] == 0)\n            {\n                AMD_DEBUG3 ((\"          j : \"ID\"\\n\", j)) ;\n                j = Pe [j] ;\n                AMD_DEBUG3 ((\"          j:: \"ID\"\\n\", j)) ;\n                ASSERT (j >= 0 && j < n) ;\n            }\n            /* got to an element e */\n            e = j ;\n            AMD_DEBUG3 ((\"got to e: \"ID\"\\n\", e)) ;\n\n            /* -------------------------------------------------------------\n             * traverse the path again from i to e, and compress the path\n             * (all nodes point to e).  Path compression allows this code to\n             * compute in O(n) time.\n             * ------------------------------------------------------------- */\n\n            j = i ;\n            /* while (j is a variable) */\n            while (Nv [j] == 0)\n            {\n                jnext = Pe [j] ;\n                AMD_DEBUG3 ((\"j \"ID\" jnext \"ID\"\\n\", j, jnext)) ;\n                Pe [j] = e ;\n                j = jnext ;\n                ASSERT (j >= 0 && j < n) ;\n            }\n        }\n    }\n\n/* ========================================================================= */\n/* postorder the assembly tree */\n/* ========================================================================= */\n\n    AMD_postorder (n, Pe, Nv, Elen,\n        W,                      /* output order */\n        Head, Next, Last) ;     /* workspace */\n\n/* ========================================================================= */\n/* compute output permutation and inverse permutation */\n/* ========================================================================= */\n\n    /* W [e] = k means that element e is the kth element in the new\n     * order.  e is in the range 0 to n-1, and k is in the range 0 to\n     * the number of elements.  Use Head for inverse order. */\n\n    for (k = 0 ; k < n ; k++)\n    {\n        Head [k] = EMPTY ;\n        Next [k] = EMPTY ;\n    }\n    for (e = 0 ; e < n ; e++)\n    {\n        k = W [e] ;\n        ASSERT ((k == EMPTY) == (Nv [e] == 0)) ;\n        if (k != EMPTY)\n        {\n            ASSERT (k >= 0 && k < n) ;\n            Head [k] = e ;\n        }\n    }\n\n    /* construct output inverse permutation in Next,\n     * and permutation in Last */\n    nel = 0 ;\n    for (k = 0 ; k < n ; k++)\n    {\n        e = Head [k] ;\n        if (e == EMPTY) break ;\n        ASSERT (e >= 0 && e < n && Nv [e] > 0) ;\n        Next [e] = nel ;\n        nel += Nv [e] ;\n    }\n    ASSERT (nel == n - ndense) ;\n\n    /* order non-principal variables (dense, & those merged into supervar's) */\n    for (i = 0 ; i < n ; i++)\n    {\n        if (Nv [i] == 0)\n        {\n            e = Pe [i] ;\n            ASSERT (e >= EMPTY && e < n) ;\n            if (e != EMPTY)\n            {\n                /* This is an unordered variable that was merged\n                 * into element e via supernode detection or mass\n                 * elimination of i when e became the pivot element.\n                 * Place i in order just before e. */\n                ASSERT (Next [i] == EMPTY && Nv [e] > 0) ;\n                Next [i] = Next [e] ;\n                Next [e]++ ;\n            }\n            else\n            {\n                /* This is a dense unordered variable, with no parent.\n                 * Place it last in the output order. */\n                Next [i] = nel++ ;\n            }\n        }\n    }\n    ASSERT (nel == n) ;\n\n    AMD_DEBUG2 ((\"\\n\\nPerm:\\n\")) ;\n    for (i = 0 ; i < n ; i++)\n    {\n        k = Next [i] ;\n        ASSERT (k >= 0 && k < n) ;\n        Last [k] = i ;\n        AMD_DEBUG2 ((\"   perm [\"ID\"] = \"ID\"\\n\", k, i)) ;\n    }\n}",
      "lines": 1800,
      "depth": 26,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_aat.c": {
    "AMD_aat": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "GLOBAL size_t AMD_aat   /* returns nz in A+A' */\n(\n    Int n,\n    const Int Ap [ ],\n    const Int Ai [ ],\n    Int Len [ ],        /* Len [j]: length of column j of A+A', excl diagonal*/\n    Int Tp [ ],         /* workspace of size n */\n    double Info [ ]\n)\n{\n    Int p1, p2, p, i, j, pj, pj2, k, nzdiag, nzboth, nz ;\n    double sym ;\n    size_t nzaat ;\n\n#ifndef NDEBUG\n    AMD_debug_init (\"AMD AAT\") ;\n    for (k = 0 ; k < n ; k++) Tp [k] = EMPTY ;\n    ASSERT (AMD_valid (n, n, Ap, Ai) == AMD_OK) ;\n#endif\n\n    if (Info != (double *) NULL)\n    {\n        /* clear the Info array, if it exists */\n        for (i = 0 ; i < AMD_INFO ; i++)\n        {\n            Info [i] = EMPTY ;\n        }\n        Info [AMD_STATUS] = AMD_OK ;\n    }\n\n    for (k = 0 ; k < n ; k++)\n    {\n        Len [k] = 0 ;\n    }\n\n    nzdiag = 0 ;\n    nzboth = 0 ;\n    nz = Ap [n] ;\n\n    for (k = 0 ; k < n ; k++)\n    {\n        p1 = Ap [k] ;\n        p2 = Ap [k+1] ;\n        AMD_DEBUG2 ((\"\\nAAT Column: \"ID\" p1: \"ID\" p2: \"ID\"\\n\", k, p1, p2)) ;\n\n        /* construct A+A' */\n        for (p = p1 ; p < p2 ; )\n        {\n            /* scan the upper triangular part of A */\n            j = Ai [p] ;\n            if (j < k)\n            {\n                /* entry A (j,k) is in the strictly upper triangular part,\n                 * add both A (j,k) and A (k,j) to the matrix A+A' */\n                Len [j]++ ;\n                Len [k]++ ;\n                AMD_DEBUG3 ((\"    upper (\"ID\",\"ID\") (\"ID\",\"ID\")\\n\", j,k, k,j));\n                p++ ;\n            }\n            else if (j == k)\n            {\n                /* skip the diagonal */\n                p++ ;\n                nzdiag++ ;\n                break ;\n            }\n            else /* j > k */\n            {\n                /* first entry below the diagonal */\n                break ;\n            }\n            /* scan lower triangular part of A, in column j until reaching\n             * row k.  Start where last scan left off. */\n            ASSERT (Tp [j] != EMPTY) ;\n            ASSERT (Ap [j] <= Tp [j] && Tp [j] <= Ap [j+1]) ;\n            pj2 = Ap [j+1] ;\n            for (pj = Tp [j] ; pj < pj2 ; )\n            {\n                i = Ai [pj] ;\n                if (i < k)\n                {\n                    /* A (i,j) is only in the lower part, not in upper.\n                     * add both A (i,j) and A (j,i) to the matrix A+A' */\n                    Len [i]++ ;\n                    Len [j]++ ;\n                    AMD_DEBUG3 ((\"    lower (\"ID\",\"ID\") (\"ID\",\"ID\")\\n\",\n                        i,j, j,i)) ;\n                    pj++ ;\n                }\n                else if (i == k)\n                {\n                    /* entry A (k,j) in lower part and A (j,k) in upper */\n                    pj++ ;\n                    nzboth++ ;\n                    break ;\n                }\n                else /* i > k */\n                {\n                    /* consider this entry later, when k advances to i */\n                    break ;\n                }\n            }\n            Tp [j] = pj ;\n        }\n        /* Tp [k] points to the entry just below the diagonal in column k */\n        Tp [k] = p ;\n    }\n\n    /* clean up, for remaining mismatched entries */\n    for (j = 0 ; j < n ; j++)\n    {\n        for (pj = Tp [j] ; pj < Ap [j+1] ; pj++)\n        {\n            i = Ai [pj] ;\n            /* A (i,j) is only in the lower part, not in upper.\n             * add both A (i,j) and A (j,i) to the matrix A+A' */\n            Len [i]++ ;\n            Len [j]++ ;\n            AMD_DEBUG3 ((\"    lower cleanup (\"ID\",\"ID\") (\"ID\",\"ID\")\\n\",\n                i,j, j,i)) ;\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* compute the symmetry of the nonzero pattern of A */\n    /* --------------------------------------------------------------------- */\n\n    /* Given a matrix A, the symmetry of A is:\n     *  B = tril (spones (A), -1) + triu (spones (A), 1) ;\n     *  sym = nnz (B & B') / nnz (B) ;\n     *  or 1 if nnz (B) is zero.\n     */\n\n    if (nz == nzdiag)\n    {\n        sym = 1 ;\n    }\n    else\n    {\n        sym = (2 * (double) nzboth) / ((double) (nz - nzdiag)) ;\n    }\n\n    nzaat = 0 ;\n    for (k = 0 ; k < n ; k++)\n    {\n        nzaat += Len [k] ;\n    }\n\n    AMD_DEBUG1 ((\"AMD nz in A+A', excluding diagonal (nzaat) = %g\\n\",\n        (double) nzaat)) ;\n    AMD_DEBUG1 ((\"   nzboth: \"ID\" nz: \"ID\" nzdiag: \"ID\" symmetry: %g\\n\",\n                nzboth, nz, nzdiag, sym)) ;\n\n    if (Info != (double *) NULL)\n    {\n        Info [AMD_STATUS] = AMD_OK ;\n        Info [AMD_N] = n ;\n        Info [AMD_NZ] = nz ;\n        Info [AMD_SYMMETRY] = sym ;         /* symmetry of pattern of A */\n        Info [AMD_NZDIAG] = nzdiag ;        /* nonzeros on diagonal of A */\n        Info [AMD_NZ_A_PLUS_AT] = nzaat ;   /* nonzeros in A+A' */\n    }\n\n    return (nzaat) ;\n}",
      "lines": 165,
      "depth": 19,
      "decorators": [
        "GLOBAL",
        "size_t",
        "size_t"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_control.c": {
    "AMD_control": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "GLOBAL void AMD_control\n(\n    double Control [ ]\n)\n{\n    double alpha ;\n    Int aggressive ;\n\n    if (Control != (double *) NULL)\n    {\n        alpha = Control [AMD_DENSE] ;\n        aggressive = Control [AMD_AGGRESSIVE] != 0 ;\n    }\n    else\n    {\n        alpha = AMD_DEFAULT_DENSE ;\n        aggressive = AMD_DEFAULT_AGGRESSIVE ;\n    }\n\n    PRINTF ((\"\\nAMD version %d.%d.%d, %s: approximate minimum degree ordering\\n\"\n        \"    dense row parameter: %g\\n\", AMD_MAIN_VERSION, AMD_SUB_VERSION,\n        AMD_SUBSUB_VERSION, AMD_DATE, alpha)) ;\n\n    if (alpha < 0)\n    {\n        PRINTF ((\"    no rows treated as dense\\n\")) ;\n    }\n    else\n    {\n        PRINTF ((\n        \"    (rows with more than max (%g * sqrt (n), 16) entries are\\n\"\n        \"    considered \\\"dense\\\", and placed last in output permutation)\\n\",\n        alpha)) ;\n    }\n\n    if (aggressive)\n    {\n        PRINTF ((\"    aggressive absorption:  yes\\n\")) ;\n    }\n    else\n    {\n        PRINTF ((\"    aggressive absorption:  no\\n\")) ;\n    }\n\n    PRINTF ((\"    size of AMD integer: %d\\n\\n\", sizeof (Int))) ;\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_defaults.c": {
    "AMD_defaults": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "GLOBAL void AMD_defaults\n(\n    double Control [ ]\n)\n{\n    Int i ;\n\n    if (Control != (double *) NULL)\n    {\n        for (i = 0 ; i < AMD_CONTROL ; i++)\n        {\n            Control [i] = 0 ;\n        }\n        Control [AMD_DENSE] = AMD_DEFAULT_DENSE ;\n        Control [AMD_AGGRESSIVE] = AMD_DEFAULT_AGGRESSIVE ;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_dump.c": {
    "AMD_debug_init": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "GLOBAL void AMD_debug_init ( char *s )\n{\n    FILE *f ;\n    f = fopen (\"debug.amd\", \"r\") ;\n    if (f == (FILE *) NULL)\n    {\n        AMD_debug = -999 ;\n    }\n    else\n    {\n        fscanf (f, ID, &AMD_debug) ;\n        fclose (f) ;\n    }\n    if (AMD_debug >= 0)\n    {\n        printf (\"%s: AMD_debug_init, D= \"ID\"\\n\", s, AMD_debug) ;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    },
    "AMD_dump": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "GLOBAL void AMD_dump (\n    Int n,          /* A is n-by-n */\n    Int Pe [ ],     /* pe [0..n-1]: index in iw of start of row i */\n    Int Iw [ ],     /* workspace of size iwlen, iwlen [0..pfree-1]\n                     * holds the matrix on input */\n    Int Len [ ],    /* len [0..n-1]: length for row i */\n    Int iwlen,      /* length of iw */\n    Int pfree,      /* iw [pfree ... iwlen-1] is empty on input */\n    Int Nv [ ],     /* nv [0..n-1] */\n    Int Next [ ],   /* next [0..n-1] */\n    Int Last [ ],   /* last [0..n-1] */\n    Int Head [ ],   /* head [0..n-1] */\n    Int Elen [ ],   /* size n */\n    Int Degree [ ], /* size n */\n    Int W [ ],      /* size n */\n    Int nel\n)\n{\n    Int i, pe, elen, nv, len, e, p, k, j, deg, w, cnt, ilast ;\n\n    if (AMD_debug < 0) return ;\n    ASSERT (pfree <= iwlen) ;\n    AMD_DEBUG3 ((\"\\nAMD dump, pfree: \"ID\"\\n\", pfree)) ;\n    for (i = 0 ; i < n ; i++)\n    {\n        pe = Pe [i] ;\n        elen = Elen [i] ;\n        nv = Nv [i] ;\n        len = Len [i] ;\n        w = W [i] ;\n\n        if (elen >= EMPTY)\n        {\n            if (nv == 0)\n            {\n                AMD_DEBUG3 ((\"\\nI \"ID\": nonprincipal:    \", i)) ;\n                ASSERT (elen == EMPTY) ;\n                if (pe == EMPTY)\n                {\n                    AMD_DEBUG3 ((\" dense node\\n\")) ;\n                    ASSERT (w == 1) ;\n                }\n                else\n                {\n                    ASSERT (pe < EMPTY) ;\n                    AMD_DEBUG3 ((\" i \"ID\" -> parent \"ID\"\\n\", i, FLIP (Pe[i])));\n                }\n            }\n            else\n            {\n                AMD_DEBUG3 ((\"\\nI \"ID\": active principal supervariable:\\n\",i));\n                AMD_DEBUG3 ((\"   nv(i): \"ID\"  Flag: %d\\n\", nv, (nv < 0))) ;\n                ASSERT (elen >= 0) ;\n                ASSERT (nv > 0 && pe >= 0) ;\n                p = pe ;\n                AMD_DEBUG3 ((\"   e/s: \")) ;\n                if (elen == 0) AMD_DEBUG3 ((\" : \")) ;\n                ASSERT (pe + len <= pfree) ;\n                for (k = 0 ; k < len ; k++)\n                {\n                    j = Iw [p] ;\n                    AMD_DEBUG3 ((\"  \"ID\"\", j)) ;\n                    ASSERT (j >= 0 && j < n) ;\n                    if (k == elen-1) AMD_DEBUG3 ((\" : \")) ;\n                    p++ ;\n                }\n                AMD_DEBUG3 ((\"\\n\")) ;\n            }\n        }\n        else\n        {\n            e = i ;\n            if (w == 0)\n            {\n                AMD_DEBUG3 ((\"\\nE \"ID\": absorbed element: w \"ID\"\\n\", e, w)) ;\n                ASSERT (nv > 0 && pe < 0) ;\n                AMD_DEBUG3 ((\" e \"ID\" -> parent \"ID\"\\n\", e, FLIP (Pe [e]))) ;\n            }\n            else\n            {\n                AMD_DEBUG3 ((\"\\nE \"ID\": unabsorbed element: w \"ID\"\\n\", e, w)) ;\n                ASSERT (nv > 0 && pe >= 0) ;\n                p = pe ;\n                AMD_DEBUG3 ((\" : \")) ;\n                ASSERT (pe + len <= pfree) ;\n                for (k = 0 ; k < len ; k++)\n                {\n                    j = Iw [p] ;\n                    AMD_DEBUG3 ((\"  \"ID\"\", j)) ;\n                    ASSERT (j >= 0 && j < n) ;\n                    p++ ;\n                }\n                AMD_DEBUG3 ((\"\\n\")) ;\n            }\n        }\n    }\n\n    /* this routine cannot be called when the hash buckets are non-empty */\n    AMD_DEBUG3 ((\"\\nDegree lists:\\n\")) ;\n    if (nel >= 0)\n    {\n        cnt = 0 ;\n        for (deg = 0 ; deg < n ; deg++)\n        {\n            if (Head [deg] == EMPTY) continue ;\n            ilast = EMPTY ;\n            AMD_DEBUG3 ((ID\": \\n\", deg)) ;\n            for (i = Head [deg] ; i != EMPTY ; i = Next [i])\n            {\n                AMD_DEBUG3 ((\"   \"ID\" : next \"ID\" last \"ID\" deg \"ID\"\\n\",\n                    i, Next [i], Last [i], Degree [i])) ;\n                ASSERT (i >= 0 && i < n && ilast == Last [i] &&\n                    deg == Degree [i]) ;\n                cnt += Nv [i] ;\n                ilast = i ;\n            }\n            AMD_DEBUG3 ((\"\\n\")) ;\n        }\n        ASSERT (cnt == n - nel) ;\n    }\n\n}",
      "lines": 122,
      "depth": 20,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_info.c": {
    "AMD_info": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "GLOBAL void AMD_info\n(\n    double Info [ ]\n)\n{\n    double n, ndiv, nmultsubs_ldl, nmultsubs_lu, lnz, lnzd ;\n\n    PRINTF ((\"\\nAMD version %d.%d.%d, %s, results:\\n\",\n        AMD_MAIN_VERSION, AMD_SUB_VERSION, AMD_SUBSUB_VERSION, AMD_DATE)) ;\n\n    if (!Info)\n    {\n        return ;\n    }\n\n    n = Info [AMD_N] ;\n    ndiv = Info [AMD_NDIV] ;\n    nmultsubs_ldl = Info [AMD_NMULTSUBS_LDL] ;\n    nmultsubs_lu = Info [AMD_NMULTSUBS_LU] ;\n    lnz = Info [AMD_LNZ] ;\n    lnzd = (n >= 0 && lnz >= 0) ? (n + lnz) : (-1) ;\n\n    /* AMD return status */\n    PRINTF ((\"    status: \")) ;\n    if (Info [AMD_STATUS] == AMD_OK)\n    {\n        PRINTF ((\"OK\\n\")) ;\n    }\n    else if (Info [AMD_STATUS] == AMD_OUT_OF_MEMORY)\n    {\n        PRINTF ((\"out of memory\\n\")) ;\n    }\n    else if (Info [AMD_STATUS] == AMD_INVALID)\n    {\n        PRINTF ((\"invalid matrix\\n\")) ;\n    }\n    else if (Info [AMD_STATUS] == AMD_OK_BUT_JUMBLED)\n    {\n        PRINTF ((\"OK, but jumbled\\n\")) ;\n    }\n    else\n    {\n        PRINTF ((\"unknown\\n\")) ;\n    }\n\n    /* statistics about the input matrix */\n    PRI (\"    n, dimension of A:                                  %.20g\\n\", n);\n    PRI (\"    nz, number of nonzeros in A:                        %.20g\\n\",\n        Info [AMD_NZ]) ;\n    PRI (\"    symmetry of A:                                      %.4f\\n\",\n        Info [AMD_SYMMETRY]) ;\n    PRI (\"    number of nonzeros on diagonal:                     %.20g\\n\",\n        Info [AMD_NZDIAG]) ;\n    PRI (\"    nonzeros in pattern of A+A' (excl. diagonal):       %.20g\\n\",\n        Info [AMD_NZ_A_PLUS_AT]) ;\n    PRI (\"    # dense rows/columns of A+A':                       %.20g\\n\",\n        Info [AMD_NDENSE]) ;\n\n    /* statistics about AMD's behavior  */\n    PRI (\"    memory used, in bytes:                              %.20g\\n\",\n        Info [AMD_MEMORY]) ;\n    PRI (\"    # of memory compactions:                            %.20g\\n\",\n        Info [AMD_NCMPA]) ;\n\n    /* statistics about the ordering quality */\n    PRINTF ((\"\\n\"\n        \"    The following approximate statistics are for a subsequent\\n\"\n        \"    factorization of A(P,P) + A(P,P)'.  They are slight upper\\n\"\n        \"    bounds if there are no dense rows/columns in A+A', and become\\n\"\n        \"    looser if dense rows/columns exist.\\n\\n\")) ;\n\n    PRI (\"    nonzeros in L (excluding diagonal):                 %.20g\\n\",\n        lnz) ;\n    PRI (\"    nonzeros in L (including diagonal):                 %.20g\\n\",\n        lnzd) ;\n    PRI (\"    # divide operations for LDL' or LU:                 %.20g\\n\",\n        ndiv) ;\n    PRI (\"    # multiply-subtract operations for LDL':            %.20g\\n\",\n        nmultsubs_ldl) ;\n    PRI (\"    # multiply-subtract operations for LU:              %.20g\\n\",\n        nmultsubs_lu) ;\n    PRI (\"    max nz. in any column of L (incl. diagonal):        %.20g\\n\",\n        Info [AMD_DMAX]) ;\n\n    /* total flop counts for various factorizations */\n\n    if (n >= 0 && ndiv >= 0 && nmultsubs_ldl >= 0 && nmultsubs_lu >= 0)\n    {\n        PRINTF ((\"\\n\"\n        \"    chol flop count for real A, sqrt counted as 1 flop: %.20g\\n\"\n        \"    LDL' flop count for real A:                         %.20g\\n\"\n        \"    LDL' flop count for complex A:                      %.20g\\n\"\n        \"    LU flop count for real A (with no pivoting):        %.20g\\n\"\n        \"    LU flop count for complex A (with no pivoting):     %.20g\\n\\n\",\n        n + ndiv + 2*nmultsubs_ldl,\n            ndiv + 2*nmultsubs_ldl,\n          9*ndiv + 8*nmultsubs_ldl,\n            ndiv + 2*nmultsubs_lu,\n          9*ndiv + 8*nmultsubs_lu)) ;\n    }\n}",
      "lines": 101,
      "depth": 16,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_internal.h": {},
  "glpk/glpk-4.65/src/amd/amd_order.c": {
    "AMD_order": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "GLOBAL Int AMD_order\n(\n    Int n,\n    const Int Ap [ ],\n    const Int Ai [ ],\n    Int P [ ],\n    double Control [ ],\n    double Info [ ]\n)\n{\n    Int *Len, *S, nz, i, *Pinv, info, status, *Rp, *Ri, *Cp, *Ci, ok ;\n    size_t nzaat, slen ;\n    double mem = 0 ;\n\n#ifndef NDEBUG\n    AMD_debug_init (\"amd\") ;\n#endif\n\n    /* clear the Info array, if it exists */\n    info = Info != (double *) NULL ;\n    if (info)\n    {\n        for (i = 0 ; i < AMD_INFO ; i++)\n        {\n            Info [i] = EMPTY ;\n        }\n        Info [AMD_N] = n ;\n        Info [AMD_STATUS] = AMD_OK ;\n    }\n\n    /* make sure inputs exist and n is >= 0 */\n    if (Ai == (Int *) NULL || Ap == (Int *) NULL || P == (Int *) NULL || n < 0)\n    {\n        if (info) Info [AMD_STATUS] = AMD_INVALID ;\n        return (AMD_INVALID) ;      /* arguments are invalid */\n    }\n\n    if (n == 0)\n    {\n        return (AMD_OK) ;           /* n is 0 so there's nothing to do */\n    }\n\n    nz = Ap [n] ;\n    if (info)\n    {\n        Info [AMD_NZ] = nz ;\n    }\n    if (nz < 0)\n    {\n        if (info) Info [AMD_STATUS] = AMD_INVALID ;\n        return (AMD_INVALID) ;\n    }\n\n    /* check if n or nz will cause size_t overflow */\n    if (((size_t) n) >= SIZE_T_MAX / sizeof (Int)\n     || ((size_t) nz) >= SIZE_T_MAX / sizeof (Int))\n    {\n        if (info) Info [AMD_STATUS] = AMD_OUT_OF_MEMORY ;\n        return (AMD_OUT_OF_MEMORY) ;        /* problem too large */\n    }\n\n    /* check the input matrix:  AMD_OK, AMD_INVALID, or AMD_OK_BUT_JUMBLED */\n    status = AMD_valid (n, n, Ap, Ai) ;\n\n    if (status == AMD_INVALID)\n    {\n        if (info) Info [AMD_STATUS] = AMD_INVALID ;\n        return (AMD_INVALID) ;      /* matrix is invalid */\n    }\n\n    /* allocate two size-n integer workspaces */\n    Len = amd_malloc (n * sizeof (Int)) ;\n    Pinv = amd_malloc (n * sizeof (Int)) ;\n    mem += n ;\n    mem += n ;\n    if (!Len || !Pinv)\n    {\n        /* :: out of memory :: */\n        amd_free (Len) ;\n        amd_free (Pinv) ;\n        if (info) Info [AMD_STATUS] = AMD_OUT_OF_MEMORY ;\n        return (AMD_OUT_OF_MEMORY) ;\n    }\n\n    if (status == AMD_OK_BUT_JUMBLED)\n    {\n        /* sort the input matrix and remove duplicate entries */\n        AMD_DEBUG1 ((\"Matrix is jumbled\\n\")) ;\n        Rp = amd_malloc ((n+1) * sizeof (Int)) ;\n        Ri = amd_malloc (MAX (nz,1) * sizeof (Int)) ;\n        mem += (n+1) ;\n        mem += MAX (nz,1) ;\n        if (!Rp || !Ri)\n        {\n            /* :: out of memory :: */\n            amd_free (Rp) ;\n            amd_free (Ri) ;\n            amd_free (Len) ;\n            amd_free (Pinv) ;\n            if (info) Info [AMD_STATUS] = AMD_OUT_OF_MEMORY ;\n            return (AMD_OUT_OF_MEMORY) ;\n        }\n        /* use Len and Pinv as workspace to create R = A' */\n        AMD_preprocess (n, Ap, Ai, Rp, Ri, Len, Pinv) ;\n        Cp = Rp ;\n        Ci = Ri ;\n    }\n    else\n    {\n        /* order the input matrix as-is.  No need to compute R = A' first */\n        Rp = NULL ;\n        Ri = NULL ;\n        Cp = (Int *) Ap ;\n        Ci = (Int *) Ai ;\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* determine the symmetry and count off-diagonal nonzeros in A+A' */\n    /* --------------------------------------------------------------------- */\n\n    nzaat = AMD_aat (n, Cp, Ci, Len, P, Info) ;\n    AMD_DEBUG1 ((\"nzaat: %g\\n\", (double) nzaat)) ;\n    ASSERT ((MAX (nz-n, 0) <= nzaat) && (nzaat <= 2 * (size_t) nz)) ;\n\n    /* --------------------------------------------------------------------- */\n    /* allocate workspace for matrix, elbow room, and 6 size-n vectors */\n    /* --------------------------------------------------------------------- */\n\n    S = NULL ;\n    slen = nzaat ;                      /* space for matrix */\n    ok = ((slen + nzaat/5) >= slen) ;   /* check for size_t overflow */\n    slen += nzaat/5 ;                   /* add elbow room */\n    for (i = 0 ; ok && i < 7 ; i++)\n    {\n        ok = ((slen + n) > slen) ;      /* check for size_t overflow */\n        slen += n ;                     /* size-n elbow room, 6 size-n work */\n    }\n    mem += slen ;\n    ok = ok && (slen < SIZE_T_MAX / sizeof (Int)) ; /* check for overflow */\n    ok = ok && (slen < Int_MAX) ;       /* S[i] for Int i must be OK */\n    if (ok)\n    {\n        S = amd_malloc (slen * sizeof (Int)) ;\n    }\n    AMD_DEBUG1 ((\"slen %g\\n\", (double) slen)) ;\n    if (!S)\n    {\n        /* :: out of memory :: (or problem too large) */\n        amd_free (Rp) ;\n        amd_free (Ri) ;\n        amd_free (Len) ;\n        amd_free (Pinv) ;\n        if (info) Info [AMD_STATUS] = AMD_OUT_OF_MEMORY ;\n        return (AMD_OUT_OF_MEMORY) ;\n    }\n    if (info)\n    {\n        /* memory usage, in bytes. */\n        Info [AMD_MEMORY] = mem * sizeof (Int) ;\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* order the matrix */\n    /* --------------------------------------------------------------------- */\n\n    AMD_1 (n, Cp, Ci, P, Pinv, Len, slen, S, Control, Info) ;\n\n    /* --------------------------------------------------------------------- */\n    /* free the workspace */\n    /* --------------------------------------------------------------------- */\n\n    amd_free (Rp) ;\n    amd_free (Ri) ;\n    amd_free (Len) ;\n    amd_free (Pinv) ;\n    amd_free (S) ;\n    if (info) Info [AMD_STATUS] = status ;\n    return (status) ;       /* successful ordering */\n}",
      "lines": 179,
      "depth": 12,
      "decorators": [
        "GLOBAL",
        "Int",
        "Int"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_postorder.c": {
    "AMD_postorder": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "GLOBAL void AMD_postorder\n(\n    /* inputs, not modified on output: */\n    Int nn,             /* nodes are in the range 0..nn-1 */\n    Int Parent [ ],     /* Parent [j] is the parent of j, or EMPTY if root */\n    Int Nv [ ],         /* Nv [j] > 0 number of pivots represented by node j,\n                         * or zero if j is not a node. */\n    Int Fsize [ ],      /* Fsize [j]: size of node j */\n\n    /* output, not defined on input: */\n    Int Order [ ],      /* output post-order */\n\n    /* workspaces of size nn: */\n    Int Child [ ],\n    Int Sibling [ ],\n    Int Stack [ ]\n)\n{\n    Int i, j, k, parent, frsize, f, fprev, maxfrsize, bigfprev, bigf, fnext ;\n\n    for (j = 0 ; j < nn ; j++)\n    {\n        Child [j] = EMPTY ;\n        Sibling [j] = EMPTY ;\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* place the children in link lists - bigger elements tend to be last */\n    /* --------------------------------------------------------------------- */\n\n    for (j = nn-1 ; j >= 0 ; j--)\n    {\n        if (Nv [j] > 0)\n        {\n            /* this is an element */\n            parent = Parent [j] ;\n            if (parent != EMPTY)\n            {\n                /* place the element in link list of the children its parent */\n                /* bigger elements will tend to be at the end of the list */\n                Sibling [j] = Child [parent] ;\n                Child [parent] = j ;\n            }\n        }\n    }\n\n#ifndef NDEBUG\n    {\n        Int nels, ff, nchild ;\n        AMD_DEBUG1 ((\"\\n\\n================================ AMD_postorder:\\n\"));\n        nels = 0 ;\n        for (j = 0 ; j < nn ; j++)\n        {\n            if (Nv [j] > 0)\n            {\n                AMD_DEBUG1 (( \"\"ID\" :  nels \"ID\" npiv \"ID\" size \"ID\n                    \" parent \"ID\" maxfr \"ID\"\\n\", j, nels,\n                    Nv [j], Fsize [j], Parent [j], Fsize [j])) ;\n                /* this is an element */\n                /* dump the link list of children */\n                nchild = 0 ;\n                AMD_DEBUG1 ((\"    Children: \")) ;\n                for (ff = Child [j] ; ff != EMPTY ; ff = Sibling [ff])\n                {\n                    AMD_DEBUG1 ((ID\" \", ff)) ;\n                    ASSERT (Parent [ff] == j) ;\n                    nchild++ ;\n                    ASSERT (nchild < nn) ;\n                }\n                AMD_DEBUG1 ((\"\\n\")) ;\n                parent = Parent [j] ;\n                if (parent != EMPTY)\n                {\n                    ASSERT (Nv [parent] > 0) ;\n                }\n                nels++ ;\n            }\n        }\n    }\n    AMD_DEBUG1 ((\"\\n\\nGo through the children of each node, and put\\n\"\n                 \"the biggest child last in each list:\\n\")) ;\n#endif\n\n    /* --------------------------------------------------------------------- */\n    /* place the largest child last in the list of children for each node */\n    /* --------------------------------------------------------------------- */\n\n    for (i = 0 ; i < nn ; i++)\n    {\n        if (Nv [i] > 0 && Child [i] != EMPTY)\n        {\n\n#ifndef NDEBUG\n            Int nchild ;\n            AMD_DEBUG1 ((\"Before partial sort, element \"ID\"\\n\", i)) ;\n            nchild = 0 ;\n            for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n            {\n                ASSERT (f >= 0 && f < nn) ;\n                AMD_DEBUG1 ((\"      f: \"ID\"  size: \"ID\"\\n\", f, Fsize [f])) ;\n                nchild++ ;\n                ASSERT (nchild <= nn) ;\n            }\n#endif\n\n            /* find the biggest element in the child list */\n            fprev = EMPTY ;\n            maxfrsize = EMPTY ;\n            bigfprev = EMPTY ;\n            bigf = EMPTY ;\n            for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n            {\n                ASSERT (f >= 0 && f < nn) ;\n                frsize = Fsize [f] ;\n                if (frsize >= maxfrsize)\n                {\n                    /* this is the biggest seen so far */\n                    maxfrsize = frsize ;\n                    bigfprev = fprev ;\n                    bigf = f ;\n                }\n                fprev = f ;\n            }\n            ASSERT (bigf != EMPTY) ;\n\n            fnext = Sibling [bigf] ;\n\n            AMD_DEBUG1 ((\"bigf \"ID\" maxfrsize \"ID\" bigfprev \"ID\" fnext \"ID\n                \" fprev \" ID\"\\n\", bigf, maxfrsize, bigfprev, fnext, fprev)) ;\n\n            if (fnext != EMPTY)\n            {\n                /* if fnext is EMPTY then bigf is already at the end of list */\n\n                if (bigfprev == EMPTY)\n                {\n                    /* delete bigf from the element of the list */\n                    Child [i] = fnext ;\n                }\n                else\n                {\n                    /* delete bigf from the middle of the list */\n                    Sibling [bigfprev] = fnext ;\n                }\n\n                /* put bigf at the end of the list */\n                Sibling [bigf] = EMPTY ;\n                ASSERT (Child [i] != EMPTY) ;\n                ASSERT (fprev != bigf) ;\n                ASSERT (fprev != EMPTY) ;\n                Sibling [fprev] = bigf ;\n            }\n\n#ifndef NDEBUG\n            AMD_DEBUG1 ((\"After partial sort, element \"ID\"\\n\", i)) ;\n            for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n            {\n                ASSERT (f >= 0 && f < nn) ;\n                AMD_DEBUG1 ((\"        \"ID\"  \"ID\"\\n\", f, Fsize [f])) ;\n                ASSERT (Nv [f] > 0) ;\n                nchild-- ;\n            }\n            ASSERT (nchild == 0) ;\n#endif\n\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* postorder the assembly tree */\n    /* --------------------------------------------------------------------- */\n\n    for (i = 0 ; i < nn ; i++)\n    {\n        Order [i] = EMPTY ;\n    }\n\n    k = 0 ;\n\n    for (i = 0 ; i < nn ; i++)\n    {\n        if (Parent [i] == EMPTY && Nv [i] > 0)\n        {\n            AMD_DEBUG1 ((\"Root of assembly tree \"ID\"\\n\", i)) ;\n            k = AMD_post_tree (i, k, Child, Sibling, Order, Stack\n#ifndef NDEBUG\n                , nn\n#endif\n                ) ;\n        }\n    }\n}",
      "lines": 192,
      "depth": 20,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_post_tree.c": {
    "AMD_post_tree": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "GLOBAL Int AMD_post_tree\n(\n    Int root,                   /* root of the tree */\n    Int k,                      /* start numbering at k */\n    Int Child [ ],              /* input argument of size nn, undefined on\n                                 * output.  Child [i] is the head of a link\n                                 * list of all nodes that are children of node\n                                 * i in the tree. */\n    const Int Sibling [ ],      /* input argument of size nn, not modified.\n                                 * If f is a node in the link list of the\n                                 * children of node i, then Sibling [f] is the\n                                 * next child of node i.\n                                 */\n    Int Order [ ],              /* output order, of size nn.  Order [i] = k\n                                 * if node i is the kth node of the reordered\n                                 * tree. */\n    Int Stack [ ]               /* workspace of size nn */\n#ifndef NDEBUG\n    , Int nn                    /* nodes are in the range 0..nn-1. */\n#endif\n)\n{\n    Int f, head, h, i ;\n\n#if 0\n    /* --------------------------------------------------------------------- */\n    /* recursive version (Stack [ ] is not used): */\n    /* --------------------------------------------------------------------- */\n\n    /* this is simple, but can caouse stack overflow if nn is large */\n    i = root ;\n    for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n    {\n        k = AMD_post_tree (f, k, Child, Sibling, Order, Stack, nn) ;\n    }\n    Order [i] = k++ ;\n    return (k) ;\n#endif\n\n    /* --------------------------------------------------------------------- */\n    /* non-recursive version, using an explicit stack */\n    /* --------------------------------------------------------------------- */\n\n    /* push root on the stack */\n    head = 0 ;\n    Stack [0] = root ;\n\n    while (head >= 0)\n    {\n        /* get head of stack */\n        ASSERT (head < nn) ;\n        i = Stack [head] ;\n        AMD_DEBUG1 ((\"head of stack \"ID\" \\n\", i)) ;\n        ASSERT (i >= 0 && i < nn) ;\n\n        if (Child [i] != EMPTY)\n        {\n            /* the children of i are not yet ordered */\n            /* push each child onto the stack in reverse order */\n            /* so that small ones at the head of the list get popped first */\n            /* and the biggest one at the end of the list gets popped last */\n            for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n            {\n                head++ ;\n                ASSERT (head < nn) ;\n                ASSERT (f >= 0 && f < nn) ;\n            }\n            h = head ;\n            ASSERT (head < nn) ;\n            for (f = Child [i] ; f != EMPTY ; f = Sibling [f])\n            {\n                ASSERT (h > 0) ;\n                Stack [h--] = f ;\n                AMD_DEBUG1 ((\"push \"ID\" on stack\\n\", f)) ;\n                ASSERT (f >= 0 && f < nn) ;\n            }\n            ASSERT (Stack [h] == i) ;\n\n            /* delete child list so that i gets ordered next time we see it */\n            Child [i] = EMPTY ;\n        }\n        else\n        {\n            /* the children of i (if there were any) are already ordered */\n            /* remove i from the stack and order it.  Front i is kth front */\n            head-- ;\n            AMD_DEBUG1 ((\"pop \"ID\" order \"ID\"\\n\", i, k)) ;\n            Order [i] = k++ ;\n            ASSERT (k <= nn) ;\n        }\n\n#ifndef NDEBUG\n        AMD_DEBUG1 ((\"\\nStack:\")) ;\n        for (h = head ; h >= 0 ; h--)\n        {\n            Int j = Stack [h] ;\n            AMD_DEBUG1 ((\" \"ID, j)) ;\n            ASSERT (j >= 0 && j < nn) ;\n        }\n        AMD_DEBUG1 ((\"\\n\\n\")) ;\n        ASSERT (head < nn) ;\n#endif\n\n    }\n    return (k) ;\n}",
      "lines": 106,
      "depth": 16,
      "decorators": [
        "GLOBAL",
        "Int",
        "Int"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_preprocess.c": {
    "AMD_preprocess": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "GLOBAL void AMD_preprocess\n(\n    Int n,              /* input matrix: A is n-by-n */\n    const Int Ap [ ],   /* size n+1 */\n    const Int Ai [ ],   /* size nz = Ap [n] */\n\n    /* output matrix R: */\n    Int Rp [ ],         /* size n+1 */\n    Int Ri [ ],         /* size nz (or less, if duplicates present) */\n\n    Int W [ ],          /* workspace of size n */\n    Int Flag [ ]        /* workspace of size n */\n)\n{\n\n    /* --------------------------------------------------------------------- */\n    /* local variables */\n    /* --------------------------------------------------------------------- */\n\n    Int i, j, p, p2 ;\n\n    ASSERT (AMD_valid (n, n, Ap, Ai) != AMD_INVALID) ;\n\n    /* --------------------------------------------------------------------- */\n    /* count the entries in each row of A (excluding duplicates) */\n    /* --------------------------------------------------------------------- */\n\n    for (i = 0 ; i < n ; i++)\n    {\n        W [i] = 0 ;             /* # of nonzeros in row i (excl duplicates) */\n        Flag [i] = EMPTY ;      /* Flag [i] = j if i appears in column j */\n    }\n    for (j = 0 ; j < n ; j++)\n    {\n        p2 = Ap [j+1] ;\n        for (p = Ap [j] ; p < p2 ; p++)\n        {\n            i = Ai [p] ;\n            if (Flag [i] != j)\n            {\n                /* row index i has not yet appeared in column j */\n                W [i]++ ;           /* one more entry in row i */\n                Flag [i] = j ;      /* flag row index i as appearing in col j*/\n            }\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* compute the row pointers for R */\n    /* --------------------------------------------------------------------- */\n\n    Rp [0] = 0 ;\n    for (i = 0 ; i < n ; i++)\n    {\n        Rp [i+1] = Rp [i] + W [i] ;\n    }\n    for (i = 0 ; i < n ; i++)\n    {\n        W [i] = Rp [i] ;\n        Flag [i] = EMPTY ;\n    }\n\n    /* --------------------------------------------------------------------- */\n    /* construct the row form matrix R */\n    /* --------------------------------------------------------------------- */\n\n    /* R = row form of pattern of A */\n    for (j = 0 ; j < n ; j++)\n    {\n        p2 = Ap [j+1] ;\n        for (p = Ap [j] ; p < p2 ; p++)\n        {\n            i = Ai [p] ;\n            if (Flag [i] != j)\n            {\n                /* row index i has not yet appeared in column j */\n                Ri [W [i]++] = j ;  /* put col j in row i */\n                Flag [i] = j ;      /* flag row index i as appearing in col j*/\n            }\n        }\n    }\n\n#ifndef NDEBUG\n    ASSERT (AMD_valid (n, n, Rp, Ri) == AMD_OK) ;\n    for (j = 0 ; j < n ; j++)\n    {\n        ASSERT (W [j] == Rp [j+1]) ;\n    }\n#endif\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "GLOBAL",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/amd/amd_valid.c": {
    "AMD_valid": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "GLOBAL Int AMD_valid\n(\n    /* inputs, not modified on output: */\n    Int n_row,          /* A is n_row-by-n_col */\n    Int n_col,\n    const Int Ap [ ],   /* column pointers of A, of size n_col+1 */\n    const Int Ai [ ]    /* row indices of A, of size nz = Ap [n_col] */\n)\n{\n    Int nz, j, p1, p2, ilast, i, p, result = AMD_OK ;\n\n    if (n_row < 0 || n_col < 0 || Ap == NULL || Ai == NULL)\n    {\n        return (AMD_INVALID) ;\n    }\n    nz = Ap [n_col] ;\n    if (Ap [0] != 0 || nz < 0)\n    {\n        /* column pointers must start at Ap [0] = 0, and Ap [n] must be >= 0 */\n        AMD_DEBUG0 ((\"column 0 pointer bad or nz < 0\\n\")) ;\n        return (AMD_INVALID) ;\n    }\n    for (j = 0 ; j < n_col ; j++)\n    {\n        p1 = Ap [j] ;\n        p2 = Ap [j+1] ;\n        AMD_DEBUG2 ((\"\\nColumn: \"ID\" p1: \"ID\" p2: \"ID\"\\n\", j, p1, p2)) ;\n        if (p1 > p2)\n        {\n            /* column pointers must be ascending */\n            AMD_DEBUG0 ((\"column \"ID\" pointer bad\\n\", j)) ;\n            return (AMD_INVALID) ;\n        }\n        ilast = EMPTY ;\n        for (p = p1 ; p < p2 ; p++)\n        {\n            i = Ai [p] ;\n            AMD_DEBUG3 ((\"row: \"ID\"\\n\", i)) ;\n            if (i < 0 || i >= n_row)\n            {\n                /* row index out of range */\n                AMD_DEBUG0 ((\"index out of range, col \"ID\" row \"ID\"\\n\", j, i));\n                return (AMD_INVALID) ;\n            }\n            if (i <= ilast)\n            {\n                /* row index unsorted, or duplicate entry present */\n                AMD_DEBUG1 ((\"index unsorted/dupl col \"ID\" row \"ID\"\\n\", j, i));\n                result = AMD_OK_BUT_JUMBLED ;\n            }\n            ilast = i ;\n        }\n    }\n    return (result) ;\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "GLOBAL",
        "Int",
        "Int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/advbas.c": {
    "mat": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static int mat(void *info, int k, int ind[], double val[])\n{     glp_prob *P = info;\n      int m = P->m;\n      int n = P->n;\n      GLPROW **row = P->row;\n      GLPCOL **col = P->col;\n      GLPAIJ *aij;\n      int i, j, len;\n      if (k > 0)\n      {  /* retrieve scaled row of constraint matrix */\n         i = +k;\n         xassert(1 <= i && i <= m);\n         len = 0;\n         if (row[i]->type == GLP_FX)\n         {  for (aij = row[i]->ptr; aij != NULL; aij = aij->r_next)\n            {  j = aij->col->j;\n               if (col[j]->type != GLP_FX)\n               {  len++;\n                  ind[len] = j;\n                  val[len] = aij->row->rii * aij->val * aij->col->sjj;\n               }\n            }\n         }\n      }\n      else\n      {  /* retrieve scaled column of constraint matrix */\n         j = -k;\n         xassert(1 <= j && j <= n);\n         len = 0;\n         if (col[j]->type != GLP_FX)\n         {  for (aij = col[j]->ptr; aij != NULL; aij = aij->c_next)\n            {  i = aij->row->i;\n               if (row[i]->type == GLP_FX)\n               {  len++;\n                  ind[len] = i;\n                  val[len] = aij->row->rii * aij->val * aij->col->sjj;\n               }\n            }\n         }\n      }\n      return len;\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_adv_basis": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void glp_adv_basis(glp_prob *P, int flags)\n{     int i, j, k, m, n, min_mn, size, *rn, *cn;\n      char *flag;\n      if (flags != 0)\n         xerror(\"glp_adv_basis: flags = %d; invalid flags\\n\", flags);\n      m = P->m; /* number of rows */\n      n = P->n; /* number of columns */\n      if (m == 0 || n == 0)\n      {  /* trivial case */\n         glp_std_basis(P);\n         goto done;\n      }\n      xprintf(\"Constructing initial basis...\\n\");\n      /* allocate working arrays */\n      min_mn = (m < n ? m : n);\n      rn = talloc(1+min_mn, int);\n      cn = talloc(1+min_mn, int);\n      flag = talloc(1+m, char);\n      /* make the basis empty */\n      for (i = 1; i <= m; i++)\n      {  flag[i] = 0;\n         glp_set_row_stat(P, i, GLP_NS);\n      }\n      for (j = 1; j <= n; j++)\n         glp_set_col_stat(P, j, GLP_NS);\n      /* find maximal triangular part of the constraint matrix;\n         to prevent including non-fixed rows and fixed columns in the\n         triangular part, such rows and columns are temporarily made\n         empty by the routine mat */\n#if 1 /* FIXME: tolerance */\n      size = triang(m, n, mat, P, 0.001, rn, cn);\n#endif\n      xassert(0 <= size && size <= min_mn);\n      /* include in the basis non-fixed structural variables, whose\n         columns constitute the triangular part */\n      for (k = 1; k <= size; k++)\n      {  i = rn[k];\n         xassert(1 <= i && i <= m);\n         flag[i] = 1;\n         j = cn[k];\n         xassert(1 <= j && j <= n);\n         glp_set_col_stat(P, j, GLP_BS);\n      }\n      /* include in the basis appropriate auxiliary variables, whose\n         unity columns preserve triangular form of the basis matrix */\n      for (i = 1; i <= m; i++)\n      {  if (flag[i] == 0)\n         {  glp_set_row_stat(P, i, GLP_BS);\n            if (P->row[i]->type != GLP_FX)\n               size++;\n         }\n      }\n      /* size of triangular part = (number of rows) - (number of basic\n         fixed auxiliary variables) */\n      xprintf(\"Size of triangular part is %d\\n\", size);\n      /* deallocate working arrays */\n      tfree(rn);\n      tfree(cn);\n      tfree(flag);\ndone: return;\n}",
      "lines": 61,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/asnhall.c": {
    "glp_asnprob_hall": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int glp_asnprob_hall(glp_graph *G, int v_set, int a_x)\n{     glp_vertex *v;\n      glp_arc *a;\n      int card, i, k, loc, n, n1, n2, xij;\n      int *num, *icn, *ip, *lenr, *iperm, *pr, *arp, *cv, *out;\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_asnprob_hall: v_set = %d; invalid offset\\n\",\n            v_set);\n      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(int))\n         xerror(\"glp_asnprob_hall: a_x = %d; invalid offset\\n\", a_x);\n      if (glp_check_asnprob(G, v_set))\n         return -1;\n      /* determine the number of vertices in sets R and S and renumber\n         vertices in S which correspond to columns of the matrix; skip\n         all isolated vertices */\n      num = xcalloc(1+G->nv, sizeof(int));\n      n1 = n2 = 0;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (v->in == NULL && v->out != NULL)\n            n1++, num[i] = 0; /* vertex in R */\n         else if (v->in != NULL && v->out == NULL)\n            n2++, num[i] = n2; /* vertex in S */\n         else\n         {  xassert(v->in == NULL && v->out == NULL);\n            num[i] = -1; /* isolated vertex */\n         }\n      }\n      /* the matrix must be square, thus, if it has more columns than\n         rows, extra rows will be just empty, and vice versa */\n      n = (n1 >= n2 ? n1 : n2);\n      /* allocate working arrays */\n      icn = xcalloc(1+G->na, sizeof(int));\n      ip = xcalloc(1+n, sizeof(int));\n      lenr = xcalloc(1+n, sizeof(int));\n      iperm = xcalloc(1+n, sizeof(int));\n      pr = xcalloc(1+n, sizeof(int));\n      arp = xcalloc(1+n, sizeof(int));\n      cv = xcalloc(1+n, sizeof(int));\n      out = xcalloc(1+n, sizeof(int));\n      /* build the adjacency matrix of the bipartite graph in row-wise\n         format (rows are vertices in R, columns are vertices in S) */\n      k = 0, loc = 1;\n      for (i = 1; i <= G->nv; i++)\n      {  if (num[i] != 0) continue;\n         /* vertex i in R */\n         ip[++k] = loc;\n         v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  xassert(num[a->head->i] != 0);\n            icn[loc++] = num[a->head->i];\n         }\n         lenr[k] = loc - ip[k];\n      }\n      xassert(loc-1 == G->na);\n      /* make all extra rows empty (all extra columns are empty due to\n         the row-wise format used) */\n      for (k++; k <= n; k++)\n         ip[k] = loc, lenr[k] = 0;\n      /* find a row permutation that maximizes the number of non-zeros\n         on the main diagonal */\n      card = mc21a(n, icn, ip, lenr, iperm, pr, arp, cv, out);\n#if 1 /* 18/II-2010 */\n      /* FIXED: if card = n, arp remains clobbered on exit */\n      for (i = 1; i <= n; i++)\n         arp[i] = 0;\n      for (i = 1; i <= card; i++)\n      {  k = iperm[i];\n         xassert(1 <= k && k <= n);\n         xassert(arp[k] == 0);\n         arp[k] = i;\n      }\n#endif\n      /* store solution, if necessary */\n      if (a_x < 0) goto skip;\n      k = 0;\n      for (i = 1; i <= G->nv; i++)\n      {  if (num[i] != 0) continue;\n         /* vertex i in R */\n         k++;\n         v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  /* arp[k] is the number of matched column or zero */\n            if (arp[k] == num[a->head->i])\n            {  xassert(arp[k] != 0);\n               xij = 1;\n            }\n            else\n               xij = 0;\n            memcpy((char *)a->data + a_x, &xij, sizeof(int));\n         }\n      }\nskip: /* free working arrays */\n      xfree(num);\n      xfree(icn);\n      xfree(ip);\n      xfree(lenr);\n      xfree(iperm);\n      xfree(pr);\n      xfree(arp);\n      xfree(cv);\n      xfree(out);\n      return card;\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/asnlp.c": {
    "glp_asnprob_lp": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int glp_asnprob_lp(glp_prob *P, int form, glp_graph *G, int names,\n      int v_set, int a_cost)\n{     glp_vertex *v;\n      glp_arc *a;\n      int i, j, ret, ind[1+2];\n      double cost, val[1+2];\n      if (!(form == GLP_ASN_MIN || form == GLP_ASN_MAX ||\n            form == GLP_ASN_MMP))\n         xerror(\"glp_asnprob_lp: form = %d; invalid parameter\\n\",\n            form);\n      if (!(names == GLP_ON || names == GLP_OFF))\n         xerror(\"glp_asnprob_lp: names = %d; invalid parameter\\n\",\n            names);\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_asnprob_lp: v_set = %d; invalid offset\\n\",\n            v_set);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_asnprob_lp: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      ret = glp_check_asnprob(G, v_set);\n      if (ret != 0) goto done;\n      glp_erase_prob(P);\n      if (names) glp_set_prob_name(P, G->name);\n      glp_set_obj_dir(P, form == GLP_ASN_MIN ? GLP_MIN : GLP_MAX);\n      if (G->nv > 0) glp_add_rows(P, G->nv);\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (names) glp_set_row_name(P, i, v->name);\n         glp_set_row_bnds(P, i, form == GLP_ASN_MMP ? GLP_UP : GLP_FX,\n            1.0, 1.0);\n      }\n      if (G->na > 0) glp_add_cols(P, G->na);\n      for (i = 1, j = 0; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  j++;\n            if (names)\n            {  char name[50+1];\n               sprintf(name, \"x[%d,%d]\", a->tail->i, a->head->i);\n               xassert(strlen(name) < sizeof(name));\n               glp_set_col_name(P, j, name);\n            }\n            ind[1] = a->tail->i, val[1] = +1.0;\n            ind[2] = a->head->i, val[2] = +1.0;\n            glp_set_mat_col(P, j, 2, ind, val);\n            glp_set_col_bnds(P, j, GLP_DB, 0.0, 1.0);\n            if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 1.0;\n            glp_set_obj_coef(P, j, cost);\n         }\n      }\n      xassert(j == G->na);\ndone: return ret;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/asnokalg.c": {
    "glp_asnprob_okalg": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int glp_asnprob_okalg(int form, glp_graph *G, int v_set, int a_cost,\n      double *sol, int a_x)\n{     /* solve assignment problem with out-of-kilter algorithm */\n      glp_vertex *v;\n      glp_arc *a;\n      int nv, na, i, k, *tail, *head, *low, *cap, *cost, *x, *pi, ret;\n      double temp;\n      if (!(form == GLP_ASN_MIN || form == GLP_ASN_MAX ||\n            form == GLP_ASN_MMP))\n         xerror(\"glp_asnprob_okalg: form = %d; invalid parameter\\n\",\n            form);\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_asnprob_okalg: v_set = %d; invalid offset\\n\",\n            v_set);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_asnprob_okalg: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(int))\n         xerror(\"glp_asnprob_okalg: a_x = %d; invalid offset\\n\", a_x);\n      if (glp_check_asnprob(G, v_set))\n         return GLP_EDATA;\n      /* nv is the total number of nodes in the resulting network */\n      nv = G->nv + 1;\n      /* na is the total number of arcs in the resulting network */\n      na = G->na + G->nv;\n      /* allocate working arrays */\n      tail = xcalloc(1+na, sizeof(int));\n      head = xcalloc(1+na, sizeof(int));\n      low = xcalloc(1+na, sizeof(int));\n      cap = xcalloc(1+na, sizeof(int));\n      cost = xcalloc(1+na, sizeof(int));\n      x = xcalloc(1+na, sizeof(int));\n      pi = xcalloc(1+nv, sizeof(int));\n      /* construct the resulting network */\n      k = 0;\n      /* (original arcs) */\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  k++;\n            tail[k] = a->tail->i;\n            head[k] = a->head->i;\n            low[k] = 0;\n            cap[k] = 1;\n            if (a_cost >= 0)\n               memcpy(&temp, (char *)a->data + a_cost, sizeof(double));\n            else\n               temp = 1.0;\n            if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            cost[k] = (int)temp;\n            if (form != GLP_ASN_MIN) cost[k] = - cost[k];\n         }\n      }\n      /* (artificial arcs) */\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         k++;\n         if (v->out == NULL)\n            tail[k] = i, head[k] = nv;\n         else if (v->in == NULL)\n            tail[k] = nv, head[k] = i;\n         else\n            xassert(v != v);\n         low[k] = (form == GLP_ASN_MMP ? 0 : 1);\n         cap[k] = 1;\n         cost[k] = 0;\n      }\n      xassert(k == na);\n      /* find minimal-cost circulation in the resulting network */\n      ret = okalg(nv, na, tail, head, low, cap, cost, x, pi);\n      switch (ret)\n      {  case 0:\n            /* optimal circulation found */\n            ret = 0;\n            break;\n         case 1:\n            /* no feasible circulation exists */\n            ret = GLP_ENOPFS;\n            break;\n         case 2:\n            /* integer overflow occured */\n            ret = GLP_ERANGE;\n            goto done;\n         case 3:\n            /* optimality test failed (logic error) */\n            ret = GLP_EFAIL;\n            goto done;\n         default:\n            xassert(ret != ret);\n      }\n      /* store solution components */\n      /* (objective function = the total cost) */\n      if (sol != NULL)\n      {  temp = 0.0;\n         for (k = 1; k <= na; k++)\n            temp += (double)cost[k] * (double)x[k];\n         if (form != GLP_ASN_MIN) temp = - temp;\n         *sol = temp;\n      }\n      /* (arc flows) */\n      if (a_x >= 0)\n      {  k = 0;\n         for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            for (a = v->out; a != NULL; a = a->t_next)\n            {  k++;\n               if (ret == 0)\n                  xassert(x[k] == 0 || x[k] == 1);\n               memcpy((char *)a->data + a_x, &x[k], sizeof(int));\n            }\n         }\n      }\ndone: /* free working arrays */\n      xfree(tail);\n      xfree(head);\n      xfree(low);\n      xfree(cap);\n      xfree(cost);\n      xfree(x);\n      xfree(pi);\n      return ret;\n}",
      "lines": 125,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/ckasn.c": {
    "glp_check_asnprob": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int glp_check_asnprob(glp_graph *G, int v_set)\n{     glp_vertex *v;\n      int i, k, ret = 0;\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_check_asnprob: v_set = %d; invalid offset\\n\",\n            v_set);\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (v_set >= 0)\n         {  memcpy(&k, (char *)v->data + v_set, sizeof(int));\n            if (k == 0)\n            {  if (v->in != NULL)\n               {  ret = 1;\n                  break;\n               }\n            }\n            else if (k == 1)\n            {  if (v->out != NULL)\n               {  ret = 2;\n                  break;\n               }\n            }\n            else\n            {  ret = 3;\n               break;\n            }\n         }\n         else\n         {  if (v->in != NULL && v->out != NULL)\n            {  ret = 4;\n               break;\n            }\n         }\n      }\n      return ret;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/ckcnf.c": {
    "glp_check_cnfsat": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int glp_check_cnfsat(glp_prob *P)\n{     /* check for CNF-SAT problem instance */\n      int m = P->m;\n      int n = P->n;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int i, j, neg;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_check_cnfsat: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      /* check columns */\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         /* the variable should be binary */\n         if (!(col->kind == GLP_IV && col->type == GLP_DB &&\n               col->lb == 0.0 && col->ub == 1.0))\n            return 1;\n      }\n      /* objective function should be zero */\n      if (P->c0 != 0.0)\n         return 2;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         if (col->coef != 0.0)\n            return 3;\n      }\n      /* check rows */\n      for (i = 1; i <= m; i++)\n      {  row = P->row[i];\n         /* the row should be of \">=\" type */\n         if (row->type != GLP_LO)\n            return 4;\n         /* check constraint coefficients */\n         neg = 0;\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  /* the constraint coefficient should be +1 or -1 */\n            if (aij->val == +1.0)\n               ;\n            else if (aij->val == -1.0)\n               neg++;\n            else\n               return 5;\n         }\n         /* the right-hand side should be (1 - neg), where neg is the\n            number of negative constraint coefficients in the row */\n         if (row->lb != (double)(1 - neg))\n            return 6;\n      }\n      /* congratulations; this is CNF-SAT */\n      return 0;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/cplex.c": {
    "glp_init_cpxcp": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void glp_init_cpxcp(glp_cpxcp *parm)\n{     xassert(parm != NULL);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "check_parm": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void check_parm(const char *func, const glp_cpxcp *parm)\n{     /* check control parameters */\n      xassert(func != NULL);\n      xassert(parm != NULL);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void error(struct csa *csa, const char *fmt, ...)\n{     /* print error message and terminate processing */\n      va_list arg;\n      xprintf(\"%s:%d: \", csa->fname, csa->count);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      longjmp(csa->jump, 1);\n      /* no return */\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "warning": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static void warning(struct csa *csa, const char *fmt, ...)\n{     /* print warning message and continue processing */\n      va_list arg;\n      xprintf(\"%s:%d: warning: \", csa->fname, csa->count);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_char": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void read_char(struct csa *csa)\n{     /* read next character from input file */\n      int c;\n      xassert(csa->c != EOF);\n      if (csa->c == '\\n') csa->count++;\n      c = glp_getc(csa->fp);\n      if (c < 0)\n      {  if (glp_ioerr(csa->fp))\n            error(csa, \"read error - %s\\n\", get_err_msg());\n         else if (csa->c == '\\n')\n         {  csa->count--;\n            c = EOF;\n         }\n         else\n         {  warning(csa, \"missing final end of line\\n\");\n            c = '\\n';\n         }\n      }\n      else if (c == '\\n')\n         ;\n      else if (isspace(c))\n         c = ' ';\n      else if (iscntrl(c))\n         error(csa, \"invalid control character 0x%02X\\n\", c);\n      csa->c = c;\n      return;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_char": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void add_char(struct csa *csa)\n{     /* append current character to current token */\n      if (csa->imlen == sizeof(csa->image)-1)\n         error(csa, \"token '%.15s...' too long\\n\", csa->image);\n      csa->image[csa->imlen++] = (char)csa->c;\n      csa->image[csa->imlen] = '\\0';\n      read_char(csa);\n      return;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "the_same": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static int the_same(char *s1, char *s2)\n{     /* compare two character strings ignoring case sensitivity */\n      for (; *s1 != '\\0'; s1++, s2++)\n      {  if (tolower((unsigned char)*s1) != tolower((unsigned char)*s2))\n            return 0;\n      }\n      return 1;\n}",
      "lines": 8,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_token": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static void scan_token(struct csa *csa)\n{     /* scan next token */\n      int flag;\n      csa->token = -1;\n      csa->image[0] = '\\0';\n      csa->imlen = 0;\n      csa->value = 0.0;\nloop: flag = 0;\n      /* skip non-significant characters */\n      while (csa->c == ' ') read_char(csa);\n      /* recognize and scan current token */\n      if (csa->c == EOF)\n         csa->token = T_EOF;\n      else if (csa->c == '\\n')\n      {  read_char(csa);\n         /* if the next character is letter, it may begin a keyword */\n         if (isalpha(csa->c))\n         {  flag = 1;\n            goto name;\n         }\n         goto loop;\n      }\n      else if (csa->c == '\\\\')\n      {  /* comment; ignore everything until end-of-line */\n         while (csa->c != '\\n') read_char(csa);\n         goto loop;\n      }\n      else if (isalpha(csa->c) || csa->c != '.' && strchr(CHAR_SET,\n         csa->c) != NULL)\nname: {  /* symbolic name */\n         csa->token = T_NAME;\n         while (isalnum(csa->c) || strchr(CHAR_SET, csa->c) != NULL)\n            add_char(csa);\n         if (flag)\n         {  /* check for keyword */\n            if (the_same(csa->image, \"minimize\"))\n               csa->token = T_MINIMIZE;\n            else if (the_same(csa->image, \"minimum\"))\n               csa->token = T_MINIMIZE;\n            else if (the_same(csa->image, \"min\"))\n               csa->token = T_MINIMIZE;\n            else if (the_same(csa->image, \"maximize\"))\n               csa->token = T_MAXIMIZE;\n            else if (the_same(csa->image, \"maximum\"))\n               csa->token = T_MAXIMIZE;\n            else if (the_same(csa->image, \"max\"))\n               csa->token = T_MAXIMIZE;\n            else if (the_same(csa->image, \"subject\"))\n            {  if (csa->c == ' ')\n               {  read_char(csa);\n                  if (tolower(csa->c) == 't')\n                  {  csa->token = T_SUBJECT_TO;\n                     csa->image[csa->imlen++] = ' ';\n                     csa->image[csa->imlen] = '\\0';\n                     add_char(csa);\n                     if (tolower(csa->c) != 'o')\n                        error(csa, \"keyword 'subject to' incomplete\\n\");\n                     add_char(csa);\n                     if (isalpha(csa->c))\n                        error(csa, \"keyword '%s%c...' not recognized\\n\",\n                           csa->image, csa->c);\n                  }\n               }\n            }\n            else if (the_same(csa->image, \"such\"))\n            {  if (csa->c == ' ')\n               {  read_char(csa);\n                  if (tolower(csa->c) == 't')\n                  {  csa->token = T_SUBJECT_TO;\n                     csa->image[csa->imlen++] = ' ';\n                     csa->image[csa->imlen] = '\\0';\n                     add_char(csa);\n                     if (tolower(csa->c) != 'h')\nerr:                    error(csa, \"keyword 'such that' incomplete\\n\");\n                     add_char(csa);\n                     if (tolower(csa->c) != 'a') goto err;\n                     add_char(csa);\n                     if (tolower(csa->c) != 't') goto err;\n                     add_char(csa);\n                     if (isalpha(csa->c))\n                        error(csa, \"keyword '%s%c...' not recognized\\n\",\n                           csa->image, csa->c);\n                  }\n               }\n            }\n            else if (the_same(csa->image, \"st\"))\n               csa->token = T_SUBJECT_TO;\n            else if (the_same(csa->image, \"s.t.\"))\n               csa->token = T_SUBJECT_TO;\n            else if (the_same(csa->image, \"st.\"))\n               csa->token = T_SUBJECT_TO;\n            else if (the_same(csa->image, \"bounds\"))\n               csa->token = T_BOUNDS;\n            else if (the_same(csa->image, \"bound\"))\n               csa->token = T_BOUNDS;\n            else if (the_same(csa->image, \"general\"))\n               csa->token = T_GENERAL;\n            else if (the_same(csa->image, \"generals\"))\n               csa->token = T_GENERAL;\n            else if (the_same(csa->image, \"gen\"))\n               csa->token = T_GENERAL;\n            else if (the_same(csa->image, \"integer\"))\n               csa->token = T_INTEGER;\n            else if (the_same(csa->image, \"integers\"))\n               csa->token = T_INTEGER;\n            else if (the_same(csa->image, \"int\"))\n              csa->token = T_INTEGER;\n            else if (the_same(csa->image, \"binary\"))\n               csa->token = T_BINARY;\n            else if (the_same(csa->image, \"binaries\"))\n               csa->token = T_BINARY;\n            else if (the_same(csa->image, \"bin\"))\n               csa->token = T_BINARY;\n            else if (the_same(csa->image, \"end\"))\n               csa->token = T_END;\n         }\n      }\n      else if (isdigit(csa->c) || csa->c == '.')\n      {  /* numeric constant */\n         csa->token = T_NUMBER;\n         /* scan integer part */\n         while (isdigit(csa->c)) add_char(csa);\n         /* scan optional fractional part (it is mandatory, if there is\n            no integer part) */\n         if (csa->c == '.')\n         {  add_char(csa);\n            if (csa->imlen == 1 && !isdigit(csa->c))\n               error(csa, \"invalid use of decimal point\\n\");\n            while (isdigit(csa->c)) add_char(csa);\n         }\n         /* scan optional decimal exponent */\n         if (csa->c == 'e' || csa->c == 'E')\n         {  add_char(csa);\n            if (csa->c == '+' || csa->c == '-') add_char(csa);\n            if (!isdigit(csa->c))\n               error(csa, \"numeric constant '%s' incomplete\\n\",\n                  csa->image);\n            while (isdigit(csa->c)) add_char(csa);\n         }\n         /* convert the numeric constant to floating-point */\n         if (str2num(csa->image, &csa->value))\n            error(csa, \"numeric constant '%s' out of range\\n\",\n               csa->image);\n      }\n      else if (csa->c == '+')\n         csa->token = T_PLUS, add_char(csa);\n      else if (csa->c == '-')\n         csa->token = T_MINUS, add_char(csa);\n      else if (csa->c == ':')\n         csa->token = T_COLON, add_char(csa);\n      else if (csa->c == '<')\n      {  csa->token = T_LE, add_char(csa);\n         if (csa->c == '=') add_char(csa);\n      }\n      else if (csa->c == '>')\n      {  csa->token = T_GE, add_char(csa);\n         if (csa->c == '=') add_char(csa);\n      }\n      else if (csa->c == '=')\n      {  csa->token = T_EQ, add_char(csa);\n         if (csa->c == '<')\n            csa->token = T_LE, add_char(csa);\n         else if (csa->c == '>')\n            csa->token = T_GE, add_char(csa);\n      }\n      else\n         error(csa, \"character '%c' not recognized\\n\", csa->c);\n      /* skip non-significant characters */\n      while (csa->c == ' ') read_char(csa);\n      return;\n}",
      "lines": 171,
      "depth": 38,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_col": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "static int find_col(struct csa *csa, char *name)\n{     /* find column by its symbolic name */\n      int j;\n      j = glp_find_col(csa->P, name);\n      if (j == 0)\n      {  /* not found; create new column */\n         j = glp_add_cols(csa->P, 1);\n         glp_set_col_name(csa->P, j, name);\n         /* enlarge working arrays, if necessary */\n         if (csa->n_max < j)\n         {  int n_max = csa->n_max;\n            int *ind = csa->ind;\n            double *val = csa->val;\n            char *flag = csa->flag;\n            double *lb = csa->lb;\n            double *ub = csa->ub;\n            csa->n_max += csa->n_max;\n            csa->ind = xcalloc(1+csa->n_max, sizeof(int));\n            memcpy(&csa->ind[1], &ind[1], n_max * sizeof(int));\n            xfree(ind);\n            csa->val = xcalloc(1+csa->n_max, sizeof(double));\n            memcpy(&csa->val[1], &val[1], n_max * sizeof(double));\n            xfree(val);\n            csa->flag = xcalloc(1+csa->n_max, sizeof(char));\n            memset(&csa->flag[1], 0, csa->n_max * sizeof(char));\n            memcpy(&csa->flag[1], &flag[1], n_max * sizeof(char));\n            xfree(flag);\n            csa->lb = xcalloc(1+csa->n_max, sizeof(double));\n            memcpy(&csa->lb[1], &lb[1], n_max * sizeof(double));\n            xfree(lb);\n            csa->ub = xcalloc(1+csa->n_max, sizeof(double));\n            memcpy(&csa->ub[1], &ub[1], n_max * sizeof(double));\n            xfree(ub);\n         }\n         csa->lb[j] = +DBL_MAX, csa->ub[j] = -DBL_MAX;\n      }\n      return j;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_linear_form": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "static int parse_linear_form(struct csa *csa)\n{     int j, k, len = 0, newlen;\n      double s, coef;\nloop: /* parse an optional sign */\n      if (csa->token == T_PLUS)\n         s = +1.0, scan_token(csa);\n      else if (csa->token == T_MINUS)\n         s = -1.0, scan_token(csa);\n      else\n         s = +1.0;\n      /* parse an optional coefficient */\n      if (csa->token == T_NUMBER)\n         coef = csa->value, scan_token(csa);\n      else\n         coef = 1.0;\n      /* parse a variable name */\n      if (csa->token != T_NAME)\n         error(csa, \"missing variable name\\n\");\n      /* find the corresponding column */\n      j = find_col(csa, csa->image);\n      /* check if the variable is already used in the linear form */\n      if (csa->flag[j])\n         error(csa, \"multiple use of variable '%s' not allowed\\n\",\n            csa->image);\n      /* add new term to the linear form */\n      len++, csa->ind[len] = j, csa->val[len] = s * coef;\n      /* and mark that the variable is used in the linear form */\n      csa->flag[j] = 1;\n      scan_token(csa);\n      /* if the next token is a sign, there is another term */\n      if (csa->token == T_PLUS || csa->token == T_MINUS) goto loop;\n      /* clear marks of the variables used in the linear form */\n      for (k = 1; k <= len; k++) csa->flag[csa->ind[k]] = 0;\n      /* remove zero coefficients */\n      newlen = 0;\n      for (k = 1; k <= len; k++)\n      {  if (csa->val[k] != 0.0)\n         {  newlen++;\n            csa->ind[newlen] = csa->ind[k];\n            csa->val[newlen] = csa->val[k];\n         }\n      }\n      return newlen;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_objective": {
      "start_point": [
        494,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static void parse_objective(struct csa *csa)\n{     /* parse objective sense */\n      int k, len;\n      /* parse the keyword 'minimize' or 'maximize' */\n      if (csa->token == T_MINIMIZE)\n         glp_set_obj_dir(csa->P, GLP_MIN);\n      else if (csa->token == T_MAXIMIZE)\n         glp_set_obj_dir(csa->P, GLP_MAX);\n      else\n         xassert(csa != csa);\n      scan_token(csa);\n      /* parse objective name */\n      if (csa->token == T_NAME && csa->c == ':')\n      {  /* objective name is followed by a colon */\n         glp_set_obj_name(csa->P, csa->image);\n         scan_token(csa);\n         xassert(csa->token == T_COLON);\n         scan_token(csa);\n      }\n      else\n      {  /* objective name is not specified; use default */\n         glp_set_obj_name(csa->P, \"obj\");\n      }\n      /* parse linear form */\n      len = parse_linear_form(csa);\n      for (k = 1; k <= len; k++)\n         glp_set_obj_coef(csa->P, csa->ind[k], csa->val[k]);\n      return;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_constraints": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        596,
        1
      ],
      "content": "static void parse_constraints(struct csa *csa)\n{     int i, len, type;\n      double s;\n      /* parse the keyword 'subject to' */\n      xassert(csa->token == T_SUBJECT_TO);\n      scan_token(csa);\nloop: /* create new row (constraint) */\n      i = glp_add_rows(csa->P, 1);\n      /* parse row name */\n      if (csa->token == T_NAME && csa->c == ':')\n      {  /* row name is followed by a colon */\n         if (glp_find_row(csa->P, csa->image) != 0)\n            error(csa, \"constraint '%s' multiply defined\\n\",\n               csa->image);\n         glp_set_row_name(csa->P, i, csa->image);\n         scan_token(csa);\n         xassert(csa->token == T_COLON);\n         scan_token(csa);\n      }\n      else\n      {  /* row name is not specified; use default */\n         char name[50];\n         sprintf(name, \"r.%d\", csa->count);\n         glp_set_row_name(csa->P, i, name);\n      }\n      /* parse linear form */\n      len = parse_linear_form(csa);\n      glp_set_mat_row(csa->P, i, len, csa->ind, csa->val);\n      /* parse constraint sense */\n      if (csa->token == T_LE)\n         type = GLP_UP, scan_token(csa);\n      else if (csa->token == T_GE)\n         type = GLP_LO, scan_token(csa);\n      else if (csa->token == T_EQ)\n         type = GLP_FX, scan_token(csa);\n      else\n         error(csa, \"missing constraint sense\\n\");\n      /* parse right-hand side */\n      if (csa->token == T_PLUS)\n         s = +1.0, scan_token(csa);\n      else if (csa->token == T_MINUS)\n         s = -1.0, scan_token(csa);\n      else\n         s = +1.0;\n      if (csa->token != T_NUMBER)\n         error(csa, \"missing right-hand side\\n\");\n      glp_set_row_bnds(csa->P, i, type, s * csa->value, s * csa->value);\n      /* the rest of the current line must be empty */\n      if (!(csa->c == '\\n' || csa->c == EOF))\n         error(csa, \"invalid symbol(s) beyond right-hand side\\n\");\n      scan_token(csa);\n      /* if the next token is a sign, numeric constant, or a symbolic\n         name, here is another constraint */\n      if (csa->token == T_PLUS || csa->token == T_MINUS ||\n          csa->token == T_NUMBER || csa->token == T_NAME) goto loop;\n      return;\n}",
      "lines": 57,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_lower_bound": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        607,
        1
      ],
      "content": "static void set_lower_bound(struct csa *csa, int j, double lb)\n{     /* set lower bound of j-th variable */\n      if (csa->lb[j] != +DBL_MAX && !csa->lb_warn)\n      {  warning(csa, \"lower bound of variable '%s' redefined\\n\",\n            glp_get_col_name(csa->P, j));\n         csa->lb_warn = 1;\n      }\n      csa->lb[j] = lb;\n      return;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_upper_bound": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "static void set_upper_bound(struct csa *csa, int j, double ub)\n{     /* set upper bound of j-th variable */\n      if (csa->ub[j] != -DBL_MAX && !csa->ub_warn)\n      {  warning(csa, \"upper bound of variable '%s' redefined\\n\",\n            glp_get_col_name(csa->P, j));\n         csa->ub_warn = 1;\n      }\n      csa->ub[j] = ub;\n      return;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_bounds": {
      "start_point": [
        638,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static void parse_bounds(struct csa *csa)\n{     int j, lb_flag;\n      double lb, s;\n      /* parse the keyword 'bounds' */\n      xassert(csa->token == T_BOUNDS);\n      scan_token(csa);\nloop: /* bound definition can start with a sign, numeric constant, or\n         a symbolic name */\n      if (!(csa->token == T_PLUS || csa->token == T_MINUS ||\n            csa->token == T_NUMBER || csa->token == T_NAME)) goto done;\n      /* parse bound definition */\n      if (csa->token == T_PLUS || csa->token == T_MINUS)\n      {  /* parse signed lower bound */\n         lb_flag = 1;\n         s = (csa->token == T_PLUS ? +1.0 : -1.0);\n         scan_token(csa);\n         if (csa->token == T_NUMBER)\n            lb = s * csa->value, scan_token(csa);\n         else if (the_same(csa->image, \"infinity\") ||\n                  the_same(csa->image, \"inf\"))\n         {  if (s > 0.0)\n               error(csa, \"invalid use of '+inf' as lower bound\\n\");\n            lb = -DBL_MAX, scan_token(csa);\n         }\n         else\n            error(csa, \"missing lower bound\\n\");\n      }\n      else if (csa->token == T_NUMBER)\n      {  /* parse unsigned lower bound */\n         lb_flag = 1;\n         lb = csa->value, scan_token(csa);\n      }\n      else\n      {  /* lower bound is not specified */\n         lb_flag = 0;\n      }\n      /* parse the token that should follow the lower bound */\n      if (lb_flag)\n      {  if (csa->token != T_LE)\n            error(csa, \"missing '<', '<=', or '=<' after lower bound\\n\")\n               ;\n         scan_token(csa);\n      }\n      /* parse variable name */\n      if (csa->token != T_NAME)\n         error(csa, \"missing variable name\\n\");\n      j = find_col(csa, csa->image);\n      /* set lower bound */\n      if (lb_flag) set_lower_bound(csa, j, lb);\n      scan_token(csa);\n      /* parse the context that follows the variable name */\n      if (csa->token == T_LE)\n      {  /* parse upper bound */\n         scan_token(csa);\n         if (csa->token == T_PLUS || csa->token == T_MINUS)\n         {  /* parse signed upper bound */\n            s = (csa->token == T_PLUS ? +1.0 : -1.0);\n            scan_token(csa);\n            if (csa->token == T_NUMBER)\n            {  set_upper_bound(csa, j, s * csa->value);\n               scan_token(csa);\n            }\n            else if (the_same(csa->image, \"infinity\") ||\n                     the_same(csa->image, \"inf\"))\n            {  if (s < 0.0)\n                  error(csa, \"invalid use of '-inf' as upper bound\\n\");\n               set_upper_bound(csa, j, +DBL_MAX);\n               scan_token(csa);\n            }\n            else\n               error(csa, \"missing upper bound\\n\");\n         }\n         else if (csa->token == T_NUMBER)\n         {  /* parse unsigned upper bound */\n            set_upper_bound(csa, j, csa->value);\n            scan_token(csa);\n         }\n         else\n            error(csa, \"missing upper bound\\n\");\n      }\n      else if (csa->token == T_GE)\n      {  /* parse lower bound */\n         if (lb_flag)\n         {  /* the context '... <= x >= ...' is invalid */\n            error(csa, \"invalid bound definition\\n\");\n         }\n         scan_token(csa);\n         if (csa->token == T_PLUS || csa->token == T_MINUS)\n         {  /* parse signed lower bound */\n            s = (csa->token == T_PLUS ? +1.0 : -1.0);\n            scan_token(csa);\n            if (csa->token == T_NUMBER)\n            {  set_lower_bound(csa, j, s * csa->value);\n               scan_token(csa);\n            }\n            else if (the_same(csa->image, \"infinity\") ||\n                     the_same(csa->image, \"inf\") == 0)\n            {  if (s > 0.0)\n                  error(csa, \"invalid use of '+inf' as lower bound\\n\");\n               set_lower_bound(csa, j, -DBL_MAX);\n               scan_token(csa);\n            }\n            else\n               error(csa, \"missing lower bound\\n\");\n         }\n         else if (csa->token == T_NUMBER)\n         {  /* parse unsigned lower bound */\n            set_lower_bound(csa, j, csa->value);\n            scan_token(csa);\n         }\n         else\n            error(csa, \"missing lower bound\\n\");\n      }\n      else if (csa->token == T_EQ)\n      {  /* parse fixed value */\n         if (lb_flag)\n         {  /* the context '... <= x = ...' is invalid */\n            error(csa, \"invalid bound definition\\n\");\n         }\n         scan_token(csa);\n         if (csa->token == T_PLUS || csa->token == T_MINUS)\n         {  /* parse signed fixed value */\n            s = (csa->token == T_PLUS ? +1.0 : -1.0);\n            scan_token(csa);\n            if (csa->token == T_NUMBER)\n            {  set_lower_bound(csa, j, s * csa->value);\n               set_upper_bound(csa, j, s * csa->value);\n               scan_token(csa);\n            }\n            else\n               error(csa, \"missing fixed value\\n\");\n         }\n         else if (csa->token == T_NUMBER)\n         {  /* parse unsigned fixed value */\n            set_lower_bound(csa, j, csa->value);\n            set_upper_bound(csa, j, csa->value);\n            scan_token(csa);\n         }\n         else\n            error(csa, \"missing fixed value\\n\");\n      }\n      else if (the_same(csa->image, \"free\"))\n      {  /* parse the keyword 'free' */\n         if (lb_flag)\n         {  /* the context '... <= x free ...' is invalid */\n            error(csa, \"invalid bound definition\\n\");\n         }\n         set_lower_bound(csa, j, -DBL_MAX);\n         set_upper_bound(csa, j, +DBL_MAX);\n         scan_token(csa);\n      }\n      else if (!lb_flag)\n      {  /* neither lower nor upper bounds are specified */\n         error(csa, \"invalid bound definition\\n\");\n      }\n      goto loop;\ndone: return;\n}",
      "lines": 158,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_integer": {
      "start_point": [
        808,
        0
      ],
      "end_point": [
        841,
        1
      ],
      "content": "static void parse_integer(struct csa *csa)\n{     int j, binary;\n      /* parse the keyword 'general', 'integer', or 'binary' */\n      if (csa->token == T_GENERAL)\n         binary = 0, scan_token(csa);\n      else if (csa->token == T_INTEGER)\n         binary = 0, scan_token(csa);\n      else if (csa->token == T_BINARY)\n         binary = 1, scan_token(csa);\n      else\n         xassert(csa != csa);\n      /* parse list of variables (may be empty) */\n      while (csa->token == T_NAME)\n      {  /* find the corresponding column */\n         j = find_col(csa, csa->image);\n         /* change kind of the variable */\n         glp_set_col_kind(csa->P, j, GLP_IV);\n         /* set bounds for the binary variable */\n         if (binary)\n#if 0 /* 07/VIII-2013 */\n         {  set_lower_bound(csa, j, 0.0);\n            set_upper_bound(csa, j, 1.0);\n         }\n#else\n         {  set_lower_bound(csa, j,\n               csa->lb[j] == +DBL_MAX ? 0.0 : csa->lb[j]);\n            set_upper_bound(csa, j,\n               csa->ub[j] == -DBL_MAX ? 1.0 : csa->ub[j]);\n         }\n#endif\n         scan_token(csa);\n      }\n      return;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_read_lp": {
      "start_point": [
        843,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "int glp_read_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)\n{     /* read problem data in CPLEX LP format */\n      glp_cpxcp _parm;\n      struct csa _csa, *csa = &_csa;\n      int ret;\n      xprintf(\"Reading problem data from '%s'...\\n\", fname);\n      if (parm == NULL)\n         glp_init_cpxcp(&_parm), parm = &_parm;\n      /* check control parameters */\n      check_parm(\"glp_read_lp\", parm);\n      /* initialize common storage area */\n      csa->P = P;\n      csa->parm = parm;\n      csa->fname = fname;\n      csa->fp = NULL;\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->token = T_EOF;\n      csa->image[0] = '\\0';\n      csa->imlen = 0;\n      csa->value = 0.0;\n      csa->n_max = 100;\n      csa->ind = xcalloc(1+csa->n_max, sizeof(int));\n      csa->val = xcalloc(1+csa->n_max, sizeof(double));\n      csa->flag = xcalloc(1+csa->n_max, sizeof(char));\n      memset(&csa->flag[1], 0, csa->n_max * sizeof(char));\n      csa->lb = xcalloc(1+csa->n_max, sizeof(double));\n      csa->ub = xcalloc(1+csa->n_max, sizeof(double));\n#if 1 /* 27/VII-2013 */\n      csa->lb_warn = csa->ub_warn = 0;\n#endif\n      /* erase problem object */\n      glp_erase_prob(P);\n      glp_create_index(P);\n      /* open input CPLEX LP file */\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* scan very first token */\n      scan_token(csa);\n      /* parse definition of the objective function */\n      if (!(csa->token == T_MINIMIZE || csa->token == T_MAXIMIZE))\n         error(csa, \"'minimize' or 'maximize' keyword missing\\n\");\n      parse_objective(csa);\n      /* parse constraints section */\n      if (csa->token != T_SUBJECT_TO)\n         error(csa, \"constraints section missing\\n\");\n      parse_constraints(csa);\n      /* parse optional bounds section */\n      if (csa->token == T_BOUNDS) parse_bounds(csa);\n      /* parse optional general, integer, and binary sections */\n      while (csa->token == T_GENERAL ||\n             csa->token == T_INTEGER ||\n             csa->token == T_BINARY) parse_integer(csa);\n      /* check for the keyword 'end' */\n      if (csa->token == T_END)\n         scan_token(csa);\n      else if (csa->token == T_EOF)\n         warning(csa, \"keyword 'end' missing\\n\");\n      else\n         error(csa, \"symbol '%s' in wrong position\\n\", csa->image);\n      /* nothing must follow the keyword 'end' (except comments) */\n      if (csa->token != T_EOF)\n         error(csa, \"extra symbol(s) detected beyond 'end'\\n\");\n      /* set bounds of variables */\n      {  int j, type;\n         double lb, ub;\n         for (j = 1; j <= P->n; j++)\n         {  lb = csa->lb[j];\n            ub = csa->ub[j];\n            if (lb == +DBL_MAX) lb = 0.0;      /* default lb */\n            if (ub == -DBL_MAX) ub = +DBL_MAX; /* default ub */\n            if (lb == -DBL_MAX && ub == +DBL_MAX)\n               type = GLP_FR;\n            else if (ub == +DBL_MAX)\n               type = GLP_LO;\n            else if (lb == -DBL_MAX)\n               type = GLP_UP;\n            else if (lb != ub)\n               type = GLP_DB;\n            else\n               type = GLP_FX;\n            glp_set_col_bnds(csa->P, j, type, lb, ub);\n         }\n      }\n      /* print some statistics */\n      xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n         P->m, P->m == 1 ? \"\" : \"s\", P->n, P->n == 1 ? \"\" : \"s\",\n         P->nnz, P->nnz == 1 ? \"\" : \"s\");\n      if (glp_get_num_int(P) > 0)\n      {  int ni = glp_get_num_int(P);\n         int nb = glp_get_num_bin(P);\n         if (ni == 1)\n         {  if (nb == 0)\n               xprintf(\"One variable is integer\\n\");\n            else\n               xprintf(\"One variable is binary\\n\");\n         }\n         else\n         {  xprintf(\"%d integer variables, \", ni);\n            if (nb == 0)\n               xprintf(\"none\");\n            else if (nb == 1)\n               xprintf(\"one\");\n            else if (nb == ni)\n               xprintf(\"all\");\n            else\n               xprintf(\"%d\", nb);\n            xprintf(\" of which %s binary\\n\", nb == 1 ? \"is\" : \"are\");\n         }\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\n      /* problem data has been successfully read */\n      glp_delete_index(P);\n      glp_sort_matrix(P);\n      ret = 0;\ndone: if (csa->fp != NULL) glp_close(csa->fp);\n      xfree(csa->ind);\n      xfree(csa->val);\n      xfree(csa->flag);\n      xfree(csa->lb);\n      xfree(csa->ub);\n      if (ret != 0) glp_erase_prob(P);\n      return ret;\n}",
      "lines": 132,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "check_name": {
      "start_point": [
        1013,
        0
      ],
      "end_point": [
        1022,
        1
      ],
      "content": "static int check_name(char *name)\n{     /* check if specified name is valid for CPLEX LP format */\n      if (*name == '.') return 1;\n      if (isdigit((unsigned char)*name)) return 1;\n      for (; *name; name++)\n      {  if (!isalnum((unsigned char)*name) &&\n             strchr(CHAR_SET, (unsigned char)*name) == NULL) return 1;\n      }\n      return 0; /* name is ok */\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "adjust_name": {
      "start_point": [
        1024,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "static void adjust_name(char *name)\n{     /* attempt to adjust specified name to make it valid for CPLEX LP\n         format */\n      for (; *name; name++)\n      {  if (*name == ' ')\n            *name = '_';\n         else if (*name == '-')\n            *name = '~';\n         else if (*name == '[')\n            *name = '(';\n         else if (*name == ']')\n            *name = ')';\n      }\n      return;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_name": {
      "start_point": [
        1040,
        0
      ],
      "end_point": [
        1057,
        1
      ],
      "content": "static char *row_name(struct csa *csa, int i, char rname[255+1])\n{     /* construct symbolic name of i-th row (constraint) */\n      const char *name;\n      if (i == 0)\n         name = glp_get_obj_name(csa->P);\n      else\n         name = glp_get_row_name(csa->P, i);\n      if (name == NULL) goto fake;\n      strcpy(rname, name);\n      adjust_name(rname);\n      if (check_name(rname)) goto fake;\n      return rname;\nfake: if (i == 0)\n         strcpy(rname, \"obj\");\n      else\n         sprintf(rname, \"r_%d\", i);\n      return rname;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*row_name(struct csa *csa, int i, char rname[255+1])",
        "*"
      ]
    },
    "col_name": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "static char *col_name(struct csa *csa, int j, char cname[255+1])\n{     /* construct symbolic name of j-th column (variable) */\n      const char *name;\n      name = glp_get_col_name(csa->P, j);\n      if (name == NULL) goto fake;\n      strcpy(cname, name);\n      adjust_name(cname);\n      if (check_name(cname)) goto fake;\n      return cname;\n#if 0 /* 18/I-2018 */\nfake: sprintf(cname, \"x_%d\", j);\n#else\nfake: /* construct fake name depending on column's attributes */\n      {  GLPCOL *col = csa->P->col[j];\n         if (col->type == GLP_FX)\n         {  /* fixed column */\n            sprintf(cname, \"s_%d\", j);\n         }\n         else if (col->kind == GLP_CV)\n         {  /* continuous variable */\n            sprintf(cname, \"x_%d\", j);\n         }\n         else if (!(col->lb == 0 && col->ub == 1))\n         {  /* general (non-binary) integer variable */\n            sprintf(cname, \"y_%d\", j);\n         }\n         else\n         {  /* binary variable */\n            sprintf(cname, \"z_%d\", j);\n         }\n      }\n#endif\n      return cname;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*col_name(struct csa *csa, int j, char cname[255+1])",
        "*"
      ]
    },
    "glp_write_lp": {
      "start_point": [
        1094,
        0
      ],
      "end_point": [
        1280,
        1
      ],
      "content": "int glp_write_lp(glp_prob *P, const glp_cpxcp *parm, const char *fname)\n{     /* write problem data in CPLEX LP format */\n      glp_cpxcp _parm;\n      struct csa _csa, *csa = &_csa;\n      glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int i, j, len, flag, count, ret;\n      char line[1000+1], term[500+1], name[255+1];\n      xprintf(\"Writing problem data to '%s'...\\n\", fname);\n      if (parm == NULL)\n         glp_init_cpxcp(&_parm), parm = &_parm;\n      /* check control parameters */\n      check_parm(\"glp_write_lp\", parm);\n      /* initialize common storage area */\n      csa->P = P;\n      csa->parm = parm;\n      /* create output CPLEX LP file */\n      fp = glp_open(fname, \"w\"), count = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* write problem name */\n      xfprintf(fp, \"\\\\* Problem: %s *\\\\\\n\",\n         P->name == NULL ? \"Unknown\" : P->name), count++;\n      xfprintf(fp, \"\\n\"), count++;\n      /* the problem should contain at least one row and one column */\n      if (!(P->m > 0 && P->n > 0))\n      {  xprintf(\"Warning: problem has no rows/columns\\n\");\n         xfprintf(fp, \"\\\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\\\\n\"),\n            count++;\n         xfprintf(fp, \"\\n\"), count++;\n         goto skip;\n      }\n      /* write the objective function definition */\n      if (P->dir == GLP_MIN)\n         xfprintf(fp, \"Minimize\\n\"), count++;\n      else if (P->dir == GLP_MAX)\n         xfprintf(fp, \"Maximize\\n\"), count++;\n      else\n         xassert(P != P);\n      row_name(csa, 0, name);\n      sprintf(line, \" %s:\", name);\n      len = 0;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->coef != 0.0 || col->ptr == NULL)\n         {  len++;\n            col_name(csa, j, name);\n            if (col->coef == 0.0)\n               sprintf(term, \" + 0 %s\", name); /* empty column */\n            else if (col->coef == +1.0)\n               sprintf(term, \" + %s\", name);\n            else if (col->coef == -1.0)\n               sprintf(term, \" - %s\", name);\n            else if (col->coef > 0.0)\n               sprintf(term, \" + %.*g %s\", DBL_DIG, +col->coef, name);\n            else\n               sprintf(term, \" - %.*g %s\", DBL_DIG, -col->coef, name);\n            if (strlen(line) + strlen(term) > 72)\n               xfprintf(fp, \"%s\\n\", line), line[0] = '\\0', count++;\n            strcat(line, term);\n         }\n      }\n      if (len == 0)\n      {  /* empty objective */\n         sprintf(term, \" 0 %s\", col_name(csa, 1, name));\n         strcat(line, term);\n      }\n      xfprintf(fp, \"%s\\n\", line), count++;\n      if (P->c0 != 0.0)\n         xfprintf(fp, \"\\\\* constant term = %.*g *\\\\\\n\", DBL_DIG, P->c0),\n            count++;\n      xfprintf(fp, \"\\n\"), count++;\n      /* write the constraints section */\n      xfprintf(fp, \"Subject To\\n\"), count++;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->type == GLP_FR) continue; /* skip free row */\n         row_name(csa, i, name);\n         sprintf(line, \" %s:\", name);\n         /* linear form */\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  col_name(csa, aij->col->j, name);\n            if (aij->val == +1.0)\n               sprintf(term, \" + %s\", name);\n            else if (aij->val == -1.0)\n               sprintf(term, \" - %s\", name);\n            else if (aij->val > 0.0)\n               sprintf(term, \" + %.*g %s\", DBL_DIG, +aij->val, name);\n            else\n               sprintf(term, \" - %.*g %s\", DBL_DIG, -aij->val, name);\n            if (strlen(line) + strlen(term) > 72)\n               xfprintf(fp, \"%s\\n\", line), line[0] = '\\0', count++;\n            strcat(line, term);\n         }\n         if (row->type == GLP_DB)\n         {  /* double-bounded (ranged) constraint */\n            sprintf(term, \" - ~r_%d\", i);\n            if (strlen(line) + strlen(term) > 72)\n               xfprintf(fp, \"%s\\n\", line), line[0] = '\\0', count++;\n            strcat(line, term);\n         }\n         else if (row->ptr == NULL)\n         {  /* empty constraint */\n            sprintf(term, \" 0 %s\", col_name(csa, 1, name));\n            strcat(line, term);\n         }\n         /* right hand-side */\n         if (row->type == GLP_LO)\n            sprintf(term, \" >= %.*g\", DBL_DIG, row->lb);\n         else if (row->type == GLP_UP)\n            sprintf(term, \" <= %.*g\", DBL_DIG, row->ub);\n         else if (row->type == GLP_DB || row->type == GLP_FX)\n            sprintf(term, \" = %.*g\", DBL_DIG, row->lb);\n         else\n            xassert(row != row);\n         if (strlen(line) + strlen(term) > 72)\n            xfprintf(fp, \"%s\\n\", line), line[0] = '\\0', count++;\n         strcat(line, term);\n         xfprintf(fp, \"%s\\n\", line), count++;\n      }\n      xfprintf(fp, \"\\n\"), count++;\n      /* write the bounds section */\n      flag = 0;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->type != GLP_DB) continue;\n         if (!flag)\n            xfprintf(fp, \"Bounds\\n\"), flag = 1, count++;\n         xfprintf(fp, \" 0 <= ~r_%d <= %.*g\\n\",\n            i, DBL_DIG, row->ub - row->lb), count++;\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->type == GLP_LO && col->lb == 0.0) continue;\n         if (!flag)\n            xfprintf(fp, \"Bounds\\n\"), flag = 1, count++;\n         col_name(csa, j, name);\n         if (col->type == GLP_FR)\n            xfprintf(fp, \" %s free\\n\", name), count++;\n         else if (col->type == GLP_LO)\n            xfprintf(fp, \" %s >= %.*g\\n\",\n               name, DBL_DIG, col->lb), count++;\n         else if (col->type == GLP_UP)\n            xfprintf(fp, \" -Inf <= %s <= %.*g\\n\",\n               name, DBL_DIG, col->ub), count++;\n         else if (col->type == GLP_DB)\n            xfprintf(fp, \" %.*g <= %s <= %.*g\\n\",\n               DBL_DIG, col->lb, name, DBL_DIG, col->ub), count++;\n         else if (col->type == GLP_FX)\n            xfprintf(fp, \" %s = %.*g\\n\",\n               name, DBL_DIG, col->lb), count++;\n         else\n            xassert(col != col);\n      }\n      if (flag) xfprintf(fp, \"\\n\"), count++;\n      /* write the integer section */\n      flag = 0;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->kind == GLP_CV) continue;\n         xassert(col->kind == GLP_IV);\n         if (!flag)\n            xfprintf(fp, \"Generals\\n\"), flag = 1, count++;\n         xfprintf(fp, \" %s\\n\", col_name(csa, j, name)), count++;\n      }\n      if (flag) xfprintf(fp, \"\\n\"), count++;\nskip: /* write the end keyword */\n      xfprintf(fp, \"End\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* problem data has been successfully written */\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 187,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/cpp.c": {
    "glp_cpp": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "double glp_cpp(glp_graph *G, int v_t, int v_es, int v_ls)\n{     glp_vertex *v;\n      glp_arc *a;\n      int i, j, k, nv, *list;\n      double temp, total, *t, *es, *ls;\n      if (v_t >= 0 && v_t > G->v_size - (int)sizeof(double))\n         xerror(\"glp_cpp: v_t = %d; invalid offset\\n\", v_t);\n      if (v_es >= 0 && v_es > G->v_size - (int)sizeof(double))\n         xerror(\"glp_cpp: v_es = %d; invalid offset\\n\", v_es);\n      if (v_ls >= 0 && v_ls > G->v_size - (int)sizeof(double))\n         xerror(\"glp_cpp: v_ls = %d; invalid offset\\n\", v_ls);\n      nv = G->nv;\n      if (nv == 0)\n      {  total = 0.0;\n         goto done;\n      }\n      /* allocate working arrays */\n      t = xcalloc(1+nv, sizeof(double));\n      es = xcalloc(1+nv, sizeof(double));\n      ls = xcalloc(1+nv, sizeof(double));\n      list = xcalloc(1+nv, sizeof(int));\n      /* retrieve job times */\n      for (i = 1; i <= nv; i++)\n      {  v = G->v[i];\n         if (v_t >= 0)\n         {  memcpy(&t[i], (char *)v->data + v_t, sizeof(double));\n            if (t[i] < 0.0)\n               xerror(\"glp_cpp: t[%d] = %g; invalid time\\n\", i, t[i]);\n         }\n         else\n            t[i] = 1.0;\n      }\n      /* perform topological sorting to determine the list of nodes\n         (jobs) such that if list[k] = i and list[kk] = j and there\n         exists arc (i->j), then k < kk */\n      sorting(G, list);\n      /* FORWARD PASS */\n      /* determine earliest start times */\n      for (k = 1; k <= nv; k++)\n      {  j = list[k];\n         es[j] = 0.0;\n         for (a = G->v[j]->in; a != NULL; a = a->h_next)\n         {  i = a->tail->i;\n            /* there exists arc (i->j) in the project network */\n            temp = es[i] + t[i];\n            if (es[j] < temp) es[j] = temp;\n         }\n      }\n      /* determine the minimal project duration */\n      total = 0.0;\n      for (i = 1; i <= nv; i++)\n      {  temp = es[i] + t[i];\n         if (total < temp) total = temp;\n      }\n      /* BACKWARD PASS */\n      /* determine latest start times */\n      for (k = nv; k >= 1; k--)\n      {  i = list[k];\n         ls[i] = total - t[i];\n         for (a = G->v[i]->out; a != NULL; a = a->t_next)\n         {  j = a->head->i;\n            /* there exists arc (i->j) in the project network */\n            temp = ls[j] - t[i];\n            if (ls[i] > temp) ls[i] = temp;\n         }\n         /* avoid possible round-off errors */\n         if (ls[i] < es[i]) ls[i] = es[i];\n      }\n      /* store results, if necessary */\n      if (v_es >= 0)\n      {  for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_es, &es[i], sizeof(double));\n         }\n      }\n      if (v_ls >= 0)\n      {  for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_ls, &ls[i], sizeof(double));\n         }\n      }\n      /* free working arrays */\n      xfree(t);\n      xfree(es);\n      xfree(ls);\n      xfree(list);\ndone: return total;\n}",
      "lines": 88,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "sorting": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void sorting(glp_graph *G, int list[])\n{     /* perform topological sorting to determine the list of nodes\n         (jobs) such that if list[k] = i and list[kk] = j and there\n         exists arc (i->j), then k < kk */\n      int i, k, nv, v_size, *num;\n      void **save;\n      nv = G->nv;\n      v_size = G->v_size;\n      save = xcalloc(1+nv, sizeof(void *));\n      num = xcalloc(1+nv, sizeof(int));\n      G->v_size = sizeof(int);\n      for (i = 1; i <= nv; i++)\n      {  save[i] = G->v[i]->data;\n         G->v[i]->data = &num[i];\n         list[i] = 0;\n      }\n      if (glp_top_sort(G, 0) != 0)\n         xerror(\"glp_cpp: project network is not acyclic\\n\");\n      G->v_size = v_size;\n      for (i = 1; i <= nv; i++)\n      {  G->v[i]->data = save[i];\n         k = num[i];\n         xassert(1 <= k && k <= nv);\n         xassert(list[k] == 0);\n         list[k] = i;\n      }\n      xfree(save);\n      xfree(num);\n      return;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/cpxbas.c": {
    "fcmp": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static int CDECL fcmp(const void *ptr1, const void *ptr2)\n{     /* this routine is passed to the qsort() function */\n      struct var *col1 = (void *)ptr1, *col2 = (void *)ptr2;\n      if (col1->q < col2->q) return -1;\n      if (col1->q > col2->q) return +1;\n      return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "get_column": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static int get_column(glp_prob *lp, int j, int ind[], double val[])\n{     /* Bixby's algorithm assumes that the constraint matrix is scaled\n         such that the maximum absolute value in every non-zero row and\n         column is 1 */\n      int k, len;\n      double big;\n      len = glp_get_mat_col(lp, j, ind, val);\n      big = 0.0;\n      for (k = 1; k <= len; k++)\n         if (big < fabs(val[k])) big = fabs(val[k]);\n      if (big == 0.0) big = 1.0;\n      for (k = 1; k <= len; k++) val[k] /= big;\n      return len;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cpx_basis": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static void cpx_basis(glp_prob *lp)\n{     /* main routine */\n      struct var *C, *C2, *C3, *C4;\n      int m, n, i, j, jk, k, l, ll, t, n2, n3, n4, type, len, *I, *r,\n         *ind;\n      double alpha, gamma, cmax, temp, *v, *val;\n      xprintf(\"Constructing initial basis...\\n\");\n      /* determine the number of rows and columns */\n      m = glp_get_num_rows(lp);\n      n = glp_get_num_cols(lp);\n      /* allocate working arrays */\n      C = xcalloc(1+n, sizeof(struct var));\n      I = xcalloc(1+m, sizeof(int));\n      r = xcalloc(1+m, sizeof(int));\n      v = xcalloc(1+m, sizeof(double));\n      ind = xcalloc(1+m, sizeof(int));\n      val = xcalloc(1+m, sizeof(double));\n      /* make all auxiliary variables non-basic */\n      for (i = 1; i <= m; i++)\n      {  if (glp_get_row_type(lp, i) != GLP_DB)\n            glp_set_row_stat(lp, i, GLP_NS);\n         else if (fabs(glp_get_row_lb(lp, i)) <=\n                  fabs(glp_get_row_ub(lp, i)))\n            glp_set_row_stat(lp, i, GLP_NL);\n         else\n            glp_set_row_stat(lp, i, GLP_NU);\n      }\n      /* make all structural variables non-basic */\n      for (j = 1; j <= n; j++)\n      {  if (glp_get_col_type(lp, j) != GLP_DB)\n            glp_set_col_stat(lp, j, GLP_NS);\n         else if (fabs(glp_get_col_lb(lp, j)) <=\n                  fabs(glp_get_col_ub(lp, j)))\n            glp_set_col_stat(lp, j, GLP_NL);\n         else\n            glp_set_col_stat(lp, j, GLP_NU);\n      }\n      /* C2 is a set of free structural variables */\n      n2 = 0, C2 = C + 0;\n      for (j = 1; j <= n; j++)\n      {  type = glp_get_col_type(lp, j);\n         if (type == GLP_FR)\n         {  n2++;\n            C2[n2].j = j;\n            C2[n2].q = 0.0;\n         }\n      }\n      /* C3 is a set of structural variables having excatly one (lower\n         or upper) bound */\n      n3 = 0, C3 = C2 + n2;\n      for (j = 1; j <= n; j++)\n      {  type = glp_get_col_type(lp, j);\n         if (type == GLP_LO)\n         {  n3++;\n            C3[n3].j = j;\n            C3[n3].q = + glp_get_col_lb(lp, j);\n         }\n         else if (type == GLP_UP)\n         {  n3++;\n            C3[n3].j = j;\n            C3[n3].q = - glp_get_col_ub(lp, j);\n         }\n      }\n      /* C4 is a set of structural variables having both (lower and\n         upper) bounds */\n      n4 = 0, C4 = C3 + n3;\n      for (j = 1; j <= n; j++)\n      {  type = glp_get_col_type(lp, j);\n         if (type == GLP_DB)\n         {  n4++;\n            C4[n4].j = j;\n            C4[n4].q = glp_get_col_lb(lp, j) - glp_get_col_ub(lp, j);\n         }\n      }\n      /* compute gamma = max{|c[j]|: 1 <= j <= n} */\n      gamma = 0.0;\n      for (j = 1; j <= n; j++)\n      {  temp = fabs(glp_get_obj_coef(lp, j));\n         if (gamma < temp) gamma = temp;\n      }\n      /* compute cmax */\n      cmax = (gamma == 0.0 ? 1.0 : 1000.0 * gamma);\n      /* compute final penalty for all structural variables within sets\n         C2, C3, and C4 */\n      switch (glp_get_obj_dir(lp))\n      {  case GLP_MIN: temp = +1.0; break;\n         case GLP_MAX: temp = -1.0; break;\n         default: xassert(lp != lp);\n      }\n      for (k = 1; k <= n2+n3+n4; k++)\n      {  j = C[k].j;\n         C[k].q += (temp * glp_get_obj_coef(lp, j)) / cmax;\n      }\n      /* sort structural variables within C2, C3, and C4 in ascending\n         order of penalty value */\n      qsort(C2+1, n2, sizeof(struct var), fcmp);\n      for (k = 1; k < n2; k++) xassert(C2[k].q <= C2[k+1].q);\n      qsort(C3+1, n3, sizeof(struct var), fcmp);\n      for (k = 1; k < n3; k++) xassert(C3[k].q <= C3[k+1].q);\n      qsort(C4+1, n4, sizeof(struct var), fcmp);\n      for (k = 1; k < n4; k++) xassert(C4[k].q <= C4[k+1].q);\n      /*** STEP 1 ***/\n      for (i = 1; i <= m; i++)\n      {  type = glp_get_row_type(lp, i);\n         if (type != GLP_FX)\n         {  /* row i is either free or inequality constraint */\n            glp_set_row_stat(lp, i, GLP_BS);\n            I[i] = 1;\n            r[i] = 1;\n         }\n         else\n         {  /* row i is equality constraint */\n            I[i] = 0;\n            r[i] = 0;\n         }\n         v[i] = +DBL_MAX;\n      }\n      /*** STEP 2 ***/\n      for (k = 1; k <= n2+n3+n4; k++)\n      {  jk = C[k].j;\n         len = get_column(lp, jk, ind, val);\n         /* let alpha = max{|A[l,jk]|: r[l] = 0} and let l' be such\n            that alpha = |A[l',jk]| */\n         alpha = 0.0, ll = 0;\n         for (t = 1; t <= len; t++)\n         {  l = ind[t];\n            if (r[l] == 0 && alpha < fabs(val[t]))\n               alpha = fabs(val[t]), ll = l;\n         }\n         if (alpha >= 0.99)\n         {  /* B := B union {jk} */\n            glp_set_col_stat(lp, jk, GLP_BS);\n            I[ll] = 1;\n            v[ll] = alpha;\n            /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\n            for (t = 1; t <= len; t++)\n            {  l = ind[t];\n               if (val[t] != 0.0) r[l]++;\n            }\n            /* continue to the next k */\n            continue;\n         }\n         /* if |A[l,jk]| > 0.01 * v[l] for some l, continue to the\n            next k */\n         for (t = 1; t <= len; t++)\n         {  l = ind[t];\n            if (fabs(val[t]) > 0.01 * v[l]) break;\n         }\n         if (t <= len) continue;\n         /* otherwise, let alpha = max{|A[l,jk]|: I[l] = 0} and let l'\n            be such that alpha = |A[l',jk]| */\n         alpha = 0.0, ll = 0;\n         for (t = 1; t <= len; t++)\n         {  l = ind[t];\n            if (I[l] == 0 && alpha < fabs(val[t]))\n               alpha = fabs(val[t]), ll = l;\n         }\n         /* if alpha = 0, continue to the next k */\n         if (alpha == 0.0) continue;\n         /* B := B union {jk} */\n         glp_set_col_stat(lp, jk, GLP_BS);\n         I[ll] = 1;\n         v[ll] = alpha;\n         /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\n         for (t = 1; t <= len; t++)\n         {  l = ind[t];\n            if (val[t] != 0.0) r[l]++;\n         }\n      }\n      /*** STEP 3 ***/\n      /* add an artificial variable (auxiliary variable for equality\n         constraint) to cover each remaining uncovered row */\n      for (i = 1; i <= m; i++)\n         if (I[i] == 0) glp_set_row_stat(lp, i, GLP_BS);\n      /* free working arrays */\n      xfree(C);\n      xfree(I);\n      xfree(r);\n      xfree(v);\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 183,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_cpx_basis": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void glp_cpx_basis(glp_prob *lp)\n{     if (lp->m == 0 || lp->n == 0)\n         glp_std_basis(lp);\n      else\n         cpx_basis(lp);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/graph.c": {
    "create_graph": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void create_graph(glp_graph *G, int v_size, int a_size)\n{     G->pool = dmp_create_pool();\n      G->name = NULL;\n      G->nv_max = 50;\n      G->nv = G->na = 0;\n      G->v = xcalloc(1+G->nv_max, sizeof(glp_vertex *));\n      G->index = NULL;\n      G->v_size = v_size;\n      G->a_size = a_size;\n      return;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_create_graph": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "glp_graph *glp_create_graph(int v_size, int a_size)\n{     glp_graph *G;\n      if (!(0 <= v_size && v_size <= 256))\n         xerror(\"glp_create_graph: v_size = %d; invalid size of vertex \"\n            \"data\\n\", v_size);\n      if (!(0 <= a_size && a_size <= 256))\n         xerror(\"glp_create_graph: a_size = %d; invalid size of arc dat\"\n            \"a\\n\", a_size);\n      G = xmalloc(sizeof(glp_graph));\n      create_graph(G, v_size, a_size);\n      return G;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "glp_graph",
        "*glp_create_graph(int v_size, int a_size)",
        "*"
      ]
    },
    "glp_set_graph_name": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void glp_set_graph_name(glp_graph *G, const char *name)\n{     if (G->name != NULL)\n      {  dmp_free_atom(G->pool, G->name, strlen(G->name)+1);\n         G->name = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int j;\n         for (j = 0; name[j] != '\\0'; j++)\n         {  if (j == 256)\n               xerror(\"glp_set_graph_name: graph name too long\\n\");\n            if (iscntrl((unsigned char)name[j]))\n               xerror(\"glp_set_graph_name: graph name contains invalid \"\n                  \"character(s)\\n\");\n         }\n         G->name = dmp_get_atom(G->pool, strlen(name)+1);\n         strcpy(G->name, name);\n      }\n      return;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_add_vertices": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int glp_add_vertices(glp_graph *G, int nadd)\n{     int i, nv_new;\n      if (nadd < 1)\n         xerror(\"glp_add_vertices: nadd = %d; invalid number of vertice\"\n            \"s\\n\", nadd);\n      if (nadd > NV_MAX - G->nv)\n         xerror(\"glp_add_vertices: nadd = %d; too many vertices\\n\",\n            nadd);\n      /* determine new number of vertices */\n      nv_new = G->nv + nadd;\n      /* increase the room, if necessary */\n      if (G->nv_max < nv_new)\n      {  glp_vertex **save = G->v;\n         while (G->nv_max < nv_new)\n         {  G->nv_max += G->nv_max;\n            xassert(G->nv_max > 0);\n         }\n         G->v = xcalloc(1+G->nv_max, sizeof(glp_vertex *));\n         memcpy(&G->v[1], &save[1], G->nv * sizeof(glp_vertex *));\n         xfree(save);\n      }\n      /* add new vertices to the end of the vertex list */\n      for (i = G->nv+1; i <= nv_new; i++)\n      {  glp_vertex *v;\n         G->v[i] = v = dmp_get_atom(G->pool, sizeof(glp_vertex));\n         v->i = i;\n         v->name = NULL;\n         v->entry = NULL;\n         if (G->v_size == 0)\n            v->data = NULL;\n         else\n         {  v->data = dmp_get_atom(G->pool, G->v_size);\n            memset(v->data, 0, G->v_size);\n         }\n         v->temp = NULL;\n         v->in = v->out = NULL;\n      }\n      /* set new number of vertices */\n      G->nv = nv_new;\n      /* return the ordinal number of the first vertex added */\n      return nv_new - nadd + 1;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_set_vertex_name": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void glp_set_vertex_name(glp_graph *G, int i, const char *name)\n{     /* assign (change) vertex name */\n      glp_vertex *v;\n      if (!(1 <= i && i <= G->nv))\n         xerror(\"glp_set_vertex_name: i = %d; vertex number out of rang\"\n            \"e\\n\", i);\n      v = G->v[i];\n      if (v->name != NULL)\n      {  if (v->entry != NULL)\n         {  xassert(G->index != NULL);\n            avl_delete_node(G->index, v->entry);\n            v->entry = NULL;\n         }\n         dmp_free_atom(G->pool, v->name, strlen(v->name)+1);\n         v->name = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int k;\n         for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_set_vertex_name: i = %d; vertex name too lon\"\n                  \"g\\n\", i);\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_set_vertex_name: i = %d; vertex name contain\"\n                  \"s invalid character(s)\\n\", i);\n         }\n         v->name = dmp_get_atom(G->pool, strlen(name)+1);\n         strcpy(v->name, name);\n         if (G->index != NULL)\n         {  xassert(v->entry == NULL);\n            v->entry = avl_insert_node(G->index, v->name);\n            avl_set_node_link(v->entry, v);\n         }\n      }\n      return;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_add_arc": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "glp_arc *glp_add_arc(glp_graph *G, int i, int j)\n{     glp_arc *a;\n      if (!(1 <= i && i <= G->nv))\n         xerror(\"glp_add_arc: i = %d; tail vertex number out of range\\n\"\n            , i);\n      if (!(1 <= j && j <= G->nv))\n         xerror(\"glp_add_arc: j = %d; head vertex number out of range\\n\"\n            , j);\n      if (G->na == NA_MAX)\n         xerror(\"glp_add_arc: too many arcs\\n\");\n      a = dmp_get_atom(G->pool, sizeof(glp_arc));\n      a->tail = G->v[i];\n      a->head = G->v[j];\n      if (G->a_size == 0)\n         a->data = NULL;\n      else\n      {  a->data = dmp_get_atom(G->pool, G->a_size);\n         memset(a->data, 0, G->a_size);\n      }\n      a->temp = NULL;\n      a->t_prev = NULL;\n      a->t_next = G->v[i]->out;\n      if (a->t_next != NULL) a->t_next->t_prev = a;\n      a->h_prev = NULL;\n      a->h_next = G->v[j]->in;\n      if (a->h_next != NULL) a->h_next->h_prev = a;\n      G->v[i]->out = G->v[j]->in = a;\n      G->na++;\n      return a;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "glp_arc",
        "*glp_add_arc(glp_graph *G, int i, int j)",
        "*"
      ]
    },
    "glp_del_vertices": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "void glp_del_vertices(glp_graph *G, int ndel, const int num[])\n{     glp_vertex *v;\n      int i, k, nv_new;\n      /* scan the list of vertices to be deleted */\n      if (!(1 <= ndel && ndel <= G->nv))\n         xerror(\"glp_del_vertices: ndel = %d; invalid number of vertice\"\n            \"s\\n\", ndel);\n      for (k = 1; k <= ndel; k++)\n      {  /* take the number of vertex to be deleted */\n         i = num[k];\n         /* obtain pointer to i-th vertex */\n         if (!(1 <= i && i <= G->nv))\n            xerror(\"glp_del_vertices: num[%d] = %d; vertex number out o\"\n               \"f range\\n\", k, i);\n         v = G->v[i];\n         /* check that the vertex is not marked yet */\n         if (v->i == 0)\n            xerror(\"glp_del_vertices: num[%d] = %d; duplicate vertex nu\"\n               \"mbers not allowed\\n\", k, i);\n         /* erase symbolic name assigned to the vertex */\n         glp_set_vertex_name(G, i, NULL);\n         xassert(v->name == NULL);\n         xassert(v->entry == NULL);\n         /* free vertex data, if allocated */\n         if (v->data != NULL)\n            dmp_free_atom(G->pool, v->data, G->v_size);\n         /* delete all incoming arcs */\n         while (v->in != NULL)\n            glp_del_arc(G, v->in);\n         /* delete all outgoing arcs */\n         while (v->out != NULL)\n            glp_del_arc(G, v->out);\n         /* mark the vertex to be deleted */\n         v->i = 0;\n      }\n      /* delete all marked vertices from the vertex list */\n      nv_new = 0;\n      for (i = 1; i <= G->nv; i++)\n      {  /* obtain pointer to i-th vertex */\n         v = G->v[i];\n         /* check if the vertex is marked */\n         if (v->i == 0)\n         {  /* it is marked, delete it */\n            dmp_free_atom(G->pool, v, sizeof(glp_vertex));\n         }\n         else\n         {  /* it is not marked, keep it */\n            v->i = ++nv_new;\n            G->v[v->i] = v;\n         }\n      }\n      /* set new number of vertices in the graph */\n      G->nv = nv_new;\n      return;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_del_arc": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "void glp_del_arc(glp_graph *G, glp_arc *a)\n{     /* some sanity checks */\n      xassert(G->na > 0);\n      xassert(1 <= a->tail->i && a->tail->i <= G->nv);\n      xassert(a->tail == G->v[a->tail->i]);\n      xassert(1 <= a->head->i && a->head->i <= G->nv);\n      xassert(a->head == G->v[a->head->i]);\n      /* remove the arc from the list of incoming arcs */\n      if (a->h_prev == NULL)\n         a->head->in = a->h_next;\n      else\n         a->h_prev->h_next = a->h_next;\n      if (a->h_next == NULL)\n         ;\n      else\n         a->h_next->h_prev = a->h_prev;\n      /* remove the arc from the list of outgoing arcs */\n      if (a->t_prev == NULL)\n         a->tail->out = a->t_next;\n      else\n         a->t_prev->t_next = a->t_next;\n      if (a->t_next == NULL)\n         ;\n      else\n         a->t_next->t_prev = a->t_prev;\n      /* free arc data, if allocated */\n      if (a->data != NULL)\n         dmp_free_atom(G->pool, a->data, G->a_size);\n      /* delete the arc from the graph */\n      dmp_free_atom(G->pool, a, sizeof(glp_arc));\n      G->na--;\n      return;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "delete_graph": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "static void delete_graph(glp_graph *G)\n{     dmp_delete_pool(G->pool);\n      xfree(G->v);\n      if (G->index != NULL) avl_delete_tree(G->index);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_erase_graph": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "void glp_erase_graph(glp_graph *G, int v_size, int a_size)\n{     if (!(0 <= v_size && v_size <= 256))\n         xerror(\"glp_erase_graph: v_size = %d; invalid size of vertex d\"\n            \"ata\\n\", v_size);\n      if (!(0 <= a_size && a_size <= 256))\n         xerror(\"glp_erase_graph: a_size = %d; invalid size of arc data\"\n            \"\\n\", a_size);\n      delete_graph(G);\n      create_graph(G, v_size, a_size);\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "glp_delete_graph": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "void glp_delete_graph(glp_graph *G)\n{     delete_graph(G);\n      xfree(G);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "glp_create_v_index": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "void glp_create_v_index(glp_graph *G)\n{     /* create vertex name index */\n      glp_vertex *v;\n      int i;\n      if (G->index == NULL)\n      {  G->index = avl_create_tree(avl_strcmp, NULL);\n         for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            xassert(v->entry == NULL);\n            if (v->name != NULL)\n            {  v->entry = avl_insert_node(G->index, v->name);\n               avl_set_node_link(v->entry, v);\n            }\n         }\n      }\n      return;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_find_vertex": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "int glp_find_vertex(glp_graph *G, const char *name)\n{     /* find vertex by its name */\n      AVLNODE *node;\n      int i = 0;\n      if (G->index == NULL)\n         xerror(\"glp_find_vertex: vertex name index does not exist\\n\");\n      if (!(name == NULL || name[0] == '\\0' || strlen(name) > 255))\n      {  node = avl_find_node(G->index, name);\n         if (node != NULL)\n            i = ((glp_vertex *)avl_get_node_link(node))->i;\n      }\n      return i;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_delete_v_index": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        501,
        1
      ],
      "content": "void glp_delete_v_index(glp_graph *G)\n{     /* delete vertex name index */\n      int i;\n      if (G->index != NULL)\n      {  avl_delete_tree(G->index), G->index = NULL;\n         for (i = 1; i <= G->nv; i++) G->v[i]->entry = NULL;\n      }\n      return;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/gridgen.c": {
    "glp_gridgen": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "int glp_gridgen(glp_graph *G_, int _v_rhs, int _a_cap, int _a_cost,\n      const int parm[1+14])\n{     struct csa _csa, *csa = &_csa;\n      int n, ret;\n      G = G_;\n      v_rhs = _v_rhs;\n      a_cap = _a_cap;\n      a_cost = _a_cost;\n      if (G != NULL)\n      {  if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n            xerror(\"glp_gridgen: v_rhs = %d; invalid offset\\n\", v_rhs);\n         if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n            xerror(\"glp_gridgen: a_cap = %d; invalid offset\\n\", a_cap);\n         if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n            xerror(\"glp_gridgen: a_cost = %d; invalid offset\\n\", a_cost)\n               ;\n      }\n      /* Check the parameters for consistency. */\n      if (!(parm[1] == 0 || parm[1] == 1))\n      {  ret = 1;\n         goto done;\n      }\n      if (parm[2] < 1)\n      {  ret = 2;\n         goto done;\n      }\n      if (!(10 <= parm[3] && parm[3] <= 40000))\n      {  ret = 3;\n         goto done;\n      }\n      if (!(1 <= parm[4] && parm[4] <= 40000))\n      {  ret = 4;\n         goto done;\n      }\n      if (!(parm[5] >= 0 && parm[6] >= 0 && parm[5] + parm[6] <=\n         parm[3]))\n      {  ret = 5;\n         goto done;\n      }\n      if (!(1 <= parm[7] && parm[7] <= parm[3]))\n      {  ret = 6;\n         goto done;\n      }\n      if (parm[8] < 0)\n      {  ret = 7;\n         goto done;\n      }\n      if (!(parm[9] == 1 || parm[9] == 2))\n      {  ret = 8;\n         goto done;\n      }\n      if (parm[9] == 1 && parm[10] > parm[11] ||\n          parm[9] == 2 && parm[10] < 1)\n      {  ret = 9;\n         goto done;\n      }\n      if (!(parm[12] == 1 || parm[12] == 2))\n      {  ret = 10;\n         goto done;\n      }\n      if (parm[12] == 1 && !(0 <= parm[13] && parm[13] <= parm[14]) ||\n          parm[12] == 2 && parm[13] < 1)\n      {  ret = 11;\n         goto done;\n      }\n      /* Initialize the graph object. */\n      if (G != NULL)\n      {  glp_erase_graph(G, G->v_size, G->a_size);\n         glp_set_graph_name(G, \"GRIDGEN\");\n      }\n      /* Copy the generator parameters. */\n      two_way = parm[1];\n      seed_original = seed = parm[2];\n      n_node = parm[3];\n      n = parm[4];\n      n_source = parm[5];\n      n_sink = parm[6];\n      avg_degree = parm[7];\n      t_supply = parm[8];\n      arc_costs.distribution = parm[9];\n      if (parm[9] == 1)\n      {  arc_costs.parameter[0] = parm[10];\n         arc_costs.parameter[1] = parm[11];\n      }\n      else\n      {  arc_costs.parameter[0] = (double)parm[10] / 100.0;\n         arc_costs.parameter[1] = 0.0;\n      }\n      capacities.distribution = parm[12];\n      if (parm[12] == 1)\n      {  capacities.parameter[0] = parm[13];\n         capacities.parameter[1] = parm[14];\n      }\n      else\n      {  capacities.parameter[0] = (double)parm[13] / 100.0;\n         capacities.parameter[1] = 0.0;\n      }\n      /* Calculate the edge lengths of the grid according to the\n         input. */\n      if (n * n >= n_node)\n      {  n1 = n;\n         n2 = (int)((double)n_node / (double)n + 0.5);\n      }\n      else\n      {  n2 = n;\n         n1 = (int)((double)n_node / (double)n + 0.5);\n      }\n      /* Recalculate the total number of nodes and plus 1 for the super\n         node. */\n      n_node = n1 * n2 + 1;\n      n_arc = n_node * avg_degree;\n      n_grid_arc = (two_way + 1) * ((n1 - 1) * n2 + (n2 - 1) * n1) +\n         n_source + n_sink;\n      if (n_grid_arc > n_arc) n_arc = n_grid_arc;\n      arc_list = xcalloc(n_arc, sizeof(struct arcs));\n      source_list = xcalloc(n_source, sizeof(struct imbalance));\n      sink_list = xcalloc(n_sink, sizeof(struct imbalance));\n      /* Generate a random network. */\n      generate(csa);\n      /* Output the network. */\n      output(csa);\n      /* Free all allocated memory. */\n      xfree(arc_list);\n      xfree(source_list);\n      xfree(sink_list);\n      /* The instance has been successfully generated. */\n      ret = 0;\ndone: return ret;\n}",
      "lines": 129,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "assign_capacities": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "static void assign_capacities(struct csa *csa)\n{     /* Assign a capacity to each arc. */\n      struct arcs *arc_ptr = arc_list;\n      int (*random)(struct csa *csa, double *);\n      int i;\n      /* Determine the random number generator to use. */\n      switch (arc_costs.distribution)\n      {  case UNIFORM:\n            random = uniform;\n            break;\n         case EXPONENTIAL:\n            random = exponential;\n            break;\n         default:\n            xassert(csa != csa);\n      }\n      /* Assign capacities to grid arcs. */\n      for (i = n_source + n_sink; i < n_grid_arc; i++, arc_ptr++)\n         arc_ptr->u = random(csa, capacities.parameter);\n      i = i - n_source - n_sink;\n      /* Assign capacities to arcs to/from supernode. */\n      for (; i < n_grid_arc; i++, arc_ptr++)\n         arc_ptr->u = t_supply;\n      /* Assign capacities to all other arcs. */\n      for (; i < n_arc; i++, arc_ptr++)\n         arc_ptr->u = random(csa, capacities.parameter);\n      return;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "assign_costs": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "static void assign_costs(struct csa *csa)\n{     /* Assign a cost to each arc. */\n      struct arcs *arc_ptr = arc_list;\n      int (*random)(struct csa *csa, double *);\n      int i;\n      /* A high cost assigned to arcs to/from the supernode. */\n      int high_cost;\n      /* The maximum cost assigned to arcs in the base grid. */\n      int max_cost = 0;\n      /* Determine the random number generator to use. */\n      switch (arc_costs.distribution)\n      {  case UNIFORM:\n            random = uniform;\n            break;\n         case EXPONENTIAL:\n            random = exponential;\n            break;\n         default:\n            xassert(csa != csa);\n      }\n      /* Assign costs to arcs in the base grid. */\n      for (i = n_source + n_sink; i < n_grid_arc; i++, arc_ptr++)\n      {  arc_ptr->cost = random(csa, arc_costs.parameter);\n         if (max_cost < arc_ptr->cost) max_cost = arc_ptr->cost;\n      }\n      i = i - n_source - n_sink;\n      /* Assign costs to arcs to/from the super node. */\n      high_cost = max_cost * 2;\n      for (; i < n_grid_arc; i++, arc_ptr++)\n         arc_ptr->cost = high_cost;\n      /* Assign costs to all other arcs. */\n      for (; i < n_arc; i++, arc_ptr++)\n         arc_ptr->cost = random(csa, arc_costs.parameter);\n      return;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "assign_imbalance": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static void assign_imbalance(struct csa *csa)\n{     /* Assign an imbalance to each node. */\n      int total, i;\n      double avg;\n      struct imbalance *ptr;\n      /* assign the supply nodes */\n      avg = 2.0 * t_supply / n_source;\n      do\n      {  for (i = 1, total = t_supply, ptr = source_list + 1;\n            i < n_source; i++, ptr++)\n         {  ptr->supply = (int)(randy(csa) * avg + 0.5);\n            total -= ptr->supply;\n         }\n         source_list->supply = total;\n      }\n      /* redo all if the assignment \"overshooted\" */\n      while (total <= 0);\n      /* assign the demand nodes */\n      avg = -2.0 * t_supply / n_sink;\n      do\n      {  for (i = 1, total = t_supply, ptr = sink_list + 1;\n            i < n_sink; i++, ptr++)\n         {  ptr->supply = (int)(randy(csa) * avg - 0.5);\n            total += ptr->supply;\n         }\n         sink_list->supply = - total;\n      }\n      while (total <= 0);\n      return;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "exponential": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static int exponential(struct csa *csa, double lambda[1])\n{     /* Returns an \"exponentially distributed\" integer with parameter\n         lambda. */\n      return ((int)(- lambda[0] * log((double)randy(csa)) + 0.5));\n}",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gen_additional_arcs": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "static struct arcs *gen_additional_arcs(struct csa *csa, struct arcs\n      *arc_ptr)\n{     /* Generate an arc from each source to the supernode and from\n         supernode to each sink. */\n      int i;\n      for (i = 0; i < n_source; i++, arc_ptr++)\n      {  arc_ptr->from = source_list[i].node;\n         arc_ptr->to = n_node;\n      }\n      for (i = 0; i < n_sink; i++, arc_ptr++)\n      {  arc_ptr->to = sink_list[i].node;\n         arc_ptr->from = n_node;\n      }\n      return arc_ptr;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct arcs",
        "struct",
        "arcs",
        "*gen_additional_arcs(struct csa *csa, struct arcs\n      *arc_ptr)",
        "*"
      ]
    },
    "gen_basic_grid": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "static struct arcs *gen_basic_grid(struct csa *csa, struct arcs\n      *arc_ptr)\n{     /* Generate the basic grid. */\n      int direction = 1, i, j, k;\n      if (two_way)\n      {  /* Generate an arc in each direction. */\n         for (i = 1; i < n_node; i += n1)\n         {  for (j = i, k = j + n1 - 1; j < k; j++)\n            {  arc_ptr->from = j;\n               arc_ptr->to = j + 1;\n               arc_ptr++;\n               arc_ptr->from = j + 1;\n               arc_ptr->to = j;\n               arc_ptr++;\n            }\n         }\n         for (i = 1; i <= n1; i++)\n         {  for (j = i + n1; j < n_node; j += n1)\n            {  arc_ptr->from = j;\n               arc_ptr->to = j - n1;\n               arc_ptr++;\n               arc_ptr->from = j - n1;\n               arc_ptr->to = j;\n               arc_ptr++;\n            }\n         }\n      }\n      else\n      {  /* Generate one arc in each direction. */\n         for (i = 1; i < n_node; i += n1)\n         {  if (direction == 1)\n               j = i;\n            else\n               j = i + 1;\n            for (k = j + n1 - 1; j < k; j++)\n            {  arc_ptr->from = j;\n               arc_ptr->to = j + direction;\n               arc_ptr++;\n            }\n            direction = - direction;\n         }\n         for (i = 1; i <= n1; i++)\n         {  j = i + n1;\n            if (direction == 1)\n            {  for (; j < n_node; j += n1)\n               {  arc_ptr->from = j - n1;\n                  arc_ptr->to = j;\n                  arc_ptr++;\n               }\n            }\n            else\n            {  for (; j < n_node; j += n1)\n               {  arc_ptr->from = j - n1;\n                  arc_ptr->to = j;\n                  arc_ptr++;\n               }\n            }\n            direction = - direction;\n         }\n      }\n      return arc_ptr;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "struct arcs",
        "struct",
        "arcs",
        "*gen_basic_grid(struct csa *csa, struct arcs\n      *arc_ptr)",
        "*"
      ]
    },
    "gen_more_arcs": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "static void gen_more_arcs(struct csa *csa, struct arcs *arc_ptr)\n{     /* Generate random arcs to meet the specified density. */\n      int i;\n      double ab[2];\n      ab[0] = 0.9;\n      ab[1] = n_node - 0.99;  /* upper limit is n_node-1 because the\n                                 supernode cannot be selected */\n      for (i = n_grid_arc; i < n_arc; i++, arc_ptr++)\n      {  arc_ptr->from = uniform(csa, ab);\n         arc_ptr->to = uniform(csa, ab);\n         if (arc_ptr->from == arc_ptr->to)\n         {  arc_ptr--;\n            i--;\n         }\n      }\n      return;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "generate": {
      "start_point": [
        571,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static void generate(struct csa *csa)\n{     /* Generate a random network. */\n      struct arcs *arc_ptr = arc_list;\n      arc_ptr = gen_basic_grid(csa, arc_ptr);\n      select_source_sinks(csa);\n      arc_ptr = gen_additional_arcs(csa, arc_ptr);\n      gen_more_arcs(csa, arc_ptr);\n      assign_costs(csa);\n      assign_capacities(csa);\n      assign_imbalance(csa);\n      return;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "static void output(struct csa *csa)\n{     /* Output the network in DIMACS format. */\n      struct arcs *arc_ptr;\n      struct imbalance *imb_ptr;\n      int i;\n      if (G != NULL) goto skip;\n      /* Output \"c\", \"p\" records. */\n      xprintf(\"c generated by GRIDGEN\\n\");\n      xprintf(\"c seed %d\\n\", seed_original);\n      xprintf(\"c nodes %d\\n\", n_node);\n      xprintf(\"c grid size %d X %d\\n\", n1, n2);\n      xprintf(\"c sources %d sinks %d\\n\", n_source, n_sink);\n      xprintf(\"c avg. degree %d\\n\", avg_degree);\n      xprintf(\"c supply %d\\n\", t_supply);\n      switch (arc_costs.distribution)\n      {  case UNIFORM:\n            xprintf(\"c arc costs: UNIFORM distr. min %d max %d\\n\",\n               (int)arc_costs.parameter[0],\n               (int)arc_costs.parameter[1]);\n            break;\n         case EXPONENTIAL:\n            xprintf(\"c arc costs: EXPONENTIAL distr. lambda %d\\n\",\n               (int)arc_costs.parameter[0]);\n            break;\n         default:\n            xassert(csa != csa);\n      }\n      switch (capacities.distribution)\n      {  case UNIFORM:\n            xprintf(\"c arc caps :  UNIFORM distr. min %d max %d\\n\",\n               (int)capacities.parameter[0],\n               (int)capacities.parameter[1]);\n            break;\n         case EXPONENTIAL:\n            xprintf(\"c arc caps :  EXPONENTIAL distr. %d lambda %d\\n\",\n               (int)capacities.parameter[0]);\n            break;\n         default:\n            xassert(csa != csa);\n      }\nskip: if (G == NULL)\n         xprintf(\"p min %d %d\\n\", n_node, n_arc);\n      else\n      {  glp_add_vertices(G, n_node);\n         if (v_rhs >= 0)\n         {  double zero = 0.0;\n            for (i = 1; i <= n_node; i++)\n            {  glp_vertex *v = G->v[i];\n               memcpy((char *)v->data + v_rhs, &zero, sizeof(double));\n            }\n         }\n      }\n      /* Output \"n node supply\". */\n      for (i = 0, imb_ptr = source_list; i < n_source; i++, imb_ptr++)\n      {  if (G == NULL)\n            xprintf(\"n %d %d\\n\", imb_ptr->node, imb_ptr->supply);\n         else\n         {  if (v_rhs >= 0)\n            {  double temp = (double)imb_ptr->supply;\n               glp_vertex *v = G->v[imb_ptr->node];\n               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));\n            }\n         }\n      }\n      for (i = 0, imb_ptr = sink_list; i < n_sink; i++, imb_ptr++)\n      {  if (G == NULL)\n            xprintf(\"n %d %d\\n\", imb_ptr->node, imb_ptr->supply);\n         else\n         {  if (v_rhs >= 0)\n            {  double temp = (double)imb_ptr->supply;\n               glp_vertex *v = G->v[imb_ptr->node];\n               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));\n            }\n         }\n      }\n      /* Output \"a from to lowcap=0 hicap cost\". */\n      for (i = 0, arc_ptr = arc_list; i < n_arc; i++, arc_ptr++)\n      {  if (G == NULL)\n            xprintf(\"a %d %d 0 %d %d\\n\", arc_ptr->from, arc_ptr->to,\n               arc_ptr->u, arc_ptr->cost);\n         else\n         {  glp_arc *a = glp_add_arc(G, arc_ptr->from, arc_ptr->to);\n            if (a_cap >= 0)\n            {  double temp = (double)arc_ptr->u;\n               memcpy((char *)a->data + a_cap, &temp, sizeof(double));\n            }\n            if (a_cost >= 0)\n            {  double temp = (double)arc_ptr->cost;\n               memcpy((char *)a->data + a_cost, &temp, sizeof(double));\n            }\n         }\n      }\n      return;\n}",
      "lines": 94,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "randy": {
      "start_point": [
        679,
        0
      ],
      "end_point": [
        686,
        1
      ],
      "content": "static double randy(struct csa *csa)\n{     /* Returns a random number between 0.0 and 1.0.\n         See Ward Cheney & David Kincaid, \"Numerical Mathematics and\n         Computing,\" 2Ed, pp. 335. */\n      seed = 16807 * seed % 2147483647;\n      if (seed < 0) seed = - seed;\n      return seed * 4.6566128752459e-10;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "select_source_sinks": {
      "start_point": [
        688,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static void select_source_sinks(struct csa *csa)\n{     /* Randomly select the source nodes and sink nodes. */\n      int i, *int_ptr;\n      int *temp_list;   /* a temporary list of nodes */\n      struct imbalance *ptr;\n      double ab[2];     /* parameter for random number generator */\n      ab[0] = 0.9;\n      ab[1] = n_node - 0.99;  /* upper limit is n_node-1 because the\n                                 supernode cannot be selected */\n      temp_list = xcalloc(n_node, sizeof(int));\n      for (i = 0, int_ptr = temp_list; i < n_node; i++, int_ptr++)\n         *int_ptr = 0;\n      /* Select the source nodes. */\n      for (i = 0, ptr = source_list; i < n_source; i++, ptr++)\n      {  ptr->node = uniform(csa, ab);\n         if (temp_list[ptr->node] == 1) /* check for duplicates */\n         {  ptr--;\n            i--;\n         }\n         else\n            temp_list[ptr->node] = 1;\n      }\n      /* Select the sink nodes. */\n      for (i = 0, ptr = sink_list; i < n_sink; i++, ptr++)\n      {  ptr->node = uniform(csa, ab);\n         if (temp_list[ptr->node] == 1)\n         {  ptr--;\n            i--;\n         }\n         else\n            temp_list[ptr->node] = 1;\n      }\n      xfree(temp_list);\n      return;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uniform": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "int uniform(struct csa *csa, double a[2])\n{     /* Generates an integer uniformly selected from [a[0],a[1]]. */\n      return (int)((a[1] - a[0]) * randy(csa) + a[0] + 0.5);\n}",
      "lines": 4,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        732,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "int main(void)\n{     int parm[1+14];\n      double temp;\n      scanf(\"%d\", &parm[1]);\n      scanf(\"%d\", &parm[2]);\n      scanf(\"%d\", &parm[3]);\n      scanf(\"%d\", &parm[4]);\n      scanf(\"%d\", &parm[5]);\n      scanf(\"%d\", &parm[6]);\n      scanf(\"%d\", &parm[7]);\n      scanf(\"%d\", &parm[8]);\n      scanf(\"%d\", &parm[9]);\n      if (parm[9] == 1)\n      {  scanf(\"%d\", &parm[10]);\n         scanf(\"%d\", &parm[11]);\n      }\n      else\n      {  scanf(\"%le\", &temp);\n         parm[10] = (int)(100.0 * temp + .5);\n         parm[11] = 0;\n      }\n      scanf(\"%d\", &parm[12]);\n      if (parm[12] == 1)\n      {  scanf(\"%d\", &parm[13]);\n         scanf(\"%d\", &parm[14]);\n      }\n      else\n      {  scanf(\"%le\", &temp);\n         parm[13] = (int)(100.0 * temp + .5);\n         parm[14] = 0;\n      }\n      glp_gridgen(NULL, 0, 0, 0, parm);\n      return 0;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/intfeas1.c": {
    "glp_intfeas1": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        266,
        9
      ],
      "content": "int glp_intfeas1(glp_prob *P, int use_bound, int obj_bound)\n{     /* solve integer feasibility problem */\n      NPP *npp = NULL;\n      glp_prob *mip = NULL;\n      int *obj_ind = NULL;\n      double *obj_val = NULL;\n      int obj_row = 0;\n      int i, j, k, obj_len, temp, ret;\n#if 0 /* 04/IV-2016 */\n      /* check the problem object */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_intfeas1: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (P->tree != NULL)\n         xerror(\"glp_intfeas1: operation not allowed\\n\");\n      /* integer solution is currently undefined */\n      P->mip_stat = GLP_UNDEF;\n      P->mip_obj = 0.0;\n      /* check columns (variables) */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n#if 0 /* binarization is not yet implemented */\n         if (!(col->kind == GLP_IV || col->type == GLP_FX))\n         {  xprintf(\"glp_intfeas1: column %d: non-integer non-fixed var\"\n               \"iable not allowed\\n\", j);\n#else\n         if (!((col->kind == GLP_IV && col->lb == 0.0 && col->ub == 1.0)\n            || col->type == GLP_FX))\n         {  xprintf(\"glp_intfeas1: column %d: non-binary non-fixed vari\"\n               \"able not allowed\\n\", j);\n#endif\n            ret = GLP_EDATA;\n            goto done;\n         }\n         temp = (int)col->lb;\n         if ((double)temp != col->lb)\n         {  if (col->type == GLP_FX)\n               xprintf(\"glp_intfeas1: column %d: fixed value %g is non-\"\n                  \"integer or out of range\\n\", j, col->lb);\n            else\n               xprintf(\"glp_intfeas1: column %d: lower bound %g is non-\"\n                  \"integer or out of range\\n\", j, col->lb);\n            ret = GLP_EDATA;\n            goto done;\n         }\n         temp = (int)col->ub;\n         if ((double)temp != col->ub)\n         {  xprintf(\"glp_intfeas1: column %d: upper bound %g is non-int\"\n               \"eger or out of range\\n\", j, col->ub);\n            ret = GLP_EDATA;\n            goto done;\n         }\n         if (col->type == GLP_DB && col->lb > col->ub)\n         {  xprintf(\"glp_intfeas1: column %d: lower bound %g is greater\"\n               \" than upper bound %g\\n\", j, col->lb, col->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      /* check rows (constraints) */\n      for (i = 1; i <= P->m; i++)\n      {  GLPROW *row = P->row[i];\n         GLPAIJ *aij;\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  temp = (int)aij->val;\n            if ((double)temp != aij->val)\n            {  xprintf(\"glp_intfeas1: row = %d, column %d: constraint c\"\n                  \"oefficient %g is non-integer or out of range\\n\",\n                  i, aij->col->j, aij->val);\n               ret = GLP_EDATA;\n               goto done;\n            }\n         }\n         temp = (int)row->lb;\n         if ((double)temp != row->lb)\n         {  if (row->type == GLP_FX)\n               xprintf(\"glp_intfeas1: row = %d: fixed value %g is non-i\"\n                  \"nteger or out of range\\n\", i, row->lb);\n            else\n               xprintf(\"glp_intfeas1: row = %d: lower bound %g is non-i\"\n                  \"nteger or out of range\\n\", i, row->lb);\n            ret = GLP_EDATA;\n            goto done;\n         }\n         temp = (int)row->ub;\n         if ((double)temp != row->ub)\n         {  xprintf(\"glp_intfeas1: row = %d: upper bound %g is non-inte\"\n               \"ger or out of range\\n\", i, row->ub);\n            ret = GLP_EDATA;\n            goto done;\n         }\n         if (row->type == GLP_DB && row->lb > row->ub)\n         {  xprintf(\"glp_intfeas1: row %d: lower bound %g is greater th\"\n               \"an upper bound %g\\n\", i, row->lb, row->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      /* check the objective function */\n#if 1 /* 08/I-2017 by cmatraki & mao */\n      if (!use_bound)\n      {  /* skip check if no obj. bound is specified */\n         goto skip;\n      }\n#endif\n      temp = (int)P->c0;\n      if ((double)temp != P->c0)\n      {  xprintf(\"glp_intfeas1: objective constant term %g is non-integ\"\n            \"er or out of range\\n\", P->c0);\n         ret = GLP_EDATA;\n         goto done;\n      }\n      for (j = 1; j <= P->n; j++)\n      {  temp = (int)P->col[j]->coef;\n         if ((double)temp != P->col[j]->coef)\n         {  xprintf(\"glp_intfeas1: column %d: objective coefficient is \"\n               \"non-integer or out of range\\n\", j, P->col[j]->coef);\n            ret = GLP_EDATA;\n            goto done;\n         }\n      }\n#if 1 /* 08/I-2017 by cmatraki & mao */\nskip: ;\n#endif\n      /* save the objective function and set it to zero */\n      obj_ind = xcalloc(1+P->n, sizeof(int));\n      obj_val = xcalloc(1+P->n, sizeof(double));\n      obj_len = 0;\n      obj_ind[0] = 0;\n      obj_val[0] = P->c0;\n      P->c0 = 0.0;\n      for (j = 1; j <= P->n; j++)\n      {  if (P->col[j]->coef != 0.0)\n         {  obj_len++;\n            obj_ind[obj_len] = j;\n            obj_val[obj_len] = P->col[j]->coef;\n            P->col[j]->coef = 0.0;\n         }\n      }\n      /* add inequality to bound the objective function, if required */\n      if (!use_bound)\n         xprintf(\"Will search for ANY feasible solution\\n\");\n      else\n      {  xprintf(\"Will search only for solution not worse than %d\\n\",\n            obj_bound);\n         obj_row = glp_add_rows(P, 1);\n         glp_set_mat_row(P, obj_row, obj_len, obj_ind, obj_val);\n         if (P->dir == GLP_MIN)\n            glp_set_row_bnds(P, obj_row,\n               GLP_UP, 0.0, (double)obj_bound - obj_val[0]);\n         else if (P->dir == GLP_MAX)\n            glp_set_row_bnds(P, obj_row,\n               GLP_LO, (double)obj_bound - obj_val[0], 0.0);\n         else\n            xassert(P != P);\n      }\n      /* create preprocessor workspace */\n      xprintf(\"Translating to CNF-SAT...\\n\");\n      xprintf(\"Original problem has %d row%s, %d column%s, and %d non-z\"\n         \"ero%s\\n\", P->m, P->m == 1 ? \"\" : \"s\", P->n, P->n == 1 ? \"\" :\n         \"s\", P->nnz, P->nnz == 1 ? \"\" : \"s\");\n      npp = npp_create_wksp();\n      /* load the original problem into the preprocessor workspace */\n      npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);\n      /* perform translation to SAT-CNF problem instance */\n      ret = npp_sat_encode_prob(npp);\n      if (ret == 0)\n         ;\n      else if (ret == GLP_ENOPFS)\n         xprintf(\"PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\\n\");\n      else if (ret == GLP_ERANGE)\n         xprintf(\"glp_intfeas1: translation to SAT-CNF failed because o\"\n            \"f integer overflow\\n\");\n      else\n         xassert(ret != ret);\n      if (ret != 0)\n         goto done;\n      /* build SAT-CNF problem instance and try to solve it */\n      mip = glp_create_prob();\n      npp_build_prob(npp, mip);\n      ret = glp_minisat1(mip);\n      /* only integer feasible solution can be postprocessed */\n      if (!(mip->mip_stat == GLP_OPT || mip->mip_stat == GLP_FEAS))\n      {  P->mip_stat = mip->mip_stat;\n         goto done;\n      }\n      /* postprocess the solution found */\n      npp_postprocess(npp, mip);\n      /* the transformed problem is no longer needed */\n      glp_delete_prob(mip), mip = NULL;\n      /* store solution to the original problem object */\n      npp_unload_sol(npp, P);\n      /* change the solution status to 'integer feasible' */\n      P->mip_stat = GLP_FEAS;\n      /* check integer feasibility */\n      for (i = 1; i <= P->m; i++)\n      {  GLPROW *row;\n         GLPAIJ *aij;\n         double sum;\n         row = P->row[i];\n         sum = 0.0;\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n            sum += aij->val * aij->col->mipx;\n         xassert(sum == row->mipx);\n         if (row->type == GLP_LO || row->type == GLP_DB ||\n             row->type == GLP_FX)\n            xassert(sum >= row->lb);\n         if (row->type == GLP_UP || row->type == GLP_DB ||\n             row->type == GLP_FX)\n            xassert(sum <= row->ub);\n      }\n      /* compute value of the original objective function */\n      P->mip_obj = obj_val[0];\n      for (k = 1; k <= obj_len; k++)\n         P->mip_obj += obj_val[k] * P->col[obj_ind[k]]->mipx;\n      xprintf(\"Objective value = %17.9e\\n\", P->mip_obj);\ndone: /* delete the transformed problem, if it exists */\n      if (mip != NULL)\n         glp_delete_prob(mip);\n      /* delete the preprocessor workspace, if it exists */\n      if (npp != NULL)\n         npp_delete_wksp(npp);\n      /* remove inequality used to bound the objective function */\n      if (obj_row > 0)\n      {  int ind[1+1];\n         ind[1] = obj_row;\n         glp_del_rows(P, 1, ind);\n      }\n      /* restore the original objective function */\n      if (obj_ind != NULL)\n      {  P->c0 = obj_val[0];\n         for (k = 1; k <= obj_len; k++)\n            P->col[obj_ind[k]]->coef = obj_val[k];\n         xfree(obj_ind);\n         xfree(obj_val);\n      }\n      return ret;\n}\n\n/* eof */",
      "lines": 241,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/maxffalg.c": {
    "glp_maxflow_ffalg": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int glp_maxflow_ffalg(glp_graph *G, int s, int t, int a_cap,\n      double *sol, int a_x, int v_cut)\n{     /* find maximal flow with Ford-Fulkerson algorithm */\n      glp_vertex *v;\n      glp_arc *a;\n      int nv, na, i, k, flag, *tail, *head, *cap, *x, ret;\n      char *cut;\n      double temp;\n      if (!(1 <= s && s <= G->nv))\n         xerror(\"glp_maxflow_ffalg: s = %d; source node number out of r\"\n            \"ange\\n\", s);\n      if (!(1 <= t && t <= G->nv))\n         xerror(\"glp_maxflow_ffalg: t = %d: sink node number out of ran\"\n            \"ge\\n\", t);\n      if (s == t)\n         xerror(\"glp_maxflow_ffalg: s = t = %d; source and sink nodes m\"\n            \"ust be distinct\\n\", s);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_maxflow_ffalg: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      if (v_cut >= 0 && v_cut > G->v_size - (int)sizeof(int))\n         xerror(\"glp_maxflow_ffalg: v_cut = %d; invalid offset\\n\",\n            v_cut);\n      /* allocate working arrays */\n      nv = G->nv;\n      na = G->na;\n      tail = xcalloc(1+na, sizeof(int));\n      head = xcalloc(1+na, sizeof(int));\n      cap = xcalloc(1+na, sizeof(int));\n      x = xcalloc(1+na, sizeof(int));\n      if (v_cut < 0)\n         cut = NULL;\n      else\n         cut = xcalloc(1+nv, sizeof(char));\n      /* copy the flow network */\n      k = 0;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  k++;\n            tail[k] = a->tail->i;\n            head[k] = a->head->i;\n            if (tail[k] == head[k])\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            if (a_cap >= 0)\n               memcpy(&temp, (char *)a->data + a_cap, sizeof(double));\n            else\n               temp = 1.0;\n            if (!(0.0 <= temp && temp <= (double)INT_MAX &&\n                  temp == floor(temp)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            cap[k] = (int)temp;\n         }\n      }\n      xassert(k == na);\n      /* find maximal flow in the flow network */\n      ffalg(nv, na, tail, head, s, t, cap, x, cut);\n      ret = 0;\n      /* store solution components */\n      /* (objective function = total flow through the network) */\n      if (sol != NULL)\n      {  temp = 0.0;\n         for (k = 1; k <= na; k++)\n         {  if (tail[k] == s)\n               temp += (double)x[k];\n            else if (head[k] == s)\n               temp -= (double)x[k];\n         }\n         *sol = temp;\n      }\n      /* (arc flows) */\n      if (a_x >= 0)\n      {  k = 0;\n         for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            for (a = v->out; a != NULL; a = a->t_next)\n            {  temp = (double)x[++k];\n               memcpy((char *)a->data + a_x, &temp, sizeof(double));\n            }\n         }\n      }\n      /* (node flags) */\n      if (v_cut >= 0)\n      {  for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            flag = cut[i];\n            memcpy((char *)v->data + v_cut, &flag, sizeof(int));\n         }\n      }\ndone: /* free working arrays */\n      xfree(tail);\n      xfree(head);\n      xfree(cap);\n      xfree(x);\n      if (cut != NULL) xfree(cut);\n      return ret;\n}",
      "lines": 101,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/maxflp.c": {
    "glp_maxflow_lp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void glp_maxflow_lp(glp_prob *lp, glp_graph *G, int names, int s,\n      int t, int a_cap)\n{     glp_vertex *v;\n      glp_arc *a;\n      int i, j, type, ind[1+2];\n      double cap, val[1+2];\n      if (!(names == GLP_ON || names == GLP_OFF))\n         xerror(\"glp_maxflow_lp: names = %d; invalid parameter\\n\",\n            names);\n      if (!(1 <= s && s <= G->nv))\n         xerror(\"glp_maxflow_lp: s = %d; source node number out of rang\"\n            \"e\\n\", s);\n      if (!(1 <= t && t <= G->nv))\n         xerror(\"glp_maxflow_lp: t = %d: sink node number out of range \"\n            \"\\n\", t);\n      if (s == t)\n         xerror(\"glp_maxflow_lp: s = t = %d; source and sink nodes must\"\n            \" be distinct\\n\", s);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_maxflow_lp: a_cap = %d; invalid offset\\n\", a_cap);\n      glp_erase_prob(lp);\n      if (names) glp_set_prob_name(lp, G->name);\n      glp_set_obj_dir(lp, GLP_MAX);\n      glp_add_rows(lp, G->nv);\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (names) glp_set_row_name(lp, i, v->name);\n         if (i == s)\n            type = GLP_LO;\n         else if (i == t)\n            type = GLP_UP;\n         else\n            type = GLP_FX;\n         glp_set_row_bnds(lp, i, type, 0.0, 0.0);\n      }\n      if (G->na > 0) glp_add_cols(lp, G->na);\n      for (i = 1, j = 0; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  j++;\n            if (names)\n            {  char name[50+1];\n               sprintf(name, \"x[%d,%d]\", a->tail->i, a->head->i);\n               xassert(strlen(name) < sizeof(name));\n               glp_set_col_name(lp, j, name);\n            }\n            if (a->tail->i != a->head->i)\n            {  ind[1] = a->tail->i, val[1] = +1.0;\n               ind[2] = a->head->i, val[2] = -1.0;\n               glp_set_mat_col(lp, j, 2, ind, val);\n            }\n            if (a_cap >= 0)\n               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));\n            else\n               cap = 1.0;\n            if (cap == DBL_MAX)\n               type = GLP_LO;\n            else if (cap != 0.0)\n               type = GLP_DB;\n            else\n               type = GLP_FX;\n            glp_set_col_bnds(lp, j, type, 0.0, cap);\n            if (a->tail->i == s)\n               glp_set_obj_coef(lp, j, +1.0);\n            else if (a->head->i == s)\n               glp_set_obj_coef(lp, j, -1.0);\n         }\n      }\n      xassert(j == G->na);\n      return;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/mcflp.c": {
    "glp_mincost_lp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void glp_mincost_lp(glp_prob *lp, glp_graph *G, int names, int v_rhs,\n      int a_low, int a_cap, int a_cost)\n{     glp_vertex *v;\n      glp_arc *a;\n      int i, j, type, ind[1+2];\n      double rhs, low, cap, cost, val[1+2];\n      if (!(names == GLP_ON || names == GLP_OFF))\n         xerror(\"glp_mincost_lp: names = %d; invalid parameter\\n\",\n            names);\n      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n         xerror(\"glp_mincost_lp: v_rhs = %d; invalid offset\\n\", v_rhs);\n      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_lp: a_low = %d; invalid offset\\n\", a_low);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_lp: a_cap = %d; invalid offset\\n\", a_cap);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_lp: a_cost = %d; invalid offset\\n\", a_cost)\n            ;\n      glp_erase_prob(lp);\n      if (names) glp_set_prob_name(lp, G->name);\n      if (G->nv > 0) glp_add_rows(lp, G->nv);\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (names) glp_set_row_name(lp, i, v->name);\n         if (v_rhs >= 0)\n            memcpy(&rhs, (char *)v->data + v_rhs, sizeof(double));\n         else\n            rhs = 0.0;\n         glp_set_row_bnds(lp, i, GLP_FX, rhs, rhs);\n      }\n      if (G->na > 0) glp_add_cols(lp, G->na);\n      for (i = 1, j = 0; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  j++;\n            if (names)\n            {  char name[50+1];\n               sprintf(name, \"x[%d,%d]\", a->tail->i, a->head->i);\n               xassert(strlen(name) < sizeof(name));\n               glp_set_col_name(lp, j, name);\n            }\n            if (a->tail->i != a->head->i)\n            {  ind[1] = a->tail->i, val[1] = +1.0;\n               ind[2] = a->head->i, val[2] = -1.0;\n               glp_set_mat_col(lp, j, 2, ind, val);\n            }\n            if (a_low >= 0)\n               memcpy(&low, (char *)a->data + a_low, sizeof(double));\n            else\n               low = 0.0;\n            if (a_cap >= 0)\n               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));\n            else\n               cap = 1.0;\n            if (cap == DBL_MAX)\n               type = GLP_LO;\n            else if (low != cap)\n               type = GLP_DB;\n            else\n               type = GLP_FX;\n            glp_set_col_bnds(lp, j, type, low, cap);\n            if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 0.0;\n            glp_set_obj_coef(lp, j, cost);\n         }\n      }\n      xassert(j == G->na);\n      return;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/mcfokalg.c": {
    "glp_mincost_okalg": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int glp_mincost_okalg(glp_graph *G, int v_rhs, int a_low, int a_cap,\n      int a_cost, double *sol, int a_x, int v_pi)\n{     /* find minimum-cost flow with out-of-kilter algorithm */\n      glp_vertex *v;\n      glp_arc *a;\n      int nv, na, i, k, s, t, *tail, *head, *low, *cap, *cost, *x, *pi,\n         ret;\n      double sum, temp;\n      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: v_rhs = %d; invalid offset\\n\",\n            v_rhs);\n      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: a_low = %d; invalid offset\\n\",\n            a_low);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: a_x = %d; invalid offset\\n\", a_x);\n      if (v_pi >= 0 && v_pi > G->v_size - (int)sizeof(double))\n         xerror(\"glp_mincost_okalg: v_pi = %d; invalid offset\\n\", v_pi);\n      /* s is artificial source node */\n      s = G->nv + 1;\n      /* t is artificial sink node */\n      t = s + 1;\n      /* nv is the total number of nodes in the resulting network */\n      nv = t;\n      /* na is the total number of arcs in the resulting network */\n      na = G->na + 1;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (v_rhs >= 0)\n            memcpy(&temp, (char *)v->data + v_rhs, sizeof(double));\n         else\n            temp = 0.0;\n         if (temp != 0.0) na++;\n      }\n      /* allocate working arrays */\n      tail = xcalloc(1+na, sizeof(int));\n      head = xcalloc(1+na, sizeof(int));\n      low = xcalloc(1+na, sizeof(int));\n      cap = xcalloc(1+na, sizeof(int));\n      cost = xcalloc(1+na, sizeof(int));\n      x = xcalloc(1+na, sizeof(int));\n      pi = xcalloc(1+nv, sizeof(int));\n      /* construct the resulting network */\n      k = 0;\n      /* (original arcs) */\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  k++;\n            tail[k] = a->tail->i;\n            head[k] = a->head->i;\n            if (tail[k] == head[k])\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            if (a_low >= 0)\n               memcpy(&temp, (char *)a->data + a_low, sizeof(double));\n            else\n               temp = 0.0;\n            if (!(0.0 <= temp && temp <= (double)INT_MAX &&\n                  temp == floor(temp)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            low[k] = (int)temp;\n            if (a_cap >= 0)\n               memcpy(&temp, (char *)a->data + a_cap, sizeof(double));\n            else\n               temp = 1.0;\n            if (!((double)low[k] <= temp && temp <= (double)INT_MAX &&\n                  temp == floor(temp)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            cap[k] = (int)temp;\n            if (a_cost >= 0)\n               memcpy(&temp, (char *)a->data + a_cost, sizeof(double));\n            else\n               temp = 0.0;\n            if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            cost[k] = (int)temp;\n         }\n      }\n      /* (artificial arcs) */\n      sum = 0.0;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (v_rhs >= 0)\n            memcpy(&temp, (char *)v->data + v_rhs, sizeof(double));\n         else\n            temp = 0.0;\n         if (!(fabs(temp) <= (double)INT_MAX && temp == floor(temp)))\n         {  ret = GLP_EDATA;\n            goto done;\n         }\n         if (temp > 0.0)\n         {  /* artificial arc from s to original source i */\n            k++;\n            tail[k] = s;\n            head[k] = i;\n            low[k] = cap[k] = (int)(+temp); /* supply */\n            cost[k] = 0;\n            sum += (double)temp;\n         }\n         else if (temp < 0.0)\n         {  /* artificial arc from original sink i to t */\n            k++;\n            tail[k] = i;\n            head[k] = t;\n            low[k] = cap[k] = (int)(-temp); /* demand */\n            cost[k] = 0;\n         }\n      }\n      /* (feedback arc from t to s) */\n      k++;\n      xassert(k == na);\n      tail[k] = t;\n      head[k] = s;\n      if (sum > (double)INT_MAX)\n      {  ret = GLP_EDATA;\n         goto done;\n      }\n      low[k] = cap[k] = (int)sum; /* total supply/demand */\n      cost[k] = 0;\n      /* find minimal-cost circulation in the resulting network */\n      ret = okalg(nv, na, tail, head, low, cap, cost, x, pi);\n      switch (ret)\n      {  case 0:\n            /* optimal circulation found */\n            ret = 0;\n            break;\n         case 1:\n            /* no feasible circulation exists */\n            ret = GLP_ENOPFS;\n            break;\n         case 2:\n            /* integer overflow occured */\n            ret = GLP_ERANGE;\n            goto done;\n         case 3:\n            /* optimality test failed (logic error) */\n            ret = GLP_EFAIL;\n            goto done;\n         default:\n            xassert(ret != ret);\n      }\n      /* store solution components */\n      /* (objective function = the total cost) */\n      if (sol != NULL)\n      {  temp = 0.0;\n         for (k = 1; k <= na; k++)\n            temp += (double)cost[k] * (double)x[k];\n         *sol = temp;\n      }\n      /* (arc flows) */\n      if (a_x >= 0)\n      {  k = 0;\n         for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            for (a = v->out; a != NULL; a = a->t_next)\n            {  temp = (double)x[++k];\n               memcpy((char *)a->data + a_x, &temp, sizeof(double));\n            }\n         }\n      }\n      /* (node potentials = Lagrange multipliers) */\n      if (v_pi >= 0)\n      {  for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            temp = - (double)pi[i];\n            memcpy((char *)v->data + v_pi, &temp, sizeof(double));\n         }\n      }\ndone: /* free working arrays */\n      xfree(tail);\n      xfree(head);\n      xfree(low);\n      xfree(cap);\n      xfree(cost);\n      xfree(x);\n      xfree(pi);\n      return ret;\n}",
      "lines": 192,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/mcfrelax.c": {
    "overflow": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static int overflow(int u, int v)\n{     /* check for integer overflow on computing u + v */\n      if (u > 0 && v > 0 && u + v < 0) return 1;\n      if (u < 0 && v < 0 && u + v > 0) return 1;\n      return 0;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_mincost_relax4": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "int glp_mincost_relax4(glp_graph *G, int v_rhs, int a_low, int a_cap,\n      int a_cost, int crash, double *sol, int a_x, int a_rc)\n{     /* find minimum-cost flow with Bertsekas-Tseng relaxation method\n         (RELAX-IV) */\n      glp_vertex *v;\n      glp_arc *a;\n      struct relax4_csa csa;\n      int i, k, large, n, na, ret;\n      double cap, cost, low, rc, rhs, sum, x;\n      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: v_rhs = %d; invalid offset\\n\",\n            v_rhs);\n      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: a_low = %d; invalid offset\\n\",\n            a_low);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      if (a_x >= 0 && a_x > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: a_x = %d; invalid offset\\n\",\n            a_x);\n      if (a_rc >= 0 && a_rc > G->a_size - (int)sizeof(double))\n         xerror(\"glp_mincost_relax4: a_rc = %d; invalid offset\\n\",\n            a_rc);\n      csa.n = n = G->nv; /* number of nodes */\n      csa.na = na = G->na; /* number of arcs */\n      csa.large = large = INT_MAX / 4;\n      csa.repeat = 0;\n      csa.crash = crash;\n      /* allocate working arrays */\n      csa.startn = xcalloc(1+na, sizeof(int));\n      csa.endn = xcalloc(1+na, sizeof(int));\n      csa.fou = xcalloc(1+n, sizeof(int));\n      csa.nxtou = xcalloc(1+na, sizeof(int));\n      csa.fin = xcalloc(1+n, sizeof(int));\n      csa.nxtin = xcalloc(1+na, sizeof(int));\n      csa.rc = xcalloc(1+na, sizeof(int));\n      csa.u = xcalloc(1+na, sizeof(int));\n      csa.dfct = xcalloc(1+n, sizeof(int));\n      csa.x = xcalloc(1+na, sizeof(int));\n      csa.label = xcalloc(1+n, sizeof(int));\n      csa.prdcsr = xcalloc(1+n, sizeof(int));\n      csa.save = xcalloc(1+na, sizeof(int));\n      csa.tfstou = xcalloc(1+n, sizeof(int));\n      csa.tnxtou = xcalloc(1+na, sizeof(int));\n      csa.tfstin = xcalloc(1+n, sizeof(int));\n      csa.tnxtin = xcalloc(1+na, sizeof(int));\n      csa.nxtqueue = xcalloc(1+n, sizeof(int));\n      csa.scan = xcalloc(1+n, sizeof(char));\n      csa.mark = xcalloc(1+n, sizeof(char));\n      if (crash)\n      {  csa.extend_arc = xcalloc(1+n, sizeof(int));\n         csa.sb_level = xcalloc(1+n, sizeof(int));\n         csa.sb_arc = xcalloc(1+n, sizeof(int));\n      }\n      else\n      {  csa.extend_arc = NULL;\n         csa.sb_level = NULL;\n         csa.sb_arc = NULL;\n      }\n      /* scan nodes */\n      for (i = 1; i <= n; i++)\n      {  v = G->v[i];\n         /* get supply at i-th node */\n         if (v_rhs >= 0)\n            memcpy(&rhs, (char *)v->data + v_rhs, sizeof(double));\n         else\n            rhs = 0.0;\n         if (!(fabs(rhs) <= (double)large && rhs == floor(rhs)))\n         {  ret = GLP_EDATA;\n            goto done;\n         }\n         /* set demand at i-th node */\n         csa.dfct[i] = -(int)rhs;\n      }\n      /* scan arcs */\n      k = 0;\n      for (i = 1; i <= n; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  k++;\n            /* set endpoints of k-th arc */\n            if (a->tail->i == a->head->i)\n            {  /* self-loops not allowed */\n               ret = GLP_EDATA;\n               goto done;\n            }\n            csa.startn[k] = a->tail->i;\n            csa.endn[k] = a->head->i;\n            /* set per-unit cost for k-th arc flow */\n            if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 0.0;\n            if (!(fabs(cost) <= (double)large && cost == floor(cost)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            csa.rc[k] = (int)cost;\n            /* get lower bound for k-th arc flow */\n            if (a_low >= 0)\n               memcpy(&low, (char *)a->data + a_low, sizeof(double));\n            else\n               low = 0.0;\n            if (!(0.0 <= low && low <= (double)large &&\n                  low == floor(low)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            /* get upper bound for k-th arc flow */\n            if (a_cap >= 0)\n               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));\n            else\n               cap = 1.0;\n            if (!(low <= cap && cap <= (double)large &&\n                  cap == floor(cap)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            /* substitute x = x' + low, where 0 <= x' <= cap - low */\n            csa.u[k] = (int)(cap - low);\n            /* correct demands at endpoints of k-th arc */\n            if (overflow(csa.dfct[a->tail->i], +low))\n            {  ret = GLP_ERANGE;\n               goto done;\n            }\n#if 0 /* 29/IX-2017 */\n            csa.dfct[a->tail->i] += low;\n#else\n            csa.dfct[a->tail->i] += (int)low;\n#endif\n            if (overflow(csa.dfct[a->head->i], -low))\n            {  ret = GLP_ERANGE;\n               goto done;\n            }\n#if 0 /* 29/IX-2017 */\n            csa.dfct[a->head->i] -= low;\n#else\n            csa.dfct[a->head->i] -= (int)low;\n#endif\n         }\n      }\n      /* construct linked list for network topology */\n      relax4_inidat(&csa);\n      /* find minimum-cost flow */\n      ret = relax4(&csa);\n      if (ret != 0)\n      {  /* problem is found to be infeasible */\n         xassert(1 <= ret && ret <= 8);\n         ret = GLP_ENOPFS;\n         goto done;\n      }\n      /* store solution */\n      sum = 0.0;\n      k = 0;\n      for (i = 1; i <= n; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  k++;\n            /* get lower bound for k-th arc flow */\n            if (a_low >= 0)\n               memcpy(&low, (char *)a->data + a_low, sizeof(double));\n            else\n               low = 0.0;\n            /* store original flow x = x' + low thru k-th arc */\n            x = (double)csa.x[k] + low;\n            if (a_x >= 0)\n               memcpy((char *)a->data + a_x, &x, sizeof(double));\n            /* store reduced cost for k-th arc flow */\n            rc = (double)csa.rc[k];\n            if (a_rc >= 0)\n               memcpy((char *)a->data + a_rc, &rc, sizeof(double));\n            /* get per-unit cost for k-th arc flow */\n            if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 0.0;\n            /* compute the total cost */\n            sum += cost * x;\n         }\n      }\n      /* store the total cost */\n      if (sol != NULL)\n         *sol = sum;\ndone: /* free working arrays */\n      xfree(csa.startn);\n      xfree(csa.endn);\n      xfree(csa.fou);\n      xfree(csa.nxtou);\n      xfree(csa.fin);\n      xfree(csa.nxtin);\n      xfree(csa.rc);\n      xfree(csa.u);\n      xfree(csa.dfct);\n      xfree(csa.x);\n      xfree(csa.label);\n      xfree(csa.prdcsr);\n      xfree(csa.save);\n      xfree(csa.tfstou);\n      xfree(csa.tnxtou);\n      xfree(csa.tfstin);\n      xfree(csa.tnxtin);\n      xfree(csa.nxtqueue);\n      xfree(csa.scan);\n      xfree(csa.mark);\n      if (crash)\n      {  xfree(csa.extend_arc);\n         xfree(csa.sb_level);\n         xfree(csa.sb_arc);\n      }\n      return ret;\n}",
      "lines": 215,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/minisat1.c": {
    "glp_minisat1": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int glp_minisat1(glp_prob *P)\n{     /* solve CNF-SAT problem with MiniSat solver */\n      solver *s;\n      GLPAIJ *aij;\n      int i, j, len, ret, *ind;\n      double sum;\n#if 0 /* 04/IV-2016 */\n      /* check problem object */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_minisat1: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (P->tree != NULL)\n         xerror(\"glp_minisat1: operation not allowed\\n\");\n      /* integer solution is currently undefined */\n      P->mip_stat = GLP_UNDEF;\n      P->mip_obj = 0.0;\n      /* check that problem object encodes CNF-SAT instance */\n      if (glp_check_cnfsat(P) != 0)\n      {  xprintf(\"glp_minisat1: problem object does not encode CNF-SAT \"\n            \"instance\\n\");\n         ret = GLP_EDATA;\n         goto done;\n      }\n#if 0 /* 08/I-2017 by cmatraki */\n#if 1 /* 07/XI-2015 */\n      if (sizeof(void *) != sizeof(int))\n      {  xprintf(\"glp_minisat1: sorry, MiniSat solver is not supported \"\n            \"on 64-bit platforms\\n\");\n         ret = GLP_EFAIL;\n         goto done;\n      }\n#endif\n#else\n      if (sizeof(void *) != sizeof(size_t))\n      {  xprintf(\"glp_minisat1: sorry, MiniSat solver is not supported \"\n            \"on this platform\\n\");\n         ret = GLP_EFAIL;\n         goto done;\n      }\n#endif\n      /* solve CNF-SAT problem */\n      xprintf(\"Solving CNF-SAT problem...\\n\");\n      xprintf(\"Instance has %d variable%s, %d clause%s, and %d literal%\"\n         \"s\\n\", P->n, P->n == 1 ? \"\" : \"s\", P->m, P->m == 1 ? \"\" : \"s\",\n         P->nnz, P->nnz == 1 ? \"\" : \"s\");\n      /* if CNF-SAT has no clauses, it is satisfiable */\n      if (P->m == 0)\n      {  P->mip_stat = GLP_OPT;\n         for (j = 1; j <= P->n; j++)\n            P->col[j]->mipx = 0.0;\n         goto fini;\n      }\n      /* if CNF-SAT has an empty clause, it is unsatisfiable */\n      for (i = 1; i <= P->m; i++)\n      {  if (P->row[i]->ptr == NULL)\n         {  P->mip_stat = GLP_NOFEAS;\n            goto fini;\n         }\n      }\n      /* prepare input data for the solver */\n      s = solver_new();\n      solver_setnvars(s, P->n);\n      ind = xcalloc(1+P->n, sizeof(int));\n      for (i = 1; i <= P->m; i++)\n      {  len = 0;\n         for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  ind[++len] = toLit(aij->col->j-1);\n            if (aij->val < 0.0)\n               ind[len] = lit_neg(ind[len]);\n         }\n         xassert(len > 0);\n#if 0 /* 08/I-2017 by cmatraki */\n         xassert(solver_addclause(s, &ind[1], &ind[1+len]));\n#else\n         if (!solver_addclause(s, &ind[1], &ind[1+len]))\n         {  /* found trivial conflict */\n            xfree(ind);\n            solver_delete(s);\n            P->mip_stat = GLP_NOFEAS;\n            goto fini;\n         }\n#endif\n      }\n      xfree(ind);\n      /* call the solver */\n      s->verbosity = 1;\n      if (solver_solve(s, 0, 0))\n      {  /* instance is reported as satisfiable */\n         P->mip_stat = GLP_OPT;\n         /* copy solution to the problem object */\n         xassert(s->model.size == P->n);\n         for (j = 1; j <= P->n; j++)\n         {  P->col[j]->mipx =\n               s->model.ptr[j-1] == l_True ? 1.0 : 0.0;\n         }\n         /* compute row values */\n         for (i = 1; i <= P->m; i++)\n         {  sum = 0;\n            for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)\n               sum += aij->val * aij->col->mipx;\n            P->row[i]->mipx = sum;\n         }\n         /* check integer feasibility */\n         for (i = 1; i <= P->m; i++)\n         {  if (P->row[i]->mipx < P->row[i]->lb)\n            {  /* solution is wrong */\n               P->mip_stat = GLP_UNDEF;\n               break;\n            }\n         }\n      }\n      else\n      {  /* instance is reported as unsatisfiable */\n         P->mip_stat = GLP_NOFEAS;\n      }\n      solver_delete(s);\nfini: /* report the instance status */\n      if (P->mip_stat == GLP_OPT)\n      {  xprintf(\"SATISFIABLE\\n\");\n         ret = 0;\n      }\n      else if (P->mip_stat == GLP_NOFEAS)\n      {  xprintf(\"UNSATISFIABLE\\n\");\n         ret = 0;\n      }\n      else\n      {  xprintf(\"glp_minisat1: solver failed\\n\");\n         ret = GLP_EFAIL;\n      }\ndone: return ret;\n}",
      "lines": 132,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/mpl.c": {
    "glp_mpl_alloc_wksp": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "glp_tran *glp_mpl_alloc_wksp(void)\n{     /* allocate the MathProg translator workspace */\n      glp_tran *tran;\n      tran = mpl_initialize();\n      return tran;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "glp_tran",
        "*glp_mpl_alloc_wksp(void)",
        "*"
      ]
    },
    "glp_mpl_init_rand": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void glp_mpl_init_rand(glp_tran *tran, int seed)\n{     /* initialize pseudo-random number generator */\n      if (tran->phase != 0)\n         xerror(\"glp_mpl_init_rand: invalid call sequence\\n\");\n      rng_init_rand(tran->rand, seed);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_mpl_read_model": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int glp_mpl_read_model(glp_tran *tran, const char *fname, int skip)\n{     /* read and translate model section */\n      int ret;\n      if (tran->phase != 0)\n         xerror(\"glp_mpl_read_model: invalid call sequence\\n\");\n      ret = mpl_read_model(tran, (char *)fname, skip);\n      if (ret == 1 || ret == 2)\n         ret = 0;\n      else if (ret == 4)\n         ret = 1;\n      else\n         xassert(ret != ret);\n      return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_mpl_read_data": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int glp_mpl_read_data(glp_tran *tran, const char *fname)\n{     /* read and translate data section */\n      int ret;\n      if (!(tran->phase == 1 || tran->phase == 2))\n         xerror(\"glp_mpl_read_data: invalid call sequence\\n\");\n      ret = mpl_read_data(tran, (char *)fname);\n      if (ret == 2)\n         ret = 0;\n      else if (ret == 4)\n         ret = 1;\n      else\n         xassert(ret != ret);\n      return ret;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_mpl_generate": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int glp_mpl_generate(glp_tran *tran, const char *fname)\n{     /* generate the model */\n      int ret;\n      if (!(tran->phase == 1 || tran->phase == 2))\n         xerror(\"glp_mpl_generate: invalid call sequence\\n\");\n      ret = mpl_generate(tran, (char *)fname);\n      if (ret == 3)\n         ret = 0;\n      else if (ret == 4)\n         ret = 1;\n      return ret;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_mpl_build_prob": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void glp_mpl_build_prob(glp_tran *tran, glp_prob *prob)\n{     /* build LP/MIP problem instance from the model */\n      int m, n, i, j, t, kind, type, len, *ind;\n      double lb, ub, *val;\n      if (tran->phase != 3)\n         xerror(\"glp_mpl_build_prob: invalid call sequence\\n\");\n      /* erase the problem object */\n      glp_erase_prob(prob);\n      /* set problem name */\n      glp_set_prob_name(prob, mpl_get_prob_name(tran));\n      /* build rows (constraints) */\n      m = mpl_get_num_rows(tran);\n      if (m > 0)\n         glp_add_rows(prob, m);\n      for (i = 1; i <= m; i++)\n      {  /* set row name */\n         glp_set_row_name(prob, i, mpl_get_row_name(tran, i));\n         /* set row bounds */\n         type = mpl_get_row_bnds(tran, i, &lb, &ub);\n         switch (type)\n         {  case MPL_FR: type = GLP_FR; break;\n            case MPL_LO: type = GLP_LO; break;\n            case MPL_UP: type = GLP_UP; break;\n            case MPL_DB: type = GLP_DB; break;\n            case MPL_FX: type = GLP_FX; break;\n            default: xassert(type != type);\n         }\n         if (type == GLP_DB && fabs(lb - ub) < 1e-9 * (1.0 + fabs(lb)))\n         {  type = GLP_FX;\n            if (fabs(lb) <= fabs(ub)) ub = lb; else lb = ub;\n         }\n         glp_set_row_bnds(prob, i, type, lb, ub);\n         /* warn about non-zero constant term */\n         if (mpl_get_row_c0(tran, i) != 0.0)\n            xprintf(\"glp_mpl_build_prob: row %s; constant term %.12g ig\"\n               \"nored\\n\",\n               mpl_get_row_name(tran, i), mpl_get_row_c0(tran, i));\n      }\n      /* build columns (variables) */\n      n = mpl_get_num_cols(tran);\n      if (n > 0)\n         glp_add_cols(prob, n);\n      for (j = 1; j <= n; j++)\n      {  /* set column name */\n         glp_set_col_name(prob, j, mpl_get_col_name(tran, j));\n         /* set column kind */\n         kind = mpl_get_col_kind(tran, j);\n         switch (kind)\n         {  case MPL_NUM:\n               break;\n            case MPL_INT:\n            case MPL_BIN:\n               glp_set_col_kind(prob, j, GLP_IV);\n               break;\n            default:\n               xassert(kind != kind);\n         }\n         /* set column bounds */\n         type = mpl_get_col_bnds(tran, j, &lb, &ub);\n         switch (type)\n         {  case MPL_FR: type = GLP_FR; break;\n            case MPL_LO: type = GLP_LO; break;\n            case MPL_UP: type = GLP_UP; break;\n            case MPL_DB: type = GLP_DB; break;\n            case MPL_FX: type = GLP_FX; break;\n            default: xassert(type != type);\n         }\n         if (kind == MPL_BIN)\n         {  if (type == GLP_FR || type == GLP_UP || lb < 0.0) lb = 0.0;\n            if (type == GLP_FR || type == GLP_LO || ub > 1.0) ub = 1.0;\n            type = GLP_DB;\n         }\n         if (type == GLP_DB && fabs(lb - ub) < 1e-9 * (1.0 + fabs(lb)))\n         {  type = GLP_FX;\n            if (fabs(lb) <= fabs(ub)) ub = lb; else lb = ub;\n         }\n         glp_set_col_bnds(prob, j, type, lb, ub);\n      }\n      /* load the constraint matrix */\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      for (i = 1; i <= m; i++)\n      {  len = mpl_get_mat_row(tran, i, ind, val);\n         glp_set_mat_row(prob, i, len, ind, val);\n      }\n      /* build objective function (the first objective is used) */\n      for (i = 1; i <= m; i++)\n      {  kind = mpl_get_row_kind(tran, i);\n         if (kind == MPL_MIN || kind == MPL_MAX)\n         {  /* set objective name */\n            glp_set_obj_name(prob, mpl_get_row_name(tran, i));\n            /* set optimization direction */\n            glp_set_obj_dir(prob, kind == MPL_MIN ? GLP_MIN : GLP_MAX);\n            /* set constant term */\n            glp_set_obj_coef(prob, 0, mpl_get_row_c0(tran, i));\n            /* set objective coefficients */\n            len = mpl_get_mat_row(tran, i, ind, val);\n            for (t = 1; t <= len; t++)\n               glp_set_obj_coef(prob, ind[t], val[t]);\n            break;\n         }\n      }\n      /* free working arrays */\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_mpl_postsolve": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "int glp_mpl_postsolve(glp_tran *tran, glp_prob *prob, int sol)\n{     /* postsolve the model */\n      int i, j, m, n, stat, ret;\n      double prim, dual;\n      if (!(tran->phase == 3 && !tran->flag_p))\n         xerror(\"glp_mpl_postsolve: invalid call sequence\\n\");\n      if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\n         xerror(\"glp_mpl_postsolve: sol = %d; invalid parameter\\n\",\n            sol);\n      m = mpl_get_num_rows(tran);\n      n = mpl_get_num_cols(tran);\n      if (!(m == glp_get_num_rows(prob) &&\n            n == glp_get_num_cols(prob)))\n         xerror(\"glp_mpl_postsolve: wrong problem object\\n\");\n      if (!mpl_has_solve_stmt(tran))\n      {  ret = 0;\n         goto done;\n      }\n      for (i = 1; i <= m; i++)\n      {  if (sol == GLP_SOL)\n         {  stat = glp_get_row_stat(prob, i);\n            prim = glp_get_row_prim(prob, i);\n            dual = glp_get_row_dual(prob, i);\n         }\n         else if (sol == GLP_IPT)\n         {  stat = 0;\n            prim = glp_ipt_row_prim(prob, i);\n            dual = glp_ipt_row_dual(prob, i);\n         }\n         else if (sol == GLP_MIP)\n         {  stat = 0;\n            prim = glp_mip_row_val(prob, i);\n            dual = 0.0;\n         }\n         else\n            xassert(sol != sol);\n         if (fabs(prim) < 1e-9) prim = 0.0;\n         if (fabs(dual) < 1e-9) dual = 0.0;\n         mpl_put_row_soln(tran, i, stat, prim, dual);\n      }\n      for (j = 1; j <= n; j++)\n      {  if (sol == GLP_SOL)\n         {  stat = glp_get_col_stat(prob, j);\n            prim = glp_get_col_prim(prob, j);\n            dual = glp_get_col_dual(prob, j);\n         }\n         else if (sol == GLP_IPT)\n         {  stat = 0;\n            prim = glp_ipt_col_prim(prob, j);\n            dual = glp_ipt_col_dual(prob, j);\n         }\n         else if (sol == GLP_MIP)\n         {  stat = 0;\n            prim = glp_mip_col_val(prob, j);\n            dual = 0.0;\n         }\n         else\n            xassert(sol != sol);\n         if (fabs(prim) < 1e-9) prim = 0.0;\n         if (fabs(dual) < 1e-9) dual = 0.0;\n         mpl_put_col_soln(tran, j, stat, prim, dual);\n      }\n      ret = mpl_postsolve(tran);\n      if (ret == 3)\n         ret = 0;\n      else if (ret == 4)\n         ret = 1;\ndone: return ret;\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_mpl_free_wksp": {
      "start_point": [
        262,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void glp_mpl_free_wksp(glp_tran *tran)\n{     /* free the MathProg translator workspace */\n      mpl_terminate(tran);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/mps.c": {
    "glp_init_mpscp": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void glp_init_mpscp(glp_mpscp *parm)\n{     parm->blank = '\\0';\n      parm->obj_name = NULL;\n      parm->tol_mps = 1e-12;\n      return;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "check_parm": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void check_parm(const char *func, const glp_mpscp *parm)\n{     /* check control parameters */\n      if (!(0x00 <= parm->blank && parm->blank <= 0xFF) ||\n          !(parm->blank == '\\0' || isprint(parm->blank)))\n         xerror(\"%s: blank = 0x%02X; invalid parameter\\n\",\n            func, parm->blank);\n      if (!(parm->obj_name == NULL || strlen(parm->obj_name) <= 255))\n         xerror(\"%s: obj_name = \\\"%.12s...\\\"; parameter too long\\n\",\n            func, parm->obj_name);\n      if (!(0.0 <= parm->tol_mps && parm->tol_mps < 1.0))\n         xerror(\"%s: tol_mps = %g; invalid parameter\\n\",\n            func, parm->tol_mps);\n      return;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "static void error(struct csa *csa, const char *fmt, ...)\n{     /* print error message and terminate processing */\n      va_list arg;\n      xprintf(\"%s:%d: \", csa->fname, csa->recno);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      longjmp(csa->jump, 1);\n      /* no return */\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "warning": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static void warning(struct csa *csa, const char *fmt, ...)\n{     /* print warning message and continue processing */\n      va_list arg;\n      xprintf(\"%s:%d: warning: \", csa->fname, csa->recno);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_char": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static void read_char(struct csa *csa)\n{     /* read next character */\n      int c;\n      if (csa->c == '\\n')\n         csa->recno++, csa->recpos = 0;\n      csa->recpos++;\nread: c = glp_getc(csa->fp);\n      if (c < 0)\n      {  if (glp_ioerr(csa->fp))\n            error(csa, \"read error - %s\\n\", get_err_msg());\n         else if (csa->c == '\\n')\n            error(csa, \"unexpected end of file\\n\");\n         else\n         {  warning(csa, \"missing final end of line\\n\");\n            c = '\\n';\n         }\n      }\n      else if (c == '\\n')\n         ;\n      else if (csa->c == '\\r')\n      {  c = '\\r';\n         goto badc;\n      }\n      else if (csa->deck && c == '\\r')\n      {  csa->c = '\\r';\n         goto read;\n      }\n      else if (c == ' ')\n         ;\n      else if (isspace(c))\n      {  if (csa->deck)\nbadc:       error(csa, \"in fixed MPS format white-space character 0x%02\"\n               \"X is not allowed\\n\", c);\n         c = ' ';\n      }\n      else if (iscntrl(c))\n         error(csa, \"invalid control character 0x%02X\\n\", c);\n      if (csa->deck && csa->recpos == 81 && c != '\\n' && csa->w80 < 1)\n      {  warning(csa, \"in fixed MPS format record must not be longer th\"\n            \"an 80 characters\\n\");\n         csa->w80++;\n      }\n      csa->c = c;\n      return;\n}",
      "lines": 45,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "indicator": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static int indicator(struct csa *csa, int name)\n{     /* skip comment records and read possible indicator record */\n      int ret;\n      /* reset current field number */\n      csa->fldno = 0;\nloop: /* read the very first character of the next record */\n      xassert(csa->c == '\\n');\n      read_char(csa);\n      if (csa->c == ' ' || csa->c == '\\n')\n      {  /* data record */\n         ret = 0;\n      }\n      else if (csa->c == '*')\n      {  /* comment record */\n         while (csa->c != '\\n')\n            read_char(csa);\n         goto loop;\n      }\n      else\n      {  /* indicator record */\n         int len = 0;\n         while (csa->c != ' ' && csa->c != '\\n' && len < 12)\n         {  csa->field[len++] = (char)csa->c;\n            read_char(csa);\n         }\n         csa->field[len] = '\\0';\n         if (!(strcmp(csa->field, \"NAME\")    == 0 ||\n               strcmp(csa->field, \"ROWS\")    == 0 ||\n               strcmp(csa->field, \"COLUMNS\") == 0 ||\n               strcmp(csa->field, \"RHS\")     == 0 ||\n               strcmp(csa->field, \"RANGES\")  == 0 ||\n               strcmp(csa->field, \"BOUNDS\")  == 0 ||\n               strcmp(csa->field, \"ENDATA\")  == 0))\n            error(csa, \"invalid indicator record\\n\");\n         if (!name)\n         {  while (csa->c != '\\n')\n               read_char(csa);\n         }\n         ret = 1;\n      }\n      return ret;\n}",
      "lines": 42,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_field": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static void read_field(struct csa *csa)\n{     /* read next field of the current data record */\n      csa->fldno++;\n      if (csa->deck)\n      {  /* fixed MPS format */\n         int beg, end, pos;\n         /* determine predefined field positions */\n         if (csa->fldno == 1)\n            beg = 2, end = 3;\n         else if (csa->fldno == 2)\n            beg = 5, end = 12;\n         else if (csa->fldno == 3)\n            beg = 15, end = 22;\n         else if (csa->fldno == 4)\n            beg = 25, end = 36;\n         else if (csa->fldno == 5)\n            beg = 40, end = 47;\n         else if (csa->fldno == 6)\n            beg = 50, end = 61;\n         else\n            xassert(csa != csa);\n         /* skip blanks preceding the current field */\n         if (csa->c != '\\n')\n         {  pos = csa->recpos;\n            while (csa->recpos < beg)\n            {  if (csa->c == ' ')\n                  ;\n               else if (csa->c == '\\n')\n                  break;\n               else\n                  error(csa, \"in fixed MPS format positions %d-%d must \"\n                     \"be blank\\n\", pos, beg-1);\n               read_char(csa);\n            }\n         }\n         /* skip possible comment beginning in the field 3 or 5 */\n         if ((csa->fldno == 3 || csa->fldno == 5) && csa->c == '$')\n         {  while (csa->c != '\\n')\n               read_char(csa);\n         }\n         /* read the current field */\n         for (pos = beg; pos <= end; pos++)\n         {  if (csa->c == '\\n') break;\n            csa->field[pos-beg] = (char)csa->c;\n            read_char(csa);\n         }\n         csa->field[pos-beg] = '\\0';\n         strtrim(csa->field);\n         /* skip blanks following the last field */\n         if (csa->fldno == 6 && csa->c != '\\n')\n         {  while (csa->recpos <= 72)\n            {  if (csa->c == ' ')\n                  ;\n               else if (csa->c == '\\n')\n                  break;\n               else\n                  error(csa, \"in fixed MPS format positions 62-72 must \"\n                     \"be blank\\n\");\n               read_char(csa);\n            }\n            while (csa->c != '\\n')\n               read_char(csa);\n         }\n      }\n      else\n      {  /* free MPS format */\n         int len;\n         /* skip blanks preceding the current field */\n         while (csa->c == ' ')\n            read_char(csa);\n         /* skip possible comment */\n         if (csa->c == '$')\n         {  while (csa->c != '\\n')\n               read_char(csa);\n         }\n         /* read the current field */\n         len = 0;\n         while (!(csa->c == ' ' || csa->c == '\\n'))\n         {  if (len == 255)\n               error(csa, \"length of field %d exceeds 255 characters\\n\",\n                  csa->fldno++);\n            csa->field[len++] = (char)csa->c;\n            read_char(csa);\n         }\n         csa->field[len] = '\\0';\n         /* skip anything following the last field (any extra fields\n            are considered to be comments) */\n         if (csa->fldno == 6)\n         {  while (csa->c == ' ')\n               read_char(csa);\n            if (csa->c != '$' && csa->c != '\\n' && csa->wef < 1)\n            {  warning(csa, \"some extra field(s) detected beyond field \"\n                  \"6; field(s) ignored\\n\");\n               csa->wef++;\n            }\n            while (csa->c != '\\n')\n               read_char(csa);\n         }\n      }\n      return;\n}",
      "lines": 101,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "patch_name": {
      "start_point": [
        350,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "static void patch_name(struct csa *csa, char *name)\n{     /* process embedded blanks in symbolic name */\n      int blank = csa->parm->blank;\n      if (blank == '\\0')\n      {  /* remove emedded blanks */\n         strspx(name);\n      }\n      else\n      {  /* replace embedded blanks by specified character */\n         for (; *name != '\\0'; name++)\n            if (*name == ' ') *name = (char)blank;\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_number": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        381,
        1
      ],
      "content": "static double read_number(struct csa *csa)\n{     /* read next field and convert it to floating-point number */\n      double x;\n      char *s;\n      /* read next field */\n      read_field(csa);\n      xassert(csa->fldno == 4 || csa->fldno == 6);\n      if (csa->field[0] == '\\0')\n         error(csa, \"missing numeric value in field %d\\n\", csa->fldno);\n      /* skip initial spaces of the field */\n      for (s = csa->field; *s == ' '; s++);\n      /* perform conversion */\n      if (str2num(s, &x) != 0)\n         error(csa, \"cannot convert '%s' to floating-point number\\n\",\n            s);\n      return x;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "skip_field": {
      "start_point": [
        383,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static void skip_field(struct csa *csa)\n{     /* read and skip next field (assumed to be blank) */\n      read_field(csa);\n      if (csa->field[0] != '\\0')\n         error(csa, \"field %d must be blank\\n\", csa->fldno);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_name": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static void read_name(struct csa *csa)\n{     /* read NAME indicator record */\n      if (!(indicator(csa, 1) && strcmp(csa->field, \"NAME\") == 0))\n         error(csa, \"missing NAME indicator record\\n\");\n      /* this indicator record looks like a data record; simulate that\n         fields 1 and 2 were read */\n      csa->fldno = 2;\n      /* field 3: model name */\n      read_field(csa), patch_name(csa, csa->field);\n      if (csa->field[0] == '\\0')\n         warning(csa, \"missing model name in field 3\\n\");\n      else\n         glp_set_prob_name(csa->P, csa->field);\n      /* skip anything following field 3 */\n      while (csa->c != '\\n')\n         read_char(csa);\n      return;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_rows": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "static void read_rows(struct csa *csa)\n{     /* read ROWS section */\n      int i, type;\nloop: if (indicator(csa, 0)) goto done;\n      /* field 1: row type */\n      read_field(csa), strspx(csa->field);\n      if (strcmp(csa->field, \"N\") == 0)\n         type = GLP_FR;\n      else if (strcmp(csa->field, \"G\") == 0)\n         type = GLP_LO;\n      else if (strcmp(csa->field, \"L\") == 0)\n         type = GLP_UP;\n      else if (strcmp(csa->field, \"E\") == 0)\n         type = GLP_FX;\n      else if (csa->field[0] == '\\0')\n         error(csa, \"missing row type in field 1\\n\");\n      else\n         error(csa, \"invalid row type in field 1\\n\");\n      /* field 2: row name */\n      read_field(csa), patch_name(csa, csa->field);\n      if (csa->field[0] == '\\0')\n         error(csa, \"missing row name in field 2\\n\");\n      if (glp_find_row(csa->P, csa->field) != 0)\n         error(csa, \"row '%s' multiply specified\\n\", csa->field);\n      i = glp_add_rows(csa->P, 1);\n      glp_set_row_name(csa->P, i, csa->field);\n      glp_set_row_bnds(csa->P, i, type, 0.0, 0.0);\n      /* fields 3, 4, 5, and 6 must be blank */\n      skip_field(csa);\n      skip_field(csa);\n      skip_field(csa);\n      skip_field(csa);\n      goto loop;\ndone: return;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_columns": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void read_columns(struct csa *csa)\n{     /* read COLUMNS section */\n      int i, j, f, len, kind = GLP_CV, *ind;\n      double aij, *val;\n      char name[255+1], *flag;\n      /* allocate working arrays */\n      csa->work1 = ind = xcalloc(1+csa->P->m, sizeof(int));\n      csa->work2 = val = xcalloc(1+csa->P->m, sizeof(double));\n      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));\n      memset(&flag[1], 0, csa->P->m);\n      /* no current column exists */\n      j = 0, len = 0;\nloop: if (indicator(csa, 0)) goto done;\n      /* field 1 must be blank */\n      if (csa->deck)\n      {  read_field(csa);\n         if (csa->field[0] != '\\0')\n            error(csa, \"field 1 must be blank\\n\");\n      }\n      else\n         csa->fldno++;\n      /* field 2: column or kind name */\n      read_field(csa), patch_name(csa, csa->field);\n      strcpy(name, csa->field);\n      /* field 3: row name or keyword 'MARKER' */\n      read_field(csa), patch_name(csa, csa->field);\n      if (strcmp(csa->field, \"'MARKER'\") == 0)\n      {  /* process kind data record */\n         /* field 4 must be blank */\n         if (csa->deck)\n         {  read_field(csa);\n            if (csa->field[0] != '\\0')\n               error(csa, \"field 4 must be blank\\n\");\n         }\n         else\n            csa->fldno++;\n         /* field 5: keyword 'INTORG' or 'INTEND' */\n         read_field(csa), patch_name(csa, csa->field);\n         if (strcmp(csa->field, \"'INTORG'\") == 0)\n            kind = GLP_IV;\n         else if (strcmp(csa->field, \"'INTEND'\") == 0)\n            kind = GLP_CV;\n         else if (csa->field[0] == '\\0')\n            error(csa, \"missing keyword in field 5\\n\");\n         else\n            error(csa, \"invalid keyword in field 5\\n\");\n         /* field 6 must be blank */\n         skip_field(csa);\n         goto loop;\n      }\n      /* process column name specified in field 2 */\n      if (name[0] == '\\0')\n      {  /* the same column as in previous data record */\n         if (j == 0)\n            error(csa, \"missing column name in field 2\\n\");\n      }\n      else if (j != 0 && strcmp(name, csa->P->col[j]->name) == 0)\n      {  /* the same column as in previous data record */\n         xassert(j != 0);\n      }\n      else\n      {  /* store the current column */\n         if (j != 0)\n         {  glp_set_mat_col(csa->P, j, len, ind, val);\n            while (len > 0) flag[ind[len--]] = 0;\n         }\n         /* create new column */\n         if (glp_find_col(csa->P, name) != 0)\n            error(csa, \"column '%s' multiply specified\\n\", name);\n         j = glp_add_cols(csa->P, 1);\n         glp_set_col_name(csa->P, j, name);\n         glp_set_col_kind(csa->P, j, kind);\n         if (kind == GLP_CV)\n            glp_set_col_bnds(csa->P, j, GLP_LO, 0.0, 0.0);\n         else if (kind == GLP_IV)\n            glp_set_col_bnds(csa->P, j, GLP_DB, 0.0, 1.0);\n         else\n            xassert(kind != kind);\n      }\n      /* process fields 3-4 and 5-6 */\n      for (f = 3; f <= 5; f += 2)\n      {  /* field 3 or 5: row name */\n         if (f == 3)\n         {  if (csa->field[0] == '\\0')\n               error(csa, \"missing row name in field 3\\n\");\n         }\n         else\n         {  read_field(csa), patch_name(csa, csa->field);\n            if (csa->field[0] == '\\0')\n            {  /* if field 5 is blank, field 6 also must be blank */\n               skip_field(csa);\n               continue;\n            }\n         }\n         i = glp_find_row(csa->P, csa->field);\n         if (i == 0)\n            error(csa, \"row '%s' not found\\n\", csa->field);\n         if (flag[i])\n            error(csa, \"duplicate coefficient in row '%s'\\n\",\n               csa->field);\n         /* field 4 or 6: coefficient value */\n         aij = read_number(csa);\n         if (fabs(aij) < csa->parm->tol_mps) aij = 0.0;\n         len++, ind[len] = i, val[len] = aij, flag[i] = 1;\n      }\n      goto loop;\ndone: /* store the last column */\n      if (j != 0)\n         glp_set_mat_col(csa->P, j, len, ind, val);\n      /* free working arrays */\n      xfree(ind);\n      xfree(val);\n      xfree(flag);\n      csa->work1 = csa->work2 = csa->work3 = NULL;\n      return;\n}",
      "lines": 116,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_rhs": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "static void read_rhs(struct csa *csa)\n{     /* read RHS section */\n      int i, f, v, type;\n      double rhs;\n      char name[255+1], *flag;\n      /* allocate working array */\n      csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));\n      memset(&flag[1], 0, csa->P->m);\n      /* no current RHS vector exists */\n      v = 0;\nloop: if (indicator(csa, 0)) goto done;\n      /* field 1 must be blank */\n      if (csa->deck)\n      {  read_field(csa);\n         if (csa->field[0] != '\\0')\n            error(csa, \"field 1 must be blank\\n\");\n      }\n      else\n         csa->fldno++;\n      /* field 2: RHS vector name */\n      read_field(csa), patch_name(csa, csa->field);\n      if (csa->field[0] == '\\0')\n      {  /* the same RHS vector as in previous data record */\n         if (v == 0)\n         {  warning(csa, \"missing RHS vector name in field 2\\n\");\n            goto blnk;\n         }\n      }\n      else if (v != 0 && strcmp(csa->field, name) == 0)\n      {  /* the same RHS vector as in previous data record */\n         xassert(v != 0);\n      }\n      else\nblnk: {  /* new RHS vector */\n         if (v != 0)\n            error(csa, \"multiple RHS vectors not supported\\n\");\n         v++;\n         strcpy(name, csa->field);\n      }\n      /* process fields 3-4 and 5-6 */\n      for (f = 3; f <= 5; f += 2)\n      {  /* field 3 or 5: row name */\n         read_field(csa), patch_name(csa, csa->field);\n         if (csa->field[0] == '\\0')\n         {  if (f == 3)\n               error(csa, \"missing row name in field 3\\n\");\n            else\n            {  /* if field 5 is blank, field 6 also must be blank */\n               skip_field(csa);\n               continue;\n            }\n         }\n         i = glp_find_row(csa->P, csa->field);\n         if (i == 0)\n            error(csa, \"row '%s' not found\\n\", csa->field);\n         if (flag[i])\n            error(csa, \"duplicate right-hand side for row '%s'\\n\",\n               csa->field);\n         /* field 4 or 6: right-hand side value */\n         rhs = read_number(csa);\n         if (fabs(rhs) < csa->parm->tol_mps) rhs = 0.0;\n         type = csa->P->row[i]->type;\n         if (type == GLP_FR)\n         {  if (i == csa->obj_row)\n               glp_set_obj_coef(csa->P, 0, rhs);\n            else if (rhs != 0.0)\n               warning(csa, \"non-zero right-hand side for free row '%s'\"\n                  \" ignored\\n\", csa->P->row[i]->name);\n         }\n         else\n            glp_set_row_bnds(csa->P, i, type, rhs, rhs);\n         flag[i] = 1;\n      }\n      goto loop;\ndone: /* free working array */\n      xfree(flag);\n      csa->work3 = NULL;\n      return;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_bounds": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "static void read_bounds(struct csa *csa)\n{     /* read BOUNDS section */\n      GLPCOL *col;\n      int j, v, mask, data;\n      double bnd, lb, ub;\n      char type[2+1], name[255+1], *flag;\n      /* allocate working array */\n      csa->work3 = flag = xcalloc(1+csa->P->n, sizeof(char));\n      memset(&flag[1], 0, csa->P->n);\n      /* no current BOUNDS vector exists */\n      v = 0;\nloop: if (indicator(csa, 0)) goto done;\n      /* field 1: bound type */\n      read_field(csa);\n      if (strcmp(csa->field, \"LO\") == 0)\n         mask = 0x01, data = 1;\n      else if (strcmp(csa->field, \"UP\") == 0)\n         mask = 0x10, data = 1;\n      else if (strcmp(csa->field, \"FX\") == 0)\n         mask = 0x11, data = 1;\n      else if (strcmp(csa->field, \"FR\") == 0)\n         mask = 0x11, data = 0;\n      else if (strcmp(csa->field, \"MI\") == 0)\n         mask = 0x01, data = 0;\n      else if (strcmp(csa->field, \"PL\") == 0)\n         mask = 0x10, data = 0;\n      else if (strcmp(csa->field, \"LI\") == 0)\n         mask = 0x01, data = 1;\n      else if (strcmp(csa->field, \"UI\") == 0)\n         mask = 0x10, data = 1;\n      else if (strcmp(csa->field, \"BV\") == 0)\n         mask = 0x11, data = 0;\n      else if (csa->field[0] == '\\0')\n         error(csa, \"missing bound type in field 1\\n\");\n      else\n         error(csa, \"invalid bound type in field 1\\n\");\n      strcpy(type, csa->field);\n      /* field 2: BOUNDS vector name */\n      read_field(csa), patch_name(csa, csa->field);\n      if (csa->field[0] == '\\0')\n      {  /* the same BOUNDS vector as in previous data record */\n         if (v == 0)\n         {  warning(csa, \"missing BOUNDS vector name in field 2\\n\");\n            goto blnk;\n         }\n      }\n      else if (v != 0 && strcmp(csa->field, name) == 0)\n      {  /* the same BOUNDS vector as in previous data record */\n         xassert(v != 0);\n      }\n      else\nblnk: {  /* new BOUNDS vector */\n         if (v != 0)\n            error(csa, \"multiple BOUNDS vectors not supported\\n\");\n         v++;\n         strcpy(name, csa->field);\n      }\n      /* field 3: column name */\n      read_field(csa), patch_name(csa, csa->field);\n      if (csa->field[0] == '\\0')\n         error(csa, \"missing column name in field 3\\n\");\n      j = glp_find_col(csa->P, csa->field);\n      if (j == 0)\n         error(csa, \"column '%s' not found\\n\", csa->field);\n      if ((flag[j] & mask) == 0x01)\n         error(csa, \"duplicate lower bound for column '%s'\\n\",\n            csa->field);\n      if ((flag[j] & mask) == 0x10)\n         error(csa, \"duplicate upper bound for column '%s'\\n\",\n            csa->field);\n      xassert((flag[j] & mask) == 0x00);\n      /* field 4: bound value */\n      if (data)\n      {  bnd = read_number(csa);\n         if (fabs(bnd) < csa->parm->tol_mps) bnd = 0.0;\n      }\n      else\n         read_field(csa), bnd = 0.0;\n      /* get current column bounds */\n      col = csa->P->col[j];\n      if (col->type == GLP_FR)\n         lb = -DBL_MAX, ub = +DBL_MAX;\n      else if (col->type == GLP_LO)\n         lb = col->lb, ub = +DBL_MAX;\n      else if (col->type == GLP_UP)\n         lb = -DBL_MAX, ub = col->ub;\n      else if (col->type == GLP_DB)\n         lb = col->lb, ub = col->ub;\n      else if (col->type == GLP_FX)\n         lb = ub = col->lb;\n      else\n         xassert(col != col);\n      /* change column bounds */\n      if (strcmp(type, \"LO\") == 0)\n         lb = bnd;\n      else if (strcmp(type, \"UP\") == 0)\n         ub = bnd;\n      else if (strcmp(type, \"FX\") == 0)\n         lb = ub = bnd;\n      else if (strcmp(type, \"FR\") == 0)\n         lb = -DBL_MAX, ub = +DBL_MAX;\n      else if (strcmp(type, \"MI\") == 0)\n         lb = -DBL_MAX;\n      else if (strcmp(type, \"PL\") == 0)\n         ub = +DBL_MAX;\n      else if (strcmp(type, \"LI\") == 0)\n      {  glp_set_col_kind(csa->P, j, GLP_IV);\n         lb = ceil(bnd);\n#if 1 /* 16/VII-2013 */\n         /* if column upper bound has not been explicitly specified,\n            take it as +inf */\n         if (!(flag[j] & 0x10))\n            ub = +DBL_MAX;\n#endif\n      }\n      else if (strcmp(type, \"UI\") == 0)\n      {  glp_set_col_kind(csa->P, j, GLP_IV);\n         ub = floor(bnd);\n      }\n      else if (strcmp(type, \"BV\") == 0)\n      {  glp_set_col_kind(csa->P, j, GLP_IV);\n         lb = 0.0, ub = 1.0;\n      }\n      else\n         xassert(type != type);\n      /* set new column bounds */\n      if (lb == -DBL_MAX && ub == +DBL_MAX)\n         glp_set_col_bnds(csa->P, j, GLP_FR, lb, ub);\n      else if (ub == +DBL_MAX)\n         glp_set_col_bnds(csa->P, j, GLP_LO, lb, ub);\n      else if (lb == -DBL_MAX)\n         glp_set_col_bnds(csa->P, j, GLP_UP, lb, ub);\n      else if (lb != ub)\n         glp_set_col_bnds(csa->P, j, GLP_DB, lb, ub);\n      else\n         glp_set_col_bnds(csa->P, j, GLP_FX, lb, ub);\n      flag[j] |= (char)mask;\n      /* fields 5 and 6 must be blank */\n      skip_field(csa);\n      skip_field(csa);\n      goto loop;\ndone: /* free working array */\n      xfree(flag);\n      csa->work3 = NULL;\n      return;\n}",
      "lines": 146,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_read_mps": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        1060,
        1
      ],
      "content": "int glp_read_mps(glp_prob *P, int fmt, const glp_mpscp *parm,\n      const char *fname)\n{     /* read problem data in MPS format */\n      glp_mpscp _parm;\n      struct csa _csa, *csa = &_csa;\n      int ret;\n      xprintf(\"Reading problem data from '%s'...\\n\", fname);\n      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))\n         xerror(\"glp_read_mps: fmt = %d; invalid parameter\\n\", fmt);\n      if (parm == NULL)\n         glp_init_mpscp(&_parm), parm = &_parm;\n      /* check control parameters */\n      check_parm(\"glp_read_mps\", parm);\n      /* initialize common storage area */\n      csa->P = P;\n      csa->deck = (fmt == GLP_MPS_DECK);\n      csa->parm = parm;\n      csa->fname = fname;\n      csa->fp = NULL;\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->recno = csa->recpos = 0;\n      csa->c = '\\n';\n      csa->fldno = 0;\n      csa->field[0] = '\\0';\n      csa->w80 = csa->wef = 0;\n      csa->obj_row = 0;\n      csa->work1 = csa->work2 = csa->work3 = NULL;\n      /* erase problem object */\n      glp_erase_prob(P);\n      glp_create_index(P);\n      /* open input MPS file */\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* read NAME indicator record */\n      read_name(csa);\n      if (P->name != NULL)\n         xprintf(\"Problem: %s\\n\", P->name);\n      /* read ROWS section */\n      if (!(indicator(csa, 0) && strcmp(csa->field, \"ROWS\") == 0))\n         error(csa, \"missing ROWS indicator record\\n\");\n      read_rows(csa);\n      /* determine objective row */\n      if (parm->obj_name == NULL || parm->obj_name[0] == '\\0')\n      {  /* use the first row of N type */\n         int i;\n         for (i = 1; i <= P->m; i++)\n         {  if (P->row[i]->type == GLP_FR)\n            {  csa->obj_row = i;\n               break;\n            }\n         }\n         if (csa->obj_row == 0)\n            warning(csa, \"unable to determine objective row\\n\");\n      }\n      else\n      {  /* use a row with specified name */\n         int i;\n         for (i = 1; i <= P->m; i++)\n         {  xassert(P->row[i]->name != NULL);\n            if (strcmp(parm->obj_name, P->row[i]->name) == 0)\n            {  csa->obj_row = i;\n               break;\n            }\n         }\n         if (csa->obj_row == 0)\n            error(csa, \"objective row '%s' not found\\n\",\n               parm->obj_name);\n      }\n      if (csa->obj_row != 0)\n      {  glp_set_obj_name(P, P->row[csa->obj_row]->name);\n         xprintf(\"Objective: %s\\n\", P->obj);\n      }\n      /* read COLUMNS section */\n      if (strcmp(csa->field, \"COLUMNS\") != 0)\n         error(csa, \"missing COLUMNS indicator record\\n\");\n      read_columns(csa);\n      /* set objective coefficients */\n      if (csa->obj_row != 0)\n      {  GLPAIJ *aij;\n         for (aij = P->row[csa->obj_row]->ptr; aij != NULL; aij =\n            aij->r_next) glp_set_obj_coef(P, aij->col->j, aij->val);\n      }\n      /* read optional RHS section */\n      if (strcmp(csa->field, \"RHS\") == 0)\n         read_rhs(csa);\n      /* read optional RANGES section */\n      if (strcmp(csa->field, \"RANGES\") == 0)\n         read_ranges(csa);\n      /* read optional BOUNDS section */\n      if (strcmp(csa->field, \"BOUNDS\") == 0)\n         read_bounds(csa);\n      /* read ENDATA indicator record */\n      if (strcmp(csa->field, \"ENDATA\") != 0)\n         error(csa, \"invalid use of %s indicator record\\n\",\n            csa->field);\n      /* print some statistics */\n      xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n         P->m, P->m == 1 ? \"\" : \"s\", P->n, P->n == 1 ? \"\" : \"s\",\n         P->nnz, P->nnz == 1 ? \"\" : \"s\");\n      if (glp_get_num_int(P) > 0)\n      {  int ni = glp_get_num_int(P);\n         int nb = glp_get_num_bin(P);\n         if (ni == 1)\n         {  if (nb == 0)\n               xprintf(\"One variable is integer\\n\");\n            else\n               xprintf(\"One variable is binary\\n\");\n         }\n         else\n         {  xprintf(\"%d integer variables, \", ni);\n            if (nb == 0)\n               xprintf(\"none\");\n            else if (nb == 1)\n               xprintf(\"one\");\n            else if (nb == ni)\n               xprintf(\"all\");\n            else\n               xprintf(\"%d\", nb);\n            xprintf(\" of which %s binary\\n\", nb == 1 ? \"is\" : \"are\");\n         }\n      }\n      xprintf(\"%d records were read\\n\", csa->recno);\n#if 1 /* 31/III-2016 */\n      /* free (unbounded) row(s) in MPS file are intended to specify\n       * objective function(s), so all such rows can be removed */\n#if 1 /* 08/VIII-2013 */\n      /* remove free rows */\n      {  int i, nrs, *num;\n         num = talloc(1+P->m, int);\n         nrs = 0;\n         for (i = 1; i <= P->m; i++)\n         {  if (P->row[i]->type == GLP_FR)\n               num[++nrs] = i;\n         }\n         if (nrs > 0)\n         {  glp_del_rows(P, nrs, num);\n            if (nrs == 1)\n               xprintf(\"One free row was removed\\n\");\n            else\n               xprintf(\"%d free rows were removed\\n\", nrs);\n         }\n         tfree(num);\n      }\n#endif\n#else\n      /* if objective function row is free, remove it */\n      if (csa->obj_row != 0 && P->row[csa->obj_row]->type == GLP_FR)\n      {  int num[1+1];\n         num[1] = csa->obj_row;\n         glp_del_rows(P, 1, num);\n         xprintf(\"Free objective row was removed\\n\");\n      }\n#endif\n      /* problem data has been successfully read */\n      glp_delete_index(P);\n      glp_sort_matrix(P);\n      ret = 0;\ndone: if (csa->fp != NULL) glp_close(csa->fp);\n      if (csa->work1 != NULL) xfree(csa->work1);\n      if (csa->work2 != NULL) xfree(csa->work2);\n      if (csa->work3 != NULL) xfree(csa->work3);\n      if (ret != 0) glp_erase_prob(P);\n      return ret;\n}",
      "lines": 171,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "mps_name": {
      "start_point": [
        1108,
        0
      ],
      "end_point": [
        1122,
        1
      ],
      "content": "static char *mps_name(struct csa *csa)\n{     /* make problem name */\n      char *f;\n      if (csa->P->name == NULL)\n         csa->field[0] = '\\0';\n      else if (csa->deck)\n      {  strncpy(csa->field, csa->P->name, 8);\n         csa->field[8] = '\\0';\n      }\n      else\n         strcpy(csa->field, csa->P->name);\n      for (f = csa->field; *f != '\\0'; f++)\n         if (*f == ' ') *f = '_';\n      return csa->field;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*mps_name(struct csa *csa)",
        "*"
      ]
    },
    "row_name": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1137,
        1
      ],
      "content": "static char *row_name(struct csa *csa, int i)\n{     /* make i-th row name */\n      char *f;\n      xassert(0 <= i && i <= csa->P->m);\n      if (i == 0 || csa->P->row[i]->name == NULL ||\n          csa->deck && strlen(csa->P->row[i]->name) > 8)\n         sprintf(csa->field, \"R%07d\", i);\n      else\n      {  strcpy(csa->field, csa->P->row[i]->name);\n         for (f = csa->field; *f != '\\0'; f++)\n            if (*f == ' ') *f = '_';\n      }\n      return csa->field;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*row_name(struct csa *csa, int i)",
        "*"
      ]
    },
    "col_name": {
      "start_point": [
        1139,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "static char *col_name(struct csa *csa, int j)\n{     /* make j-th column name */\n      char *f;\n      xassert(1 <= j && j <= csa->P->n);\n      if (csa->P->col[j]->name == NULL ||\n          csa->deck && strlen(csa->P->col[j]->name) > 8)\n         sprintf(csa->field, \"C%07d\", j);\n      else\n      {  strcpy(csa->field, csa->P->col[j]->name);\n         for (f = csa->field; *f != '\\0'; f++)\n            if (*f == ' ') *f = '_';\n      }\n      return csa->field;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*col_name(struct csa *csa, int j)",
        "*"
      ]
    },
    "mps_numb": {
      "start_point": [
        1154,
        0
      ],
      "end_point": [
        1170,
        1
      ],
      "content": "static char *mps_numb(struct csa *csa, double val)\n{     /* format floating-point number */\n      int dig;\n      char *exp;\n      for (dig = 12; dig >= 6; dig--)\n      {  if (val != 0.0 && fabs(val) < 0.002)\n            sprintf(csa->field, \"%.*E\", dig-1, val);\n         else\n            sprintf(csa->field, \"%.*G\", dig, val);\n         exp = strchr(csa->field, 'E');\n         if (exp != NULL)\n            sprintf(exp+1, \"%d\", atoi(exp+1));\n         if (strlen(csa->field) <= 12) break;\n      }\n      xassert(strlen(csa->field) <= 12);\n      return csa->field;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*mps_numb(struct csa *csa, double val)",
        "*"
      ]
    },
    "glp_write_mps": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1449,
        1
      ],
      "content": "int glp_write_mps(glp_prob *P, int fmt, const glp_mpscp *parm,\n      const char *fname)\n{     /* write problem data in MPS format */\n      glp_mpscp _parm;\n      struct csa _csa, *csa = &_csa;\n      glp_file *fp;\n      int out_obj, one_col = 0, empty = 0;\n      int i, j, recno, marker, count, gap, ret;\n      xprintf(\"Writing problem data to '%s'...\\n\", fname);\n      if (!(fmt == GLP_MPS_DECK || fmt == GLP_MPS_FILE))\n         xerror(\"glp_write_mps: fmt = %d; invalid parameter\\n\", fmt);\n      if (parm == NULL)\n         glp_init_mpscp(&_parm), parm = &_parm;\n      /* check control parameters */\n      check_parm(\"glp_write_mps\", parm);\n      /* initialize common storage area */\n      csa->P = P;\n      csa->deck = (fmt == GLP_MPS_DECK);\n      csa->parm = parm;\n      /* create output MPS file */\n      fp = glp_open(fname, \"w\"), recno = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* write comment records */\n      xfprintf(fp, \"* %-*s%s\\n\", P->name == NULL ? 1 : 12, \"Problem:\",\n         P->name == NULL ? \"\" : P->name), recno++;\n      xfprintf(fp, \"* %-12s%s\\n\", \"Class:\", glp_get_num_int(P) == 0 ?\n         \"LP\" : \"MIP\"), recno++;\n      xfprintf(fp, \"* %-12s%d\\n\", \"Rows:\", P->m), recno++;\n      if (glp_get_num_int(P) == 0)\n         xfprintf(fp, \"* %-12s%d\\n\", \"Columns:\", P->n), recno++;\n      else\n         xfprintf(fp, \"* %-12s%d (%d integer, %d binary)\\n\",\n            \"Columns:\", P->n, glp_get_num_int(P), glp_get_num_bin(P)),\n            recno++;\n      xfprintf(fp, \"* %-12s%d\\n\", \"Non-zeros:\", P->nnz), recno++;\n      xfprintf(fp, \"* %-12s%s\\n\", \"Format:\", csa->deck ? \"Fixed MPS\" :\n         \"Free MPS\"), recno++;\n      xfprintf(fp, \"*\\n\", recno++);\n      /* write NAME indicator record */\n      xfprintf(fp, \"NAME%*s%s\\n\",\n         P->name == NULL ? 0 : csa->deck ? 10 : 1, \"\", mps_name(csa)),\n         recno++;\n#if 1\n      /* determine whether to write the objective row */\n      out_obj = 1;\n      for (i = 1; i <= P->m; i++)\n      {  if (P->row[i]->type == GLP_FR)\n         {  out_obj = 0;\n            break;\n         }\n      }\n#endif\n      /* write ROWS section */\n      xfprintf(fp, \"ROWS\\n\"), recno++;\n      for (i = (out_obj ? 0 : 1); i <= P->m; i++)\n      {  int type;\n         type = (i == 0 ? GLP_FR : P->row[i]->type);\n         if (type == GLP_FR)\n            type = 'N';\n         else if (type == GLP_LO)\n            type = 'G';\n         else if (type == GLP_UP)\n            type = 'L';\n         else if (type == GLP_DB || type == GLP_FX)\n            type = 'E';\n         else\n            xassert(type != type);\n         xfprintf(fp, \" %c%*s%s\\n\", type, csa->deck ? 2 : 1, \"\",\n            row_name(csa, i)), recno++;\n      }\n      /* write COLUMNS section */\n      xfprintf(fp, \"COLUMNS\\n\"), recno++;\n      marker = 0;\n      for (j = 1; j <= P->n; j++)\n      {  GLPAIJ cj, *aij;\n         int kind;\n         kind = P->col[j]->kind;\n         if (kind == GLP_CV)\n         {  if (marker % 2 == 1)\n            {  /* close current integer block */\n               marker++;\n               xfprintf(fp, \"%*sM%07d%*s'MARKER'%*s'INTEND'\\n\",\n                  csa->deck ? 4 : 1, \"\", marker, csa->deck ? 2 : 1, \"\",\n                  csa->deck ? 17 : 1, \"\"), recno++;\n            }\n         }\n         else if (kind == GLP_IV)\n         {  if (marker % 2 == 0)\n            {  /* open new integer block */\n               marker++;\n               xfprintf(fp, \"%*sM%07d%*s'MARKER'%*s'INTORG'\\n\",\n                  csa->deck ? 4 : 1, \"\", marker, csa->deck ? 2 : 1, \"\",\n                  csa->deck ? 17 : 1, \"\"), recno++;\n            }\n         }\n         else\n            xassert(kind != kind);\n         if (out_obj && P->col[j]->coef != 0.0)\n         {  /* make fake objective coefficient */\n            aij = &cj;\n            aij->row = NULL;\n            aij->val = P->col[j]->coef;\n            aij->c_next = P->col[j]->ptr;\n         }\n         else\n            aij = P->col[j]->ptr;\n#if 1 /* FIXME */\n         if (aij == NULL)\n         {  /* empty column */\n            empty++;\n            xfprintf(fp, \"%*s%-*s\", csa->deck ? 4 : 1, \"\",\n               csa->deck ? 8 : 1, col_name(csa, j));\n            /* we need a row */\n            xassert(P->m > 0);\n            xfprintf(fp, \"%*s%-*s\",\n               csa->deck ? 2 : 1, \"\", csa->deck ? 8 : 1,\n               row_name(csa, 1));\n            xfprintf(fp, \"%*s0%*s$ empty column\\n\",\n               csa->deck ? 13 : 1, \"\", csa->deck ? 3 : 1, \"\"), recno++;\n         }\n#endif\n         count = 0;\n         for (aij = aij; aij != NULL; aij = aij->c_next)\n         {  if (one_col || count % 2 == 0)\n               xfprintf(fp, \"%*s%-*s\", csa->deck ? 4 : 1, \"\",\n                  csa->deck ? 8 : 1, col_name(csa, j));\n            gap = (one_col || count % 2 == 0 ? 2 : 3);\n            xfprintf(fp, \"%*s%-*s\",\n               csa->deck ? gap : 1, \"\", csa->deck ? 8 : 1,\n               row_name(csa, aij->row == NULL ? 0 : aij->row->i));\n            xfprintf(fp, \"%*s%*s\",\n               csa->deck ? 2 : 1, \"\", csa->deck ? 12 : 1,\n               mps_numb(csa, aij->val)), count++;\n            if (one_col || count % 2 == 0)\n               xfprintf(fp, \"\\n\"), recno++;\n         }\n         if (!(one_col || count % 2 == 0))\n            xfprintf(fp, \"\\n\"), recno++;\n      }\n      if (marker % 2 == 1)\n      {  /* close last integer block */\n         marker++;\n         xfprintf(fp, \"%*sM%07d%*s'MARKER'%*s'INTEND'\\n\",\n            csa->deck ? 4 : 1, \"\", marker, csa->deck ? 2 : 1, \"\",\n            csa->deck ? 17 : 1, \"\"), recno++;\n      }\n#if 1\n      if (empty > 0)\n         xprintf(\"Warning: problem has %d empty column(s)\\n\", empty);\n#endif\n      /* write RHS section */\n      xfprintf(fp, \"RHS\\n\"), recno++;\n      count = 0;\n      for (i = (out_obj ? 0 : 1); i <= P->m; i++)\n      {  int type;\n         double rhs;\n         if (i == 0)\n            rhs = P->c0;\n         else\n         {  type = P->row[i]->type;\n            if (type == GLP_FR)\n               rhs = 0.0;\n            else if (type == GLP_LO)\n               rhs = P->row[i]->lb;\n            else if (type == GLP_UP)\n               rhs = P->row[i]->ub;\n            else if (type == GLP_DB || type == GLP_FX)\n               rhs = P->row[i]->lb;\n            else\n               xassert(type != type);\n         }\n         if (rhs != 0.0)\n         {  if (one_col || count % 2 == 0)\n               xfprintf(fp, \"%*s%-*s\", csa->deck ? 4 : 1, \"\",\n                  csa->deck ? 8 : 1, \"RHS1\");\n            gap = (one_col || count % 2 == 0 ? 2 : 3);\n            xfprintf(fp, \"%*s%-*s\",\n               csa->deck ? gap : 1, \"\", csa->deck ? 8 : 1,\n               row_name(csa, i));\n            xfprintf(fp, \"%*s%*s\",\n               csa->deck ? 2 : 1, \"\", csa->deck ? 12 : 1,\n               mps_numb(csa, rhs)), count++;\n            if (one_col || count % 2 == 0)\n               xfprintf(fp, \"\\n\"), recno++;\n         }\n      }\n      if (!(one_col || count % 2 == 0))\n         xfprintf(fp, \"\\n\"), recno++;\n      /* write RANGES section */\n      for (i = P->m; i >= 1; i--)\n         if (P->row[i]->type == GLP_DB) break;\n      if (i == 0) goto bnds;\n      xfprintf(fp, \"RANGES\\n\"), recno++;\n      count = 0;\n      for (i = 1; i <= P->m; i++)\n      {  if (P->row[i]->type == GLP_DB)\n         {  if (one_col || count % 2 == 0)\n               xfprintf(fp, \"%*s%-*s\", csa->deck ? 4 : 1, \"\",\n                  csa->deck ? 8 : 1, \"RNG1\");\n            gap = (one_col || count % 2 == 0 ? 2 : 3);\n            xfprintf(fp, \"%*s%-*s\",\n               csa->deck ? gap : 1, \"\", csa->deck ? 8 : 1,\n               row_name(csa, i));\n            xfprintf(fp, \"%*s%*s\",\n               csa->deck ? 2 : 1, \"\", csa->deck ? 12 : 1,\n               mps_numb(csa, P->row[i]->ub - P->row[i]->lb)), count++;\n            if (one_col || count % 2 == 0)\n               xfprintf(fp, \"\\n\"), recno++;\n         }\n      }\n      if (!(one_col || count % 2 == 0))\n         xfprintf(fp, \"\\n\"), recno++;\nbnds: /* write BOUNDS section */\n      for (j = P->n; j >= 1; j--)\n         if (!(P->col[j]->kind == GLP_CV &&\n               P->col[j]->type == GLP_LO && P->col[j]->lb == 0.0))\n            break;\n      if (j == 0) goto endt;\n      xfprintf(fp, \"BOUNDS\\n\"), recno++;\n      for (j = 1; j <= P->n; j++)\n      {  int type, data[2];\n         double bnd[2];\n         char *spec[2];\n         spec[0] = spec[1] = NULL;\n         type = P->col[j]->type;\n         if (type == GLP_FR)\n            spec[0] = \"FR\", data[0] = 0;\n         else if (type == GLP_LO)\n         {  if (P->col[j]->lb != 0.0)\n               spec[0] = \"LO\", data[0] = 1, bnd[0] = P->col[j]->lb;\n            if (P->col[j]->kind == GLP_IV)\n               spec[1] = \"PL\", data[1] = 0;\n         }\n         else if (type == GLP_UP)\n         {  spec[0] = \"MI\", data[0] = 0;\n            spec[1] = \"UP\", data[1] = 1, bnd[1] = P->col[j]->ub;\n         }\n         else if (type == GLP_DB)\n         {  if (P->col[j]->lb != 0.0)\n               spec[0] = \"LO\", data[0] = 1, bnd[0] = P->col[j]->lb;\n            spec[1] = \"UP\", data[1] = 1, bnd[1] = P->col[j]->ub;\n         }\n         else if (type == GLP_FX)\n            spec[0] = \"FX\", data[0] = 1, bnd[0] = P->col[j]->lb;\n         else\n            xassert(type != type);\n         for (i = 0; i <= 1; i++)\n         {  if (spec[i] != NULL)\n            {  xfprintf(fp, \" %s %-*s%*s%-*s\", spec[i],\n                  csa->deck ? 8 : 1, \"BND1\", csa->deck ? 2 : 1, \"\",\n                  csa->deck ? 8 : 1, col_name(csa, j));\n               if (data[i])\n                  xfprintf(fp, \"%*s%*s\", csa->deck ? 2 : 1, \"\",\n                     csa->deck ? 12 : 1, mps_numb(csa, bnd[i]));\n               xfprintf(fp, \"\\n\"), recno++;\n            }\n         }\n      }\nendt: /* write ENDATA indicator record */\n      xfprintf(fp, \"ENDATA\\n\"), recno++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* problem data has been successfully written */\n      xprintf(\"%d records were written\\n\", recno);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 278,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/netgen.c": {
    "glp_netgen": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "int glp_netgen(glp_graph *G_, int _v_rhs, int _a_cap, int _a_cost,\n      const int parm[1+15])\n{     struct csa _csa, *csa = &_csa;\n      int iseed, nprob, ntsorc, ntsink, iphic, i, nskel, nltr, ltsink,\n         ntrans, npsink, nftr, npsorc, ntravl, ntrrem, lsorc, lpick,\n         nsksr, nsrchn, j, item, l, ks, k, ksp, li, n, ii, it, ih, icap,\n         jcap, icost, jcost, ret;\n      G = G_;\n      v_rhs = _v_rhs;\n      a_cap = _a_cap;\n      a_cost = _a_cost;\n      if (G != NULL)\n      {  if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n            xerror(\"glp_netgen: v_rhs = %d; invalid offset\\n\", v_rhs);\n         if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n            xerror(\"glp_netgen: a_cap = %d; invalid offset\\n\", a_cap);\n         if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n            xerror(\"glp_netgen: a_cost = %d; invalid offset\\n\", a_cost);\n      }\n      /* Input the user's random number seed and fix it if\n         non-positive. */\n      iseed = parm[1];\n      nprob = parm[2];\n      if (iseed <= 0) iseed = 13502460;\n      setran(csa, iseed);\n      /* Input the user's problem characteristics. */\n      nodes = parm[3];\n      nsorc = parm[4];\n      nsink = parm[5];\n      iarcs = parm[6];\n      mincst = parm[7];\n      maxcst = parm[8];\n      itsup = parm[9];\n      ntsorc = parm[10];\n      ntsink = parm[11];\n      iphic = parm[12];\n      ipcap = parm[13];\n      mincap = parm[14];\n      maxcap = parm[15];\n      /* Check the size of the problem. */\n      if (!(10 <= nodes && nodes <= 100000))\n      {  ret = 1;\n         goto done;\n      }\n      /* Check user supplied parameters for consistency. */\n      if (!(nsorc >= 0 && nsink >= 0 && nsorc + nsink <= nodes))\n      {  ret = 2;\n         goto done;\n      }\n      if (iarcs < 0)\n      {  ret = 3;\n         goto done;\n      }\n      if (mincst > maxcst)\n      {  ret = 4;\n         goto done;\n      }\n      if (itsup < 0)\n      {  ret = 5;\n         goto done;\n      }\n      if (!(0 <= ntsorc && ntsorc <= nsorc))\n      {  ret = 6;\n         goto done;\n      }\n      if (!(0 <= ntsink && ntsink <= nsink))\n      {  ret = 7;\n         goto done;\n      }\n      if (!(0 <= iphic && iphic <= 100))\n      {  ret = 8;\n         goto done;\n      }\n      if (!(0 <= ipcap && ipcap <= 100))\n      {  ret = 9;\n         goto done;\n      }\n      if (mincap > maxcap)\n      {  ret = 10;\n         goto done;\n      }\n      /* Initailize the graph object. */\n      if (G != NULL)\n      {  glp_erase_graph(G, G->v_size, G->a_size);\n         glp_add_vertices(G, nodes);\n         if (v_rhs >= 0)\n         {  double zero = 0.0;\n            for (i = 1; i <= nodes; i++)\n            {  glp_vertex *v = G->v[i];\n               memcpy((char *)v->data + v_rhs, &zero, sizeof(double));\n            }\n         }\n      }\n      /* Allocate working arrays. */\n      ipred = xcalloc(1+nodes, sizeof(int));\n      ihead = xcalloc(1+nodes, sizeof(int));\n      itail = xcalloc(1+nodes, sizeof(int));\n      iflag = xcalloc(1+nodes, sizeof(int));\n      isup = xcalloc(1+nodes, sizeof(int));\n      lsinks = xcalloc(1+nodes, sizeof(int));\n      /* Print the problem documentation records. */\n      if (G == NULL)\n      {  xprintf(\"BEGIN\\n\");\n         xprintf(\"NETGEN PROBLEM%8d%10s%10d NODES AND%10d ARCS\\n\",\n            nprob, \"\", nodes, iarcs);\n         xprintf(\"USER:%11d%11d%11d%11d%11d%11d\\nDATA:%11d%11d%11d%11d%\"\n            \"11d%11d\\n\", iseed, nsorc, nsink, mincst,\n            maxcst, itsup, ntsorc, ntsink, iphic, ipcap,\n            mincap, maxcap);\n      }\n      else\n         glp_set_graph_name(G, \"NETGEN\");\n      /* Set various constants used in the program. */\n      narcs = 0;\n      nskel = 0;\n      nltr = nodes - nsink;\n      ltsink = nltr + ntsink;\n      ntrans = nltr - nsorc;\n      nfsink = nltr + 1;\n      nonsor = nodes - nsorc + ntsorc;\n      npsink = nsink - ntsink;\n      nodlft = nodes - nsink + ntsink;\n      nftr = nsorc + 1;\n      nftsor = nsorc - ntsorc + 1;\n      npsorc = nsorc - ntsorc;\n      /* Randomly distribute the supply among the source nodes. */\n      if (npsorc + npsink == nodes && npsorc == npsink &&\n          itsup == nsorc)\n      {  assign(csa);\n         nskel = nsorc;\n         goto L390;\n      }\n      cresup(csa);\n      /* Print the supply records. */\n      if (G == NULL)\n      {  xprintf(\"SUPPLY\\n\");\n         for (i = 1; i <= nsorc; i++)\n            xprintf(\"%6s%6d%18s%10d\\n\", \"\", i, \"\", isup[i]);\n         xprintf(\"ARCS\\n\");\n      }\n      else\n      {  if (v_rhs >= 0)\n         {  for (i = 1; i <= nsorc; i++)\n            {  double temp = (double)isup[i];\n               glp_vertex *v = G->v[i];\n               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));\n            }\n         }\n      }\n      /* Make the sources point to themselves in ipred array. */\n      for (i = 1; i <= nsorc; i++)\n         ipred[i] = i;\n      if (ntrans == 0) goto L170;\n      /* Chain the transshipment nodes together in the ipred array. */\n      ist = nftr;\n      ipred[nltr] = 0;\n      for (i = nftr; i < nltr; i++)\n         ipred[i] = i+1;\n      /* Form even length chains for 60 percent of the transshipments.*/\n      ntravl = 6 * ntrans / 10;\n      ntrrem = ntrans - ntravl;\nL140: lsorc = 1;\n      while (ntravl != 0)\n      {  lpick = iran(csa, 1, ntravl + ntrrem);\n         ntravl--;\n         chain(csa, lpick, lsorc);\n         if (lsorc == nsorc) goto L140;\n         lsorc++;\n      }\n      /* Add the remaining transshipments to the chains. */\n      while (ntrrem != 0)\n      {\n         lpick = iran(csa, 1, ntrrem);\n         ntrrem--;\n         lsorc = iran(csa, 1, nsorc);\n         chain(csa, lpick, lsorc);\n      }\nL170: /* Set all demands equal to zero. */\n      for (i = nfsink; i <= nodes; i++)\n         ipred[i] = 0;\n      /* The following loop takes one chain at a time (through the use\n         of logic contained in the loop and calls to other routines) and\n         creates the remaining network arcs. */\n      for (lsorc = 1; lsorc <= nsorc; lsorc++)\n      {  chnarc(csa, lsorc);\n         for (i = nfsink; i <= nodes; i++)\n            iflag[i] = 0;\n         /* Choose the number of sinks to be hooked up to the current\n            chain. */\n         if (ntrans != 0)\n            nsksr = (nsort * 2 * nsink) / ntrans;\n         else\n            nsksr = nsink / nsorc + 1;\n         if (nsksr < 2) nsksr = 2;\n         if (nsksr > nsink) nsksr = nsink;\n         nsrchn = nsort;\n         /* Randomly pick nsksr sinks and put their names in lsinks. */\n         ktl = nsink;\n         for (j = 1; j <= nsksr; j++)\n         {  item = iran(csa, 1, ktl);\n            ktl--;\n            for (l = nfsink; l <= nodes; l++)\n            {  if (iflag[l] != 1)\n               {  item--;\n                  if (item == 0) goto L230;\n               }\n            }\n            break;\nL230:       lsinks[j] = l;\n            iflag[l] = 1;\n         }\n         /* If last source chain, add all sinks with zero demand to\n            lsinks list. */\n         if (lsorc == nsorc)\n         {  for (j = nfsink; j <= nodes; j++)\n            {  if (ipred[j] == 0 && iflag[j] != 1)\n               {  nsksr++;\n                  lsinks[nsksr] = j;\n                  iflag[j] = 1;\n               }\n            }\n         }\n         /* Create demands for group of sinks in lsinks. */\n         ks = isup[lsorc] / nsksr;\n         k = ipred[lsorc];\n         for (i = 1; i <= nsksr; i++)\n         {  nsort++;\n            ksp = iran(csa, 1, ks);\n            j = iran(csa, 1, nsksr);\n            itail[nsort] = k;\n            li = lsinks[i];\n            ihead[nsort] = li;\n            ipred[li] += ksp;\n            li = lsinks[j];\n            ipred[li] += ks - ksp;\n            n = iran(csa, 1, nsrchn);\n            k = lsorc;\n            for (ii = 1; ii <= n; ii++)\n               k = ipred[k];\n         }\n         li = lsinks[1];\n         ipred[li] += isup[lsorc] - ks * nsksr;\n         nskel += nsort;\n         /* Sort the arcs in the chain from source lsorc using itail as\n            sort key. */\n         sort(csa);\n         /* Print this part of skeleton and create the arcs for these\n            nodes. */\n         i = 1;\n         itail[nsort+1] = 0;\nL300:    for (j = nftsor; j <= nodes; j++)\n            iflag[j] = 0;\n         ktl = nonsor - 1;\n         it = itail[i];\n         iflag[it] = 1;\nL320:    ih = ihead[i];\n         iflag[ih] = 1;\n         narcs++;\n         ktl--;\n         /* Determine if this skeleton arc should be capacitated. */\n         icap = itsup;\n         jcap = iran(csa, 1, 100);\n         if (jcap <= ipcap)\n         {  icap = isup[lsorc];\n            if (mincap > icap) icap = mincap;\n         }\n         /* Determine if this skeleton arc should have the maximum\n            cost. */\n         icost = maxcst;\n         jcost = iran(csa, 1, 100);\n         if (jcost > iphic)\n            icost = iran(csa, mincst, maxcst);\n         if (G == NULL)\n            xprintf(\"%6s%6d%6d%2s%10d%10d\\n\", \"\", it, ih, \"\", icost,\n               icap);\n         else\n         {  glp_arc *a = glp_add_arc(G, it, ih);\n            if (a_cap >= 0)\n            {  double temp = (double)icap;\n               memcpy((char *)a->data + a_cap, &temp, sizeof(double));\n            }\n            if (a_cost >= 0)\n            {  double temp = (double)icost;\n               memcpy((char *)a->data + a_cost, &temp, sizeof(double));\n            }\n         }\n         i++;\n         if (itail[i] == it) goto L320;\n         pickj(csa, it);\n         if (i <= nsort) goto L300;\n      }\n      /* Create arcs from the transshipment sinks. */\n      if (ntsink != 0)\n      {  for (i = nfsink; i <= ltsink; i++)\n         {  for (j = nftsor; j <= nodes; j++)\n               iflag[j] = 0;\n            ktl = nonsor - 1;\n            iflag[i] = 1;\n            pickj(csa, i);\n         }\n      }\nL390: /* Print the demand records and end record. */\n      if (G == NULL)\n      {  xprintf(\"DEMAND\\n\");\n         for (i = nfsink; i <= nodes; i++)\n            xprintf(\"%6s%6d%18s%10d\\n\", \"\", i, \"\", ipred[i]);\n         xprintf(\"END\\n\");\n      }\n      else\n      {  if (v_rhs >= 0)\n         {  for (i = nfsink; i <= nodes; i++)\n            {  double temp = - (double)ipred[i];\n               glp_vertex *v = G->v[i];\n               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));\n            }\n         }\n      }\n      /* Free working arrays. */\n      xfree(ipred);\n      xfree(ihead);\n      xfree(itail);\n      xfree(iflag);\n      xfree(isup);\n      xfree(lsinks);\n      /* The instance has been successfully generated. */\n      ret = 0;\ndone: return ret;\n}",
      "lines": 328,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "cresup": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "static void cresup(struct csa *csa)\n{     int i, j, ks, ksp;\n      xassert(itsup > nsorc);\n      ks = itsup / nsorc;\n      for (i = 1; i <= nsorc; i++)\n         isup[i] = 0;\n      for (i = 1; i <= nsorc; i++)\n      {  ksp = iran(csa, 1, ks);\n         j = iran(csa, 1, nsorc);\n         isup[i] += ksp;\n         isup[j] += ks - ksp;\n      }\n      j = iran(csa, 1, nsorc);\n      isup[j] += itsup - ks * nsorc;\n      return;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "chain": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "static void chain(struct csa *csa, int lpick, int lsorc)\n{     int i, j, k, l, m;\n      k = 0;\n      m = ist;\n      for (i = 1; i <= lpick; i++)\n      {  l = k;\n         k = m;\n         m = ipred[k];\n      }\n      ipred[l] = m;\n      j = ipred[lsorc];\n      ipred[k] = j;\n      ipred[lsorc] = k;\n      return;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "chnarc": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "static void chnarc(struct csa *csa, int lsorc)\n{     int ito, ifrom;\n      nsort = 0;\n      ito = ipred[lsorc];\nL10:  if (ito == lsorc) return;\n      nsort++;\n      ifrom = ipred[ito];\n      ihead[nsort] = ito;\n      itail[nsort] = ifrom;\n      ito = ifrom;\n      goto L10;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sort": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "static void sort(struct csa *csa)\n{     int i, j, k, l, m, n, it;\n      n = nsort;\n      m = n;\nL10:  m /= 2;\n      if (m == 0) return;\n      k = n - m;\n      j = 1;\nL20:  i = j;\nL30:  l = i + m;\n      if (itail[i] <= itail[l]) goto L40;\n      it = itail[i];\n      itail[i] = itail[l];\n      itail[l] = it;\n      it = ihead[i];\n      ihead[i] = ihead[l];\n      ihead[l] = it;\n      i -= m;\n      if (i >= 1) goto L30;\nL40:  j++;\n      if (j <= k) goto L20;\n      goto L10;\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pickj": {
      "start_point": [
        582,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "static void pickj(struct csa *csa, int it)\n{     int j, k, l, nn, nupbnd, icap, jcap, icost;\n      if ((nodlft - 1) * 2 > iarcs - narcs - 1)\n      {  nodlft--;\n         return;\n      }\n      if ((iarcs - narcs + nonsor - ktl - 1) / nodlft - nonsor + 1 >= 0)\n         k = nonsor;\n      else\n      {  nupbnd = (iarcs - narcs - nodlft) / nodlft * 2;\nL40:     k = iran(csa, 1, nupbnd);\n         if (nodlft == 1) k = iarcs - narcs;\n         if ((nodlft - 1) * (nonsor - 1) < iarcs - narcs - k) goto L40;\n      }\n      nodlft--;\n      for (j = 1; j <= k; j++)\n      {  nn = iran(csa, 1, ktl);\n         ktl--;\n         for (l = nftsor; l <= nodes; l++)\n         {  if (iflag[l] != 1)\n            {  nn--;\n               if (nn == 0) goto L70;\n            }\n         }\n         return;\nL70:     iflag[l] = 1;\n         icap = itsup;\n         jcap = iran(csa, 1, 100);\n         if (jcap <= ipcap)\n            icap = iran(csa, mincap, maxcap);\n         icost = iran(csa, mincst, maxcst);\n         if (G == NULL)\n            xprintf(\"%6s%6d%6d%2s%10d%10d\\n\", \"\", it, l, \"\", icost,\n               icap);\n         else\n         {  glp_arc *a = glp_add_arc(G, it, l);\n            if (a_cap >= 0)\n            {  double temp = (double)icap;\n               memcpy((char *)a->data + a_cap, &temp, sizeof(double));\n            }\n            if (a_cost >= 0)\n            {  double temp = (double)icost;\n               memcpy((char *)a->data + a_cost, &temp, sizeof(double));\n            }\n         }\n         narcs++;\n      }\n      return;\n}",
      "lines": 49,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "assign": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        690,
        1
      ],
      "content": "static void assign(struct csa *csa)\n{     int i, it, nn, l, ll, icost;\n      if (G == NULL)\n         xprintf(\"SUPPLY\\n\");\n      for (i = 1; i <= nsorc; i++)\n      {  isup[i] = 1;\n         iflag[i] = 0;\n         if (G == NULL)\n            xprintf(\"%6s%6d%18s%10d\\n\", \"\", i, \"\", isup[i]);\n         else\n         {  if (v_rhs >= 0)\n            {  double temp = (double)isup[i];\n               glp_vertex *v = G->v[i];\n               memcpy((char *)v->data + v_rhs, &temp, sizeof(double));\n            }\n         }\n      }\n      if (G == NULL)\n         xprintf(\"ARCS\\n\");\n      for (i = nfsink; i <= nodes; i++)\n         ipred[i] = 1;\n      for (it = 1; it <= nsorc; it++)\n      {  for (i = nfsink; i <= nodes; i++)\n            iflag[i] = 0;\n         ktl = nsink - 1;\n         nn = iran(csa, 1, nsink - it + 1);\n         for (l = 1; l <= nsorc; l++)\n         {  if (iflag[l] != 1)\n            {  nn--;\n               if (nn == 0) break;\n            }\n         }\n         narcs++;\n         ll = nsorc + l;\n         icost = iran(csa, mincst, maxcst);\n         if (G == NULL)\n            xprintf(\"%6s%6d%6d%2s%10d%10d\\n\", \"\", it, ll, \"\", icost,\n               isup[1]);\n         else\n         {  glp_arc *a = glp_add_arc(G, it, ll);\n            if (a_cap >= 0)\n            {  double temp = (double)isup[1];\n               memcpy((char *)a->data + a_cap, &temp, sizeof(double));\n            }\n            if (a_cost >= 0)\n            {  double temp = (double)icost;\n               memcpy((char *)a->data + a_cost, &temp, sizeof(double));\n            }\n         }\n         iflag[l] = 1;\n         iflag[ll] = 1;\n         pickj(csa, it);\n      }\n      return;\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setran": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "static void setran(struct csa *csa, int iseed)\n{     xassert(iseed >= 1);\n      mult = 16807;\n      modul = 2147483647;\n      i15 = 1 << 15;\n      i16 = 1 << 16;\n      jran = iseed;\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "iran": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        739,
        1
      ],
      "content": "static int iran(struct csa *csa, int ilow, int ihigh)\n{     int ixhi, ixlo, ixalo, leftlo, ixahi, ifulhi, irtlo, iover,\n         irthi, j;\n      ixhi = jran / i16;\n      ixlo = jran - ixhi * i16;\n      ixalo = ixlo * mult;\n      leftlo = ixalo / i16;\n      ixahi = ixhi * mult;\n      ifulhi = ixahi + leftlo;\n      irtlo = ixalo - leftlo * i16;\n      iover = ifulhi / i15;\n      irthi = ifulhi - iover * i15;\n      jran = ((irtlo - modul) + irthi * i16) + iover;\n      if (jran < 0) jran += modul;\n      j = ihigh - ilow + 1;\n      if (j > 0)\n         return jran % j + ilow;\n      else\n         return ihigh;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_netgen_prob": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        982,
        1
      ],
      "content": "void glp_netgen_prob(int nprob, int parm[1+15])\n{     int k;\n      if (!(101 <= nprob && nprob <= 150))\n         xerror(\"glp_netgen_prob: nprob = %d; invalid problem instance \"\n            \"number\\n\", nprob);\n      for (k = 1; k <= 15; k++)\n         parm[k] = data[nprob-101][k];\n      return;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "scan": {
      "start_point": [
        987,
        0
      ],
      "end_point": [
        992,
        1
      ],
      "content": "static int scan(char card[80+1], int pos, int len)\n{     char buf[10+1];\n      memcpy(buf, &card[pos-1], len);\n      buf[len] = '\\0';\n      return atoi(buf);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1016,
        1
      ],
      "content": "int main(void)\n{     int parm[1+15];\n      char card[80+1];\n      xassert(fgets(card, sizeof(card), stdin) == card);\n      parm[1] = scan(card, 1, 8);\n      parm[2] = scan(card, 9, 8);\n      xassert(fgets(card, sizeof(card), stdin) == card);\n      parm[3] = scan(card, 1, 5);\n      parm[4] = scan(card, 6, 5);\n      parm[5] = scan(card, 11, 5);\n      parm[6] = scan(card, 16, 5);\n      parm[7] = scan(card, 21, 5);\n      parm[8] = scan(card, 26, 5);\n      parm[9] = scan(card, 31, 10);\n      parm[10] = scan(card, 41, 5);\n      parm[11] = scan(card, 46, 5);\n      parm[12] = scan(card, 51, 5);\n      parm[13] = scan(card, 56, 5);\n      parm[14] = scan(card, 61, 10);\n      parm[15] = scan(card, 71, 10);\n      glp_netgen(NULL, 0, 0, 0, parm);\n      return 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/npp.c": {
    "glp_npp_alloc_wksp": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "glp_prep *glp_npp_alloc_wksp(void)\n{     /* allocate the preprocessor workspace */\n      glp_prep *prep;\n      prep = npp_create_wksp();\n      return prep;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "glp_prep",
        "*glp_npp_alloc_wksp(void)",
        "*"
      ]
    },
    "glp_npp_load_prob": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void glp_npp_load_prob(glp_prep *prep, glp_prob *P, int sol, int names)\n{     /* load original problem instance */\n      if (prep->sol != 0)\n         xerror(\"glp_npp_load_prob: invalid call sequence (original ins\"\n            \"tance already loaded)\\n\");\n      if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\n         xerror(\"glp_npp_load_prob: sol = %d; invalid parameter\\n\",\n            sol);\n      if (!(names == GLP_ON || names == GLP_OFF))\n         xerror(\"glp_npp_load_prob: names = %d; invalid parameter\\n\",\n            names);\n      npp_load_prob(prep, P, names, sol, GLP_OFF);\n      return;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_npp_preprocess1": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int glp_npp_preprocess1(glp_prep *prep, int hard)\n{     /* perform basic LP/MIP preprocessing */\n      if (prep->sol == 0)\n         xerror(\"glp_npp_preprocess1: invalid call sequence (original i\"\n            \"nstance not loaded yet)\\n\");\n      if (prep->pool == NULL)\n         xerror(\"glp_npp_preprocess1: invalid call sequence (preprocess\"\n            \"ing already finished)\\n\");\n      if (!(hard == GLP_ON || hard == GLP_OFF))\n         xerror(\"glp_npp_preprocess1: hard = %d; invalid parameter\\n\",\n            hard);\n      return npp_process_prob(prep, hard);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glp_npp_build_prob": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void glp_npp_build_prob(glp_prep *prep, glp_prob *Q)\n{     /* build resultant problem instance */\n      if (prep->sol == 0)\n         xerror(\"glp_npp_build_prob: invalid call sequence (original in\"\n            \"stance not loaded yet)\\n\");\n      if (prep->pool == NULL)\n         xerror(\"glp_npp_build_prob: invalid call sequence (resultant i\"\n            \"nstance already built)\\n\");\n      npp_build_prob(prep, Q);\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "glp_npp_postprocess": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void glp_npp_postprocess(glp_prep *prep, glp_prob *Q)\n{     /* postprocess solution to resultant problem */\n      if (prep->pool != NULL)\n         xerror(\"glp_npp_postprocess: invalid call sequence (resultant \"\n            \"instance not built yet)\\n\");\n      if (!(prep->m == Q->m && prep->n == Q->n && prep->nnz == Q->nnz))\n         xerror(\"glp_npp_postprocess: resultant instance mismatch\\n\");\n      switch (prep->sol)\n      {  case GLP_SOL:\n            if (glp_get_status(Q) != GLP_OPT)\n               xerror(\"glp_npp_postprocess: unable to recover non-optim\"\n                  \"al basic solution\\n\");\n            break;\n         case GLP_IPT:\n            if (glp_ipt_status(Q) != GLP_OPT)\n               xerror(\"glp_npp_postprocess: unable to recover non-optim\"\n                  \"al interior-point solution\\n\");\n            break;\n         case GLP_MIP:\n            if (!(glp_mip_status(Q) == GLP_OPT || glp_mip_status(Q) ==\n               GLP_FEAS))\n               xerror(\"glp_npp_postprocess: unable to recover integer n\"\n                  \"on-feasible solution\\n\");\n            break;\n         default:\n            xassert(prep != prep);\n      }\n      npp_postprocess(prep, Q);\n      return;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_npp_obtain_sol": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void glp_npp_obtain_sol(glp_prep *prep, glp_prob *P)\n{     /* obtain solution to original problem */\n      if (prep->pool != NULL)\n         xerror(\"glp_npp_obtain_sol: invalid call sequence (resultant i\"\n            \"nstance not built yet)\\n\");\n      switch (prep->sol)\n      {  case GLP_SOL:\n            if (prep->p_stat == 0 || prep->d_stat == 0)\n               xerror(\"glp_npp_obtain_sol: invalid call sequence (basic\"\n                  \" solution not provided yet)\\n\");\n            break;\n         case GLP_IPT:\n            if (prep->t_stat == 0)\n               xerror(\"glp_npp_obtain_sol: invalid call sequence (inter\"\n                  \"ior-point solution not provided yet)\\n\");\n            break;\n         case GLP_MIP:\n            if (prep->i_stat == 0)\n               xerror(\"glp_npp_obtain_sol: invalid call sequence (MIP s\"\n                  \"olution not provided yet)\\n\");\n            break;\n         default:\n            xassert(prep != prep);\n      }\n      if (!(prep->orig_dir == P->dir && prep->orig_m == P->m &&\n            prep->orig_n == P->n && prep->orig_nnz == P->nnz))\n         xerror(\"glp_npp_obtain_sol: original instance mismatch\\n\");\n      npp_unload_sol(prep, P);\n      return;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_npp_free_wksp": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void glp_npp_free_wksp(glp_prep *prep)\n{     /* free the preprocessor workspace */\n      npp_delete_wksp(prep);\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/pript.c": {
    "glp_print_ipt": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "int glp_print_ipt(glp_prob *P, const char *fname)\n{     /* write interior-point solution in printable format */\n      glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, t, ae_ind, re_ind, ret;\n      double ae_max, re_max;\n      xprintf(\"Writing interior-point solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"%-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name);\n      xfprintf(fp, \"%-12s%d\\n\", \"Rows:\", P->m);\n      xfprintf(fp, \"%-12s%d\\n\", \"Columns:\", P->n);\n      xfprintf(fp, \"%-12s%d\\n\", \"Non-zeros:\", P->nnz);\n      t = glp_ipt_status(P);\n      xfprintf(fp, \"%-12s%s\\n\", \"Status:\",\n         t == GLP_OPT    ? \"OPTIMAL\" :\n         t == GLP_UNDEF  ? \"UNDEFINED\" :\n         t == GLP_INFEAS ? \"INFEASIBLE (INTERMEDIATE)\" :\n         t == GLP_NOFEAS ? \"INFEASIBLE (FINAL)\" : \"???\");\n      xfprintf(fp, \"%-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->ipt_obj,\n         P->dir == GLP_MIN ? \"MINimum\" :\n         P->dir == GLP_MAX ? \"MAXimum\" : \"???\");\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No.   Row name        Activity     Lower bound  \"\n         \" Upper bound    Marginal\\n\");\n      xfprintf(fp, \"------ ------------    ------------- ------------- \"\n         \"------------- -------------\\n\");\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         xfprintf(fp, \"%6d \", i);\n         if (row->name == NULL || strlen(row->name) <= 12)\n            xfprintf(fp, \"%-12s \", row->name == NULL ? \"\" : row->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", row->name, \"\");\n         xfprintf(fp, \"%3s\", \"\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(row->pval) <= 1e-9 ? 0.0 : row->pval);\n         if (row->type == GLP_LO || row->type == GLP_DB ||\n             row->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", row->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (row->type == GLP_UP || row->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", row->ub);\n         else\n            xfprintf(fp, \"%13s \", row->type == GLP_FX ? \"=\" : \"\");\n         if (fabs(row->dval) <= 1e-9)\n            xfprintf(fp, \"%13s\", \"< eps\");\n         else\n            xfprintf(fp, \"%13.6g \", row->dval);\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No. Column name       Activity     Lower bound  \"\n         \" Upper bound    Marginal\\n\");\n      xfprintf(fp, \"------ ------------    ------------- ------------- \"\n         \"------------- -------------\\n\");\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         xfprintf(fp, \"%6d \", j);\n         if (col->name == NULL || strlen(col->name) <= 12)\n            xfprintf(fp, \"%-12s \", col->name == NULL ? \"\" : col->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", col->name, \"\");\n         xfprintf(fp, \"%3s\", \"\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(col->pval) <= 1e-9 ? 0.0 : col->pval);\n         if (col->type == GLP_LO || col->type == GLP_DB ||\n             col->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", col->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (col->type == GLP_UP || col->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", col->ub);\n         else\n            xfprintf(fp, \"%13s \", col->type == GLP_FX ? \"=\" : \"\");\n         if (fabs(col->dval) <= 1e-9)\n            xfprintf(fp, \"%13s\", \"< eps\");\n         else\n            xfprintf(fp, \"%13.6g \", col->dval);\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"Karush-Kuhn-Tucker optimality conditions:\\n\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_IPT, GLP_KKT_PE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PE: max.abs.err = %.2e on row %d\\n\",\n         ae_max, ae_ind);\n      xfprintf(fp, \"        max.rel.err = %.2e on row %d\\n\",\n         re_max, re_ind);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"PRIMAL SOLUTION IS WRONG\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_IPT, GLP_KKT_PB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PB: max.abs.err = %.2e on %s %d\\n\",\n            ae_max, ae_ind <= P->m ? \"row\" : \"column\",\n            ae_ind <= P->m ? ae_ind : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on %s %d\\n\",\n            re_max, re_ind <= P->m ? \"row\" : \"column\",\n            re_ind <= P->m ? re_ind : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"PRIMAL SOLUTION IS INFEASIBL\"\n            \"E\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_IPT, GLP_KKT_DE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.DE: max.abs.err = %.2e on column %d\\n\",\n         ae_max, ae_ind == 0 ? 0 : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on column %d\\n\",\n         re_max, re_ind == 0 ? 0 : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"DUAL SOLUTION IS WRONG\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_IPT, GLP_KKT_DB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.DB: max.abs.err = %.2e on %s %d\\n\",\n            ae_max, ae_ind <= P->m ? \"row\" : \"column\",\n            ae_ind <= P->m ? ae_ind : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on %s %d\\n\",\n            re_max, re_ind <= P->m ? \"row\" : \"column\",\n            re_ind <= P->m ? re_ind : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"DUAL SOLUTION IS INFEASIBLE\")\n            ;\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"End of output\\n\");\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 156,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prmip.c": {
    "glp_print_mip": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int glp_print_mip(glp_prob *P, const char *fname)\n{     /* write MIP solution in printable format */\n      glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, t, ae_ind, re_ind, ret;\n      double ae_max, re_max;\n      xprintf(\"Writing MIP solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"%-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name);\n      xfprintf(fp, \"%-12s%d\\n\", \"Rows:\", P->m);\n      xfprintf(fp, \"%-12s%d (%d integer, %d binary)\\n\", \"Columns:\",\n         P->n, glp_get_num_int(P), glp_get_num_bin(P));\n      xfprintf(fp, \"%-12s%d\\n\", \"Non-zeros:\", P->nnz);\n      t = glp_mip_status(P);\n      xfprintf(fp, \"%-12s%s\\n\", \"Status:\",\n         t == GLP_OPT    ? \"INTEGER OPTIMAL\" :\n         t == GLP_FEAS   ? \"INTEGER NON-OPTIMAL\" :\n         t == GLP_NOFEAS ? \"INTEGER EMPTY\" :\n         t == GLP_UNDEF  ? \"INTEGER UNDEFINED\" : \"???\");\n      xfprintf(fp, \"%-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->mip_obj,\n         P->dir == GLP_MIN ? \"MINimum\" :\n         P->dir == GLP_MAX ? \"MAXimum\" : \"???\");\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No.   Row name        Activity     Lower bound  \"\n         \" Upper bound\\n\");\n      xfprintf(fp, \"------ ------------    ------------- ------------- \"\n         \"-------------\\n\");\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         xfprintf(fp, \"%6d \", i);\n         if (row->name == NULL || strlen(row->name) <= 12)\n            xfprintf(fp, \"%-12s \", row->name == NULL ? \"\" : row->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", row->name, \"\");\n         xfprintf(fp, \"%3s\", \"\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(row->mipx) <= 1e-9 ? 0.0 : row->mipx);\n         if (row->type == GLP_LO || row->type == GLP_DB ||\n             row->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", row->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (row->type == GLP_UP || row->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", row->ub);\n         else\n            xfprintf(fp, \"%13s \", row->type == GLP_FX ? \"=\" : \"\");\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No. Column name       Activity     Lower bound  \"\n         \" Upper bound\\n\");\n      xfprintf(fp, \"------ ------------    ------------- ------------- \"\n         \"-------------\\n\");\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         xfprintf(fp, \"%6d \", j);\n         if (col->name == NULL || strlen(col->name) <= 12)\n            xfprintf(fp, \"%-12s \", col->name == NULL ? \"\" : col->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", col->name, \"\");\n         xfprintf(fp, \"%s  \",\n            col->kind == GLP_CV ? \" \" :\n            col->kind == GLP_IV ? \"*\" : \"?\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(col->mipx) <= 1e-9 ? 0.0 : col->mipx);\n         if (col->type == GLP_LO || col->type == GLP_DB ||\n             col->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", col->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (col->type == GLP_UP || col->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", col->ub);\n         else\n            xfprintf(fp, \"%13s \", col->type == GLP_FX ? \"=\" : \"\");\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"Integer feasibility conditions:\\n\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_MIP, GLP_KKT_PE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PE: max.abs.err = %.2e on row %d\\n\",\n         ae_max, ae_ind);\n      xfprintf(fp, \"        max.rel.err = %.2e on row %d\\n\",\n         re_max, re_ind);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"SOLUTION IS WRONG\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_MIP, GLP_KKT_PB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PB: max.abs.err = %.2e on %s %d\\n\",\n            ae_max, ae_ind <= P->m ? \"row\" : \"column\",\n            ae_ind <= P->m ? ae_ind : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on %s %d\\n\",\n            re_max, re_ind <= P->m ? \"row\" : \"column\",\n            re_ind <= P->m ? re_ind : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"SOLUTION IS INFEASIBLE\");\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"End of output\\n\");\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 125,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prob.h": {},
  "glpk/glpk-4.65/src/api/prob1.c": {
    "glp_create_prob": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "glp_prob *glp_create_prob(void)\n{     glp_prob *lp;\n      lp = xmalloc(sizeof(glp_prob));\n      create_prob(lp);\n      return lp;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "glp_prob",
        "*glp_create_prob(void)",
        "*"
      ]
    },
    "glp_set_prob_name": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void glp_set_prob_name(glp_prob *lp, const char *name)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_prob_name: operation not allowed\\n\");\n      if (lp->name != NULL)\n      {  dmp_free_atom(lp->pool, lp->name, strlen(lp->name)+1);\n         lp->name = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int k;\n         for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_set_prob_name: problem name too long\\n\");\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_set_prob_name: problem name contains invalid\"\n                  \" character(s)\\n\");\n         }\n         lp->name = dmp_get_atom(lp->pool, strlen(name)+1);\n         strcpy(lp->name, name);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_obj_name": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void glp_set_obj_name(glp_prob *lp, const char *name)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_obj_name: operation not allowed\\n\");\n     if (lp->obj != NULL)\n      {  dmp_free_atom(lp->pool, lp->obj, strlen(lp->obj)+1);\n         lp->obj = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int k;\n         for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_set_obj_name: objective name too long\\n\");\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_set_obj_name: objective name contains invali\"\n                  \"d character(s)\\n\");\n         }\n         lp->obj = dmp_get_atom(lp->pool, strlen(name)+1);\n         strcpy(lp->obj, name);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_obj_dir": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void glp_set_obj_dir(glp_prob *lp, int dir)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_obj_dir: operation not allowed\\n\");\n     if (!(dir == GLP_MIN || dir == GLP_MAX))\n         xerror(\"glp_set_obj_dir: dir = %d; invalid direction flag\\n\",\n            dir);\n      lp->dir = dir;\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "glp_add_rows": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "int glp_add_rows(glp_prob *lp, int nrs)\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      int m_new, i;\n      /* determine new number of rows */\n      if (nrs < 1)\n         xerror(\"glp_add_rows: nrs = %d; invalid number of rows\\n\",\n            nrs);\n      if (nrs > M_MAX - lp->m)\n         xerror(\"glp_add_rows: nrs = %d; too many rows\\n\", nrs);\n      m_new = lp->m + nrs;\n      /* increase the room, if necessary */\n      if (lp->m_max < m_new)\n      {  GLPROW **save = lp->row;\n         while (lp->m_max < m_new)\n         {  lp->m_max += lp->m_max;\n            xassert(lp->m_max > 0);\n         }\n         lp->row = xcalloc(1+lp->m_max, sizeof(GLPROW *));\n         memcpy(&lp->row[1], &save[1], lp->m * sizeof(GLPROW *));\n         xfree(save);\n         /* do not forget about the basis header */\n         xfree(lp->head);\n         lp->head = xcalloc(1+lp->m_max, sizeof(int));\n      }\n      /* add new rows to the end of the row list */\n      for (i = lp->m+1; i <= m_new; i++)\n      {  /* create row descriptor */\n         lp->row[i] = row = dmp_get_atom(lp->pool, sizeof(GLPROW));\n         row->i = i;\n         row->name = NULL;\n         row->node = NULL;\n#if 1 /* 20/IX-2008 */\n         row->level = 0;\n         row->origin = 0;\n         row->klass = 0;\n         if (tree != NULL)\n         {  switch (tree->reason)\n            {  case 0:\n                  break;\n               case GLP_IROWGEN:\n                  xassert(tree->curr != NULL);\n                  row->level = tree->curr->level;\n                  row->origin = GLP_RF_LAZY;\n                  break;\n               case GLP_ICUTGEN:\n                  xassert(tree->curr != NULL);\n                  row->level = tree->curr->level;\n                  row->origin = GLP_RF_CUT;\n                  break;\n               default:\n                  xassert(tree != tree);\n            }\n         }\n#endif\n         row->type = GLP_FR;\n         row->lb = row->ub = 0.0;\n         row->ptr = NULL;\n         row->rii = 1.0;\n         row->stat = GLP_BS;\n#if 0\n         row->bind = -1;\n#else\n         row->bind = 0;\n#endif\n         row->prim = row->dual = 0.0;\n         row->pval = row->dval = 0.0;\n         row->mipx = 0.0;\n      }\n      /* set new number of rows */\n      lp->m = m_new;\n      /* invalidate the basis factorization */\n      lp->valid = 0;\n#if 1\n      if (tree != NULL && tree->reason != 0) tree->reopt = 1;\n#endif\n      /* return the ordinal number of the first row added */\n      return m_new - nrs + 1;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "glp_add_cols": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "int glp_add_cols(glp_prob *lp, int ncs)\n{     glp_tree *tree = lp->tree;\n      GLPCOL *col;\n      int n_new, j;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_add_cols: operation not allowed\\n\");\n      /* determine new number of columns */\n      if (ncs < 1)\n         xerror(\"glp_add_cols: ncs = %d; invalid number of columns\\n\",\n            ncs);\n      if (ncs > N_MAX - lp->n)\n         xerror(\"glp_add_cols: ncs = %d; too many columns\\n\", ncs);\n      n_new = lp->n + ncs;\n      /* increase the room, if necessary */\n      if (lp->n_max < n_new)\n      {  GLPCOL **save = lp->col;\n         while (lp->n_max < n_new)\n         {  lp->n_max += lp->n_max;\n            xassert(lp->n_max > 0);\n         }\n         lp->col = xcalloc(1+lp->n_max, sizeof(GLPCOL *));\n         memcpy(&lp->col[1], &save[1], lp->n * sizeof(GLPCOL *));\n         xfree(save);\n      }\n      /* add new columns to the end of the column list */\n      for (j = lp->n+1; j <= n_new; j++)\n      {  /* create column descriptor */\n         lp->col[j] = col = dmp_get_atom(lp->pool, sizeof(GLPCOL));\n         col->j = j;\n         col->name = NULL;\n         col->node = NULL;\n         col->kind = GLP_CV;\n         col->type = GLP_FX;\n         col->lb = col->ub = 0.0;\n         col->coef = 0.0;\n         col->ptr = NULL;\n         col->sjj = 1.0;\n         col->stat = GLP_NS;\n#if 0\n         col->bind = -1;\n#else\n         col->bind = 0; /* the basis may remain valid */\n#endif\n         col->prim = col->dual = 0.0;\n         col->pval = col->dval = 0.0;\n         col->mipx = 0.0;\n      }\n      /* set new number of columns */\n      lp->n = n_new;\n      /* return the ordinal number of the first column added */\n      return n_new - ncs + 1;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_set_row_name": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "void glp_set_row_name(glp_prob *lp, int i, const char *name)\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_set_row_name: i = %d; row number out of range\\n\",\n            i);\n      row = lp->row[i];\n      if (tree != NULL && tree->reason != 0)\n      {  xassert(tree->curr != NULL);\n         xassert(row->level == tree->curr->level);\n      }\n      if (row->name != NULL)\n      {  if (row->node != NULL)\n         {  xassert(lp->r_tree != NULL);\n            avl_delete_node(lp->r_tree, row->node);\n            row->node = NULL;\n         }\n         dmp_free_atom(lp->pool, row->name, strlen(row->name)+1);\n         row->name = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int k;\n         for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_set_row_name: i = %d; row name too long\\n\",\n                  i);\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_set_row_name: i = %d: row name contains inva\"\n                  \"lid character(s)\\n\", i);\n         }\n         row->name = dmp_get_atom(lp->pool, strlen(name)+1);\n         strcpy(row->name, name);\n         if (lp->r_tree != NULL)\n         {  xassert(row->node == NULL);\n            row->node = avl_insert_node(lp->r_tree, row->name);\n            avl_set_node_link(row->node, row);\n         }\n      }\n      return;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_col_name": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "void glp_set_col_name(glp_prob *lp, int j, const char *name)\n{     glp_tree *tree = lp->tree;\n      GLPCOL *col;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_col_name: operation not allowed\\n\");\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_set_col_name: j = %d; column number out of range\\n\"\n            , j);\n      col = lp->col[j];\n      if (col->name != NULL)\n      {  if (col->node != NULL)\n         {  xassert(lp->c_tree != NULL);\n            avl_delete_node(lp->c_tree, col->node);\n            col->node = NULL;\n         }\n         dmp_free_atom(lp->pool, col->name, strlen(col->name)+1);\n         col->name = NULL;\n      }\n      if (!(name == NULL || name[0] == '\\0'))\n      {  int k;\n         for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_set_col_name: j = %d; column name too long\\n\"\n                  , j);\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_set_col_name: j = %d: column name contains i\"\n                  \"nvalid character(s)\\n\", j);\n         }\n         col->name = dmp_get_atom(lp->pool, strlen(name)+1);\n         strcpy(col->name, name);\n         if (lp->c_tree != NULL && col->name != NULL)\n         {  xassert(col->node == NULL);\n            col->node = avl_insert_node(lp->c_tree, col->name);\n            avl_set_node_link(col->node, col);\n         }\n      }\n      return;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_row_bnds": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "void glp_set_row_bnds(glp_prob *lp, int i, int type, double lb,\n      double ub)\n{     GLPROW *row;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_set_row_bnds: i = %d; row number out of range\\n\",\n            i);\n      row = lp->row[i];\n      row->type = type;\n      switch (type)\n      {  case GLP_FR:\n            row->lb = row->ub = 0.0;\n            if (row->stat != GLP_BS) row->stat = GLP_NF;\n            break;\n         case GLP_LO:\n            row->lb = lb, row->ub = 0.0;\n            if (row->stat != GLP_BS) row->stat = GLP_NL;\n            break;\n         case GLP_UP:\n            row->lb = 0.0, row->ub = ub;\n            if (row->stat != GLP_BS) row->stat = GLP_NU;\n            break;\n         case GLP_DB:\n            row->lb = lb, row->ub = ub;\n            if (!(row->stat == GLP_BS ||\n                  row->stat == GLP_NL || row->stat == GLP_NU))\n               row->stat = (fabs(lb) <= fabs(ub) ? GLP_NL : GLP_NU);\n            break;\n         case GLP_FX:\n            row->lb = row->ub = lb;\n            if (row->stat != GLP_BS) row->stat = GLP_NS;\n            break;\n         default:\n            xerror(\"glp_set_row_bnds: i = %d; type = %d; invalid row ty\"\n               \"pe\\n\", i, type);\n      }\n      return;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_col_bnds": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "void glp_set_col_bnds(glp_prob *lp, int j, int type, double lb,\n      double ub)\n{     GLPCOL *col;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_set_col_bnds: j = %d; column number out of range\\n\"\n            , j);\n      col = lp->col[j];\n      col->type = type;\n      switch (type)\n      {  case GLP_FR:\n            col->lb = col->ub = 0.0;\n            if (col->stat != GLP_BS) col->stat = GLP_NF;\n            break;\n         case GLP_LO:\n            col->lb = lb, col->ub = 0.0;\n            if (col->stat != GLP_BS) col->stat = GLP_NL;\n            break;\n         case GLP_UP:\n            col->lb = 0.0, col->ub = ub;\n            if (col->stat != GLP_BS) col->stat = GLP_NU;\n            break;\n         case GLP_DB:\n            col->lb = lb, col->ub = ub;\n            if (!(col->stat == GLP_BS ||\n                  col->stat == GLP_NL || col->stat == GLP_NU))\n               col->stat = (fabs(lb) <= fabs(ub) ? GLP_NL : GLP_NU);\n            break;\n         case GLP_FX:\n            col->lb = col->ub = lb;\n            if (col->stat != GLP_BS) col->stat = GLP_NS;\n            break;\n         default:\n            xerror(\"glp_set_col_bnds: j = %d; type = %d; invalid column\"\n               \" type\\n\", j, type);\n      }\n      return;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_set_obj_coef": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        694,
        1
      ],
      "content": "void glp_set_obj_coef(glp_prob *lp, int j, double coef)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_obj_coef: operation not allowed\\n\");\n      if (!(0 <= j && j <= lp->n))\n         xerror(\"glp_set_obj_coef: j = %d; column number out of range\\n\"\n            , j);\n      if (j == 0)\n         lp->c0 = coef;\n      else\n         lp->col[j]->coef = coef;\n      return;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_set_mat_row": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "void glp_set_mat_row(glp_prob *lp, int i, int len, const int ind[],\n      const double val[])\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij, *next;\n      int j, k;\n      /* obtain pointer to i-th row */\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_set_mat_row: i = %d; row number out of range\\n\",\n            i);\n      row = lp->row[i];\n      if (tree != NULL && tree->reason != 0)\n      {  xassert(tree->curr != NULL);\n         xassert(row->level == tree->curr->level);\n      }\n      /* remove all existing elements from i-th row */\n      while (row->ptr != NULL)\n      {  /* take next element in the row */\n         aij = row->ptr;\n         /* remove the element from the row list */\n         row->ptr = aij->r_next;\n         /* obtain pointer to corresponding column */\n         col = aij->col;\n         /* remove the element from the column list */\n         if (aij->c_prev == NULL)\n            col->ptr = aij->c_next;\n         else\n            aij->c_prev->c_next = aij->c_next;\n         if (aij->c_next == NULL)\n            ;\n         else\n            aij->c_next->c_prev = aij->c_prev;\n         /* return the element to the memory pool */\n         dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n         /* if the corresponding column is basic, invalidate the basis\n            factorization */\n         if (col->stat == GLP_BS) lp->valid = 0;\n      }\n      /* store new contents of i-th row */\n      if (!(0 <= len && len <= lp->n))\n         xerror(\"glp_set_mat_row: i = %d; len = %d; invalid row length \"\n            \"\\n\", i, len);\n      if (len > NNZ_MAX - lp->nnz)\n         xerror(\"glp_set_mat_row: i = %d; len = %d; too many constraint\"\n            \" coefficients\\n\", i, len);\n      for (k = 1; k <= len; k++)\n      {  /* take number j of corresponding column */\n         j = ind[k];\n         /* obtain pointer to j-th column */\n         if (!(1 <= j && j <= lp->n))\n            xerror(\"glp_set_mat_row: i = %d; ind[%d] = %d; column index\"\n               \" out of range\\n\", i, k, j);\n         col = lp->col[j];\n         /* if there is element with the same column index, it can only\n            be found in the beginning of j-th column list */\n         if (col->ptr != NULL && col->ptr->row->i == i)\n            xerror(\"glp_set_mat_row: i = %d; ind[%d] = %d; duplicate co\"\n               \"lumn indices not allowed\\n\", i, k, j);\n         /* create new element */\n         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;\n         aij->row = row;\n         aij->col = col;\n         aij->val = val[k];\n         /* add the new element to the beginning of i-th row and j-th\n            column lists */\n         aij->r_prev = NULL;\n         aij->r_next = row->ptr;\n         aij->c_prev = NULL;\n         aij->c_next = col->ptr;\n         if (aij->r_next != NULL) aij->r_next->r_prev = aij;\n         if (aij->c_next != NULL) aij->c_next->c_prev = aij;\n         row->ptr = col->ptr = aij;\n         /* if the corresponding column is basic, invalidate the basis\n            factorization */\n         if (col->stat == GLP_BS && aij->val != 0.0) lp->valid = 0;\n      }\n      /* remove zero elements from i-th row */\n      for (aij = row->ptr; aij != NULL; aij = next)\n      {  next = aij->r_next;\n         if (aij->val == 0.0)\n         {  /* remove the element from the row list */\n            if (aij->r_prev == NULL)\n               row->ptr = next;\n            else\n               aij->r_prev->r_next = next;\n            if (next == NULL)\n               ;\n            else\n               next->r_prev = aij->r_prev;\n            /* remove the element from the column list */\n            xassert(aij->c_prev == NULL);\n            aij->col->ptr = aij->c_next;\n            if (aij->c_next != NULL) aij->c_next->c_prev = NULL;\n            /* return the element to the memory pool */\n            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n         }\n      }\n      return;\n}",
      "lines": 100,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "glp_set_mat_col": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "void glp_set_mat_col(glp_prob *lp, int j, int len, const int ind[],\n      const double val[])\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij, *next;\n      int i, k;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_set_mat_col: operation not allowed\\n\");\n      /* obtain pointer to j-th column */\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_set_mat_col: j = %d; column number out of range\\n\",\n            j);\n      col = lp->col[j];\n      /* remove all existing elements from j-th column */\n      while (col->ptr != NULL)\n      {  /* take next element in the column */\n         aij = col->ptr;\n         /* remove the element from the column list */\n         col->ptr = aij->c_next;\n         /* obtain pointer to corresponding row */\n         row = aij->row;\n         /* remove the element from the row list */\n         if (aij->r_prev == NULL)\n            row->ptr = aij->r_next;\n         else\n            aij->r_prev->r_next = aij->r_next;\n         if (aij->r_next == NULL)\n            ;\n         else\n            aij->r_next->r_prev = aij->r_prev;\n         /* return the element to the memory pool */\n         dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n      }\n      /* store new contents of j-th column */\n      if (!(0 <= len && len <= lp->m))\n         xerror(\"glp_set_mat_col: j = %d; len = %d; invalid column leng\"\n            \"th\\n\", j, len);\n      if (len > NNZ_MAX - lp->nnz)\n         xerror(\"glp_set_mat_col: j = %d; len = %d; too many constraint\"\n            \" coefficients\\n\", j, len);\n      for (k = 1; k <= len; k++)\n      {  /* take number i of corresponding row */\n         i = ind[k];\n         /* obtain pointer to i-th row */\n         if (!(1 <= i && i <= lp->m))\n            xerror(\"glp_set_mat_col: j = %d; ind[%d] = %d; row index ou\"\n               \"t of range\\n\", j, k, i);\n         row = lp->row[i];\n         /* if there is element with the same row index, it can only be\n            found in the beginning of i-th row list */\n         if (row->ptr != NULL && row->ptr->col->j == j)\n            xerror(\"glp_set_mat_col: j = %d; ind[%d] = %d; duplicate ro\"\n               \"w indices not allowed\\n\", j, k, i);\n         /* create new element */\n         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;\n         aij->row = row;\n         aij->col = col;\n         aij->val = val[k];\n         /* add the new element to the beginning of i-th row and j-th\n            column lists */\n         aij->r_prev = NULL;\n         aij->r_next = row->ptr;\n         aij->c_prev = NULL;\n         aij->c_next = col->ptr;\n         if (aij->r_next != NULL) aij->r_next->r_prev = aij;\n         if (aij->c_next != NULL) aij->c_next->c_prev = aij;\n         row->ptr = col->ptr = aij;\n      }\n      /* remove zero elements from j-th column */\n      for (aij = col->ptr; aij != NULL; aij = next)\n      {  next = aij->c_next;\n         if (aij->val == 0.0)\n         {  /* remove the element from the row list */\n            xassert(aij->r_prev == NULL);\n            aij->row->ptr = aij->r_next;\n            if (aij->r_next != NULL) aij->r_next->r_prev = NULL;\n            /* remove the element from the column list */\n            if (aij->c_prev == NULL)\n               col->ptr = next;\n            else\n               aij->c_prev->c_next = next;\n            if (next == NULL)\n               ;\n            else\n               next->c_prev = aij->c_prev;\n            /* return the element to the memory pool */\n            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n         }\n      }\n      /* if j-th column is basic, invalidate the basis factorization */\n      if (col->stat == GLP_BS) lp->valid = 0;\n      return;\n}",
      "lines": 94,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "glp_load_matrix": {
      "start_point": [
        970,
        0
      ],
      "end_point": [
        1076,
        1
      ],
      "content": "void glp_load_matrix(glp_prob *lp, int ne, const int ia[],\n      const int ja[], const double ar[])\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij, *next;\n      int i, j, k;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_load_matrix: operation not allowed\\n\");\n      /* clear the constraint matrix */\n      for (i = 1; i <= lp->m; i++)\n      {  row = lp->row[i];\n         while (row->ptr != NULL)\n         {  aij = row->ptr;\n            row->ptr = aij->r_next;\n            dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n         }\n      }\n      xassert(lp->nnz == 0);\n      for (j = 1; j <= lp->n; j++) lp->col[j]->ptr = NULL;\n      /* load the new contents of the constraint matrix and build its\n         row lists */\n      if (ne < 0)\n         xerror(\"glp_load_matrix: ne = %d; invalid number of constraint\"\n            \" coefficients\\n\", ne);\n      if (ne > NNZ_MAX)\n         xerror(\"glp_load_matrix: ne = %d; too many constraint coeffici\"\n            \"ents\\n\", ne);\n      for (k = 1; k <= ne; k++)\n      {  /* take indices of new element */\n         i = ia[k], j = ja[k];\n         /* obtain pointer to i-th row */\n         if (!(1 <= i && i <= lp->m))\n            xerror(\"glp_load_matrix: ia[%d] = %d; row index out of rang\"\n               \"e\\n\", k, i);\n         row = lp->row[i];\n         /* obtain pointer to j-th column */\n         if (!(1 <= j && j <= lp->n))\n            xerror(\"glp_load_matrix: ja[%d] = %d; column index out of r\"\n               \"ange\\n\", k, j);\n         col = lp->col[j];\n         /* create new element */\n         aij = dmp_get_atom(lp->pool, sizeof(GLPAIJ)), lp->nnz++;\n         aij->row = row;\n         aij->col = col;\n         aij->val = ar[k];\n         /* add the new element to the beginning of i-th row list */\n         aij->r_prev = NULL;\n         aij->r_next = row->ptr;\n         if (aij->r_next != NULL) aij->r_next->r_prev = aij;\n         row->ptr = aij;\n      }\n      xassert(lp->nnz == ne);\n      /* build column lists of the constraint matrix and check elements\n         with identical indices */\n      for (i = 1; i <= lp->m; i++)\n      {  for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  /* obtain pointer to corresponding column */\n            col = aij->col;\n            /* if there is element with identical indices, it can only\n               be found in the beginning of j-th column list */\n            if (col->ptr != NULL && col->ptr->row->i == i)\n            {  for (k = 1; k <= ne; k++)\n                  if (ia[k] == i && ja[k] == col->j) break;\n               xerror(\"glp_load_mat: ia[%d] = %d; ja[%d] = %d; duplicat\"\n                  \"e indices not allowed\\n\", k, i, k, col->j);\n            }\n            /* add the element to the beginning of j-th column list */\n            aij->c_prev = NULL;\n            aij->c_next = col->ptr;\n            if (aij->c_next != NULL) aij->c_next->c_prev = aij;\n            col->ptr = aij;\n         }\n      }\n      /* remove zero elements from the constraint matrix */\n      for (i = 1; i <= lp->m; i++)\n      {  row = lp->row[i];\n         for (aij = row->ptr; aij != NULL; aij = next)\n         {  next = aij->r_next;\n            if (aij->val == 0.0)\n            {  /* remove the element from the row list */\n               if (aij->r_prev == NULL)\n                  row->ptr = next;\n               else\n                  aij->r_prev->r_next = next;\n               if (next == NULL)\n                  ;\n               else\n                  next->r_prev = aij->r_prev;\n               /* remove the element from the column list */\n               if (aij->c_prev == NULL)\n                  aij->col->ptr = aij->c_next;\n               else\n                  aij->c_prev->c_next = aij->c_next;\n               if (aij->c_next == NULL)\n                  ;\n               else\n                  aij->c_next->c_prev = aij->c_prev;\n               /* return the element to the memory pool */\n               dmp_free_atom(lp->pool, aij, sizeof(GLPAIJ)), lp->nnz--;\n            }\n         }\n      }\n      /* invalidate the basis factorization */\n      lp->valid = 0;\n      return;\n}",
      "lines": 107,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "glp_check_dup": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1185,
        1
      ],
      "content": "int glp_check_dup(int m, int n, int ne, const int ia[], const int ja[])\n{     int i, j, k, *ptr, *next, ret;\n      char *flag;\n      if (m < 0)\n         xerror(\"glp_check_dup: m = %d; invalid parameter\\n\");\n      if (n < 0)\n         xerror(\"glp_check_dup: n = %d; invalid parameter\\n\");\n      if (ne < 0)\n         xerror(\"glp_check_dup: ne = %d; invalid parameter\\n\");\n      if (ne > 0 && ia == NULL)\n         xerror(\"glp_check_dup: ia = %p; invalid parameter\\n\", ia);\n      if (ne > 0 && ja == NULL)\n         xerror(\"glp_check_dup: ja = %p; invalid parameter\\n\", ja);\n      for (k = 1; k <= ne; k++)\n      {  i = ia[k], j = ja[k];\n         if (!(1 <= i && i <= m && 1 <= j && j <= n))\n         {  ret = -k;\n            goto done;\n         }\n      }\n      if (m == 0 || n == 0)\n      {  ret = 0;\n         goto done;\n      }\n      /* allocate working arrays */\n      ptr = xcalloc(1+m, sizeof(int));\n      next = xcalloc(1+ne, sizeof(int));\n      flag = xcalloc(1+n, sizeof(char));\n      /* build row lists */\n      for (i = 1; i <= m; i++)\n         ptr[i] = 0;\n      for (k = 1; k <= ne; k++)\n      {  i = ia[k];\n         next[k] = ptr[i];\n         ptr[i] = k;\n      }\n      /* clear column flags */\n      for (j = 1; j <= n; j++)\n         flag[j] = 0;\n      /* check for duplicate elements */\n      for (i = 1; i <= m; i++)\n      {  for (k = ptr[i]; k != 0; k = next[k])\n         {  j = ja[k];\n            if (flag[j])\n            {  /* find first element (i,j) */\n               for (k = 1; k <= ne; k++)\n                  if (ia[k] == i && ja[k] == j) break;\n               xassert(k <= ne);\n               /* find next (duplicate) element (i,j) */\n               for (k++; k <= ne; k++)\n                  if (ia[k] == i && ja[k] == j) break;\n               xassert(k <= ne);\n               ret = +k;\n               goto skip;\n            }\n            flag[j] = 1;\n         }\n         /* clear column flags */\n         for (k = ptr[i]; k != 0; k = next[k])\n            flag[ja[k]] = 0;\n      }\n      /* no duplicate element found */\n      ret = 0;\nskip: /* free working arrays */\n      xfree(ptr);\n      xfree(next);\n      xfree(flag);\ndone: return ret;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "glp_sort_matrix": {
      "start_point": [
        1205,
        0
      ],
      "end_point": [
        1238,
        1
      ],
      "content": "void glp_sort_matrix(glp_prob *P)\n{     GLPAIJ *aij;\n      int i, j;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_sort_matrix: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      /* rebuild row linked lists */\n      for (i = P->m; i >= 1; i--)\n         P->row[i]->ptr = NULL;\n      for (j = P->n; j >= 1; j--)\n      {  for (aij = P->col[j]->ptr; aij != NULL; aij = aij->c_next)\n         {  i = aij->row->i;\n            aij->r_prev = NULL;\n            aij->r_next = P->row[i]->ptr;\n            if (aij->r_next != NULL) aij->r_next->r_prev = aij;\n            P->row[i]->ptr = aij;\n         }\n      }\n      /* rebuild column linked lists */\n      for (j = P->n; j >= 1; j--)\n         P->col[j]->ptr = NULL;\n      for (i = P->m; i >= 1; i--)\n      {  for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  j = aij->col->j;\n            aij->c_prev = NULL;\n            aij->c_next = P->col[j]->ptr;\n            if (aij->c_next != NULL) aij->c_next->c_prev = aij;\n            P->col[j]->ptr = aij;\n         }\n      }\n      return;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_del_rows": {
      "start_point": [
        1260,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "void glp_del_rows(glp_prob *lp, int nrs, const int num[])\n{     glp_tree *tree = lp->tree;\n      GLPROW *row;\n      int i, k, m_new;\n      /* mark rows to be deleted */\n      if (!(1 <= nrs && nrs <= lp->m))\n         xerror(\"glp_del_rows: nrs = %d; invalid number of rows\\n\",\n            nrs);\n      for (k = 1; k <= nrs; k++)\n      {  /* take the number of row to be deleted */\n         i = num[k];\n         /* obtain pointer to i-th row */\n         if (!(1 <= i && i <= lp->m))\n            xerror(\"glp_del_rows: num[%d] = %d; row number out of range\"\n               \"\\n\", k, i);\n         row = lp->row[i];\n         if (tree != NULL && tree->reason != 0)\n         {  if (!(tree->reason == GLP_IROWGEN ||\n                  tree->reason == GLP_ICUTGEN))\n               xerror(\"glp_del_rows: operation not allowed\\n\");\n            xassert(tree->curr != NULL);\n            if (row->level != tree->curr->level)\n               xerror(\"glp_del_rows: num[%d] = %d; invalid attempt to d\"\n                  \"elete row created not in current subproblem\\n\", k,i);\n            if (row->stat != GLP_BS)\n               xerror(\"glp_del_rows: num[%d] = %d; invalid attempt to d\"\n                  \"elete active row (constraint)\\n\", k, i);\n            tree->reinv = 1;\n         }\n         /* check that the row is not marked yet */\n         if (row->i == 0)\n            xerror(\"glp_del_rows: num[%d] = %d; duplicate row numbers n\"\n               \"ot allowed\\n\", k, i);\n         /* erase symbolic name assigned to the row */\n         glp_set_row_name(lp, i, NULL);\n         xassert(row->node == NULL);\n         /* erase corresponding row of the constraint matrix */\n         glp_set_mat_row(lp, i, 0, NULL, NULL);\n         xassert(row->ptr == NULL);\n         /* mark the row to be deleted */\n         row->i = 0;\n      }\n      /* delete all marked rows from the row list */\n      m_new = 0;\n      for (i = 1; i <= lp->m; i++)\n      {  /* obtain pointer to i-th row */\n         row = lp->row[i];\n         /* check if the row is marked */\n         if (row->i == 0)\n         {  /* it is marked, delete it */\n            dmp_free_atom(lp->pool, row, sizeof(GLPROW));\n         }\n         else\n         {  /* it is not marked; keep it */\n            row->i = ++m_new;\n            lp->row[row->i] = row;\n         }\n      }\n      /* set new number of rows */\n      lp->m = m_new;\n      /* invalidate the basis factorization */\n      lp->valid = 0;\n      return;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_del_cols": {
      "start_point": [
        1345,
        0
      ],
      "end_point": [
        1409,
        1
      ],
      "content": "void glp_del_cols(glp_prob *lp, int ncs, const int num[])\n{     glp_tree *tree = lp->tree;\n      GLPCOL *col;\n      int j, k, n_new;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_del_cols: operation not allowed\\n\");\n      /* mark columns to be deleted */\n      if (!(1 <= ncs && ncs <= lp->n))\n         xerror(\"glp_del_cols: ncs = %d; invalid number of columns\\n\",\n            ncs);\n      for (k = 1; k <= ncs; k++)\n      {  /* take the number of column to be deleted */\n         j = num[k];\n         /* obtain pointer to j-th column */\n         if (!(1 <= j && j <= lp->n))\n            xerror(\"glp_del_cols: num[%d] = %d; column number out of ra\"\n               \"nge\", k, j);\n         col = lp->col[j];\n         /* check that the column is not marked yet */\n         if (col->j == 0)\n            xerror(\"glp_del_cols: num[%d] = %d; duplicate column number\"\n               \"s not allowed\\n\", k, j);\n         /* erase symbolic name assigned to the column */\n         glp_set_col_name(lp, j, NULL);\n         xassert(col->node == NULL);\n         /* erase corresponding column of the constraint matrix */\n         glp_set_mat_col(lp, j, 0, NULL, NULL);\n         xassert(col->ptr == NULL);\n         /* mark the column to be deleted */\n         col->j = 0;\n         /* if it is basic, invalidate the basis factorization */\n         if (col->stat == GLP_BS) lp->valid = 0;\n      }\n      /* delete all marked columns from the column list */\n      n_new = 0;\n      for (j = 1; j <= lp->n; j++)\n      {  /* obtain pointer to j-th column */\n         col = lp->col[j];\n         /* check if the column is marked */\n         if (col->j == 0)\n         {  /* it is marked; delete it */\n            dmp_free_atom(lp->pool, col, sizeof(GLPCOL));\n         }\n         else\n         {  /* it is not marked; keep it */\n            col->j = ++n_new;\n            lp->col[col->j] = col;\n         }\n      }\n      /* set new number of columns */\n      lp->n = n_new;\n      /* if the basis header is still valid, adjust it */\n      if (lp->valid)\n      {  int m = lp->m;\n         int *head = lp->head;\n         for (j = 1; j <= n_new; j++)\n         {  k = lp->col[j]->bind;\n            if (k != 0)\n            {  xassert(1 <= k && k <= m);\n               head[k] = m + j;\n            }\n         }\n      }\n      return;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_copy_prob": {
      "start_point": [
        1429,
        0
      ],
      "end_point": [
        1504,
        1
      ],
      "content": "void glp_copy_prob(glp_prob *dest, glp_prob *prob, int names)\n{     glp_tree *tree = dest->tree;\n      glp_bfcp bfcp;\n      int i, j, len, *ind;\n      double *val;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_copy_prob: operation not allowed\\n\");\n      if (dest == prob)\n         xerror(\"glp_copy_prob: copying problem object to itself not al\"\n            \"lowed\\n\");\n      if (!(names == GLP_ON || names == GLP_OFF))\n         xerror(\"glp_copy_prob: names = %d; invalid parameter\\n\",\n            names);\n      glp_erase_prob(dest);\n      if (names && prob->name != NULL)\n         glp_set_prob_name(dest, prob->name);\n      if (names && prob->obj != NULL)\n         glp_set_obj_name(dest, prob->obj);\n      dest->dir = prob->dir;\n      dest->c0 = prob->c0;\n      if (prob->m > 0)\n         glp_add_rows(dest, prob->m);\n      if (prob->n > 0)\n         glp_add_cols(dest, prob->n);\n      glp_get_bfcp(prob, &bfcp);\n      glp_set_bfcp(dest, &bfcp);\n      dest->pbs_stat = prob->pbs_stat;\n      dest->dbs_stat = prob->dbs_stat;\n      dest->obj_val = prob->obj_val;\n      dest->some = prob->some;\n      dest->ipt_stat = prob->ipt_stat;\n      dest->ipt_obj = prob->ipt_obj;\n      dest->mip_stat = prob->mip_stat;\n      dest->mip_obj = prob->mip_obj;\n      for (i = 1; i <= prob->m; i++)\n      {  GLPROW *to = dest->row[i];\n         GLPROW *from = prob->row[i];\n         if (names && from->name != NULL)\n            glp_set_row_name(dest, i, from->name);\n         to->type = from->type;\n         to->lb = from->lb;\n         to->ub = from->ub;\n         to->rii = from->rii;\n         to->stat = from->stat;\n         to->prim = from->prim;\n         to->dual = from->dual;\n         to->pval = from->pval;\n         to->dval = from->dval;\n         to->mipx = from->mipx;\n      }\n      ind = xcalloc(1+prob->m, sizeof(int));\n      val = xcalloc(1+prob->m, sizeof(double));\n      for (j = 1; j <= prob->n; j++)\n      {  GLPCOL *to = dest->col[j];\n         GLPCOL *from = prob->col[j];\n         if (names && from->name != NULL)\n            glp_set_col_name(dest, j, from->name);\n         to->kind = from->kind;\n         to->type = from->type;\n         to->lb = from->lb;\n         to->ub = from->ub;\n         to->coef = from->coef;\n         len = glp_get_mat_col(prob, j, ind, val);\n         glp_set_mat_col(dest, j, len, ind, val);\n         to->sjj = from->sjj;\n         to->stat = from->stat;\n         to->prim = from->prim;\n         to->dual = from->dual;\n         to->pval = from->pval;\n         to->dval = from->dval;\n         to->mipx = from->mipx;\n      }\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_erase_prob": {
      "start_point": [
        1525,
        0
      ],
      "end_point": [
        1532,
        1
      ],
      "content": "void glp_erase_prob(glp_prob *lp)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_erase_prob: operation not allowed\\n\");\n      delete_prob(lp);\n      create_prob(lp);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_delete_prob": {
      "start_point": [
        1578,
        0
      ],
      "end_point": [
        1585,
        1
      ],
      "content": "void glp_delete_prob(glp_prob *lp)\n{     glp_tree *tree = lp->tree;\n      if (tree != NULL && tree->reason != 0)\n         xerror(\"glp_delete_prob: operation not allowed\\n\");\n      delete_prob(lp);\n      xfree(lp);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prob2.c": {
    "glp_get_prob_name": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "const char *glp_get_prob_name(glp_prob *lp)\n{     char *name;\n      name = lp->name;\n      return name;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*glp_get_prob_name(glp_prob *lp)",
        "*"
      ]
    },
    "glp_get_obj_name": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "const char *glp_get_obj_name(glp_prob *lp)\n{     char *name;\n      name = lp->obj;\n      return name;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*glp_get_obj_name(glp_prob *lp)",
        "*"
      ]
    },
    "glp_get_obj_dir": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int glp_get_obj_dir(glp_prob *lp)\n{     int dir = lp->dir;\n      return dir;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_num_rows": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int glp_get_num_rows(glp_prob *lp)\n{     int m = lp->m;\n      return m;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_num_cols": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int glp_get_num_cols(glp_prob *lp)\n{     int n = lp->n;\n      return n;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_row_name": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "const char *glp_get_row_name(glp_prob *lp, int i)\n{     char *name;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_name: i = %d; row number out of range\\n\",\n            i);\n      name = lp->row[i]->name;\n      return name;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*glp_get_row_name(glp_prob *lp, int i)",
        "*"
      ]
    },
    "glp_get_col_name": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "const char *glp_get_col_name(glp_prob *lp, int j)\n{     char *name;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_name: j = %d; column number out of range\\n\"\n            , j);\n      name = lp->col[j]->name;\n      return name;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*glp_get_col_name(glp_prob *lp, int j)",
        "*"
      ]
    },
    "glp_get_row_type": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "int glp_get_row_type(glp_prob *lp, int i)\n{     if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_type: i = %d; row number out of range\\n\",\n            i);\n      return lp->row[i]->type;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_row_lb": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "double glp_get_row_lb(glp_prob *lp, int i)\n{     double lb;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_lb: i = %d; row number out of range\\n\", i);\n      switch (lp->row[i]->type)\n      {  case GLP_FR:\n         case GLP_UP:\n            lb = -DBL_MAX; break;\n         case GLP_LO:\n         case GLP_DB:\n         case GLP_FX:\n            lb = lp->row[i]->lb; break;\n         default:\n            xassert(lp != lp);\n      }\n      return lb;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "glp_get_row_ub": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "double glp_get_row_ub(glp_prob *lp, int i)\n{     double ub;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_ub: i = %d; row number out of range\\n\", i);\n      switch (lp->row[i]->type)\n      {  case GLP_FR:\n         case GLP_LO:\n            ub = +DBL_MAX; break;\n         case GLP_UP:\n         case GLP_DB:\n         case GLP_FX:\n            ub = lp->row[i]->ub; break;\n         default:\n            xassert(lp != lp);\n      }\n      return ub;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "glp_get_col_type": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "int glp_get_col_type(glp_prob *lp, int j)\n{     if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_type: j = %d; column number out of range\\n\"\n            , j);\n      return lp->col[j]->type;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_col_lb": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "double glp_get_col_lb(glp_prob *lp, int j)\n{     double lb;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_lb: j = %d; column number out of range\\n\",\n            j);\n      switch (lp->col[j]->type)\n      {  case GLP_FR:\n         case GLP_UP:\n            lb = -DBL_MAX; break;\n         case GLP_LO:\n         case GLP_DB:\n         case GLP_FX:\n            lb = lp->col[j]->lb; break;\n         default:\n            xassert(lp != lp);\n      }\n      return lb;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "glp_get_col_ub": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "double glp_get_col_ub(glp_prob *lp, int j)\n{     double ub;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_ub: j = %d; column number out of range\\n\",\n            j);\n      switch (lp->col[j]->type)\n      {  case GLP_FR:\n         case GLP_LO:\n            ub = +DBL_MAX; break;\n         case GLP_UP:\n         case GLP_DB:\n         case GLP_FX:\n            ub = lp->col[j]->ub; break;\n         default:\n            xassert(lp != lp);\n      }\n      return ub;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "glp_get_obj_coef": {
      "start_point": [
        382,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "double glp_get_obj_coef(glp_prob *lp, int j)\n{     if (!(0 <= j && j <= lp->n))\n         xerror(\"glp_get_obj_coef: j = %d; column number out of range\\n\"\n            , j);\n      return j == 0 ? lp->c0 : lp->col[j]->coef;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_num_nz": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "int glp_get_num_nz(glp_prob *lp)\n{     int nnz = lp->nnz;\n      return nnz;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_mat_row": {
      "start_point": [
        433,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "int glp_get_mat_row(glp_prob *lp, int i, int ind[], double val[])\n{     GLPAIJ *aij;\n      int len;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_mat_row: i = %d; row number out of range\\n\",\n            i);\n      len = 0;\n      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)\n      {  len++;\n         if (ind != NULL) ind[len] = aij->col->j;\n         if (val != NULL) val[len] = aij->val;\n      }\n      xassert(len <= lp->n);\n      return len;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_mat_col": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "int glp_get_mat_col(glp_prob *lp, int j, int ind[], double val[])\n{     GLPAIJ *aij;\n      int len;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_mat_col: j = %d; column number out of range\\n\",\n            j);\n      len = 0;\n      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)\n      {  len++;\n         if (ind != NULL) ind[len] = aij->row->i;\n         if (val != NULL) val[len] = aij->val;\n      }\n      xassert(len <= lp->m);\n      return len;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prob3.c": {
    "glp_create_index": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void glp_create_index(glp_prob *lp)\n{     GLPROW *row;\n      GLPCOL *col;\n      int i, j;\n      /* create row name index */\n      if (lp->r_tree == NULL)\n      {  lp->r_tree = avl_create_tree(avl_strcmp, NULL);\n         for (i = 1; i <= lp->m; i++)\n         {  row = lp->row[i];\n            xassert(row->node == NULL);\n            if (row->name != NULL)\n            {  row->node = avl_insert_node(lp->r_tree, row->name);\n               avl_set_node_link(row->node, row);\n            }\n         }\n      }\n      /* create column name index */\n      if (lp->c_tree == NULL)\n      {  lp->c_tree = avl_create_tree(avl_strcmp, NULL);\n         for (j = 1; j <= lp->n; j++)\n         {  col = lp->col[j];\n            xassert(col->node == NULL);\n            if (col->name != NULL)\n            {  col->node = avl_insert_node(lp->c_tree, col->name);\n               avl_set_node_link(col->node, col);\n            }\n         }\n      }\n      return;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_find_row": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int glp_find_row(glp_prob *lp, const char *name)\n{     AVLNODE *node;\n      int i = 0;\n      if (lp->r_tree == NULL)\n         xerror(\"glp_find_row: row name index does not exist\\n\");\n      if (!(name == NULL || name[0] == '\\0' || strlen(name) > 255))\n      {  node = avl_find_node(lp->r_tree, name);\n         if (node != NULL)\n            i = ((GLPROW *)avl_get_node_link(node))->i;\n      }\n      return i;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_find_col": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int glp_find_col(glp_prob *lp, const char *name)\n{     AVLNODE *node;\n      int j = 0;\n      if (lp->c_tree == NULL)\n         xerror(\"glp_find_col: column name index does not exist\\n\");\n      if (!(name == NULL || name[0] == '\\0' || strlen(name) > 255))\n      {  node = avl_find_node(lp->c_tree, name);\n         if (node != NULL)\n            j = ((GLPCOL *)avl_get_node_link(node))->j;\n      }\n      return j;\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_delete_index": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void glp_delete_index(glp_prob *lp)\n{     int i, j;\n      /* delete row name index */\n      if (lp->r_tree != NULL)\n      {  for (i = 1; i <= lp->m; i++) lp->row[i]->node = NULL;\n         avl_delete_tree(lp->r_tree), lp->r_tree = NULL;\n      }\n      /* delete column name index */\n      if (lp->c_tree != NULL)\n      {  for (j = 1; j <= lp->n; j++) lp->col[j]->node = NULL;\n         avl_delete_tree(lp->c_tree), lp->c_tree = NULL;\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prob4.c": {
    "glp_set_rii": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void glp_set_rii(glp_prob *lp, int i, double rii)\n{     if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_set_rii: i = %d; row number out of range\\n\", i);\n      if (rii <= 0.0)\n         xerror(\"glp_set_rii: i = %d; rii = %g; invalid scale factor\\n\",\n            i, rii);\n      if (lp->valid && lp->row[i]->rii != rii)\n      {  GLPAIJ *aij;\n         for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  if (aij->col->stat == GLP_BS)\n            {  /* invalidate the basis factorization */\n               lp->valid = 0;\n               break;\n            }\n         }\n      }\n      lp->row[i]->rii = rii;\n      return;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_set_sjj": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void glp_set_sjj(glp_prob *lp, int j, double sjj)\n{     if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_set_sjj: j = %d; column number out of range\\n\", j);\n      if (sjj <= 0.0)\n         xerror(\"glp_set_sjj: j = %d; sjj = %g; invalid scale factor\\n\",\n            j, sjj);\n      if (lp->valid && lp->col[j]->sjj != sjj && lp->col[j]->stat ==\n         GLP_BS)\n      {  /* invalidate the basis factorization */\n         lp->valid = 0;\n      }\n      lp->col[j]->sjj = sjj;\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_get_rii": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "double glp_get_rii(glp_prob *lp, int i)\n{     if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_rii: i = %d; row number out of range\\n\", i);\n      return lp->row[i]->rii;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_sjj": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "double glp_get_sjj(glp_prob *lp, int j)\n{     if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_sjj: j = %d; column number out of range\\n\", j);\n      return lp->col[j]->sjj;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_unscale_prob": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "void glp_unscale_prob(glp_prob *lp)\n{     int m = glp_get_num_rows(lp);\n      int n = glp_get_num_cols(lp);\n      int i, j;\n      for (i = 1; i <= m; i++) glp_set_rii(lp, i, 1.0);\n      for (j = 1; j <= n; j++) glp_set_sjj(lp, j, 1.0);\n      return;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prob5.c": {
    "glp_set_row_stat": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void glp_set_row_stat(glp_prob *lp, int i, int stat)\n{     GLPROW *row;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_set_row_stat: i = %d; row number out of range\\n\",\n            i);\n      if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU ||\n            stat == GLP_NF || stat == GLP_NS))\n         xerror(\"glp_set_row_stat: i = %d; stat = %d; invalid status\\n\",\n            i, stat);\n      row = lp->row[i];\n      if (stat != GLP_BS)\n      {  switch (row->type)\n         {  case GLP_FR: stat = GLP_NF; break;\n            case GLP_LO: stat = GLP_NL; break;\n            case GLP_UP: stat = GLP_NU; break;\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\n            case GLP_FX: stat = GLP_NS; break;\n            default: xassert(row != row);\n         }\n      }\n      if (row->stat == GLP_BS && stat != GLP_BS ||\n          row->stat != GLP_BS && stat == GLP_BS)\n      {  /* invalidate the basis factorization */\n         lp->valid = 0;\n      }\n      row->stat = stat;\n      return;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_set_col_stat": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void glp_set_col_stat(glp_prob *lp, int j, int stat)\n{     GLPCOL *col;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_set_col_stat: j = %d; column number out of range\\n\"\n            , j);\n      if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU ||\n            stat == GLP_NF || stat == GLP_NS))\n         xerror(\"glp_set_col_stat: j = %d; stat = %d; invalid status\\n\",\n            j, stat);\n      col = lp->col[j];\n      if (stat != GLP_BS)\n      {  switch (col->type)\n         {  case GLP_FR: stat = GLP_NF; break;\n            case GLP_LO: stat = GLP_NL; break;\n            case GLP_UP: stat = GLP_NU; break;\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\n            case GLP_FX: stat = GLP_NS; break;\n            default: xassert(col != col);\n         }\n      }\n      if (col->stat == GLP_BS && stat != GLP_BS ||\n          col->stat != GLP_BS && stat == GLP_BS)\n      {  /* invalidate the basis factorization */\n         lp->valid = 0;\n      }\n      col->stat = stat;\n      return;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_std_basis": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void glp_std_basis(glp_prob *lp)\n{     int i, j;\n      /* make all auxiliary variables basic */\n      for (i = 1; i <= lp->m; i++)\n         glp_set_row_stat(lp, i, GLP_BS);\n      /* make all structural variables non-basic */\n      for (j = 1; j <= lp->n; j++)\n      {  GLPCOL *col = lp->col[j];\n         if (col->type == GLP_DB && fabs(col->lb) > fabs(col->ub))\n            glp_set_col_stat(lp, j, GLP_NU);\n         else\n            glp_set_col_stat(lp, j, GLP_NL);\n      }\n      return;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prrngs.c": {
    "format": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static char *format(char buf[13+1], double x)\n{     /* format floating-point number in MPS/360-like style */\n      if (x == -DBL_MAX)\n         strcpy(buf, \"         -Inf\");\n      else if (x == +DBL_MAX)\n         strcpy(buf, \"         +Inf\");\n      else if (fabs(x) <= 999999.99998)\n      {  sprintf(buf, \"%13.5f\", x);\n#if 1\n         if (strcmp(buf, \"      0.00000\") == 0 ||\n             strcmp(buf, \"     -0.00000\") == 0)\n            strcpy(buf, \"       .     \");\n         else if (memcmp(buf, \"      0.\", 8) == 0)\n            memcpy(buf, \"       .\", 8);\n         else if (memcmp(buf, \"     -0.\", 8) == 0)\n            memcpy(buf, \"      -.\", 8);\n#endif\n      }\n      else\n         sprintf(buf, \"%13.6g\", x);\n      return buf;\n}",
      "lines": 22,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*format(char buf[13+1], double x)",
        "*"
      ]
    },
    "glp_print_ranges": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int glp_print_ranges(glp_prob *P, int len, const int list[],\n      int flags, const char *fname)\n{     /* print sensitivity analysis report */\n      glp_file *fp = NULL;\n      GLPROW *row;\n      GLPCOL *col;\n      int m, n, pass, k, t, numb, type, stat, var1, var2, count, page,\n         ret;\n      double lb, ub, slack, coef, prim, dual, value1, value2, coef1,\n         coef2, obj1, obj2;\n      const char *name, *limit;\n      char buf[13+1];\n      /* sanity checks */\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_print_ranges: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      m = P->m, n = P->n;\n      if (len < 0)\n         xerror(\"glp_print_ranges: len = %d; invalid list length\\n\",\n            len);\n      if (len > 0)\n      {  if (list == NULL)\n            xerror(\"glp_print_ranges: list = %p: invalid parameter\\n\",\n               list);\n         for (t = 1; t <= len; t++)\n         {  k = list[t];\n            if (!(1 <= k && k <= m+n))\n               xerror(\"glp_print_ranges: list[%d] = %d; row/column numb\"\n                  \"er out of range\\n\", t, k);\n         }\n      }\n      if (flags != 0)\n         xerror(\"glp_print_ranges: flags = %d; invalid parameter\\n\",\n            flags);\n      if (fname == NULL)\n         xerror(\"glp_print_ranges: fname = %p; invalid parameter\\n\",\n            fname);\n      if (glp_get_status(P) != GLP_OPT)\n      {  xprintf(\"glp_print_ranges: optimal basic solution required\\n\");\n         ret = 1;\n         goto done;\n      }\n      if (!glp_bf_exists(P))\n      {  xprintf(\"glp_print_ranges: basis factorization required\\n\");\n         ret = 2;\n         goto done;\n      }\n      /* start reporting */\n      xprintf(\"Write sensitivity analysis report to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 3;\n         goto done;\n      }\n      page = count = 0;\n      for (pass = 1; pass <= 2; pass++)\n      for (t = 1; t <= (len == 0 ? m+n : len); t++)\n      {  if (t == 1) count = 0;\n         k = (len == 0 ? t : list[t]);\n         if (pass == 1 && k > m || pass == 2 && k <= m)\n            continue;\n         if (count == 0)\n         {  xfprintf(fp, \"GLPK %-4s - SENSITIVITY ANALYSIS REPORT%73sPa\"\n               \"ge%4d\\n\", glp_version(), \"\", ++page);\n            xfprintf(fp, \"\\n\");\n            xfprintf(fp, \"%-12s%s\\n\", \"Problem:\",\n               P->name == NULL ? \"\" : P->name);\n            xfprintf(fp, \"%-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n               P->obj == NULL ? \"\" : P->obj,\n               P->obj == NULL ? \"\" : \" = \", P->obj_val,\n               P->dir == GLP_MIN ? \"MINimum\" :\n               P->dir == GLP_MAX ? \"MAXimum\" : \"???\");\n            xfprintf(fp, \"\\n\");\n            xfprintf(fp, \"%6s %-12s %2s %13s %13s %13s  %13s %13s %13s \"\n               \"%s\\n\", \"No.\", pass == 1 ? \"Row name\" : \"Column name\",\n               \"St\", \"Activity\", pass == 1 ? \"Slack\" : \"Obj coef\",\n               \"Lower bound\", \"Activity\", \"Obj coef\", \"Obj value at\",\n               \"Limiting\");\n            xfprintf(fp, \"%6s %-12s %2s %13s %13s %13s  %13s %13s %13s \"\n               \"%s\\n\", \"\", \"\", \"\", \"\", \"Marginal\", \"Upper bound\",\n               \"range\", \"range\", \"break point\", \"variable\");\n            xfprintf(fp, \"------ ------------ -- ------------- --------\"\n               \"----- -------------  ------------- ------------- ------\"\n               \"------- ------------\\n\");\n         }\n         if (pass == 1)\n         {  numb = k;\n            xassert(1 <= numb && numb <= m);\n            row = P->row[numb];\n            name = row->name;\n            type = row->type;\n            lb = glp_get_row_lb(P, numb);\n            ub = glp_get_row_ub(P, numb);\n            coef = 0.0;\n            stat = row->stat;\n            prim = row->prim;\n            if (type == GLP_FR)\n               slack = - prim;\n            else if (type == GLP_LO)\n               slack = lb - prim;\n            else if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n               slack = ub - prim;\n            dual = row->dual;\n         }\n         else\n         {  numb = k - m;\n            xassert(1 <= numb && numb <= n);\n            col = P->col[numb];\n            name = col->name;\n            lb = glp_get_col_lb(P, numb);\n            ub = glp_get_col_ub(P, numb);\n            coef = col->coef;\n            stat = col->stat;\n            prim = col->prim;\n            slack = 0.0;\n            dual = col->dual;\n         }\n         if (stat != GLP_BS)\n         {  glp_analyze_bound(P, k, &value1, &var1, &value2, &var2);\n            if (stat == GLP_NF)\n               coef1 = coef2 = coef;\n            else if (stat == GLP_NS)\n               coef1 = -DBL_MAX, coef2 = +DBL_MAX;\n            else if (stat == GLP_NL && P->dir == GLP_MIN ||\n                     stat == GLP_NU && P->dir == GLP_MAX)\n               coef1 = coef - dual, coef2 = +DBL_MAX;\n            else\n               coef1 = -DBL_MAX, coef2 = coef - dual;\n            if (value1 == -DBL_MAX)\n            {  if (dual < -1e-9)\n                  obj1 = +DBL_MAX;\n               else if (dual > +1e-9)\n                  obj1 = -DBL_MAX;\n               else\n                  obj1 = P->obj_val;\n            }\n            else\n               obj1 = P->obj_val + dual * (value1 - prim);\n            if (value2 == +DBL_MAX)\n            {  if (dual < -1e-9)\n                  obj2 = -DBL_MAX;\n               else if (dual > +1e-9)\n                  obj2 = +DBL_MAX;\n               else\n                  obj2 = P->obj_val;\n            }\n            else\n               obj2 = P->obj_val + dual * (value2 - prim);\n         }\n         else\n         {  glp_analyze_coef(P, k, &coef1, &var1, &value1, &coef2,\n               &var2, &value2);\n            if (coef1 == -DBL_MAX)\n            {  if (prim < -1e-9)\n                  obj1 = +DBL_MAX;\n               else if (prim > +1e-9)\n                  obj1 = -DBL_MAX;\n               else\n                  obj1 = P->obj_val;\n            }\n            else\n               obj1 = P->obj_val + (coef1 - coef) * prim;\n            if (coef2 == +DBL_MAX)\n            {  if (prim < -1e-9)\n                  obj2 = -DBL_MAX;\n               else if (prim > +1e-9)\n                  obj2 = +DBL_MAX;\n               else\n                  obj2 = P->obj_val;\n            }\n            else\n               obj2 = P->obj_val + (coef2 - coef) * prim;\n         }\n         /*** first line ***/\n         /* row/column number */\n         xfprintf(fp, \"%6d\", numb);\n         /* row/column name */\n         xfprintf(fp, \" %-12.12s\", name == NULL ? \"\" : name);\n         if (name != NULL && strlen(name) > 12)\n            xfprintf(fp, \"%s\\n%6s %12s\", name+12, \"\", \"\");\n         /* row/column status */\n         xfprintf(fp, \" %2s\",\n            stat == GLP_BS ? \"BS\" : stat == GLP_NL ? \"NL\" :\n            stat == GLP_NU ? \"NU\" : stat == GLP_NF ? \"NF\" :\n            stat == GLP_NS ? \"NS\" : \"??\");\n         /* row/column activity */\n         xfprintf(fp, \" %s\", format(buf, prim));\n         /* row slack, column objective coefficient */\n         xfprintf(fp, \" %s\", format(buf, k <= m ? slack : coef));\n         /* row/column lower bound */\n         xfprintf(fp, \" %s\", format(buf, lb));\n         /* row/column activity range */\n         xfprintf(fp, \"  %s\", format(buf, value1));\n         /* row/column objective coefficient range */\n         xfprintf(fp, \" %s\", format(buf, coef1));\n         /* objective value at break point */\n         xfprintf(fp, \" %s\", format(buf, obj1));\n         /* limiting variable name */\n         if (var1 != 0)\n         {  if (var1 <= m)\n               limit = glp_get_row_name(P, var1);\n            else\n               limit = glp_get_col_name(P, var1 - m);\n            if (limit != NULL)\n               xfprintf(fp, \" %s\", limit);\n         }\n         xfprintf(fp, \"\\n\");\n         /*** second line ***/\n         xfprintf(fp, \"%6s %-12s %2s %13s\", \"\", \"\", \"\", \"\");\n         /* row/column reduced cost */\n         xfprintf(fp, \" %s\", format(buf, dual));\n         /* row/column upper bound */\n         xfprintf(fp, \" %s\", format(buf, ub));\n         /* row/column activity range */\n         xfprintf(fp, \"  %s\", format(buf, value2));\n         /* row/column objective coefficient range */\n         xfprintf(fp, \" %s\", format(buf, coef2));\n         /* objective value at break point */\n         xfprintf(fp, \" %s\", format(buf, obj2));\n         /* limiting variable name */\n         if (var2 != 0)\n         {  if (var2 <= m)\n               limit = glp_get_row_name(P, var2);\n            else\n               limit = glp_get_col_name(P, var2 - m);\n            if (limit != NULL)\n               xfprintf(fp, \" %s\", limit);\n         }\n         xfprintf(fp, \"\\n\");\n         xfprintf(fp, \"\\n\");\n         /* print 10 items per page */\n         count = (count + 1) % 10;\n      }\n      xfprintf(fp, \"End of report\\n\");\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 4;\n         goto done;\n      }\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 249,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/prsol.c": {
    "glp_print_sol": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "int glp_print_sol(glp_prob *P, const char *fname)\n{     /* write basic solution in printable format */\n      glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, t, ae_ind, re_ind, ret;\n      double ae_max, re_max;\n      xprintf(\"Writing basic solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"%-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name);\n      xfprintf(fp, \"%-12s%d\\n\", \"Rows:\", P->m);\n      xfprintf(fp, \"%-12s%d\\n\", \"Columns:\", P->n);\n      xfprintf(fp, \"%-12s%d\\n\", \"Non-zeros:\", P->nnz);\n      t = glp_get_status(P);\n      xfprintf(fp, \"%-12s%s\\n\", \"Status:\",\n         t == GLP_OPT    ? \"OPTIMAL\" :\n         t == GLP_FEAS   ? \"FEASIBLE\" :\n         t == GLP_INFEAS ? \"INFEASIBLE (INTERMEDIATE)\" :\n         t == GLP_NOFEAS ? \"INFEASIBLE (FINAL)\" :\n         t == GLP_UNBND  ? \"UNBOUNDED\" :\n         t == GLP_UNDEF  ? \"UNDEFINED\" : \"???\");\n      xfprintf(fp, \"%-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->obj_val,\n         P->dir == GLP_MIN ? \"MINimum\" :\n         P->dir == GLP_MAX ? \"MAXimum\" : \"???\");\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No.   Row name   St   Activity     Lower bound  \"\n         \" Upper bound    Marginal\\n\");\n      xfprintf(fp, \"------ ------------ -- ------------- ------------- \"\n         \"------------- -------------\\n\");\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         xfprintf(fp, \"%6d \", i);\n         if (row->name == NULL || strlen(row->name) <= 12)\n            xfprintf(fp, \"%-12s \", row->name == NULL ? \"\" : row->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", row->name, \"\");\n         xfprintf(fp, \"%s \",\n            row->stat == GLP_BS ? \"B \" :\n            row->stat == GLP_NL ? \"NL\" :\n            row->stat == GLP_NU ? \"NU\" :\n            row->stat == GLP_NF ? \"NF\" :\n            row->stat == GLP_NS ? \"NS\" : \"??\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(row->prim) <= 1e-9 ? 0.0 : row->prim);\n         if (row->type == GLP_LO || row->type == GLP_DB ||\n             row->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", row->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (row->type == GLP_UP || row->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", row->ub);\n         else\n            xfprintf(fp, \"%13s \", row->type == GLP_FX ? \"=\" : \"\");\n         if (row->stat != GLP_BS)\n         {  if (fabs(row->dual) <= 1e-9)\n               xfprintf(fp, \"%13s\", \"< eps\");\n            else\n               xfprintf(fp, \"%13.6g \", row->dual);\n         }\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"   No. Column name  St   Activity     Lower bound  \"\n         \" Upper bound    Marginal\\n\");\n      xfprintf(fp, \"------ ------------ -- ------------- ------------- \"\n         \"------------- -------------\\n\");\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         xfprintf(fp, \"%6d \", j);\n         if (col->name == NULL || strlen(col->name) <= 12)\n            xfprintf(fp, \"%-12s \", col->name == NULL ? \"\" : col->name);\n         else\n            xfprintf(fp, \"%s\\n%20s\", col->name, \"\");\n         xfprintf(fp, \"%s \",\n            col->stat == GLP_BS ? \"B \" :\n            col->stat == GLP_NL ? \"NL\" :\n            col->stat == GLP_NU ? \"NU\" :\n            col->stat == GLP_NF ? \"NF\" :\n            col->stat == GLP_NS ? \"NS\" : \"??\");\n         xfprintf(fp, \"%13.6g \",\n            fabs(col->prim) <= 1e-9 ? 0.0 : col->prim);\n         if (col->type == GLP_LO || col->type == GLP_DB ||\n             col->type == GLP_FX)\n            xfprintf(fp, \"%13.6g \", col->lb);\n         else\n            xfprintf(fp, \"%13s \", \"\");\n         if (col->type == GLP_UP || col->type == GLP_DB)\n            xfprintf(fp, \"%13.6g \", col->ub);\n         else\n            xfprintf(fp, \"%13s \", col->type == GLP_FX ? \"=\" : \"\");\n         if (col->stat != GLP_BS)\n         {  if (fabs(col->dual) <= 1e-9)\n               xfprintf(fp, \"%13s\", \"< eps\");\n            else\n               xfprintf(fp, \"%13.6g \", col->dual);\n         }\n         xfprintf(fp, \"\\n\");\n      }\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"Karush-Kuhn-Tucker optimality conditions:\\n\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_SOL, GLP_KKT_PE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PE: max.abs.err = %.2e on row %d\\n\",\n         ae_max, ae_ind);\n      xfprintf(fp, \"        max.rel.err = %.2e on row %d\\n\",\n         re_max, re_ind);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"PRIMAL SOLUTION IS WRONG\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_SOL, GLP_KKT_PB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.PB: max.abs.err = %.2e on %s %d\\n\",\n            ae_max, ae_ind <= P->m ? \"row\" : \"column\",\n            ae_ind <= P->m ? ae_ind : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on %s %d\\n\",\n            re_max, re_ind <= P->m ? \"row\" : \"column\",\n            re_ind <= P->m ? re_ind : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"PRIMAL SOLUTION IS INFEASIBL\"\n            \"E\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_SOL, GLP_KKT_DE, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.DE: max.abs.err = %.2e on column %d\\n\",\n         ae_max, ae_ind == 0 ? 0 : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on column %d\\n\",\n         re_max, re_ind == 0 ? 0 : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"DUAL SOLUTION IS WRONG\");\n      xfprintf(fp, \"\\n\");\n      glp_check_kkt(P, GLP_SOL, GLP_KKT_DB, &ae_max, &ae_ind, &re_max,\n         &re_ind);\n      xfprintf(fp, \"KKT.DB: max.abs.err = %.2e on %s %d\\n\",\n            ae_max, ae_ind <= P->m ? \"row\" : \"column\",\n            ae_ind <= P->m ? ae_ind : ae_ind - P->m);\n      xfprintf(fp, \"        max.rel.err = %.2e on %s %d\\n\",\n            re_max, re_ind <= P->m ? \"row\" : \"column\",\n            re_ind <= P->m ? re_ind : re_ind - P->m);\n      xfprintf(fp, \"%8s%s\\n\", \"\",\n         re_max <= 1e-9 ? \"High quality\" :\n         re_max <= 1e-6 ? \"Medium quality\" :\n         re_max <= 1e-3 ? \"Low quality\" : \"DUAL SOLUTION IS INFEASIBLE\")\n            ;\n      xfprintf(fp, \"\\n\");\n      xfprintf(fp, \"End of output\\n\");\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 172,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdasn.c": {
    "glp_read_asnprob": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int glp_read_asnprob(glp_graph *G, int v_set, int a_cost, const char\n      *fname)\n{     DMX _csa, *csa = &_csa;\n      glp_vertex *v;\n      glp_arc *a;\n      int nv, na, n1, i, j, k, ret = 0;\n      double cost;\n      char *flag = NULL;\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_read_asnprob: v_set = %d; invalid offset\\n\",\n            v_set);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_read_asnprob: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      glp_erase_graph(G, G->v_size, G->a_size);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading assignment problem data from '%s'...\\n\", fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"asn\") != 0)\n         error(csa, \"wrong problem designator; 'asn' expected\");\n      read_field(csa);\n      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))\n         error(csa, \"number of nodes missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &na) == 0 && na >= 0))\n         error(csa, \"number of arcs missing or invalid\");\n      if (nv > 0) glp_add_vertices(G, nv);\n      end_of_line(csa);\n      /* read node descriptor lines */\n      flag = xcalloc(1+nv, sizeof(char));\n      memset(&flag[1], 0, nv * sizeof(char));\n      n1 = 0;\n      for (;;)\n      {  read_designator(csa);\n         if (strcmp(csa->field, \"n\") != 0) break;\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"node number %d out of range\", i);\n         if (flag[i])\n            error(csa, \"duplicate descriptor of node %d\", i);\n         flag[i] = 1, n1++;\n         end_of_line(csa);\n      }\n      xprintf(\n         \"Assignment problem has %d + %d = %d node%s and %d arc%s\\n\",\n         n1, nv - n1, nv, nv == 1 ? \"\" : \"s\", na, na == 1 ? \"\" : \"s\");\n      if (v_set >= 0)\n      {  for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            k = (flag[i] ? 0 : 1);\n            memcpy((char *)v->data + v_set, &k, sizeof(int));\n         }\n      }\n      /* read arc descriptor lines */\n      for (k = 1; k <= na; k++)\n      {  if (k > 1) read_designator(csa);\n         if (strcmp(csa->field, \"a\") != 0)\n            error(csa, \"wrong line designator; 'a' expected\");\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"starting node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"starting node number %d out of range\", i);\n         if (!flag[i])\n            error(csa, \"node %d cannot be a starting node\", i);\n         read_field(csa);\n         if (str2int(csa->field, &j) != 0)\n            error(csa, \"ending node number missing or invalid\");\n         if (!(1 <= j && j <= nv))\n            error(csa, \"ending node number %d out of range\", j);\n         if (flag[j])\n            error(csa, \"node %d cannot be an ending node\", j);\n         read_field(csa);\n         if (str2num(csa->field, &cost) != 0)\n            error(csa, \"arc cost missing or invalid\");\n         check_int(csa, cost);\n         a = glp_add_arc(G, i, j);\n         if (a_cost >= 0)\n            memcpy((char *)a->data + a_cost, &cost, sizeof(double));\n         end_of_line(csa);\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\ndone: if (ret) glp_erase_graph(G, G->v_size, G->a_size);\n      if (csa->fp != NULL) glp_close(csa->fp);\n      if (flag != NULL) xfree(flag);\n      return ret;\n}",
      "lines": 107,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdcc.c": {
    "glp_read_ccdata": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int glp_read_ccdata(glp_graph *G, int v_wgt, const char *fname)\n{     DMX _csa, *csa = &_csa;\n      glp_vertex *v;\n      int i, j, k, nv, ne, ret = 0;\n      double w;\n      char *flag = NULL;\n      if (v_wgt >= 0 && v_wgt > G->v_size - (int)sizeof(double))\n         xerror(\"glp_read_ccdata: v_wgt = %d; invalid offset\\n\",\n            v_wgt);\n      glp_erase_graph(G, G->v_size, G->a_size);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading graph from '%s'...\\n\", fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"edge\") != 0)\n         error(csa, \"wrong problem designator; 'edge' expected\");\n      read_field(csa);\n      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))\n         error(csa, \"number of vertices missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &ne) == 0 && ne >= 0))\n         error(csa, \"number of edges missing or invalid\");\n      xprintf(\"Graph has %d vert%s and %d edge%s\\n\",\n         nv, nv == 1 ? \"ex\" : \"ices\", ne, ne == 1 ? \"\" : \"s\");\n      if (nv > 0) glp_add_vertices(G, nv);\n      end_of_line(csa);\n      /* read node descriptor lines */\n      flag = xcalloc(1+nv, sizeof(char));\n      memset(&flag[1], 0, nv * sizeof(char));\n      if (v_wgt >= 0)\n      {  w = 1.0;\n         for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_wgt, &w, sizeof(double));\n         }\n      }\n      for (;;)\n      {  read_designator(csa);\n         if (strcmp(csa->field, \"n\") != 0) break;\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"vertex number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"vertex number %d out of range\", i);\n         if (flag[i])\n            error(csa, \"duplicate descriptor of vertex %d\", i);\n         read_field(csa);\n         if (str2num(csa->field, &w) != 0)\n            error(csa, \"vertex weight missing or invalid\");\n         check_int(csa, w);\n         if (v_wgt >= 0)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_wgt, &w, sizeof(double));\n         }\n         flag[i] = 1;\n         end_of_line(csa);\n      }\n      xfree(flag), flag = NULL;\n      /* read edge descriptor lines */\n      for (k = 1; k <= ne; k++)\n      {  if (k > 1) read_designator(csa);\n         if (strcmp(csa->field, \"e\") != 0)\n            error(csa, \"wrong line designator; 'e' expected\");\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"first vertex number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"first vertex number %d out of range\", i);\n         read_field(csa);\n         if (str2int(csa->field, &j) != 0)\n            error(csa, \"second vertex number missing or invalid\");\n         if (!(1 <= j && j <= nv))\n            error(csa, \"second vertex number %d out of range\", j);\n         glp_add_arc(G, i, j);\n         end_of_line(csa);\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\ndone: if (ret) glp_erase_graph(G, G->v_size, G->a_size);\n      if (csa->fp != NULL) glp_close(csa->fp);\n      if (flag != NULL) xfree(flag);\n      return ret;\n}",
      "lines": 99,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glp_read_graph": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int glp_read_graph(glp_graph *G, const char *fname)\n{     return\n         glp_read_ccdata(G, -1, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdcnf.c": {
    "glp_read_cnfsat": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int glp_read_cnfsat(glp_prob *P, const char *fname)\n{     /* read CNF-SAT problem data in DIMACS format */\n      DMX _csa, *csa = &_csa;\n      int m, n, i, j, len, neg, rhs, ret = 0, *ind = NULL;\n      double *val = NULL;\n      char *map = NULL;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_read_cnfsat: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_read_cnfsat: fname = %p; invalid parameter\\n\",\n            fname);\n      glp_erase_prob(P);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading CNF-SAT problem data from '%s'...\\n\", fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"cnf\") != 0)\n         error(csa, \"wrong problem designator; 'cnf' expected\\n\");\n      read_field(csa);\n      if (!(str2int(csa->field, &n) == 0 && n >= 0))\n         error(csa, \"number of variables missing or invalid\\n\");\n      read_field(csa);\n      if (!(str2int(csa->field, &m) == 0 && m >= 0))\n         error(csa, \"number of clauses missing or invalid\\n\");\n      xprintf(\"Instance has %d variable%s and %d clause%s\\n\",\n         n, n == 1 ? \"\" : \"s\", m, m == 1 ? \"\" : \"s\");\n      end_of_line(csa);\n      if (m > 0)\n         glp_add_rows(P, m);\n      if (n > 0)\n      {  glp_add_cols(P, n);\n         for (j = 1; j <= n; j++)\n            glp_set_col_kind(P, j, GLP_BV);\n      }\n      /* allocate working arrays */\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      map = xcalloc(1+n, sizeof(char));\n      for (j = 1; j <= n; j++) map[j] = 0;\n      /* read clauses */\n      for (i = 1; i <= m; i++)\n      {  /* read i-th clause */\n         len = 0, rhs = 1;\n         for (;;)\n         {  /* skip white-space characters */\n            while (csa->c == ' ' || csa->c == '\\n')\n               read_char(csa);\n            /* read term */\n            read_field(csa);\n            if (str2int(csa->field, &j) != 0)\n               error(csa, \"variable number missing or invalid\\n\");\n            if (j > 0)\n               neg = 0;\n            else if (j < 0)\n               neg = 1, j = -j, rhs--;\n            else\n               break;\n            if (!(1 <= j && j <= n))\n               error(csa, \"variable number out of range\\n\");\n            if (map[j])\n               error(csa, \"duplicate variable number\\n\");\n            len++, ind[len] = j, val[len] = (neg ? -1.0 : +1.0);\n            map[j] = 1;\n         }\n         glp_set_row_bnds(P, i, GLP_LO, (double)rhs, 0.0);\n         glp_set_mat_row(P, i, len, ind, val);\n         while (len > 0) map[ind[len--]] = 0;\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\n      /* problem data has been successfully read */\n      glp_sort_matrix(P);\ndone: if (csa->fp != NULL) glp_close(csa->fp);\n      if (ind != NULL) xfree(ind);\n      if (val != NULL) xfree(val);\n      if (map != NULL) xfree(map);\n      if (ret) glp_erase_prob(P);\n      return ret;\n}",
      "lines": 98,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdipt.c": {
    "glp_read_ipt": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int glp_read_ipt(glp_prob *P, const char *fname)\n{     DMX dmx_, *dmx = &dmx_;\n      int i, j, k, m, n, sst, ret = 1;\n      char *stat = NULL;\n      double obj, *prim = NULL, *dual = NULL;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_read_ipt: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_read_ipt: fname = %d; invalid parameter\\n\", fname);\n      if (setjmp(dmx->jump))\n         goto done;\n      dmx->fname = fname;\n      dmx->fp = NULL;\n      dmx->count = 0;\n      dmx->c = '\\n';\n      dmx->field[0] = '\\0';\n      dmx->empty = dmx->nonint = 0;\n      xprintf(\"Reading interior-point solution from '%s'...\\n\", fname);\n      dmx->fp = glp_open(fname, \"r\");\n      if (dmx->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* read solution line */\n      dmx_read_designator(dmx);\n      if (strcmp(dmx->field, \"s\") != 0)\n         dmx_error(dmx, \"solution line missing or invalid\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"ipt\") != 0)\n         dmx_error(dmx, \"wrong solution designator; 'ipt' expected\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &m) == 0 && m >= 0))\n         dmx_error(dmx, \"number of rows missing or invalid\");\n      if (m != P->m)\n         dmx_error(dmx, \"number of rows mismatch\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &n) == 0 && n >= 0))\n         dmx_error(dmx, \"number of columns missing or invalid\");\n      if (n != P->n)\n         dmx_error(dmx, \"number of columns mismatch\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"o\") == 0)\n         sst = GLP_OPT;\n      else if (strcmp(dmx->field, \"i\") == 0)\n         sst = GLP_INFEAS;\n      else if (strcmp(dmx->field, \"n\") == 0)\n         sst = GLP_NOFEAS;\n      else if (strcmp(dmx->field, \"u\") == 0)\n         sst = GLP_UNDEF;\n      else\n         dmx_error(dmx, \"solution status missing or invalid\");\n      dmx_read_field(dmx);\n      if (str2num(dmx->field, &obj) != 0)\n         dmx_error(dmx, \"objective value missing or invalid\");\n      dmx_end_of_line(dmx);\n      /* allocate working arrays */\n      stat = xalloc(1+m+n, sizeof(stat[0]));\n      for (k = 1; k <= m+n; k++)\n         stat[k] = '?';\n      prim = xalloc(1+m+n, sizeof(prim[0]));\n      dual = xalloc(1+m+n, sizeof(dual[0]));\n      /* read solution descriptor lines */\n      for (;;)\n      {  dmx_read_designator(dmx);\n         if (strcmp(dmx->field, \"i\") == 0)\n         {  /* row solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &i) != 0)\n               dmx_error(dmx, \"row number missing or invalid\");\n            if (!(1 <= i && i <= m))\n               dmx_error(dmx, \"row number out of range\");\n            if (stat[i] != '?')\n               dmx_error(dmx, \"duplicate row solution descriptor\");\n            stat[i] = GLP_BS;\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[i]) != 0)\n               dmx_error(dmx, \"row primal value missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &dual[i]) != 0)\n               dmx_error(dmx, \"row dual value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"j\") == 0)\n         {  /* column solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &j) != 0)\n               dmx_error(dmx, \"column number missing or invalid\");\n            if (!(1 <= j && j <= n))\n               dmx_error(dmx, \"column number out of range\");\n            if (stat[m+j] != '?')\n               dmx_error(dmx, \"duplicate column solution descriptor\");\n            stat[m+j] = GLP_BS;\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[m+j]) != 0)\n               dmx_error(dmx, \"column primal value missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &dual[m+j]) != 0)\n               dmx_error(dmx, \"column dual value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"e\") == 0)\n            break;\n         else\n            dmx_error(dmx, \"line designator missing or invalid\");\n         dmx_end_of_line(dmx);\n      }\n      /* store solution components into problem object */\n      for (k = 1; k <= m+n; k++)\n      {  if (stat[k] == '?')\n            dmx_error(dmx, \"incomplete interior-point solution\");\n      }\n      P->ipt_stat = sst;\n      P->ipt_obj = obj;\n      for (i = 1; i <= m; i++)\n      {  P->row[i]->pval = prim[i];\n         P->row[i]->dval = dual[i];\n      }\n      for (j = 1; j <= n; j++)\n      {  P->col[j]->pval = prim[m+j];\n         P->col[j]->dval = dual[m+j];\n      }\n      /* interior-point solution has been successfully read */\n      xprintf(\"%d lines were read\\n\", dmx->count);\n      ret = 0;\ndone: if (dmx->fp != NULL)\n         glp_close(dmx->fp);\n      if (stat != NULL)\n         xfree(stat);\n      if (prim != NULL)\n         xfree(prim);\n      if (dual != NULL)\n         xfree(dual);\n      return ret;\n}",
      "lines": 136,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdmaxf.c": {
    "glp_read_maxflow": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "int glp_read_maxflow(glp_graph *G, int *_s, int *_t, int a_cap,\n      const char *fname)\n{     DMX _csa, *csa = &_csa;\n      glp_arc *a;\n      int i, j, k, s, t, nv, na, ret = 0;\n      double cap;\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_read_maxflow: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      glp_erase_graph(G, G->v_size, G->a_size);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading maximum flow problem data from '%s'...\\n\",\n         fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"max\") != 0)\n         error(csa, \"wrong problem designator; 'max' expected\");\n      read_field(csa);\n      if (!(str2int(csa->field, &nv) == 0 && nv >= 2))\n         error(csa, \"number of nodes missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &na) == 0 && na >= 0))\n         error(csa, \"number of arcs missing or invalid\");\n      xprintf(\"Flow network has %d node%s and %d arc%s\\n\",\n         nv, nv == 1 ? \"\" : \"s\", na, na == 1 ? \"\" : \"s\");\n      if (nv > 0) glp_add_vertices(G, nv);\n      end_of_line(csa);\n      /* read node descriptor lines */\n      s = t = 0;\n      for (;;)\n      {  read_designator(csa);\n         if (strcmp(csa->field, \"n\") != 0) break;\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"node number %d out of range\", i);\n         read_field(csa);\n         if (strcmp(csa->field, \"s\") == 0)\n         {  if (s > 0)\n               error(csa, \"only one source node allowed\");\n            s = i;\n         }\n         else if (strcmp(csa->field, \"t\") == 0)\n         {  if (t > 0)\n               error(csa, \"only one sink node allowed\");\n            t = i;\n         }\n         else\n            error(csa, \"wrong node designator; 's' or 't' expected\");\n         if (s > 0 && s == t)\n            error(csa, \"source and sink nodes must be distinct\");\n         end_of_line(csa);\n      }\n      if (s == 0)\n         error(csa, \"source node descriptor missing\\n\");\n      if (t == 0)\n         error(csa, \"sink node descriptor missing\\n\");\n      if (_s != NULL) *_s = s;\n      if (_t != NULL) *_t = t;\n      /* read arc descriptor lines */\n      for (k = 1; k <= na; k++)\n      {  if (k > 1) read_designator(csa);\n         if (strcmp(csa->field, \"a\") != 0)\n            error(csa, \"wrong line designator; 'a' expected\");\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"starting node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"starting node number %d out of range\", i);\n         read_field(csa);\n         if (str2int(csa->field, &j) != 0)\n            error(csa, \"ending node number missing or invalid\");\n         if (!(1 <= j && j <= nv))\n            error(csa, \"ending node number %d out of range\", j);\n         read_field(csa);\n         if (!(str2num(csa->field, &cap) == 0 && cap >= 0.0))\n            error(csa, \"arc capacity missing or invalid\");\n         check_int(csa, cap);\n         a = glp_add_arc(G, i, j);\n         if (a_cap >= 0)\n            memcpy((char *)a->data + a_cap, &cap, sizeof(double));\n         end_of_line(csa);\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\ndone: if (ret) glp_erase_graph(G, G->v_size, G->a_size);\n      if (csa->fp != NULL) glp_close(csa->fp);\n      return ret;\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdmcf.c": {
    "glp_read_mincost": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "int glp_read_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,\n      int a_cost, const char *fname)\n{     DMX _csa, *csa = &_csa;\n      glp_vertex *v;\n      glp_arc *a;\n      int i, j, k, nv, na, ret = 0;\n      double rhs, low, cap, cost;\n      char *flag = NULL;\n      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n         xerror(\"glp_read_mincost: v_rhs = %d; invalid offset\\n\",\n            v_rhs);\n      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))\n         xerror(\"glp_read_mincost: a_low = %d; invalid offset\\n\",\n            a_low);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_read_mincost: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_read_mincost: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      glp_erase_graph(G, G->v_size, G->a_size);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading min-cost flow problem data from '%s'...\\n\",\n         fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"min\") != 0)\n         error(csa, \"wrong problem designator; 'min' expected\");\n      read_field(csa);\n      if (!(str2int(csa->field, &nv) == 0 && nv >= 0))\n         error(csa, \"number of nodes missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &na) == 0 && na >= 0))\n         error(csa, \"number of arcs missing or invalid\");\n      xprintf(\"Flow network has %d node%s and %d arc%s\\n\",\n         nv, nv == 1 ? \"\" : \"s\", na, na == 1 ? \"\" : \"s\");\n      if (nv > 0) glp_add_vertices(G, nv);\n      end_of_line(csa);\n      /* read node descriptor lines */\n      flag = xcalloc(1+nv, sizeof(char));\n      memset(&flag[1], 0, nv * sizeof(char));\n      if (v_rhs >= 0)\n      {  rhs = 0.0;\n         for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_rhs, &rhs, sizeof(double));\n         }\n      }\n      for (;;)\n      {  read_designator(csa);\n         if (strcmp(csa->field, \"n\") != 0) break;\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"node number %d out of range\", i);\n         if (flag[i])\n            error(csa, \"duplicate descriptor of node %d\", i);\n         read_field(csa);\n         if (str2num(csa->field, &rhs) != 0)\n            error(csa, \"node supply/demand missing or invalid\");\n         check_int(csa, rhs);\n         if (v_rhs >= 0)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_rhs, &rhs, sizeof(double));\n         }\n         flag[i] = 1;\n         end_of_line(csa);\n      }\n      xfree(flag), flag = NULL;\n      /* read arc descriptor lines */\n      for (k = 1; k <= na; k++)\n      {  if (k > 1) read_designator(csa);\n         if (strcmp(csa->field, \"a\") != 0)\n            error(csa, \"wrong line designator; 'a' expected\");\n         read_field(csa);\n         if (str2int(csa->field, &i) != 0)\n            error(csa, \"starting node number missing or invalid\");\n         if (!(1 <= i && i <= nv))\n            error(csa, \"starting node number %d out of range\", i);\n         read_field(csa);\n         if (str2int(csa->field, &j) != 0)\n            error(csa, \"ending node number missing or invalid\");\n         if (!(1 <= j && j <= nv))\n            error(csa, \"ending node number %d out of range\", j);\n         read_field(csa);\n         if (!(str2num(csa->field, &low) == 0 && low >= 0.0))\n            error(csa, \"lower bound of arc flow missing or invalid\");\n         check_int(csa, low);\n         read_field(csa);\n         if (!(str2num(csa->field, &cap) == 0 && cap >= low))\n            error(csa, \"upper bound of arc flow missing or invalid\");\n         check_int(csa, cap);\n         read_field(csa);\n         if (str2num(csa->field, &cost) != 0)\n            error(csa, \"per-unit cost of arc flow missing or invalid\");\n         check_int(csa, cost);\n         a = glp_add_arc(G, i, j);\n         if (a_low >= 0)\n            memcpy((char *)a->data + a_low, &low, sizeof(double));\n         if (a_cap >= 0)\n            memcpy((char *)a->data + a_cap, &cap, sizeof(double));\n         if (a_cost >= 0)\n            memcpy((char *)a->data + a_cost, &cost, sizeof(double));\n         end_of_line(csa);\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\ndone: if (ret) glp_erase_graph(G, G->v_size, G->a_size);\n      if (csa->fp != NULL) glp_close(csa->fp);\n      if (flag != NULL) xfree(flag);\n      return ret;\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdmip.c": {
    "glp_read_mip": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int glp_read_mip(glp_prob *P, const char *fname)\n{     DMX dmx_, *dmx = &dmx_;\n      int i, j, k, m, n, sst, ret = 1;\n      char *stat = NULL;\n      double obj, *prim = NULL;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_read_mip: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_read_mip: fname = %d; invalid parameter\\n\", fname);\n      if (setjmp(dmx->jump))\n         goto done;\n      dmx->fname = fname;\n      dmx->fp = NULL;\n      dmx->count = 0;\n      dmx->c = '\\n';\n      dmx->field[0] = '\\0';\n      dmx->empty = dmx->nonint = 0;\n      xprintf(\"Reading MIP solution from '%s'...\\n\", fname);\n      dmx->fp = glp_open(fname, \"r\");\n      if (dmx->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* read solution line */\n      dmx_read_designator(dmx);\n      if (strcmp(dmx->field, \"s\") != 0)\n         dmx_error(dmx, \"solution line missing or invalid\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"mip\") != 0)\n         dmx_error(dmx, \"wrong solution designator; 'mip' expected\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &m) == 0 && m >= 0))\n         dmx_error(dmx, \"number of rows missing or invalid\");\n      if (m != P->m)\n         dmx_error(dmx, \"number of rows mismatch\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &n) == 0 && n >= 0))\n         dmx_error(dmx, \"number of columns missing or invalid\");\n      if (n != P->n)\n         dmx_error(dmx, \"number of columns mismatch\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"o\") == 0)\n         sst = GLP_OPT;\n      else if (strcmp(dmx->field, \"f\") == 0)\n         sst = GLP_FEAS;\n      else if (strcmp(dmx->field, \"n\") == 0)\n         sst = GLP_NOFEAS;\n      else if (strcmp(dmx->field, \"u\") == 0)\n         sst = GLP_UNDEF;\n      else\n         dmx_error(dmx, \"solution status missing or invalid\");\n      dmx_read_field(dmx);\n      if (str2num(dmx->field, &obj) != 0)\n         dmx_error(dmx, \"objective value missing or invalid\");\n      dmx_end_of_line(dmx);\n      /* allocate working arrays */\n      stat = xalloc(1+m+n, sizeof(stat[0]));\n      for (k = 1; k <= m+n; k++)\n         stat[k] = '?';\n      prim = xalloc(1+m+n, sizeof(prim[0]));\n      /* read solution descriptor lines */\n      for (;;)\n      {  dmx_read_designator(dmx);\n         if (strcmp(dmx->field, \"i\") == 0)\n         {  /* row solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &i) != 0)\n               dmx_error(dmx, \"row number missing or invalid\");\n            if (!(1 <= i && i <= m))\n               dmx_error(dmx, \"row number out of range\");\n            if (stat[i] != '?')\n               dmx_error(dmx, \"duplicate row solution descriptor\");\n            stat[i] = GLP_BS;\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[i]) != 0)\n               dmx_error(dmx, \"row value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"j\") == 0)\n         {  /* column solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &j) != 0)\n               dmx_error(dmx, \"column number missing or invalid\");\n            if (!(1 <= j && j <= n))\n               dmx_error(dmx, \"column number out of range\");\n            if (stat[m+j] != '?')\n               dmx_error(dmx, \"duplicate column solution descriptor\");\n            stat[m+j] = GLP_BS;\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[m+j]) != 0)\n               dmx_error(dmx, \"column value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"e\") == 0)\n            break;\n         else\n            dmx_error(dmx, \"line designator missing or invalid\");\n         dmx_end_of_line(dmx);\n      }\n      /* store solution components into problem object */\n      for (k = 1; k <= m+n; k++)\n      {  if (stat[k] == '?')\n            dmx_error(dmx, \"incomplete MIP solution\");\n      }\n      P->mip_stat = sst;\n      P->mip_obj = obj;\n      for (i = 1; i <= m; i++)\n         P->row[i]->mipx = prim[i];\n      for (j = 1; j <= n; j++)\n         P->col[j]->mipx = prim[m+j];\n      /* MIP solution has been successfully read */\n      xprintf(\"%d lines were read\\n\", dmx->count);\n      ret = 0;\ndone: if (dmx->fp != NULL)\n         glp_close(dmx->fp);\n      if (stat != NULL)\n         xfree(stat);\n      if (prim != NULL)\n         xfree(prim);\n      return ret;\n}",
      "lines": 123,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdprob.c": {
    "glp_read_prob": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "int glp_read_prob(glp_prob *P, int flags, const char *fname)\n{     DMX _csa, *csa = &_csa;\n      int mip, m, n, nnz, ne, i, j, k, type, kind, ret, *ln = NULL,\n         *ia = NULL, *ja = NULL;\n      double lb, ub, temp, *ar = NULL;\n      char *rf = NULL, *cf = NULL;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_read_prob: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (flags != 0)\n         xerror(\"glp_read_prob: flags = %d; invalid parameter\\n\",\n            flags);\n      if (fname == NULL)\n         xerror(\"glp_read_prob: fname = %d; invalid parameter\\n\",\n            fname);\n      glp_erase_prob(P);\n      if (setjmp(csa->jump))\n      {  ret = 1;\n         goto done;\n      }\n      csa->fname = fname;\n      csa->fp = NULL;\n      csa->count = 0;\n      csa->c = '\\n';\n      csa->field[0] = '\\0';\n      csa->empty = csa->nonint = 0;\n      xprintf(\"Reading problem data from '%s'...\\n\", fname);\n      csa->fp = glp_open(fname, \"r\");\n      if (csa->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         longjmp(csa->jump, 1);\n      }\n      /* read problem line */\n      read_designator(csa);\n      if (strcmp(csa->field, \"p\") != 0)\n         error(csa, \"problem line missing or invalid\");\n      read_field(csa);\n      if (strcmp(csa->field, \"lp\") == 0)\n         mip = 0;\n      else if (strcmp(csa->field, \"mip\") == 0)\n         mip = 1;\n      else\n         error(csa, \"wrong problem designator; 'lp' or 'mip' expected\");\n      read_field(csa);\n      if (strcmp(csa->field, \"min\") == 0)\n         glp_set_obj_dir(P, GLP_MIN);\n      else if (strcmp(csa->field, \"max\") == 0)\n         glp_set_obj_dir(P, GLP_MAX);\n      else\n         error(csa, \"objective sense missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &m) == 0 && m >= 0))\n         error(csa, \"number of rows missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &n) == 0 && n >= 0))\n         error(csa, \"number of columns missing or invalid\");\n      read_field(csa);\n      if (!(str2int(csa->field, &nnz) == 0 && nnz >= 0))\n         error(csa, \"number of constraint coefficients missing or inval\"\n            \"id\");\n      if (m > 0)\n      {  glp_add_rows(P, m);\n         for (i = 1; i <= m; i++)\n            glp_set_row_bnds(P, i, GLP_FX, 0.0, 0.0);\n      }\n      if (n > 0)\n      {  glp_add_cols(P, n);\n         for (j = 1; j <= n; j++)\n         {  if (!mip)\n               glp_set_col_bnds(P, j, GLP_LO, 0.0, 0.0);\n            else\n               glp_set_col_kind(P, j, GLP_BV);\n         }\n      }\n      end_of_line(csa);\n      /* allocate working arrays */\n      rf = xcalloc(1+m, sizeof(char));\n      memset(rf, 0, 1+m);\n      cf = xcalloc(1+n, sizeof(char));\n      memset(cf, 0, 1+n);\n      ln = xcalloc(1+nnz, sizeof(int));\n      ia = xcalloc(1+nnz, sizeof(int));\n      ja = xcalloc(1+nnz, sizeof(int));\n      ar = xcalloc(1+nnz, sizeof(double));\n      /* read descriptor lines */\n      ne = 0;\n      for (;;)\n      {  read_designator(csa);\n         if (strcmp(csa->field, \"i\") == 0)\n         {  /* row descriptor */\n            read_field(csa);\n            if (str2int(csa->field, &i) != 0)\n               error(csa, \"row number missing or invalid\");\n            if (!(1 <= i && i <= m))\n               error(csa, \"row number out of range\");\n            read_field(csa);\n            if (strcmp(csa->field, \"f\") == 0)\n               type = GLP_FR;\n            else if (strcmp(csa->field, \"l\") == 0)\n               type = GLP_LO;\n            else if (strcmp(csa->field, \"u\") == 0)\n               type = GLP_UP;\n            else if (strcmp(csa->field, \"d\") == 0)\n               type = GLP_DB;\n            else if (strcmp(csa->field, \"s\") == 0)\n               type = GLP_FX;\n            else\n               error(csa, \"row type missing or invalid\");\n            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n            {  read_field(csa);\n               if (str2num(csa->field, &lb) != 0)\n                  error(csa, \"row lower bound/fixed value missing or in\"\n                     \"valid\");\n            }\n            else\n               lb = 0.0;\n            if (type == GLP_UP || type == GLP_DB)\n            {  read_field(csa);\n               if (str2num(csa->field, &ub) != 0)\n                  error(csa, \"row upper bound missing or invalid\");\n            }\n            else\n               ub = 0.0;\n            if (rf[i] & 0x01)\n               error(csa, \"duplicate row descriptor\");\n            glp_set_row_bnds(P, i, type, lb, ub), rf[i] |= 0x01;\n         }\n         else if (strcmp(csa->field, \"j\") == 0)\n         {  /* column descriptor */\n            read_field(csa);\n            if (str2int(csa->field, &j) != 0)\n               error(csa, \"column number missing or invalid\");\n            if (!(1 <= j && j <= n))\n               error(csa, \"column number out of range\");\n            if (!mip)\n               kind = GLP_CV;\n            else\n            {  read_field(csa);\n               if (strcmp(csa->field, \"c\") == 0)\n                  kind = GLP_CV;\n               else if (strcmp(csa->field, \"i\") == 0)\n                  kind = GLP_IV;\n               else if (strcmp(csa->field, \"b\") == 0)\n               {  kind = GLP_IV;\n                  type = GLP_DB, lb = 0.0, ub = 1.0;\n                  goto skip;\n               }\n               else\n                  error(csa, \"column kind missing or invalid\");\n            }\n            read_field(csa);\n            if (strcmp(csa->field, \"f\") == 0)\n               type = GLP_FR;\n            else if (strcmp(csa->field, \"l\") == 0)\n               type = GLP_LO;\n            else if (strcmp(csa->field, \"u\") == 0)\n               type = GLP_UP;\n            else if (strcmp(csa->field, \"d\") == 0)\n               type = GLP_DB;\n            else if (strcmp(csa->field, \"s\") == 0)\n               type = GLP_FX;\n            else\n               error(csa, \"column type missing or invalid\");\n            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n            {  read_field(csa);\n               if (str2num(csa->field, &lb) != 0)\n                  error(csa, \"column lower bound/fixed value missing or\"\n                     \" invalid\");\n            }\n            else\n               lb = 0.0;\n            if (type == GLP_UP || type == GLP_DB)\n            {  read_field(csa);\n               if (str2num(csa->field, &ub) != 0)\n                  error(csa, \"column upper bound missing or invalid\");\n            }\n            else\n               ub = 0.0;\nskip:       if (cf[j] & 0x01)\n               error(csa, \"duplicate column descriptor\");\n            glp_set_col_kind(P, j, kind);\n            glp_set_col_bnds(P, j, type, lb, ub), cf[j] |= 0x01;\n         }\n         else if (strcmp(csa->field, \"a\") == 0)\n         {  /* coefficient descriptor */\n            read_field(csa);\n            if (str2int(csa->field, &i) != 0)\n               error(csa, \"row number missing or invalid\");\n            if (!(0 <= i && i <= m))\n               error(csa, \"row number out of range\");\n            read_field(csa);\n            if (str2int(csa->field, &j) != 0)\n               error(csa, \"column number missing or invalid\");\n            if (!((i == 0 ? 0 : 1) <= j && j <= n))\n               error(csa, \"column number out of range\");\n            read_field(csa);\n            if (i == 0)\n            {  if (str2num(csa->field, &temp) != 0)\n                  error(csa, \"objective %s missing or invalid\",\n                     j == 0 ? \"constant term\" : \"coefficient\");\n               if (cf[j] & 0x10)\n                  error(csa, \"duplicate objective %s\",\n                     j == 0 ? \"constant term\" : \"coefficient\");\n               glp_set_obj_coef(P, j, temp), cf[j] |= 0x10;\n            }\n            else\n            {  if (str2num(csa->field, &temp) != 0)\n                  error(csa, \"constraint coefficient missing or invalid\"\n                     );\n               if (ne == nnz)\n                  error(csa, \"too many constraint coefficient descripto\"\n                     \"rs\");\n               ln[++ne] = csa->count;\n               ia[ne] = i, ja[ne] = j, ar[ne] = temp;\n            }\n         }\n         else if (strcmp(csa->field, \"n\") == 0)\n         {  /* symbolic name descriptor */\n            read_field(csa);\n            if (strcmp(csa->field, \"p\") == 0)\n            {  /* problem name */\n               read_field(csa);\n               if (P->name != NULL)\n                  error(csa, \"duplicate problem name\");\n               glp_set_prob_name(P, csa->field);\n            }\n            else if (strcmp(csa->field, \"z\") == 0)\n            {  /* objective name */\n               read_field(csa);\n               if (P->obj != NULL)\n                  error(csa, \"duplicate objective name\");\n               glp_set_obj_name(P, csa->field);\n            }\n            else if (strcmp(csa->field, \"i\") == 0)\n            {  /* row name */\n               read_field(csa);\n               if (str2int(csa->field, &i) != 0)\n                  error(csa, \"row number missing or invalid\");\n               if (!(1 <= i && i <= m))\n                  error(csa, \"row number out of range\");\n               read_field(csa);\n               if (P->row[i]->name != NULL)\n                  error(csa, \"duplicate row name\");\n               glp_set_row_name(P, i, csa->field);\n            }\n            else if (strcmp(csa->field, \"j\") == 0)\n            {  /* column name */\n               read_field(csa);\n               if (str2int(csa->field, &j) != 0)\n                  error(csa, \"column number missing or invalid\");\n               if (!(1 <= j && j <= n))\n                  error(csa, \"column number out of range\");\n               read_field(csa);\n               if (P->col[j]->name != NULL)\n                  error(csa, \"duplicate column name\");\n               glp_set_col_name(P, j, csa->field);\n            }\n            else\n               error(csa, \"object designator missing or invalid\");\n         }\n         else if (strcmp(csa->field, \"e\") == 0)\n            break;\n         else\n            error(csa, \"line designator missing or invalid\");\n         end_of_line(csa);\n      }\n      if (ne < nnz)\n         error(csa, \"too few constraint coefficient descriptors\");\n      xassert(ne == nnz);\n      k = glp_check_dup(m, n, ne, ia, ja);\n      xassert(0 <= k && k <= nnz);\n      if (k > 0)\n      {  csa->count = ln[k];\n         error(csa, \"duplicate constraint coefficient\");\n      }\n      glp_load_matrix(P, ne, ia, ja, ar);\n      /* print some statistics */\n      if (P->name != NULL)\n         xprintf(\"Problem: %s\\n\", P->name);\n      if (P->obj != NULL)\n         xprintf(\"Objective: %s\\n\", P->obj);\n      xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n         m, m == 1 ? \"\" : \"s\", n, n == 1 ? \"\" : \"s\", nnz, nnz == 1 ?\n         \"\" : \"s\");\n      if (glp_get_num_int(P) > 0)\n      {  int ni = glp_get_num_int(P);\n         int nb = glp_get_num_bin(P);\n         if (ni == 1)\n         {  if (nb == 0)\n               xprintf(\"One variable is integer\\n\");\n            else\n               xprintf(\"One variable is binary\\n\");\n         }\n         else\n         {  xprintf(\"%d integer variables, \", ni);\n            if (nb == 0)\n               xprintf(\"none\");\n            else if (nb == 1)\n               xprintf(\"one\");\n            else if (nb == ni)\n               xprintf(\"all\");\n            else\n               xprintf(\"%d\", nb);\n            xprintf(\" of which %s binary\\n\", nb == 1 ? \"is\" : \"are\");\n         }\n      }\n      xprintf(\"%d lines were read\\n\", csa->count);\n      /* problem data has been successfully read */\n      glp_sort_matrix(P);\n      ret = 0;\ndone: if (csa->fp != NULL) glp_close(csa->fp);\n      if (rf != NULL) xfree(rf);\n      if (cf != NULL) xfree(cf);\n      if (ln != NULL) xfree(ln);\n      if (ia != NULL) xfree(ia);\n      if (ja != NULL) xfree(ja);\n      if (ar != NULL) xfree(ar);\n      if (ret) glp_erase_prob(P);\n      return ret;\n}",
      "lines": 322,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rdsol.c": {
    "glp_read_sol": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int glp_read_sol(glp_prob *P, const char *fname)\n{     DMX dmx_, *dmx = &dmx_;\n      int i, j, k, m, n, pst, dst, ret = 1;\n      char *stat = NULL;\n      double obj, *prim = NULL, *dual = NULL;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_read_sol: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_read_sol: fname = %d; invalid parameter\\n\", fname);\n      if (setjmp(dmx->jump))\n         goto done;\n      dmx->fname = fname;\n      dmx->fp = NULL;\n      dmx->count = 0;\n      dmx->c = '\\n';\n      dmx->field[0] = '\\0';\n      dmx->empty = dmx->nonint = 0;\n      xprintf(\"Reading basic solution from '%s'...\\n\", fname);\n      dmx->fp = glp_open(fname, \"r\");\n      if (dmx->fp == NULL)\n      {  xprintf(\"Unable to open '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* read solution line */\n      dmx_read_designator(dmx);\n      if (strcmp(dmx->field, \"s\") != 0)\n         dmx_error(dmx, \"solution line missing or invalid\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"bas\") != 0)\n         dmx_error(dmx, \"wrong solution designator; 'bas' expected\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &m) == 0 && m >= 0))\n         dmx_error(dmx, \"number of rows missing or invalid\");\n      if (m != P->m)\n         dmx_error(dmx, \"number of rows mismatch\");\n      dmx_read_field(dmx);\n      if (!(str2int(dmx->field, &n) == 0 && n >= 0))\n         dmx_error(dmx, \"number of columns missing or invalid\");\n      if (n != P->n)\n         dmx_error(dmx, \"number of columns mismatch\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"u\") == 0)\n         pst = GLP_UNDEF;\n      else if (strcmp(dmx->field, \"f\") == 0)\n         pst = GLP_FEAS;\n      else if (strcmp(dmx->field, \"i\") == 0)\n         pst = GLP_INFEAS;\n      else if (strcmp(dmx->field, \"n\") == 0)\n         pst = GLP_NOFEAS;\n      else\n         dmx_error(dmx, \"primal solution status missing or invalid\");\n      dmx_read_field(dmx);\n      if (strcmp(dmx->field, \"u\") == 0)\n         dst = GLP_UNDEF;\n      else if (strcmp(dmx->field, \"f\") == 0)\n         dst = GLP_FEAS;\n      else if (strcmp(dmx->field, \"i\") == 0)\n         dst = GLP_INFEAS;\n      else if (strcmp(dmx->field, \"n\") == 0)\n         dst = GLP_NOFEAS;\n      else\n         dmx_error(dmx, \"dual solution status missing or invalid\");\n      dmx_read_field(dmx);\n      if (str2num(dmx->field, &obj) != 0)\n         dmx_error(dmx, \"objective value missing or invalid\");\n      dmx_end_of_line(dmx);\n      /* allocate working arrays */\n      stat = xalloc(1+m+n, sizeof(stat[0]));\n      for (k = 1; k <= m+n; k++)\n         stat[k] = '?';\n      prim = xalloc(1+m+n, sizeof(prim[0]));\n      dual = xalloc(1+m+n, sizeof(dual[0]));\n      /* read solution descriptor lines */\n      for (;;)\n      {  dmx_read_designator(dmx);\n         if (strcmp(dmx->field, \"i\") == 0)\n         {  /* row solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &i) != 0)\n               dmx_error(dmx, \"row number missing or invalid\");\n            if (!(1 <= i && i <= m))\n               dmx_error(dmx, \"row number out of range\");\n            if (stat[i] != '?')\n               dmx_error(dmx, \"duplicate row solution descriptor\");\n            dmx_read_field(dmx);\n            if (strcmp(dmx->field, \"b\") == 0)\n               stat[i] = GLP_BS;\n            else if (strcmp(dmx->field, \"l\") == 0)\n               stat[i] = GLP_NL;\n            else if (strcmp(dmx->field, \"u\") == 0)\n               stat[i] = GLP_NU;\n            else if (strcmp(dmx->field, \"f\") == 0)\n               stat[i] = GLP_NF;\n            else if (strcmp(dmx->field, \"s\") == 0)\n               stat[i] = GLP_NS;\n            else\n               dmx_error(dmx, \"row status missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[i]) != 0)\n               dmx_error(dmx, \"row primal value missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &dual[i]) != 0)\n               dmx_error(dmx, \"row dual value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"j\") == 0)\n         {  /* column solution descriptor */\n            dmx_read_field(dmx);\n            if (str2int(dmx->field, &j) != 0)\n               dmx_error(dmx, \"column number missing or invalid\");\n            if (!(1 <= j && j <= n))\n               dmx_error(dmx, \"column number out of range\");\n            if (stat[m+j] != '?')\n               dmx_error(dmx, \"duplicate column solution descriptor\");\n            dmx_read_field(dmx);\n            if (strcmp(dmx->field, \"b\") == 0)\n               stat[m+j] = GLP_BS;\n            else if (strcmp(dmx->field, \"l\") == 0)\n               stat[m+j] = GLP_NL;\n            else if (strcmp(dmx->field, \"u\") == 0)\n               stat[m+j] = GLP_NU;\n            else if (strcmp(dmx->field, \"f\") == 0)\n               stat[m+j] = GLP_NF;\n            else if (strcmp(dmx->field, \"s\") == 0)\n               stat[m+j] = GLP_NS;\n            else\n               dmx_error(dmx, \"column status missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &prim[m+j]) != 0)\n               dmx_error(dmx, \"column primal value missing or invalid\");\n            dmx_read_field(dmx);\n            if (str2num(dmx->field, &dual[m+j]) != 0)\n               dmx_error(dmx, \"column dual value missing or invalid\");\n            dmx_end_of_line(dmx);\n         }\n         else if (strcmp(dmx->field, \"e\") == 0)\n            break;\n         else\n            dmx_error(dmx, \"line designator missing or invalid\");\n         dmx_end_of_line(dmx);\n      }\n      /* store solution components into problem object */\n      for (k = 1; k <= m+n; k++)\n      {  if (stat[k] == '?')\n            dmx_error(dmx, \"incomplete basic solution\");\n      }\n      P->pbs_stat = pst;\n      P->dbs_stat = dst;\n      P->obj_val = obj;\n      P->it_cnt = 0;\n      P->some = 0;\n      for (i = 1; i <= m; i++)\n      {  glp_set_row_stat(P, i, stat[i]);\n         P->row[i]->prim = prim[i];\n         P->row[i]->dual = dual[i];\n      }\n      for (j = 1; j <= n; j++)\n      {  glp_set_col_stat(P, j, stat[m+j]);\n         P->col[j]->prim = prim[m+j];\n         P->col[j]->dual = dual[m+j];\n      }\n      /* basic solution has been successfully read */\n      xprintf(\"%d lines were read\\n\", dmx->count);\n      ret = 0;\ndone: if (dmx->fp != NULL)\n         glp_close(dmx->fp);\n      if (stat != NULL)\n         xfree(stat);\n      if (prim != NULL)\n         xfree(prim);\n      if (dual != NULL)\n         xfree(dual);\n      return ret;\n}",
      "lines": 176,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/rmfgen.c": {
    "make_edge": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static void make_edge(struct csa *csa, int from, int to, int c1, int c2)\n{     Ec++;\n      N->edges[Ec].from = from;\n      N->edges[Ec].to = to;\n      N->edges[Ec].cap = RANDOM(c1, c2);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "permute": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static void permute(struct csa *csa)\n{     int i, j, tmp;\n      for (i = 1; i < AA; i++)\n      {  j = RANDOM(i, AA);\n         tmp = Parr[i];\n         Parr[i] = Parr[j];\n         Parr[j] = tmp;\n      }\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "connect": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static void connect(struct csa *csa, int offset, int cv, int x1, int y1)\n{     int cv1;\n      cv1 = offset + (x1 - 1) * A + y1;\n      Ec++;\n      N->edges[Ec].from = cv;\n      N->edges[Ec].to = cv1;\n      N->edges[Ec].cap = C2AA;\n      return;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gen_rmf": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static network *gen_rmf(struct csa *csa, int a, int b, int c1, int c2)\n{     /* generates a network with a*a*b nodes and 6a*a*b-4ab-2a*a edges\n         random_frame network:\n         Derigs & Meier, Methods & Models of OR (1989), 33:383-403 */\n      int x, y, z, offset, cv;\n      A = a;\n      AA = a * a;\n      C2AA = c2 * AA;\n      Ec = 0;\n      N = (network *)xmalloc(sizeof(network));\n      N->vertnum = AA * b;\n      N->edgenum = 5 * AA * b - 4 * A * b - AA;\n      N->edges = (edge *)xcalloc(N->edgenum + 1, sizeof(edge));\n      N->source = 1;\n      N->sink = N->vertnum;\n      Parr = (int *)xcalloc(AA + 1, sizeof(int));\n      for (x = 1; x <= AA; x++)\n         Parr[x] = x;\n      for (z = 1; z <= b; z++)\n      {  offset = AA * (z - 1);\n         if (z != b)\n            permute(csa);\n         for (x = 1; x <= A; x++)\n         {  for (y = 1; y <= A; y++)\n            {  cv = offset + (x - 1) * A + y;\n               if (z != b)\n                  make_edge(csa, cv, offset + AA + Parr[cv - offset],\n                     c1, c2); /* the intermediate edges */\n               if (y < A)\n                  connect(csa, offset, cv, x, y + 1);\n               if (y > 1)\n                  connect(csa, offset, cv, x, y - 1);\n               if (x < A)\n                  connect(csa, offset, cv, x + 1, y);\n               if (x > 1)\n                  connect(csa, offset, cv, x - 1, y);\n            }\n         }\n      }\n      xfree(Parr);\n      return N;\n}",
      "lines": 42,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "network",
        "*gen_rmf(struct csa *csa, int a, int b, int c1, int c2)",
        "*"
      ]
    },
    "print_max_format": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static void print_max_format(struct csa *csa, network *n, char *comm[],\n      int dim)\n{     /* prints a network heading with dim lines of comments (no \\n\n         needs at the ends) */\n      int i, vnum, e_num;\n      edge *e;\n      vnum = n->vertnum;\n      e_num = n->edgenum;\n      if (G == NULL)\n      {  for (i = 0; i < dim; i++)\n            xprintf(\"c %s\\n\", comm[i]);\n         xprintf(\"p max %7d %10d\\n\", vnum, e_num);\n         xprintf(\"n %7d s\\n\", n->source);\n         xprintf(\"n %7d t\\n\", n->sink);\n      }\n      else\n      {  glp_add_vertices(G, vnum);\n         if (s != NULL) *s = n->source;\n         if (t != NULL) *t = n->sink;\n      }\n      for (i = 1; i <= e_num; i++)\n      {  e = &n->edges[i];\n         if (G == NULL)\n            xprintf(\"a %7d %7d %10d\\n\", e->from, e->to, (int)e->cap);\n         else\n         {  glp_arc *a = glp_add_arc(G, e->from, e->to);\n            if (a_cap >= 0)\n            {  double temp = (double)e->cap;\n               memcpy((char *)a->data + a_cap, &temp, sizeof(double));\n            }\n         }\n      }\n      return;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gen_free_net": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static void gen_free_net(network *n)\n{     xfree(n->edges);\n      xfree(n);\n      return;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_rmfgen": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "int glp_rmfgen(glp_graph *G_, int *_s, int *_t, int _a_cap,\n      const int parm[1+5])\n{     struct csa _csa, *csa = &_csa;\n      network *n;\n      char comm[10][80], *com1[10];\n      int seed, a, b, c1, c2, ret;\n      G = G_;\n      s = _s;\n      t = _t;\n      a_cap = _a_cap;\n      if (G != NULL)\n      {  if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n           xerror(\"glp_rmfgen: a_cap = %d; invalid offset\\n\", a_cap);\n      }\n      seed = parm[1];\n      a = parm[2];\n      b = parm[3];\n      c1 = parm[4];\n      c2 = parm[5];\n      if (!(seed > 0 && 1 <= a && a <= 1000 && 1 <= b && b <= 1000 &&\n            0 <= c1 && c1 <= c2 && c2 <= 1000))\n      {  ret = 1;\n         goto done;\n      }\n      if (G != NULL)\n      {  glp_erase_graph(G, G->v_size, G->a_size);\n         glp_set_graph_name(G, \"RMFGEN\");\n      }\n      csa->rand = rng_create_rand();\n      rng_init_rand(csa->rand, seed);\n      n = gen_rmf(csa, a, b, c1, c2);\n      sprintf(comm[0], \"This file was generated by genrmf.\");\n      sprintf(comm[1], \"The parameters are: a: %d b: %d c1: %d c2: %d\",\n         a, b, c1, c2);\n      com1[0] = comm[0];\n      com1[1] = comm[1];\n      print_max_format(csa, n, com1, 2);\n      gen_free_net(n);\n      rng_delete_rand(csa->rand);\n      ret = 0;\ndone: return ret;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "int main(int argc, char *argv[])\n{     int seed, a, b, c1, c2, i, parm[1+5];\n      seed = 123;\n      a = b = c1 = c2 = -1;\n      for (i = 1; i < argc; i++)\n      {  if (strcmp(argv[i], \"-seed\") == 0)\n            seed = atoi(argv[++i]);\n         else if (strcmp(argv[i], \"-a\") == 0)\n            a = atoi(argv[++i]);\n         else if (strcmp(argv[i], \"-b\") == 0)\n            b = atoi(argv[++i]);\n         else if (strcmp(argv[i], \"-c1\") == 0)\n            c1 = atoi(argv[++i]);\n         else if (strcmp(argv[i], \"-c2\") == 0)\n            c2 = atoi(argv[++i]);\n      }\n      if (a < 0 || b < 0 || c1 < 0 || c2 < 0)\n      {  xprintf(\"Usage:\\n\");\n         xprintf(\"genrmf [-seed seed] -a frame_size -b depth\\n\");\n         xprintf(\"        -c1 cap_range1 -c2 cap_range2\\n\");\n      }\n      else\n      {  parm[1] = seed;\n         parm[2] = a;\n         parm[3] = b;\n         parm[4] = c1;\n         parm[5] = c2;\n         glp_rmfgen(NULL, NULL, NULL, 0, parm);\n      }\n      return 0;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/strong.c": {
    "glp_strong_comp": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int glp_strong_comp(glp_graph *G, int v_num)\n{     glp_vertex *v;\n      glp_arc *a;\n      int i, k, last, n, na, nc, *icn, *ip, *lenr, *ior, *ib, *lowl,\n         *numb, *prev;\n      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))\n         xerror(\"glp_strong_comp: v_num = %d; invalid offset\\n\",\n            v_num);\n      n = G->nv;\n      if (n == 0)\n      {  nc = 0;\n         goto done;\n      }\n      na = G->na;\n      icn = xcalloc(1+na, sizeof(int));\n      ip = xcalloc(1+n, sizeof(int));\n      lenr = xcalloc(1+n, sizeof(int));\n      ior = xcalloc(1+n, sizeof(int));\n      ib = xcalloc(1+n, sizeof(int));\n      lowl = xcalloc(1+n, sizeof(int));\n      numb = xcalloc(1+n, sizeof(int));\n      prev = xcalloc(1+n, sizeof(int));\n      k = 1;\n      for (i = 1; i <= n; i++)\n      {  v = G->v[i];\n         ip[i] = k;\n         for (a = v->out; a != NULL; a = a->t_next)\n            icn[k++] = a->head->i;\n         lenr[i] = k - ip[i];\n      }\n      xassert(na == k-1);\n      nc = mc13d(n, icn, ip, lenr, ior, ib, lowl, numb, prev);\n      if (v_num >= 0)\n      {  xassert(ib[1] == 1);\n         for (k = 1; k <= nc; k++)\n         {  last = (k < nc ? ib[k+1] : n+1);\n            xassert(ib[k] < last);\n            for (i = ib[k]; i < last; i++)\n            {  v = G->v[ior[i]];\n               memcpy((char *)v->data + v_num, &k, sizeof(int));\n            }\n         }\n      }\n      xfree(icn);\n      xfree(ip);\n      xfree(lenr);\n      xfree(ior);\n      xfree(ib);\n      xfree(lowl);\n      xfree(numb);\n      xfree(prev);\ndone: return nc;\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/topsort.c": {
    "top_sort": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "static int top_sort(glp_graph *G, int num[])\n{     glp_arc *a;\n      int i, j, cnt, top, *stack, *indeg;\n      /* allocate working arrays */\n      indeg = xcalloc(1+G->nv, sizeof(int));\n      stack = xcalloc(1+G->nv, sizeof(int));\n      /* determine initial indegree of each vertex; push into the stack\n         the vertices having zero indegree */\n      top = 0;\n      for (i = 1; i <= G->nv; i++)\n      {  num[i] = indeg[i] = 0;\n         for (a = G->v[i]->in; a != NULL; a = a->h_next)\n            indeg[i]++;\n         if (indeg[i] == 0)\n            stack[++top] = i;\n      }\n      /* assign numbers to vertices in the sorted order */\n      cnt = 0;\n      while (top > 0)\n      {  /* pull vertex i from the stack */\n         i = stack[top--];\n         /* it has zero indegree in the current graph */\n         xassert(indeg[i] == 0);\n         /* so assign it a next number */\n         xassert(num[i] == 0);\n         num[i] = ++cnt;\n         /* remove vertex i from the current graph, update indegree of\n            its adjacent vertices, and push into the stack new vertices\n            whose indegree becomes zero */\n         for (a = G->v[i]->out; a != NULL; a = a->t_next)\n         {  j = a->head->i;\n            /* there exists arc (i->j) in the graph */\n            xassert(indeg[j] > 0);\n            indeg[j]--;\n            if (indeg[j] == 0)\n               stack[++top] = j;\n         }\n      }\n      /* free working arrays */\n      xfree(indeg);\n      xfree(stack);\n      return G->nv - cnt;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_top_sort": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int glp_top_sort(glp_graph *G, int v_num)\n{     glp_vertex *v;\n      int i, cnt, *num;\n      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))\n         xerror(\"glp_top_sort: v_num = %d; invalid offset\\n\", v_num);\n      if (G->nv == 0)\n      {  cnt = 0;\n         goto done;\n      }\n      num = xcalloc(1+G->nv, sizeof(int));\n      cnt = top_sort(G, num);\n      if (v_num >= 0)\n      {  for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_num, &num[i], sizeof(int));\n         }\n      }\n      xfree(num);\ndone: return cnt;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wcliqex.c": {
    "set_edge": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static void set_edge(int nv, unsigned char a[], int i, int j)\n{     int k;\n      xassert(1 <= j && j < i && i <= nv);\n      k = ((i - 1) * (i - 2)) / 2 + (j - 1);\n      a[k / CHAR_BIT] |=\n         (unsigned char)(1 << ((CHAR_BIT - 1) - k % CHAR_BIT));\n      return;\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_wclique_exact": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int glp_wclique_exact(glp_graph *G, int v_wgt, double *sol, int v_set)\n{     /* find maximum weight clique with exact algorithm */\n      glp_arc *e;\n      int i, j, k, len, x, *w, *ind, ret = 0;\n      unsigned char *a;\n      double s, t;\n      if (v_wgt >= 0 && v_wgt > G->v_size - (int)sizeof(double))\n         xerror(\"glp_wclique_exact: v_wgt = %d; invalid parameter\\n\",\n            v_wgt);\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_wclique_exact: v_set = %d; invalid parameter\\n\",\n            v_set);\n      if (G->nv == 0)\n      {  /* empty graph has only empty clique */\n         if (sol != NULL) *sol = 0.0;\n         return 0;\n      }\n      /* allocate working arrays */\n      w = xcalloc(1+G->nv, sizeof(int));\n      ind = xcalloc(1+G->nv, sizeof(int));\n      len = G->nv; /* # vertices */\n      len = len * (len - 1) / 2; /* # entries in lower triangle */\n      len = (len + (CHAR_BIT - 1)) / CHAR_BIT; /* # bytes needed */\n      a = xcalloc(len, sizeof(char));\n      memset(a, 0, len * sizeof(char));\n      /* determine vertex weights */\n      s = 0.0;\n      for (i = 1; i <= G->nv; i++)\n      {  if (v_wgt >= 0)\n         {  memcpy(&t, (char *)G->v[i]->data + v_wgt, sizeof(double));\n            if (!(0.0 <= t && t <= (double)INT_MAX && t == floor(t)))\n            {  ret = GLP_EDATA;\n               goto done;\n            }\n            w[i] = (int)t;\n         }\n         else\n            w[i] = 1;\n         s += (double)w[i];\n      }\n      if (s > (double)INT_MAX)\n      {  ret = GLP_EDATA;\n         goto done;\n      }\n      /* build the adjacency matrix */\n      for (i = 1; i <= G->nv; i++)\n      {  for (e = G->v[i]->in; e != NULL; e = e->h_next)\n         {  j = e->tail->i;\n            /* there exists edge (j,i) in the graph */\n            if (i > j) set_edge(G->nv, a, i, j);\n         }\n         for (e = G->v[i]->out; e != NULL; e = e->t_next)\n         {  j = e->head->i;\n            /* there exists edge (i,j) in the graph */\n            if (i > j) set_edge(G->nv, a, i, j);\n         }\n      }\n      /* find maximum weight clique in the graph */\n      len = wclique(G->nv, w, a, ind);\n      /* compute the clique weight */\n      s = 0.0;\n      for (k = 1; k <= len; k++)\n      {  i = ind[k];\n         xassert(1 <= i && i <= G->nv);\n         s += (double)w[i];\n      }\n      if (sol != NULL) *sol = s;\n      /* mark vertices included in the clique */\n      if (v_set >= 0)\n      {  x = 0;\n         for (i = 1; i <= G->nv; i++)\n            memcpy((char *)G->v[i]->data + v_set, &x, sizeof(int));\n         x = 1;\n         for (k = 1; k <= len; k++)\n         {  i = ind[k];\n            memcpy((char *)G->v[i]->data + v_set, &x, sizeof(int));\n         }\n      }\ndone: /* free working arrays */\n      xfree(w);\n      xfree(ind);\n      xfree(a);\n      return ret;\n}",
      "lines": 84,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/weak.c": {
    "glp_weak_comp": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int glp_weak_comp(glp_graph *G, int v_num)\n{     glp_vertex *v;\n      glp_arc *a;\n      int f, i, j, nc, nv, pos1, pos2, *prev, *next, *list;\n      if (v_num >= 0 && v_num > G->v_size - (int)sizeof(int))\n         xerror(\"glp_weak_comp: v_num = %d; invalid offset\\n\", v_num);\n      nv = G->nv;\n      if (nv == 0)\n      {  nc = 0;\n         goto done;\n      }\n      /* allocate working arrays */\n      prev = xcalloc(1+nv, sizeof(int));\n      next = xcalloc(1+nv, sizeof(int));\n      list = xcalloc(1+nv, sizeof(int));\n      /* if vertex i is unlabelled, prev[i] is the index of previous\n         unlabelled vertex, and next[i] is the index of next unlabelled\n         vertex; if vertex i is labelled, then prev[i] < 0, and next[i]\n         is the connected component number */\n      /* initially all vertices are unlabelled */\n      f = 1;\n      for (i = 1; i <= nv; i++)\n         prev[i] = i - 1, next[i] = i + 1;\n      next[nv] = 0;\n      /* main loop (until all vertices have been labelled) */\n      nc = 0;\n      while (f != 0)\n      {  /* take an unlabelled vertex */\n         i = f;\n         /* and remove it from the list of unlabelled vertices */\n         f = next[i];\n         if (f != 0) prev[f] = 0;\n         /* label the vertex; it begins a new component */\n         prev[i] = -1, next[i] = ++nc;\n         /* breadth first search */\n         list[1] = i, pos1 = pos2 = 1;\n         while (pos1 <= pos2)\n         {  /* dequeue vertex i */\n            i = list[pos1++];\n            /* consider all arcs incoming to vertex i */\n            for (a = G->v[i]->in; a != NULL; a = a->h_next)\n            {  /* vertex j is adjacent to vertex i */\n               j = a->tail->i;\n               if (prev[j] >= 0)\n               {  /* vertex j is unlabelled */\n                  /* remove it from the list of unlabelled vertices */\n                  if (prev[j] == 0)\n                     f = next[j];\n                  else\n                     next[prev[j]] = next[j];\n                  if (next[j] == 0)\n                     ;\n                  else\n                     prev[next[j]] = prev[j];\n                  /* label the vertex */\n                  prev[j] = -1, next[j] = nc;\n                  /* and enqueue it for further consideration */\n                  list[++pos2] = j;\n               }\n            }\n            /* consider all arcs outgoing from vertex i */\n            for (a = G->v[i]->out; a != NULL; a = a->t_next)\n            {  /* vertex j is adjacent to vertex i */\n               j = a->head->i;\n               if (prev[j] >= 0)\n               {  /* vertex j is unlabelled */\n                  /* remove it from the list of unlabelled vertices */\n                  if (prev[j] == 0)\n                     f = next[j];\n                  else\n                     next[prev[j]] = next[j];\n                  if (next[j] == 0)\n                     ;\n                  else\n                     prev[next[j]] = prev[j];\n                  /* label the vertex */\n                  prev[j] = -1, next[j] = nc;\n                  /* and enqueue it for further consideration */\n                  list[++pos2] = j;\n               }\n            }\n         }\n      }\n      /* store component numbers */\n      if (v_num >= 0)\n      {  for (i = 1; i <= nv; i++)\n         {  v = G->v[i];\n            memcpy((char *)v->data + v_num, &next[i], sizeof(int));\n         }\n      }\n      /* free working arrays */\n      xfree(prev);\n      xfree(next);\n      xfree(list);\ndone: return nc;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrasn.c": {
    "glp_write_asnprob": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int glp_write_asnprob(glp_graph *G, int v_set, int a_cost, const char\n      *fname)\n{     glp_file *fp;\n      glp_vertex *v;\n      glp_arc *a;\n      int i, k, count = 0, ret;\n      double cost;\n      if (v_set >= 0 && v_set > G->v_size - (int)sizeof(int))\n         xerror(\"glp_write_asnprob: v_set = %d; invalid offset\\n\",\n            v_set);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_write_asnprob: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      xprintf(\"Writing assignment problem data to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"c %s\\n\",\n         G->name == NULL ? \"unknown\" : G->name), count++;\n      xfprintf(fp, \"p asn %d %d\\n\", G->nv, G->na), count++;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         if (v_set >= 0)\n            memcpy(&k, (char *)v->data + v_set, sizeof(int));\n         else\n            k = (v->out != NULL ? 0 : 1);\n         if (k == 0)\n            xfprintf(fp, \"n %d\\n\", i), count++;\n      }\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 1.0;\n            xfprintf(fp, \"a %d %d %.*g\\n\",\n               a->tail->i, a->head->i, DBL_DIG, cost), count++;\n         }\n      }\n      xfprintf(fp, \"c eof\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 57,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrcc.c": {
    "glp_write_ccdata": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int glp_write_ccdata(glp_graph *G, int v_wgt, const char *fname)\n{     glp_file *fp;\n      glp_vertex *v;\n      glp_arc *e;\n      int i, count = 0, ret;\n      double w;\n      if (v_wgt >= 0 && v_wgt > G->v_size - (int)sizeof(double))\n         xerror(\"glp_write_ccdata: v_wgt = %d; invalid offset\\n\",\n            v_wgt);\n      xprintf(\"Writing graph to '%s'\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"c %s\\n\",\n         G->name == NULL ? \"unknown\" : G->name), count++;\n      xfprintf(fp, \"p edge %d %d\\n\", G->nv, G->na), count++;\n      if (v_wgt >= 0)\n      {  for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            memcpy(&w, (char *)v->data + v_wgt, sizeof(double));\n            if (w != 1.0)\n               xfprintf(fp, \"n %d %.*g\\n\", i, DBL_DIG, w), count++;\n         }\n      }\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (e = v->out; e != NULL; e = e->t_next)\n            xfprintf(fp, \"e %d %d\\n\", e->tail->i, e->head->i), count++;\n      }\n      xfprintf(fp, \"c eof\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glp_write_graph": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int glp_write_graph(glp_graph *G, const char *fname)\n{     return\n         glp_write_ccdata(G, -1, fname);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrcnf.c": {
    "glp_write_cnfsat": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int glp_write_cnfsat(glp_prob *P, const char *fname)\n{     /* write CNF-SAT problem data in DIMACS format */\n      glp_file *fp = NULL;\n      GLPAIJ *aij;\n      int i, j, len, count = 0, ret;\n      char s[50];\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_write_cnfsat: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (glp_check_cnfsat(P) != 0)\n      {  xprintf(\"glp_write_cnfsat: problem object does not encode CNF-\"\n            \"SAT instance\\n\");\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"Writing CNF-SAT problem data to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"c %s\\n\",\n         P->name == NULL ? \"unknown\" : P->name), count++;\n      xfprintf(fp, \"p cnf %d %d\\n\", P->n, P->m), count++;\n      for (i = 1; i <= P->m; i++)\n      {  len = 0;\n         for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  j = aij->col->j;\n            if (aij->val < 0.0) j = -j;\n            sprintf(s, \"%d\", j);\n            if (len > 0 && len + 1 + strlen(s) > 72)\n               xfprintf(fp, \"\\n\"), count++, len = 0;\n            xfprintf(fp, \"%s%s\", len == 0 ? \"\" : \" \", s);\n            if (len > 0) len++;\n            len += strlen(s);\n         }\n         if (len > 0 && len + 1 + 1 > 72)\n            xfprintf(fp, \"\\n\"), count++, len = 0;\n         xfprintf(fp, \"%s0\\n\", len == 0 ? \"\" : \" \"), count++;\n      }\n      xfprintf(fp, \"c eof\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wript.c": {
    "glp_write_ipt": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int glp_write_ipt(glp_prob *P, const char *fname)\n{     glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, count, ret = 1;\n      char *s;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_write_ipt: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_write_ipt: fname = %d; invalid parameter\\n\", fname)\n            ;\n      xprintf(\"Writing interior-point solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\"), count = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* write comment lines */\n      glp_format(fp, \"c %-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Rows:\", P->m), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Columns:\", P->n), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Non-zeros:\", P->nnz), count++;\n      switch (P->ipt_stat)\n      {  case GLP_OPT:    s = \"OPTIMAL\";                   break;\n         case GLP_INFEAS: s = \"INFEASIBLE (INTERMEDIATE)\"; break;\n         case GLP_NOFEAS: s = \"INFEASIBLE (FINAL)\";        break;\n         case GLP_UNDEF:  s = \"UNDEFINED\";                 break;\n         default:         s = \"???\";                       break;\n      }\n      glp_format(fp, \"c %-12s%s\\n\", \"Status:\", s), count++;\n      switch (P->dir)\n      {  case GLP_MIN: s = \"MINimum\"; break;\n         case GLP_MAX: s = \"MAXimum\"; break;\n         default:      s = \"???\";     break;\n      }\n      glp_format(fp, \"c %-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->ipt_obj, s), count++;\n      glp_format(fp, \"c\\n\"), count++;\n      /* write solution line */\n      glp_format(fp, \"s ipt %d %d \", P->m, P->n), count++;\n      switch (P->ipt_stat)\n      {  case GLP_OPT:    glp_format(fp, \"o\"); break;\n         case GLP_INFEAS: glp_format(fp, \"i\"); break;\n         case GLP_NOFEAS: glp_format(fp, \"n\"); break;\n         case GLP_UNDEF:  glp_format(fp, \"u\"); break;\n         default:         glp_format(fp, \"?\"); break;\n      }\n      glp_format(fp, \" %.*g\\n\", DBL_DIG, P->ipt_obj);\n      /* write row solution descriptor lines */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         glp_format(fp, \"i %d %.*g %.*g\\n\", i, DBL_DIG, row->pval,\n            DBL_DIG, row->dval), count++;\n      }\n      /* write column solution descriptor lines */\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         glp_format(fp, \"j %d %.*g %.*g\\n\", j, DBL_DIG, col->pval,\n            DBL_DIG, col->dval), count++;\n      }\n      /* write end line */\n      glp_format(fp, \"e o f\\n\"), count++;\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* interior-point solution has been successfully written */\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL)\n         glp_close(fp);\n      return ret;\n}",
      "lines": 77,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrmaxf.c": {
    "glp_write_maxflow": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int glp_write_maxflow(glp_graph *G, int s, int t, int a_cap,\n      const char *fname)\n{     glp_file *fp;\n      glp_vertex *v;\n      glp_arc *a;\n      int i, count = 0, ret;\n      double cap;\n      if (!(1 <= s && s <= G->nv))\n         xerror(\"glp_write_maxflow: s = %d; source node number out of r\"\n            \"ange\\n\", s);\n      if (!(1 <= t && t <= G->nv))\n         xerror(\"glp_write_maxflow: t = %d: sink node number out of ran\"\n            \"ge\\n\", t);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_write_mincost: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      xprintf(\"Writing maximum flow problem data to '%s'...\\n\",\n         fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"c %s\\n\",\n         G->name == NULL ? \"unknown\" : G->name), count++;\n      xfprintf(fp, \"p max %d %d\\n\", G->nv, G->na), count++;\n      xfprintf(fp, \"n %d s\\n\", s), count++;\n      xfprintf(fp, \"n %d t\\n\", t), count++;\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  if (a_cap >= 0)\n               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));\n            else\n               cap = 1.0;\n            xfprintf(fp, \"a %d %d %.*g\\n\",\n               a->tail->i, a->head->i, DBL_DIG, cap), count++;\n         }\n      }\n      xfprintf(fp, \"c eof\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrmcf.c": {
    "glp_write_mincost": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int glp_write_mincost(glp_graph *G, int v_rhs, int a_low, int a_cap,\n      int a_cost, const char *fname)\n{     glp_file *fp;\n      glp_vertex *v;\n      glp_arc *a;\n      int i, count = 0, ret;\n      double rhs, low, cap, cost;\n      if (v_rhs >= 0 && v_rhs > G->v_size - (int)sizeof(double))\n         xerror(\"glp_write_mincost: v_rhs = %d; invalid offset\\n\",\n            v_rhs);\n      if (a_low >= 0 && a_low > G->a_size - (int)sizeof(double))\n         xerror(\"glp_write_mincost: a_low = %d; invalid offset\\n\",\n            a_low);\n      if (a_cap >= 0 && a_cap > G->a_size - (int)sizeof(double))\n         xerror(\"glp_write_mincost: a_cap = %d; invalid offset\\n\",\n            a_cap);\n      if (a_cost >= 0 && a_cost > G->a_size - (int)sizeof(double))\n         xerror(\"glp_write_mincost: a_cost = %d; invalid offset\\n\",\n            a_cost);\n      xprintf(\"Writing min-cost flow problem data to '%s'...\\n\",\n         fname);\n      fp = glp_open(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xfprintf(fp, \"c %s\\n\",\n         G->name == NULL ? \"unknown\" : G->name), count++;\n      xfprintf(fp, \"p min %d %d\\n\", G->nv, G->na), count++;\n      if (v_rhs >= 0)\n      {  for (i = 1; i <= G->nv; i++)\n         {  v = G->v[i];\n            memcpy(&rhs, (char *)v->data + v_rhs, sizeof(double));\n            if (rhs != 0.0)\n               xfprintf(fp, \"n %d %.*g\\n\", i, DBL_DIG, rhs), count++;\n         }\n      }\n      for (i = 1; i <= G->nv; i++)\n      {  v = G->v[i];\n         for (a = v->out; a != NULL; a = a->t_next)\n         {  if (a_low >= 0)\n               memcpy(&low, (char *)a->data + a_low, sizeof(double));\n            else\n               low = 0.0;\n            if (a_cap >= 0)\n               memcpy(&cap, (char *)a->data + a_cap, sizeof(double));\n            else\n               cap = 1.0;\n            if (a_cost >= 0)\n               memcpy(&cost, (char *)a->data + a_cost, sizeof(double));\n            else\n               cost = 0.0;\n            xfprintf(fp, \"a %d %d %.*g %.*g %.*g\\n\",\n               a->tail->i, a->head->i, DBL_DIG, low, DBL_DIG, cap,\n               DBL_DIG, cost), count++;\n         }\n      }\n      xfprintf(fp, \"c eof\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrmip.c": {
    "glp_write_mip": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int glp_write_mip(glp_prob *P, const char *fname)\n{     glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, count, ret = 1;\n      char *s;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_write_mip: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_write_mip: fname = %d; invalid parameter\\n\", fname)\n            ;\n      xprintf(\"Writing MIP solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\"), count = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* write comment lines */\n      glp_format(fp, \"c %-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Rows:\", P->m), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Columns:\", P->n), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Non-zeros:\", P->nnz), count++;\n      switch (P->mip_stat)\n      {  case GLP_OPT:    s = \"INTEGER OPTIMAL\";           break;\n         case GLP_FEAS:   s = \"INTEGER NON-OPTIMAL\";       break;\n         case GLP_NOFEAS: s = \"INTEGER EMPTY\";             break;\n         case GLP_UNDEF:  s = \"INTEGER UNDEFINED\";         break;\n         default:         s = \"???\";                       break;\n      }\n      glp_format(fp, \"c %-12s%s\\n\", \"Status:\", s), count++;\n      switch (P->dir)\n      {  case GLP_MIN: s = \"MINimum\"; break;\n         case GLP_MAX: s = \"MAXimum\"; break;\n         default:      s = \"???\";     break;\n      }\n      glp_format(fp, \"c %-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->mip_obj, s), count++;\n      glp_format(fp, \"c\\n\"), count++;\n      /* write solution line */\n      glp_format(fp, \"s mip %d %d \", P->m, P->n), count++;\n      switch (P->mip_stat)\n      {  case GLP_OPT:    glp_format(fp, \"o\"); break;\n         case GLP_FEAS:   glp_format(fp, \"f\"); break;\n         case GLP_NOFEAS: glp_format(fp, \"n\"); break;\n         case GLP_UNDEF:  glp_format(fp, \"u\"); break;\n         default:         glp_format(fp, \"?\"); break;\n      }\n      glp_format(fp, \" %.*g\\n\", DBL_DIG, P->mip_obj);\n      /* write row solution descriptor lines */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         glp_format(fp, \"i %d %.*g\\n\", i, DBL_DIG, row->mipx), count++;\n      }\n      /* write column solution descriptor lines */\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         glp_format(fp, \"j %d %.*g\\n\", j, DBL_DIG, col->mipx), count++;\n      }\n      /* write end line */\n      glp_format(fp, \"e o f\\n\"), count++;\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* MIP solution has been successfully written */\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL)\n         glp_close(fp);\n      return ret;\n}",
      "lines": 75,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrprob.c": {
    "glp_write_prob": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int glp_write_prob(glp_prob *P, int flags, const char *fname)\n{     glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int mip, i, j, count, ret;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_write_prob: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      if (flags != 0)\n         xerror(\"glp_write_prob: flags = %d; invalid parameter\\n\",\n            flags);\n      if (fname == NULL)\n         xerror(\"glp_write_prob: fname = %d; invalid parameter\\n\",\n            fname);\n      xprintf(\"Writing problem data to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\"), count = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      /* write problem line */\n      mip = (glp_get_num_int(P) > 0);\n      xfprintf(fp, \"p %s %s %d %d %d\\n\", !mip ? \"lp\" : \"mip\",\n         P->dir == GLP_MIN ? \"min\" : P->dir == GLP_MAX ? \"max\" : \"???\",\n         P->m, P->n, P->nnz), count++;\n      if (P->name != NULL)\n         xfprintf(fp, \"n p %s\\n\", P->name), count++;\n      if (P->obj != NULL)\n         xfprintf(fp, \"n z %s\\n\", P->obj), count++;\n      /* write row descriptors */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->type == GLP_FX && row->lb == 0.0)\n            goto skip1;\n         xfprintf(fp, \"i %d \", i), count++;\n         if (row->type == GLP_FR)\n            xfprintf(fp, \"f\\n\");\n         else if (row->type == GLP_LO)\n            xfprintf(fp, \"l %.*g\\n\", DBL_DIG, row->lb);\n         else if (row->type == GLP_UP)\n            xfprintf(fp, \"u %.*g\\n\", DBL_DIG, row->ub);\n         else if (row->type == GLP_DB)\n            xfprintf(fp, \"d %.*g %.*g\\n\", DBL_DIG, row->lb, DBL_DIG,\n                  row->ub);\n         else if (row->type == GLP_FX)\n            xfprintf(fp, \"s %.*g\\n\", DBL_DIG, row->lb);\n         else\n            xassert(row != row);\nskip1:   if (row->name != NULL)\n            xfprintf(fp, \"n i %d %s\\n\", i, row->name), count++;\n      }\n      /* write column descriptors */\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (!mip && col->type == GLP_LO && col->lb == 0.0)\n            goto skip2;\n         if (mip && col->kind == GLP_IV && col->type == GLP_DB &&\n             col->lb == 0.0 && col->ub == 1.0)\n            goto skip2;\n         xfprintf(fp, \"j %d \", j), count++;\n         if (mip)\n         {  if (col->kind == GLP_CV)\n               xfprintf(fp, \"c \");\n            else if (col->kind == GLP_IV)\n               xfprintf(fp, \"i \");\n            else\n               xassert(col != col);\n         }\n         if (col->type == GLP_FR)\n            xfprintf(fp, \"f\\n\");\n         else if (col->type == GLP_LO)\n            xfprintf(fp, \"l %.*g\\n\", DBL_DIG, col->lb);\n         else if (col->type == GLP_UP)\n            xfprintf(fp, \"u %.*g\\n\", DBL_DIG, col->ub);\n         else if (col->type == GLP_DB)\n            xfprintf(fp, \"d %.*g %.*g\\n\", DBL_DIG, col->lb, DBL_DIG,\n                  col->ub);\n         else if (col->type == GLP_FX)\n            xfprintf(fp, \"s %.*g\\n\", DBL_DIG, col->lb);\n         else\n            xassert(col != col);\nskip2:   if (col->name != NULL)\n            xfprintf(fp, \"n j %d %s\\n\", j, col->name), count++;\n      }\n      /* write objective coefficient descriptors */\n      if (P->c0 != 0.0)\n         xfprintf(fp, \"a 0 0 %.*g\\n\", DBL_DIG, P->c0), count++;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->coef != 0.0)\n            xfprintf(fp, \"a 0 %d %.*g\\n\", j, DBL_DIG, col->coef),\n               count++;\n      }\n      /* write constraint coefficient descriptors */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n            xfprintf(fp, \"a %d %d %.*g\\n\", i, aij->col->j, DBL_DIG,\n               aij->val), count++;\n      }\n      /* write end line */\n      xfprintf(fp, \"e o f\\n\"), count++;\n#if 0 /* FIXME */\n      xfflush(fp);\n#endif\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL) glp_close(fp);\n      return ret;\n}",
      "lines": 119,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/api/wrsol.c": {
    "glp_write_sol": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int glp_write_sol(glp_prob *P, const char *fname)\n{     glp_file *fp;\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j, count, ret = 1;\n      char *s;\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_write_sol: P = %p; invalid problem object\\n\", P);\n#endif\n      if (fname == NULL)\n         xerror(\"glp_write_sol: fname = %d; invalid parameter\\n\", fname)\n            ;\n      xprintf(\"Writing basic solution to '%s'...\\n\", fname);\n      fp = glp_open(fname, \"w\"), count = 0;\n      if (fp == NULL)\n      {  xprintf(\"Unable to create '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* write comment lines */\n      glp_format(fp, \"c %-12s%s\\n\", \"Problem:\",\n         P->name == NULL ? \"\" : P->name), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Rows:\", P->m), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Columns:\", P->n), count++;\n      glp_format(fp, \"c %-12s%d\\n\", \"Non-zeros:\", P->nnz), count++;\n      switch (glp_get_status(P))\n      {  case GLP_OPT:    s = \"OPTIMAL\";                   break;\n         case GLP_FEAS:   s = \"FEASIBLE\";                  break;\n         case GLP_INFEAS: s = \"INFEASIBLE (INTERMEDIATE)\"; break;\n         case GLP_NOFEAS: s = \"INFEASIBLE (FINAL)\";        break;\n         case GLP_UNBND:  s = \"UNBOUNDED\";                 break;\n         case GLP_UNDEF:  s = \"UNDEFINED\";                 break;\n         default:         s = \"???\";                       break;\n      }\n      glp_format(fp, \"c %-12s%s\\n\", \"Status:\", s), count++;\n      switch (P->dir)\n      {  case GLP_MIN: s = \"MINimum\"; break;\n         case GLP_MAX: s = \"MAXimum\"; break;\n         default:      s = \"???\";     break;\n      }\n      glp_format(fp, \"c %-12s%s%s%.10g (%s)\\n\", \"Objective:\",\n         P->obj == NULL ? \"\" : P->obj,\n         P->obj == NULL ? \"\" : \" = \", P->obj_val, s), count++;\n      glp_format(fp, \"c\\n\"), count++;\n      /* write solution line */\n      glp_format(fp, \"s bas %d %d \", P->m, P->n), count++;\n      switch (P->pbs_stat)\n      {  case GLP_UNDEF:  glp_format(fp, \"u\"); break;\n         case GLP_FEAS:   glp_format(fp, \"f\"); break;\n         case GLP_INFEAS: glp_format(fp, \"i\"); break;\n         case GLP_NOFEAS: glp_format(fp, \"n\"); break;\n         default:         glp_format(fp, \"?\"); break;\n      }\n      glp_format(fp, \" \");\n      switch (P->dbs_stat)\n      {  case GLP_UNDEF:  glp_format(fp, \"u\"); break;\n         case GLP_FEAS:   glp_format(fp, \"f\"); break;\n         case GLP_INFEAS: glp_format(fp, \"i\"); break;\n         case GLP_NOFEAS: glp_format(fp, \"n\"); break;\n         default:         glp_format(fp, \"?\"); break;\n      }\n      glp_format(fp, \" %.*g\\n\", DBL_DIG, P->obj_val);\n      /* write row solution descriptor lines */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         glp_format(fp, \"i %d \", i), count++;\n         switch (row->stat)\n         {  case GLP_BS:\n               glp_format(fp, \"b\");\n               break;\n            case GLP_NL:\n               glp_format(fp, \"l\");\n               break;\n            case GLP_NU:\n               glp_format(fp, \"u\");\n               break;\n            case GLP_NF:\n               glp_format(fp, \"f\");\n               break;\n            case GLP_NS:\n               glp_format(fp, \"s\");\n               break;\n            default:\n               xassert(row != row);\n         }\n         glp_format(fp, \" %.*g %.*g\\n\", DBL_DIG, row->prim, DBL_DIG,\n            row->dual);\n      }\n      /* write column solution descriptor lines */\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         glp_format(fp, \"j %d \", j), count++;\n         switch (col->stat)\n         {  case GLP_BS:\n               glp_format(fp, \"b\");\n               break;\n            case GLP_NL:\n               glp_format(fp, \"l\");\n               break;\n            case GLP_NU:\n               glp_format(fp, \"u\");\n               break;\n            case GLP_NF:\n               glp_format(fp, \"f\");\n               break;\n            case GLP_NS:\n               glp_format(fp, \"s\");\n               break;\n            default:\n               xassert(col != col);\n         }\n         glp_format(fp, \" %.*g %.*g\\n\", DBL_DIG, col->prim, DBL_DIG,\n            col->dual);\n      }\n      /* write end line */\n      glp_format(fp, \"e o f\\n\"), count++;\n      if (glp_ioerr(fp))\n      {  xprintf(\"Write error on '%s' - %s\\n\", fname, get_err_msg());\n         goto done;\n      }\n      /* basic solution has been successfully written */\n      xprintf(\"%d lines were written\\n\", count);\n      ret = 0;\ndone: if (fp != NULL)\n         glp_close(fp);\n      return ret;\n}",
      "lines": 127,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/btf.c": {
    "btf_store_a_cols": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int btf_store_a_cols(BTF *btf, int (*col)(void *info, int j, int ind[],\n      double val[]), void *info, int ind[], double val[])\n{     int n = btf->n;\n      SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      int j, len, ptr, nnz;\n      nnz = 0;\n      for (j = 1; j <= n; j++)\n      {  /* get j-th column */\n         len = col(info, j, ind, val);\n         xassert(0 <= len && len <= n);\n         /* reserve locations for j-th column */\n         if (len > 0)\n         {  if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n            }\n            sva_reserve_cap(sva, ac_ref+(j-1), len);\n         }\n         /* store pattern of j-th column */\n         ptr = ac_ptr[j];\n         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));\n         ac_len[j] = len;\n         nnz += len;\n      }\n      return nnz;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "btf_make_blocks": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int btf_make_blocks(BTF *btf)\n{     int n = btf->n;\n      SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      int *pp_ind = btf->pp_ind;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int *qq_inv = btf->qq_inv;\n      int *beg = btf->beg;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      int i, j, rank, *iperm, *pr, *arp, *cv, *out, *ip, *lenr, *lowl,\n         *numb, *prev;\n      /* determine column permutation matrix M such that matrix A * M\n       * has zero-free diagonal */\n      iperm = qq_inv; /* matrix M */\n      pr  = btf->p1_ind; /* working array */\n      arp = btf->p1_inv; /* working array */\n      cv  = btf->q1_ind; /* working array */\n      out = btf->q1_inv; /* working array */\n      rank = mc21a(n, sv_ind, ac_ptr, ac_len, iperm, pr, arp, cv, out);\n      xassert(0 <= rank && rank <= n);\n      if (rank < n)\n      {  /* A is structurally singular (rank is its symbolic rank) */\n         goto done;\n      }\n      /* build pattern of matrix A * M */\n      ip   = pp_ind; /* working array */\n      lenr = qq_ind; /* working array */\n      for (j = 1; j <= n; j++)\n      {  ip[j] = ac_ptr[iperm[j]];\n         lenr[j] = ac_len[iperm[j]];\n      }\n      /* determine symmetric permutation matrix S such that matrix\n       * S * (A * M) * S' = A~ is upper block triangular */\n      lowl = btf->p1_ind; /* working array */\n      numb = btf->p1_inv; /* working array */\n      prev = btf->q1_ind; /* working array */\n      btf->num =\n         mc13d(n, sv_ind, ip, lenr, pp_inv, beg, lowl, numb, prev);\n      xassert(beg[1] == 1);\n      beg[btf->num+1] = n+1;\n      /* A * M = S' * A~ * S ==> A = S' * A~ * (S * M') */\n      /* determine permutation matrix P = S' */\n      for (j = 1; j <= n; j++)\n         pp_ind[pp_inv[j]] = j;\n      /* determine permutation matrix Q = S * M' = P' * M' */\n      for (i = 1; i <= n; i++)\n         qq_ind[i] = iperm[pp_inv[i]];\n      for (i = 1; i <= n; i++)\n         qq_inv[qq_ind[i]] = i;\ndone: return rank;\n}",
      "lines": 54,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "btf_check_blocks": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "void btf_check_blocks(BTF *btf)\n{     int n = btf->n;\n      SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      int *pp_ind = btf->pp_ind;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int *qq_inv = btf->qq_inv;\n      int num = btf->num;\n      int *beg = btf->beg;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      int i, ii, j, jj, k, size, ptr, end, diag;\n      xassert(n > 0);\n      /* check permutation matrices P and Q */\n      for (k = 1; k <= n; k++)\n      {  xassert(1 <= pp_ind[k] && pp_ind[k] <= n);\n         xassert(pp_inv[pp_ind[k]] == k);\n         xassert(1 <= qq_ind[k] && qq_ind[k] <= n);\n         xassert(qq_inv[qq_ind[k]] == k);\n      }\n      /* check that matrix A~ is upper block triangular with non-zero\n       * diagonal */\n      xassert(1 <= num && num <= n);\n      xassert(beg[1] == 1);\n      xassert(beg[num+1] == n+1);\n      /* walk thru blocks of A~ */\n      for (k = 1; k <= num; k++)\n      {  /* determine size of k-th block */\n         size = beg[k+1] - beg[k];\n         xassert(size >= 1);\n         /* walk thru columns of k-th block */\n         for (jj = beg[k]; jj < beg[k+1]; jj++)\n         {  diag = 0;\n            /* jj-th column of A~ = j-th column of A */\n            j = qq_ind[jj];\n            /* walk thru elements of j-th column of A */\n            ptr = ac_ptr[j];\n            end = ptr + ac_len[j];\n            for (; ptr < end; ptr++)\n            {  /* determine row index of a[i,j] */\n               i = sv_ind[ptr];\n               /* i-th row of A = ii-th row of A~ */\n               ii = pp_ind[i];\n               /* a~[ii,jj] should not be below k-th block */\n               xassert(ii < beg[k+1]);\n               if (ii == jj)\n               {  /* non-zero diagonal element of A~ encountered */\n                  diag = 1;\n               }\n            }\n            xassert(diag);\n         }\n      }\n      return;\n}",
      "lines": 57,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "btf_build_a_rows": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "void btf_build_a_rows(BTF *btf, int len[/*1+n*/])\n{     int n = btf->n;\n      SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int ar_ref = btf->ar_ref;\n      int *ar_ptr = &sva->ptr[ar_ref-1];\n      int *ar_len = &sva->len[ar_ref-1];\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      int i, j, end, nnz, ptr, ptr1;\n      /* calculate the number of non-zeros in each row of matrix A and\n       * the total number of non-zeros */\n      nnz = 0;\n      for (i = 1; i <= n; i++)\n         len[i] = 0;\n      for (j = 1; j <= n; j++)\n      {  nnz += ac_len[j];\n         for (end = (ptr = ac_ptr[j]) + ac_len[j]; ptr < end; ptr++)\n            len[sv_ind[ptr]]++;\n      }\n      /* we need at least nnz free locations in SVA */\n      if (sva->r_ptr - sva->m_ptr < nnz)\n      {  sva_more_space(sva, nnz);\n         sv_ind = sva->ind;\n         sv_val = sva->val;\n      }\n      /* reserve locations for rows of matrix A */\n      for (i = 1; i <= n; i++)\n      {  if (len[i] > 0)\n            sva_reserve_cap(sva, ar_ref-1+i, len[i]);\n         ar_len[i] = len[i];\n      }\n      /* walk thru columns of matrix A and build its rows */\n      for (j = 1; j <= n; j++)\n      {  for (end = (ptr = ac_ptr[j]) + ac_len[j]; ptr < end; ptr++)\n         {  i = sv_ind[ptr];\n            sv_ind[ptr1 = ar_ptr[i] + (--len[i])] = j;\n            sv_val[ptr1] = sv_val[ptr];\n         }\n      }\n      return;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "btf_a_solve": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "void btf_a_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],\n      double w1[/*1+n*/], double w2[/*1+n*/])\n{     SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int num = btf->num;\n      int *beg = btf->beg;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      double *bb = w1;\n      double *xx = w2;\n      LUF luf;\n      int i, j, jj, k, beg_k, flag;\n      double t;\n      for (k = num; k >= 1; k--)\n      {  /* determine order of diagonal block A~[k,k] */\n         luf.n = beg[k+1] - (beg_k = beg[k]);\n         if (luf.n == 1)\n         {  /* trivial case */\n            /* solve system A~[k,k] * X[k] = B[k] */\n            t = x[qq_ind[beg_k]] =\n               b[pp_inv[beg_k]] / btf->vr_piv[beg_k];\n            /* substitute X[k] into other equations */\n            if (t != 0.0)\n            {  int ptr = ac_ptr[qq_ind[beg_k]];\n               int end = ptr + ac_len[qq_ind[beg_k]];\n               for (; ptr < end; ptr++)\n                  b[sv_ind[ptr]] -= sv_val[ptr] * t;\n            }\n         }\n         else\n         {  /* general case */\n            /* construct B[k] */\n            flag = 0;\n            for (i = 1; i <= luf.n; i++)\n            {  if ((bb[i] = b[pp_inv[i + (beg_k-1)]]) != 0.0)\n                  flag = 1;\n            }\n            /* solve system A~[k,k] * X[k] = B[k] */\n            if (!flag)\n            {  /* B[k] = 0, so X[k] = 0 */\n               for (j = 1; j <= luf.n; j++)\n                  x[qq_ind[j + (beg_k-1)]] = 0.0;\n               continue;\n            }\n            luf.sva = sva;\n            luf.fr_ref = btf->fr_ref + (beg_k-1);\n            luf.fc_ref = btf->fc_ref + (beg_k-1);\n            luf.vr_ref = btf->vr_ref + (beg_k-1);\n            luf.vr_piv = btf->vr_piv + (beg_k-1);\n            luf.vc_ref = btf->vc_ref + (beg_k-1);\n            luf.pp_ind = btf->p1_ind + (beg_k-1);\n            luf.pp_inv = btf->p1_inv + (beg_k-1);\n            luf.qq_ind = btf->q1_ind + (beg_k-1);\n            luf.qq_inv = btf->q1_inv + (beg_k-1);\n            luf_f_solve(&luf, bb);\n            luf_v_solve(&luf, bb, xx);\n            /* store X[k] and substitute it into other equations */\n            for (j = 1; j <= luf.n; j++)\n            {  jj = j + (beg_k-1);\n               t = x[qq_ind[jj]] = xx[j];\n               if (t != 0.0)\n               {  int ptr = ac_ptr[qq_ind[jj]];\n                  int end = ptr + ac_len[qq_ind[jj]];\n                  for (; ptr < end; ptr++)\n                     b[sv_ind[ptr]] -= sv_val[ptr] * t;\n               }\n            }\n         }\n      }\n      return;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "btf_at_solve": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void btf_at_solve(BTF *btf, double b[/*1+n*/], double x[/*1+n*/],\n      double w1[/*1+n*/], double w2[/*1+n*/])\n{     SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int num = btf->num;\n      int *beg = btf->beg;\n      int ar_ref = btf->ar_ref;\n      int *ar_ptr = &sva->ptr[ar_ref-1];\n      int *ar_len = &sva->len[ar_ref-1];\n      double *bb = w1;\n      double *xx = w2;\n      LUF luf;\n      int i, j, jj, k, beg_k, flag;\n      double t;\n      for (k = 1; k <= num; k++)\n      {  /* determine order of diagonal block A~[k,k] */\n         luf.n = beg[k+1] - (beg_k = beg[k]);\n         if (luf.n == 1)\n         {  /* trivial case */\n            /* solve system A~'[k,k] * X[k] = B[k] */\n            t = x[pp_inv[beg_k]] =\n               b[qq_ind[beg_k]] / btf->vr_piv[beg_k];\n            /* substitute X[k] into other equations */\n            if (t != 0.0)\n            {  int ptr = ar_ptr[pp_inv[beg_k]];\n               int end = ptr + ar_len[pp_inv[beg_k]];\n               for (; ptr < end; ptr++)\n                  b[sv_ind[ptr]] -= sv_val[ptr] * t;\n            }\n         }\n         else\n         {  /* general case */\n            /* construct B[k] */\n            flag = 0;\n            for (i = 1; i <= luf.n; i++)\n            {  if ((bb[i] = b[qq_ind[i + (beg_k-1)]]) != 0.0)\n                  flag = 1;\n            }\n            /* solve system A~'[k,k] * X[k] = B[k] */\n            if (!flag)\n            {  /* B[k] = 0, so X[k] = 0 */\n               for (j = 1; j <= luf.n; j++)\n                  x[pp_inv[j + (beg_k-1)]] = 0.0;\n               continue;\n            }\n            luf.sva = sva;\n            luf.fr_ref = btf->fr_ref + (beg_k-1);\n            luf.fc_ref = btf->fc_ref + (beg_k-1);\n            luf.vr_ref = btf->vr_ref + (beg_k-1);\n            luf.vr_piv = btf->vr_piv + (beg_k-1);\n            luf.vc_ref = btf->vc_ref + (beg_k-1);\n            luf.pp_ind = btf->p1_ind + (beg_k-1);\n            luf.pp_inv = btf->p1_inv + (beg_k-1);\n            luf.qq_ind = btf->q1_ind + (beg_k-1);\n            luf.qq_inv = btf->q1_inv + (beg_k-1);\n            luf_vt_solve(&luf, bb, xx);\n            luf_ft_solve(&luf, xx);\n            /* store X[k] and substitute it into other equations */\n            for (j = 1; j <= luf.n; j++)\n            {  jj = j + (beg_k-1);\n               t = x[pp_inv[jj]] = xx[j];\n               if (t != 0.0)\n               {  int ptr = ar_ptr[pp_inv[jj]];\n                  int end = ptr + ar_len[pp_inv[jj]];\n                  for (; ptr < end; ptr++)\n                     b[sv_ind[ptr]] -= sv_val[ptr] * t;\n               }\n            }\n         }\n      }\n      return;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "btf_at_solve1": {
      "start_point": [
        455,
        0
      ],
      "end_point": [
        518,
        1
      ],
      "content": "void btf_at_solve1(BTF *btf, double e[/*1+n*/], double y[/*1+n*/],\n      double w1[/*1+n*/], double w2[/*1+n*/])\n{     SVA *sva = btf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int num = btf->num;\n      int *beg = btf->beg;\n      int ar_ref = btf->ar_ref;\n      int *ar_ptr = &sva->ptr[ar_ref-1];\n      int *ar_len = &sva->len[ar_ref-1];\n      double *ee = w1;\n      double *yy = w2;\n      LUF luf;\n      int i, j, jj, k, beg_k, ptr, end;\n      double e_k, y_k;\n      for (k = 1; k <= num; k++)\n      {  /* determine order of diagonal block A~[k,k] */\n         luf.n = beg[k+1] - (beg_k = beg[k]);\n         if (luf.n == 1)\n         {  /* trivial case */\n            /* determine E'[k] = E[k] + delta E[k] */\n            e_k = e[qq_ind[beg_k]];\n            e_k = (e_k >= 0.0 ? e_k + 1.0 : e_k - 1.0);\n            /* solve system A~'[k,k] * Y[k] = E[k] */\n            y_k = y[pp_inv[beg_k]] = e_k / btf->vr_piv[beg_k];\n            /* substitute Y[k] into other equations */\n            ptr = ar_ptr[pp_inv[beg_k]];\n            end = ptr + ar_len[pp_inv[beg_k]];\n            for (; ptr < end; ptr++)\n               e[sv_ind[ptr]] -= sv_val[ptr] * y_k;\n         }\n         else\n         {  /* general case */\n            /* construct E[k] */\n            for (i = 1; i <= luf.n; i++)\n               ee[i] = e[qq_ind[i + (beg_k-1)]];\n            /* solve system A~'[k,k] * Y[k] = E[k] + delta E[k] */\n            luf.sva = sva;\n            luf.fr_ref = btf->fr_ref + (beg_k-1);\n            luf.fc_ref = btf->fc_ref + (beg_k-1);\n            luf.vr_ref = btf->vr_ref + (beg_k-1);\n            luf.vr_piv = btf->vr_piv + (beg_k-1);\n            luf.vc_ref = btf->vc_ref + (beg_k-1);\n            luf.pp_ind = btf->p1_ind + (beg_k-1);\n            luf.pp_inv = btf->p1_inv + (beg_k-1);\n            luf.qq_ind = btf->q1_ind + (beg_k-1);\n            luf.qq_inv = btf->q1_inv + (beg_k-1);\n            luf_vt_solve1(&luf, ee, yy);\n            luf_ft_solve(&luf, yy);\n            /* store Y[k] and substitute it into other equations */\n            for (j = 1; j <= luf.n; j++)\n            {  jj = j + (beg_k-1);\n               y_k = y[pp_inv[jj]] = yy[j];\n               ptr = ar_ptr[pp_inv[jj]];\n               end = ptr + ar_len[pp_inv[jj]];\n               for (; ptr < end; ptr++)\n                  e[sv_ind[ptr]] -= sv_val[ptr] * y_k;\n            }\n         }\n      }\n      return;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "btf_estimate_norm": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "double btf_estimate_norm(BTF *btf, double w1[/*1+n*/], double\n      w2[/*1+n*/], double w3[/*1+n*/], double w4[/*1+n*/])\n{     int n = btf->n;\n      double *e = w1;\n      double *y = w2;\n      double *z = w1;\n      int i;\n      double y_norm, z_norm;\n      /* compute y = inv(A') * e to cause growth in y */\n      for (i = 1; i <= n; i++)\n         e[i] = 0.0;\n      btf_at_solve1(btf, e, y, w3, w4);\n      /* compute 1-norm of y = sum |y[i]| */\n      y_norm = 0.0;\n      for (i = 1; i <= n; i++)\n         y_norm += (y[i] >= 0.0 ? +y[i] : -y[i]);\n      /* compute z = inv(A) * y */\n      btf_a_solve(btf, y, z, w3, w4);\n      /* compute 1-norm of z = sum |z[i]| */\n      z_norm = 0.0;\n      for (i = 1; i <= n; i++)\n         z_norm += (z[i] >= 0.0 ? +z[i] : -z[i]);\n      /* estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y) */\n      return z_norm / y_norm;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/btf.h": {},
  "glpk/glpk-4.65/src/bflib/btfint.c": {
    "btfint_create": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "BTFINT *btfint_create(void)\n{     /* create interface to BT-factorization */\n      BTFINT *fi;\n      fi = talloc(1, BTFINT);\n      fi->n_max = 0;\n      fi->valid = 0;\n      fi->sva = NULL;\n      fi->btf = NULL;\n      fi->sgf = NULL;\n      fi->sva_n_max = fi->sva_size = 0;\n      fi->delta_n0 = fi->delta_n = 0;\n      fi->sgf_piv_tol = 0.10;\n      fi->sgf_piv_lim = 4;\n      fi->sgf_suhl = 1;\n      fi->sgf_eps_tol = DBL_EPSILON;\n      return fi;\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "BTFINT",
        "*btfint_create(void)",
        "*"
      ]
    },
    "factorize_triv": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void factorize_triv(BTFINT *fi, int k, int (*col)(void *info,\n      int j, int ind[], double val[]), void *info)\n{     /* compute LU-factorization of diagonal block A~[k,k] and store\n       * corresponding columns of matrix A except elements of A~[k,k]\n       * (trivial case when the block has unity size) */\n      SVA *sva = fi->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      BTF *btf = fi->btf;\n      int *pp_inv = btf->pp_inv;\n      int *qq_ind = btf->qq_ind;\n      int *beg = btf->beg;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      SGF *sgf = fi->sgf;\n      int *ind = (int *)sgf->vr_max; /* working array */\n      double *val = sgf->work; /* working array */\n      int i, j, t, len, ptr, beg_k;\n      /* diagonal block A~[k,k] has the only element in matrix A~,\n       * which is a~[beg[k],beg[k]] = a[i,j] */\n      beg_k = beg[k];\n      i = pp_inv[beg_k];\n      j = qq_ind[beg_k];\n      /* get j-th column of A */\n      len = col(info, j, ind, val);\n      /* find element a[i,j] = a~[beg[k],beg[k]] in j-th column */\n      for (t = 1; t <= len; t++)\n      {  if (ind[t] == i)\n            break;\n      }\n      xassert(t <= len);\n      /* compute LU-factorization of diagonal block A~[k,k], where\n       * F = (1), V = (a[i,j]), P = Q = (1) (see the module LUF) */\n#if 1 /* FIXME */\n      xassert(val[t] != 0.0);\n#endif\n      btf->vr_piv[beg_k] = val[t];\n      btf->p1_ind[beg_k] = btf->p1_inv[beg_k] = 1;\n      btf->q1_ind[beg_k] = btf->q1_inv[beg_k] = 1;\n      /* remove element a[i,j] = a~[beg[k],beg[k]] from j-th column */\n      memmove(&ind[t], &ind[t+1], (len-t) * sizeof(int));\n      memmove(&val[t], &val[t+1], (len-t) * sizeof(double));\n      len--;\n      /* and store resulting j-th column of A into BTF */\n      if (len > 0)\n      {  /* reserve locations for j-th column of A */\n         if (sva->r_ptr - sva->m_ptr < len)\n         {  sva_more_space(sva, len);\n            sv_ind = sva->ind;\n            sv_val = sva->val;\n         }\n         sva_reserve_cap(sva, ac_ref+(j-1), len);\n         /* store j-th column of A (except elements of A~[k,k]) */\n         ptr = ac_ptr[j];\n         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));\n         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));\n         ac_len[j] = len;\n      }\n      return;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "factorize_block": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static int factorize_block(BTFINT *fi, int k, int (*col)(void *info,\n      int j, int ind[], double val[]), void *info)\n{     /* compute LU-factorization of diagonal block A~[k,k] and store\n       * corresponding columns of matrix A except elements of A~[k,k]\n       * (general case) */\n      SVA *sva = fi->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      BTF *btf = fi->btf;\n      int *pp_ind = btf->pp_ind;\n      int *qq_ind = btf->qq_ind;\n      int *beg = btf->beg;\n      int ac_ref = btf->ac_ref;\n      int *ac_ptr = &sva->ptr[ac_ref-1];\n      int *ac_len = &sva->len[ac_ref-1];\n      SGF *sgf = fi->sgf;\n      int *ind = (int *)sgf->vr_max; /* working array */\n      double *val = sgf->work; /* working array */\n      LUF luf;\n      int *vc_ptr, *vc_len, *vc_cap;\n      int i, ii, j, jj, t, len, cnt, ptr, beg_k;\n      /* construct fake LUF for LU-factorization of A~[k,k] */\n      sgf->luf = &luf;\n      luf.n = beg[k+1] - (beg_k = beg[k]);\n      luf.sva = sva;\n      luf.fr_ref = btf->fr_ref + (beg_k-1);\n      luf.fc_ref = btf->fc_ref + (beg_k-1);\n      luf.vr_ref = btf->vr_ref + (beg_k-1);\n      luf.vr_piv = btf->vr_piv + (beg_k-1);\n      luf.vc_ref = btf->vc_ref + (beg_k-1);\n      luf.pp_ind = btf->p1_ind + (beg_k-1);\n      luf.pp_inv = btf->p1_inv + (beg_k-1);\n      luf.qq_ind = btf->q1_ind + (beg_k-1);\n      luf.qq_inv = btf->q1_inv + (beg_k-1);\n      /* process columns of k-th block of matrix A~ */\n      vc_ptr = &sva->ptr[luf.vc_ref-1];\n      vc_len = &sva->len[luf.vc_ref-1];\n      vc_cap = &sva->cap[luf.vc_ref-1];\n      for (jj = 1; jj <= luf.n; jj++)\n      {  /* jj-th column of A~ = j-th column of A */\n         j = qq_ind[jj + (beg_k-1)];\n         /* get j-th column of A */\n         len = col(info, j, ind, val);\n         /* move elements of diagonal block A~[k,k] to the beginning of\n          * the column list */\n         cnt = 0;\n         for (t = 1; t <= len; t++)\n         {  /* i = row index of element a[i,j] */\n            i = ind[t];\n            /* i-th row of A = ii-th row of A~ */\n            ii = pp_ind[i];\n            if (ii >= beg_k)\n            {  /* a~[ii,jj] = a[i,j] is in diagonal block A~[k,k] */\n               double temp;\n               cnt++;\n               ind[t] = ind[cnt];\n               ind[cnt] = ii - (beg_k-1); /* local index */\n               temp = val[t], val[t] = val[cnt], val[cnt] = temp;\n            }\n         }\n         /* first cnt elements in the column list give jj-th column of\n          * diagonal block A~[k,k], which is initial matrix V in LUF */\n         /* enlarge capacity of jj-th column of V = A~[k,k] */\n         if (vc_cap[jj] < cnt)\n         {  if (sva->r_ptr - sva->m_ptr < cnt)\n            {  sva_more_space(sva, cnt);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_enlarge_cap(sva, luf.vc_ref+(jj-1), cnt, 0);\n         }\n         /* store jj-th column of V = A~[k,k] */\n         ptr = vc_ptr[jj];\n         memcpy(&sv_ind[ptr], &ind[1], cnt * sizeof(int));\n         memcpy(&sv_val[ptr], &val[1], cnt * sizeof(double));\n         vc_len[jj] = cnt;\n         /* other (len-cnt) elements in the column list are stored in\n          * j-th column of the original matrix A */\n         len -= cnt;\n         if (len > 0)\n         {  /* reserve locations for j-th column of A */\n            if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_reserve_cap(sva, ac_ref-1+j, len);\n            /* store j-th column of A (except elements of A~[k,k]) */\n            ptr = ac_ptr[j];\n            memcpy(&sv_ind[ptr], &ind[cnt+1], len * sizeof(int));\n            memcpy(&sv_val[ptr], &val[cnt+1], len * sizeof(double));\n            ac_len[j] = len;\n         }\n      }\n      /* compute LU-factorization of diagonal block A~[k,k]; may note\n       * that A~[k,k] is irreducible (strongly connected), so singleton\n       * phase will have no effect */\n      k = sgf_factorize(sgf, 0 /* disable singleton phase */);\n      /* now left (dynamic) part of SVA should be empty (wichtig!) */\n      xassert(sva->m_ptr == 1);\n      return k;\n}",
      "lines": 102,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "btfint_factorize": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "int btfint_factorize(BTFINT *fi, int n, int (*col)(void *info, int j,\n      int ind[], double val[]), void *info)\n{     /* compute BT-factorization of specified matrix A */\n      SVA *sva;\n      BTF *btf;\n      SGF *sgf;\n      int k, rank;\n      xassert(n > 0);\n      fi->valid = 0;\n      /* create sparse vector area (SVA), if necessary */\n      sva = fi->sva;\n      if (sva == NULL)\n      {  int sva_n_max = fi->sva_n_max;\n         int sva_size = fi->sva_size;\n         if (sva_n_max == 0)\n            sva_n_max = 6 * n;\n         if (sva_size == 0)\n            sva_size = 10 * n;\n         sva = fi->sva = sva_create_area(sva_n_max, sva_size);\n      }\n      /* allocate/reallocate underlying objects, if necessary */\n      if (fi->n_max < n)\n      {  int n_max = fi->n_max;\n         if (n_max == 0)\n            n_max = fi->n_max = n + fi->delta_n0;\n         else\n            n_max = fi->n_max = n + fi->delta_n;\n         xassert(n_max >= n);\n         /* allocate/reallocate block triangular factorization (BTF) */\n         btf = fi->btf;\n         if (btf == NULL)\n         {  btf = fi->btf = talloc(1, BTF);\n            memset(btf, 0, sizeof(BTF));\n            btf->sva = sva;\n         }\n         else\n         {  tfree(btf->pp_ind);\n            tfree(btf->pp_inv);\n            tfree(btf->qq_ind);\n            tfree(btf->qq_inv);\n            tfree(btf->beg);\n            tfree(btf->vr_piv);\n            tfree(btf->p1_ind);\n            tfree(btf->p1_inv);\n            tfree(btf->q1_ind);\n            tfree(btf->q1_inv);\n         }\n         btf->pp_ind = talloc(1+n_max, int);\n         btf->pp_inv = talloc(1+n_max, int);\n         btf->qq_ind = talloc(1+n_max, int);\n         btf->qq_inv = talloc(1+n_max, int);\n         btf->beg = talloc(1+n_max+1, int);\n         btf->vr_piv = talloc(1+n_max, double);\n         btf->p1_ind = talloc(1+n_max, int);\n         btf->p1_inv = talloc(1+n_max, int);\n         btf->q1_ind = talloc(1+n_max, int);\n         btf->q1_inv = talloc(1+n_max, int);\n         /* allocate/reallocate factorizer workspace (SGF) */\n         /* (note that for SGF we could use the size of largest block\n          * rather than n_max) */\n         sgf = fi->sgf;\n         sgf = fi->sgf;\n         if (sgf == NULL)\n         {  sgf = fi->sgf = talloc(1, SGF);\n            memset(sgf, 0, sizeof(SGF));\n         }\n         else\n         {  tfree(sgf->rs_head);\n            tfree(sgf->rs_prev);\n            tfree(sgf->rs_next);\n            tfree(sgf->cs_head);\n            tfree(sgf->cs_prev);\n            tfree(sgf->cs_next);\n            tfree(sgf->vr_max);\n            tfree(sgf->flag);\n            tfree(sgf->work);\n         }\n         sgf->rs_head = talloc(1+n_max, int);\n         sgf->rs_prev = talloc(1+n_max, int);\n         sgf->rs_next = talloc(1+n_max, int);\n         sgf->cs_head = talloc(1+n_max, int);\n         sgf->cs_prev = talloc(1+n_max, int);\n         sgf->cs_next = talloc(1+n_max, int);\n         sgf->vr_max = talloc(1+n_max, double);\n         sgf->flag = talloc(1+n_max, char);\n         sgf->work = talloc(1+n_max, double);\n      }\n      btf = fi->btf;\n      btf->n = n;\n      sgf = fi->sgf;\n#if 1 /* FIXME */\n      /* initialize SVA */\n      sva->n = 0;\n      sva->m_ptr = 1;\n      sva->r_ptr = sva->size + 1;\n      sva->head = sva->tail = 0;\n#endif\n      /* store pattern of original matrix A in column-wise format */\n      btf->ac_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf_store_a_cols(btf, col, info, btf->pp_ind, btf->vr_piv);\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n#endif\n      /* analyze pattern of original matrix A and determine permutation\n       * matrices P and Q such that A = P * A~* Q, where A~ is an upper\n       * block triangular matrix */\n      rank = btf_make_blocks(btf);\n      if (rank != n)\n      {  /* original matrix A is structurally singular */\n         return 1;\n      }\n#ifdef GLP_DEBUG\n      btf_check_blocks(btf);\n#endif\n#if 1 /* FIXME */\n      /* initialize SVA */\n      sva->n = 0;\n      sva->m_ptr = 1;\n      sva->r_ptr = sva->size + 1;\n      sva->head = sva->tail = 0;\n#endif\n      /* allocate sparse vectors in SVA */\n      btf->ar_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf->ac_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf->fr_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf->fc_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf->vr_ref = sva_alloc_vecs(btf->sva, btf->n);\n      btf->vc_ref = sva_alloc_vecs(btf->sva, btf->n);\n      /* setup factorizer control parameters */\n      sgf->updat = 0; /* wichtig! */\n      sgf->piv_tol = fi->sgf_piv_tol;\n      sgf->piv_lim = fi->sgf_piv_lim;\n      sgf->suhl = fi->sgf_suhl;\n      sgf->eps_tol = fi->sgf_eps_tol;\n      /* compute LU-factorizations of diagonal blocks A~[k,k] and also\n       * store corresponding columns of matrix A except elements of all\n       * blocks A~[k,k] */\n      for (k = 1; k <= btf->num; k++)\n      {  if (btf->beg[k+1] - btf->beg[k] == 1)\n         {  /* trivial case (A~[k,k] has unity order) */\n            factorize_triv(fi, k, col, info);\n         }\n         else\n         {  /* general case */\n            if (factorize_block(fi, k, col, info) != 0)\n               return 2; /* factorization of A~[k,k] failed */\n         }\n      }\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n#endif\n      /* build row-wise representation of matrix A */\n      btf_build_a_rows(fi->btf, fi->sgf->rs_head);\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n#endif\n      /* BT-factorization has been successfully computed */\n      fi->valid = 1;\n      return 0;\n}",
      "lines": 160,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "btfint_delete": {
      "start_point": [
        370,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "void btfint_delete(BTFINT *fi)\n{     /* delete interface to BT-factorization */\n      SVA *sva = fi->sva;\n      BTF *btf = fi->btf;\n      SGF *sgf = fi->sgf;\n      if (sva != NULL)\n         sva_delete_area(sva);\n      if (btf != NULL)\n      {  tfree(btf->pp_ind);\n         tfree(btf->pp_inv);\n         tfree(btf->qq_ind);\n         tfree(btf->qq_inv);\n         tfree(btf->beg);\n         tfree(btf->vr_piv);\n         tfree(btf->p1_ind);\n         tfree(btf->p1_inv);\n         tfree(btf->q1_ind);\n         tfree(btf->q1_inv);\n         tfree(btf);\n      }\n      if (sgf != NULL)\n      {  tfree(sgf->rs_head);\n         tfree(sgf->rs_prev);\n         tfree(sgf->rs_next);\n         tfree(sgf->cs_head);\n         tfree(sgf->cs_prev);\n         tfree(sgf->cs_next);\n         tfree(sgf->vr_max);\n         tfree(sgf->flag);\n         tfree(sgf->work);\n         tfree(sgf);\n      }\n      tfree(fi);\n      return;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/btfint.h": {},
  "glpk/glpk-4.65/src/bflib/fhv.c": {
    "fhv_ft_update": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        222,
        7
      ],
      "content": "int fhv_ft_update(FHV *fhv, int q, int aq_len, const int aq_ind[],\n      const double aq_val[], int ind[/*1+n*/], double val[/*1+n*/],\n      double work[/*1+n*/])\n{     LUF *luf = fhv->luf;\n      int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int *vr_cap = &sva->cap[vr_ref-1];\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *vc_cap = &sva->cap[vc_ref-1];\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int *hh_ind = fhv->hh_ind;\n      int hh_ref = fhv->hh_ref;\n      int *hh_ptr = &sva->ptr[hh_ref-1];\n      int *hh_len = &sva->len[hh_ref-1];\n#if 1 /* FIXME */\n      const double eps_tol = DBL_EPSILON;\n      const double vpq_tol = 1e-5;\n      const double err_tol = 1e-10;\n#endif\n      int end, i, i_end, i_ptr, j, j_end, j_ptr, k, len, nnz, p, p_end,\n         p_ptr, ptr, q_end, q_ptr, s, t;\n      double f, vpq, temp;\n      /*--------------------------------------------------------------*/\n      /* replace current q-th column of matrix V by new one           */\n      /*--------------------------------------------------------------*/\n      xassert(1 <= q && q <= n);\n      /* convert new q-th column of matrix A to dense format */\n      for (i = 1; i <= n; i++)\n         val[i] = 0.0;\n      xassert(0 <= aq_len && aq_len <= n);\n      for (k = 1; k <= aq_len; k++)\n      {  i = aq_ind[k];\n         xassert(1 <= i && i <= n);\n         xassert(val[i] == 0.0);\n         xassert(aq_val[k] != 0.0);\n         val[i] = aq_val[k];\n      }\n      /* compute new q-th column of matrix V:\n       * new V[q] = inv(F * H) * (new A[q]) */\n      luf->pp_ind = fhv->p0_ind;\n      luf->pp_inv = fhv->p0_inv;\n      luf_f_solve(luf, val);\n      luf->pp_ind = pp_ind;\n      luf->pp_inv = pp_inv;\n      fhv_h_solve(fhv, val);\n      /* q-th column of V = s-th column of U */\n      s = qq_inv[q];\n      /* determine row number of element v[p,q] that corresponds to\n       * diagonal element u[s,s] */\n      p = pp_inv[s];\n      /* convert new q-th column of V to sparse format;\n       * element v[p,q] = u[s,s] is not included in the element list\n       * and stored separately */\n      vpq = 0.0;\n      len = 0;\n      for (i = 1; i <= n; i++)\n      {  temp = val[i];\n#if 1 /* FIXME */\n         if (-eps_tol < temp && temp < +eps_tol)\n#endif\n            /* nop */;\n         else if (i == p)\n            vpq = temp;\n         else\n         {  ind[++len] = i;\n            val[len] = temp;\n         }\n      }",
      "lines": 79,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "fhv_h_solve": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void fhv_h_solve(FHV *fhv, double x[/*1+n*/])\n{     SVA *sva = fhv->luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int nfs = fhv->nfs;\n      int *hh_ind = fhv->hh_ind;\n      int hh_ref = fhv->hh_ref;\n      int *hh_ptr = &sva->ptr[hh_ref-1];\n      int *hh_len = &sva->len[hh_ref-1];\n      int i, k, end, ptr;\n      double x_i;\n      for (k = 1; k <= nfs; k++)\n      {  x_i = x[i = hh_ind[k]];\n         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)\n            x_i -= sv_val[ptr] * x[sv_ind[ptr]];\n         x[i] = x_i;\n      }\n      return;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "fhv_ht_solve": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "void fhv_ht_solve(FHV *fhv, double x[/*1+n*/])\n{     SVA *sva = fhv->luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int nfs = fhv->nfs;\n      int *hh_ind = fhv->hh_ind;\n      int hh_ref = fhv->hh_ref;\n      int *hh_ptr = &sva->ptr[hh_ref-1];\n      int *hh_len = &sva->len[hh_ref-1];\n      int k, end, ptr;\n      double x_j;\n      for (k = nfs; k >= 1; k--)\n      {  if ((x_j = x[hh_ind[k]]) == 0.0)\n            continue;\n         for (end = (ptr = hh_ptr[k]) + hh_len[k]; ptr < end; ptr++)\n            x[sv_ind[ptr]] -= sv_val[ptr] * x_j;\n      }\n      return;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/fhv.h": {},
  "glpk/glpk-4.65/src/bflib/fhvint.c": {
    "fhvint_create": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "FHVINT *fhvint_create(void)\n{     /* create interface to FHV-factorization */\n      FHVINT *fi;\n      fi = talloc(1, FHVINT);\n      memset(fi, 0, sizeof(FHVINT));\n      fi->lufi = lufint_create();\n      return fi;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "FHVINT",
        "*fhvint_create(void)",
        "*"
      ]
    },
    "fhvint_factorize": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int fhvint_factorize(FHVINT *fi, int n, int (*col)(void *info, int j,\n      int ind[], double val[]), void *info)\n{     /* compute FHV-factorization of specified matrix A */\n      int nfs_max, old_n_max, n_max, k, ret;\n      xassert(n > 0);\n      fi->valid = 0;\n      /* get required value of nfs_max */\n      nfs_max = fi->nfs_max;\n      if (nfs_max == 0)\n         nfs_max = 100;\n      xassert(nfs_max > 0);\n      /* compute factorization of specified matrix A */\n      old_n_max = fi->lufi->n_max;\n      fi->lufi->sva_n_max = 4 * n + nfs_max;\n      fi->lufi->sgf_updat = 1;\n      ret = lufint_factorize(fi->lufi, n, col, info);\n      n_max = fi->lufi->n_max;\n      /* allocate/reallocate arrays, if necessary */\n      if (fi->fhv.nfs_max != nfs_max)\n      {  if (fi->fhv.hh_ind != NULL)\n            tfree(fi->fhv.hh_ind);\n         fi->fhv.hh_ind = talloc(1+nfs_max, int);\n      }\n      if (old_n_max < n_max)\n      {  if (fi->fhv.p0_ind != NULL)\n            tfree(fi->fhv.p0_ind);\n         if (fi->fhv.p0_inv != NULL)\n            tfree(fi->fhv.p0_inv);\n         fi->fhv.p0_ind = talloc(1+n_max, int);\n         fi->fhv.p0_inv = talloc(1+n_max, int);\n      }\n      /* initialize FHV-factorization */\n      fi->fhv.luf = fi->lufi->luf;\n      fi->fhv.nfs_max = nfs_max;\n      /* H := I */\n      fi->fhv.nfs = 0;\n      fi->fhv.hh_ref = sva_alloc_vecs(fi->lufi->sva, nfs_max);\n      /* P0 := P */\n      for (k = 1; k <= n; k++)\n      {  fi->fhv.p0_ind[k] = fi->fhv.luf->pp_ind[k];\n         fi->fhv.p0_inv[k] = fi->fhv.luf->pp_inv[k];\n      }\n      /* set validation flag */\n      if (ret == 0)\n         fi->valid = 1;\n      return ret;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "fhvint_update": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int fhvint_update(FHVINT *fi, int j, int len, const int ind[],\n      const double val[])\n{     /* update FHV-factorization after replacing j-th column of A */\n      SGF *sgf = fi->lufi->sgf;\n      int *ind1 = sgf->rs_next;\n      double *val1 = sgf->vr_max;\n      double *work = sgf->work;\n      int ret;\n      xassert(fi->valid);\n      ret = fhv_ft_update(&fi->fhv, j, len, ind, val, ind1, val1, work);\n      if (ret != 0)\n         fi->valid = 0;\n      return ret;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "fhvint_ftran": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void fhvint_ftran(FHVINT *fi, double x[])\n{     /* solve system A * x = b */\n      FHV *fhv = &fi->fhv;\n      LUF *luf = fhv->luf;\n      int n = luf->n;\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      SGF *sgf = fi->lufi->sgf;\n      double *work = sgf->work;\n      xassert(fi->valid);\n      /* A = F * H * V */\n      /* x = inv(A) * b = inv(V) * inv(H) * inv(F) * b */\n      luf->pp_ind = fhv->p0_ind;\n      luf->pp_inv = fhv->p0_inv;\n      luf_f_solve(luf, x);\n      luf->pp_ind = pp_ind;\n      luf->pp_inv = pp_inv;\n      fhv_h_solve(fhv, x);\n      luf_v_solve(luf, x, work);\n      memcpy(&x[1], &work[1], n * sizeof(double));\n      return;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fhvint_btran": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void fhvint_btran(FHVINT *fi, double x[])\n{     /* solve system A'* x = b */\n      FHV *fhv = &fi->fhv;\n      LUF *luf = fhv->luf;\n      int n = luf->n;\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      SGF *sgf = fi->lufi->sgf;\n      double *work = sgf->work;\n      xassert(fi->valid);\n      /* A' = (F * H * V)' = V'* H'* F' */\n      /* x = inv(A') * b = inv(F') * inv(H') * inv(V') * b */\n      luf_vt_solve(luf, x, work);\n      fhv_ht_solve(fhv, work);\n      luf->pp_ind = fhv->p0_ind;\n      luf->pp_inv = fhv->p0_inv;\n      luf_ft_solve(luf, work);\n      luf->pp_ind = pp_ind;\n      luf->pp_inv = pp_inv;\n      memcpy(&x[1], &work[1], n * sizeof(double));\n      return;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fhvint_estimate": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "double fhvint_estimate(FHVINT *fi)\n{     /* estimate 1-norm of inv(A) */\n      double norm;\n      xassert(fi->valid);\n      xassert(fi->fhv.nfs == 0);\n      norm = luf_estimate_norm(fi->fhv.luf, fi->lufi->sgf->vr_max,\n         fi->lufi->sgf->work);\n      return norm;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "fhvint_delete": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void fhvint_delete(FHVINT *fi)\n{     /* delete interface to FHV-factorization */\n      lufint_delete(fi->lufi);\n      if (fi->fhv.hh_ind != NULL)\n         tfree(fi->fhv.hh_ind);\n      if (fi->fhv.p0_ind != NULL)\n         tfree(fi->fhv.p0_ind);\n      if (fi->fhv.p0_inv != NULL)\n         tfree(fi->fhv.p0_inv);\n      tfree(fi);\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/fhvint.h": {},
  "glpk/glpk-4.65/src/bflib/ifu.c": {
    "ifu_expand": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void ifu_expand(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],\n      double d)\n{     /* non-optimized version */\n      int n_max = ifu->n_max;\n      int n = ifu->n;\n      double *f_ = ifu->f;\n      double *u_ = ifu->u;\n      int i, j;\n      double t;\n#     define f(i,j) f_[(i)*n_max+(j)]\n#     define u(i,j) u_[(i)*n_max+(j)]\n      xassert(0 <= n && n < n_max);\n      /* adjust indexing */\n      c++, r++;\n      /* set new zero column of matrix F */\n      for (i = 0; i < n; i++)\n         f(i,n) = 0.0;\n      /* set new zero row of matrix F */\n      for (j = 0; j < n; j++)\n         f(n,j) = 0.0;\n      /* set new unity diagonal element of matrix F */\n      f(n,n) = 1.0;\n      /* set new column of matrix U to vector (old F) * c */\n      for (i = 0; i < n; i++)\n      {  /* u[i,n] := (i-th row of old F) * c */\n         t = 0.0;\n         for (j = 0; j < n; j++)\n            t += f(i,j) * c[j];\n         u(i,n) = t;\n      }\n      /* set new row of matrix U to vector r */\n      for (j = 0; j < n; j++)\n         u(n,j) = r[j];\n      /* set new diagonal element of matrix U to scalar d */\n      u(n,n) = d;\n      /* increase factorization order */\n      ifu->n++;\n#     undef f\n#     undef u\n      return;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ifu_bg_update": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int ifu_bg_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],\n      double d)\n{     /* non-optimized version */\n      int n_max = ifu->n_max;\n      int n = ifu->n;\n      double *f_ = ifu->f;\n      double *u_ = ifu->u;\n#if 1 /* FIXME */\n      double tol = 1e-5;\n#endif\n      int j, k;\n      double t;\n#     define f(i,j) f_[(i)*n_max+(j)]\n#     define u(i,j) u_[(i)*n_max+(j)]\n      /* expand factorization */\n      ifu_expand(ifu, c, r, d);\n      /* NOTE: n keeps its old value */\n      /* eliminate spike (non-zero subdiagonal elements) in last row of\n       * matrix U */\n      for (k = 0; k < n; k++)\n      {  /* if |u[k,k]| < |u[n,k]|, interchange k-th and n-th rows to\n          * provide |u[k,k]| >= |u[n,k]| for numeric stability */\n         if (fabs(u(k,k)) < fabs(u(n,k)))\n         {  /* interchange k-th and n-th rows of matrix U */\n            for (j = k; j <= n; j++)\n               t = u(k,j), u(k,j) = u(n,j), u(n,j) = t;\n            /* interchange k-th and n-th rows of matrix F to keep the\n             * main equality F * A = U */\n            for (j = 0; j <= n; j++)\n               t = f(k,j), f(k,j) = f(n,j), f(n,j) = t;\n         }\n         /* now |u[k,k]| >= |u[n,k]| */\n         /* check if diagonal element u[k,k] can be used as pivot */\n         if (fabs(u(k,k)) < tol)\n         {  /* u[k,k] is too small in magnitude */\n            return 1;\n         }\n         /* if u[n,k] = 0, elimination is not needed */\n         if (u(n,k) == 0.0)\n            continue;\n         /* compute gaussian multiplier t = u[n,k] / u[k,k] */\n         t = u(n,k) / u(k,k);\n         /* apply gaussian transformation to eliminate u[n,k] */\n         /* (n-th row of U) := (n-th row of U) - t * (k-th row of U) */\n         for (j = k+1; j <= n; j++)\n            u(n,j) -= t * u(k,j);\n         /* apply the same transformation to matrix F to keep the main\n          * equality F * A = U */\n         for (j = 0; j <= n; j++)\n            f(n,j) -= t * f(k,j);\n      }\n      /* now matrix U is upper triangular */\n      if (fabs(u(n,n)) < tol)\n      {  /* u[n,n] is too small in magnitude */\n         return 2;\n      }\n#     undef f\n#     undef u\n      return 0;\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "givens": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "static void givens(double a, double b, double *c, double *s)\n{     /* non-optimized version */\n      double t;\n      if (b == 0.0)\n         (*c) = 1.0, (*s) = 0.0;\n      else if (fabs(a) <= fabs(b))\n         t = - a / b, (*s) = 1.0 / sqrt(1.0 + t * t), (*c) = (*s) * t;\n      else\n         t = - b / a, (*c) = 1.0 / sqrt(1.0 + t * t), (*s) = (*c) * t;\n      return;\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ifu_gr_update": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int ifu_gr_update(IFU *ifu, double c[/*1+n*/], double r[/*1+n*/],\n      double d)\n{     /* non-optimized version */\n      int n_max = ifu->n_max;\n      int n = ifu->n;\n      double *f_ = ifu->f;\n      double *u_ = ifu->u;\n#if 1 /* FIXME */\n      double tol = 1e-5;\n#endif\n      int j, k;\n      double cs, sn;\n#     define f(i,j) f_[(i)*n_max+(j)]\n#     define u(i,j) u_[(i)*n_max+(j)]\n      /* expand factorization */\n      ifu_expand(ifu, c, r, d);\n      /* NOTE: n keeps its old value */\n      /* eliminate spike (non-zero subdiagonal elements) in last row of\n       * matrix U */\n      for (k = 0; k < n; k++)\n      {  /* check if elements u[k,k] and u[n,k] are eligible */\n         if (fabs(u(k,k)) < tol && fabs(u(n,k)) < tol)\n         {  /* both u[k,k] and u[n,k] are too small in magnitude */\n            return 1;\n         }\n         /* if u[n,k] = 0, elimination is not needed */\n         if (u(n,k) == 0.0)\n            continue;\n         /* compute parameters of Givens plane rotation */\n         givens(u(k,k), u(n,k), &cs, &sn);\n         /* apply Givens rotation to k-th and n-th rows of matrix U to\n          * eliminate u[n,k] */\n         for (j = k; j <= n; j++)\n         {  double ukj = u(k,j), unj = u(n,j);\n            u(k,j) = cs * ukj - sn * unj;\n            u(n,j) = sn * ukj + cs * unj;\n         }\n         /* apply the same transformation to matrix F to keep the main\n          * equality F * A = U */\n         for (j = 0; j <= n; j++)\n         {  double fkj = f(k,j), fnj = f(n,j);\n            f(k,j) = cs * fkj - sn * fnj;\n            f(n,j) = sn * fkj + cs * fnj;\n         }\n      }\n      /* now matrix U is upper triangular */\n      if (fabs(u(n,n)) < tol)\n      {  /* u[n,n] is too small in magnitude */\n         return 2;\n      }\n#     undef f\n#     undef u\n      return 0;\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "ifu_a_solve": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "void ifu_a_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/])\n{     /* non-optimized version */\n      int n_max = ifu->n_max;\n      int n = ifu->n;\n      double *f_ = ifu->f;\n      double *u_ = ifu->u;\n      int i, j;\n      double t;\n#     define f(i,j) f_[(i)*n_max+(j)]\n#     define u(i,j) u_[(i)*n_max+(j)]\n      xassert(0 <= n && n <= n_max);\n      /* adjust indexing */\n      x++, w++;\n      /* y := F * b */\n      memcpy(w, x, n * sizeof(double));\n      for (i = 0; i < n; i++)\n      {  /* y[i] := (i-th row of F) * b */\n         t = 0.0;\n         for (j = 0; j < n; j++)\n            t += f(i,j) * w[j];\n         x[i] = t;\n      }\n      /* x := inv(U) * y */\n      for (i = n-1; i >= 0; i--)\n      {  t = x[i];\n         for (j = i+1; j < n; j++)\n            t -= u(i,j) * x[j];\n         x[i] = t / u(i,i);\n      }\n#     undef f\n#     undef u\n      return;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ifu_at_solve": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "void ifu_at_solve(IFU *ifu, double x[/*1+n*/], double w[/*1+n*/])\n{     /* non-optimized version */\n      int n_max = ifu->n_max;\n      int n = ifu->n;\n      double *f_ = ifu->f;\n      double *u_ = ifu->u;\n      int i, j;\n      double t;\n#     define f(i,j) f_[(i)*n_max+(j)]\n#     define u(i,j) u_[(i)*n_max+(j)]\n      xassert(0 <= n && n <= n_max);\n      /* adjust indexing */\n      x++, w++;\n      /* y := inv(U') * b */\n      for (i = 0; i < n; i++)\n      {  t = (x[i] /= u(i,i));\n         for (j = i+1; j < n; j++)\n            x[j] -= u(i,j) * t;\n      }\n      /* x := F'* y */\n      for (j = 0; j < n; j++)\n      {  /* x[j] := (j-th column of F) * y */\n         t = 0.0;\n         for (i = 0; i < n; i++)\n            t += f(i,j) * x[i];\n         w[j] = t;\n      }\n      memcpy(x, w, n * sizeof(double));\n#     undef f\n#     undef u\n      return;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/ifu.h": {},
  "glpk/glpk-4.65/src/bflib/luf.c": {
    "luf_store_v_cols": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int luf_store_v_cols(LUF *luf, int (*col)(void *info, int j, int ind[],\n      double val[]), void *info, int ind[], double val[])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *vc_cap = &sva->cap[vc_ref-1];\n      int j, len, ptr, nnz;\n      nnz = 0;\n      for (j = 1; j <= n; j++)\n      {  /* get j-th column */\n         len = col(info, j, ind, val);\n         xassert(0 <= len && len <= n);\n         /* enlarge j-th column capacity */\n         if (vc_cap[j] < len)\n         {  if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_enlarge_cap(sva, vc_ref-1+j, len, 0);\n         }\n         /* store j-th column */\n         ptr = vc_ptr[j];\n         memcpy(&sv_ind[ptr], &ind[1], len * sizeof(int));\n         memcpy(&sv_val[ptr], &val[1], len * sizeof(double));\n         vc_len[j] = len;\n         nnz += len;\n      }\n      return nnz;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "luf_check_all": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void luf_check_all(LUF *luf, int k)\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fr_ref = luf->fr_ref;\n      int *fr_len = &sva->len[fr_ref-1];\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int i, ii, i_ptr, i_end, j, jj, j_ptr, j_end;\n      xassert(n > 0);\n      xassert(1 <= k && k <= n+1);\n      /* check permutation matrix P */\n      for (i = 1; i <= n; i++)\n      {  ii = pp_ind[i];\n         xassert(1 <= ii && ii <= n);\n         xassert(pp_inv[ii] == i);\n      }\n      /* check permutation matrix Q */\n      for (j = 1; j <= n; j++)\n      {  jj = qq_inv[j];\n         xassert(1 <= jj && jj <= n);\n         xassert(qq_ind[jj] == j);\n      }\n      /* check row-wise representation of matrix F */\n      for (i = 1; i <= n; i++)\n         xassert(fr_len[i] == 0);\n      /* check column-wise representation of matrix F */\n      for (j = 1; j <= n; j++)\n      {  /* j-th column of F = jj-th column of L */\n         jj = pp_ind[j];\n         if (jj < k)\n         {  j_ptr = fc_ptr[j];\n            j_end = j_ptr + fc_len[j];\n            for (; j_ptr < j_end; j_ptr++)\n            {  i = sv_ind[j_ptr];\n               xassert(1 <= i && i <= n);\n               ii = pp_ind[i]; /* f[i,j] = l[ii,jj] */\n               xassert(ii > jj);\n               xassert(sv_val[j_ptr] != 0.0);\n            }\n         }\n         else /* jj >= k */\n            xassert(fc_len[j] == 0);\n      }\n      /* check row-wise representation of matrix V */\n      for (i = 1; i <= n; i++)\n      {  /* i-th row of V = ii-th row of U */\n         ii = pp_ind[i];\n         i_ptr = vr_ptr[i];\n         i_end = i_ptr + vr_len[i];\n         for (; i_ptr < i_end; i_ptr++)\n         {  j = sv_ind[i_ptr];\n            xassert(1 <= j && j <= n);\n            jj = qq_inv[j]; /* v[i,j] = u[ii,jj] */\n            if (ii < k)\n               xassert(jj > ii);\n            else /* ii >= k */\n            {  xassert(jj >= k);\n               /* find v[i,j] in j-th column */\n               j_ptr = vc_ptr[j];\n               j_end = j_ptr + vc_len[j];\n               for (; sv_ind[j_ptr] != i; j_ptr++)\n                  /* nop */;\n               xassert(j_ptr < j_end);\n            }\n            xassert(sv_val[i_ptr] != 0.0);\n         }\n      }\n      /* check column-wise representation of matrix V */\n      for (j = 1; j <= n; j++)\n      {  /* j-th column of V = jj-th column of U */\n         jj = qq_inv[j];\n         if (jj < k)\n            xassert(vc_len[j] == 0);\n         else /* jj >= k */\n         {  j_ptr = vc_ptr[j];\n            j_end = j_ptr + vc_len[j];\n            for (; j_ptr < j_end; j_ptr++)\n            {  i = sv_ind[j_ptr];\n               ii = pp_ind[i]; /* v[i,j] = u[ii,jj] */\n               xassert(ii >= k);\n               /* find v[i,j] in i-th row */\n               i_ptr = vr_ptr[i];\n               i_end = i_ptr + vr_len[i];\n               for (; sv_ind[i_ptr] != j; i_ptr++)\n                  /* nop */;\n               xassert(i_ptr < i_end);\n            }\n         }\n      }\n      return;\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "luf_build_v_rows": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void luf_build_v_rows(LUF *luf, int len[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int i, j, end, nnz, ptr, ptr1;\n      /* calculate the number of non-zeros in each row of matrix V and\n       * the total number of non-zeros */\n      nnz = 0;\n      for (i = 1; i <= n; i++)\n         len[i] = 0;\n      for (j = 1; j <= n; j++)\n      {  nnz += vc_len[j];\n         for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)\n            len[sv_ind[ptr]]++;\n      }\n      /* we need at least nnz free locations in SVA */\n      if (sva->r_ptr - sva->m_ptr < nnz)\n      {  sva_more_space(sva, nnz);\n         sv_ind = sva->ind;\n         sv_val = sva->val;\n      }\n      /* reserve locations for rows of matrix V */\n      for (i = 1; i <= n; i++)\n      {  if (len[i] > 0)\n            sva_enlarge_cap(sva, vr_ref-1+i, len[i], 0);\n         vr_len[i] = len[i];\n      }\n      /* walk thru column of matrix V and build its rows */\n      for (j = 1; j <= n; j++)\n      {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)\n         {  i = sv_ind[ptr];\n            sv_ind[ptr1 = vr_ptr[i] + (--len[i])] = j;\n            sv_val[ptr1] = sv_val[ptr];\n         }\n      }\n      return;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "luf_build_f_rows": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void luf_build_f_rows(LUF *luf, int len[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fr_ref = luf->fr_ref;\n      int *fr_ptr = &sva->ptr[fr_ref-1];\n      int *fr_len = &sva->len[fr_ref-1];\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int i, j, end, nnz, ptr, ptr1;\n      /* calculate the number of non-zeros in each row of matrix F and\n       * the total number of non-zeros (except diagonal elements) */\n      nnz = 0;\n      for (i = 1; i <= n; i++)\n         len[i] = 0;\n      for (j = 1; j <= n; j++)\n      {  nnz += fc_len[j];\n         for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)\n            len[sv_ind[ptr]]++;\n      }\n      /* we need at least nnz free locations in SVA */\n      if (sva->r_ptr - sva->m_ptr < nnz)\n      {  sva_more_space(sva, nnz);\n         sv_ind = sva->ind;\n         sv_val = sva->val;\n      }\n      /* reserve locations for rows of matrix F */\n      for (i = 1; i <= n; i++)\n      {  if (len[i] > 0)\n            sva_reserve_cap(sva, fr_ref-1+i, len[i]);\n         fr_len[i] = len[i];\n      }\n      /* walk through columns of matrix F and build its rows */\n      for (j = 1; j <= n; j++)\n      {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)\n         {  i = sv_ind[ptr];\n            sv_ind[ptr1 = fr_ptr[i] + (--len[i])] = j;\n            sv_val[ptr1] = sv_val[ptr];\n         }\n      }\n      return;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "luf_build_v_cols": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "void luf_build_v_cols(LUF *luf, int updat, int len[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int i, j, end, nnz, ptr, ptr1;\n      /* calculate the number of non-zeros in each column of matrix V\n       * and the total number of non-zeros (except pivot elements) */\n      nnz = 0;\n      for (j = 1; j <= n; j++)\n         len[j] = 0;\n      for (i = 1; i <= n; i++)\n      {  nnz += vr_len[i];\n         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)\n            len[sv_ind[ptr]]++;\n      }\n      /* we need at least nnz free locations in SVA */\n      if (sva->r_ptr - sva->m_ptr < nnz)\n      {  sva_more_space(sva, nnz);\n         sv_ind = sva->ind;\n         sv_val = sva->val;\n      }\n      /* reserve locations for columns of matrix V */\n      for (j = 1; j <= n; j++)\n      {  if (len[j] > 0)\n         {  if (updat)\n               sva_enlarge_cap(sva, vc_ref-1+j, len[j], 0);\n            else\n               sva_reserve_cap(sva, vc_ref-1+j, len[j]);\n         }\n         vc_len[j] = len[j];\n      }\n      /* walk through rows of matrix V and build its columns */\n      for (i = 1; i <= n; i++)\n      {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)\n         {  j = sv_ind[ptr];\n            sv_ind[ptr1 = vc_ptr[j] + (--len[j])] = i;\n            sv_val[ptr1] = sv_val[ptr];\n         }\n      }\n      return;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "luf_check_f_rc": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        407,
        1
      ],
      "content": "void luf_check_f_rc(LUF *luf)\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fr_ref = luf->fr_ref;\n      int *fr_ptr = &sva->ptr[fr_ref-1];\n      int *fr_len = &sva->len[fr_ref-1];\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int i, i_end, i_ptr, j, j_end, j_ptr;\n      /* walk thru rows of matrix F */\n      for (i = 1; i <= n; i++)\n      {  for (i_end = (i_ptr = fr_ptr[i]) + fr_len[i];\n            i_ptr < i_end; i_ptr++)\n         {  j = sv_ind[i_ptr];\n            /* find element f[i,j] in j-th column of matrix F */\n            for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];\n               sv_ind[j_ptr] != i; j_ptr++)\n               /* nop */;\n            xassert(j_ptr < j_end);\n            xassert(sv_val[i_ptr] == sv_val[j_ptr]);\n            /* mark element f[i,j] */\n            sv_ind[j_ptr] = -i;\n         }\n      }\n      /* walk thru column of matix F and check that all elements has\n         been marked */\n      for (j = 1; j <= n; j++)\n      {  for (j_end = (j_ptr = fc_ptr[j]) + fc_len[j];\n            j_ptr < j_end; j_ptr++)\n         {  xassert((i = sv_ind[j_ptr]) < 0);\n            /* unmark element f[i,j] */\n            sv_ind[j_ptr] = -i;\n         }\n      }\n      return;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "luf_check_v_rc": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "void luf_check_v_rc(LUF *luf)\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int i, i_end, i_ptr, j, j_end, j_ptr;\n      /* walk thru rows of matrix V */\n      for (i = 1; i <= n; i++)\n      {  for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n            i_ptr < i_end; i_ptr++)\n         {  j = sv_ind[i_ptr];\n            /* find element v[i,j] in j-th column of matrix V */\n            for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];\n               sv_ind[j_ptr] != i; j_ptr++)\n               /* nop */;\n            xassert(j_ptr < j_end);\n            xassert(sv_val[i_ptr] == sv_val[j_ptr]);\n            /* mark element v[i,j] */\n            sv_ind[j_ptr] = -i;\n         }\n      }\n      /* walk thru column of matix V and check that all elements has\n         been marked */\n      for (j = 1; j <= n; j++)\n      {  for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];\n            j_ptr < j_end; j_ptr++)\n         {  xassert((i = sv_ind[j_ptr]) < 0);\n            /* unmark element v[i,j] */\n            sv_ind[j_ptr] = -i;\n         }\n      }\n      return;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "luf_f_solve": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        491,
        1
      ],
      "content": "void luf_f_solve(LUF *luf, double x[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int j, k, ptr, end;\n      double x_j;\n      for (k = 1; k <= n; k++)\n      {  /* k-th column of L = j-th column of F */\n         j = pp_inv[k];\n         /* x[j] is already computed */\n         /* walk thru j-th column of matrix F and substitute x[j] into\n          * other equations */\n         if ((x_j = x[j]) != 0.0)\n         {  for (end = (ptr = fc_ptr[j]) + fc_len[j]; ptr < end; ptr++)\n               x[sv_ind[ptr]] -= sv_val[ptr] * x_j;\n         }\n      }\n      return;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "luf_ft_solve": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        528,
        1
      ],
      "content": "void luf_ft_solve(LUF *luf, double x[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fr_ref = luf->fr_ref;\n      int *fr_ptr = &sva->ptr[fr_ref-1];\n      int *fr_len = &sva->len[fr_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int i, k, ptr, end;\n      double x_i;\n      for (k = n; k >= 1; k--)\n      {  /* k-th column of L' = i-th row of F */\n         i = pp_inv[k];\n         /* x[i] is already computed */\n         /* walk thru i-th row of matrix F and substitute x[i] into\n          * other equations */\n         if ((x_i = x[i]) != 0.0)\n         {  for (end = (ptr = fr_ptr[i]) + fr_len[i]; ptr < end; ptr++)\n               x[sv_ind[ptr]] -= sv_val[ptr] * x_i;\n         }\n      }\n      return;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "luf_v_solve": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "void luf_v_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int i, j, k, ptr, end;\n      double x_j;\n      for (k = n; k >= 1; k--)\n      {  /* k-th row of U = i-th row of V */\n         /* k-th column of U = j-th column of V */\n         i = pp_inv[k];\n         j = qq_ind[k];\n         /* compute x[j] = b[i] / u[k,k], where u[k,k] = v[i,j];\n          * walk through j-th column of matrix V and substitute x[j]\n          * into other equations */\n         if ((x_j = x[j] = b[i] / vr_piv[i]) != 0.0)\n         {  for (end = (ptr = vc_ptr[j]) + vc_len[j]; ptr < end; ptr++)\n               b[sv_ind[ptr]] -= sv_val[ptr] * x_j;\n         }\n      }\n      return;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "luf_vt_solve": {
      "start_point": [
        584,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "void luf_vt_solve(LUF *luf, double b[/*1+n*/], double x[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      double *vr_piv = luf->vr_piv;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int i, j, k, ptr, end;\n      double x_i;\n      for (k = 1; k <= n; k++)\n      {  /* k-th row of U' = j-th column of V */\n         /* k-th column of U' = i-th row of V */\n         i = pp_inv[k];\n         j = qq_ind[k];\n         /* compute x[i] = b[j] / u'[k,k], where u'[k,k] = v[i,j];\n          * walk through i-th row of matrix V and substitute x[i] into\n          * other equations */\n         if ((x_i = x[i] = b[j] / vr_piv[i]) != 0.0)\n         {  for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)\n               b[sv_ind[ptr]] -= sv_val[ptr] * x_i;\n         }\n      }\n      return;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "luf_vt_solve1": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "void luf_vt_solve1(LUF *luf, double e[/*1+n*/], double y[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      double *vr_piv = luf->vr_piv;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int i, j, k, ptr, end;\n      double e_j, y_i;\n      for (k = 1; k <= n; k++)\n      {  /* k-th row of U' = j-th column of V */\n         /* k-th column of U' = i-th row of V */\n         i = pp_inv[k];\n         j = qq_ind[k];\n         /* determine e'[j] = e[j] + delta e[j] */\n         e_j = (e[j] >= 0.0 ? e[j] + 1.0 : e[j] - 1.0);\n         /* compute y[i] = e'[j] / u'[k,k], where u'[k,k] = v[i,j] */\n         y_i = y[i] = e_j / vr_piv[i];\n         /* walk through i-th row of matrix V and substitute y[i] into\n          * other equations */\n         for (end = (ptr = vr_ptr[i]) + vr_len[i]; ptr < end; ptr++)\n            e[sv_ind[ptr]] -= sv_val[ptr] * y_i;\n      }\n      return;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "luf_estimate_norm": {
      "start_point": [
        680,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "double luf_estimate_norm(LUF *luf, double w1[/*1+n*/], double\n      w2[/*1+n*/])\n{     int n = luf->n;\n      double *e = w1;\n      double *y = w2;\n      double *z = w1;\n      int i;\n      double y_norm, z_norm;\n      /* y = inv(A') * e = inv(F') * inv(V') * e */\n      /* compute y' = inv(V') * e to cause growth in y' */\n      for (i = 1; i <= n; i++)\n         e[i] = 0.0;\n      luf_vt_solve1(luf, e, y);\n      /* compute y = inv(F') * y' */\n      luf_ft_solve(luf, y);\n      /* compute 1-norm of y = sum |y[i]| */\n      y_norm = 0.0;\n      for (i = 1; i <= n; i++)\n         y_norm += (y[i] >= 0.0 ? +y[i] : -y[i]);\n      /* z = inv(A) * y = inv(V) * inv(F) * y */\n      /* compute z' = inv(F) * y */\n      luf_f_solve(luf, y);\n      /* compute z = inv(V) * z' */\n      luf_v_solve(luf, y, z);\n      /* compute 1-norm of z = sum |z[i]| */\n      z_norm = 0.0;\n      for (i = 1; i <= n; i++)\n         z_norm += (z[i] >= 0.0 ? +z[i] : -z[i]);\n      /* estimate 1-norm of inv(A) = (1-norm of z) / (1-norm of y) */\n      return z_norm / y_norm;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/luf.h": {},
  "glpk/glpk-4.65/src/bflib/lufint.c": {
    "lufint_create": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "LUFINT *lufint_create(void)\n{     /* create interface to LU-factorization */\n      LUFINT *fi;\n      fi = talloc(1, LUFINT);\n      fi->n_max = 0;\n      fi->valid = 0;\n      fi->sva = NULL;\n      fi->luf = NULL;\n      fi->sgf = NULL;\n      fi->sva_n_max = fi->sva_size = 0;\n      fi->delta_n0 = fi->delta_n = 0;\n      fi->sgf_updat = 0;\n      fi->sgf_piv_tol = 0.10;\n      fi->sgf_piv_lim = 4;\n      fi->sgf_suhl = 1;\n      fi->sgf_eps_tol = DBL_EPSILON;\n      return fi;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "LUFINT",
        "*lufint_create(void)",
        "*"
      ]
    },
    "lufint_factorize": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int lufint_factorize(LUFINT *fi, int n, int (*col)(void *info, int j,\n      int ind[], double val[]), void *info)\n{     /* compute LU-factorization of specified matrix A */\n      SVA *sva;\n      LUF *luf;\n      SGF *sgf;\n      int k;\n      xassert(n > 0);\n      fi->valid = 0;\n      /* create sparse vector area (SVA), if necessary */\n      sva = fi->sva;\n      if (sva == NULL)\n      {  int sva_n_max = fi->sva_n_max;\n         int sva_size = fi->sva_size;\n         if (sva_n_max == 0)\n            sva_n_max = 4 * n;\n         if (sva_size == 0)\n            sva_size = 10 * n;\n         sva = fi->sva = sva_create_area(sva_n_max, sva_size);\n      }\n      /* allocate/reallocate underlying objects, if necessary */\n      if (fi->n_max < n)\n      {  int n_max = fi->n_max;\n         if (n_max == 0)\n            n_max = fi->n_max = n + fi->delta_n0;\n         else\n            n_max = fi->n_max = n + fi->delta_n;\n         xassert(n_max >= n);\n         /* allocate/reallocate LU-factorization (LUF) */\n         luf = fi->luf;\n         if (luf == NULL)\n         {  luf = fi->luf = talloc(1, LUF);\n            memset(luf, 0, sizeof(LUF));\n            luf->sva = sva;\n         }\n         else\n         {  tfree(luf->vr_piv);\n            tfree(luf->pp_ind);\n            tfree(luf->pp_inv);\n            tfree(luf->qq_ind);\n            tfree(luf->qq_inv);\n         }\n         luf->vr_piv = talloc(1+n_max, double);\n         luf->pp_ind = talloc(1+n_max, int);\n         luf->pp_inv = talloc(1+n_max, int);\n         luf->qq_ind = talloc(1+n_max, int);\n         luf->qq_inv = talloc(1+n_max, int);\n         /* allocate/reallocate factorizer workspace (SGF) */\n         sgf = fi->sgf;\n         if (sgf == NULL)\n         {  sgf = fi->sgf = talloc(1, SGF);\n            memset(sgf, 0, sizeof(SGF));\n            sgf->luf = luf;\n         }\n         else\n         {  tfree(sgf->rs_head);\n            tfree(sgf->rs_prev);\n            tfree(sgf->rs_next);\n            tfree(sgf->cs_head);\n            tfree(sgf->cs_prev);\n            tfree(sgf->cs_next);\n            tfree(sgf->vr_max);\n            tfree(sgf->flag);\n            tfree(sgf->work);\n         }\n         sgf->rs_head = talloc(1+n_max, int);\n         sgf->rs_prev = talloc(1+n_max, int);\n         sgf->rs_next = talloc(1+n_max, int);\n         sgf->cs_head = talloc(1+n_max, int);\n         sgf->cs_prev = talloc(1+n_max, int);\n         sgf->cs_next = talloc(1+n_max, int);\n         sgf->vr_max = talloc(1+n_max, double);\n         sgf->flag = talloc(1+n_max, char);\n         sgf->work = talloc(1+n_max, double);\n      }\n      luf = fi->luf;\n      sgf = fi->sgf;\n#if 1 /* FIXME */\n      /* initialize SVA */\n      sva->n = 0;\n      sva->m_ptr = 1;\n      sva->r_ptr = sva->size + 1;\n      sva->head = sva->tail = 0;\n#endif\n      /* allocate sparse vectors in SVA */\n      luf->n = n;\n      luf->fr_ref = sva_alloc_vecs(sva, n);\n      luf->fc_ref = sva_alloc_vecs(sva, n);\n      luf->vr_ref = sva_alloc_vecs(sva, n);\n      luf->vc_ref = sva_alloc_vecs(sva, n);\n      /* store matrix V = A in column-wise format */\n      luf_store_v_cols(luf, col, info, sgf->rs_prev, sgf->work);\n      /* setup factorizer control parameters */\n      sgf->updat = fi->sgf_updat;\n      sgf->piv_tol = fi->sgf_piv_tol;\n      sgf->piv_lim = fi->sgf_piv_lim;\n      sgf->suhl = fi->sgf_suhl;\n      sgf->eps_tol = fi->sgf_eps_tol;\n      /* compute LU-factorization of specified matrix A */\n      k = sgf_factorize(sgf, 1);\n      if (k == 0)\n         fi->valid = 1;\n      return k;\n}",
      "lines": 104,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "lufint_delete": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void lufint_delete(LUFINT *fi)\n{     /* delete interface to LU-factorization */\n      SVA *sva = fi->sva;\n      LUF *luf = fi->luf;\n      SGF *sgf = fi->sgf;\n      if (sva != NULL)\n         sva_delete_area(sva);\n      if (luf != NULL)\n      {  tfree(luf->vr_piv);\n         tfree(luf->pp_ind);\n         tfree(luf->pp_inv);\n         tfree(luf->qq_ind);\n         tfree(luf->qq_inv);\n         tfree(luf);\n      }\n      if (sgf != NULL)\n      {  tfree(sgf->rs_head);\n         tfree(sgf->rs_prev);\n         tfree(sgf->rs_next);\n         tfree(sgf->cs_head);\n         tfree(sgf->cs_prev);\n         tfree(sgf->cs_next);\n         tfree(sgf->vr_max);\n         tfree(sgf->flag);\n         tfree(sgf->work);\n         tfree(sgf);\n      }\n      tfree(fi);\n      return;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/lufint.h": {},
  "glpk/glpk-4.65/src/bflib/scf.c": {
    "scf_r0_solve": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void scf_r0_solve(SCF *scf, int tr, double x[/*1+n0*/])\n{     switch (scf->type)\n      {  case 1:\n            /* A0 = F0 * V0, so R0 = F0 */\n            if (!tr)\n               luf_f_solve(scf->a0.luf, x);\n            else\n               luf_ft_solve(scf->a0.luf, x);\n            break;\n         case 2:\n            /* A0 = I * A0, so R0 = I */\n            break;\n         default:\n            xassert(scf != scf);\n      }\n      return;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "scf_s0_solve": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void scf_s0_solve(SCF *scf, int tr, double x[/*1+n0*/],\n      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/])\n{     int n0 = scf->n0;\n      switch (scf->type)\n      {  case 1:\n            /* A0 = F0 * V0, so S0 = V0 */\n            if (!tr)\n               luf_v_solve(scf->a0.luf, x, w1);\n            else\n               luf_vt_solve(scf->a0.luf, x, w1);\n            break;\n         case 2:\n            /* A0 = I * A0, so S0 = A0 */\n            if (!tr)\n               btf_a_solve(scf->a0.btf, x, w1, w2, w3);\n            else\n               btf_at_solve(scf->a0.btf, x, w1, w2, w3);\n            break;\n         default:\n            xassert(scf != scf);\n      }\n      memcpy(&x[1], &w1[1], n0 * sizeof(double));\n      return;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "scf_r_prod": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void scf_r_prod(SCF *scf, double y[/*1+nn*/], double a, const double\n      x[/*1+n0*/])\n{     int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int rr_ref = scf->rr_ref;\n      int *rr_ptr = &sva->ptr[rr_ref-1];\n      int *rr_len = &sva->len[rr_ref-1];\n      int i, ptr, end;\n      double t;\n      for (i = 1; i <= nn; i++)\n      {  /* t := (i-th row of R) * x */\n         t = 0.0;\n         for (end = (ptr = rr_ptr[i]) + rr_len[i]; ptr < end; ptr++)\n            t += sv_val[ptr] * x[sv_ind[ptr]];\n         /* y[i] := y[i] + alpha * t */\n         y[i] += a * t;\n      }\n      return;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scf_rt_prod": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "void scf_rt_prod(SCF *scf, double y[/*1+n0*/], double a, const double\n      x[/*1+nn*/])\n{     int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int rr_ref = scf->rr_ref;\n      int *rr_ptr = &sva->ptr[rr_ref-1];\n      int *rr_len = &sva->len[rr_ref-1];\n      int i, ptr, end;\n      double t;\n      for (i = 1; i <= nn; i++)\n      {  if (x[i] == 0.0)\n            continue;\n         /* y := y + alpha * R'[i] * x[i] */\n         t = a * x[i];\n         for (end = (ptr = rr_ptr[i]) + rr_len[i]; ptr < end; ptr++)\n            y[sv_ind[ptr]] += sv_val[ptr] * t;\n      }\n      return;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scf_s_prod": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void scf_s_prod(SCF *scf, double y[/*1+n0*/], double a, const double\n      x[/*1+nn*/])\n{     int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int ss_ref = scf->ss_ref;\n      int *ss_ptr = &sva->ptr[ss_ref-1];\n      int *ss_len = &sva->len[ss_ref-1];\n      int j, ptr, end;\n      double t;\n      for (j = 1; j <= nn; j++)\n      {  if (x[j] == 0.0)\n            continue;\n         /* y := y + alpha * S[j] * x[j] */\n         t = a * x[j];\n         for (end = (ptr = ss_ptr[j]) + ss_len[j]; ptr < end; ptr++)\n            y[sv_ind[ptr]] += sv_val[ptr] * t;\n      }\n      return;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scf_st_prod": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void scf_st_prod(SCF *scf, double y[/*1+nn*/], double a, const double\n      x[/*1+n0*/])\n{     int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int ss_ref = scf->ss_ref;\n      int *ss_ptr = &sva->ptr[ss_ref-1];\n      int *ss_len = &sva->len[ss_ref-1];\n      int j, ptr, end;\n      double t;\n      for (j = 1; j <= nn; j++)\n      {  /* t := (j-th column of S) * x */\n         t = 0.0;\n         for (end = (ptr = ss_ptr[j]) + ss_len[j]; ptr < end; ptr++)\n            t += sv_val[ptr] * x[sv_ind[ptr]];\n         /* y[j] := y[j] + alpha * t */\n         y[j] += a * t;\n      }\n      return;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scf_a_solve": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void scf_a_solve(SCF *scf, double x[/*1+n*/],\n      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],\n      double work2[/*1+n*/], double work3[/*1+n*/])\n{     int n = scf->n;\n      int n0 = scf->n0;\n      int nn = scf->nn;\n      int *pp_ind = scf->pp_ind;\n      int *qq_inv = scf->qq_inv;\n      int i, ii;\n      /* (u1, u2) := inv(P) * (b, 0) */\n      for (ii = 1; ii <= n0+nn; ii++)\n      {  i = pp_ind[ii];\n#if 1 /* FIXME: currently P = I */\n         xassert(i == ii);\n#endif\n         w[ii] = (i <= n ? x[i] : 0.0);\n      }\n      /* v1 := inv(R0) * u1 */\n      scf_r0_solve(scf, 0, &w[0]);\n      /* v2 := u2 - R * v1 */\n      scf_r_prod(scf, &w[n0], -1.0, &w[0]);\n      /* w2 := inv(C) * v2 */\n      ifu_a_solve(&scf->ifu, &w[n0], work1);\n      /* w1 := inv(S0) * (v1 - S * w2) */\n      scf_s_prod(scf, &w[0], -1.0, &w[n0]);\n      scf_s0_solve(scf, 0, &w[0], work1, work2, work3);\n      /* (x, x~) := inv(Q) * (w1, w2); x~ is not needed */\n      for (i = 1; i <= n; i++)\n         x[i] = w[qq_inv[i]];\n      return;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "scf_at_solve": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "void scf_at_solve(SCF *scf, double x[/*1+n*/],\n      double w[/*1+n0+nn*/], double work1[/*1+max(n0,nn)*/],\n      double work2[/*1+n*/], double work3[/*1+n*/])\n{     int n = scf->n;\n      int n0 = scf->n0;\n      int nn = scf->nn;\n      int *pp_inv = scf->pp_inv;\n      int *qq_ind = scf->qq_ind;\n      int i, ii;\n      /* (u1, u2) := Q * (b, 0) */\n      for (ii = 1; ii <= n0+nn; ii++)\n      {  i = qq_ind[ii];\n         w[ii] = (i <= n ? x[i] : 0.0);\n      }\n      /* v1 := inv(S0') * u1 */\n      scf_s0_solve(scf, 1, &w[0], work1, work2, work3);\n      /* v2 := inv(C') * (u2 - S'* v1) */\n      scf_st_prod(scf, &w[n0], -1.0, &w[0]);\n      ifu_at_solve(&scf->ifu, &w[n0], work1);\n      /* w2 := v2 */\n      /* nop */\n      /* w1 := inv(R0') * (v1 - R'* w2) */\n      scf_rt_prod(scf, &w[0], -1.0, &w[n0]);\n      scf_r0_solve(scf, 1, &w[0]);\n      /* compute (x, x~) := P * (w1, w2); x~ is not needed */\n      for (i = 1; i <= n; i++)\n      {\n#if 1 /* FIXME: currently P = I */\n         xassert(pp_inv[i] == i);\n#endif\n         x[i] = w[pp_inv[i]];\n      }\n      return;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "scf_add_r_row": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void scf_add_r_row(SCF *scf, const double w[/*1+n0*/])\n{     int n0 = scf->n0;\n      int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int rr_ref = scf->rr_ref;\n      int *rr_ptr = &sva->ptr[rr_ref-1];\n      int *rr_len = &sva->len[rr_ref-1];\n      int j, len, ptr;\n      xassert(0 <= nn && nn < scf->nn_max);\n      /* determine length of new row */\n      len = 0;\n      for (j = 1; j <= n0; j++)\n      {  if (w[j] != 0.0)\n            len++;\n      }\n      /* reserve locations for new row in static part of SVA */\n      if (len > 0)\n      {  if (sva->r_ptr - sva->m_ptr < len)\n         {  sva_more_space(sva, len);\n            sv_ind = sva->ind;\n            sv_val = sva->val;\n         }\n         sva_reserve_cap(sva, rr_ref + nn, len);\n      }\n      /* store new row in sparse format */\n      ptr = rr_ptr[nn+1];\n      for (j = 1; j <= n0; j++)\n      {  if (w[j] != 0.0)\n         {  sv_ind[ptr] = j;\n            sv_val[ptr] = w[j];\n            ptr++;\n         }\n      }\n      xassert(ptr - rr_ptr[nn+1] == len);\n      rr_len[nn+1] = len;\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n#endif\n      return;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "scf_add_s_col": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "void scf_add_s_col(SCF *scf, const double v[/*1+n0*/])\n{     int n0 = scf->n0;\n      int nn = scf->nn;\n      SVA *sva = scf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int ss_ref = scf->ss_ref;\n      int *ss_ptr = &sva->ptr[ss_ref-1];\n      int *ss_len = &sva->len[ss_ref-1];\n      int i, len, ptr;\n      xassert(0 <= nn && nn < scf->nn_max);\n      /* determine length of new column */\n      len = 0;\n      for (i = 1; i <= n0; i++)\n      {  if (v[i] != 0.0)\n            len++;\n      }\n      /* reserve locations for new column in static part of SVA */\n      if (len > 0)\n      {  if (sva->r_ptr - sva->m_ptr < len)\n         {  sva_more_space(sva, len);\n            sv_ind = sva->ind;\n            sv_val = sva->val;\n         }\n         sva_reserve_cap(sva, ss_ref + nn, len);\n      }\n      /* store new column in sparse format */\n      ptr = ss_ptr[nn+1];\n      for (i = 1; i <= n0; i++)\n      {  if (v[i] != 0.0)\n         {  sv_ind[ptr] = i;\n            sv_val[ptr] = v[i];\n            ptr++;\n         }\n      }\n      xassert(ptr - ss_ptr[nn+1] == len);\n      ss_len[nn+1] = len;\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n#endif\n      return;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "scf_update_aug": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "int scf_update_aug(SCF *scf, double b[/*1+n0*/], double d[/*1+n0*/],\n      double f[/*1+nn*/], double g[/*1+nn*/], double h, int upd,\n      double w1[/*1+n0*/], double w2[/*1+n0*/], double w3[/*1+n0*/])\n{     int n0 = scf->n0;\n      int k, ret;\n      double *v, *w, *x, *y, z;\n      if (scf->nn == scf->nn_max)\n      {  /* updating limit has been reached */\n         return 1;\n      }\n      /* v := inv(R0) * b */\n      scf_r0_solve(scf, 0, (v = b));\n      /* w := inv(S0') * d */\n      scf_s0_solve(scf, 1, (w = d), w1, w2, w3);\n      /* x := f - R * v */\n      scf_r_prod(scf, (x = f), -1.0, v);\n      /* y := g - S'* w */\n      scf_st_prod(scf, (y = g), -1.0, w);\n      /* z := h - v'* w */\n      z = h;\n      for (k = 1; k <= n0; k++)\n         z -= v[k] * w[k];\n      /* new R := R with row w added */\n      scf_add_r_row(scf, w);\n      /* new S := S with column v added */\n      scf_add_s_col(scf, v);\n      /* update IFU-factorization of C */\n      switch (upd)\n      {  case 1:\n            ret = ifu_bg_update(&scf->ifu, x, y, z);\n            break;\n         case 2:\n            ret = ifu_gr_update(&scf->ifu, x, y, z);\n            break;\n         default:\n            xassert(upd != upd);\n      }\n      if (ret != 0)\n      {  /* updating IFU-factorization failed */\n         return 2;\n      }\n      /* increase number of additional rows and columns */\n      scf->nn++;\n      /* expand P and Q */\n      k = n0 + scf->nn;\n      scf->pp_ind[k] = scf->pp_inv[k] = k;\n      scf->qq_ind[k] = scf->qq_inv[k] = k;\n      /* factorization has been successfully updated */\n      return 0;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/scf.h": {},
  "glpk/glpk-4.65/src/bflib/scfint.c": {
    "scfint_create": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "SCFINT *scfint_create(int type)\n{     /* create interface to SC-factorization */\n      SCFINT *fi;\n      fi = talloc(1, SCFINT);\n      memset(fi, 0, sizeof(SCFINT));\n      switch ((fi->scf.type = type))\n      {  case 1:\n            fi->u.lufi = lufint_create();\n            break;\n         case 2:\n            fi->u.btfi = btfint_create();\n            break;\n         default:\n            xassert(type != type);\n      }\n      return fi;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "SCFINT",
        "*scfint_create(int type)",
        "*"
      ]
    },
    "scfint_factorize": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "int scfint_factorize(SCFINT *fi, int n, int (*col)(void *info, int j,\n      int ind[], double val[]), void *info)\n{     /* compute SC-factorization of specified matrix A */\n      int nn_max, old_n0_max, n0_max, k, ret;\n      xassert(n > 0);\n      fi->valid = 0;\n      /* get required value of nn_max */\n      nn_max = fi->nn_max;\n      if (nn_max == 0)\n         nn_max = 100;\n      xassert(nn_max > 0);\n      /* compute factorization of specified matrix A */\n      switch (fi->scf.type)\n      {  case 1:\n            old_n0_max = fi->u.lufi->n_max;\n            fi->u.lufi->sva_n_max = 4 * n + 2 * nn_max;\n            ret = lufint_factorize(fi->u.lufi, n, col, info);\n            n0_max = fi->u.lufi->n_max;\n            fi->scf.sva = fi->u.lufi->sva;\n            fi->scf.a0.luf = fi->u.lufi->luf;\n            break;\n         case 2:\n            old_n0_max = fi->u.btfi->n_max;\n            fi->u.btfi->sva_n_max = 6 * n + 2 * nn_max;\n            ret = btfint_factorize(fi->u.btfi, n, col, info);\n            n0_max = fi->u.btfi->n_max;\n            fi->scf.sva = fi->u.btfi->sva;\n            fi->scf.a0.btf = fi->u.btfi->btf;\n            break;\n         default:\n            xassert(fi != fi);\n      }\n      /* allocate/reallocate arrays, if necessary */\n      if (old_n0_max < n0_max)\n      {  if (fi->w1 != NULL)\n            tfree(fi->w1);\n         if (fi->w2 != NULL)\n            tfree(fi->w2);\n         if (fi->w3 != NULL)\n            tfree(fi->w3);\n         fi->w1 = talloc(1+n0_max, double);\n         fi->w2 = talloc(1+n0_max, double);\n         fi->w3 = talloc(1+n0_max, double);\n      }\n      if (fi->scf.nn_max != nn_max)\n      {  if (fi->scf.ifu.f != NULL)\n            tfree(fi->scf.ifu.f);\n         if (fi->scf.ifu.u != NULL)\n            tfree(fi->scf.ifu.u);\n         fi->scf.ifu.f = talloc(nn_max * nn_max, double);\n         fi->scf.ifu.u = talloc(nn_max * nn_max, double);\n      }\n      if (old_n0_max < n0_max || fi->scf.nn_max != nn_max)\n      {  if (fi->scf.pp_ind != NULL)\n            tfree(fi->scf.pp_ind);\n         if (fi->scf.pp_inv != NULL)\n            tfree(fi->scf.pp_inv);\n         if (fi->scf.qq_ind != NULL)\n            tfree(fi->scf.qq_ind);\n         if (fi->scf.qq_inv != NULL)\n            tfree(fi->scf.qq_inv);\n         if (fi->w4 != NULL)\n            tfree(fi->w4);\n         if (fi->w5 != NULL)\n            tfree(fi->w5);\n         fi->scf.pp_ind = talloc(1+n0_max+nn_max, int);\n         fi->scf.pp_inv = talloc(1+n0_max+nn_max, int);\n         fi->scf.qq_ind = talloc(1+n0_max+nn_max, int);\n         fi->scf.qq_inv = talloc(1+n0_max+nn_max, int);\n         fi->w4 = talloc(1+n0_max+nn_max, double);\n         fi->w5 = talloc(1+n0_max+nn_max, double);\n      }\n      /* initialize SC-factorization */\n      fi->scf.n = n;\n      fi->scf.n0 = n;\n      fi->scf.nn_max = nn_max;\n      fi->scf.nn = 0;\n      fi->scf.rr_ref = sva_alloc_vecs(fi->scf.sva, nn_max);\n      fi->scf.ss_ref = sva_alloc_vecs(fi->scf.sva, nn_max);\n      fi->scf.ifu.n_max = nn_max;\n      fi->scf.ifu.n = 0;\n      for (k = 1; k <= n; k++)\n      {  fi->scf.pp_ind[k] = k;\n         fi->scf.pp_inv[k] = k;\n         fi->scf.qq_ind[k] = k;\n         fi->scf.qq_inv[k] = k;\n      }\n      /* set validation flag */\n      if (ret == 0)\n         fi->valid = 1;\n      return ret;\n}",
      "lines": 92,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "scfint_update": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int scfint_update(SCFINT *fi, int upd, int j, int len, const int ind[],\n      const double val[])\n{     /* update SC-factorization after replacing j-th column of A */\n      int n = fi->scf.n;\n      int n0 = fi->scf.n0;\n      int nn = fi->scf.nn;\n      int *pp_ind = fi->scf.pp_ind;\n      int *qq_ind = fi->scf.qq_ind;\n      int *qq_inv = fi->scf.qq_inv;\n      double *bf = fi->w4;\n      double *dg = fi->w5;\n      int k, t, ret;\n      xassert(fi->valid);\n      xassert(0 <= n && n <= n0+nn);\n      /* (b, f) := inv(P) * (beta, 0) */\n      for (k = 1; k <= n0+nn; k++)\n         bf[k] = 0.0;\n      for (t = 1; t <= len; t++)\n      {  k = ind[t];\n         xassert(1 <= k && k <= n);\n#if 1 /* FIXME: currently P = I */\n         xassert(pp_ind[k] == k);\n#endif\n         xassert(bf[k] == 0.0);\n         xassert(val[t] != 0.0);\n         bf[k] = val[t];\n      }\n      /* (d, g) := Q * (cj, 0) */\n      for (k = 1; k <= n0+nn; k++)\n         dg[k] = 0.0;\n      xassert(1 <= j && j <= n);\n      dg[fi->scf.qq_inv[j]] = 1;\n      /* update factorization of augmented matrix */\n      ret = scf_update_aug(&fi->scf, &bf[0], &dg[0], &bf[n0], &dg[n0],\n         0.0, upd, fi->w1, fi->w2, fi->w3);\n      if (ret == 0)\n      {  /* swap j-th and last columns of new matrix Q */\n         scf_swap_q_cols(j, n0+nn+1);\n      }\n      else\n      {  /* updating failed */\n         fi->valid = 0;\n      }\n      return ret;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "scfint_ftran": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void scfint_ftran(SCFINT *fi, double x[])\n{     /* solve system A * x = b */\n      xassert(fi->valid);\n      scf_a_solve(&fi->scf, x, fi->w4, fi->w5, fi->w1, fi->w2);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "scfint_btran": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void scfint_btran(SCFINT *fi, double x[])\n{     /* solve system A'* x = b */\n      xassert(fi->valid);\n      scf_at_solve(&fi->scf, x, fi->w4, fi->w5, fi->w1, fi->w2);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "scfint_estimate": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "double scfint_estimate(SCFINT *fi)\n{     /* estimate 1-norm of inv(A) */\n      double norm;\n      xassert(fi->valid);\n      xassert(fi->scf.n == fi->scf.n0);\n      switch (fi->scf.type)\n      {  case 1:\n            norm = luf_estimate_norm(fi->scf.a0.luf, fi->w1, fi->w2);\n            break;\n         case 2:\n            norm = btf_estimate_norm(fi->scf.a0.btf, fi->w1, fi->w2,\n               fi->w3, fi->w4);\n            break;\n         default:\n            xassert(fi != fi);\n      }\n      return norm;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "scfint_delete": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "void scfint_delete(SCFINT *fi)\n{     /* delete interface to SC-factorization */\n      switch (fi->scf.type)\n      {  case 1:\n            lufint_delete(fi->u.lufi);\n            break;\n         case 2:\n            btfint_delete(fi->u.btfi);\n            break;\n         default:\n            xassert(fi != fi);\n      }\n      if (fi->scf.ifu.f != NULL)\n         tfree(fi->scf.ifu.f);\n      if (fi->scf.ifu.u != NULL)\n         tfree(fi->scf.ifu.u);\n      if (fi->scf.pp_ind != NULL)\n         tfree(fi->scf.pp_ind);\n      if (fi->scf.pp_inv != NULL)\n         tfree(fi->scf.pp_inv);\n      if (fi->scf.qq_ind != NULL)\n         tfree(fi->scf.qq_ind);\n      if (fi->scf.qq_inv != NULL)\n         tfree(fi->scf.qq_inv);\n      if (fi->w1 != NULL)\n         tfree(fi->w1);\n      if (fi->w2 != NULL)\n         tfree(fi->w2);\n      if (fi->w3 != NULL)\n         tfree(fi->w3);\n      if (fi->w4 != NULL)\n         tfree(fi->w4);\n      if (fi->w5 != NULL)\n         tfree(fi->w5);\n      tfree(fi);\n      return;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/scfint.h": {},
  "glpk/glpk-4.65/src/bflib/sgf.c": {
    "sgf_reduce_nuc": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "int sgf_reduce_nuc(LUF *luf, int *k1_, int *k2_, int cnt[/*1+n*/],\n      int list[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int i, ii, j, jj, k1, k2, ns, ptr, end;\n      /* initial nucleus is U = V = A */\n      k1 = 1, k2 = n;\n      /*--------------------------------------------------------------*/\n      /* process column singletons                                    */\n      /*--------------------------------------------------------------*/\n      /* determine initial counts of columns of V and initialize list\n       * of active column singletons */\n      ns = 0; /* number of active column singletons */\n      for (j = 1; j <= n; j++)\n      {  if ((cnt[j] = vc_len[j]) == 1)\n            list[++ns] = j;\n      }\n      /* process active column singletons */\n      while (ns > 0)\n      {  /* column singleton is in j-th column of V */\n         j = list[ns--];\n#if 1 /* 21/II-2016 */\n         if (cnt[j] == 0)\n         {  /* j-th column in the current nucleus is actually empty */\n            /* this happened because on a previous step in the nucleus\n             * there were two or more identical column singletons (that\n             * means structural singularity), so removing one of them\n             * from the nucleus made other columns empty */\n            return 1;\n         }\n#endif\n         /* find i-th row of V containing column singleton */\n         ptr = vc_ptr[j];\n         end = ptr + vc_len[j];\n         for (; pp_ind[i = sv_ind[ptr]] < k1; ptr++)\n            /* nop */;\n         xassert(ptr < end);\n         /* permute rows and columns of U to move column singleton to\n          * position u[k1,k1] */\n         ii = pp_ind[i];\n         luf_swap_u_rows(k1, ii);\n         jj = qq_inv[j];\n         luf_swap_u_cols(k1, jj);\n         /* nucleus size decreased */\n         k1++;\n         /* walk thru i-th row of V and decrease column counts; this\n          * may cause new column singletons to appear */\n         ptr = vr_ptr[i];\n         end = ptr + vr_len[i];\n         for (; ptr < end; ptr++)\n         {  if (--(cnt[j = sv_ind[ptr]]) == 1)\n               list[++ns] = j;\n         }\n      }\n      /* nucleus begins at k1-th row/column of U */\n      if (k1 > n)\n      {  /* U is upper triangular; no nucleus exist */\n         goto done;\n      }\n      /*--------------------------------------------------------------*/\n      /* process row singletons                                       */\n      /*--------------------------------------------------------------*/\n      /* determine initial counts of rows of V and initialize list of\n       * active row singletons */\n      ns = 0; /* number of active row singletons */\n      for (i = 1; i <= n; i++)\n      {  if (pp_ind[i] < k1)\n         {  /* corresponding row of U is above its k1-th row; set its\n             * count to zero to prevent including it in active list */\n            cnt[i] = 0;\n         }\n         else if ((cnt[i] = vr_len[i]) == 1)\n            list[++ns] = i;\n      }\n      /* process active row singletons */\n      while (ns > 0)\n      {  /* row singleton is in i-th row of V */\n         i = list[ns--];\n#if 1 /* 21/II-2016 */\n         if (cnt[i] == 0)\n         {  /* i-th row in the current nucleus is actually empty */\n            /* (see comments above for similar case of empty column) */\n            return 2;\n         }\n#endif\n         /* find j-th column of V containing row singleton */\n         ptr = vr_ptr[i];\n         end = ptr + vr_len[i];\n         for (; qq_inv[j = sv_ind[ptr]] > k2; ptr++)\n            /* nop */;\n         xassert(ptr < end);\n         /* permute rows and columns of U to move row singleton to\n          * position u[k2,k2] */\n         ii = pp_ind[i];\n         luf_swap_u_rows(k2, ii);\n         jj = qq_inv[j];\n         luf_swap_u_cols(k2, jj);\n         /* nucleus size decreased */\n         k2--;\n         /* walk thru j-th column of V and decrease row counts; this\n          * may cause new row singletons to appear */\n         ptr = vc_ptr[j];\n         end = ptr + vc_len[j];\n         for (; ptr < end; ptr++)\n         {  if (--(cnt[i = sv_ind[ptr]]) == 1)\n               list[++ns] = i;\n         }\n      }\n      /* nucleus ends at k2-th row/column of U */\n      xassert(k1 < k2);\ndone: *k1_ = k1, *k2_ = k2;\n      return 0;\n}",
      "lines": 124,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "sgf_singl_phase": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "int sgf_singl_phase(LUF *luf, int k1, int k2, int updat,\n      int ind[/*1+n*/], double val[/*1+n*/])\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int i, j, k, ptr, ptr1, end, len;\n      double piv;\n      /* (see routine sgf_reduce_nuc) */\n      xassert((1 <= k1 && k1 < k2 && k2 <= n)\n         || (k1 == n+1 && k2 == n));\n      /* perform symmetric permutations of rows/columns of U */\n      for (k = k1; k <= k2; k++)\n         pp_ind[pp_inv[k]] = qq_inv[qq_ind[k]] = k - k2 + n;\n      for (k = k2+1; k <= n; k++)\n         pp_ind[pp_inv[k]] = qq_inv[qq_ind[k]] = n - k + k1;\n      for (k = 1; k <= n; k++)\n         pp_inv[pp_ind[k]] = qq_ind[qq_inv[k]] = k;\n      /* determine k2' */\n      k2 = n - k2 + k1;\n      /* process rows and columns of V corresponding to rows and\n       * columns 1, ..., k1-1 of U */\n      for (k = 1; k < k1; k++)\n      {  /* k-th row of U = i-th row of V */\n         i = pp_inv[k];\n         /* find pivot u[k,k] = v[i,j] in i-th row of V */\n         ptr = vr_ptr[i];\n         end = ptr + vr_len[i];\n         for (; qq_inv[sv_ind[ptr]] != k; ptr++)\n            /* nop */;\n         xassert(ptr < end);\n         /* store pivot */\n         vr_piv[i] = sv_val[ptr];\n         /* and remove it from i-th row of V */\n         sv_ind[ptr] = sv_ind[end-1];\n         sv_val[ptr] = sv_val[end-1];\n         vr_len[i]--;\n         /* clear column of V corresponding to k-th column of U */\n         vc_len[qq_ind[k]] = 0;\n      }\n      /* clear rows of V corresponding to rows k1, ..., k2'-1 of U */\n      for (k = k1; k < k2; k++)\n         vr_len[pp_inv[k]] = 0;\n      /* process rows and columns of V corresponding to rows and\n       * columns k2', ..., n of U */\n      for (k = k2; k <= n; k++)\n      {  /* k-th row of U = i-th row of V */\n         i = pp_inv[k];\n         /* remove elements from i-th row of V that correspond to\n          * elements u[k,k1], ..., u[k,k2'-1] */\n         ptr = ptr1 = vr_ptr[i];\n         end = ptr + vr_len[i];\n         for (; ptr < end; ptr++)\n         {  if (qq_inv[sv_ind[ptr]] >= k2)\n            {  sv_ind[ptr1] = sv_ind[ptr];\n               sv_val[ptr1] = sv_val[ptr];\n               ptr1++;\n            }\n         }\n         vr_len[i] = ptr1 - vr_ptr[i];\n         /* k-th column of U = j-th column of V */\n         j = qq_ind[k];\n         /* remove elements from j-th column of V that correspond to\n          * elements u[1,k], ..., u[k1-1,k] */\n         ptr = ptr1 = vc_ptr[j];\n         end = ptr + vc_len[j];\n         for (; ptr < end; ptr++)\n         {  if (pp_ind[sv_ind[ptr]] >= k2)\n               /* element value is not needed in this case */\n               sv_ind[ptr1++] = sv_ind[ptr];\n         }\n         vc_len[j] = ptr1 - vc_ptr[j];\n      }\n      /* process columns of V corresponding to columns k1, ..., k2'-1\n       * of U, build columns of F */\n      for (k = k1; k < k2; k++)\n      {  /* k-th column of U = j-th column of V */\n         j = qq_ind[k];\n         /* remove elements from j-th column of V that correspond to\n          * pivot (diagonal) element u[k,k] and subdiagonal elements\n          * u[k+1,k], ..., u[n,k]; subdiagonal elements are stored for\n          * further addition to matrix F */\n         len = 0;\n         piv = 0.0;\n         ptr = vc_ptr[j];\n         end = ptr + vc_len[j];\n         for (; ptr < end; ptr++)\n         {  i = sv_ind[ptr]; /* v[i,j] */\n            if (pp_ind[i] == k)\n            {  /* store pivot v[i,j] = u[k,k] */\n               piv = vr_piv[i] = sv_val[ptr];\n            }\n            else if (pp_ind[i] > k)\n            {  /* store subdiagonal element v[i,j] = u[i',k] */\n               len++;\n               ind[len] = i;\n               val[len] = sv_val[ptr];\n            }\n         }\n         /* clear j-th column of V = k-th column of U */\n         vc_len[j] = 0;\n         /* build k-th column of L = j-th column of F */\n         j = pp_inv[k];\n         xassert(piv != 0.0);\n         if (len > 0)\n         {  if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_reserve_cap(sva, fc_ref-1+j, len);\n            for (ptr = fc_ptr[j], ptr1 = 1; ptr1 <= len; ptr++, ptr1++)\n            {  sv_ind[ptr] = ind[ptr1];\n               sv_val[ptr] = val[ptr1] / piv;\n            }\n            fc_len[j] = len;\n         }\n      }\n      /* if it is not planned to update matrix V, relocate all its\n       * non-active rows corresponding to rows 1, ..., k2'-1 of U to\n       * the right (static) part of SVA */\n      if (!updat)\n      {  for (k = 1; k < k2; k++)\n         {  i = pp_inv[k];\n            len = vr_len[i];\n            if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_make_static(sva, vr_ref-1+i);\n         }\n      }\n      /* elimination steps 1, ..., k2'-1 have been performed */\n      return k2;\n}",
      "lines": 150,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "sgf_choose_pivot": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "int sgf_choose_pivot(SGF *sgf, int *p_, int *q_)\n{     LUF *luf = sgf->luf;\n      int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *rs_head = sgf->rs_head;\n      int *rs_next = sgf->rs_next;\n      int *cs_head = sgf->cs_head;\n      int *cs_prev = sgf->cs_prev;\n      int *cs_next = sgf->cs_next;\n      double *vr_max = sgf->vr_max;\n      double piv_tol = sgf->piv_tol;\n      int piv_lim = sgf->piv_lim;\n      int suhl = sgf->suhl;\n      int i, i_ptr, i_end, j, j_ptr, j_end, len, min_i, min_j, min_len,\n         ncand, next_j, p, q;\n      double best, big, cost, temp;\n      /* no pivot candidate has been chosen so far */\n      p = q = 0, best = DBL_MAX, ncand = 0;\n      /* if the active submatrix contains a column having the only\n       * non-zero element (column singleton), choose it as the pivot */\n      j = cs_head[1];\n      if (j != 0)\n      {  xassert(vc_len[j] == 1);\n         p = sv_ind[vc_ptr[j]], q = j;\n         goto done;\n      }\n      /* if the active submatrix contains a row having the only\n       * non-zero element (row singleton), choose it as the pivot */\n      i = rs_head[1];\n      if (i != 0)\n      {  xassert(vr_len[i] == 1);\n         p = i, q = sv_ind[vr_ptr[i]];\n         goto done;\n      }\n      /* the active submatrix contains no singletons; walk thru its\n       * other non-empty rows and columns */\n      for (len = 2; len <= n; len++)\n      {  /* consider active columns containing len non-zeros */\n         for (j = cs_head[len]; j != 0; j = next_j)\n         {  /* save the number of next column of the same length */\n            next_j = cs_next[j];\n            /* find an element in j-th column, which is placed in the\n             * row with minimal number of non-zeros and satisfies to\n             * the stability condition (such element may not exist) */\n            min_i = min_j = 0, min_len = INT_MAX;\n            for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];\n               j_ptr < j_end; j_ptr++)\n            {  /* get row index of v[i,j] */\n               i = sv_ind[j_ptr];\n               /* if i-th row is not shorter, skip v[i,j] */\n               if (vr_len[i] >= min_len)\n                  continue;\n               /* big := max|v[i,*]| */\n               if ((big = vr_max[i]) < 0.0)\n               {  /* largest magnitude is unknown; compute it */\n                  for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n                     i_ptr < i_end; i_ptr++)\n                  {  if ((temp = sv_val[i_ptr]) < 0.0)\n                        temp = -temp;\n                     if (big < temp)\n                        big = temp;\n                  }\n                  xassert(big > 0.0);\n                  vr_max[i] = big;\n               }\n               /* find v[i,j] in i-th row */\n               for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n                  sv_ind[i_ptr] != j; i_ptr++)\n                  /* nop */;\n               xassert(i_ptr < i_end);\n               /* if |v[i,j]| < piv_tol * max|v[i,*]|, skip v[i,j] */\n               if ((temp = sv_val[i_ptr]) < 0.0)\n                  temp = -temp;\n               if (temp < piv_tol * big)\n                  continue;\n               /* v[i,j] is a better candidate */\n               min_i = i, min_j = j, min_len = vr_len[i];\n               /* if Markowitz cost of v[i,j] is not greater than\n                * (len-1)**2, v[i,j] can be chosen as the pivot right\n                * now; this heuristic reduces the search and works well\n                * in many cases */\n               if (min_len <= len)\n               {  p = min_i, q = min_j;\n                  goto done;\n               }\n            }\n            /* j-th column has been scanned */\n            if (min_i != 0)\n            {  /* element v[min_i,min_j] is a next pivot candidate */\n               ncand++;\n               /* compute its Markowitz cost */\n               cost = (double)(min_len - 1) * (double)(len - 1);\n               /* if this element is better, choose it as the pivot */\n               if (cost < best)\n                  p = min_i, q = min_j, best = cost;\n               /* if piv_lim candidates were considered, terminate\n                * the search, because it is doubtful that a much better\n                * candidate will be found */\n               if (ncand == piv_lim)\n                  goto done;\n            }\n            else if (suhl)\n            {  /* j-th column has no eligible elements that satisfy to\n                * the stability criterion; Uwe Suhl suggests to exclude\n                * such column from further considerations until it\n                * becomes a column singleton; in hard cases this may\n                * significantly reduce the time needed to choose the\n                * pivot element */\n               sgf_deactivate_col(j);\n               cs_prev[j] = cs_next[j] = j;\n            }\n         }\n         /* consider active rows containing len non-zeros */\n         for (i = rs_head[len]; i != 0; i = rs_next[i])\n         {  /* big := max|v[i,*]| */\n            if ((big = vr_max[i]) < 0.0)\n            {  /* largest magnitude is unknown; compute it */\n               for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n                  i_ptr < i_end; i_ptr++)\n               {  if ((temp = sv_val[i_ptr]) < 0.0)\n                     temp = -temp;\n                  if (big < temp)\n                     big = temp;\n               }\n               xassert(big > 0.0);\n               vr_max[i] = big;\n            }\n            /* find an element in i-th row, which is placed in the\n             * column with minimal number of non-zeros and satisfies to\n             * the stability condition (such element always exists) */\n            min_i = min_j = 0, min_len = INT_MAX;\n            for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n               i_ptr < i_end; i_ptr++)\n            {  /* get column index of v[i,j] */\n               j = sv_ind[i_ptr];\n               /* if j-th column is not shorter, skip v[i,j] */\n               if (vc_len[j] >= min_len)\n                  continue;\n               /* if |v[i,j]| < piv_tol * max|v[i,*]|, skip v[i,j] */\n               if ((temp = sv_val[i_ptr]) < 0.0)\n                  temp = -temp;\n               if (temp < piv_tol * big)\n                  continue;\n               /* v[i,j] is a better candidate */\n               min_i = i, min_j = j, min_len = vc_len[j];\n               /* if Markowitz cost of v[i,j] is not greater than\n                * (len-1)**2, v[i,j] can be chosen as the pivot right\n                * now; this heuristic reduces the search and works well\n                * in many cases */\n               if (min_len <= len)\n               {  p = min_i, q = min_j;\n                  goto done;\n               }\n            }\n            /* i-th row has been scanned */\n            if (min_i != 0)\n            {  /* element v[min_i,min_j] is a next pivot candidate */\n               ncand++;\n               /* compute its Markowitz cost */\n               cost = (double)(len - 1) * (double)(min_len - 1);\n               /* if this element is better, choose it as the pivot */\n               if (cost < best)\n                  p = min_i, q = min_j, best = cost;\n               /* if piv_lim candidates were considered, terminate\n                * the search, because it is doubtful that a much better\n                * candidate will be found */\n               if (ncand == piv_lim)\n                  goto done;\n            }\n            else\n            {  /* this can never be */\n               xassert(min_i != min_i);\n            }\n         }\n      }\ndone: /* report the pivot to the factorization routine */\n      *p_ = p, *q_ = q;\n      return (p == 0);\n}",
      "lines": 187,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "sgf_eliminate": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "int sgf_eliminate(SGF *sgf, int p, int q)\n{     LUF *luf = sgf->luf;\n      int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int *vr_cap = &sva->cap[vr_ref-1];\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_ptr = &sva->ptr[vc_ref-1];\n      int *vc_len = &sva->len[vc_ref-1];\n      int *vc_cap = &sva->cap[vc_ref-1];\n      int *rs_head = sgf->rs_head;\n      int *rs_prev = sgf->rs_prev;\n      int *rs_next = sgf->rs_next;\n      int *cs_head = sgf->cs_head;\n      int *cs_prev = sgf->cs_prev;\n      int *cs_next = sgf->cs_next;\n      double *vr_max = sgf->vr_max;\n      char *flag = sgf->flag;\n      double *work = sgf->work;\n      double eps_tol = sgf->eps_tol;\n      int nnz_diff = 0;\n      int fill, i, i_ptr, i_end, j, j_ptr, j_end, ptr, len, loc, loc1;\n      double vpq, fip, vij;\n      xassert(1 <= p && p <= n);\n      xassert(1 <= q && q <= n);\n      /* remove p-th row from the active set; this row will never\n       * return there */\n      sgf_deactivate_row(p);\n      /* process p-th (pivot) row */\n      ptr = 0;\n      for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];\n         i_ptr < i_end; i_ptr++)\n      {  /* get column index of v[p,j] */\n         j = sv_ind[i_ptr];\n         if (j == q)\n         {  /* save pointer to pivot v[p,q] */\n            ptr = i_ptr;\n         }\n         else\n         {  /* store v[p,j], j != q, to working array */\n            flag[j] = 1;\n            work[j] = sv_val[i_ptr];\n         }\n         /* remove j-th column from the active set; q-th column will\n          * never return there while other columns will return to the\n          * active set with new length */\n         if (cs_next[j] == j)\n         {  /* j-th column was marked by the pivoting routine according\n             * to Uwe Suhl's suggestion and is already inactive */\n            xassert(cs_prev[j] == j);\n         }\n         else\n            sgf_deactivate_col(j);\n         nnz_diff -= vc_len[j];\n         /* find and remove v[p,j] from j-th column */\n         for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];\n            sv_ind[j_ptr] != p; j_ptr++)\n            /* nop */;\n         xassert(j_ptr < j_end);\n         sv_ind[j_ptr] = sv_ind[j_end-1];\n         vc_len[j]--;\n      }\n      /* save pivot v[p,q] and remove it from p-th row */\n      xassert(ptr > 0);\n      vpq = vr_piv[p] = sv_val[ptr];\n      sv_ind[ptr] = sv_ind[i_end-1];\n      sv_val[ptr] = sv_val[i_end-1];\n      vr_len[p]--;\n      /* if it is not planned to update matrix V, relocate p-th row to\n       * the right (static) part of SVA */\n      if (!sgf->updat)\n      {  len = vr_len[p];\n         if (sva->r_ptr - sva->m_ptr < len)\n         {  sva_more_space(sva, len);\n            sv_ind = sva->ind;\n            sv_val = sva->val;\n         }\n         sva_make_static(sva, vr_ref-1+p);\n      }\n      /* copy the pattern (row indices) of q-th column of the active\n       * submatrix (from which v[p,q] has been just removed) to p-th\n       * column of matrix F (without unity diagonal element) */\n      len = vc_len[q];\n      if (len > 0)\n      {  if (sva->r_ptr - sva->m_ptr < len)\n         {  sva_more_space(sva, len);\n            sv_ind = sva->ind;\n            sv_val = sva->val;\n         }\n         sva_reserve_cap(sva, fc_ref-1+p, len);\n         memcpy(&sv_ind[fc_ptr[p]], &sv_ind[vc_ptr[q]],\n            len * sizeof(int));\n         fc_len[p] = len;\n      }\n      /* make q-th column of the active submatrix empty */\n      vc_len[q] = 0;\n      /* transform non-pivot rows of the active submatrix */\n      for (loc = fc_len[p]-1; loc >= 0; loc--)\n      {  /* get row index of v[i,q] = row index of f[i,p] */\n         i = sv_ind[fc_ptr[p] + loc];\n         xassert(i != p); /* v[p,q] was removed */\n         /* remove i-th row from the active set; this row will return\n          * there with new length */\n         sgf_deactivate_row(i);\n         /* find v[i,q] in i-th row */\n         for (i_end = (i_ptr = vr_ptr[i]) + vr_len[i];\n            sv_ind[i_ptr] != q; i_ptr++)\n            /* nop */;\n         xassert(i_ptr < i_end);\n         /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] */\n         fip = sv_val[fc_ptr[p] + loc] = sv_val[i_ptr] / vpq;\n         /* remove v[i,q] from i-th row */\n         sv_ind[i_ptr] = sv_ind[i_end-1];\n         sv_val[i_ptr] = sv_val[i_end-1];\n         vr_len[i]--;\n         /* perform elementary gaussian transformation:\n          * (i-th row) := (i-th row) - f[i,p] * (p-th row)\n          * note that p-th row of V, which is in the working array,\n          * doesn't contain pivot v[p,q], and i-th row of V doesn't\n          * contain v[i,q] to be eliminated */\n         /* walk thru i-th row and transform existing elements */\n         fill = vr_len[p];\n         for (i_end = (i_ptr = ptr = vr_ptr[i]) + vr_len[i];\n            i_ptr < i_end; i_ptr++)\n         {  /* get column index and value of v[i,j] */\n            j = sv_ind[i_ptr];\n            vij = sv_val[i_ptr];\n            if (flag[j])\n            {  /* v[p,j] != 0 */\n               flag[j] = 0, fill--;\n               /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */\n               vij -= fip * work[j];\n               if (-eps_tol < vij && vij < +eps_tol)\n               {  /* new v[i,j] is close to zero; remove it from the\n                   * active submatrix, i.e. replace it by exact zero */\n                  /* find and remove v[i,j] from j-th column */\n                  for (j_end = (j_ptr = vc_ptr[j]) + vc_len[j];\n                     sv_ind[j_ptr] != i; j_ptr++)\n                     /* nop */;\n                  xassert(j_ptr < j_end);\n                  sv_ind[j_ptr] = sv_ind[j_end-1];\n                  vc_len[j]--;\n                  continue;\n               }\n            }\n            /* keep new v[i,j] in i-th row */\n            sv_ind[ptr] = j;\n            sv_val[ptr] = vij;\n            ptr++;\n         }\n         /* (new length of i-th row may decrease because of numerical\n          * cancellation) */\n         vr_len[i] = len = ptr - vr_ptr[i];\n         /* now flag[*] is the pattern of the set v[p,*] \\ v[i,*], and\n          * fill is the number of non-zeros in this set */\n         if (fill == 0)\n         {  /* no fill-in occurs */\n            /* walk thru p-th row and restore the column flags */\n            for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];\n               i_ptr < i_end; i_ptr++)\n               flag[sv_ind[i_ptr]] = 1; /* v[p,j] != 0 */\n            goto skip;\n         }\n         /* up to fill new non-zero elements may appear in i-th row due\n          * to fill-in; reserve locations for these elements (note that\n          * actual length of i-th row is currently stored in len) */\n         if (vr_cap[i] < len + fill)\n         {  if (sva->r_ptr - sva->m_ptr < len + fill)\n            {  sva_more_space(sva, len + fill);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_enlarge_cap(sva, vr_ref-1+i, len + fill, 0);\n         }\n         vr_len[i] += fill;\n         /* walk thru p-th row and add new elements to i-th row */\n         for (loc1 = vr_len[p]-1; loc1 >= 0; loc1--)\n         {  /* get column index of v[p,j] */\n            j = sv_ind[vr_ptr[p] + loc1];\n            if (!flag[j])\n            {  /* restore j-th column flag */\n               flag[j] = 1;\n               /* v[i,j] was computed earlier on transforming existing\n                * elements of i-th row */\n               continue;\n            }\n            /* v[i,j] := 0 - f[i,p] * v[p,j] */\n            vij = - fip * work[j];\n            if (-eps_tol < vij && vij < +eps_tol)\n            {  /* new v[i,j] is close to zero; do not add it to the\n                * active submatrix, i.e. replace it by exact zero */\n               continue;\n            }\n            /* add new v[i,j] to i-th row */\n            sv_ind[ptr = vr_ptr[i] + (len++)] = j;\n            sv_val[ptr] = vij;\n            /* add new v[i,j] to j-th column */\n            if (vc_cap[j] == vc_len[j])\n            {  /* we reserve extra locations in j-th column to reduce\n                * further relocations of that column */\n#if 1 /* FIXME */\n               /* use control parameter to specify the number of extra\n                * locations reserved */\n               int need = vc_len[j] + 10;\n#endif\n               if (sva->r_ptr - sva->m_ptr < need)\n               {  sva_more_space(sva, need);\n                  sv_ind = sva->ind;\n                  sv_val = sva->val;\n               }\n               sva_enlarge_cap(sva, vc_ref-1+j, need, 1);\n            }\n            sv_ind[vc_ptr[j] + (vc_len[j]++)] = i;\n         }\n         /* set final length of i-th row just transformed */\n         xassert(len <= vr_len[i]);\n         vr_len[i] = len;\nskip:    /* return i-th row to the active set with new length */\n         sgf_activate_row(i);\n         /* since i-th row has been changed, largest magnitude of its\n          * elements becomes unknown */\n         vr_max[i] = -1.0;\n      }\n      /* walk thru p-th (pivot) row */\n      for (i_end = (i_ptr = vr_ptr[p]) + vr_len[p];\n         i_ptr < i_end; i_ptr++)\n      {  /* get column index of v[p,j] */\n         j = sv_ind[i_ptr];\n         xassert(j != q); /* v[p,q] was removed */\n         /* return j-th column to the active set with new length */\n         if (cs_next[j] == j && vc_len[j] != 1)\n         {  /* j-th column was marked by the pivoting routine and it is\n             * still not a column singleton, so leave it incative */\n            xassert(cs_prev[j] == j);\n         }\n         else\n            sgf_activate_col(j);\n         nnz_diff += vc_len[j];\n         /* restore zero content of the working arrays */\n         flag[j] = 0;\n         work[j] = 0.0;\n      }\n      /* return the difference between the numbers of non-zeros in the\n       * active submatrix on entry and on exit, resp. */\n      return nnz_diff;\n}",
      "lines": 254,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "sgf_dense_lu": {
      "start_point": [
        1006,
        0
      ],
      "end_point": [
        1056,
        1
      ],
      "content": "int sgf_dense_lu(int n, double a_[], int r[], int c[], double eps)\n{     /* non-optimized version */\n      int i, j, k, p, q, ref;\n      double akk, big, temp;\n#     define a(i,j) a_[(i)*n+(j)]\n      /* initially U = A, L = P = Q = I */\n      /* main elimination loop */\n      for (k = 0; k < n; k++)\n      {  /* choose pivot u[p,q], k <= p, q <= n */\n         p = q = -1, big = eps;\n         for (i = k; i < n; i++)\n         {  for (j = k; j < n; j++)\n            {  /* temp = |u[i,j]| */\n               if ((temp = a(i,j)) < 0.0)\n                  temp = -temp;\n               if (big < temp)\n                  p = i, q = j, big = temp;\n            }\n         }\n         if (p < 0)\n         {  /* k-th elimination step failed */\n            return k+1;\n         }\n         /* permute rows k and p */\n         if (k != p)\n         {  for (j = 0; j < n; j++)\n               temp = a(k,j), a(k,j) = a(p,j), a(p,j) = temp;\n            ref = r[k], r[k] = r[p], r[p] = ref;\n         }\n         /* permute columns k and q */\n         if (k != q)\n         {  for (i = 0; i < n; i++)\n               temp = a(i,k), a(i,k) = a(i,q), a(i,q) = temp;\n            ref = c[k], c[k] = c[q], c[q] = ref;\n         }\n         /* now pivot is in position u[k,k] */\n         akk = a(k,k);\n         /* eliminate subdiagonal elements u[k+1,k], ..., u[n,k] */\n         for (i = k+1; i < n; i++)\n         {  if (a(i,k) != 0.0)\n            {  /* gaussian multiplier l[i,k] := u[i,k] / u[k,k] */\n               temp = (a(i,k) /= akk);\n               /* (i-th row) := (i-th row) - l[i,k] * (k-th row) */\n               for (j = k+1; j < n; j++)\n                  a(i,j) -= temp * a(k,j);\n            }\n         }\n      }\n#     undef a\n      return 0;\n}",
      "lines": 51,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "sgf_dense_phase": {
      "start_point": [
        1103,
        0
      ],
      "end_point": [
        1282,
        1
      ],
      "content": "int sgf_dense_phase(LUF *luf, int k, int updat)\n{     int n = luf->n;\n      SVA *sva = luf->sva;\n      int *sv_ind = sva->ind;\n      double *sv_val = sva->val;\n      int fc_ref = luf->fc_ref;\n      int *fc_ptr = &sva->ptr[fc_ref-1];\n      int *fc_len = &sva->len[fc_ref-1];\n      int *fc_cap = &sva->cap[fc_ref-1];\n      int vr_ref = luf->vr_ref;\n      int *vr_ptr = &sva->ptr[vr_ref-1];\n      int *vr_len = &sva->len[vr_ref-1];\n      int *vr_cap = &sva->cap[vr_ref-1];\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_inv = luf->pp_inv;\n      int *pp_ind = luf->pp_ind;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int a_end, a_ptr, end, i, ia, ii, j, ja, jj, ka, len, na, ne,\n         need, ptr;\n      double *a_;\n      xassert(1 <= k && k <= n);\n      /* active columns of V are not longer needed; make them empty */\n      for (jj = k; jj <= n; jj++)\n      {  /* jj is number of active column of U = P'* V * Q' */\n         vc_len[qq_ind[jj]] = 0;\n      }\n      /* determine order of active submatrix A~ of matrix U */\n      na = n - k + 1;\n      xassert(1 <= na && na <= n);\n      /* determine number of elements in dense triangular factor (L~ or\n       * U~), except diagonal elements */\n      ne = na * (na - 1) / 2;\n      /* we allocate active submatrix A~ in free (middle) part of SVA;\n       * to avoid defragmentation that could destroy A~ we also should\n       * reserve ne locations to build rows of V from rows of U~ and ne\n       * locations to build columns of F from columns of L~ */\n      need = na * na + ne + ne;\n      if (sva->r_ptr - sva->m_ptr < need)\n      {  sva_more_space(sva, need);\n         sv_ind = sva->ind;\n         sv_val = sva->val;\n      }\n      /* free (middle) part of SVA is structured as follows:\n       * end of left (dynamic) part\n       * ne free locations for new rows of V\n       * na free locations for active submatrix A~\n       * unused locations, if any\n       * ne free locations for new columns of F\n       * beginning of right (static) part */\n      a_ptr = sva->m_ptr + ne;\n      a_end = a_ptr + na * na;\n      /* copy active submatrix A~ from matrix V to working array in\n       * dense row-wise format */\n      a_ = &sva->val[a_ptr];\n#     define a(ia, ja) a_[((ia) - 1) * na + ((ja) - 1)]\n      for (ia = 1; ia <= na; ia++)\n      {  /* clear ia-th row of A~ */\n         for (ja = 1; ja <= na; ja++)\n            a(ia, ja) = 0.0;\n         /* ia-th row of A~ = (k-1+ia)-th row of U = i-th row of V */\n         i = pp_inv[k-1+ia];\n         ptr = vr_ptr[i];\n         end = ptr + vr_len[i];\n         for (; ptr < end; ptr++)\n            a(ia, qq_inv[sv_ind[ptr]]-k+1) = sv_val[ptr];\n         /* i-th row of V is no longer needed; make it empty */\n         vr_len[i] = 0;\n      }\n      /* compute dense factorization A~ = P~* L~* U~* Q~ */\n#if 1 /* FIXME: epsilon tolerance */\n      ka = sgf_dense_lu(na, &a(1, 1), &pp_inv[k], &qq_ind[k], 1e-20);\n#endif\n      /* rows of U with numbers pp_inv[k, k+1, ..., n] were permuted\n       * due to row permutations of A~; update matrix P using P~ */\n      for (ii = k; ii <= n; ii++)\n         pp_ind[pp_inv[ii]] = ii;\n      /* columns of U with numbers qq_ind[k, k+1, ..., n] were permuted\n       * due to column permutations of A~; update matrix Q using Q~ */\n      for (jj = k; jj <= n; jj++)\n         qq_inv[qq_ind[jj]] = jj;\n      /* check if dense factorization is complete */\n      if (ka != 0)\n      {  /* A~ is singular to working precision */\n         /* information on linearly dependent rows/columns is provided\n          * by matrices P and Q */\n         xassert(1 <= ka && ka <= na);\n         return k - 1 + ka;\n      }\n      /* build new rows of V from rows of U~ */\n      for (ia = 1; ia <= na; ia++)\n      {  /* ia-th row of U~ = (k-1+ia)-th row of U = i-th row of V */\n         i = pp_inv[k-1+ia];\n         xassert(vr_len[i] == 0);\n         /* store diagonal element u~[ia,ia] */\n         vr_piv[i] = a(ia, ia);\n         /* determine number of non-zero non-diagonal elements in ia-th\n          * row of U~ */\n         len = 0;\n         for (ja = ia+1; ja <= na; ja++)\n         {  if (a(ia, ja) != 0.0)\n               len++;\n         }\n         /* reserve len locations for i-th row of matrix V in left\n          * (dynamic) part of SVA */\n         if (vr_cap[i] < len)\n         {  /* there should be enough room in free part of SVA */\n            xassert(sva->r_ptr - sva->m_ptr >= len);\n            sva_enlarge_cap(sva, vr_ref-1+i, len, 0);\n            /* left part of SVA should not overlap matrix A~ */\n            xassert(sva->m_ptr <= a_ptr);\n         }\n         /* copy non-zero non-diaginal elements of ia-th row of U~ to\n          * i-th row of V */\n         ptr = vr_ptr[i];\n         for (ja = ia+1; ja <= na; ja++)\n         {  if (a(ia, ja) != 0.0)\n            {  sv_ind[ptr] = qq_ind[k-1+ja];\n               sv_val[ptr] = a(ia, ja);\n               ptr++;\n            }\n         }\n         xassert(ptr - vr_ptr[i] == len);\n         vr_len[i] = len;\n      }\n      /* build new columns of F from columns of L~ */\n      for (ja = 1; ja <= na; ja++)\n      {  /* ja-th column of L~ = (k-1+ja)-th column of L = j-th column\n          * of F */\n         j = pp_inv[k-1+ja];\n         xassert(fc_len[j] == 0);\n         xassert(fc_cap[j] == 0);\n         /* determine number of non-zero non-diagonal elements in ja-th\n          * column of L~ */\n         len = 0;\n         for (ia = ja+1; ia <= na; ia++)\n         {  if (a(ia, ja) != 0.0)\n               len++;\n         }\n         /* reserve len locations for j-th column of matrix F in right\n          * (static) part of SVA */\n         /* there should be enough room in free part of SVA */\n         xassert(sva->r_ptr - sva->m_ptr >= len);\n         if (len > 0)\n            sva_reserve_cap(sva, fc_ref-1+j, len);\n         /* right part of SVA should not overlap matrix A~ */\n         xassert(a_end <= sva->r_ptr);\n         /* copy non-zero non-diagonal elements of ja-th column of L~\n          * to j-th column of F */\n         ptr = fc_ptr[j];\n         for (ia = ja+1; ia <= na; ia++)\n         {  if (a(ia, ja) != 0.0)\n            {  sv_ind[ptr] = pp_inv[k-1+ia];\n               sv_val[ptr] = a(ia, ja);\n               ptr++;\n            }\n         }\n         xassert(ptr - fc_ptr[j] == len);\n         fc_len[j] = len;\n      }\n      /* factors L~ and U~ are no longer needed */\n#     undef a\n      /* if it is not planned to update matrix V, relocate all its new\n       * rows to the right (static) part of SVA */\n      if (!updat)\n      {  for (ia = 1; ia <= na; ia++)\n         {  i = pp_inv[k-1+ia];\n            len = vr_len[i];\n            if (sva->r_ptr - sva->m_ptr < len)\n            {  sva_more_space(sva, len);\n               sv_ind = sva->ind;\n               sv_val = sva->val;\n            }\n            sva_make_static(sva, vr_ref-1+i);\n         }\n      }\n      return 0;\n}",
      "lines": 180,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "sgf_factorize": {
      "start_point": [
        1304,
        0
      ],
      "end_point": [
        1440,
        1
      ],
      "content": "int sgf_factorize(SGF *sgf, int singl)\n{     LUF *luf = sgf->luf;\n      int n = luf->n;\n      SVA *sva = luf->sva;\n      int vr_ref = luf->vr_ref;\n      int *vr_len = &sva->len[vr_ref-1];\n      double *vr_piv = luf->vr_piv;\n      int vc_ref = luf->vc_ref;\n      int *vc_len = &sva->len[vc_ref-1];\n      int *pp_ind = luf->pp_ind;\n      int *pp_inv = luf->pp_inv;\n      int *qq_ind = luf->qq_ind;\n      int *qq_inv = luf->qq_inv;\n      int *rs_head = sgf->rs_head;\n      int *rs_prev = sgf->rs_prev;\n      int *rs_next = sgf->rs_next;\n      int *cs_head = sgf->cs_head;\n      int *cs_prev = sgf->cs_prev;\n      int *cs_next = sgf->cs_next;\n      double *vr_max = sgf->vr_max;\n      char *flag = sgf->flag;\n      double *work = sgf->work;\n      int i, j, k, k1, k2, p, q, nnz;\n      /* build matrix V = A in row-wise format */\n      luf_build_v_rows(luf, rs_prev);\n      /* P := Q := I, so V = U = A, F = L = I */\n      for (k = 1; k <= n; k++)\n      {  vr_piv[k] = 0.0;\n         pp_ind[k] = pp_inv[k] = qq_ind[k] = qq_inv[k] = k;\n      }\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n      luf_check_all(luf, 1);\n#endif\n      /* perform singleton phase, if required */\n      if (!singl)\n      {  /* assume that nucleus is entire matrix U */\n         k2 = 1;\n      }\n      else\n      {  /* minimize nucleus size */\n#if 0 /* 21/II-2016 */\n         sgf_reduce_nuc(luf, &k1, &k2, rs_prev, rs_next);\n#else\n         if (sgf_reduce_nuc(luf, &k1, &k2, rs_prev, rs_next))\n            return -1;\n#endif\n#ifdef GLP_DEBUG\n         xprintf(\"n = %d; k1 = %d; k2 = %d\\n\", n, k1, k2);\n#endif\n         /* perform singleton phase */\n         k2 = sgf_singl_phase(luf, k1, k2, sgf->updat, rs_prev, work);\n      }\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n      luf_check_all(luf, k2);\n#endif\n      /* initialize working arrays */\n      rs_head[0] = cs_head[0] = 0;\n      for (k = 1; k <= n; k++)\n      {  rs_head[k] = cs_head[k] = 0;\n         vr_max[k] = -1.0;\n         flag[k] = 0;\n         work[k] = 0.0;\n      }\n      /* build lists of active rows and columns of matrix V; determine\n       * number of non-zeros in initial active submatrix */\n      nnz = 0;\n      for (k = k2; k <= n; k++)\n      {  i = pp_inv[k];\n         sgf_activate_row(i);\n         nnz += vr_len[i];\n         j = qq_ind[k];\n         sgf_activate_col(j);\n      }\n      /* main factorization loop */\n      for (k = k2; k <= n; k++)\n      {  int na;\n         double den;\n         /* calculate density of active submatrix */\n         na = n - k + 1; /* order of active submatrix */\n#if 0 /* 21/VIII-2014 */\n         den = (double)nnz / (double)(na * na);\n#else\n         den = (double)nnz / ((double)(na) * (double)(na));\n#endif\n         /* if active submatrix is relatively dense, switch to dense\n          * phase */\n#if 1 /* FIXME */\n         if (na >= 5 && den >= 0.71)\n         {\n#ifdef GLP_DEBUG\n            xprintf(\"na = %d; nnz = %d; den = %g\\n\", na, nnz, den);\n#endif\n            break;\n         }\n#endif\n         /* choose pivot v[p,q] */\n         if (sgf_choose_pivot(sgf, &p, &q) != 0)\n            return k; /* failure */\n         /* u[i,j] = v[p,q], k <= i, j <= n */\n         i = pp_ind[p];\n         xassert(k <= i && i <= n);\n         j = qq_inv[q];\n         xassert(k <= j && j <= n);\n         /* move u[i,j] to position u[k,k] by implicit permutations of\n          * rows and columns of matrix U */\n         luf_swap_u_rows(k, i);\n         luf_swap_u_cols(k, j);\n         /* perform gaussian elimination */\n         nnz += sgf_eliminate(sgf, p, q);\n      }\n#if 1 /* FIXME */\n      if (k <= n)\n      {  /* continue computing factorization in dense mode */\n#ifdef GLP_DEBUG\n         sva_check_area(sva);\n         luf_check_all(luf, k);\n#endif\n         k = sgf_dense_phase(luf, k, sgf->updat);\n         if (k != 0)\n            return k; /* failure */\n      }\n#endif\n#ifdef GLP_DEBUG\n      sva_check_area(sva);\n      luf_check_all(luf, n+1);\n#endif\n      /* defragment SVA; currently all columns of V are empty, so they\n       * will have zero capacity as required by luf_build_v_cols */\n      sva_defrag_area(sva);\n      /* build matrix F in row-wise format */\n      luf_build_f_rows(luf, rs_head);\n      /* build matrix V in column-wise format */\n      luf_build_v_cols(luf, sgf->updat, rs_head);\n      return 0;\n}",
      "lines": 137,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/sgf.h": {},
  "glpk/glpk-4.65/src/bflib/sva.c": {
    "sva_create_area": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "SVA *sva_create_area(int n_max, int size)\n{     SVA *sva;\n      xassert(0 < n_max && n_max < INT_MAX);\n      xassert(0 < size && size < INT_MAX);\n      sva = talloc(1, SVA);\n      sva->n_max = n_max;\n      sva->n = 0;\n      sva->ptr = talloc(1+n_max, int);\n      sva->len = talloc(1+n_max, int);\n      sva->cap = talloc(1+n_max, int);\n      sva->size = size;\n      sva->m_ptr = 1;\n      sva->r_ptr = size+1;\n      sva->head = sva->tail = 0;\n      sva->prev = talloc(1+n_max, int);\n      sva->next = talloc(1+n_max, int);\n      sva->ind = talloc(1+size, int);\n      sva->val = talloc(1+size, double);\n      sva->talky = 0;\n      return sva;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "SVA",
        "*sva_create_area(int n_max, int size)",
        "*"
      ]
    },
    "sva_alloc_vecs": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int sva_alloc_vecs(SVA *sva, int nnn)\n{     int n = sva->n;\n      int n_max = sva->n_max;\n      int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      int *prev = sva->prev;\n      int *next = sva->next;\n      int k, new_n;\n#if 1\n      if (sva->talky)\n         xprintf(\"sva_alloc_vecs: nnn = %d\\n\", nnn);\n#endif\n      xassert(nnn > 0);\n      /* determine new number of vectors in SVA */\n      new_n = n + nnn;\n      xassert(new_n > n);\n      if (n_max < new_n)\n      {  /* enlarge the SVA arrays */\n         while (n_max < new_n)\n         {  n_max += n_max;\n            xassert(n_max > 0);\n         }\n         sva->n_max = n_max;\n         sva->ptr = ptr = trealloc(ptr, 1+n_max, int);\n         sva->len = len = trealloc(len, 1+n_max, int);\n         sva->cap = cap = trealloc(cap, 1+n_max, int);\n         sva->prev = prev = trealloc(prev, 1+n_max, int);\n         sva->next = next = trealloc(next, 1+n_max, int);\n      }\n      /* initialize new vectors */\n      sva->n = new_n;\n      for (k = n+1; k <= new_n; k++)\n      {  ptr[k] = len[k] = cap[k] = 0;\n         prev[k] = next[k] = -1;\n      }\n#if 1\n      if (sva->talky)\n         xprintf(\"now sva->n_max = %d, sva->n = %d\\n\",\n            sva->n_max, sva->n);\n#endif\n      /* return reference number of very first new vector */\n      return n+1;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sva_resize_area": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void sva_resize_area(SVA *sva, int delta)\n{     int n = sva->n;\n      int *ptr = sva->ptr;\n      int size = sva->size;\n      int m_ptr = sva->m_ptr;\n      int r_ptr = sva->r_ptr;\n      int k, r_size;\n#if 1\n      if (sva->talky)\n         xprintf(\"sva_resize_area: delta = %d\\n\", delta);\n#endif\n      xassert(delta != 0);\n      /* determine size of the right part, in locations */\n      r_size = size - r_ptr + 1;\n      /* relocate the right part in case of negative delta */\n      if (delta < 0)\n      {  xassert(delta >= m_ptr - r_ptr);\n         sva->r_ptr += delta;\n         memmove(&sva->ind[sva->r_ptr], &sva->ind[r_ptr],\n            r_size * sizeof(int));\n         memmove(&sva->val[sva->r_ptr], &sva->val[r_ptr],\n            r_size * sizeof(double));\n      }\n      /* reallocate the storage arrays */\n      xassert(delta < INT_MAX - sva->size);\n      sva->size += delta;\n      sva->ind = trealloc(sva->ind, 1+sva->size, int);\n      sva->val = trealloc(sva->val, 1+sva->size, double);\n      /* relocate the right part in case of positive delta */\n      if (delta > 0)\n      {  sva->r_ptr += delta;\n         memmove(&sva->ind[sva->r_ptr], &sva->ind[r_ptr],\n            r_size * sizeof(int));\n         memmove(&sva->val[sva->r_ptr], &sva->val[r_ptr],\n            r_size * sizeof(double));\n      }\n      /* update pointers to vectors stored in the right part */\n      for (k = 1; k <= n; k++)\n      {  if (ptr[k] >= r_ptr)\n            ptr[k] += delta;\n      }\n#if 1\n      if (sva->talky)\n         xprintf(\"now sva->size = %d\\n\", sva->size);\n#endif\n      return;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "sva_defrag_area": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void sva_defrag_area(SVA *sva)\n{     int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      int *prev = sva->prev;\n      int *next = sva->next;\n      int *ind = sva->ind;\n      double *val = sva->val;\n      int k, next_k, ptr_k, len_k, m_ptr, head, tail;\n#if 1\n      if (sva->talky)\n      {  xprintf(\"sva_defrag_area:\\n\");\n         xprintf(\"before defragmenting = %d %d %d\\n\", sva->m_ptr - 1,\n            sva->r_ptr - sva->m_ptr, sva->size + 1 - sva->r_ptr);\n      }\n#endif\n      m_ptr = 1;\n      head = tail = 0;\n      /* walk through the linked list of vectors stored in the left\n       * part of SVA */\n      for (k = sva->head; k != 0; k = next_k)\n      {  /* save number of next vector in the list */\n         next_k = next[k];\n         /* determine length of k-th vector */\n         len_k = len[k];\n         if (len_k == 0)\n         {  /* k-th vector is empty; remove it from the left part */\n            ptr[k] = cap[k] = 0;\n            prev[k] = next[k] = -1;\n         }\n         else\n         {  /* determine pointer to first location of k-th vector */\n            ptr_k = ptr[k];\n            xassert(m_ptr <= ptr_k);\n            /* relocate k-th vector to the beginning of the left part,\n             * if necessary */\n            if (m_ptr < ptr_k)\n            {  memmove(&ind[m_ptr], &ind[ptr_k],\n                  len_k * sizeof(int));\n               memmove(&val[m_ptr], &val[ptr_k],\n                  len_k * sizeof(double));\n               ptr[k] = m_ptr;\n            }\n            /* remove unused locations from k-th vector */\n            cap[k] = len_k;\n            /* the left part of SVA has been enlarged */\n            m_ptr += len_k;\n            /* add k-th vector to the end of the new linked list */\n            prev[k] = tail;\n            next[k] = 0;\n            if (head == 0)\n               head = k;\n            else\n               next[tail] = k;\n            tail = k;\n         }\n      }\n      /* set new pointer to the middle part of SVA */\n      xassert(m_ptr <= sva->r_ptr);\n      sva->m_ptr = m_ptr;\n      /* set new head and tail of the linked list */\n      sva->head = head;\n      sva->tail = tail;\n#if 1\n      if (sva->talky)\n         xprintf(\"after defragmenting = %d %d %d\\n\", sva->m_ptr - 1,\n            sva->r_ptr - sva->m_ptr, sva->size + 1 - sva->r_ptr);\n#endif\n      return;\n}",
      "lines": 70,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "sva_more_space": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "void sva_more_space(SVA *sva, int m_size)\n{     int size, delta;\n#if 1\n      if (sva->talky)\n         xprintf(\"sva_more_space: m_size = %d\\n\", m_size);\n#endif\n      xassert(m_size > sva->r_ptr - sva->m_ptr);\n      /* defragment the left part */\n      sva_defrag_area(sva);\n      /* set, heuristically, the minimal size of the middle part to be\n       * not less than the size of the defragmented left part */\n      if (m_size < sva->m_ptr - 1)\n         m_size = sva->m_ptr - 1;\n      /* if there is still not enough room, increase the total size of\n       * the SVA storage */\n      if (sva->r_ptr - sva->m_ptr < m_size)\n      {  size = sva->size; /* new sva size */\n         for (;;)\n         {  delta = size - sva->size;\n            if (sva->r_ptr - sva->m_ptr + delta >= m_size)\n               break;\n            size += size;\n            xassert(size > 0);\n         }\n         sva_resize_area(sva, delta);\n         xassert(sva->r_ptr - sva->m_ptr >= m_size);\n      }\n      return;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "sva_enlarge_cap": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void sva_enlarge_cap(SVA *sva, int k, int new_cap, int skip)\n{     int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      int *prev = sva->prev;\n      int *next = sva->next;\n      int *ind = sva->ind;\n      double *val = sva->val;\n      xassert(1 <= k && k <= sva->n);\n      xassert(new_cap > cap[k]);\n      /* there should be at least new_cap free locations */\n      xassert(sva->r_ptr - sva->m_ptr >= new_cap);\n      /* relocate the vector */\n      if (cap[k] == 0)\n      {  /* the vector is empty */\n         xassert(ptr[k] == 0);\n         xassert(len[k] == 0);\n      }\n      else\n      {  /* the vector has non-zero capacity */\n         xassert(ptr[k] + len[k] <= sva->m_ptr);\n         /* copy the current vector content to the beginning of the\n          * middle part */\n         if (len[k] > 0)\n         {  memcpy(&ind[sva->m_ptr], &ind[ptr[k]],\n               len[k] * sizeof(int));\n            if (!skip)\n               memcpy(&val[sva->m_ptr], &val[ptr[k]],\n                  len[k] * sizeof(double));\n         }\n         /* remove the vector from the linked list */\n         if (prev[k] == 0)\n            sva->head = next[k];\n         else\n         {  /* preceding vector exists; increase its capacity */\n            cap[prev[k]] += cap[k];\n            next[prev[k]] = next[k];\n         }\n         if (next[k] == 0)\n            sva->tail = prev[k];\n         else\n            prev[next[k]] = prev[k];\n      }\n      /* set new pointer and capacity of the vector */\n      ptr[k] = sva->m_ptr;\n      cap[k] = new_cap;\n      /* add the vector to the end of the linked list */\n      prev[k] = sva->tail;\n      next[k] = 0;\n      if (sva->head == 0)\n         sva->head = k;\n      else\n         next[sva->tail] = k;\n      sva->tail = k;\n      /* new_cap free locations have been consumed */\n      sva->m_ptr += new_cap;\n      xassert(sva->m_ptr <= sva->r_ptr);\n      return;\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sva_reserve_cap": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void sva_reserve_cap(SVA *sva, int k, int new_cap)\n{     int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      xassert(1 <= k && k <= sva->n);\n      xassert(new_cap > 0);\n      xassert(ptr[k] == 0 && len[k] == 0 && cap[k] == 0);\n      /* there should be at least new_cap free locations */\n      xassert(sva->r_ptr - sva->m_ptr >= new_cap);\n      /* set the pointer and capacity of the vector */\n      ptr[k] = sva->r_ptr - new_cap;\n      cap[k] = new_cap;\n      /* new_cap free locations have been consumed */\n      sva->r_ptr -= new_cap;\n      return;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sva_make_static": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "void sva_make_static(SVA *sva, int k)\n{     int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      int *prev = sva->prev;\n      int *next = sva->next;\n      int *ind = sva->ind;\n      double *val = sva->val;\n      int ptr_k, len_k;\n      xassert(1 <= k && k <= sva->n);\n      /* if the vector has zero capacity, do nothing */\n      if (cap[k] == 0)\n      {  xassert(ptr[k] == 0);\n         xassert(len[k] == 0);\n         goto done;\n      }\n      /* there should be at least len[k] free locations */\n      len_k = len[k];\n      xassert(sva->r_ptr - sva->m_ptr >= len_k);\n      /* remove the vector from the linked list */\n      if (prev[k] == 0)\n         sva->head = next[k];\n      else\n      {  /* preceding vector exists; increase its capacity */\n         cap[prev[k]] += cap[k];\n         next[prev[k]] = next[k];\n      }\n      if (next[k] == 0)\n         sva->tail = prev[k];\n      else\n         prev[next[k]] = prev[k];\n      /* if the vector has zero length, make it empty */\n      if (len_k == 0)\n      {  ptr[k] = cap[k] = 0;\n         goto done;\n      }\n      /* copy the vector content to the beginning of the right part */\n      ptr_k = sva->r_ptr - len_k;\n      memcpy(&ind[ptr_k], &ind[ptr[k]], len_k * sizeof(int));\n      memcpy(&val[ptr_k], &val[ptr[k]], len_k * sizeof(double));\n      /* set new pointer and capacity of the vector */\n      ptr[k] = ptr_k;\n      cap[k] = len_k;\n      /* len[k] free locations have been consumed */\n      sva->r_ptr -= len_k;\ndone: return;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sva_check_area": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "void sva_check_area(SVA *sva)\n{     int n_max = sva->n_max;\n      int n = sva->n;\n      int *ptr = sva->ptr;\n      int *len = sva->len;\n      int *cap = sva->cap;\n      int size = sva->size;\n      int m_ptr = sva->m_ptr;\n      int r_ptr = sva->r_ptr;\n      int head = sva->head;\n      int tail = sva->tail;\n      int *prev = sva->prev;\n      int *next = sva->next;\n      int k;\n#if 0 /* 16/II-2004; SVA may be empty */\n      xassert(1 <= n && n <= n_max);\n#else\n      xassert(0 <= n && n <= n_max);\n#endif\n      xassert(1 <= m_ptr && m_ptr <= r_ptr && r_ptr <= size+1);\n      /* all vectors included the linked list should have non-zero\n       * capacity and be stored in the left part */\n      for (k = head; k != 0; k = next[k])\n      {  xassert(1 <= k && k <= n);\n         xassert(cap[k] > 0);\n         xassert(0 <= len[k] && len[k] <= cap[k]);\n         if (prev[k] == 0)\n            xassert(k == head);\n         else\n         {  xassert(1 <= prev[k] && prev[k] <= n);\n            xassert(next[prev[k]] == k);\n         }\n         if (next[k] == 0)\n         {  xassert(k == tail);\n            xassert(ptr[k] + cap[k] <= m_ptr);\n         }\n         else\n         {  xassert(1 <= next[k] && next[k] <= n);\n            xassert(prev[next[k]] == k);\n            xassert(ptr[k] + cap[k] <= ptr[next[k]]);\n         }\n         cap[k] = -cap[k];\n      }\n      /* all other vectors should either have zero capacity or be\n       * stored in the right part */\n      for (k = 1; k <= n; k++)\n      {  if (cap[k] < 0)\n         {  /* k-th vector is stored in the left part */\n            cap[k] = -cap[k];\n         }\n         else if (cap[k] == 0)\n         {  /* k-th vector has zero capacity */\n            xassert(ptr[k] == 0);\n            xassert(len[k] == 0);\n         }\n         else /* cap[k] > 0 */\n         {  /* k-th vector is stored in the right part */\n            xassert(0 <= len[k] && len[k] <= cap[k]);\n            xassert(r_ptr <= ptr[k] && ptr[k] + cap[k] <= size+1);\n         }\n      }\n      return;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "sva_delete_area": {
      "start_point": [
        559,
        0
      ],
      "end_point": [
        569,
        1
      ],
      "content": "void sva_delete_area(SVA *sva)\n{     tfree(sva->ptr);\n      tfree(sva->len);\n      tfree(sva->cap);\n      tfree(sva->prev);\n      tfree(sva->next);\n      tfree(sva->ind);\n      tfree(sva->val);\n      tfree(sva);\n      return;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/bflib/sva.h": {},
  "glpk/glpk-4.65/src/colamd/colamd.c": {
    "t_add": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "static size_t t_add (size_t a, size_t b, int *ok)\n{\n    (*ok) = (*ok) && ((a + b) >= MAX (a,b)) ;\n    return ((*ok) ? (a + b) : 0) ;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "t_mult": {
      "start_point": [
        1057,
        0
      ],
      "end_point": [
        1065,
        1
      ],
      "content": "static size_t t_mult (size_t a, size_t k, int *ok)\n{\n    size_t i, s = 0 ;\n    for (i = 0 ; i < k ; i++)\n    {\n        s = t_add (s, a, ok) ;\n    }\n    return (s) ;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "COLAMD_recommended": {
      "start_point": [
        1075,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "PUBLIC size_t COLAMD_recommended        /* returns recommended value of Alen. */\n(\n    /* === Parameters ======================================================= */\n\n    Int nnz,                    /* number of nonzeros in A */\n    Int n_row,                  /* number of rows in A */\n    Int n_col                   /* number of columns in A */\n)\n{\n    size_t s, c, r ;\n    int ok = TRUE ;\n    if (nnz < 0 || n_row < 0 || n_col < 0)\n    {\n        return (0) ;\n    }\n    s = t_mult (nnz, 2, &ok) ;      /* 2*nnz */\n    c = COLAMD_C (n_col, &ok) ;     /* size of column structures */\n    r = COLAMD_R (n_row, &ok) ;     /* size of row structures */\n    s = t_add (s, c, &ok) ;\n    s = t_add (s, r, &ok) ;\n    s = t_add (s, n_col, &ok) ;     /* elbow room */\n    s = t_add (s, nnz/5, &ok) ;     /* elbow room */\n    ok = ok && (s < Int_MAX) ;\n    return (ok ? s : 0) ;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "PUBLIC",
        "size_t",
        "size_t"
      ]
    },
    "COLAMD_set_defaults": {
      "start_point": [
        1129,
        0
      ],
      "end_point": [
        1151,
        1
      ],
      "content": "PUBLIC void COLAMD_set_defaults\n(\n    /* === Parameters ======================================================= */\n\n    double knobs [COLAMD_KNOBS]         /* knob array */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int i ;\n\n    if (!knobs)\n    {\n        return ;                        /* no knobs to initialize */\n    }\n    for (i = 0 ; i < COLAMD_KNOBS ; i++)\n    {\n        knobs [i] = 0 ;\n    }\n    knobs [COLAMD_DENSE_ROW] = 10 ;\n    knobs [COLAMD_DENSE_COL] = 10 ;\n    knobs [COLAMD_AGGRESSIVE] = TRUE ;  /* default: do aggressive absorption*/\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "PUBLIC",
        "void",
        "void"
      ]
    },
    "SYMAMD_MAIN": {
      "start_point": [
        1158,
        0
      ],
      "end_point": [
        1464,
        1
      ],
      "content": "PUBLIC Int SYMAMD_MAIN                  /* return TRUE if OK, FALSE otherwise */\n(\n    /* === Parameters ======================================================= */\n\n    Int n,                              /* number of rows and columns of A */\n    Int A [],                           /* row indices of A */\n    Int p [],                           /* column pointers of A */\n    Int perm [],                        /* output permutation, size n+1 */\n    double knobs [COLAMD_KNOBS],        /* parameters (uses defaults if NULL) */\n    Int stats [COLAMD_STATS],           /* output statistics and error codes */\n    void * (*allocate) (size_t, size_t),\n                                        /* pointer to calloc (ANSI C) or */\n                                        /* mxCalloc (for MATLAB mexFunction) */\n    void (*release) (void *)\n                                        /* pointer to free (ANSI C) or */\n                                        /* mxFree (for MATLAB mexFunction) */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int *count ;                /* length of each column of M, and col pointer*/\n    Int *mark ;                 /* mark array for finding duplicate entries */\n    Int *M ;                    /* row indices of matrix M */\n    size_t Mlen ;               /* length of M */\n    Int n_row ;                 /* number of rows in M */\n    Int nnz ;                   /* number of entries in A */\n    Int i ;                     /* row index of A */\n    Int j ;                     /* column index of A */\n    Int k ;                     /* row index of M */\n    Int mnz ;                   /* number of nonzeros in M */\n    Int pp ;                    /* index into a column of A */\n    Int last_row ;              /* last row seen in the current column */\n    Int length ;                /* number of nonzeros in a column */\n\n    double cknobs [COLAMD_KNOBS] ;              /* knobs for colamd */\n    double default_knobs [COLAMD_KNOBS] ;       /* default knobs for colamd */\n\n#ifndef NDEBUG\n    colamd_get_debug (\"symamd\") ;\n#endif /* NDEBUG */\n\n    /* === Check the input arguments ======================================== */\n\n    if (!stats)\n    {\n        DEBUG0 ((\"symamd: stats not present\\n\")) ;\n        return (FALSE) ;\n    }\n    for (i = 0 ; i < COLAMD_STATS ; i++)\n    {\n        stats [i] = 0 ;\n    }\n    stats [COLAMD_STATUS] = COLAMD_OK ;\n    stats [COLAMD_INFO1] = -1 ;\n    stats [COLAMD_INFO2] = -1 ;\n\n    if (!A)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_A_not_present ;\n        DEBUG0 ((\"symamd: A not present\\n\")) ;\n        return (FALSE) ;\n    }\n\n    if (!p)             /* p is not present */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_p_not_present ;\n        DEBUG0 ((\"symamd: p not present\\n\")) ;\n        return (FALSE) ;\n    }\n\n    if (n < 0)          /* n must be >= 0 */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_ncol_negative ;\n        stats [COLAMD_INFO1] = n ;\n        DEBUG0 ((\"symamd: n negative %d\\n\", n)) ;\n        return (FALSE) ;\n    }\n\n    nnz = p [n] ;\n    if (nnz < 0)        /* nnz must be >= 0 */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_nnz_negative ;\n        stats [COLAMD_INFO1] = nnz ;\n        DEBUG0 ((\"symamd: number of entries negative %d\\n\", nnz)) ;\n        return (FALSE) ;\n    }\n\n    if (p [0] != 0)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_p0_nonzero ;\n        stats [COLAMD_INFO1] = p [0] ;\n        DEBUG0 ((\"symamd: p[0] not zero %d\\n\", p [0])) ;\n        return (FALSE) ;\n    }\n\n    /* === If no knobs, set default knobs =================================== */\n\n    if (!knobs)\n    {\n        COLAMD_set_defaults (default_knobs) ;\n        knobs = default_knobs ;\n    }\n\n    /* === Allocate count and mark ========================================== */\n\n    count = (Int *) ((*allocate) (n+1, sizeof (Int))) ;\n    if (!count)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;\n        DEBUG0 ((\"symamd: allocate count (size %d) failed\\n\", n+1)) ;\n        return (FALSE) ;\n    }\n\n    mark = (Int *) ((*allocate) (n+1, sizeof (Int))) ;\n    if (!mark)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;\n        (*release) ((void *) count) ;\n        DEBUG0 ((\"symamd: allocate mark (size %d) failed\\n\", n+1)) ;\n        return (FALSE) ;\n    }\n\n    /* === Compute column counts of M, check if A is valid ================== */\n\n    stats [COLAMD_INFO3] = 0 ;  /* number of duplicate or unsorted row indices*/\n\n    for (i = 0 ; i < n ; i++)\n    {\n        mark [i] = -1 ;\n    }\n\n    for (j = 0 ; j < n ; j++)\n    {\n        last_row = -1 ;\n\n        length = p [j+1] - p [j] ;\n        if (length < 0)\n        {\n            /* column pointers must be non-decreasing */\n            stats [COLAMD_STATUS] = COLAMD_ERROR_col_length_negative ;\n            stats [COLAMD_INFO1] = j ;\n            stats [COLAMD_INFO2] = length ;\n            (*release) ((void *) count) ;\n            (*release) ((void *) mark) ;\n            DEBUG0 ((\"symamd: col %d negative length %d\\n\", j, length)) ;\n            return (FALSE) ;\n        }\n\n        for (pp = p [j] ; pp < p [j+1] ; pp++)\n        {\n            i = A [pp] ;\n            if (i < 0 || i >= n)\n            {\n                /* row index i, in column j, is out of bounds */\n                stats [COLAMD_STATUS] = COLAMD_ERROR_row_index_out_of_bounds ;\n                stats [COLAMD_INFO1] = j ;\n                stats [COLAMD_INFO2] = i ;\n                stats [COLAMD_INFO3] = n ;\n                (*release) ((void *) count) ;\n                (*release) ((void *) mark) ;\n                DEBUG0 ((\"symamd: row %d col %d out of bounds\\n\", i, j)) ;\n                return (FALSE) ;\n            }\n\n            if (i <= last_row || mark [i] == j)\n            {\n                /* row index is unsorted or repeated (or both), thus col */\n                /* is jumbled.  This is a notice, not an error condition. */\n                stats [COLAMD_STATUS] = COLAMD_OK_BUT_JUMBLED ;\n                stats [COLAMD_INFO1] = j ;\n                stats [COLAMD_INFO2] = i ;\n                (stats [COLAMD_INFO3]) ++ ;\n                DEBUG1 ((\"symamd: row %d col %d unsorted/duplicate\\n\", i, j)) ;\n            }\n\n            if (i > j && mark [i] != j)\n            {\n                /* row k of M will contain column indices i and j */\n                count [i]++ ;\n                count [j]++ ;\n            }\n\n            /* mark the row as having been seen in this column */\n            mark [i] = j ;\n\n            last_row = i ;\n        }\n    }\n\n    /* v2.4: removed free(mark) */\n\n    /* === Compute column pointers of M ===================================== */\n\n    /* use output permutation, perm, for column pointers of M */\n    perm [0] = 0 ;\n    for (j = 1 ; j <= n ; j++)\n    {\n        perm [j] = perm [j-1] + count [j-1] ;\n    }\n    for (j = 0 ; j < n ; j++)\n    {\n        count [j] = perm [j] ;\n    }\n\n    /* === Construct M ====================================================== */\n\n    mnz = perm [n] ;\n    n_row = mnz / 2 ;\n    Mlen = COLAMD_recommended (mnz, n_row, n) ;\n    M = (Int *) ((*allocate) (Mlen, sizeof (Int))) ;\n    DEBUG0 ((\"symamd: M is %d-by-%d with %d entries, Mlen = %g\\n\",\n        n_row, n, mnz, (double) Mlen)) ;\n\n    if (!M)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_out_of_memory ;\n        (*release) ((void *) count) ;\n        (*release) ((void *) mark) ;\n        DEBUG0 ((\"symamd: allocate M (size %g) failed\\n\", (double) Mlen)) ;\n        return (FALSE) ;\n    }\n\n    k = 0 ;\n\n    if (stats [COLAMD_STATUS] == COLAMD_OK)\n    {\n        /* Matrix is OK */\n        for (j = 0 ; j < n ; j++)\n        {\n            ASSERT (p [j+1] - p [j] >= 0) ;\n            for (pp = p [j] ; pp < p [j+1] ; pp++)\n            {\n                i = A [pp] ;\n                ASSERT (i >= 0 && i < n) ;\n                if (i > j)\n                {\n                    /* row k of M contains column indices i and j */\n                    M [count [i]++] = k ;\n                    M [count [j]++] = k ;\n                    k++ ;\n                }\n            }\n        }\n    }\n    else\n    {\n        /* Matrix is jumbled.  Do not add duplicates to M.  Unsorted cols OK. */\n        DEBUG0 ((\"symamd: Duplicates in A.\\n\")) ;\n        for (i = 0 ; i < n ; i++)\n        {\n            mark [i] = -1 ;\n        }\n        for (j = 0 ; j < n ; j++)\n        {\n            ASSERT (p [j+1] - p [j] >= 0) ;\n            for (pp = p [j] ; pp < p [j+1] ; pp++)\n            {\n                i = A [pp] ;\n                ASSERT (i >= 0 && i < n) ;\n                if (i > j && mark [i] != j)\n                {\n                    /* row k of M contains column indices i and j */\n                    M [count [i]++] = k ;\n                    M [count [j]++] = k ;\n                    k++ ;\n                    mark [i] = j ;\n                }\n            }\n        }\n        /* v2.4: free(mark) moved below */\n    }\n\n    /* count and mark no longer needed */\n    (*release) ((void *) count) ;\n    (*release) ((void *) mark) ;        /* v2.4: free (mark) moved here */\n    ASSERT (k == n_row) ;\n\n    /* === Adjust the knobs for M =========================================== */\n\n    for (i = 0 ; i < COLAMD_KNOBS ; i++)\n    {\n        cknobs [i] = knobs [i] ;\n    }\n\n    /* there are no dense rows in M */\n    cknobs [COLAMD_DENSE_ROW] = -1 ;\n    cknobs [COLAMD_DENSE_COL] = knobs [COLAMD_DENSE_ROW] ;\n\n    /* === Order the columns of M =========================================== */\n\n    /* v2.4: colamd cannot fail here, so the error check is removed */\n    (void) COLAMD_MAIN (n_row, n, (Int) Mlen, M, perm, cknobs, stats) ;\n\n    /* Note that the output permutation is now in perm */\n\n    /* === get the statistics for symamd from colamd ======================== */\n\n    /* a dense column in colamd means a dense row and col in symamd */\n    stats [COLAMD_DENSE_ROW] = stats [COLAMD_DENSE_COL] ;\n\n    /* === Free M =========================================================== */\n\n    (*release) ((void *) M) ;\n    DEBUG0 ((\"symamd: done.\\n\")) ;\n    return (TRUE) ;\n\n}",
      "lines": 307,
      "depth": 16,
      "decorators": [
        "PUBLIC",
        "Int",
        "Int"
      ]
    },
    "COLAMD_MAIN": {
      "start_point": [
        1478,
        0
      ],
      "end_point": [
        1640,
        1
      ],
      "content": "PUBLIC Int COLAMD_MAIN          /* returns TRUE if successful, FALSE otherwise*/\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,                  /* number of rows in A */\n    Int n_col,                  /* number of columns in A */\n    Int Alen,                   /* length of A */\n    Int A [],                   /* row indices of A */\n    Int p [],                   /* pointers to columns in A */\n    double knobs [COLAMD_KNOBS],/* parameters (uses defaults if NULL) */\n    Int stats [COLAMD_STATS]    /* output statistics and error codes */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int i ;                     /* loop index */\n    Int nnz ;                   /* nonzeros in A */\n    size_t Row_size ;           /* size of Row [], in integers */\n    size_t Col_size ;           /* size of Col [], in integers */\n    size_t need ;               /* minimum required length of A */\n    Colamd_Row *Row ;           /* pointer into A of Row [0..n_row] array */\n    Colamd_Col *Col ;           /* pointer into A of Col [0..n_col] array */\n    Int n_col2 ;                /* number of non-dense, non-empty columns */\n    Int n_row2 ;                /* number of non-dense, non-empty rows */\n    Int ngarbage ;              /* number of garbage collections performed */\n    Int max_deg ;               /* maximum row degree */\n    double default_knobs [COLAMD_KNOBS] ;       /* default knobs array */\n    Int aggressive ;            /* do aggressive absorption */\n    int ok ;\n\n#ifndef NDEBUG\n    colamd_get_debug (\"colamd\") ;\n#endif /* NDEBUG */\n\n    /* === Check the input arguments ======================================== */\n\n    if (!stats)\n    {\n        DEBUG0 ((\"colamd: stats not present\\n\")) ;\n        return (FALSE) ;\n    }\n    for (i = 0 ; i < COLAMD_STATS ; i++)\n    {\n        stats [i] = 0 ;\n    }\n    stats [COLAMD_STATUS] = COLAMD_OK ;\n    stats [COLAMD_INFO1] = -1 ;\n    stats [COLAMD_INFO2] = -1 ;\n\n    if (!A)             /* A is not present */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_A_not_present ;\n        DEBUG0 ((\"colamd: A not present\\n\")) ;\n        return (FALSE) ;\n    }\n\n    if (!p)             /* p is not present */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_p_not_present ;\n        DEBUG0 ((\"colamd: p not present\\n\")) ;\n        return (FALSE) ;\n    }\n\n    if (n_row < 0)      /* n_row must be >= 0 */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_nrow_negative ;\n        stats [COLAMD_INFO1] = n_row ;\n        DEBUG0 ((\"colamd: nrow negative %d\\n\", n_row)) ;\n        return (FALSE) ;\n    }\n\n    if (n_col < 0)      /* n_col must be >= 0 */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_ncol_negative ;\n        stats [COLAMD_INFO1] = n_col ;\n        DEBUG0 ((\"colamd: ncol negative %d\\n\", n_col)) ;\n        return (FALSE) ;\n    }\n\n    nnz = p [n_col] ;\n    if (nnz < 0)        /* nnz must be >= 0 */\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_nnz_negative ;\n        stats [COLAMD_INFO1] = nnz ;\n        DEBUG0 ((\"colamd: number of entries negative %d\\n\", nnz)) ;\n        return (FALSE) ;\n    }\n\n    if (p [0] != 0)\n    {\n        stats [COLAMD_STATUS] = COLAMD_ERROR_p0_nonzero ;\n        stats [COLAMD_INFO1] = p [0] ;\n        DEBUG0 ((\"colamd: p[0] not zero %d\\n\", p [0])) ;\n        return (FALSE) ;\n    }\n\n    /* === If no knobs, set default knobs =================================== */\n\n    if (!knobs)\n    {\n        COLAMD_set_defaults (default_knobs) ;\n        knobs = default_knobs ;\n    }\n\n    aggressive = (knobs [COLAMD_AGGRESSIVE] != FALSE) ;\n\n    /* === Allocate the Row and Col arrays from array A ===================== */\n\n    ok = TRUE ;\n    Col_size = COLAMD_C (n_col, &ok) ;      /* size of Col array of structs */\n    Row_size = COLAMD_R (n_row, &ok) ;      /* size of Row array of structs */\n\n    /* need = 2*nnz + n_col + Col_size + Row_size ; */\n    need = t_mult (nnz, 2, &ok) ;\n    need = t_add (need, n_col, &ok) ;\n    need = t_add (need, Col_size, &ok) ;\n    need = t_add (need, Row_size, &ok) ;\n\n    if (!ok || need > (size_t) Alen || need > Int_MAX)\n    {\n        /* not enough space in array A to perform the ordering */\n        stats [COLAMD_STATUS] = COLAMD_ERROR_A_too_small ;\n        stats [COLAMD_INFO1] = need ;\n        stats [COLAMD_INFO2] = Alen ;\n        DEBUG0 ((\"colamd: Need Alen >= %d, given only Alen = %d\\n\", need,Alen));\n        return (FALSE) ;\n    }\n\n    Alen -= Col_size + Row_size ;\n    Col = (Colamd_Col *) &A [Alen] ;\n    Row = (Colamd_Row *) &A [Alen + Col_size] ;\n\n    /* === Construct the row and column data structures ===================== */\n\n    if (!init_rows_cols (n_row, n_col, Row, Col, A, p, stats))\n    {\n        /* input matrix is invalid */\n        DEBUG0 ((\"colamd: Matrix invalid\\n\")) ;\n        return (FALSE) ;\n    }\n\n    /* === Initialize scores, kill dense rows/columns ======================= */\n\n    init_scoring (n_row, n_col, Row, Col, A, p, knobs,\n        &n_row2, &n_col2, &max_deg) ;\n\n    /* === Order the supercolumns =========================================== */\n\n    ngarbage = find_ordering (n_row, n_col, Alen, Row, Col, A, p,\n        n_col2, max_deg, 2*nnz, aggressive) ;\n\n    /* === Order the non-principal columns ================================== */\n\n    order_children (n_col, Col, p) ;\n\n    /* === Return statistics in stats ======================================= */\n\n    stats [COLAMD_DENSE_ROW] = n_row - n_row2 ;\n    stats [COLAMD_DENSE_COL] = n_col - n_col2 ;\n    stats [COLAMD_DEFRAG_COUNT] = ngarbage ;\n    DEBUG0 ((\"colamd: done.\\n\")) ;\n    return (TRUE) ;\n}",
      "lines": 163,
      "depth": 11,
      "decorators": [
        "PUBLIC",
        "Int",
        "Int"
      ]
    },
    "COLAMD_report": {
      "start_point": [
        1647,
        0
      ],
      "end_point": [
        1653,
        1
      ],
      "content": "PUBLIC void COLAMD_report\n(\n    Int stats [COLAMD_STATS]\n)\n{\n    print_report (\"colamd\", stats) ;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "PUBLIC",
        "void",
        "void"
      ]
    },
    "SYMAMD_report": {
      "start_point": [
        1660,
        0
      ],
      "end_point": [
        1666,
        1
      ],
      "content": "PUBLIC void SYMAMD_report\n(\n    Int stats [COLAMD_STATS]\n)\n{\n    print_report (\"symamd\", stats) ;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "PUBLIC",
        "void",
        "void"
      ]
    },
    "init_rows_cols": {
      "start_point": [
        1690,
        0
      ],
      "end_point": [
        1915,
        1
      ],
      "content": "PRIVATE Int init_rows_cols      /* returns TRUE if OK, or FALSE otherwise */\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,                  /* number of rows of A */\n    Int n_col,                  /* number of columns of A */\n    Colamd_Row Row [],          /* of size n_row+1 */\n    Colamd_Col Col [],          /* of size n_col+1 */\n    Int A [],                   /* row indices of A, of size Alen */\n    Int p [],                   /* pointers to columns in A, of size n_col+1 */\n    Int stats [COLAMD_STATS]    /* colamd statistics */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int col ;                   /* a column index */\n    Int row ;                   /* a row index */\n    Int *cp ;                   /* a column pointer */\n    Int *cp_end ;               /* a pointer to the end of a column */\n    Int *rp ;                   /* a row pointer */\n    Int *rp_end ;               /* a pointer to the end of a row */\n    Int last_row ;              /* previous row */\n\n    /* === Initialize columns, and check column pointers ==================== */\n\n    for (col = 0 ; col < n_col ; col++)\n    {\n        Col [col].start = p [col] ;\n        Col [col].length = p [col+1] - p [col] ;\n\n        if (Col [col].length < 0)\n        {\n            /* column pointers must be non-decreasing */\n            stats [COLAMD_STATUS] = COLAMD_ERROR_col_length_negative ;\n            stats [COLAMD_INFO1] = col ;\n            stats [COLAMD_INFO2] = Col [col].length ;\n            DEBUG0 ((\"colamd: col %d length %d < 0\\n\", col, Col [col].length)) ;\n            return (FALSE) ;\n        }\n\n        Col [col].shared1.thickness = 1 ;\n        Col [col].shared2.score = 0 ;\n        Col [col].shared3.prev = EMPTY ;\n        Col [col].shared4.degree_next = EMPTY ;\n    }\n\n    /* p [0..n_col] no longer needed, used as \"head\" in subsequent routines */\n\n    /* === Scan columns, compute row degrees, and check row indices ========= */\n\n    stats [COLAMD_INFO3] = 0 ;  /* number of duplicate or unsorted row indices*/\n\n    for (row = 0 ; row < n_row ; row++)\n    {\n        Row [row].length = 0 ;\n        Row [row].shared2.mark = -1 ;\n    }\n\n    for (col = 0 ; col < n_col ; col++)\n    {\n        last_row = -1 ;\n\n        cp = &A [p [col]] ;\n        cp_end = &A [p [col+1]] ;\n\n        while (cp < cp_end)\n        {\n            row = *cp++ ;\n\n            /* make sure row indices within range */\n            if (row < 0 || row >= n_row)\n            {\n                stats [COLAMD_STATUS] = COLAMD_ERROR_row_index_out_of_bounds ;\n                stats [COLAMD_INFO1] = col ;\n                stats [COLAMD_INFO2] = row ;\n                stats [COLAMD_INFO3] = n_row ;\n                DEBUG0 ((\"colamd: row %d col %d out of bounds\\n\", row, col)) ;\n                return (FALSE) ;\n            }\n\n            if (row <= last_row || Row [row].shared2.mark == col)\n            {\n                /* row index are unsorted or repeated (or both), thus col */\n                /* is jumbled.  This is a notice, not an error condition. */\n                stats [COLAMD_STATUS] = COLAMD_OK_BUT_JUMBLED ;\n                stats [COLAMD_INFO1] = col ;\n                stats [COLAMD_INFO2] = row ;\n                (stats [COLAMD_INFO3]) ++ ;\n                DEBUG1 ((\"colamd: row %d col %d unsorted/duplicate\\n\",row,col));\n            }\n\n            if (Row [row].shared2.mark != col)\n            {\n                Row [row].length++ ;\n            }\n            else\n            {\n                /* this is a repeated entry in the column, */\n                /* it will be removed */\n                Col [col].length-- ;\n            }\n\n            /* mark the row as having been seen in this column */\n            Row [row].shared2.mark = col ;\n\n            last_row = row ;\n        }\n    }\n\n    /* === Compute row pointers ============================================= */\n\n    /* row form of the matrix starts directly after the column */\n    /* form of matrix in A */\n    Row [0].start = p [n_col] ;\n    Row [0].shared1.p = Row [0].start ;\n    Row [0].shared2.mark = -1 ;\n    for (row = 1 ; row < n_row ; row++)\n    {\n        Row [row].start = Row [row-1].start + Row [row-1].length ;\n        Row [row].shared1.p = Row [row].start ;\n        Row [row].shared2.mark = -1 ;\n    }\n\n    /* === Create row form ================================================== */\n\n    if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)\n    {\n        /* if cols jumbled, watch for repeated row indices */\n        for (col = 0 ; col < n_col ; col++)\n        {\n            cp = &A [p [col]] ;\n            cp_end = &A [p [col+1]] ;\n            while (cp < cp_end)\n            {\n                row = *cp++ ;\n                if (Row [row].shared2.mark != col)\n                {\n                    A [(Row [row].shared1.p)++] = col ;\n                    Row [row].shared2.mark = col ;\n                }\n            }\n        }\n    }\n    else\n    {\n        /* if cols not jumbled, we don't need the mark (this is faster) */\n        for (col = 0 ; col < n_col ; col++)\n        {\n            cp = &A [p [col]] ;\n            cp_end = &A [p [col+1]] ;\n            while (cp < cp_end)\n            {\n                A [(Row [*cp++].shared1.p)++] = col ;\n            }\n        }\n    }\n\n    /* === Clear the row marks and set row degrees ========================== */\n\n    for (row = 0 ; row < n_row ; row++)\n    {\n        Row [row].shared2.mark = 0 ;\n        Row [row].shared1.degree = Row [row].length ;\n    }\n\n    /* === See if we need to re-create columns ============================== */\n\n    if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)\n    {\n        DEBUG0 ((\"colamd: reconstructing column form, matrix jumbled\\n\")) ;\n\n#ifndef NDEBUG\n        /* make sure column lengths are correct */\n        for (col = 0 ; col < n_col ; col++)\n        {\n            p [col] = Col [col].length ;\n        }\n        for (row = 0 ; row < n_row ; row++)\n        {\n            rp = &A [Row [row].start] ;\n            rp_end = rp + Row [row].length ;\n            while (rp < rp_end)\n            {\n                p [*rp++]-- ;\n            }\n        }\n        for (col = 0 ; col < n_col ; col++)\n        {\n            ASSERT (p [col] == 0) ;\n        }\n        /* now p is all zero (different than when debugging is turned off) */\n#endif /* NDEBUG */\n\n        /* === Compute col pointers ========================================= */\n\n        /* col form of the matrix starts at A [0]. */\n        /* Note, we may have a gap between the col form and the row */\n        /* form if there were duplicate entries, if so, it will be */\n        /* removed upon the first garbage collection */\n        Col [0].start = 0 ;\n        p [0] = Col [0].start ;\n        for (col = 1 ; col < n_col ; col++)\n        {\n            /* note that the lengths here are for pruned columns, i.e. */\n            /* no duplicate row indices will exist for these columns */\n            Col [col].start = Col [col-1].start + Col [col-1].length ;\n            p [col] = Col [col].start ;\n        }\n\n        /* === Re-create col form =========================================== */\n\n        for (row = 0 ; row < n_row ; row++)\n        {\n            rp = &A [Row [row].start] ;\n            rp_end = rp + Row [row].length ;\n            while (rp < rp_end)\n            {\n                A [(p [*rp++])++] = row ;\n            }\n        }\n    }\n\n    /* === Done.  Matrix is not (or no longer) jumbled ====================== */\n\n    return (TRUE) ;\n}",
      "lines": 226,
      "depth": 19,
      "decorators": [
        "PRIVATE",
        "Int",
        "Int"
      ]
    },
    "init_scoring": {
      "start_point": [
        1927,
        0
      ],
      "end_point": [
        2189,
        1
      ],
      "content": "PRIVATE void init_scoring\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,                  /* number of rows of A */\n    Int n_col,                  /* number of columns of A */\n    Colamd_Row Row [],          /* of size n_row+1 */\n    Colamd_Col Col [],          /* of size n_col+1 */\n    Int A [],                   /* column form and row form of A */\n    Int head [],                /* of size n_col+1 */\n    double knobs [COLAMD_KNOBS],/* parameters */\n    Int *p_n_row2,              /* number of non-dense, non-empty rows */\n    Int *p_n_col2,              /* number of non-dense, non-empty columns */\n    Int *p_max_deg              /* maximum row degree */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int c ;                     /* a column index */\n    Int r, row ;                /* a row index */\n    Int *cp ;                   /* a column pointer */\n    Int deg ;                   /* degree of a row or column */\n    Int *cp_end ;               /* a pointer to the end of a column */\n    Int *new_cp ;               /* new column pointer */\n    Int col_length ;            /* length of pruned column */\n    Int score ;                 /* current column score */\n    Int n_col2 ;                /* number of non-dense, non-empty columns */\n    Int n_row2 ;                /* number of non-dense, non-empty rows */\n    Int dense_row_count ;       /* remove rows with more entries than this */\n    Int dense_col_count ;       /* remove cols with more entries than this */\n    Int min_score ;             /* smallest column score */\n    Int max_deg ;               /* maximum row degree */\n    Int next_col ;              /* Used to add to degree list.*/\n\n#ifndef NDEBUG\n    Int debug_count ;           /* debug only. */\n#endif /* NDEBUG */\n\n    /* === Extract knobs ==================================================== */\n\n    /* Note: if knobs contains a NaN, this is undefined: */\n    if (knobs [COLAMD_DENSE_ROW] < 0)\n    {\n        /* only remove completely dense rows */\n        dense_row_count = n_col-1 ;\n    }\n    else\n    {\n        dense_row_count = DENSE_DEGREE (knobs [COLAMD_DENSE_ROW], n_col) ;\n    }\n    if (knobs [COLAMD_DENSE_COL] < 0)\n    {\n        /* only remove completely dense columns */\n        dense_col_count = n_row-1 ;\n    }\n    else\n    {\n        dense_col_count =\n            DENSE_DEGREE (knobs [COLAMD_DENSE_COL], MIN (n_row, n_col)) ;\n    }\n\n    DEBUG1 ((\"colamd: densecount: %d %d\\n\", dense_row_count, dense_col_count)) ;\n    max_deg = 0 ;\n    n_col2 = n_col ;\n    n_row2 = n_row ;\n\n    /* === Kill empty columns =============================================== */\n\n    /* Put the empty columns at the end in their natural order, so that LU */\n    /* factorization can proceed as far as possible. */\n    for (c = n_col-1 ; c >= 0 ; c--)\n    {\n        deg = Col [c].length ;\n        if (deg == 0)\n        {\n            /* this is a empty column, kill and order it last */\n            Col [c].shared2.order = --n_col2 ;\n            KILL_PRINCIPAL_COL (c) ;\n        }\n    }\n    DEBUG1 ((\"colamd: null columns killed: %d\\n\", n_col - n_col2)) ;\n\n    /* === Kill dense columns =============================================== */\n\n    /* Put the dense columns at the end, in their natural order */\n    for (c = n_col-1 ; c >= 0 ; c--)\n    {\n        /* skip any dead columns */\n        if (COL_IS_DEAD (c))\n        {\n            continue ;\n        }\n        deg = Col [c].length ;\n        if (deg > dense_col_count)\n        {\n            /* this is a dense column, kill and order it last */\n            Col [c].shared2.order = --n_col2 ;\n            /* decrement the row degrees */\n            cp = &A [Col [c].start] ;\n            cp_end = cp + Col [c].length ;\n            while (cp < cp_end)\n            {\n                Row [*cp++].shared1.degree-- ;\n            }\n            KILL_PRINCIPAL_COL (c) ;\n        }\n    }\n    DEBUG1 ((\"colamd: Dense and null columns killed: %d\\n\", n_col - n_col2)) ;\n\n    /* === Kill dense and empty rows ======================================== */\n\n    for (r = 0 ; r < n_row ; r++)\n    {\n        deg = Row [r].shared1.degree ;\n        ASSERT (deg >= 0 && deg <= n_col) ;\n        if (deg > dense_row_count || deg == 0)\n        {\n            /* kill a dense or empty row */\n            KILL_ROW (r) ;\n            --n_row2 ;\n        }\n        else\n        {\n            /* keep track of max degree of remaining rows */\n            max_deg = MAX (max_deg, deg) ;\n        }\n    }\n    DEBUG1 ((\"colamd: Dense and null rows killed: %d\\n\", n_row - n_row2)) ;\n\n    /* === Compute initial column scores ==================================== */\n\n    /* At this point the row degrees are accurate.  They reflect the number */\n    /* of \"live\" (non-dense) columns in each row.  No empty rows exist. */\n    /* Some \"live\" columns may contain only dead rows, however.  These are */\n    /* pruned in the code below. */\n\n    /* now find the initial matlab score for each column */\n    for (c = n_col-1 ; c >= 0 ; c--)\n    {\n        /* skip dead column */\n        if (COL_IS_DEAD (c))\n        {\n            continue ;\n        }\n        score = 0 ;\n        cp = &A [Col [c].start] ;\n        new_cp = cp ;\n        cp_end = cp + Col [c].length ;\n        while (cp < cp_end)\n        {\n            /* get a row */\n            row = *cp++ ;\n            /* skip if dead */\n            if (ROW_IS_DEAD (row))\n            {\n                continue ;\n            }\n            /* compact the column */\n            *new_cp++ = row ;\n            /* add row's external degree */\n            score += Row [row].shared1.degree - 1 ;\n            /* guard against integer overflow */\n            score = MIN (score, n_col) ;\n        }\n        /* determine pruned column length */\n        col_length = (Int) (new_cp - &A [Col [c].start]) ;\n        if (col_length == 0)\n        {\n            /* a newly-made null column (all rows in this col are \"dense\" */\n            /* and have already been killed) */\n            DEBUG2 ((\"Newly null killed: %d\\n\", c)) ;\n            Col [c].shared2.order = --n_col2 ;\n            KILL_PRINCIPAL_COL (c) ;\n        }\n        else\n        {\n            /* set column length and set score */\n            ASSERT (score >= 0) ;\n            ASSERT (score <= n_col) ;\n            Col [c].length = col_length ;\n            Col [c].shared2.score = score ;\n        }\n    }\n    DEBUG1 ((\"colamd: Dense, null, and newly-null columns killed: %d\\n\",\n        n_col-n_col2)) ;\n\n    /* At this point, all empty rows and columns are dead.  All live columns */\n    /* are \"clean\" (containing no dead rows) and simplicial (no supercolumns */\n    /* yet).  Rows may contain dead columns, but all live rows contain at */\n    /* least one live column. */\n\n#ifndef NDEBUG\n    debug_structures (n_row, n_col, Row, Col, A, n_col2) ;\n#endif /* NDEBUG */\n\n    /* === Initialize degree lists ========================================== */\n\n#ifndef NDEBUG\n    debug_count = 0 ;\n#endif /* NDEBUG */\n\n    /* clear the hash buckets */\n    for (c = 0 ; c <= n_col ; c++)\n    {\n        head [c] = EMPTY ;\n    }\n    min_score = n_col ;\n    /* place in reverse order, so low column indices are at the front */\n    /* of the lists.  This is to encourage natural tie-breaking */\n    for (c = n_col-1 ; c >= 0 ; c--)\n    {\n        /* only add principal columns to degree lists */\n        if (COL_IS_ALIVE (c))\n        {\n            DEBUG4 ((\"place %d score %d minscore %d ncol %d\\n\",\n                c, Col [c].shared2.score, min_score, n_col)) ;\n\n            /* === Add columns score to DList =============================== */\n\n            score = Col [c].shared2.score ;\n\n            ASSERT (min_score >= 0) ;\n            ASSERT (min_score <= n_col) ;\n            ASSERT (score >= 0) ;\n            ASSERT (score <= n_col) ;\n            ASSERT (head [score] >= EMPTY) ;\n\n            /* now add this column to dList at proper score location */\n            next_col = head [score] ;\n            Col [c].shared3.prev = EMPTY ;\n            Col [c].shared4.degree_next = next_col ;\n\n            /* if there already was a column with the same score, set its */\n            /* previous pointer to this new column */\n            if (next_col != EMPTY)\n            {\n                Col [next_col].shared3.prev = c ;\n            }\n            head [score] = c ;\n\n            /* see if this score is less than current min */\n            min_score = MIN (min_score, score) ;\n\n#ifndef NDEBUG\n            debug_count++ ;\n#endif /* NDEBUG */\n\n        }\n    }\n\n#ifndef NDEBUG\n    DEBUG1 ((\"colamd: Live cols %d out of %d, non-princ: %d\\n\",\n        debug_count, n_col, n_col-debug_count)) ;\n    ASSERT (debug_count == n_col2) ;\n    debug_deg_lists (n_row, n_col, Row, Col, head, min_score, n_col2, max_deg) ;\n#endif /* NDEBUG */\n\n    /* === Return number of remaining columns, and max row degree =========== */\n\n    *p_n_col2 = n_col2 ;\n    *p_n_row2 = n_row2 ;\n    *p_max_deg = max_deg ;\n}",
      "lines": 263,
      "depth": 17,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "find_ordering": {
      "start_point": [
        2202,
        0
      ],
      "end_point": [
        2747,
        1
      ],
      "content": "PRIVATE Int find_ordering       /* return the number of garbage collections */\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,                  /* number of rows of A */\n    Int n_col,                  /* number of columns of A */\n    Int Alen,                   /* size of A, 2*nnz + n_col or larger */\n    Colamd_Row Row [],          /* of size n_row+1 */\n    Colamd_Col Col [],          /* of size n_col+1 */\n    Int A [],                   /* column form and row form of A */\n    Int head [],                /* of size n_col+1 */\n    Int n_col2,                 /* Remaining columns to order */\n    Int max_deg,                /* Maximum row degree */\n    Int pfree,                  /* index of first free slot (2*nnz on entry) */\n    Int aggressive\n)\n{\n    /* === Local variables ================================================== */\n\n    Int k ;                     /* current pivot ordering step */\n    Int pivot_col ;             /* current pivot column */\n    Int *cp ;                   /* a column pointer */\n    Int *rp ;                   /* a row pointer */\n    Int pivot_row ;             /* current pivot row */\n    Int *new_cp ;               /* modified column pointer */\n    Int *new_rp ;               /* modified row pointer */\n    Int pivot_row_start ;       /* pointer to start of pivot row */\n    Int pivot_row_degree ;      /* number of columns in pivot row */\n    Int pivot_row_length ;      /* number of supercolumns in pivot row */\n    Int pivot_col_score ;       /* score of pivot column */\n    Int needed_memory ;         /* free space needed for pivot row */\n    Int *cp_end ;               /* pointer to the end of a column */\n    Int *rp_end ;               /* pointer to the end of a row */\n    Int row ;                   /* a row index */\n    Int col ;                   /* a column index */\n    Int max_score ;             /* maximum possible score */\n    Int cur_score ;             /* score of current column */\n    unsigned Int hash ;         /* hash value for supernode detection */\n    Int head_column ;           /* head of hash bucket */\n    Int first_col ;             /* first column in hash bucket */\n    Int tag_mark ;              /* marker value for mark array */\n    Int row_mark ;              /* Row [row].shared2.mark */\n    Int set_difference ;        /* set difference size of row with pivot row */\n    Int min_score ;             /* smallest column score */\n    Int col_thickness ;         /* \"thickness\" (no. of columns in a supercol) */\n    Int max_mark ;              /* maximum value of tag_mark */\n    Int pivot_col_thickness ;   /* number of columns represented by pivot col */\n    Int prev_col ;              /* Used by Dlist operations. */\n    Int next_col ;              /* Used by Dlist operations. */\n    Int ngarbage ;              /* number of garbage collections performed */\n\n#ifndef NDEBUG\n    Int debug_d ;               /* debug loop counter */\n    Int debug_step = 0 ;        /* debug loop counter */\n#endif /* NDEBUG */\n\n    /* === Initialization and clear mark ==================================== */\n\n    max_mark = INT_MAX - n_col ;        /* INT_MAX defined in <limits.h> */\n    tag_mark = clear_mark (0, max_mark, n_row, Row) ;\n    min_score = 0 ;\n    ngarbage = 0 ;\n    DEBUG1 ((\"colamd: Ordering, n_col2=%d\\n\", n_col2)) ;\n\n    /* === Order the columns ================================================ */\n\n    for (k = 0 ; k < n_col2 ; /* 'k' is incremented below */)\n    {\n\n#ifndef NDEBUG\n        if (debug_step % 100 == 0)\n        {\n            DEBUG2 ((\"\\n...       Step k: %d out of n_col2: %d\\n\", k, n_col2)) ;\n        }\n        else\n        {\n            DEBUG3 ((\"\\n----------Step k: %d out of n_col2: %d\\n\", k, n_col2)) ;\n        }\n        debug_step++ ;\n        debug_deg_lists (n_row, n_col, Row, Col, head,\n                min_score, n_col2-k, max_deg) ;\n        debug_matrix (n_row, n_col, Row, Col, A) ;\n#endif /* NDEBUG */\n\n        /* === Select pivot column, and order it ============================ */\n\n        /* make sure degree list isn't empty */\n        ASSERT (min_score >= 0) ;\n        ASSERT (min_score <= n_col) ;\n        ASSERT (head [min_score] >= EMPTY) ;\n\n#ifndef NDEBUG\n        for (debug_d = 0 ; debug_d < min_score ; debug_d++)\n        {\n            ASSERT (head [debug_d] == EMPTY) ;\n        }\n#endif /* NDEBUG */\n\n        /* get pivot column from head of minimum degree list */\n        while (head [min_score] == EMPTY && min_score < n_col)\n        {\n            min_score++ ;\n        }\n        pivot_col = head [min_score] ;\n        ASSERT (pivot_col >= 0 && pivot_col <= n_col) ;\n        next_col = Col [pivot_col].shared4.degree_next ;\n        head [min_score] = next_col ;\n        if (next_col != EMPTY)\n        {\n            Col [next_col].shared3.prev = EMPTY ;\n        }\n\n        ASSERT (COL_IS_ALIVE (pivot_col)) ;\n\n        /* remember score for defrag check */\n        pivot_col_score = Col [pivot_col].shared2.score ;\n\n        /* the pivot column is the kth column in the pivot order */\n        Col [pivot_col].shared2.order = k ;\n\n        /* increment order count by column thickness */\n        pivot_col_thickness = Col [pivot_col].shared1.thickness ;\n        k += pivot_col_thickness ;\n        ASSERT (pivot_col_thickness > 0) ;\n        DEBUG3 ((\"Pivot col: %d thick %d\\n\", pivot_col, pivot_col_thickness)) ;\n\n        /* === Garbage_collection, if necessary ============================= */\n\n        needed_memory = MIN (pivot_col_score, n_col - k) ;\n        if (pfree + needed_memory >= Alen)\n        {\n            pfree = garbage_collection (n_row, n_col, Row, Col, A, &A [pfree]) ;\n            ngarbage++ ;\n            /* after garbage collection we will have enough */\n            ASSERT (pfree + needed_memory < Alen) ;\n            /* garbage collection has wiped out the Row[].shared2.mark array */\n            tag_mark = clear_mark (0, max_mark, n_row, Row) ;\n\n#ifndef NDEBUG\n            debug_matrix (n_row, n_col, Row, Col, A) ;\n#endif /* NDEBUG */\n        }\n\n        /* === Compute pivot row pattern ==================================== */\n\n        /* get starting location for this new merged row */\n        pivot_row_start = pfree ;\n\n        /* initialize new row counts to zero */\n        pivot_row_degree = 0 ;\n\n        /* tag pivot column as having been visited so it isn't included */\n        /* in merged pivot row */\n        Col [pivot_col].shared1.thickness = -pivot_col_thickness ;\n\n        /* pivot row is the union of all rows in the pivot column pattern */\n        cp = &A [Col [pivot_col].start] ;\n        cp_end = cp + Col [pivot_col].length ;\n        while (cp < cp_end)\n        {\n            /* get a row */\n            row = *cp++ ;\n            DEBUG4 ((\"Pivot col pattern %d %d\\n\", ROW_IS_ALIVE (row), row)) ;\n            /* skip if row is dead */\n            if (ROW_IS_ALIVE (row))\n            {\n                rp = &A [Row [row].start] ;\n                rp_end = rp + Row [row].length ;\n                while (rp < rp_end)\n                {\n                    /* get a column */\n                    col = *rp++ ;\n                    /* add the column, if alive and untagged */\n                    col_thickness = Col [col].shared1.thickness ;\n                    if (col_thickness > 0 && COL_IS_ALIVE (col))\n                    {\n                        /* tag column in pivot row */\n                        Col [col].shared1.thickness = -col_thickness ;\n                        ASSERT (pfree < Alen) ;\n                        /* place column in pivot row */\n                        A [pfree++] = col ;\n                        pivot_row_degree += col_thickness ;\n                    }\n                }\n            }\n        }\n\n        /* clear tag on pivot column */\n        Col [pivot_col].shared1.thickness = pivot_col_thickness ;\n        max_deg = MAX (max_deg, pivot_row_degree) ;\n\n#ifndef NDEBUG\n        DEBUG3 ((\"check2\\n\")) ;\n        debug_mark (n_row, Row, tag_mark, max_mark) ;\n#endif /* NDEBUG */\n\n        /* === Kill all rows used to construct pivot row ==================== */\n\n        /* also kill pivot row, temporarily */\n        cp = &A [Col [pivot_col].start] ;\n        cp_end = cp + Col [pivot_col].length ;\n        while (cp < cp_end)\n        {\n            /* may be killing an already dead row */\n            row = *cp++ ;\n            DEBUG3 ((\"Kill row in pivot col: %d\\n\", row)) ;\n            KILL_ROW (row) ;\n        }\n\n        /* === Select a row index to use as the new pivot row =============== */\n\n        pivot_row_length = pfree - pivot_row_start ;\n        if (pivot_row_length > 0)\n        {\n            /* pick the \"pivot\" row arbitrarily (first row in col) */\n            pivot_row = A [Col [pivot_col].start] ;\n            DEBUG3 ((\"Pivotal row is %d\\n\", pivot_row)) ;\n        }\n        else\n        {\n            /* there is no pivot row, since it is of zero length */\n            pivot_row = EMPTY ;\n            ASSERT (pivot_row_length == 0) ;\n        }\n        ASSERT (Col [pivot_col].length > 0 || pivot_row_length == 0) ;\n\n        /* === Approximate degree computation =============================== */\n\n        /* Here begins the computation of the approximate degree.  The column */\n        /* score is the sum of the pivot row \"length\", plus the size of the */\n        /* set differences of each row in the column minus the pattern of the */\n        /* pivot row itself.  The column (\"thickness\") itself is also */\n        /* excluded from the column score (we thus use an approximate */\n        /* external degree). */\n\n        /* The time taken by the following code (compute set differences, and */\n        /* add them up) is proportional to the size of the data structure */\n        /* being scanned - that is, the sum of the sizes of each column in */\n        /* the pivot row.  Thus, the amortized time to compute a column score */\n        /* is proportional to the size of that column (where size, in this */\n        /* context, is the column \"length\", or the number of row indices */\n        /* in that column).  The number of row indices in a column is */\n        /* monotonically non-decreasing, from the length of the original */\n        /* column on input to colamd. */\n\n        /* === Compute set differences ====================================== */\n\n        DEBUG3 ((\"** Computing set differences phase. **\\n\")) ;\n\n        /* pivot row is currently dead - it will be revived later. */\n\n        DEBUG3 ((\"Pivot row: \")) ;\n        /* for each column in pivot row */\n        rp = &A [pivot_row_start] ;\n        rp_end = rp + pivot_row_length ;\n        while (rp < rp_end)\n        {\n            col = *rp++ ;\n            ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;\n            DEBUG3 ((\"Col: %d\\n\", col)) ;\n\n            /* clear tags used to construct pivot row pattern */\n            col_thickness = -Col [col].shared1.thickness ;\n            ASSERT (col_thickness > 0) ;\n            Col [col].shared1.thickness = col_thickness ;\n\n            /* === Remove column from degree list =========================== */\n\n            cur_score = Col [col].shared2.score ;\n            prev_col = Col [col].shared3.prev ;\n            next_col = Col [col].shared4.degree_next ;\n            ASSERT (cur_score >= 0) ;\n            ASSERT (cur_score <= n_col) ;\n            ASSERT (cur_score >= EMPTY) ;\n            if (prev_col == EMPTY)\n            {\n                head [cur_score] = next_col ;\n            }\n            else\n            {\n                Col [prev_col].shared4.degree_next = next_col ;\n            }\n            if (next_col != EMPTY)\n            {\n                Col [next_col].shared3.prev = prev_col ;\n            }\n\n            /* === Scan the column ========================================== */\n\n            cp = &A [Col [col].start] ;\n            cp_end = cp + Col [col].length ;\n            while (cp < cp_end)\n            {\n                /* get a row */\n                row = *cp++ ;\n                row_mark = Row [row].shared2.mark ;\n                /* skip if dead */\n                if (ROW_IS_MARKED_DEAD (row_mark))\n                {\n                    continue ;\n                }\n                ASSERT (row != pivot_row) ;\n                set_difference = row_mark - tag_mark ;\n                /* check if the row has been seen yet */\n                if (set_difference < 0)\n                {\n                    ASSERT (Row [row].shared1.degree <= max_deg) ;\n                    set_difference = Row [row].shared1.degree ;\n                }\n                /* subtract column thickness from this row's set difference */\n                set_difference -= col_thickness ;\n                ASSERT (set_difference >= 0) ;\n                /* absorb this row if the set difference becomes zero */\n                if (set_difference == 0 && aggressive)\n                {\n                    DEBUG3 ((\"aggressive absorption. Row: %d\\n\", row)) ;\n                    KILL_ROW (row) ;\n                }\n                else\n                {\n                    /* save the new mark */\n                    Row [row].shared2.mark = set_difference + tag_mark ;\n                }\n            }\n        }\n\n#ifndef NDEBUG\n        debug_deg_lists (n_row, n_col, Row, Col, head,\n                min_score, n_col2-k-pivot_row_degree, max_deg) ;\n#endif /* NDEBUG */\n\n        /* === Add up set differences for each column ======================= */\n\n        DEBUG3 ((\"** Adding set differences phase. **\\n\")) ;\n\n        /* for each column in pivot row */\n        rp = &A [pivot_row_start] ;\n        rp_end = rp + pivot_row_length ;\n        while (rp < rp_end)\n        {\n            /* get a column */\n            col = *rp++ ;\n            ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;\n            hash = 0 ;\n            cur_score = 0 ;\n            cp = &A [Col [col].start] ;\n            /* compact the column */\n            new_cp = cp ;\n            cp_end = cp + Col [col].length ;\n\n            DEBUG4 ((\"Adding set diffs for Col: %d.\\n\", col)) ;\n\n            while (cp < cp_end)\n            {\n                /* get a row */\n                row = *cp++ ;\n                ASSERT(row >= 0 && row < n_row) ;\n                row_mark = Row [row].shared2.mark ;\n                /* skip if dead */\n                if (ROW_IS_MARKED_DEAD (row_mark))\n                {\n                    DEBUG4 ((\" Row %d, dead\\n\", row)) ;\n                    continue ;\n                }\n                DEBUG4 ((\" Row %d, set diff %d\\n\", row, row_mark-tag_mark));\n                ASSERT (row_mark >= tag_mark) ;\n                /* compact the column */\n                *new_cp++ = row ;\n                /* compute hash function */\n                hash += row ;\n                /* add set difference */\n                cur_score += row_mark - tag_mark ;\n                /* integer overflow... */\n                cur_score = MIN (cur_score, n_col) ;\n            }\n\n            /* recompute the column's length */\n            Col [col].length = (Int) (new_cp - &A [Col [col].start]) ;\n\n            /* === Further mass elimination ================================= */\n\n            if (Col [col].length == 0)\n            {\n                DEBUG4 ((\"further mass elimination. Col: %d\\n\", col)) ;\n                /* nothing left but the pivot row in this column */\n                KILL_PRINCIPAL_COL (col) ;\n                pivot_row_degree -= Col [col].shared1.thickness ;\n                ASSERT (pivot_row_degree >= 0) ;\n                /* order it */\n                Col [col].shared2.order = k ;\n                /* increment order count by column thickness */\n                k += Col [col].shared1.thickness ;\n            }\n            else\n            {\n                /* === Prepare for supercolumn detection ==================== */\n\n                DEBUG4 ((\"Preparing supercol detection for Col: %d.\\n\", col)) ;\n\n                /* save score so far */\n                Col [col].shared2.score = cur_score ;\n\n                /* add column to hash table, for supercolumn detection */\n                hash %= n_col + 1 ;\n\n                DEBUG4 ((\" Hash = %d, n_col = %d.\\n\", hash, n_col)) ;\n                ASSERT (((Int) hash) <= n_col) ;\n\n                head_column = head [hash] ;\n                if (head_column > EMPTY)\n                {\n                    /* degree list \"hash\" is non-empty, use prev (shared3) of */\n                    /* first column in degree list as head of hash bucket */\n                    first_col = Col [head_column].shared3.headhash ;\n                    Col [head_column].shared3.headhash = col ;\n                }\n                else\n                {\n                    /* degree list \"hash\" is empty, use head as hash bucket */\n                    first_col = - (head_column + 2) ;\n                    head [hash] = - (col + 2) ;\n                }\n                Col [col].shared4.hash_next = first_col ;\n\n                /* save hash function in Col [col].shared3.hash */\n                Col [col].shared3.hash = (Int) hash ;\n                ASSERT (COL_IS_ALIVE (col)) ;\n            }\n        }\n\n        /* The approximate external column degree is now computed.  */\n\n        /* === Supercolumn detection ======================================== */\n\n        DEBUG3 ((\"** Supercolumn detection phase. **\\n\")) ;\n\n        detect_super_cols (\n\n#ifndef NDEBUG\n                n_col, Row,\n#endif /* NDEBUG */\n\n                Col, A, head, pivot_row_start, pivot_row_length) ;\n\n        /* === Kill the pivotal column ====================================== */\n\n        KILL_PRINCIPAL_COL (pivot_col) ;\n\n        /* === Clear mark =================================================== */\n\n        tag_mark = clear_mark (tag_mark+max_deg+1, max_mark, n_row, Row) ;\n\n#ifndef NDEBUG\n        DEBUG3 ((\"check3\\n\")) ;\n        debug_mark (n_row, Row, tag_mark, max_mark) ;\n#endif /* NDEBUG */\n\n        /* === Finalize the new pivot row, and column scores ================ */\n\n        DEBUG3 ((\"** Finalize scores phase. **\\n\")) ;\n\n        /* for each column in pivot row */\n        rp = &A [pivot_row_start] ;\n        /* compact the pivot row */\n        new_rp = rp ;\n        rp_end = rp + pivot_row_length ;\n        while (rp < rp_end)\n        {\n            col = *rp++ ;\n            /* skip dead columns */\n            if (COL_IS_DEAD (col))\n            {\n                continue ;\n            }\n            *new_rp++ = col ;\n            /* add new pivot row to column */\n            A [Col [col].start + (Col [col].length++)] = pivot_row ;\n\n            /* retrieve score so far and add on pivot row's degree. */\n            /* (we wait until here for this in case the pivot */\n            /* row's degree was reduced due to mass elimination). */\n            cur_score = Col [col].shared2.score + pivot_row_degree ;\n\n            /* calculate the max possible score as the number of */\n            /* external columns minus the 'k' value minus the */\n            /* columns thickness */\n            max_score = n_col - k - Col [col].shared1.thickness ;\n\n            /* make the score the external degree of the union-of-rows */\n            cur_score -= Col [col].shared1.thickness ;\n\n            /* make sure score is less or equal than the max score */\n            cur_score = MIN (cur_score, max_score) ;\n            ASSERT (cur_score >= 0) ;\n\n            /* store updated score */\n            Col [col].shared2.score = cur_score ;\n\n            /* === Place column back in degree list ========================= */\n\n            ASSERT (min_score >= 0) ;\n            ASSERT (min_score <= n_col) ;\n            ASSERT (cur_score >= 0) ;\n            ASSERT (cur_score <= n_col) ;\n            ASSERT (head [cur_score] >= EMPTY) ;\n            next_col = head [cur_score] ;\n            Col [col].shared4.degree_next = next_col ;\n            Col [col].shared3.prev = EMPTY ;\n            if (next_col != EMPTY)\n            {\n                Col [next_col].shared3.prev = col ;\n            }\n            head [cur_score] = col ;\n\n            /* see if this score is less than current min */\n            min_score = MIN (min_score, cur_score) ;\n\n        }\n\n#ifndef NDEBUG\n        debug_deg_lists (n_row, n_col, Row, Col, head,\n                min_score, n_col2-k, max_deg) ;\n#endif /* NDEBUG */\n\n        /* === Resurrect the new pivot row ================================== */\n\n        if (pivot_row_degree > 0)\n        {\n            /* update pivot row length to reflect any cols that were killed */\n            /* during super-col detection and mass elimination */\n            Row [pivot_row].start  = pivot_row_start ;\n            Row [pivot_row].length = (Int) (new_rp - &A[pivot_row_start]) ;\n            ASSERT (Row [pivot_row].length > 0) ;\n            Row [pivot_row].shared1.degree = pivot_row_degree ;\n            Row [pivot_row].shared2.mark = 0 ;\n            /* pivot row is no longer dead */\n\n            DEBUG1 ((\"Resurrect Pivot_row %d deg: %d\\n\",\n                        pivot_row, pivot_row_degree)) ;\n        }\n    }\n\n    /* === All principal columns have now been ordered ====================== */\n\n    return (ngarbage) ;\n}",
      "lines": 546,
      "depth": 18,
      "decorators": [
        "PRIVATE",
        "Int",
        "Int"
      ]
    },
    "order_children": {
      "start_point": [
        2767,
        0
      ],
      "end_point": [
        2832,
        1
      ],
      "content": "PRIVATE void order_children\n(\n    /* === Parameters ======================================================= */\n\n    Int n_col,                  /* number of columns of A */\n    Colamd_Col Col [],          /* of size n_col+1 */\n    Int p []                    /* p [0 ... n_col-1] is the column permutation*/\n)\n{\n    /* === Local variables ================================================== */\n\n    Int i ;                     /* loop counter for all columns */\n    Int c ;                     /* column index */\n    Int parent ;                /* index of column's parent */\n    Int order ;                 /* column's order */\n\n    /* === Order each non-principal column ================================== */\n\n    for (i = 0 ; i < n_col ; i++)\n    {\n        /* find an un-ordered non-principal column */\n        ASSERT (COL_IS_DEAD (i)) ;\n        if (!COL_IS_DEAD_PRINCIPAL (i) && Col [i].shared2.order == EMPTY)\n        {\n            parent = i ;\n            /* once found, find its principal parent */\n            do\n            {\n                parent = Col [parent].shared1.parent ;\n            } while (!COL_IS_DEAD_PRINCIPAL (parent)) ;\n\n            /* now, order all un-ordered non-principal columns along path */\n            /* to this parent.  collapse tree at the same time */\n            c = i ;\n            /* get order of parent */\n            order = Col [parent].shared2.order ;\n\n            do\n            {\n                ASSERT (Col [c].shared2.order == EMPTY) ;\n\n                /* order this column */\n                Col [c].shared2.order = order++ ;\n                /* collaps tree */\n                Col [c].shared1.parent = parent ;\n\n                /* get immediate parent of this column */\n                c = Col [c].shared1.parent ;\n\n                /* continue until we hit an ordered column.  There are */\n                /* guarranteed not to be anymore unordered columns */\n                /* above an ordered column */\n            } while (Col [c].shared2.order == EMPTY) ;\n\n            /* re-order the super_col parent to largest order for this group */\n            Col [parent].shared2.order = order ;\n        }\n    }\n\n    /* === Generate the permutation ========================================= */\n\n    for (c = 0 ; c < n_col ; c++)\n    {\n        p [Col [c].shared2.order] = c ;\n    }\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "detect_super_cols": {
      "start_point": [
        2868,
        0
      ],
      "end_point": [
        3009,
        1
      ],
      "content": "PRIVATE void detect_super_cols\n(\n    /* === Parameters ======================================================= */\n\n#ifndef NDEBUG\n    /* these two parameters are only needed when debugging is enabled: */\n    Int n_col,                  /* number of columns of A */\n    Colamd_Row Row [],          /* of size n_row+1 */\n#endif /* NDEBUG */\n\n    Colamd_Col Col [],          /* of size n_col+1 */\n    Int A [],                   /* row indices of A */\n    Int head [],                /* head of degree lists and hash buckets */\n    Int row_start,              /* pointer to set of columns to check */\n    Int row_length              /* number of columns to check */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int hash ;                  /* hash value for a column */\n    Int *rp ;                   /* pointer to a row */\n    Int c ;                     /* a column index */\n    Int super_c ;               /* column index of the column to absorb into */\n    Int *cp1 ;                  /* column pointer for column super_c */\n    Int *cp2 ;                  /* column pointer for column c */\n    Int length ;                /* length of column super_c */\n    Int prev_c ;                /* column preceding c in hash bucket */\n    Int i ;                     /* loop counter */\n    Int *rp_end ;               /* pointer to the end of the row */\n    Int col ;                   /* a column index in the row to check */\n    Int head_column ;           /* first column in hash bucket or degree list */\n    Int first_col ;             /* first column in hash bucket */\n\n    /* === Consider each column in the row ================================== */\n\n    rp = &A [row_start] ;\n    rp_end = rp + row_length ;\n    while (rp < rp_end)\n    {\n        col = *rp++ ;\n        if (COL_IS_DEAD (col))\n        {\n            continue ;\n        }\n\n        /* get hash number for this column */\n        hash = Col [col].shared3.hash ;\n        ASSERT (hash <= n_col) ;\n\n        /* === Get the first column in this hash bucket ===================== */\n\n        head_column = head [hash] ;\n        if (head_column > EMPTY)\n        {\n            first_col = Col [head_column].shared3.headhash ;\n        }\n        else\n        {\n            first_col = - (head_column + 2) ;\n        }\n\n        /* === Consider each column in the hash bucket ====================== */\n\n        for (super_c = first_col ; super_c != EMPTY ;\n            super_c = Col [super_c].shared4.hash_next)\n        {\n            ASSERT (COL_IS_ALIVE (super_c)) ;\n            ASSERT (Col [super_c].shared3.hash == hash) ;\n            length = Col [super_c].length ;\n\n            /* prev_c is the column preceding column c in the hash bucket */\n            prev_c = super_c ;\n\n            /* === Compare super_c with all columns after it ================ */\n\n            for (c = Col [super_c].shared4.hash_next ;\n                 c != EMPTY ; c = Col [c].shared4.hash_next)\n            {\n                ASSERT (c != super_c) ;\n                ASSERT (COL_IS_ALIVE (c)) ;\n                ASSERT (Col [c].shared3.hash == hash) ;\n\n                /* not identical if lengths or scores are different */\n                if (Col [c].length != length ||\n                    Col [c].shared2.score != Col [super_c].shared2.score)\n                {\n                    prev_c = c ;\n                    continue ;\n                }\n\n                /* compare the two columns */\n                cp1 = &A [Col [super_c].start] ;\n                cp2 = &A [Col [c].start] ;\n\n                for (i = 0 ; i < length ; i++)\n                {\n                    /* the columns are \"clean\" (no dead rows) */\n                    ASSERT (ROW_IS_ALIVE (*cp1))  ;\n                    ASSERT (ROW_IS_ALIVE (*cp2))  ;\n                    /* row indices will same order for both supercols, */\n                    /* no gather scatter nessasary */\n                    if (*cp1++ != *cp2++)\n                    {\n                        break ;\n                    }\n                }\n\n                /* the two columns are different if the for-loop \"broke\" */\n                if (i != length)\n                {\n                    prev_c = c ;\n                    continue ;\n                }\n\n                /* === Got it!  two columns are identical =================== */\n\n                ASSERT (Col [c].shared2.score == Col [super_c].shared2.score) ;\n\n                Col [super_c].shared1.thickness += Col [c].shared1.thickness ;\n                Col [c].shared1.parent = super_c ;\n                KILL_NON_PRINCIPAL_COL (c) ;\n                /* order c later, in order_children() */\n                Col [c].shared2.order = EMPTY ;\n                /* remove c from hash bucket */\n                Col [prev_c].shared4.hash_next = Col [c].shared4.hash_next ;\n            }\n        }\n\n        /* === Empty this hash bucket ======================================= */\n\n        if (head_column > EMPTY)\n        {\n            /* corresponding degree list \"hash\" is not empty */\n            Col [head_column].shared3.headhash = EMPTY ;\n        }\n        else\n        {\n            /* corresponding degree list \"hash\" is empty */\n            head [hash] = EMPTY ;\n        }\n    }\n}",
      "lines": 142,
      "depth": 17,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "garbage_collection": {
      "start_point": [
        3025,
        0
      ],
      "end_point": [
        3145,
        1
      ],
      "content": "PRIVATE Int garbage_collection  /* returns the new value of pfree */\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,                  /* number of rows */\n    Int n_col,                  /* number of columns */\n    Colamd_Row Row [],          /* row info */\n    Colamd_Col Col [],          /* column info */\n    Int A [],                   /* A [0 ... Alen-1] holds the matrix */\n    Int *pfree                  /* &A [0] ... pfree is in use */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int *psrc ;                 /* source pointer */\n    Int *pdest ;                /* destination pointer */\n    Int j ;                     /* counter */\n    Int r ;                     /* a row index */\n    Int c ;                     /* a column index */\n    Int length ;                /* length of a row or column */\n\n#ifndef NDEBUG\n    Int debug_rows ;\n    DEBUG2 ((\"Defrag..\\n\")) ;\n    for (psrc = &A[0] ; psrc < pfree ; psrc++) ASSERT (*psrc >= 0) ;\n    debug_rows = 0 ;\n#endif /* NDEBUG */\n\n    /* === Defragment the columns =========================================== */\n\n    pdest = &A[0] ;\n    for (c = 0 ; c < n_col ; c++)\n    {\n        if (COL_IS_ALIVE (c))\n        {\n            psrc = &A [Col [c].start] ;\n\n            /* move and compact the column */\n            ASSERT (pdest <= psrc) ;\n            Col [c].start = (Int) (pdest - &A [0]) ;\n            length = Col [c].length ;\n            for (j = 0 ; j < length ; j++)\n            {\n                r = *psrc++ ;\n                if (ROW_IS_ALIVE (r))\n                {\n                    *pdest++ = r ;\n                }\n            }\n            Col [c].length = (Int) (pdest - &A [Col [c].start]) ;\n        }\n    }\n\n    /* === Prepare to defragment the rows =================================== */\n\n    for (r = 0 ; r < n_row ; r++)\n    {\n        if (ROW_IS_DEAD (r) || (Row [r].length == 0))\n        {\n            /* This row is already dead, or is of zero length.  Cannot compact\n             * a row of zero length, so kill it.  NOTE: in the current version,\n             * there are no zero-length live rows.  Kill the row (for the first\n             * time, or again) just to be safe. */\n            KILL_ROW (r) ;\n        }\n        else\n        {\n            /* save first column index in Row [r].shared2.first_column */\n            psrc = &A [Row [r].start] ;\n            Row [r].shared2.first_column = *psrc ;\n            ASSERT (ROW_IS_ALIVE (r)) ;\n            /* flag the start of the row with the one's complement of row */\n            *psrc = ONES_COMPLEMENT (r) ;\n#ifndef NDEBUG\n            debug_rows++ ;\n#endif /* NDEBUG */\n        }\n    }\n\n    /* === Defragment the rows ============================================== */\n\n    psrc = pdest ;\n    while (psrc < pfree)\n    {\n        /* find a negative number ... the start of a row */\n        if (*psrc++ < 0)\n        {\n            psrc-- ;\n            /* get the row index */\n            r = ONES_COMPLEMENT (*psrc) ;\n            ASSERT (r >= 0 && r < n_row) ;\n            /* restore first column index */\n            *psrc = Row [r].shared2.first_column ;\n            ASSERT (ROW_IS_ALIVE (r)) ;\n            ASSERT (Row [r].length > 0) ;\n            /* move and compact the row */\n            ASSERT (pdest <= psrc) ;\n            Row [r].start = (Int) (pdest - &A [0]) ;\n            length = Row [r].length ;\n            for (j = 0 ; j < length ; j++)\n            {\n                c = *psrc++ ;\n                if (COL_IS_ALIVE (c))\n                {\n                    *pdest++ = c ;\n                }\n            }\n            Row [r].length = (Int) (pdest - &A [Row [r].start]) ;\n            ASSERT (Row [r].length > 0) ;\n#ifndef NDEBUG\n            debug_rows-- ;\n#endif /* NDEBUG */\n        }\n    }\n    /* ensure we found all the rows */\n    ASSERT (debug_rows == 0) ;\n\n    /* === Return the new value of pfree ==================================== */\n\n    return ((Int) (pdest - &A [0])) ;\n}",
      "lines": 121,
      "depth": 16,
      "decorators": [
        "PRIVATE",
        "Int",
        "Int"
      ]
    },
    "clear_mark": {
      "start_point": [
        3157,
        0
      ],
      "end_point": [
        3185,
        1
      ],
      "content": "PRIVATE Int clear_mark  /* return the new value for tag_mark */\n(\n    /* === Parameters ======================================================= */\n\n    Int tag_mark,       /* new value of tag_mark */\n    Int max_mark,       /* max allowed value of tag_mark */\n\n    Int n_row,          /* number of rows in A */\n    Colamd_Row Row []   /* Row [0 ... n_row-1].shared2.mark is set to zero */\n)\n{\n    /* === Local variables ================================================== */\n\n    Int r ;\n\n    if (tag_mark <= 0 || tag_mark >= max_mark)\n    {\n        for (r = 0 ; r < n_row ; r++)\n        {\n            if (ROW_IS_ALIVE (r))\n            {\n                Row [r].shared2.mark = 0 ;\n            }\n        }\n        tag_mark = 1 ;\n    }\n\n    return (tag_mark) ;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "PRIVATE",
        "Int",
        "Int"
      ]
    },
    "print_report": {
      "start_point": [
        3192,
        0
      ],
      "end_point": [
        3313,
        1
      ],
      "content": "PRIVATE void print_report\n(\n    char *method,\n    Int stats [COLAMD_STATS]\n)\n{\n\n    Int i1, i2, i3 ;\n\n    PRINTF ((\"\\n%s version %d.%d, %s: \", method,\n            COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION, COLAMD_DATE)) ;\n\n    if (!stats)\n    {\n        PRINTF ((\"No statistics available.\\n\")) ;\n        return ;\n    }\n\n    i1 = stats [COLAMD_INFO1] ;\n    i2 = stats [COLAMD_INFO2] ;\n    i3 = stats [COLAMD_INFO3] ;\n\n    if (stats [COLAMD_STATUS] >= 0)\n    {\n        PRINTF ((\"OK.  \")) ;\n    }\n    else\n    {\n        PRINTF ((\"ERROR.  \")) ;\n    }\n\n    switch (stats [COLAMD_STATUS])\n    {\n\n        case COLAMD_OK_BUT_JUMBLED:\n\n            PRINTF((\"Matrix has unsorted or duplicate row indices.\\n\")) ;\n\n            PRINTF((\"%s: number of duplicate or out-of-order row indices: %d\\n\",\n            method, i3)) ;\n\n            PRINTF((\"%s: last seen duplicate or out-of-order row index:   %d\\n\",\n            method, INDEX (i2))) ;\n\n            PRINTF((\"%s: last seen in column:                             %d\",\n            method, INDEX (i1))) ;\n\n            /* no break - fall through to next case instead */\n\n        case COLAMD_OK:\n\n            PRINTF((\"\\n\")) ;\n\n            PRINTF((\"%s: number of dense or empty rows ignored:           %d\\n\",\n            method, stats [COLAMD_DENSE_ROW])) ;\n\n            PRINTF((\"%s: number of dense or empty columns ignored:        %d\\n\",\n            method, stats [COLAMD_DENSE_COL])) ;\n\n            PRINTF((\"%s: number of garbage collections performed:         %d\\n\",\n            method, stats [COLAMD_DEFRAG_COUNT])) ;\n            break ;\n\n        case COLAMD_ERROR_A_not_present:\n\n            PRINTF((\"Array A (row indices of matrix) not present.\\n\")) ;\n            break ;\n\n        case COLAMD_ERROR_p_not_present:\n\n            PRINTF((\"Array p (column pointers for matrix) not present.\\n\")) ;\n            break ;\n\n        case COLAMD_ERROR_nrow_negative:\n\n            PRINTF((\"Invalid number of rows (%d).\\n\", i1)) ;\n            break ;\n\n        case COLAMD_ERROR_ncol_negative:\n\n            PRINTF((\"Invalid number of columns (%d).\\n\", i1)) ;\n            break ;\n\n        case COLAMD_ERROR_nnz_negative:\n\n            PRINTF((\"Invalid number of nonzero entries (%d).\\n\", i1)) ;\n            break ;\n\n        case COLAMD_ERROR_p0_nonzero:\n\n            PRINTF((\"Invalid column pointer, p [0] = %d, must be zero.\\n\", i1));\n            break ;\n\n        case COLAMD_ERROR_A_too_small:\n\n            PRINTF((\"Array A too small.\\n\")) ;\n            PRINTF((\"        Need Alen >= %d, but given only Alen = %d.\\n\",\n            i1, i2)) ;\n            break ;\n\n        case COLAMD_ERROR_col_length_negative:\n\n            PRINTF\n            ((\"Column %d has a negative number of nonzero entries (%d).\\n\",\n            INDEX (i1), i2)) ;\n            break ;\n\n        case COLAMD_ERROR_row_index_out_of_bounds:\n\n            PRINTF\n            ((\"Row index (row %d) out of bounds (%d to %d) in column %d.\\n\",\n            INDEX (i2), INDEX (0), INDEX (i3-1), INDEX (i1))) ;\n            break ;\n\n        case COLAMD_ERROR_out_of_memory:\n\n            PRINTF((\"Out of memory.\\n\")) ;\n            break ;\n\n        /* v2.4: internal-error case deleted */\n    }\n}",
      "lines": 122,
      "depth": 17,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "debug_structures": {
      "start_point": [
        3338,
        0
      ],
      "end_point": [
        3412,
        1
      ],
      "content": "PRIVATE void debug_structures\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,\n    Int n_col,\n    Colamd_Row Row [],\n    Colamd_Col Col [],\n    Int A [],\n    Int n_col2\n)\n{\n    /* === Local variables ================================================== */\n\n    Int i ;\n    Int c ;\n    Int *cp ;\n    Int *cp_end ;\n    Int len ;\n    Int score ;\n    Int r ;\n    Int *rp ;\n    Int *rp_end ;\n    Int deg ;\n\n    /* === Check A, Row, and Col ============================================ */\n\n    for (c = 0 ; c < n_col ; c++)\n    {\n        if (COL_IS_ALIVE (c))\n        {\n            len = Col [c].length ;\n            score = Col [c].shared2.score ;\n            DEBUG4 ((\"initial live col %5d %5d %5d\\n\", c, len, score)) ;\n            ASSERT (len > 0) ;\n            ASSERT (score >= 0) ;\n            ASSERT (Col [c].shared1.thickness == 1) ;\n            cp = &A [Col [c].start] ;\n            cp_end = cp + len ;\n            while (cp < cp_end)\n            {\n                r = *cp++ ;\n                ASSERT (ROW_IS_ALIVE (r)) ;\n            }\n        }\n        else\n        {\n            i = Col [c].shared2.order ;\n            ASSERT (i >= n_col2 && i < n_col) ;\n        }\n    }\n\n    for (r = 0 ; r < n_row ; r++)\n    {\n        if (ROW_IS_ALIVE (r))\n        {\n            i = 0 ;\n            len = Row [r].length ;\n            deg = Row [r].shared1.degree ;\n            ASSERT (len > 0) ;\n            ASSERT (deg > 0) ;\n            rp = &A [Row [r].start] ;\n            rp_end = rp + len ;\n            while (rp < rp_end)\n            {\n                c = *rp++ ;\n                if (COL_IS_ALIVE (c))\n                {\n                    i++ ;\n                }\n            }\n            ASSERT (i > 0) ;\n        }\n    }\n}",
      "lines": 75,
      "depth": 14,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "debug_deg_lists": {
      "start_point": [
        3425,
        0
      ],
      "end_point": [
        3487,
        1
      ],
      "content": "PRIVATE void debug_deg_lists\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,\n    Int n_col,\n    Colamd_Row Row [],\n    Colamd_Col Col [],\n    Int head [],\n    Int min_score,\n    Int should,\n    Int max_deg\n)\n{\n    /* === Local variables ================================================== */\n\n    Int deg ;\n    Int col ;\n    Int have ;\n    Int row ;\n\n    /* === Check the degree lists =========================================== */\n\n    if (n_col > 10000 && colamd_debug <= 0)\n    {\n        return ;\n    }\n    have = 0 ;\n    DEBUG4 ((\"Degree lists: %d\\n\", min_score)) ;\n    for (deg = 0 ; deg <= n_col ; deg++)\n    {\n        col = head [deg] ;\n        if (col == EMPTY)\n        {\n            continue ;\n        }\n        DEBUG4 ((\"%d:\", deg)) ;\n        while (col != EMPTY)\n        {\n            DEBUG4 ((\" %d\", col)) ;\n            have += Col [col].shared1.thickness ;\n            ASSERT (COL_IS_ALIVE (col)) ;\n            col = Col [col].shared4.degree_next ;\n        }\n        DEBUG4 ((\"\\n\")) ;\n    }\n    DEBUG4 ((\"should %d have %d\\n\", should, have)) ;\n    ASSERT (should == have) ;\n\n    /* === Check the row degrees ============================================ */\n\n    if (n_row > 10000 && colamd_debug <= 0)\n    {\n        return ;\n    }\n    for (row = 0 ; row < n_row ; row++)\n    {\n        if (ROW_IS_ALIVE (row))\n        {\n            ASSERT (Row [row].shared1.degree <= max_deg) ;\n        }\n    }\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "debug_mark": {
      "start_point": [
        3499,
        0
      ],
      "end_point": [
        3524,
        1
      ],
      "content": "PRIVATE void debug_mark\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,\n    Colamd_Row Row [],\n    Int tag_mark,\n    Int max_mark\n)\n{\n    /* === Local variables ================================================== */\n\n    Int r ;\n\n    /* === Check the Row marks ============================================== */\n\n    ASSERT (tag_mark > 0 && tag_mark <= max_mark) ;\n    if (n_row > 10000 && colamd_debug <= 0)\n    {\n        return ;\n    }\n    for (r = 0 ; r < n_row ; r++)\n    {\n        ASSERT (Row [r].shared2.mark < tag_mark) ;\n    }\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "debug_matrix": {
      "start_point": [
        3535,
        0
      ],
      "end_point": [
        3598,
        1
      ],
      "content": "PRIVATE void debug_matrix\n(\n    /* === Parameters ======================================================= */\n\n    Int n_row,\n    Int n_col,\n    Colamd_Row Row [],\n    Colamd_Col Col [],\n    Int A []\n)\n{\n    /* === Local variables ================================================== */\n\n    Int r ;\n    Int c ;\n    Int *rp ;\n    Int *rp_end ;\n    Int *cp ;\n    Int *cp_end ;\n\n    /* === Dump the rows and columns of the matrix ========================== */\n\n    if (colamd_debug < 3)\n    {\n        return ;\n    }\n    DEBUG3 ((\"DUMP MATRIX:\\n\")) ;\n    for (r = 0 ; r < n_row ; r++)\n    {\n        DEBUG3 ((\"Row %d alive? %d\\n\", r, ROW_IS_ALIVE (r))) ;\n        if (ROW_IS_DEAD (r))\n        {\n            continue ;\n        }\n        DEBUG3 ((\"start %d length %d degree %d\\n\",\n                Row [r].start, Row [r].length, Row [r].shared1.degree)) ;\n        rp = &A [Row [r].start] ;\n        rp_end = rp + Row [r].length ;\n        while (rp < rp_end)\n        {\n            c = *rp++ ;\n            DEBUG4 ((\"  %d col %d\\n\", COL_IS_ALIVE (c), c)) ;\n        }\n    }\n\n    for (c = 0 ; c < n_col ; c++)\n    {\n        DEBUG3 ((\"Col %d alive? %d\\n\", c, COL_IS_ALIVE (c))) ;\n        if (COL_IS_DEAD (c))\n        {\n            continue ;\n        }\n        DEBUG3 ((\"start %d length %d shared1 %d shared2 %d\\n\",\n                Col [c].start, Col [c].length,\n                Col [c].shared1.thickness, Col [c].shared2.score)) ;\n        cp = &A [Col [c].start] ;\n        cp_end = cp + Col [c].length ;\n        while (cp < cp_end)\n        {\n            r = *cp++ ;\n            DEBUG4 ((\"  %d row %d\\n\", ROW_IS_ALIVE (r), r)) ;\n        }\n    }\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    },
    "colamd_get_debug": {
      "start_point": [
        3600,
        0
      ],
      "end_point": [
        3619,
        1
      ],
      "content": "PRIVATE void colamd_get_debug\n(\n    char *method\n)\n{\n    FILE *f ;\n    colamd_debug = 0 ;          /* no debug printing */\n    f = fopen (\"debug\", \"r\") ;\n    if (f == (FILE *) NULL)\n    {\n        colamd_debug = 0 ;\n    }\n    else\n    {\n        fscanf (f, \"%d\", &colamd_debug) ;\n        fclose (f) ;\n    }\n    DEBUG0 ((\"%s: debug version, D = %d (THIS WILL BE SLOW!)\\n\",\n        method, colamd_debug)) ;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "PRIVATE",
        "void",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/colamd/colamd.h": {},
  "glpk/glpk-4.65/src/draft/bfd.c": {
    "bfd_create_it": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "BFD *bfd_create_it(void)\n{     /* create LP basis factorization */\n      BFD *bfd;\n#ifdef GLP_DEBUG\n      xprintf(\"bfd_create_it: warning: debugging version used\\n\");\n#endif\n      bfd = talloc(1, BFD);\n      bfd->valid = 0;\n      bfd->type = 0;\n      bfd->u.none = NULL;\n      bfd_set_bfcp(bfd, NULL);\n#ifdef GLP_DEBUG\n      bfd->B = NULL;\n#endif\n      bfd->upd_cnt = 0;\n      return bfd;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "BFD",
        "*bfd_create_it(void)",
        "*"
      ]
    },
    "bfd_set_parm": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void bfd_set_parm(BFD *bfd, const void *parm)\n{     /* change LP basis factorization control parameters */\n      memcpy(&bfd->parm, parm, sizeof(glp_bfcp));\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "bfd_get_bfcp": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void bfd_get_bfcp(BFD *bfd, void /* glp_bfcp */ *parm)\n{     /* retrieve LP basis factorization control parameters */\n      memcpy(parm, &bfd->parm, sizeof(glp_bfcp));\n      return;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "bfd_set_bfcp": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void bfd_set_bfcp(BFD *bfd, const void /* glp_bfcp */ *parm)\n{     /* change LP basis factorization control parameters */\n      if (parm == NULL)\n      {  /* reset to default */\n         memset(&bfd->parm, 0, sizeof(glp_bfcp));\n         bfd->parm.type = GLP_BF_LUF + GLP_BF_FT;\n         bfd->parm.piv_tol = 0.10;\n         bfd->parm.piv_lim = 4;\n         bfd->parm.suhl = 1;\n         bfd->parm.eps_tol = DBL_EPSILON;\n         bfd->parm.nfs_max = 100;\n         bfd->parm.nrs_max = 70;\n      }\n      else\n         memcpy(&bfd->parm, parm, sizeof(glp_bfcp));\n      return;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "bfd_col": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static int bfd_col(void *info_, int j, int ind[], double val[])\n{     struct bfd_info *info = info_;\n      int t, len;\n      double sum;\n      len = info->col(info->info, j, ind, val);\n      sum = 0.0;\n      for (t = 1; t <= len; t++)\n      {  if (val[t] >= 0.0)\n            sum += val[t];\n         else\n            sum -= val[t];\n      }\n      if (info->bfd->b_norm < sum)\n         info->bfd->b_norm = sum;\n      return len;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bfd_factorize": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int bfd_factorize(BFD *bfd, int m, /*const int bh[],*/ int (*col1)\n      (void *info, int j, int ind[], double val[]), void *info1)\n{     /* compute LP basis factorization */\n#if 1 /* 21/IV-2014 */\n      struct bfd_info info;\n#endif\n      int type, ret;\n      /*xassert(bh == bh);*/\n      /* invalidate current factorization */\n      bfd->valid = 0;\n      /* determine required factorization type */\n      switch (bfd->parm.type)\n      {  case GLP_BF_LUF + GLP_BF_FT:\n            type = 1;\n            break;\n         case GLP_BF_LUF + GLP_BF_BG:\n         case GLP_BF_LUF + GLP_BF_GR:\n         case GLP_BF_BTF + GLP_BF_BG:\n         case GLP_BF_BTF + GLP_BF_GR:\n            type = 2;\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n      /* delete factorization interface, if necessary */\n      switch (bfd->type)\n      {  case 0:\n            break;\n         case 1:\n            if (type != 1)\n            {  bfd->type = 0;\n               fhvint_delete(bfd->u.fhvi);\n               bfd->u.fhvi = NULL;\n            }\n            break;\n         case 2:\n            if (type != 2)\n            {  bfd->type = 0;\n               scfint_delete(bfd->u.scfi);\n               bfd->u.scfi = NULL;\n            }\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n      /* establish factorization interface, if necessary */\n      if (bfd->type == 0)\n      {  switch (type)\n         {  case 1:\n               bfd->type = 1;\n               xassert(bfd->u.fhvi == NULL);\n               bfd->u.fhvi = fhvint_create();\n               break;\n            case 2:\n               bfd->type = 2;\n               xassert(bfd->u.scfi == NULL);\n               if (!(bfd->parm.type & GLP_BF_BTF))\n                  bfd->u.scfi = scfint_create(1);\n               else\n                  bfd->u.scfi = scfint_create(2);\n               break;\n            default:\n               xassert(type != type);\n         }\n      }\n      /* try to compute factorization */\n#if 1 /* 21/IV-2014 */\n      bfd->b_norm = bfd->i_norm = 0.0;\n      info.bfd = bfd;\n      info.col = col1;\n      info.info = info1;\n#endif\n      switch (bfd->type)\n      {  case 1:\n            bfd->u.fhvi->lufi->sgf_piv_tol = bfd->parm.piv_tol;\n            bfd->u.fhvi->lufi->sgf_piv_lim = bfd->parm.piv_lim;\n            bfd->u.fhvi->lufi->sgf_suhl = bfd->parm.suhl;\n            bfd->u.fhvi->lufi->sgf_eps_tol = bfd->parm.eps_tol;\n            bfd->u.fhvi->nfs_max = bfd->parm.nfs_max;\n            ret = fhvint_factorize(bfd->u.fhvi, m, bfd_col, &info);\n#if 1 /* FIXME */\n            if (ret == 0)\n               bfd->i_norm = fhvint_estimate(bfd->u.fhvi);\n            else\n               ret = BFD_ESING;\n#endif\n            break;\n         case 2:\n            if (bfd->u.scfi->scf.type == 1)\n            {  bfd->u.scfi->u.lufi->sgf_piv_tol = bfd->parm.piv_tol;\n               bfd->u.scfi->u.lufi->sgf_piv_lim = bfd->parm.piv_lim;\n               bfd->u.scfi->u.lufi->sgf_suhl = bfd->parm.suhl;\n               bfd->u.scfi->u.lufi->sgf_eps_tol = bfd->parm.eps_tol;\n            }\n            else if (bfd->u.scfi->scf.type == 2)\n            {  bfd->u.scfi->u.btfi->sgf_piv_tol = bfd->parm.piv_tol;\n               bfd->u.scfi->u.btfi->sgf_piv_lim = bfd->parm.piv_lim;\n               bfd->u.scfi->u.btfi->sgf_suhl = bfd->parm.suhl;\n               bfd->u.scfi->u.btfi->sgf_eps_tol = bfd->parm.eps_tol;\n            }\n            else\n               xassert(bfd != bfd);\n            bfd->u.scfi->nn_max = bfd->parm.nrs_max;\n            ret = scfint_factorize(bfd->u.scfi, m, bfd_col, &info);\n#if 1 /* FIXME */\n            if (ret == 0)\n               bfd->i_norm = scfint_estimate(bfd->u.scfi);\n            else\n               ret = BFD_ESING;\n#endif\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n#ifdef GLP_DEBUG\n      /* save specified LP basis */\n      if (bfd->B != NULL)\n         spm_delete_mat(bfd->B);\n      bfd->B = spm_create_mat(m, m);\n      {  int *ind = talloc(1+m, int);\n         double *val = talloc(1+m, double);\n         int j, k, len;\n         for (j = 1; j <= m; j++)\n         {  len = col(info, j, ind, val);\n            for (k = 1; k <= len; k++)\n               spm_new_elem(bfd->B, ind[k], j, val[k]);\n         }\n         tfree(ind);\n         tfree(val);\n      }\n#endif\n      if (ret == 0)\n      {  /* factorization has been successfully computed */\n         double cond;\n         bfd->valid = 1;\n#ifdef GLP_DEBUG\n         cond = bfd_condest(bfd);\n         if (cond > 1e9)\n            xprintf(\"bfd_factorize: warning: cond(B) = %g\\n\", cond);\n#endif\n      }\n#ifdef GLP_DEBUG\n      xprintf(\"bfd_factorize: m = %d; ret = %d\\n\", m, ret);\n#endif\n      bfd->upd_cnt = 0;\n      return ret;\n}",
      "lines": 147,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "bfd_estimate": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "double bfd_estimate(BFD *bfd)\n{     /* estimate 1-norm of inv(B) */\n      double norm;\n      xassert(bfd->valid);\n      xassert(bfd->upd_cnt == 0);\n      switch (bfd->type)\n      {  case 1:\n            norm = fhvint_estimate(bfd->u.fhvi);\n            break;\n         case 2:\n            norm = scfint_estimate(bfd->u.scfi);\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n      return norm;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "bfd_condest": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "double bfd_condest(BFD *bfd)\n{     /* estimate condition of B */\n      double cond;\n      xassert(bfd->valid);\n      /*xassert(bfd->upd_cnt == 0);*/\n      cond = bfd->b_norm * bfd->i_norm;\n      if (cond < 1.0)\n         cond = 1.0;\n      return cond;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "bfd_ftran": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void bfd_ftran(BFD *bfd, double x[])\n{     /* perform forward transformation (solve system B * x = b) */\n#ifdef GLP_DEBUG\n      SPM *B = bfd->B;\n      int m = B->m;\n      double *b = talloc(1+m, double);\n      SPME *e;\n      int k;\n      double s, relerr, maxerr;\n      for (k = 1; k <= m; k++)\n         b[k] = x[k];\n#endif\n      xassert(bfd->valid);\n      switch (bfd->type)\n      {  case 1:\n            fhvint_ftran(bfd->u.fhvi, x);\n            break;\n         case 2:\n            scfint_ftran(bfd->u.scfi, x);\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n#ifdef GLP_DEBUG\n      maxerr = 0.0;\n      for (k = 1; k <= m; k++)\n      {  s = 0.0;\n         for (e = B->row[k]; e != NULL; e = e->r_next)\n            s += e->val * x[e->j];\n         relerr = (b[k] - s) / (1.0 + fabs(b[k]));\n         if (maxerr < relerr)\n            maxerr = relerr;\n      }\n      if (maxerr > 1e-8)\n         xprintf(\"bfd_ftran: maxerr = %g; relative error too large\\n\",\n            maxerr);\n      tfree(b);\n#endif\n      return;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "bfd_ftran_s": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "void bfd_ftran_s(BFD *bfd, FVS *x)\n{     /* sparse version of bfd_ftran */\n      /* (sparse mode is not implemented yet) */\n      int n = x->n;\n      int *ind = x->ind;\n      double *vec = x->vec;\n      int j, nnz = 0;\n      bfd_ftran(bfd, vec);\n      for (j = n; j >= 1; j--)\n      {  if (vec[j] != 0.0)\n            ind[++nnz] = j;\n      }\n      x->nnz = nnz;\n      return;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "bfd_btran": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void bfd_btran(BFD *bfd, double x[])\n{     /* perform backward transformation (solve system B'* x = b) */\n#ifdef GLP_DEBUG\n      SPM *B = bfd->B;\n      int m = B->m;\n      double *b = talloc(1+m, double);\n      SPME *e;\n      int k;\n      double s, relerr, maxerr;\n      for (k = 1; k <= m; k++)\n         b[k] = x[k];\n#endif\n      xassert(bfd->valid);\n      switch (bfd->type)\n      {  case 1:\n            fhvint_btran(bfd->u.fhvi, x);\n            break;\n         case 2:\n            scfint_btran(bfd->u.scfi, x);\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n#ifdef GLP_DEBUG\n      maxerr = 0.0;\n      for (k = 1; k <= m; k++)\n      {  s = 0.0;\n         for (e = B->col[k]; e != NULL; e = e->c_next)\n            s += e->val * x[e->i];\n         relerr = (b[k] - s) / (1.0 + fabs(b[k]));\n         if (maxerr < relerr)\n            maxerr = relerr;\n      }\n      if (maxerr > 1e-8)\n         xprintf(\"bfd_btran: maxerr = %g; relative error too large\\n\",\n            maxerr);\n      tfree(b);\n#endif\n      return;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "bfd_btran_s": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void bfd_btran_s(BFD *bfd, FVS *x)\n{     /* sparse version of bfd_btran */\n      /* (sparse mode is not implemented yet) */\n      int n = x->n;\n      int *ind = x->ind;\n      double *vec = x->vec;\n      int j, nnz = 0;\n      bfd_btran(bfd, vec);\n      for (j = n; j >= 1; j--)\n      {  if (vec[j] != 0.0)\n            ind[++nnz] = j;\n      }\n      x->nnz = nnz;\n      return;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "bfd_update": {
      "start_point": [
        437,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "int bfd_update(BFD *bfd, int j, int len, const int ind[], const double\n      val[])\n{     /* update LP basis factorization */\n      int ret;\n      xassert(bfd->valid);\n      switch (bfd->type)\n      {  case 1:\n            ret = fhvint_update(bfd->u.fhvi, j, len, ind, val);\n#if 1 /* FIXME */\n            switch (ret)\n            {  case 0:\n                  break;\n               case 1:\n                  ret = BFD_ESING;\n                  break;\n               case 2:\n               case 3:\n                  ret = BFD_ECOND;\n                  break;\n               case 4:\n                  ret = BFD_ELIMIT;\n                  break;\n               case 5:\n                  ret = BFD_ECHECK;\n                  break;\n               default:\n                  xassert(ret != ret);\n            }\n#endif\n            break;\n         case 2:\n            switch (bfd->parm.type & 0x0F)\n            {  case GLP_BF_BG:\n                  ret = scfint_update(bfd->u.scfi, 1, j, len, ind, val);\n                  break;\n               case GLP_BF_GR:\n                  ret = scfint_update(bfd->u.scfi, 2, j, len, ind, val);\n                  break;\n               default:\n                  xassert(bfd != bfd);\n            }\n#if 1 /* FIXME */\n            switch (ret)\n            {  case 0:\n                  break;\n               case 1:\n                  ret = BFD_ELIMIT;\n                  break;\n               case 2:\n                  ret = BFD_ECOND;\n                  break;\n               default:\n                  xassert(ret != ret);\n            }\n#endif\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n      if (ret != 0)\n      {  /* updating factorization failed */\n         bfd->valid = 0;\n      }\n#ifdef GLP_DEBUG\n      /* save updated LP basis */\n      {  SPME *e;\n         int k;\n         for (e = bfd->B->col[j]; e != NULL; e = e->c_next)\n            e->val = 0.0;\n         spm_drop_zeros(bfd->B, 0.0);\n         for (k = 1; k <= len; k++)\n            spm_new_elem(bfd->B, ind[k], j, val[k]);\n      }\n#endif\n      if (ret == 0)\n         bfd->upd_cnt++;\n      return ret;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "bfd_get_count": {
      "start_point": [
        516,
        0
      ],
      "end_point": [
        519,
        1
      ],
      "content": "int bfd_get_count(BFD *bfd)\n{     /* determine factorization update count */\n      return bfd->upd_cnt;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "bfd_delete_it": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "void bfd_delete_it(BFD *bfd)\n{     /* delete LP basis factorization */\n      switch (bfd->type)\n      {  case 0:\n            break;\n         case 1:\n            fhvint_delete(bfd->u.fhvi);\n            break;\n         case 2:\n            scfint_delete(bfd->u.scfi);\n            break;\n         default:\n            xassert(bfd != bfd);\n      }\n#ifdef GLP_DEBUG\n      if (bfd->B != NULL)\n         spm_delete_mat(bfd->B);\n#endif\n      tfree(bfd);\n      return;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/bfd.h": {},
  "glpk/glpk-4.65/src/draft/bfx.c": {
    "bfx_create_binv": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "BFX *bfx_create_binv(void)\n{     /* create factorization of the basis matrix */\n      BFX *bfx;\n      bfx = xmalloc(sizeof(BFX));\n      bfx->valid = 0;\n      bfx->lux = NULL;\n      return bfx;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "BFX",
        "*bfx_create_binv(void)",
        "*"
      ]
    },
    "bfx_factorize": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int bfx_factorize(BFX *binv, int m, int (*col)(void *info, int j,\n      int ind[], mpq_t val[]), void *info)\n{     /* compute factorization of the basis matrix */\n      int ret;\n      xassert(m > 0);\n      if (binv->lux != NULL && binv->lux->n != m)\n      {  lux_delete(binv->lux);\n         binv->lux = NULL;\n      }\n      if (binv->lux == NULL)\n         binv->lux = lux_create(m);\n      ret = lux_decomp(binv->lux, col, info);\n      binv->valid = (ret == 0);\n      return ret;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "bfx_ftran": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void bfx_ftran(BFX *binv, mpq_t x[], int save)\n{     /* perform forward transformation (FTRAN) */\n      xassert(binv->valid);\n      lux_solve(binv->lux, 0, x);\n      xassert(save == save);\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "bfx_btran": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void bfx_btran(BFX *binv, mpq_t x[])\n{     /* perform backward transformation (BTRAN) */\n      xassert(binv->valid);\n      lux_solve(binv->lux, 1, x);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "bfx_update": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int bfx_update(BFX *binv, int j)\n{     /* update factorization of the basis matrix */\n      xassert(binv->valid);\n      xassert(1 <= j && j <= binv->lux->n);\n      return 1;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "bfx_delete_binv": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void bfx_delete_binv(BFX *binv)\n{     /* delete factorization of the basis matrix */\n      if (binv->lux != NULL)\n         lux_delete(binv->lux);\n      xfree(binv);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/bfx.h": {},
  "glpk/glpk-4.65/src/draft/draft.h": {},
  "glpk/glpk-4.65/src/draft/glpapi06.c": {
    "trivial_lp": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static void trivial_lp(glp_prob *P, const glp_smcp *parm)\n{     /* solve trivial LP which has empty constraint matrix */\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j;\n      double p_infeas, d_infeas, zeta;\n      P->valid = 0;\n      P->pbs_stat = P->dbs_stat = GLP_FEAS;\n      P->obj_val = P->c0;\n      P->some = 0;\n      p_infeas = d_infeas = 0.0;\n      /* make all auxiliary variables basic */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         row->stat = GLP_BS;\n         row->prim = row->dual = 0.0;\n         /* check primal feasibility */\n         if (row->type == GLP_LO || row->type == GLP_DB ||\n             row->type == GLP_FX)\n         {  /* row has lower bound */\n            if (row->lb > + parm->tol_bnd)\n            {  P->pbs_stat = GLP_NOFEAS;\n               if (P->some == 0 && parm->meth != GLP_PRIMAL)\n                  P->some = i;\n            }\n            if (p_infeas < + row->lb)\n               p_infeas = + row->lb;\n         }\n         if (row->type == GLP_UP || row->type == GLP_DB ||\n             row->type == GLP_FX)\n         {  /* row has upper bound */\n            if (row->ub < - parm->tol_bnd)\n            {  P->pbs_stat = GLP_NOFEAS;\n               if (P->some == 0 && parm->meth != GLP_PRIMAL)\n                  P->some = i;\n            }\n            if (p_infeas < - row->ub)\n               p_infeas = - row->ub;\n         }\n      }\n      /* determine scale factor for the objective row */\n      zeta = 1.0;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (zeta < fabs(col->coef)) zeta = fabs(col->coef);\n      }\n      zeta = (P->dir == GLP_MIN ? +1.0 : -1.0) / zeta;\n      /* make all structural variables non-basic */\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->type == GLP_FR)\n            col->stat = GLP_NF, col->prim = 0.0;\n         else if (col->type == GLP_LO)\nlo:         col->stat = GLP_NL, col->prim = col->lb;\n         else if (col->type == GLP_UP)\nup:         col->stat = GLP_NU, col->prim = col->ub;\n         else if (col->type == GLP_DB)\n         {  if (zeta * col->coef > 0.0)\n               goto lo;\n            else if (zeta * col->coef < 0.0)\n               goto up;\n            else if (fabs(col->lb) <= fabs(col->ub))\n               goto lo;\n            else\n               goto up;\n         }\n         else if (col->type == GLP_FX)\n            col->stat = GLP_NS, col->prim = col->lb;\n         col->dual = col->coef;\n         P->obj_val += col->coef * col->prim;\n         /* check dual feasibility */\n         if (col->type == GLP_FR || col->type == GLP_LO)\n         {  /* column has no upper bound */\n            if (zeta * col->dual < - parm->tol_dj)\n            {  P->dbs_stat = GLP_NOFEAS;\n               if (P->some == 0 && parm->meth == GLP_PRIMAL)\n                  P->some = P->m + j;\n            }\n            if (d_infeas < - zeta * col->dual)\n               d_infeas = - zeta * col->dual;\n         }\n         if (col->type == GLP_FR || col->type == GLP_UP)\n         {  /* column has no lower bound */\n            if (zeta * col->dual > + parm->tol_dj)\n            {  P->dbs_stat = GLP_NOFEAS;\n               if (P->some == 0 && parm->meth == GLP_PRIMAL)\n                  P->some = P->m + j;\n            }\n            if (d_infeas < + zeta * col->dual)\n               d_infeas = + zeta * col->dual;\n         }\n      }\n      /* simulate the simplex solver output */\n      if (parm->msg_lev >= GLP_MSG_ON && parm->out_dly == 0)\n      {  xprintf(\"~%6d: obj = %17.9e  infeas = %10.3e\\n\", P->it_cnt,\n            P->obj_val, parm->meth == GLP_PRIMAL ? p_infeas : d_infeas);\n      }\n      if (parm->msg_lev >= GLP_MSG_ALL && parm->out_dly == 0)\n      {  if (P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS)\n            xprintf(\"OPTIMAL SOLUTION FOUND\\n\");\n         else if (P->pbs_stat == GLP_NOFEAS)\n            xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\\n\");\n         else if (parm->meth == GLP_PRIMAL)\n            xprintf(\"PROBLEM HAS UNBOUNDED SOLUTION\\n\");\n         else\n            xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\\n\");\n      }\n      return;\n}",
      "lines": 109,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "solve_lp": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static int solve_lp(glp_prob *P, const glp_smcp *parm)\n{     /* solve LP directly without using the preprocessor */\n      int ret;\n      if (!glp_bf_exists(P))\n      {  ret = glp_factorize(P);\n         if (ret == 0)\n            ;\n         else if (ret == GLP_EBADB)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_simplex: initial basis is invalid\\n\");\n         }\n         else if (ret == GLP_ESING)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_simplex: initial basis is singular\\n\");\n         }\n         else if (ret == GLP_ECOND)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\n                  \"glp_simplex: initial basis is ill-conditioned\\n\");\n         }\n         else\n            xassert(ret != ret);\n         if (ret != 0) goto done;\n      }\n      if (parm->meth == GLP_PRIMAL)\n         ret = spx_primal(P, parm);\n      else if (parm->meth == GLP_DUALP)\n      {  ret = spx_dual(P, parm);\n         if (ret == GLP_EFAIL && P->valid)\n            ret = spx_primal(P, parm);\n      }\n      else if (parm->meth == GLP_DUAL)\n         ret = spx_dual(P, parm);\n      else\n         xassert(parm != parm);\ndone: return ret;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "preprocess_and_solve_lp": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static int preprocess_and_solve_lp(glp_prob *P, const glp_smcp *parm)\n{     /* solve LP using the preprocessor */\n      NPP *npp;\n      glp_prob *lp = NULL;\n      glp_bfcp bfcp;\n      int ret;\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Preprocessing...\\n\");\n      /* create preprocessor workspace */\n      npp = npp_create_wksp();\n      /* load original problem into the preprocessor workspace */\n      npp_load_prob(npp, P, GLP_OFF, GLP_SOL, GLP_OFF);\n      /* process LP prior to applying primal/dual simplex method */\n      ret = npp_simplex(npp, parm);\n      if (ret == 0)\n         ;\n      else if (ret == GLP_ENOPFS)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\\n\");\n      }\n      else if (ret == GLP_ENODFS)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\\n\");\n      }\n      else\n         xassert(ret != ret);\n      if (ret != 0) goto done;\n      /* build transformed LP */\n      lp = glp_create_prob();\n      npp_build_prob(npp, lp);\n      /* if the transformed LP is empty, it has empty solution, which\n         is optimal */\n      if (lp->m == 0 && lp->n == 0)\n      {  lp->pbs_stat = lp->dbs_stat = GLP_FEAS;\n         lp->obj_val = lp->c0;\n         if (parm->msg_lev >= GLP_MSG_ON && parm->out_dly == 0)\n         {  xprintf(\"~%6d: obj = %17.9e  infeas = %10.3e\\n\", P->it_cnt,\n               lp->obj_val, 0.0);\n         }\n         if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"OPTIMAL SOLUTION FOUND BY LP PREPROCESSOR\\n\");\n         goto post;\n      }\n      if (parm->msg_lev >= GLP_MSG_ALL)\n      {  xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n            lp->m, lp->m == 1 ? \"\" : \"s\", lp->n, lp->n == 1 ? \"\" : \"s\",\n            lp->nnz, lp->nnz == 1 ? \"\" : \"s\");\n      }\n      /* inherit basis factorization control parameters */\n      glp_get_bfcp(P, &bfcp);\n      glp_set_bfcp(lp, &bfcp);\n      /* scale the transformed problem */\n      {  ENV *env = get_env_ptr();\n         int term_out = env->term_out;\n         if (!term_out || parm->msg_lev < GLP_MSG_ALL)\n            env->term_out = GLP_OFF;\n         else\n            env->term_out = GLP_ON;\n         glp_scale_prob(lp, GLP_SF_AUTO);\n         env->term_out = term_out;\n      }\n      /* build advanced initial basis */\n      {  ENV *env = get_env_ptr();\n         int term_out = env->term_out;\n         if (!term_out || parm->msg_lev < GLP_MSG_ALL)\n            env->term_out = GLP_OFF;\n         else\n            env->term_out = GLP_ON;\n         glp_adv_basis(lp, 0);\n         env->term_out = term_out;\n      }\n      /* solve the transformed LP */\n      lp->it_cnt = P->it_cnt;\n      ret = solve_lp(lp, parm);\n      P->it_cnt = lp->it_cnt;\n      /* only optimal solution can be postprocessed */\n      if (!(ret == 0 && lp->pbs_stat == GLP_FEAS && lp->dbs_stat ==\n            GLP_FEAS))\n      {  if (parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"glp_simplex: unable to recover undefined or non-op\"\n               \"timal solution\\n\");\n         if (ret == 0)\n         {  if (lp->pbs_stat == GLP_NOFEAS)\n               ret = GLP_ENOPFS;\n            else if (lp->dbs_stat == GLP_NOFEAS)\n               ret = GLP_ENODFS;\n            else\n               xassert(lp != lp);\n         }\n         goto done;\n      }\npost: /* postprocess solution from the transformed LP */\n      npp_postprocess(npp, lp);\n      /* the transformed LP is no longer needed */\n      glp_delete_prob(lp), lp = NULL;\n      /* store solution to the original problem */\n      npp_unload_sol(npp, P);\n      /* the original LP has been successfully solved */\n      ret = 0;\ndone: /* delete the transformed LP, if it exists */\n      if (lp != NULL) glp_delete_prob(lp);\n      /* delete preprocessor workspace */\n      npp_delete_wksp(npp);\n      return ret;\n}",
      "lines": 105,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_simplex": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        482,
        1
      ],
      "content": "int glp_simplex(glp_prob *P, const glp_smcp *parm)\n{     /* solve LP problem with the simplex method */\n      glp_smcp _parm;\n      int i, j, ret;\n      /* check problem object */\n#if 0 /* 04/IV-2016 */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_simplex: P = %p; invalid problem object\\n\", P);\n#endif\n      if (P->tree != NULL && P->tree->reason != 0)\n         xerror(\"glp_simplex: operation not allowed\\n\");\n      /* check control parameters */\n      if (parm == NULL)\n         parm = &_parm, glp_init_smcp((glp_smcp *)parm);\n      if (!(parm->msg_lev == GLP_MSG_OFF ||\n            parm->msg_lev == GLP_MSG_ERR ||\n            parm->msg_lev == GLP_MSG_ON  ||\n            parm->msg_lev == GLP_MSG_ALL ||\n            parm->msg_lev == GLP_MSG_DBG))\n         xerror(\"glp_simplex: msg_lev = %d; invalid parameter\\n\",\n            parm->msg_lev);\n      if (!(parm->meth == GLP_PRIMAL ||\n            parm->meth == GLP_DUALP  ||\n            parm->meth == GLP_DUAL))\n         xerror(\"glp_simplex: meth = %d; invalid parameter\\n\",\n            parm->meth);\n      if (!(parm->pricing == GLP_PT_STD ||\n            parm->pricing == GLP_PT_PSE))\n         xerror(\"glp_simplex: pricing = %d; invalid parameter\\n\",\n            parm->pricing);\n      if (!(parm->r_test == GLP_RT_STD ||\n#if 1 /* 16/III-2016 */\n            parm->r_test == GLP_RT_FLIP ||\n#endif\n            parm->r_test == GLP_RT_HAR))\n         xerror(\"glp_simplex: r_test = %d; invalid parameter\\n\",\n            parm->r_test);\n      if (!(0.0 < parm->tol_bnd && parm->tol_bnd < 1.0))\n         xerror(\"glp_simplex: tol_bnd = %g; invalid parameter\\n\",\n            parm->tol_bnd);\n      if (!(0.0 < parm->tol_dj && parm->tol_dj < 1.0))\n         xerror(\"glp_simplex: tol_dj = %g; invalid parameter\\n\",\n            parm->tol_dj);\n      if (!(0.0 < parm->tol_piv && parm->tol_piv < 1.0))\n         xerror(\"glp_simplex: tol_piv = %g; invalid parameter\\n\",\n            parm->tol_piv);\n      if (parm->it_lim < 0)\n         xerror(\"glp_simplex: it_lim = %d; invalid parameter\\n\",\n            parm->it_lim);\n      if (parm->tm_lim < 0)\n         xerror(\"glp_simplex: tm_lim = %d; invalid parameter\\n\",\n            parm->tm_lim);\n#if 0 /* 15/VII-2017 */\n      if (parm->out_frq < 1)\n#else\n      if (parm->out_frq < 0)\n#endif\n         xerror(\"glp_simplex: out_frq = %d; invalid parameter\\n\",\n            parm->out_frq);\n      if (parm->out_dly < 0)\n         xerror(\"glp_simplex: out_dly = %d; invalid parameter\\n\",\n            parm->out_dly);\n      if (!(parm->presolve == GLP_ON || parm->presolve == GLP_OFF))\n         xerror(\"glp_simplex: presolve = %d; invalid parameter\\n\",\n            parm->presolve);\n#if 1 /* 11/VII-2017 */\n      if (!(parm->excl == GLP_ON || parm->excl == GLP_OFF))\n         xerror(\"glp_simplex: excl = %d; invalid parameter\\n\",\n            parm->excl);\n      if (!(parm->shift == GLP_ON || parm->shift == GLP_OFF))\n         xerror(\"glp_simplex: shift = %d; invalid parameter\\n\",\n            parm->shift);\n      if (!(parm->aorn == GLP_USE_AT || parm->aorn == GLP_USE_NT))\n         xerror(\"glp_simplex: aorn = %d; invalid parameter\\n\",\n            parm->aorn);\n#endif\n      /* basic solution is currently undefined */\n      P->pbs_stat = P->dbs_stat = GLP_UNDEF;\n      P->obj_val = 0.0;\n      P->some = 0;\n      /* check bounds of double-bounded variables */\n      for (i = 1; i <= P->m; i++)\n      {  GLPROW *row = P->row[i];\n         if (row->type == GLP_DB && row->lb >= row->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_simplex: row %d: lb = %g, ub = %g; incorrec\"\n                  \"t bounds\\n\", i, row->lb, row->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if (col->type == GLP_DB && col->lb >= col->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_simplex: column %d: lb = %g, ub = %g; incor\"\n                  \"rect bounds\\n\", j, col->lb, col->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      /* solve LP problem */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n      {  xprintf(\"GLPK Simplex Optimizer, v%s\\n\", glp_version());\n         xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n            P->m, P->m == 1 ? \"\" : \"s\", P->n, P->n == 1 ? \"\" : \"s\",\n            P->nnz, P->nnz == 1 ? \"\" : \"s\");\n      }\n      if (P->nnz == 0)\n         trivial_lp(P, parm), ret = 0;\n      else if (!parm->presolve)\n         ret = solve_lp(P, parm);\n      else\n         ret = preprocess_and_solve_lp(P, parm);\ndone: /* return to the application program */\n      return ret;\n}",
      "lines": 117,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glp_init_smcp": {
      "start_point": [
        501,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "void glp_init_smcp(glp_smcp *parm)\n{     parm->msg_lev = GLP_MSG_ALL;\n      parm->meth = GLP_PRIMAL;\n      parm->pricing = GLP_PT_PSE;\n      parm->r_test = GLP_RT_HAR;\n      parm->tol_bnd = 1e-7;\n      parm->tol_dj = 1e-7;\n#if 0 /* 07/XI-2015 */\n      parm->tol_piv = 1e-10;\n#else\n      parm->tol_piv = 1e-9;\n#endif\n      parm->obj_ll = -DBL_MAX;\n      parm->obj_ul = +DBL_MAX;\n      parm->it_lim = INT_MAX;\n      parm->tm_lim = INT_MAX;\n#if 0 /* 15/VII-2017 */\n      parm->out_frq = 500;\n#else\n      parm->out_frq = 5000; /* 5 seconds */\n#endif\n      parm->out_dly = 0;\n      parm->presolve = GLP_OFF;\n#if 1 /* 11/VII-2017 */\n      parm->excl = GLP_ON;\n      parm->shift = GLP_ON;\n      parm->aorn = GLP_USE_NT;\n#endif\n      return;\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_get_status": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "int glp_get_status(glp_prob *lp)\n{     int status;\n      status = glp_get_prim_stat(lp);\n      switch (status)\n      {  case GLP_FEAS:\n            switch (glp_get_dual_stat(lp))\n            {  case GLP_FEAS:\n                  status = GLP_OPT;\n                  break;\n               case GLP_NOFEAS:\n                  status = GLP_UNBND;\n                  break;\n               case GLP_UNDEF:\n               case GLP_INFEAS:\n                  status = status;\n                  break;\n               default:\n                  xassert(lp != lp);\n            }\n            break;\n         case GLP_UNDEF:\n         case GLP_INFEAS:\n         case GLP_NOFEAS:\n            status = status;\n            break;\n         default:\n            xassert(lp != lp);\n      }\n      return status;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_get_prim_stat": {
      "start_point": [
        603,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "int glp_get_prim_stat(glp_prob *lp)\n{     int pbs_stat = lp->pbs_stat;\n      return pbs_stat;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_dual_stat": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        630,
        1
      ],
      "content": "int glp_get_dual_stat(glp_prob *lp)\n{     int dbs_stat = lp->dbs_stat;\n      return dbs_stat;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_get_obj_val": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        652,
        1
      ],
      "content": "double glp_get_obj_val(glp_prob *lp)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double z;\n      z = lp->obj_val;\n      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/\n      return z;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "glp_get_row_stat": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "int glp_get_row_stat(glp_prob *lp, int i)\n{     if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_stat: i = %d; row number out of range\\n\",\n            i);\n      return lp->row[i]->stat;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_row_prim": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        704,
        1
      ],
      "content": "double glp_get_row_prim(glp_prob *lp, int i)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double prim;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_prim: i = %d; row number out of range\\n\",\n            i);\n      prim = lp->row[i]->prim;\n      /*if (cps->round && fabs(prim) < 1e-9) prim = 0.0;*/\n      return prim;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_row_dual": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        729,
        1
      ],
      "content": "double glp_get_row_dual(glp_prob *lp, int i)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double dual;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_dual: i = %d; row number out of range\\n\",\n            i);\n      dual = lp->row[i]->dual;\n      /*if (cps->round && fabs(dual) < 1e-9) dual = 0.0;*/\n      return dual;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_col_stat": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        756,
        1
      ],
      "content": "int glp_get_col_stat(glp_prob *lp, int j)\n{     if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_stat: j = %d; column number out of range\\n\"\n            , j);\n      return lp->col[j]->stat;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_col_prim": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "double glp_get_col_prim(glp_prob *lp, int j)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double prim;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_prim: j = %d; column number out of range\\n\"\n            , j);\n      prim = lp->col[j]->prim;\n      /*if (cps->round && fabs(prim) < 1e-9) prim = 0.0;*/\n      return prim;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_col_dual": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "double glp_get_col_dual(glp_prob *lp, int j)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double dual;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_dual: j = %d; column number out of range\\n\"\n            , j);\n      dual = lp->col[j]->dual;\n      /*if (cps->round && fabs(dual) < 1e-9) dual = 0.0;*/\n      return dual;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_get_unbnd_ray": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "int glp_get_unbnd_ray(glp_prob *lp)\n{     int k;\n      k = lp->some;\n      xassert(k >= 0);\n      if (k > lp->m + lp->n) k = 0;\n      return k;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glp_get_it_cnt": {
      "start_point": [
        845,
        0
      ],
      "end_point": [
        848,
        1
      ],
      "content": "int glp_get_it_cnt(glp_prob *P)\n{     /* get simplex solver iteration count */\n      return P->it_cnt;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_set_it_cnt": {
      "start_point": [
        852,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "void glp_set_it_cnt(glp_prob *P, int it_cnt)\n{     /* set simplex solver iteration count */\n      P->it_cnt = it_cnt;\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpapi07.c": {
    "set_d_eps": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void set_d_eps(mpq_t x, double val)\n{     /* convert double val to rational x obtaining a more adequate\n         fraction than provided by mpq_set_d due to allowing a small\n         approximation error specified by a given relative tolerance;\n         for example, mpq_set_d would give the following\n         1/3 ~= 0.333333333333333314829616256247391... ->\n             -> 6004799503160661/18014398509481984\n         while this routine gives exactly 1/3 */\n      int s, n, j;\n      double f, p, q, eps = 1e-9;\n      mpq_t temp;\n      xassert(-DBL_MAX <= val && val <= +DBL_MAX);\n#if 1 /* 30/VII-2008 */\n      if (val == floor(val))\n      {  /* if val is integral, do not approximate */\n         mpq_set_d(x, val);\n         goto done;\n      }\n#endif\n      if (val > 0.0)\n         s = +1;\n      else if (val < 0.0)\n         s = -1;\n      else\n      {  mpq_set_si(x, 0, 1);\n         goto done;\n      }\n      f = frexp(fabs(val), &n);\n      /* |val| = f * 2^n, where 0.5 <= f < 1.0 */\n      fp2rat(f, 0.1 * eps, &p, &q);\n      /* f ~= p / q, where p and q are integers */\n      mpq_init(temp);\n      mpq_set_d(x, p);\n      mpq_set_d(temp, q);\n      mpq_div(x, x, temp);\n      mpq_set_si(temp, 1, 1);\n      for (j = 1; j <= abs(n); j++)\n         mpq_add(temp, temp, temp);\n      if (n > 0)\n         mpq_mul(x, x, temp);\n      else if (n < 0)\n         mpq_div(x, x, temp);\n      mpq_clear(temp);\n      if (s < 0) mpq_neg(x, x);\n      /* check that the desired tolerance has been attained */\n      xassert(fabs(val - mpq_get_d(x)) <= eps * (1.0 + fabs(val)));\ndone: return;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "load_data": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void load_data(SSX *ssx, glp_prob *lp)\n{     /* load LP problem data into simplex solver workspace */\n      int m = ssx->m;\n      int n = ssx->n;\n      int nnz = ssx->A_ptr[n+1]-1;\n      int j, k, type, loc, len, *ind;\n      double lb, ub, coef, *val;\n      xassert(lp->m == m);\n      xassert(lp->n == n);\n      xassert(lp->nnz == nnz);\n      /* types and bounds of rows and columns */\n      for (k = 1; k <= m+n; k++)\n      {  if (k <= m)\n         {  type = lp->row[k]->type;\n            lb = lp->row[k]->lb;\n            ub = lp->row[k]->ub;\n         }\n         else\n         {  type = lp->col[k-m]->type;\n            lb = lp->col[k-m]->lb;\n            ub = lp->col[k-m]->ub;\n         }\n         switch (type)\n         {  case GLP_FR: type = SSX_FR; break;\n            case GLP_LO: type = SSX_LO; break;\n            case GLP_UP: type = SSX_UP; break;\n            case GLP_DB: type = SSX_DB; break;\n            case GLP_FX: type = SSX_FX; break;\n            default: xassert(type != type);\n         }\n         ssx->type[k] = type;\n         set_d_eps(ssx->lb[k], lb);\n         set_d_eps(ssx->ub[k], ub);\n      }\n      /* optimization direction */\n      switch (lp->dir)\n      {  case GLP_MIN: ssx->dir = SSX_MIN; break;\n         case GLP_MAX: ssx->dir = SSX_MAX; break;\n         default: xassert(lp != lp);\n      }\n      /* objective coefficients */\n      for (k = 0; k <= m+n; k++)\n      {  if (k == 0)\n            coef = lp->c0;\n         else if (k <= m)\n            coef = 0.0;\n         else\n            coef = lp->col[k-m]->coef;\n         set_d_eps(ssx->coef[k], coef);\n      }\n      /* constraint coefficients */\n      ind = xcalloc(1+m, sizeof(int));\n      val = xcalloc(1+m, sizeof(double));\n      loc = 0;\n      for (j = 1; j <= n; j++)\n      {  ssx->A_ptr[j] = loc+1;\n         len = glp_get_mat_col(lp, j, ind, val);\n         for (k = 1; k <= len; k++)\n         {  loc++;\n            ssx->A_ind[loc] = ind[k];\n            set_d_eps(ssx->A_val[loc], val[k]);\n         }\n      }\n      xassert(loc == nnz);\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "load_basis": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static int load_basis(SSX *ssx, glp_prob *lp)\n{     /* load current LP basis into simplex solver workspace */\n      int m = ssx->m;\n      int n = ssx->n;\n      int *type = ssx->type;\n      int *stat = ssx->stat;\n      int *Q_row = ssx->Q_row;\n      int *Q_col = ssx->Q_col;\n      int i, j, k;\n      xassert(lp->m == m);\n      xassert(lp->n == n);\n      /* statuses of rows and columns */\n      for (k = 1; k <= m+n; k++)\n      {  if (k <= m)\n            stat[k] = lp->row[k]->stat;\n         else\n            stat[k] = lp->col[k-m]->stat;\n         switch (stat[k])\n         {  case GLP_BS:\n               stat[k] = SSX_BS;\n               break;\n            case GLP_NL:\n               stat[k] = SSX_NL;\n               xassert(type[k] == SSX_LO || type[k] == SSX_DB);\n               break;\n            case GLP_NU:\n               stat[k] = SSX_NU;\n               xassert(type[k] == SSX_UP || type[k] == SSX_DB);\n               break;\n            case GLP_NF:\n               stat[k] = SSX_NF;\n               xassert(type[k] == SSX_FR);\n               break;\n            case GLP_NS:\n               stat[k] = SSX_NS;\n               xassert(type[k] == SSX_FX);\n               break;\n            default:\n               xassert(stat != stat);\n         }\n      }\n      /* build permutation matix Q */\n      i = j = 0;\n      for (k = 1; k <= m+n; k++)\n      {  if (stat[k] == SSX_BS)\n         {  i++;\n            if (i > m) return 1;\n            Q_row[k] = i, Q_col[i] = k;\n         }\n         else\n         {  j++;\n            if (j > n) return 1;\n            Q_row[k] = m+j, Q_col[m+j] = k;\n         }\n      }\n      xassert(i == m && j == n);\n      return 0;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpapi08.c": {
    "transform": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static void transform(NPP *npp)\n{     /* transform LP to the standard formulation */\n      NPPROW *row, *prev_row;\n      NPPCOL *col, *prev_col;\n      for (row = npp->r_tail; row != NULL; row = prev_row)\n      {  prev_row = row->prev;\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n            npp_free_row(npp, row);\n         else if (row->lb == -DBL_MAX)\n            npp_leq_row(npp, row);\n         else if (row->ub == +DBL_MAX)\n            npp_geq_row(npp, row);\n         else if (row->lb != row->ub)\n         {  if (fabs(row->lb) < fabs(row->ub))\n               npp_geq_row(npp, row);\n            else\n               npp_leq_row(npp, row);\n         }\n      }\n      for (col = npp->c_tail; col != NULL; col = prev_col)\n      {  prev_col = col->prev;\n         if (col->lb == -DBL_MAX && col->ub == +DBL_MAX)\n            npp_free_col(npp, col);\n         else if (col->lb == -DBL_MAX)\n            npp_ubnd_col(npp, col);\n         else if (col->ub == +DBL_MAX)\n         {  if (col->lb != 0.0)\n               npp_lbnd_col(npp, col);\n         }\n         else if (col->lb != col->ub)\n         {  if (fabs(col->lb) < fabs(col->ub))\n            {  if (col->lb != 0.0)\n                  npp_lbnd_col(npp, col);\n            }\n            else\n               npp_ubnd_col(npp, col);\n            npp_dbnd_col(npp, col);\n         }\n         else\n            npp_fixed_col(npp, col);\n      }\n      for (row = npp->r_head; row != NULL; row = row->next)\n         xassert(row->lb == row->ub);\n      for (col = npp->c_head; col != NULL; col = col->next)\n         xassert(col->lb == 0.0 && col->ub == +DBL_MAX);\n      return;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_interior": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int glp_interior(glp_prob *P, const glp_iptcp *parm)\n{     glp_iptcp _parm;\n      GLPROW *row;\n      GLPCOL *col;\n      NPP *npp = NULL;\n      glp_prob *prob = NULL;\n      int i, j, ret;\n      /* check control parameters */\n      if (parm == NULL)\n         glp_init_iptcp(&_parm), parm = &_parm;\n      if (!(parm->msg_lev == GLP_MSG_OFF ||\n            parm->msg_lev == GLP_MSG_ERR ||\n            parm->msg_lev == GLP_MSG_ON  ||\n            parm->msg_lev == GLP_MSG_ALL))\n         xerror(\"glp_interior: msg_lev = %d; invalid parameter\\n\",\n            parm->msg_lev);\n      if (!(parm->ord_alg == GLP_ORD_NONE ||\n            parm->ord_alg == GLP_ORD_QMD ||\n            parm->ord_alg == GLP_ORD_AMD ||\n            parm->ord_alg == GLP_ORD_SYMAMD))\n         xerror(\"glp_interior: ord_alg = %d; invalid parameter\\n\",\n            parm->ord_alg);\n      /* interior-point solution is currently undefined */\n      P->ipt_stat = GLP_UNDEF;\n      P->ipt_obj = 0.0;\n      /* check bounds of double-bounded variables */\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->type == GLP_DB && row->lb >= row->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_interior: row %d: lb = %g, ub = %g; incorre\"\n                  \"ct bounds\\n\", i, row->lb, row->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->type == GLP_DB && col->lb >= col->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_interior: column %d: lb = %g, ub = %g; inco\"\n                  \"rrect bounds\\n\", j, col->lb, col->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      /* transform LP to the standard formulation */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Original LP has %d row(s), %d column(s), and %d non-z\"\n            \"ero(s)\\n\", P->m, P->n, P->nnz);\n      npp = npp_create_wksp();\n      npp_load_prob(npp, P, GLP_OFF, GLP_IPT, GLP_ON);\n      transform(npp);\n      prob = glp_create_prob();\n      npp_build_prob(npp, prob);\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Working LP has %d row(s), %d column(s), and %d non-ze\"\n            \"ro(s)\\n\", prob->m, prob->n, prob->nnz);\n#if 1\n      /* currently empty problem cannot be solved */\n      if (!(prob->m > 0 && prob->n > 0))\n      {  if (parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"glp_interior: unable to solve empty problem\\n\");\n         ret = GLP_EFAIL;\n         goto done;\n      }\n#endif\n      /* scale the resultant LP */\n      {  ENV *env = get_env_ptr();\n         int term_out = env->term_out;\n         env->term_out = GLP_OFF;\n         glp_scale_prob(prob, GLP_SF_EQ);\n         env->term_out = term_out;\n      }\n      /* warn about dense columns */\n      if (parm->msg_lev >= GLP_MSG_ON && prob->m >= 200)\n      {  int len, cnt = 0;\n         for (j = 1; j <= prob->n; j++)\n         {  len = glp_get_mat_col(prob, j, NULL, NULL);\n            if ((double)len >= 0.20 * (double)prob->m) cnt++;\n         }\n         if (cnt == 1)\n            xprintf(\"WARNING: PROBLEM HAS ONE DENSE COLUMN\\n\");\n         else if (cnt > 0)\n            xprintf(\"WARNING: PROBLEM HAS %d DENSE COLUMNS\\n\", cnt);\n      }\n      /* solve the transformed LP */\n      ret = ipm_solve(prob, parm);\n      /* postprocess solution from the transformed LP */\n      npp_postprocess(npp, prob);\n      /* and store solution to the original LP */\n      npp_unload_sol(npp, P);\ndone: /* free working program objects */\n      if (npp != NULL) npp_delete_wksp(npp);\n      if (prob != NULL) glp_delete_prob(prob);\n      /* return to the application program */\n      return ret;\n}",
      "lines": 98,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_init_iptcp": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "void glp_init_iptcp(glp_iptcp *parm)\n{     parm->msg_lev = GLP_MSG_ALL;\n      parm->ord_alg = GLP_ORD_AMD;\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "glp_ipt_status": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "int glp_ipt_status(glp_prob *lp)\n{     int ipt_stat = lp->ipt_stat;\n      return ipt_stat;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_ipt_obj_val": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "double glp_ipt_obj_val(glp_prob *lp)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double z;\n      z = lp->ipt_obj;\n      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/\n      return z;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "glp_ipt_row_prim": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "double glp_ipt_row_prim(glp_prob *lp, int i)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double pval;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_ipt_row_prim: i = %d; row number out of range\\n\",\n            i);\n      pval = lp->row[i]->pval;\n      /*if (cps->round && fabs(pval) < 1e-9) pval = 0.0;*/\n      return pval;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_ipt_row_dual": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "double glp_ipt_row_dual(glp_prob *lp, int i)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double dval;\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_ipt_row_dual: i = %d; row number out of range\\n\",\n            i);\n      dval = lp->row[i]->dval;\n      /*if (cps->round && fabs(dval) < 1e-9) dval = 0.0;*/\n      return dval;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_ipt_col_prim": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "double glp_ipt_col_prim(glp_prob *lp, int j)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double pval;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_ipt_col_prim: j = %d; column number out of range\\n\"\n            , j);\n      pval = lp->col[j]->pval;\n      /*if (cps->round && fabs(pval) < 1e-9) pval = 0.0;*/\n      return pval;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_ipt_col_dual": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "double glp_ipt_col_dual(glp_prob *lp, int j)\n{     /*struct LPXCPS *cps = lp->cps;*/\n      double dval;\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_ipt_col_dual: j = %d; column number out of range\\n\"\n            , j);\n      dval = lp->col[j]->dval;\n      /*if (cps->round && fabs(dval) < 1e-9) dval = 0.0;*/\n      return dval;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpapi09.c": {
    "glp_set_col_kind": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void glp_set_col_kind(glp_prob *mip, int j, int kind)\n{     GLPCOL *col;\n      if (!(1 <= j && j <= mip->n))\n         xerror(\"glp_set_col_kind: j = %d; column number out of range\\n\"\n            , j);\n      col = mip->col[j];\n      switch (kind)\n      {  case GLP_CV:\n            col->kind = GLP_CV;\n            break;\n         case GLP_IV:\n            col->kind = GLP_IV;\n            break;\n         case GLP_BV:\n            col->kind = GLP_IV;\n            if (!(col->type == GLP_DB && col->lb == 0.0 && col->ub ==\n               1.0)) glp_set_col_bnds(mip, j, GLP_DB, 0.0, 1.0);\n            break;\n         default:\n            xerror(\"glp_set_col_kind: j = %d; kind = %d; invalid column\"\n               \" kind\\n\", j, kind);\n      }\n      return;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "glp_get_col_kind": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int glp_get_col_kind(glp_prob *mip, int j)\n{     GLPCOL *col;\n      int kind;\n      if (!(1 <= j && j <= mip->n))\n         xerror(\"glp_get_col_kind: j = %d; column number out of range\\n\"\n            , j);\n      col = mip->col[j];\n      kind = col->kind;\n      switch (kind)\n      {  case GLP_CV:\n            break;\n         case GLP_IV:\n            if (col->type == GLP_DB && col->lb == 0.0 && col->ub == 1.0)\n               kind = GLP_BV;\n            break;\n         default:\n            xassert(kind != kind);\n      }\n      return kind;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_get_num_int": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int glp_get_num_int(glp_prob *mip)\n{     GLPCOL *col;\n      int j, count = 0;\n      for (j = 1; j <= mip->n; j++)\n      {  col = mip->col[j];\n         if (col->kind == GLP_IV) count++;\n      }\n      return count;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glp_get_num_bin": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "int glp_get_num_bin(glp_prob *mip)\n{     GLPCOL *col;\n      int j, count = 0;\n      for (j = 1; j <= mip->n; j++)\n      {  col = mip->col[j];\n         if (col->kind == GLP_IV && col->type == GLP_DB && col->lb ==\n            0.0 && col->ub == 1.0) count++;\n      }\n      return count;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "solve_mip": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static int solve_mip(glp_prob *P, const glp_iocp *parm,\n      glp_prob *P0 /* problem passed to glp_intopt */,\n      NPP *npp /* preprocessor workspace or NULL */)\n#endif\n{     /* solve MIP directly without using the preprocessor */\n      glp_tree *T;\n      int ret;\n      /* optimal basis to LP relaxation must be provided */\n      if (glp_get_status(P) != GLP_OPT)\n      {  if (parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"glp_intopt: optimal basis to initial LP relaxation\"\n               \" not provided\\n\");\n         ret = GLP_EROOT;\n         goto done;\n      }\n      /* it seems all is ok */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Integer optimization begins...\\n\");\n      /* create the branch-and-bound tree */\n      T = ios_create_tree(P, parm);\n#if 1 /* 11/VII-2013 */\n      T->P = P0;\n      T->npp = npp;\n#endif\n      /* solve the problem instance */\n      ret = ios_driver(T);\n      /* delete the branch-and-bound tree */\n      ios_delete_tree(T);\n      /* analyze exit code reported by the mip driver */\n      if (ret == 0)\n      {  if (P->mip_stat == GLP_FEAS)\n         {  if (parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"INTEGER OPTIMAL SOLUTION FOUND\\n\");\n            P->mip_stat = GLP_OPT;\n         }\n         else\n         {  if (parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\\n\");\n            P->mip_stat = GLP_NOFEAS;\n         }\n      }\n      else if (ret == GLP_EMIPGAP)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINA\"\n               \"TED\\n\");\n      }\n      else if (ret == GLP_ETMLIM)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\\n\");\n      }\n      else if (ret == GLP_EFAIL)\n      {  if (parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"glp_intopt: cannot solve current LP relaxation\\n\");\n      }\n      else if (ret == GLP_ESTOP)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"SEARCH TERMINATED BY APPLICATION\\n\");\n      }\n      else\n         xassert(ret != ret);\ndone: return ret;\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "preprocess_and_solve_mip": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static int preprocess_and_solve_mip(glp_prob *P, const glp_iocp *parm)\n{     /* solve MIP using the preprocessor */\n      ENV *env = get_env_ptr();\n      int term_out = env->term_out;\n      NPP *npp;\n      glp_prob *mip = NULL;\n      glp_bfcp bfcp;\n      glp_smcp smcp;\n      int ret;\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Preprocessing...\\n\");\n      /* create preprocessor workspace */\n      npp = npp_create_wksp();\n      /* load original problem into the preprocessor workspace */\n      npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);\n      /* process MIP prior to applying the branch-and-bound method */\n      if (!term_out || parm->msg_lev < GLP_MSG_ALL)\n         env->term_out = GLP_OFF;\n      else\n         env->term_out = GLP_ON;\n      ret = npp_integer(npp, parm);\n      env->term_out = term_out;\n      if (ret == 0)\n         ;\n      else if (ret == GLP_ENOPFS)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\\n\");\n      }\n      else if (ret == GLP_ENODFS)\n      {  if (parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION\\n\");\n      }\n      else\n         xassert(ret != ret);\n      if (ret != 0) goto done;\n      /* build transformed MIP */\n      mip = glp_create_prob();\n      npp_build_prob(npp, mip);\n      /* if the transformed MIP is empty, it has empty solution, which\n         is optimal */\n      if (mip->m == 0 && mip->n == 0)\n      {  mip->mip_stat = GLP_OPT;\n         mip->mip_obj = mip->c0;\n         if (parm->msg_lev >= GLP_MSG_ALL)\n         {  xprintf(\"Objective value = %17.9e\\n\", mip->mip_obj);\n            xprintf(\"INTEGER OPTIMAL SOLUTION FOUND BY MIP PREPROCESSOR\"\n               \"\\n\");\n         }\n         goto post;\n      }\n      /* display some statistics */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n      {  int ni = glp_get_num_int(mip);\n         int nb = glp_get_num_bin(mip);\n         char s[50];\n         xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n            mip->m, mip->m == 1 ? \"\" : \"s\", mip->n, mip->n == 1 ? \"\" :\n            \"s\", mip->nnz, mip->nnz == 1 ? \"\" : \"s\");\n         if (nb == 0)\n            strcpy(s, \"none of\");\n         else if (ni == 1 && nb == 1)\n            strcpy(s, \"\");\n         else if (nb == 1)\n            strcpy(s, \"one of\");\n         else if (nb == ni)\n            strcpy(s, \"all of\");\n         else\n            sprintf(s, \"%d of\", nb);\n         xprintf(\"%d integer variable%s, %s which %s binary\\n\",\n            ni, ni == 1 ? \"\" : \"s\", s, nb == 1 ? \"is\" : \"are\");\n      }\n      /* inherit basis factorization control parameters */\n      glp_get_bfcp(P, &bfcp);\n      glp_set_bfcp(mip, &bfcp);\n      /* scale the transformed problem */\n      if (!term_out || parm->msg_lev < GLP_MSG_ALL)\n         env->term_out = GLP_OFF;\n      else\n         env->term_out = GLP_ON;\n      glp_scale_prob(mip,\n         GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP);\n      env->term_out = term_out;\n      /* build advanced initial basis */\n      if (!term_out || parm->msg_lev < GLP_MSG_ALL)\n         env->term_out = GLP_OFF;\n      else\n         env->term_out = GLP_ON;\n      glp_adv_basis(mip, 0);\n      env->term_out = term_out;\n      /* solve initial LP relaxation */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Solving LP relaxation...\\n\");\n      glp_init_smcp(&smcp);\n      smcp.msg_lev = parm->msg_lev;\n      /* respect time limit */\n      smcp.tm_lim = parm->tm_lim;\n      mip->it_cnt = P->it_cnt;\n      ret = glp_simplex(mip, &smcp);\n      P->it_cnt = mip->it_cnt;\n      if (ret == GLP_ETMLIM)\n         goto done;\n      else if (ret != 0)\n      {  if (parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"glp_intopt: cannot solve LP relaxation\\n\");\n         ret = GLP_EFAIL;\n         goto done;\n      }\n      /* check status of the basic solution */\n      ret = glp_get_status(mip);\n      if (ret == GLP_OPT)\n         ret = 0;\n      else if (ret == GLP_NOFEAS)\n         ret = GLP_ENOPFS;\n      else if (ret == GLP_UNBND)\n         ret = GLP_ENODFS;\n      else\n         xassert(ret != ret);\n      if (ret != 0) goto done;\n      /* solve the transformed MIP */\n      mip->it_cnt = P->it_cnt;\n#if 0 /* 11/VII-2013 */\n      ret = solve_mip(mip, parm);\n#else\n      if (parm->use_sol)\n      {  mip->mip_stat = P->mip_stat;\n         mip->mip_obj = P->mip_obj;\n      }\n      ret = solve_mip(mip, parm, P, npp);\n#endif\n      P->it_cnt = mip->it_cnt;\n      /* only integer feasible solution can be postprocessed */\n      if (!(mip->mip_stat == GLP_OPT || mip->mip_stat == GLP_FEAS))\n      {  P->mip_stat = mip->mip_stat;\n         goto done;\n      }\n      /* postprocess solution from the transformed MIP */\npost: npp_postprocess(npp, mip);\n      /* the transformed MIP is no longer needed */\n      glp_delete_prob(mip), mip = NULL;\n      /* store solution to the original problem */\n      npp_unload_sol(npp, P);\ndone: /* delete the transformed MIP, if it exists */\n      if (mip != NULL) glp_delete_prob(mip);\n      /* delete preprocessor workspace */\n      npp_delete_wksp(npp);\n      return ret;\n}",
      "lines": 147,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_glp_intopt1": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "int _glp_intopt1(glp_prob *P, const glp_iocp *parm)\n{     xassert(P == P);\n      xassert(parm == parm);\n      xprintf(\"glp_intopt: no alien solver is available\\n\");\n      return GLP_EFAIL;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "glp_intopt": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "int glp_intopt(glp_prob *P, const glp_iocp *parm)\n{     /* solve MIP problem with the branch-and-bound method */\n      glp_iocp _parm;\n      int i, j, ret;\n#if 0 /* 04/IV-2016 */\n      /* check problem object */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_intopt: P = %p; invalid problem object\\n\", P);\n#endif\n      if (P->tree != NULL)\n         xerror(\"glp_intopt: operation not allowed\\n\");\n      /* check control parameters */\n      if (parm == NULL)\n         parm = &_parm, glp_init_iocp((glp_iocp *)parm);\n      if (!(parm->msg_lev == GLP_MSG_OFF ||\n            parm->msg_lev == GLP_MSG_ERR ||\n            parm->msg_lev == GLP_MSG_ON  ||\n            parm->msg_lev == GLP_MSG_ALL ||\n            parm->msg_lev == GLP_MSG_DBG))\n         xerror(\"glp_intopt: msg_lev = %d; invalid parameter\\n\",\n            parm->msg_lev);\n      if (!(parm->br_tech == GLP_BR_FFV ||\n            parm->br_tech == GLP_BR_LFV ||\n            parm->br_tech == GLP_BR_MFV ||\n            parm->br_tech == GLP_BR_DTH ||\n            parm->br_tech == GLP_BR_PCH))\n         xerror(\"glp_intopt: br_tech = %d; invalid parameter\\n\",\n            parm->br_tech);\n      if (!(parm->bt_tech == GLP_BT_DFS ||\n            parm->bt_tech == GLP_BT_BFS ||\n            parm->bt_tech == GLP_BT_BLB ||\n            parm->bt_tech == GLP_BT_BPH))\n         xerror(\"glp_intopt: bt_tech = %d; invalid parameter\\n\",\n            parm->bt_tech);\n      if (!(0.0 < parm->tol_int && parm->tol_int < 1.0))\n         xerror(\"glp_intopt: tol_int = %g; invalid parameter\\n\",\n            parm->tol_int);\n      if (!(0.0 < parm->tol_obj && parm->tol_obj < 1.0))\n         xerror(\"glp_intopt: tol_obj = %g; invalid parameter\\n\",\n            parm->tol_obj);\n      if (parm->tm_lim < 0)\n         xerror(\"glp_intopt: tm_lim = %d; invalid parameter\\n\",\n            parm->tm_lim);\n      if (parm->out_frq < 0)\n         xerror(\"glp_intopt: out_frq = %d; invalid parameter\\n\",\n            parm->out_frq);\n      if (parm->out_dly < 0)\n         xerror(\"glp_intopt: out_dly = %d; invalid parameter\\n\",\n            parm->out_dly);\n      if (!(0 <= parm->cb_size && parm->cb_size <= 256))\n         xerror(\"glp_intopt: cb_size = %d; invalid parameter\\n\",\n            parm->cb_size);\n      if (!(parm->pp_tech == GLP_PP_NONE ||\n            parm->pp_tech == GLP_PP_ROOT ||\n            parm->pp_tech == GLP_PP_ALL))\n         xerror(\"glp_intopt: pp_tech = %d; invalid parameter\\n\",\n            parm->pp_tech);\n      if (parm->mip_gap < 0.0)\n         xerror(\"glp_intopt: mip_gap = %g; invalid parameter\\n\",\n            parm->mip_gap);\n      if (!(parm->mir_cuts == GLP_ON || parm->mir_cuts == GLP_OFF))\n         xerror(\"glp_intopt: mir_cuts = %d; invalid parameter\\n\",\n            parm->mir_cuts);\n      if (!(parm->gmi_cuts == GLP_ON || parm->gmi_cuts == GLP_OFF))\n         xerror(\"glp_intopt: gmi_cuts = %d; invalid parameter\\n\",\n            parm->gmi_cuts);\n      if (!(parm->cov_cuts == GLP_ON || parm->cov_cuts == GLP_OFF))\n         xerror(\"glp_intopt: cov_cuts = %d; invalid parameter\\n\",\n            parm->cov_cuts);\n      if (!(parm->clq_cuts == GLP_ON || parm->clq_cuts == GLP_OFF))\n         xerror(\"glp_intopt: clq_cuts = %d; invalid parameter\\n\",\n            parm->clq_cuts);\n      if (!(parm->presolve == GLP_ON || parm->presolve == GLP_OFF))\n         xerror(\"glp_intopt: presolve = %d; invalid parameter\\n\",\n            parm->presolve);\n      if (!(parm->binarize == GLP_ON || parm->binarize == GLP_OFF))\n         xerror(\"glp_intopt: binarize = %d; invalid parameter\\n\",\n            parm->binarize);\n      if (!(parm->fp_heur == GLP_ON || parm->fp_heur == GLP_OFF))\n         xerror(\"glp_intopt: fp_heur = %d; invalid parameter\\n\",\n            parm->fp_heur);\n#if 1 /* 28/V-2010 */\n      if (!(parm->alien == GLP_ON || parm->alien == GLP_OFF))\n         xerror(\"glp_intopt: alien = %d; invalid parameter\\n\",\n            parm->alien);\n#endif\n#if 0 /* 11/VII-2013 */\n      /* integer solution is currently undefined */\n      P->mip_stat = GLP_UNDEF;\n      P->mip_obj = 0.0;\n#else\n      if (!parm->use_sol)\n         P->mip_stat = GLP_UNDEF;\n      if (P->mip_stat == GLP_NOFEAS)\n         P->mip_stat = GLP_UNDEF;\n      if (P->mip_stat == GLP_UNDEF)\n         P->mip_obj = 0.0;\n      else if (P->mip_stat == GLP_OPT)\n         P->mip_stat = GLP_FEAS;\n#endif\n      /* check bounds of double-bounded variables */\n      for (i = 1; i <= P->m; i++)\n      {  GLPROW *row = P->row[i];\n         if (row->type == GLP_DB && row->lb >= row->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_intopt: row %d: lb = %g, ub = %g; incorrect\"\n                  \" bounds\\n\", i, row->lb, row->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if (col->type == GLP_DB && col->lb >= col->ub)\n         {  if (parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"glp_intopt: column %d: lb = %g, ub = %g; incorr\"\n                  \"ect bounds\\n\", j, col->lb, col->ub);\n            ret = GLP_EBOUND;\n            goto done;\n         }\n      }\n      /* bounds of all integer variables must be integral */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if (col->kind != GLP_IV) continue;\n         if (col->type == GLP_LO || col->type == GLP_DB)\n         {  if (col->lb != floor(col->lb))\n            {  if (parm->msg_lev >= GLP_MSG_ERR)\n                  xprintf(\"glp_intopt: integer column %d has non-intege\"\n                     \"r lower bound %g\\n\", j, col->lb);\n               ret = GLP_EBOUND;\n               goto done;\n            }\n         }\n         if (col->type == GLP_UP || col->type == GLP_DB)\n         {  if (col->ub != floor(col->ub))\n            {  if (parm->msg_lev >= GLP_MSG_ERR)\n                  xprintf(\"glp_intopt: integer column %d has non-intege\"\n                     \"r upper bound %g\\n\", j, col->ub);\n               ret = GLP_EBOUND;\n               goto done;\n            }\n         }\n         if (col->type == GLP_FX)\n         {  if (col->lb != floor(col->lb))\n            {  if (parm->msg_lev >= GLP_MSG_ERR)\n                  xprintf(\"glp_intopt: integer column %d has non-intege\"\n                     \"r fixed value %g\\n\", j, col->lb);\n               ret = GLP_EBOUND;\n               goto done;\n            }\n         }\n      }\n      /* solve MIP problem */\n      if (parm->msg_lev >= GLP_MSG_ALL)\n      {  int ni = glp_get_num_int(P);\n         int nb = glp_get_num_bin(P);\n         char s[50];\n         xprintf(\"GLPK Integer Optimizer, v%s\\n\", glp_version());\n         xprintf(\"%d row%s, %d column%s, %d non-zero%s\\n\",\n            P->m, P->m == 1 ? \"\" : \"s\", P->n, P->n == 1 ? \"\" : \"s\",\n            P->nnz, P->nnz == 1 ? \"\" : \"s\");\n         if (nb == 0)\n            strcpy(s, \"none of\");\n         else if (ni == 1 && nb == 1)\n            strcpy(s, \"\");\n         else if (nb == 1)\n            strcpy(s, \"one of\");\n         else if (nb == ni)\n            strcpy(s, \"all of\");\n         else\n            sprintf(s, \"%d of\", nb);\n         xprintf(\"%d integer variable%s, %s which %s binary\\n\",\n            ni, ni == 1 ? \"\" : \"s\", s, nb == 1 ? \"is\" : \"are\");\n      }\n#if 1 /* 28/V-2010 */\n      if (parm->alien)\n      {  /* use alien integer optimizer */\n         ret = _glp_intopt1(P, parm);\n         goto done;\n      }\n#endif\n      if (!parm->presolve)\n#if 0 /* 11/VII-2013 */\n         ret = solve_mip(P, parm);\n#else\n         ret = solve_mip(P, parm, P, NULL);\n#endif\n      else\n         ret = preprocess_and_solve_mip(P, parm);\n#if 1 /* 12/III-2013 */\n      if (ret == GLP_ENOPFS)\n         P->mip_stat = GLP_NOFEAS;\n#endif\ndone: /* return to the application program */\n      return ret;\n}",
      "lines": 197,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "glp_init_iocp": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "void glp_init_iocp(glp_iocp *parm)\n{     parm->msg_lev = GLP_MSG_ALL;\n      parm->br_tech = GLP_BR_DTH;\n      parm->bt_tech = GLP_BT_BLB;\n      parm->tol_int = 1e-5;\n      parm->tol_obj = 1e-7;\n      parm->tm_lim = INT_MAX;\n      parm->out_frq = 5000;\n      parm->out_dly = 10000;\n      parm->cb_func = NULL;\n      parm->cb_info = NULL;\n      parm->cb_size = 0;\n      parm->pp_tech = GLP_PP_ALL;\n      parm->mip_gap = 0.0;\n      parm->mir_cuts = GLP_OFF;\n      parm->gmi_cuts = GLP_OFF;\n      parm->cov_cuts = GLP_OFF;\n      parm->clq_cuts = GLP_OFF;\n      parm->presolve = GLP_OFF;\n      parm->binarize = GLP_OFF;\n      parm->fp_heur = GLP_OFF;\n      parm->ps_heur = GLP_OFF;\n      parm->ps_tm_lim = 60000; /* 1 minute */\n      parm->sr_heur = GLP_ON;\n#if 1 /* 24/X-2015; not documented--should not be used */\n      parm->use_sol = GLP_OFF;\n      parm->save_sol = NULL;\n      parm->alien = GLP_OFF;\n#endif\n#if 0 /* 20/I-2018 */\n#if 1 /* 16/III-2016; not documented--should not be used */\n      parm->flip = GLP_OFF;\n#endif\n#else\n      parm->flip = GLP_ON;\n#endif\n      return;\n}",
      "lines": 38,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_mip_status": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        723,
        1
      ],
      "content": "int glp_mip_status(glp_prob *mip)\n{     int mip_stat = mip->mip_stat;\n      return mip_stat;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_mip_obj_val": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "double glp_mip_obj_val(glp_prob *mip)\n{     /*struct LPXCPS *cps = mip->cps;*/\n      double z;\n      z = mip->mip_obj;\n      /*if (cps->round && fabs(z) < 1e-9) z = 0.0;*/\n      return z;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "glp_mip_row_val": {
      "start_point": [
        761,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "double glp_mip_row_val(glp_prob *mip, int i)\n{     /*struct LPXCPS *cps = mip->cps;*/\n      double mipx;\n      if (!(1 <= i && i <= mip->m))\n         xerror(\"glp_mip_row_val: i = %d; row number out of range\\n\", i)\n            ;\n      mipx = mip->row[i]->mipx;\n      /*if (cps->round && fabs(mipx) < 1e-9) mipx = 0.0;*/\n      return mipx;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_mip_col_val": {
      "start_point": [
        786,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "double glp_mip_col_val(glp_prob *mip, int j)\n{     /*struct LPXCPS *cps = mip->cps;*/\n      double mipx;\n      if (!(1 <= j && j <= mip->n))\n         xerror(\"glp_mip_col_val: j = %d; column number out of range\\n\",\n            j);\n      mipx = mip->col[j]->mipx;\n      /*if (cps->round && fabs(mipx) < 1e-9) mipx = 0.0;*/\n      return mipx;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpapi10.c": {},
  "glpk/glpk-4.65/src/draft/glpapi12.c": {
    "glp_bf_exists": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int glp_bf_exists(glp_prob *lp)\n{     int ret;\n      ret = (lp->m == 0 || lp->valid);\n      return ret;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "b_col": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static int b_col(void *info, int j, int ind[], double val[])\n{     glp_prob *lp = info;\n      int m = lp->m;\n      GLPAIJ *aij;\n      int k, len;\n      xassert(1 <= j && j <= m);\n      /* determine the ordinal number of basic auxiliary or structural\n         variable x[k] corresponding to basic variable xB[j] */\n      k = lp->head[j];\n      /* build j-th column of the basic matrix, which is k-th column of\n         the scaled augmented matrix (I | -R*A*S) */\n      if (k <= m)\n      {  /* x[k] is auxiliary variable */\n         len = 1;\n         ind[1] = k;\n         val[1] = 1.0;\n      }\n      else\n      {  /* x[k] is structural variable */\n         len = 0;\n         for (aij = lp->col[k-m]->ptr; aij != NULL; aij = aij->c_next)\n         {  len++;\n            ind[len] = aij->row->i;\n            val[len] = - aij->row->rii * aij->val * aij->col->sjj;\n         }\n      }\n      return len;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_factorize": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "int glp_factorize(glp_prob *lp)\n{     int m = lp->m;\n      int n = lp->n;\n      GLPROW **row = lp->row;\n      GLPCOL **col = lp->col;\n      int *head = lp->head;\n      int j, k, stat, ret;\n      /* invalidate the basis factorization */\n      lp->valid = 0;\n      /* build the basis header */\n      j = 0;\n      for (k = 1; k <= m+n; k++)\n      {  if (k <= m)\n         {  stat = row[k]->stat;\n            row[k]->bind = 0;\n         }\n         else\n         {  stat = col[k-m]->stat;\n            col[k-m]->bind = 0;\n         }\n         if (stat == GLP_BS)\n         {  j++;\n            if (j > m)\n            {  /* too many basic variables */\n               ret = GLP_EBADB;\n               goto fini;\n            }\n            head[j] = k;\n            if (k <= m)\n               row[k]->bind = j;\n            else\n               col[k-m]->bind = j;\n         }\n      }\n      if (j < m)\n      {  /* too few basic variables */\n         ret = GLP_EBADB;\n         goto fini;\n      }\n      /* try to factorize the basis matrix */\n      if (m > 0)\n      {  if (lp->bfd == NULL)\n         {  lp->bfd = bfd_create_it();\n#if 0 /* 08/III-2014 */\n            copy_bfcp(lp);\n#endif\n         }\n         switch (bfd_factorize(lp->bfd, m, /*lp->head,*/ b_col, lp))\n         {  case 0:\n               /* ok */\n               break;\n            case BFD_ESING:\n               /* singular matrix */\n               ret = GLP_ESING;\n               goto fini;\n            case BFD_ECOND:\n               /* ill-conditioned matrix */\n               ret = GLP_ECOND;\n               goto fini;\n            default:\n               xassert(lp != lp);\n         }\n         lp->valid = 1;\n      }\n      /* factorization successful */\n      ret = 0;\nfini: /* bring the return code to the calling program */\n      return ret;\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_bf_updated": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int glp_bf_updated(glp_prob *lp)\n{     int cnt;\n      if (!(lp->m == 0 || lp->valid))\n         xerror(\"glp_bf_update: basis factorization does not exist\\n\");\n#if 0 /* 15/XI-2009 */\n      cnt = (lp->m == 0 ? 0 : lp->bfd->upd_cnt);\n#else\n      cnt = (lp->m == 0 ? 0 : bfd_get_count(lp->bfd));\n#endif\n      return cnt;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_get_bfcp": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "void glp_get_bfcp(glp_prob *P, glp_bfcp *parm)\n{     if (P->bfd == NULL)\n         P->bfd = bfd_create_it();\n      bfd_get_bfcp(P->bfd, parm);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_set_bfcp": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void glp_set_bfcp(glp_prob *P, const glp_bfcp *parm)\n{     if (P->bfd == NULL)\n         P->bfd = bfd_create_it();\n      if (parm != NULL)\n      {  if (!(parm->type == GLP_BF_LUF + GLP_BF_FT ||\n               parm->type == GLP_BF_LUF + GLP_BF_BG ||\n               parm->type == GLP_BF_LUF + GLP_BF_GR ||\n               parm->type == GLP_BF_BTF + GLP_BF_BG ||\n               parm->type == GLP_BF_BTF + GLP_BF_GR))\n            xerror(\"glp_set_bfcp: type = 0x%02X; invalid parameter\\n\",\n               parm->type);\n         if (!(0.0 < parm->piv_tol && parm->piv_tol < 1.0))\n            xerror(\"glp_set_bfcp: piv_tol = %g; invalid parameter\\n\",\n               parm->piv_tol);\n         if (parm->piv_lim < 1)\n            xerror(\"glp_set_bfcp: piv_lim = %d; invalid parameter\\n\",\n               parm->piv_lim);\n         if (!(parm->suhl == GLP_ON || parm->suhl == GLP_OFF))\n            xerror(\"glp_set_bfcp: suhl = %d; invalid parameter\\n\",\n               parm->suhl);\n         if (!(0.0 <= parm->eps_tol && parm->eps_tol <= 1e-6))\n            xerror(\"glp_set_bfcp: eps_tol = %g; invalid parameter\\n\",\n               parm->eps_tol);\n         if (!(1 <= parm->nfs_max && parm->nfs_max <= 32767))\n            xerror(\"glp_set_bfcp: nfs_max = %d; invalid parameter\\n\",\n               parm->nfs_max);\n         if (!(1 <= parm->nrs_max && parm->nrs_max <= 32767))\n            xerror(\"glp_set_bfcp: nrs_max = %d; invalid parameter\\n\",\n               parm->nrs_max);\n      }\n      bfd_set_bfcp(P->bfd, parm);\n      return;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "glp_get_bhead": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "int glp_get_bhead(glp_prob *lp, int k)\n{     if (!(lp->m == 0 || lp->valid))\n         xerror(\"glp_get_bhead: basis factorization does not exist\\n\");\n      if (!(1 <= k && k <= lp->m))\n         xerror(\"glp_get_bhead: k = %d; index out of range\\n\", k);\n      return lp->head[k];\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_row_bind": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "int glp_get_row_bind(glp_prob *lp, int i)\n{     if (!(lp->m == 0 || lp->valid))\n         xerror(\"glp_get_row_bind: basis factorization does not exist\\n\"\n            );\n      if (!(1 <= i && i <= lp->m))\n         xerror(\"glp_get_row_bind: i = %d; row number out of range\\n\",\n            i);\n      return lp->row[i]->bind;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_get_col_bind": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "int glp_get_col_bind(glp_prob *lp, int j)\n{     if (!(lp->m == 0 || lp->valid))\n         xerror(\"glp_get_col_bind: basis factorization does not exist\\n\"\n            );\n      if (!(1 <= j && j <= lp->n))\n         xerror(\"glp_get_col_bind: j = %d; column number out of range\\n\"\n            , j);\n      return lp->col[j]->bind;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_ftran": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "void glp_ftran(glp_prob *lp, double x[])\n{     int m = lp->m;\n      GLPROW **row = lp->row;\n      GLPCOL **col = lp->col;\n      int i, k;\n      /* B*x = b ===> (R*B*SB)*(inv(SB)*x) = R*b ===>\n         B\"*x\" = b\", where b\" = R*b, x = SB*x\" */\n      if (!(m == 0 || lp->valid))\n         xerror(\"glp_ftran: basis factorization does not exist\\n\");\n      /* b\" := R*b */\n      for (i = 1; i <= m; i++)\n         x[i] *= row[i]->rii;\n      /* x\" := inv(B\")*b\" */\n      if (m > 0) bfd_ftran(lp->bfd, x);\n      /* x := SB*x\" */\n      for (i = 1; i <= m; i++)\n      {  k = lp->head[i];\n         if (k <= m)\n            x[i] /= row[k]->rii;\n         else\n            x[i] *= col[k-m]->sjj;\n      }\n      return;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_btran": {
      "start_point": [
        476,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "void glp_btran(glp_prob *lp, double x[])\n{     int m = lp->m;\n      GLPROW **row = lp->row;\n      GLPCOL **col = lp->col;\n      int i, k;\n      /* B'*x = b ===> (SB*B'*R)*(inv(R)*x) = SB*b ===>\n         (B\")'*x\" = b\", where b\" = SB*b, x = R*x\" */\n      if (!(m == 0 || lp->valid))\n         xerror(\"glp_btran: basis factorization does not exist\\n\");\n      /* b\" := SB*b */\n      for (i = 1; i <= m; i++)\n      {  k = lp->head[i];\n         if (k <= m)\n            x[i] /= row[k]->rii;\n         else\n            x[i] *= col[k-m]->sjj;\n      }\n      /* x\" := inv[(B\")']*b\" */\n      if (m > 0) bfd_btran(lp->bfd, x);\n      /* x := R*x\" */\n      for (i = 1; i <= m; i++)\n         x[i] *= row[i]->rii;\n      return;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_warm_up": {
      "start_point": [
        535,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "int glp_warm_up(glp_prob *P)\n{     GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int i, j, type, stat, ret;\n      double eps, temp, *work;\n      /* invalidate basic solution */\n      P->pbs_stat = P->dbs_stat = GLP_UNDEF;\n      P->obj_val = 0.0;\n      P->some = 0;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         row->prim = row->dual = 0.0;\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         col->prim = col->dual = 0.0;\n      }\n      /* compute the basis factorization, if necessary */\n      if (!glp_bf_exists(P))\n      {  ret = glp_factorize(P);\n         if (ret != 0) goto done;\n      }\n      /* allocate working array */\n      work = xcalloc(1+P->m, sizeof(double));\n      /* determine and store values of non-basic variables, compute\n         vector (- N * xN) */\n      for (i = 1; i <= P->m; i++)\n         work[i] = 0.0;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->stat == GLP_BS)\n            continue;\n         else if (row->stat == GLP_NL)\n            row->prim = row->lb;\n         else if (row->stat == GLP_NU)\n            row->prim = row->ub;\n         else if (row->stat == GLP_NF)\n            row->prim = 0.0;\n         else if (row->stat == GLP_NS)\n            row->prim = row->lb;\n         else\n            xassert(row != row);\n         /* N[j] is i-th column of matrix (I|-A) */\n         work[i] -= row->prim;\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->stat == GLP_BS)\n            continue;\n         else if (col->stat == GLP_NL)\n            col->prim = col->lb;\n         else if (col->stat == GLP_NU)\n            col->prim = col->ub;\n         else if (col->stat == GLP_NF)\n            col->prim = 0.0;\n         else if (col->stat == GLP_NS)\n            col->prim = col->lb;\n         else\n            xassert(col != col);\n         /* N[j] is (m+j)-th column of matrix (I|-A) */\n         if (col->prim != 0.0)\n         {  for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n               work[aij->row->i] += aij->val * col->prim;\n         }\n      }\n      /* compute vector of basic variables xB = - inv(B) * N * xN */\n      glp_ftran(P, work);\n      /* store values of basic variables, check primal feasibility */\n      P->pbs_stat = GLP_FEAS;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->stat != GLP_BS)\n            continue;\n         row->prim = work[row->bind];\n         type = row->type;\n         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n         {  eps = 1e-6 + 1e-9 * fabs(row->lb);\n            if (row->prim < row->lb - eps)\n               P->pbs_stat = GLP_INFEAS;\n         }\n         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n         {  eps = 1e-6 + 1e-9 * fabs(row->ub);\n            if (row->prim > row->ub + eps)\n               P->pbs_stat = GLP_INFEAS;\n         }\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->stat != GLP_BS)\n            continue;\n         col->prim = work[col->bind];\n         type = col->type;\n         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n         {  eps = 1e-6 + 1e-9 * fabs(col->lb);\n            if (col->prim < col->lb - eps)\n               P->pbs_stat = GLP_INFEAS;\n         }\n         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n         {  eps = 1e-6 + 1e-9 * fabs(col->ub);\n            if (col->prim > col->ub + eps)\n               P->pbs_stat = GLP_INFEAS;\n         }\n      }\n      /* compute value of the objective function */\n      P->obj_val = P->c0;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         P->obj_val += col->coef * col->prim;\n      }\n      /* build vector cB of objective coefficients at basic variables */\n      for (i = 1; i <= P->m; i++)\n         work[i] = 0.0;\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->stat == GLP_BS)\n            work[col->bind] = col->coef;\n      }\n      /* compute vector of simplex multipliers pi = inv(B') * cB */\n      glp_btran(P, work);\n      /* compute and store reduced costs of non-basic variables d[j] =\n         c[j] - N'[j] * pi, check dual feasibility */\n      P->dbs_stat = GLP_FEAS;\n      for (i = 1; i <= P->m; i++)\n      {  row = P->row[i];\n         if (row->stat == GLP_BS)\n         {  row->dual = 0.0;\n            continue;\n         }\n         /* N[j] is i-th column of matrix (I|-A) */\n         row->dual = - work[i];\n#if 0 /* 07/III-2013 */\n         type = row->type;\n         temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);\n         if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||\n             (type == GLP_FR || type == GLP_UP) && temp > +1e-5)\n            P->dbs_stat = GLP_INFEAS;\n#else\n         stat = row->stat;\n         temp = (P->dir == GLP_MIN ? + row->dual : - row->dual);\n         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\n             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\n            P->dbs_stat = GLP_INFEAS;\n#endif\n      }\n      for (j = 1; j <= P->n; j++)\n      {  col = P->col[j];\n         if (col->stat == GLP_BS)\n         {  col->dual = 0.0;\n            continue;\n         }\n         /* N[j] is (m+j)-th column of matrix (I|-A) */\n         col->dual = col->coef;\n         for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n            col->dual += aij->val * work[aij->row->i];\n#if 0 /* 07/III-2013 */\n         type = col->type;\n         temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);\n         if ((type == GLP_FR || type == GLP_LO) && temp < -1e-5 ||\n             (type == GLP_FR || type == GLP_UP) && temp > +1e-5)\n            P->dbs_stat = GLP_INFEAS;\n#else\n         stat = col->stat;\n         temp = (P->dir == GLP_MIN ? + col->dual : - col->dual);\n         if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\n             (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\n            P->dbs_stat = GLP_INFEAS;\n#endif\n      }\n      /* free working array */\n      xfree(work);\n      ret = 0;\ndone: return ret;\n}",
      "lines": 174,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glp_eval_tab_row": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "int glp_eval_tab_row(glp_prob *lp, int k, int ind[], double val[])\n{     int m = lp->m;\n      int n = lp->n;\n      int i, t, len, lll, *iii;\n      double alfa, *rho, *vvv;\n      if (!(m == 0 || lp->valid))\n         xerror(\"glp_eval_tab_row: basis factorization does not exist\\n\"\n            );\n      if (!(1 <= k && k <= m+n))\n         xerror(\"glp_eval_tab_row: k = %d; variable number out of range\"\n            , k);\n      /* determine xB[i] which corresponds to x[k] */\n      if (k <= m)\n         i = glp_get_row_bind(lp, k);\n      else\n         i = glp_get_col_bind(lp, k-m);\n      if (i == 0)\n         xerror(\"glp_eval_tab_row: k = %d; variable must be basic\", k);\n      xassert(1 <= i && i <= m);\n      /* allocate working arrays */\n      rho = xcalloc(1+m, sizeof(double));\n      iii = xcalloc(1+m, sizeof(int));\n      vvv = xcalloc(1+m, sizeof(double));\n      /* compute i-th row of the inverse; see (8) */\n      for (t = 1; t <= m; t++) rho[t] = 0.0;\n      rho[i] = 1.0;\n      glp_btran(lp, rho);\n      /* compute i-th row of the simplex table */\n      len = 0;\n      for (k = 1; k <= m+n; k++)\n      {  if (k <= m)\n         {  /* x[k] is auxiliary variable, so N[k] is a unity column */\n            if (glp_get_row_stat(lp, k) == GLP_BS) continue;\n            /* compute alfa[i,j]; see (9) */\n            alfa = - rho[k];\n         }\n         else\n         {  /* x[k] is structural variable, so N[k] is a column of the\n               original constraint matrix A with negative sign */\n            if (glp_get_col_stat(lp, k-m) == GLP_BS) continue;\n            /* compute alfa[i,j]; see (9) */\n            lll = glp_get_mat_col(lp, k-m, iii, vvv);\n            alfa = 0.0;\n            for (t = 1; t <= lll; t++) alfa += rho[iii[t]] * vvv[t];\n         }\n         /* store alfa[i,j] */\n         if (alfa != 0.0) len++, ind[len] = k, val[len] = alfa;\n      }\n      xassert(len <= n);\n      /* free working arrays */\n      xfree(rho);\n      xfree(iii);\n      xfree(vvv);\n      /* return to the calling program */\n      return len;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_eval_tab_col": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        964,
        1
      ],
      "content": "int glp_eval_tab_col(glp_prob *lp, int k, int ind[], double val[])\n{     int m = lp->m;\n      int n = lp->n;\n      int t, len, stat;\n      double *col;\n      if (!(m == 0 || lp->valid))\n         xerror(\"glp_eval_tab_col: basis factorization does not exist\\n\"\n            );\n      if (!(1 <= k && k <= m+n))\n         xerror(\"glp_eval_tab_col: k = %d; variable number out of range\"\n            , k);\n      if (k <= m)\n         stat = glp_get_row_stat(lp, k);\n      else\n         stat = glp_get_col_stat(lp, k-m);\n      if (stat == GLP_BS)\n         xerror(\"glp_eval_tab_col: k = %d; variable must be non-basic\",\n            k);\n      /* obtain column N[k] with negative sign */\n      col = xcalloc(1+m, sizeof(double));\n      for (t = 1; t <= m; t++) col[t] = 0.0;\n      if (k <= m)\n      {  /* x[k] is auxiliary variable, so N[k] is a unity column */\n         col[k] = -1.0;\n      }\n      else\n      {  /* x[k] is structural variable, so N[k] is a column of the\n            original constraint matrix A with negative sign */\n         len = glp_get_mat_col(lp, k-m, ind, val);\n         for (t = 1; t <= len; t++) col[ind[t]] = val[t];\n      }\n      /* compute column of the simplex table, which corresponds to the\n         specified non-basic variable x[k] */\n      glp_ftran(lp, col);\n      len = 0;\n      for (t = 1; t <= m; t++)\n      {  if (col[t] != 0.0)\n         {  len++;\n            ind[len] = glp_get_bhead(lp, t);\n            val[len] = col[t];\n         }\n      }\n      xfree(col);\n      /* return to the calling program */\n      return len;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glp_transform_row": {
      "start_point": [
        1048,
        0
      ],
      "end_point": [
        1118,
        1
      ],
      "content": "int glp_transform_row(glp_prob *P, int len, int ind[], double val[])\n{     int i, j, k, m, n, t, lll, *iii;\n      double alfa, *a, *aB, *rho, *vvv;\n      if (!glp_bf_exists(P))\n         xerror(\"glp_transform_row: basis factorization does not exist \"\n            \"\\n\");\n      m = glp_get_num_rows(P);\n      n = glp_get_num_cols(P);\n      /* unpack the row to be transformed to the array a */\n      a = xcalloc(1+n, sizeof(double));\n      for (j = 1; j <= n; j++) a[j] = 0.0;\n      if (!(0 <= len && len <= n))\n         xerror(\"glp_transform_row: len = %d; invalid row length\\n\",\n            len);\n      for (t = 1; t <= len; t++)\n      {  j = ind[t];\n         if (!(1 <= j && j <= n))\n            xerror(\"glp_transform_row: ind[%d] = %d; column index out o\"\n               \"f range\\n\", t, j);\n         if (val[t] == 0.0)\n            xerror(\"glp_transform_row: val[%d] = 0; zero coefficient no\"\n               \"t allowed\\n\", t);\n         if (a[j] != 0.0)\n            xerror(\"glp_transform_row: ind[%d] = %d; duplicate column i\"\n               \"ndices not allowed\\n\", t, j);\n         a[j] = val[t];\n      }\n      /* construct the vector aB */\n      aB = xcalloc(1+m, sizeof(double));\n      for (i = 1; i <= m; i++)\n      {  k = glp_get_bhead(P, i);\n         /* xB[i] is k-th original variable */\n         xassert(1 <= k && k <= m+n);\n         aB[i] = (k <= m ? 0.0 : a[k-m]);\n      }\n      /* solve the system B'*rho = aB to compute the vector rho */\n      rho = aB, glp_btran(P, rho);\n      /* compute coefficients at non-basic auxiliary variables */\n      len = 0;\n      for (i = 1; i <= m; i++)\n      {  if (glp_get_row_stat(P, i) != GLP_BS)\n         {  alfa = - rho[i];\n            if (alfa != 0.0)\n            {  len++;\n               ind[len] = i;\n               val[len] = alfa;\n            }\n         }\n      }\n      /* compute coefficients at non-basic structural variables */\n      iii = xcalloc(1+m, sizeof(int));\n      vvv = xcalloc(1+m, sizeof(double));\n      for (j = 1; j <= n; j++)\n      {  if (glp_get_col_stat(P, j) != GLP_BS)\n         {  alfa = a[j];\n            lll = glp_get_mat_col(P, j, iii, vvv);\n            for (t = 1; t <= lll; t++) alfa += vvv[t] * rho[iii[t]];\n            if (alfa != 0.0)\n            {  len++;\n               ind[len] = m+j;\n               val[len] = alfa;\n            }\n         }\n      }\n      xassert(len <= n);\n      xfree(iii);\n      xfree(vvv);\n      xfree(aB);\n      xfree(a);\n      return len;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_transform_col": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1227,
        1
      ],
      "content": "int glp_transform_col(glp_prob *P, int len, int ind[], double val[])\n{     int i, m, t;\n      double *a, *alfa;\n      if (!glp_bf_exists(P))\n         xerror(\"glp_transform_col: basis factorization does not exist \"\n            \"\\n\");\n      m = glp_get_num_rows(P);\n      /* unpack the column to be transformed to the array a */\n      a = xcalloc(1+m, sizeof(double));\n      for (i = 1; i <= m; i++) a[i] = 0.0;\n      if (!(0 <= len && len <= m))\n         xerror(\"glp_transform_col: len = %d; invalid column length\\n\",\n            len);\n      for (t = 1; t <= len; t++)\n      {  i = ind[t];\n         if (!(1 <= i && i <= m))\n            xerror(\"glp_transform_col: ind[%d] = %d; row index out of r\"\n               \"ange\\n\", t, i);\n         if (val[t] == 0.0)\n            xerror(\"glp_transform_col: val[%d] = 0; zero coefficient no\"\n               \"t allowed\\n\", t);\n         if (a[i] != 0.0)\n            xerror(\"glp_transform_col: ind[%d] = %d; duplicate row indi\"\n               \"ces not allowed\\n\", t, i);\n         a[i] = val[t];\n      }\n      /* solve the system B*a = alfa to compute the vector alfa */\n      alfa = a, glp_ftran(P, alfa);\n      /* store resultant coefficients */\n      len = 0;\n      for (i = 1; i <= m; i++)\n      {  if (alfa[i] != 0.0)\n         {  len++;\n            ind[len] = glp_get_bhead(P, i);\n            val[len] = alfa[i];\n         }\n      }\n      xfree(a);\n      return len;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glp_prim_rtest": {
      "start_point": [
        1287,
        0
      ],
      "end_point": [
        1371,
        1
      ],
      "content": "int glp_prim_rtest(glp_prob *P, int len, const int ind[],\n      const double val[], int dir, double eps)\n{     int k, m, n, piv, t, type, stat;\n      double alfa, big, beta, lb, ub, temp, teta;\n      if (glp_get_prim_stat(P) != GLP_FEAS)\n         xerror(\"glp_prim_rtest: basic solution is not primal feasible \"\n            \"\\n\");\n      if (!(dir == +1 || dir == -1))\n         xerror(\"glp_prim_rtest: dir = %d; invalid parameter\\n\", dir);\n      if (!(0.0 < eps && eps < 1.0))\n         xerror(\"glp_prim_rtest: eps = %g; invalid parameter\\n\", eps);\n      m = glp_get_num_rows(P);\n      n = glp_get_num_cols(P);\n      /* initial settings */\n      piv = 0, teta = DBL_MAX, big = 0.0;\n      /* walk through the entries of the specified column */\n      for (t = 1; t <= len; t++)\n      {  /* get the ordinal number of basic variable */\n         k = ind[t];\n         if (!(1 <= k && k <= m+n))\n            xerror(\"glp_prim_rtest: ind[%d] = %d; variable number out o\"\n               \"f range\\n\", t, k);\n         /* determine type, bounds, status and primal value of basic\n            variable xB[i] = x[k] in the current basic solution */\n         if (k <= m)\n         {  type = glp_get_row_type(P, k);\n            lb = glp_get_row_lb(P, k);\n            ub = glp_get_row_ub(P, k);\n            stat = glp_get_row_stat(P, k);\n            beta = glp_get_row_prim(P, k);\n         }\n         else\n         {  type = glp_get_col_type(P, k-m);\n            lb = glp_get_col_lb(P, k-m);\n            ub = glp_get_col_ub(P, k-m);\n            stat = glp_get_col_stat(P, k-m);\n            beta = glp_get_col_prim(P, k-m);\n         }\n         if (stat != GLP_BS)\n            xerror(\"glp_prim_rtest: ind[%d] = %d; non-basic variable no\"\n               \"t allowed\\n\", t, k);\n         /* determine influence coefficient at basic variable xB[i]\n            in the explicitly specified column and turn to the case of\n            increasing the variable x in order to simplify the program\n            logic */\n         alfa = (dir > 0 ? + val[t] : - val[t]);\n         /* analyze main cases */\n         if (type == GLP_FR)\n         {  /* xB[i] is free variable */\n            continue;\n         }\n         else if (type == GLP_LO)\nlo:      {  /* xB[i] has an lower bound */\n            if (alfa > - eps) continue;\n            temp = (lb - beta) / alfa;\n         }\n         else if (type == GLP_UP)\nup:      {  /* xB[i] has an upper bound */\n            if (alfa < + eps) continue;\n            temp = (ub - beta) / alfa;\n         }\n         else if (type == GLP_DB)\n         {  /* xB[i] has both lower and upper bounds */\n            if (alfa < 0.0) goto lo; else goto up;\n         }\n         else if (type == GLP_FX)\n         {  /* xB[i] is fixed variable */\n            if (- eps < alfa && alfa < + eps) continue;\n            temp = 0.0;\n         }\n         else\n            xassert(type != type);\n         /* if the value of the variable xB[i] violates its lower or\n            upper bound (slightly, because the current basis is assumed\n            to be primal feasible), temp is negative; we can think this\n            happens due to round-off errors and the value is exactly on\n            the bound; this allows replacing temp by zero */\n         if (temp < 0.0) temp = 0.0;\n         /* apply the minimal ratio test */\n         if (teta > temp || teta == temp && big < fabs(alfa))\n            piv = t, teta = temp, big = fabs(alfa);\n      }\n      /* return index of the pivot element chosen */\n      return piv;\n}",
      "lines": 85,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "glp_dual_rtest": {
      "start_point": [
        1429,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "int glp_dual_rtest(glp_prob *P, int len, const int ind[],\n      const double val[], int dir, double eps)\n{     int k, m, n, piv, t, stat;\n      double alfa, big, cost, obj, temp, teta;\n      if (glp_get_dual_stat(P) != GLP_FEAS)\n         xerror(\"glp_dual_rtest: basic solution is not dual feasible\\n\")\n            ;\n      if (!(dir == +1 || dir == -1))\n         xerror(\"glp_dual_rtest: dir = %d; invalid parameter\\n\", dir);\n      if (!(0.0 < eps && eps < 1.0))\n         xerror(\"glp_dual_rtest: eps = %g; invalid parameter\\n\", eps);\n      m = glp_get_num_rows(P);\n      n = glp_get_num_cols(P);\n      /* take into account optimization direction */\n      obj = (glp_get_obj_dir(P) == GLP_MIN ? +1.0 : -1.0);\n      /* initial settings */\n      piv = 0, teta = DBL_MAX, big = 0.0;\n      /* walk through the entries of the specified row */\n      for (t = 1; t <= len; t++)\n      {  /* get ordinal number of non-basic variable */\n         k = ind[t];\n         if (!(1 <= k && k <= m+n))\n            xerror(\"glp_dual_rtest: ind[%d] = %d; variable number out o\"\n               \"f range\\n\", t, k);\n         /* determine status and reduced cost of non-basic variable\n            x[k] = xN[j] in the current basic solution */\n         if (k <= m)\n         {  stat = glp_get_row_stat(P, k);\n            cost = glp_get_row_dual(P, k);\n         }\n         else\n         {  stat = glp_get_col_stat(P, k-m);\n            cost = glp_get_col_dual(P, k-m);\n         }\n         if (stat == GLP_BS)\n            xerror(\"glp_dual_rtest: ind[%d] = %d; basic variable not al\"\n               \"lowed\\n\", t, k);\n         /* determine influence coefficient at non-basic variable xN[j]\n            in the explicitly specified row and turn to the case of\n            increasing the variable x in order to simplify the program\n            logic */\n         alfa = (dir > 0 ? + val[t] : - val[t]);\n         /* analyze main cases */\n         if (stat == GLP_NL)\n         {  /* xN[j] is on its lower bound */\n            if (alfa < + eps) continue;\n            temp = (obj * cost) / alfa;\n         }\n         else if (stat == GLP_NU)\n         {  /* xN[j] is on its upper bound */\n            if (alfa > - eps) continue;\n            temp = (obj * cost) / alfa;\n         }\n         else if (stat == GLP_NF)\n         {  /* xN[j] is non-basic free variable */\n            if (- eps < alfa && alfa < + eps) continue;\n            temp = 0.0;\n         }\n         else if (stat == GLP_NS)\n         {  /* xN[j] is non-basic fixed variable */\n            continue;\n         }\n         else\n            xassert(stat != stat);\n         /* if the reduced cost of the variable xN[j] violates its zero\n            bound (slightly, because the current basis is assumed to be\n            dual feasible), temp is negative; we can think this happens\n            due to round-off errors and the reduced cost is exact zero;\n            this allows replacing temp by zero */\n         if (temp < 0.0) temp = 0.0;\n         /* apply the minimal ratio test */\n         if (teta > temp || teta == temp && big < fabs(alfa))\n            piv = t, teta = temp, big = fabs(alfa);\n      }\n      /* return index of the pivot element chosen */\n      return piv;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "_glp_analyze_row": {
      "start_point": [
        1585,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "int _glp_analyze_row(glp_prob *P, int len, const int ind[],\n      const double val[], int type, double rhs, double eps, int *_piv,\n      double *_x, double *_dx, double *_y, double *_dy, double *_dz)\n{     int t, k, dir, piv, ret = 0;\n      double x, dx, y, dy, dz;\n      if (P->pbs_stat == GLP_UNDEF)\n         xerror(\"glp_analyze_row: primal basic solution components are \"\n            \"undefined\\n\");\n      if (P->dbs_stat != GLP_FEAS)\n         xerror(\"glp_analyze_row: basic solution is not dual feasible\\n\"\n            );\n      /* compute the row value y = sum alfa[j] * xN[j] in the current\n         basis */\n      if (!(0 <= len && len <= P->n))\n         xerror(\"glp_analyze_row: len = %d; invalid row length\\n\", len);\n      y = 0.0;\n      for (t = 1; t <= len; t++)\n      {  /* determine value of x[k] = xN[j] in the current basis */\n         k = ind[t];\n         if (!(1 <= k && k <= P->m+P->n))\n            xerror(\"glp_analyze_row: ind[%d] = %d; row/column index out\"\n               \" of range\\n\", t, k);\n         if (k <= P->m)\n         {  /* x[k] is auxiliary variable */\n            if (P->row[k]->stat == GLP_BS)\n               xerror(\"glp_analyze_row: ind[%d] = %d; basic auxiliary v\"\n                  \"ariable is not allowed\\n\", t, k);\n            x = P->row[k]->prim;\n         }\n         else\n         {  /* x[k] is structural variable */\n            if (P->col[k-P->m]->stat == GLP_BS)\n               xerror(\"glp_analyze_row: ind[%d] = %d; basic structural \"\n                  \"variable is not allowed\\n\", t, k);\n            x = P->col[k-P->m]->prim;\n         }\n         y += val[t] * x;\n      }\n      /* check if the row is primal infeasible in the current basis,\n         i.e. the constraint is violated at the current point */\n      if (type == GLP_LO)\n      {  if (y >= rhs)\n         {  /* the constraint is not violated */\n            ret = 1;\n            goto done;\n         }\n         /* in the adjacent basis y goes to its lower bound */\n         dir = +1;\n      }\n      else if (type == GLP_UP)\n      {  if (y <= rhs)\n         {  /* the constraint is not violated */\n            ret = 1;\n            goto done;\n         }\n         /* in the adjacent basis y goes to its upper bound */\n         dir = -1;\n      }\n      else\n         xerror(\"glp_analyze_row: type = %d; invalid parameter\\n\",\n            type);\n      /* compute dy = y.new - y.old */\n      dy = rhs - y;\n      /* perform dual ratio test to determine which non-basic variable\n         should enter the adjacent basis to keep it dual feasible */\n      piv = glp_dual_rtest(P, len, ind, val, dir, eps);\n      if (piv == 0)\n      {  /* no dual feasible adjacent basis exists */\n         ret = 2;\n         goto done;\n      }\n      /* non-basic variable x[k] = xN[j] should enter the basis */\n      k = ind[piv];\n      xassert(1 <= k && k <= P->m+P->n);\n      /* determine its value in the current basis */\n      if (k <= P->m)\n         x = P->row[k]->prim;\n      else\n         x = P->col[k-P->m]->prim;\n      /* compute dx = x.new - x.old = dy / alfa[j] */\n      xassert(val[piv] != 0.0);\n      dx = dy / val[piv];\n      /* compute dz = z.new - z.old = d[j] * dx, where d[j] is reduced\n         cost of xN[j] in the current basis */\n      if (k <= P->m)\n         dz = P->row[k]->dual * dx;\n      else\n         dz = P->col[k-P->m]->dual * dx;\n      /* store the analysis results */\n      if (_piv != NULL) *_piv = piv;\n      if (_x   != NULL) *_x   = x;\n      if (_dx  != NULL) *_dx  = dx;\n      if (_y   != NULL) *_y   = y;\n      if (_dy  != NULL) *_dy  = dy;\n      if (_dz  != NULL) *_dz  = dz;\ndone: return ret;\n}",
      "lines": 97,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1684,
        0
      ],
      "end_point": [
        1750,
        1
      ],
      "content": "int main(void)\n{     /* example program for the routine glp_analyze_row */\n      glp_prob *P;\n      glp_smcp parm;\n      int i, k, len, piv, ret, ind[1+100];\n      double rhs, x, dx, y, dy, dz, val[1+100];\n      P = glp_create_prob();\n      /* read plan.mps (see glpk/examples) */\n      ret = glp_read_mps(P, GLP_MPS_DECK, NULL, \"plan.mps\");\n      glp_assert(ret == 0);\n      /* and solve it to optimality */\n      ret = glp_simplex(P, NULL);\n      glp_assert(ret == 0);\n      glp_assert(glp_get_status(P) == GLP_OPT);\n      /* the optimal objective value is 296.217 */\n      /* we would like to know what happens if we would add a new row\n         (constraint) to plan.mps:\n         .01 * bin1 + .01 * bin2 + .02 * bin4 + .02 * bin5 <= 12 */\n      /* first, we specify this new row */\n      glp_create_index(P);\n      len = 0;\n      ind[++len] = glp_find_col(P, \"BIN1\"), val[len] = .01;\n      ind[++len] = glp_find_col(P, \"BIN2\"), val[len] = .01;\n      ind[++len] = glp_find_col(P, \"BIN4\"), val[len] = .02;\n      ind[++len] = glp_find_col(P, \"BIN5\"), val[len] = .02;\n      rhs = 12;\n      /* then we can compute value of the row (i.e. of its auxiliary\n         variable) in the current basis to see if the constraint is\n         violated */\n      y = 0.0;\n      for (k = 1; k <= len; k++)\n         y += val[k] * glp_get_col_prim(P, ind[k]);\n      glp_printf(\"y = %g\\n\", y);\n      /* this prints y = 15.1372, so the constraint is violated, since\n         we require that y <= rhs = 12 */\n      /* now we transform the row to express it only through non-basic\n         (auxiliary and artificial) variables */\n      len = glp_transform_row(P, len, ind, val);\n      /* finally, we simulate one step of the dual simplex method to\n         obtain necessary information for the adjacent basis */\n      ret = _glp_analyze_row(P, len, ind, val, GLP_UP, rhs, 1e-9, &piv,\n         &x, &dx, &y, &dy, &dz);\n      glp_assert(ret == 0);\n      glp_printf(\"k = %d, x = %g; dx = %g; y = %g; dy = %g; dz = %g\\n\",\n         ind[piv], x, dx, y, dy, dz);\n      /* this prints dz = 5.64418 and means that in the adjacent basis\n         the objective function would be 296.217 + 5.64418 = 301.861 */\n      /* now we actually include the row into the problem object; note\n         that the arrays ind and val are clobbered, so we need to build\n         them once again */\n      len = 0;\n      ind[++len] = glp_find_col(P, \"BIN1\"), val[len] = .01;\n      ind[++len] = glp_find_col(P, \"BIN2\"), val[len] = .01;\n      ind[++len] = glp_find_col(P, \"BIN4\"), val[len] = .02;\n      ind[++len] = glp_find_col(P, \"BIN5\"), val[len] = .02;\n      rhs = 12;\n      i = glp_add_rows(P, 1);\n      glp_set_row_bnds(P, i, GLP_UP, 0, rhs);\n      glp_set_mat_row(P, i, len, ind, val);\n      /* and perform one dual simplex iteration */\n      glp_init_smcp(&parm);\n      parm.meth = GLP_DUAL;\n      parm.it_lim = 1;\n      glp_simplex(P, &parm);\n      /* the current objective value is 301.861 */\n      return 0;\n}",
      "lines": 67,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_analyze_bound": {
      "start_point": [
        1795,
        0
      ],
      "end_point": [
        1900,
        1
      ],
      "content": "void glp_analyze_bound(glp_prob *P, int k, double *value1, int *var1,\n      double *value2, int *var2)\n{     GLPROW *row;\n      GLPCOL *col;\n      int m, n, stat, kase, p, len, piv, *ind;\n      double x, new_x, ll, uu, xx, delta, *val;\n#if 0 /* 04/IV-2016 */\n      /* sanity checks */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_analyze_bound: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      m = P->m, n = P->n;\n      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))\n         xerror(\"glp_analyze_bound: optimal basic solution required\\n\");\n      if (!(m == 0 || P->valid))\n         xerror(\"glp_analyze_bound: basis factorization required\\n\");\n      if (!(1 <= k && k <= m+n))\n         xerror(\"glp_analyze_bound: k = %d; variable number out of rang\"\n            \"e\\n\", k);\n      /* retrieve information about the specified non-basic variable\n         x[k] whose active bound is to be analyzed */\n      if (k <= m)\n      {  row = P->row[k];\n         stat = row->stat;\n         x = row->prim;\n      }\n      else\n      {  col = P->col[k-m];\n         stat = col->stat;\n         x = col->prim;\n      }\n      if (stat == GLP_BS)\n         xerror(\"glp_analyze_bound: k = %d; basic variable not allowed \"\n            \"\\n\", k);\n      /* allocate working arrays */\n      ind = xcalloc(1+m, sizeof(int));\n      val = xcalloc(1+m, sizeof(double));\n      /* compute column of the simplex table corresponding to the\n         non-basic variable x[k] */\n      len = glp_eval_tab_col(P, k, ind, val);\n      xassert(0 <= len && len <= m);\n      /* perform analysis */\n      for (kase = -1; kase <= +1; kase += 2)\n      {  /* kase < 0 means active bound of x[k] is decreasing;\n            kase > 0 means active bound of x[k] is increasing */\n         /* use the primal ratio test to determine some basic variable\n            x[p] which reaches its bound first */\n         piv = glp_prim_rtest(P, len, ind, val, kase, 1e-9);\n         if (piv == 0)\n         {  /* nothing limits changing the active bound of x[k] */\n            p = 0;\n            new_x = (kase < 0 ? -DBL_MAX : +DBL_MAX);\n            goto store;\n         }\n         /* basic variable x[p] limits changing the active bound of\n            x[k]; determine its value in the current basis */\n         xassert(1 <= piv && piv <= len);\n         p = ind[piv];\n         if (p <= m)\n         {  row = P->row[p];\n            ll = glp_get_row_lb(P, row->i);\n            uu = glp_get_row_ub(P, row->i);\n            stat = row->stat;\n            xx = row->prim;\n         }\n         else\n         {  col = P->col[p-m];\n            ll = glp_get_col_lb(P, col->j);\n            uu = glp_get_col_ub(P, col->j);\n            stat = col->stat;\n            xx = col->prim;\n         }\n         xassert(stat == GLP_BS);\n         /* determine delta x[p] = bound of x[p] - value of x[p] */\n         if (kase < 0 && val[piv] > 0.0 ||\n             kase > 0 && val[piv] < 0.0)\n         {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\n            xassert(ll != -DBL_MAX);\n            delta = ll - xx;\n         }\n         else\n         {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\n            xassert(uu != +DBL_MAX);\n            delta = uu - xx;\n         }\n         /* delta x[p] = alfa[p,k] * delta x[k], so new x[k] = x[k] +\n            delta x[k] = x[k] + delta x[p] / alfa[p,k] is the value of\n            x[k] in the adjacent basis */\n         xassert(val[piv] != 0.0);\n         new_x = x + delta / val[piv];\nstore:   /* store analysis results */\n         if (kase < 0)\n         {  if (value1 != NULL) *value1 = new_x;\n            if (var1 != NULL) *var1 = p;\n         }\n         else\n         {  if (value2 != NULL) *value2 = new_x;\n            if (var2 != NULL) *var2 = p;\n         }\n      }\n      /* free working arrays */\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 106,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "glp_analyze_coef": {
      "start_point": [
        1961,
        0
      ],
      "end_point": [
        2182,
        1
      ],
      "content": "void glp_analyze_coef(glp_prob *P, int k, double *coef1, int *var1,\n      double *value1, double *coef2, int *var2, double *value2)\n{     GLPROW *row; GLPCOL *col;\n      int m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv,\n         *cind, *rind;\n      double lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx,\n         *rval, *cval;\n#if 0 /* 04/IV-2016 */\n      /* sanity checks */\n      if (P == NULL || P->magic != GLP_PROB_MAGIC)\n         xerror(\"glp_analyze_coef: P = %p; invalid problem object\\n\",\n            P);\n#endif\n      m = P->m, n = P->n;\n      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))\n         xerror(\"glp_analyze_coef: optimal basic solution required\\n\");\n      if (!(m == 0 || P->valid))\n         xerror(\"glp_analyze_coef: basis factorization required\\n\");\n      if (!(1 <= k && k <= m+n))\n         xerror(\"glp_analyze_coef: k = %d; variable number out of range\"\n            \"\\n\", k);\n      /* retrieve information about the specified basic variable x[k]\n         whose objective coefficient c[k] is to be analyzed */\n      if (k <= m)\n      {  row = P->row[k];\n         type = row->type;\n         lb = row->lb;\n         ub = row->ub;\n         coef = 0.0;\n         stat = row->stat;\n         x = row->prim;\n      }\n      else\n      {  col = P->col[k-m];\n         type = col->type;\n         lb = col->lb;\n         ub = col->ub;\n         coef = col->coef;\n         stat = col->stat;\n         x = col->prim;\n      }\n      if (stat != GLP_BS)\n         xerror(\"glp_analyze_coef: k = %d; non-basic variable not allow\"\n            \"ed\\n\", k);\n      /* allocate working arrays */\n      cind = xcalloc(1+m, sizeof(int));\n      cval = xcalloc(1+m, sizeof(double));\n      rind = xcalloc(1+n, sizeof(int));\n      rval = xcalloc(1+n, sizeof(double));\n      /* compute row of the simplex table corresponding to the basic\n         variable x[k] */\n      rlen = glp_eval_tab_row(P, k, rind, rval);\n      xassert(0 <= rlen && rlen <= n);\n      /* perform analysis */\n      for (kase = -1; kase <= +1; kase += 2)\n      {  /* kase < 0 means objective coefficient c[k] is decreasing;\n            kase > 0 means objective coefficient c[k] is increasing */\n         /* note that decreasing c[k] is equivalent to increasing dual\n            variable lambda[k] and vice versa; we need to correctly set\n            the dir flag as required by the routine glp_dual_rtest */\n         if (P->dir == GLP_MIN)\n            dir = - kase;\n         else if (P->dir == GLP_MAX)\n            dir = + kase;\n         else\n            xassert(P != P);\n         /* use the dual ratio test to determine non-basic variable\n            x[q] whose reduced cost d[q] reaches zero bound first */\n         rpiv = glp_dual_rtest(P, rlen, rind, rval, dir, 1e-9);\n         if (rpiv == 0)\n         {  /* nothing limits changing c[k] */\n            lim_coef = (kase < 0 ? -DBL_MAX : +DBL_MAX);\n            q = 0;\n            /* x[k] keeps its current value */\n            new_x = x;\n            goto store;\n         }\n         /* non-basic variable x[q] limits changing coefficient c[k];\n            determine its status and reduced cost d[k] in the current\n            basis */\n         xassert(1 <= rpiv && rpiv <= rlen);\n         q = rind[rpiv];\n         xassert(1 <= q && q <= m+n);\n         if (q <= m)\n         {  row = P->row[q];\n            stat = row->stat;\n            d = row->dual;\n         }\n         else\n         {  col = P->col[q-m];\n            stat = col->stat;\n            d = col->dual;\n         }\n         /* note that delta d[q] = new d[q] - d[q] = - d[q], because\n            new d[q] = 0; delta d[q] = alfa[k,q] * delta c[k], so\n            delta c[k] = delta d[q] / alfa[k,q] = - d[q] / alfa[k,q] */\n         xassert(rval[rpiv] != 0.0);\n         delta = - d / rval[rpiv];\n         /* compute new c[k] = c[k] + delta c[k], which is the limiting\n            value of the objective coefficient c[k] */\n         lim_coef = coef + delta;\n         /* let c[k] continue decreasing/increasing that makes d[q]\n            dual infeasible and forces x[q] to enter the basis;\n            to perform the primal ratio test we need to know in which\n            direction x[q] changes on entering the basis; we determine\n            that analyzing the sign of delta d[q] (see above), since\n            d[q] may be close to zero having wrong sign */\n         /* let, for simplicity, the problem is minimization */\n         if (kase < 0 && rval[rpiv] > 0.0 ||\n             kase > 0 && rval[rpiv] < 0.0)\n         {  /* delta d[q] < 0, so d[q] being non-negative will become\n               negative, so x[q] will increase */\n            dir = +1;\n         }\n         else\n         {  /* delta d[q] > 0, so d[q] being non-positive will become\n               positive, so x[q] will decrease */\n            dir = -1;\n         }\n         /* if the problem is maximization, correct the direction */\n         if (P->dir == GLP_MAX) dir = - dir;\n         /* check that we didn't make a silly mistake */\n         if (dir > 0)\n            xassert(stat == GLP_NL || stat == GLP_NF);\n         else\n            xassert(stat == GLP_NU || stat == GLP_NF);\n         /* compute column of the simplex table corresponding to the\n            non-basic variable x[q] */\n         clen = glp_eval_tab_col(P, q, cind, cval);\n         /* make x[k] temporarily free (unbounded) */\n         if (k <= m)\n         {  row = P->row[k];\n            row->type = GLP_FR;\n            row->lb = row->ub = 0.0;\n         }\n         else\n         {  col = P->col[k-m];\n            col->type = GLP_FR;\n            col->lb = col->ub = 0.0;\n         }\n         /* use the primal ratio test to determine some basic variable\n            which leaves the basis */\n         cpiv = glp_prim_rtest(P, clen, cind, cval, dir, 1e-9);\n         /* restore original bounds of the basic variable x[k] */\n         if (k <= m)\n         {  row = P->row[k];\n            row->type = type;\n            row->lb = lb, row->ub = ub;\n         }\n         else\n         {  col = P->col[k-m];\n            col->type = type;\n            col->lb = lb, col->ub = ub;\n         }\n         if (cpiv == 0)\n         {  /* non-basic variable x[q] can change unlimitedly */\n            if (dir < 0 && rval[rpiv] > 0.0 ||\n                dir > 0 && rval[rpiv] < 0.0)\n            {  /* delta x[k] = alfa[k,q] * delta x[q] < 0 */\n               new_x = -DBL_MAX;\n            }\n            else\n            {  /* delta x[k] = alfa[k,q] * delta x[q] > 0 */\n               new_x = +DBL_MAX;\n            }\n            goto store;\n         }\n         /* some basic variable x[p] limits changing non-basic variable\n            x[q] in the adjacent basis */\n         xassert(1 <= cpiv && cpiv <= clen);\n         p = cind[cpiv];\n         xassert(1 <= p && p <= m+n);\n         xassert(p != k);\n         if (p <= m)\n         {  row = P->row[p];\n            xassert(row->stat == GLP_BS);\n            ll = glp_get_row_lb(P, row->i);\n            uu = glp_get_row_ub(P, row->i);\n            xx = row->prim;\n         }\n         else\n         {  col = P->col[p-m];\n            xassert(col->stat == GLP_BS);\n            ll = glp_get_col_lb(P, col->j);\n            uu = glp_get_col_ub(P, col->j);\n            xx = col->prim;\n         }\n         /* determine delta x[p] = new x[p] - x[p] */\n         if (dir < 0 && cval[cpiv] > 0.0 ||\n             dir > 0 && cval[cpiv] < 0.0)\n         {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\n            xassert(ll != -DBL_MAX);\n            delta = ll - xx;\n         }\n         else\n         {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\n            xassert(uu != +DBL_MAX);\n            delta = uu - xx;\n         }\n         /* compute new x[k] = x[k] + alfa[k,q] * delta x[q], where\n            delta x[q] = delta x[p] / alfa[p,q] */\n         xassert(cval[cpiv] != 0.0);\n         new_x = x + (rval[rpiv] / cval[cpiv]) * delta;\nstore:   /* store analysis results */\n         if (kase < 0)\n         {  if (coef1 != NULL) *coef1 = lim_coef;\n            if (var1 != NULL) *var1 = q;\n            if (value1 != NULL) *value1 = new_x;\n         }\n         else\n         {  if (coef2 != NULL) *coef2 = lim_coef;\n            if (var2 != NULL) *var2 = q;\n            if (value2 != NULL) *value2 = new_x;\n         }\n      }\n      /* free working arrays */\n      xfree(cind);\n      xfree(cval);\n      xfree(rind);\n      xfree(rval);\n      return;\n}",
      "lines": 222,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpapi13.c": {
    "glp_ios_reason": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int glp_ios_reason(glp_tree *tree)\n{     return\n         tree->reason;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_get_prob": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "glp_prob *glp_ios_get_prob(glp_tree *tree)\n{     return\n         tree->mip;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "glp_prob",
        "*glp_ios_get_prob(glp_tree *tree)",
        "*"
      ]
    },
    "glp_ios_tree_size": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void glp_ios_tree_size(glp_tree *tree, int *a_cnt, int *n_cnt,\n      int *t_cnt)\n{     if (a_cnt != NULL) *a_cnt = tree->a_cnt;\n      if (n_cnt != NULL) *n_cnt = tree->n_cnt;\n      if (t_cnt != NULL) *t_cnt = tree->t_cnt;\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_curr_node": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int glp_ios_curr_node(glp_tree *tree)\n{     IOSNPD *node;\n      /* obtain pointer to the current subproblem */\n      node = tree->curr;\n      /* return its reference number */\n      return node == NULL ? 0 : node->p;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_next_node": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "int glp_ios_next_node(glp_tree *tree, int p)\n{     IOSNPD *node;\n      if (p == 0)\n      {  /* obtain pointer to the first active subproblem */\n         node = tree->head;\n      }\n      else\n      {  /* obtain pointer to the specified subproblem */\n         if (!(1 <= p && p <= tree->nslots))\nerr:        xerror(\"glp_ios_next_node: p = %d; invalid subproblem refer\"\n               \"ence number\\n\", p);\n         node = tree->slot[p].node;\n         if (node == NULL) goto err;\n         /* the specified subproblem must be active */\n         if (node->count != 0)\n            xerror(\"glp_ios_next_node: p = %d; subproblem not in the ac\"\n               \"tive list\\n\", p);\n         /* obtain pointer to the next active subproblem */\n         node = node->next;\n      }\n      /* return the reference number */\n      return node == NULL ? 0 : node->p;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_prev_node": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int glp_ios_prev_node(glp_tree *tree, int p)\n{     IOSNPD *node;\n      if (p == 0)\n      {  /* obtain pointer to the last active subproblem */\n         node = tree->tail;\n      }\n      else\n      {  /* obtain pointer to the specified subproblem */\n         if (!(1 <= p && p <= tree->nslots))\nerr:        xerror(\"glp_ios_prev_node: p = %d; invalid subproblem refer\"\n               \"ence number\\n\", p);\n         node = tree->slot[p].node;\n         if (node == NULL) goto err;\n         /* the specified subproblem must be active */\n         if (node->count != 0)\n            xerror(\"glp_ios_prev_node: p = %d; subproblem not in the ac\"\n               \"tive list\\n\", p);\n         /* obtain pointer to the previous active subproblem */\n         node = node->prev;\n      }\n      /* return the reference number */\n      return node == NULL ? 0 : node->p;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_up_node": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "int glp_ios_up_node(glp_tree *tree, int p)\n{     IOSNPD *node;\n      /* obtain pointer to the specified subproblem */\n      if (!(1 <= p && p <= tree->nslots))\nerr:     xerror(\"glp_ios_up_node: p = %d; invalid subproblem reference \"\n            \"number\\n\", p);\n      node = tree->slot[p].node;\n      if (node == NULL) goto err;\n      /* obtain pointer to the parent subproblem */\n      node = node->up;\n      /* return the reference number */\n      return node == NULL ? 0 : node->p;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_node_level": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "int glp_ios_node_level(glp_tree *tree, int p)\n{     IOSNPD *node;\n      /* obtain pointer to the specified subproblem */\n      if (!(1 <= p && p <= tree->nslots))\nerr:     xerror(\"glp_ios_node_level: p = %d; invalid subproblem referen\"\n            \"ce number\\n\", p);\n      node = tree->slot[p].node;\n      if (node == NULL) goto err;\n      /* return the node level */\n      return node->level;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_node_bound": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "double glp_ios_node_bound(glp_tree *tree, int p)\n{     IOSNPD *node;\n      /* obtain pointer to the specified subproblem */\n      if (!(1 <= p && p <= tree->nslots))\nerr:     xerror(\"glp_ios_node_bound: p = %d; invalid subproblem referen\"\n            \"ce number\\n\", p);\n      node = tree->slot[p].node;\n      if (node == NULL) goto err;\n      /* return the node local bound */\n      return node->bound;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "glp_ios_best_node": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "int glp_ios_best_node(glp_tree *tree)\n{     return\n         ios_best_node(tree);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_mip_gap": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "double glp_ios_mip_gap(glp_tree *tree)\n{     return\n         ios_relative_gap(tree);\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "glp_ios_node_data": {
      "start_point": [
        414,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "void *glp_ios_node_data(glp_tree *tree, int p)\n{     IOSNPD *node;\n      /* obtain pointer to the specified subproblem */\n      if (!(1 <= p && p <= tree->nslots))\nerr:     xerror(\"glp_ios_node_level: p = %d; invalid subproblem referen\"\n            \"ce number\\n\", p);\n      node = tree->slot[p].node;\n      if (node == NULL) goto err;\n      /* return pointer to the application-specific data */\n      return node->data;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*glp_ios_node_data(glp_tree *tree, int p)",
        "*"
      ]
    },
    "glp_ios_row_attr": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "void glp_ios_row_attr(glp_tree *tree, int i, glp_attr *attr)\n{     GLPROW *row;\n      if (!(1 <= i && i <= tree->mip->m))\n         xerror(\"glp_ios_row_attr: i = %d; row number out of range\\n\",\n            i);\n      row = tree->mip->row[i];\n      attr->level = row->level;\n      attr->origin = row->origin;\n      attr->klass = row->klass;\n      return;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_pool_size": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        464,
        1
      ],
      "content": "int glp_ios_pool_size(glp_tree *tree)\n{     /* determine current size of the cut pool */\n      if (tree->reason != GLP_ICUTGEN)\n         xerror(\"glp_ios_pool_size: operation not allowed\\n\");\n      xassert(tree->local != NULL);\n#ifdef NEW_LOCAL /* 02/II-2018 */\n      return tree->local->m;\n#else\n      return tree->local->size;\n#endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_add_row": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        479,
        1
      ],
      "content": "int glp_ios_add_row(glp_tree *tree,\n      const char *name, int klass, int flags, int len, const int ind[],\n      const double val[], int type, double rhs)\n{     /* add row (constraint) to the cut pool */\n      int num;\n      if (tree->reason != GLP_ICUTGEN)\n         xerror(\"glp_ios_add_row: operation not allowed\\n\");\n      xassert(tree->local != NULL);\n      num = ios_add_row(tree, tree->local, name, klass, flags, len,\n         ind, val, type, rhs);\n      return num;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_del_row": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void glp_ios_del_row(glp_tree *tree, int i)\n{     /* remove row (constraint) from the cut pool */\n      if (tree->reason != GLP_ICUTGEN)\n         xerror(\"glp_ios_del_row: operation not allowed\\n\");\n      ios_del_row(tree, tree->local, i);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_clear_pool": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "void glp_ios_clear_pool(glp_tree *tree)\n{     /* remove all rows (constraints) from the cut pool */\n      if (tree->reason != GLP_ICUTGEN)\n         xerror(\"glp_ios_clear_pool: operation not allowed\\n\");\n      ios_clear_pool(tree, tree->local);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_can_branch": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "int glp_ios_can_branch(glp_tree *tree, int j)\n{     if (!(1 <= j && j <= tree->mip->n))\n         xerror(\"glp_ios_can_branch: j = %d; column number out of range\"\n            \"\\n\", j);\n      return tree->non_int[j];\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_branch_upon": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "void glp_ios_branch_upon(glp_tree *tree, int j, int sel)\n{     if (!(1 <= j && j <= tree->mip->n))\n         xerror(\"glp_ios_branch_upon: j = %d; column number out of rang\"\n            \"e\\n\", j);\n      if (!(sel == GLP_DN_BRNCH || sel == GLP_UP_BRNCH ||\n            sel == GLP_NO_BRNCH))\n         xerror(\"glp_ios_branch_upon: sel = %d: invalid branch selectio\"\n            \"n flag\\n\", sel);\n      if (!(tree->non_int[j]))\n         xerror(\"glp_ios_branch_upon: j = %d; variable cannot be used t\"\n            \"o branch upon\\n\", j);\n      if (tree->br_var != 0)\n         xerror(\"glp_ios_branch_upon: branching variable already chosen\"\n            \"\\n\");\n      tree->br_var = j;\n      tree->br_sel = sel;\n      return;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_select_node": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "void glp_ios_select_node(glp_tree *tree, int p)\n{     IOSNPD *node;\n      /* obtain pointer to the specified subproblem */\n      if (!(1 <= p && p <= tree->nslots))\nerr:     xerror(\"glp_ios_select_node: p = %d; invalid subproblem refere\"\n            \"nce number\\n\", p);\n      node = tree->slot[p].node;\n      if (node == NULL) goto err;\n      /* the specified subproblem must be active */\n      if (node->count != 0)\n         xerror(\"glp_ios_select_node: p = %d; subproblem not in the act\"\n            \"ive list\\n\", p);\n      /* no subproblem must be selected yet */\n      if (tree->next_p != 0)\n         xerror(\"glp_ios_select_node: subproblem already selected\\n\");\n      /* select the specified subproblem to continue the search */\n      tree->next_p = p;\n      return;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_ios_heur_sol": {
      "start_point": [
        634,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "int glp_ios_heur_sol(glp_tree *tree, const double x[])\n{     glp_prob *mip = tree->mip;\n      int m = tree->orig_m;\n      int n = tree->n;\n      int i, j;\n      double obj;\n      xassert(mip->m >= m);\n      xassert(mip->n == n);\n      /* check values of integer variables and compute value of the\n         objective function */\n      obj = mip->c0;\n      for (j = 1; j <= n; j++)\n      {  GLPCOL *col = mip->col[j];\n         if (col->kind == GLP_IV)\n         {  /* provided value must be integral */\n            if (x[j] != floor(x[j])) return 1;\n         }\n         obj += col->coef * x[j];\n      }\n      /* check if the provided solution is better than the best known\n         integer feasible solution */\n      if (mip->mip_stat == GLP_FEAS)\n      {  switch (mip->dir)\n         {  case GLP_MIN:\n               if (obj >= tree->mip->mip_obj) return 1;\n               break;\n            case GLP_MAX:\n               if (obj <= tree->mip->mip_obj) return 1;\n               break;\n            default:\n               xassert(mip != mip);\n         }\n      }\n      /* it is better; store it in the problem object */\n      if (tree->parm->msg_lev >= GLP_MSG_ON)\n         xprintf(\"Solution found by heuristic: %.12g\\n\", obj);\n      mip->mip_stat = GLP_FEAS;\n      mip->mip_obj = obj;\n      for (j = 1; j <= n; j++)\n         mip->col[j]->mipx = x[j];\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = mip->row[i];\n         GLPAIJ *aij;\n         row->mipx = 0.0;\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n            row->mipx += aij->val * aij->col->mipx;\n      }\n#if 1 /* 11/VII-2013 */\n      ios_process_sol(tree);\n#endif\n      return 0;\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glp_ios_terminate": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        707,
        1
      ],
      "content": "void glp_ios_terminate(glp_tree *tree)\n{     if (tree->parm->msg_lev >= GLP_MSG_DBG)\n         xprintf(\"The search is prematurely terminated due to applicati\"\n            \"on request\\n\");\n      tree->stop = 1;\n      return;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glphbm.c": {
    "read_card": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static int read_card(struct dsa *dsa)\n{     int c, len = 0;\n      char buf[255+1];\n      dsa->seqn++;\n      for (;;)\n      {  c = fgetc(dsa->fp);\n         if (c == EOF)\n         {  if (ferror(dsa->fp))\n               xprintf(\"%s:%d: read error\\n\",\n                  dsa->fname, dsa->seqn);\n            else\n               xprintf(\"%s:%d: unexpected end-of-file\\n\",\n                  dsa->fname, dsa->seqn);\n            return 1;\n         }\n         else if (c == '\\r')\n            /* nop */;\n         else if (c == '\\n')\n            break;\n         else if (iscntrl(c))\n         {  xprintf(\"%s:%d: invalid control character\\n\",\n               dsa->fname, dsa->seqn, c);\n            return 1;\n         }\n         else\n         {  if (len == sizeof(buf)-1)\n               goto err;\n            buf[len++] = (char)c;\n         }\n      }\n      /* remove trailing spaces */\n      while (len > 80 && buf[len-1] == ' ')\n         len--;\n      buf[len] = '\\0';\n      /* line should not be longer than 80 chars */\n      if (len > 80)\nerr:  {  xerror(\"%s:%d: card image too long\\n\",\n            dsa->fname, dsa->seqn);\n         return 1;\n      }\n      /* padd by spaces to 80-column card image */\n      strcpy(dsa->card, buf);\n      memset(&dsa->card[len], ' ', 80 - len);\n      dsa->card[80] = '\\0';\n      return 0;\n}",
      "lines": 46,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_int": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int scan_int(struct dsa *dsa, char *fld, int pos, int width,\n      int *val)\n{     char str[80+1];\n      xassert(1 <= width && width <= 80);\n      memcpy(str, dsa->card + pos, width), str[width] = '\\0';\n      if (str2int(strspx(str), val))\n      {  xprintf(\"%s:%d: field '%s' contains invalid value '%s'\\n\",\n            dsa->fname, dsa->seqn, fld, str);\n         return 1;\n      }\n      return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_fmt": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static int parse_fmt(struct dsa *dsa, char *fmt)\n{     int k, s, val;\n      char str[80+1];\n      /* first character should be left parenthesis */\n      if (fmt[0] != '(')\nfail: {  xprintf(\"hbm_read_mat: format '%s' not recognised\\n\", fmt);\n         return 1;\n      }\n      k = 1;\n      /* optional scale factor */\n      dsa->fmt_p = 0;\n      if (isdigit((unsigned char)fmt[k]))\n      {  s = 0;\n         while (isdigit((unsigned char)fmt[k]))\n         {  if (s == 80) goto fail;\n            str[s++] = fmt[k++];\n         }\n         str[s] = '\\0';\n         if (str2int(str, &val)) goto fail;\n         if (toupper((unsigned char)fmt[k]) != 'P') goto iter;\n         dsa->fmt_p = val, k++;\n         if (!(0 <= dsa->fmt_p && dsa->fmt_p <= 255)) goto fail;\n         /* optional comma may follow scale factor */\n         if (fmt[k] == ',') k++;\n      }\n      /* optional iterator */\n      dsa->fmt_k = 1;\n      if (isdigit((unsigned char)fmt[k]))\n      {  s = 0;\n         while (isdigit((unsigned char)fmt[k]))\n         {  if (s == 80) goto fail;\n            str[s++] = fmt[k++];\n         }\n         str[s] = '\\0';\n         if (str2int(str, &val)) goto fail;\niter:    dsa->fmt_k = val;\n         if (!(1 <= dsa->fmt_k && dsa->fmt_k <= 255)) goto fail;\n      }\n      /* format code */\n      dsa->fmt_f = toupper((unsigned char)fmt[k++]);\n      if (!(dsa->fmt_f == 'D' || dsa->fmt_f == 'E' ||\n            dsa->fmt_f == 'F' || dsa->fmt_f == 'G' ||\n            dsa->fmt_f == 'I')) goto fail;\n      /* field width */\n      if (!isdigit((unsigned char)fmt[k])) goto fail;\n      s = 0;\n      while (isdigit((unsigned char)fmt[k]))\n      {  if (s == 80) goto fail;\n         str[s++] = fmt[k++];\n      }\n      str[s] = '\\0';\n      if (str2int(str, &dsa->fmt_w)) goto fail;\n      if (!(1 <= dsa->fmt_w && dsa->fmt_w <= 255)) goto fail;\n      /* optional number of decimal places after point */\n      dsa->fmt_d = 0;\n      if (fmt[k] == '.')\n      {  k++;\n         if (!isdigit((unsigned char)fmt[k])) goto fail;\n         s = 0;\n         while (isdigit((unsigned char)fmt[k]))\n         {  if (s == 80) goto fail;\n            str[s++] = fmt[k++];\n         }\n         str[s] = '\\0';\n         if (str2int(str, &dsa->fmt_d)) goto fail;\n         if (!(0 <= dsa->fmt_d && dsa->fmt_d <= 255)) goto fail;\n      }\n      /* last character should be right parenthesis */\n      if (!(fmt[k] == ')' && fmt[k+1] == '\\0')) goto fail;\n      return 0;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_int_array": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int read_int_array(struct dsa *dsa, char *name, char *fmt,\n      int n, int val[])\n{     int k, pos;\n      char str[80+1];\n      if (parse_fmt(dsa, fmt)) return 1;\n      if (!(dsa->fmt_f == 'I' && dsa->fmt_w <= 80 &&\n            dsa->fmt_k * dsa->fmt_w <= 80))\n      {  xprintf(\n            \"%s:%d: can't read array '%s' - invalid format '%s'\\n\",\n            dsa->fname, dsa->seqn, name, fmt);\n         return 1;\n      }\n      for (k = 1, pos = INT_MAX; k <= n; k++, pos++)\n      {  if (pos >= dsa->fmt_k)\n         {  if (read_card(dsa)) return 1;\n            pos = 0;\n         }\n         memcpy(str, dsa->card + dsa->fmt_w * pos, dsa->fmt_w);\n         str[dsa->fmt_w] = '\\0';\n         strspx(str);\n         if (str2int(str, &val[k]))\n         {  xprintf(\n               \"%s:%d: can't read array '%s' - invalid value '%s'\\n\",\n               dsa->fname, dsa->seqn, name, str);\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_real_array": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static int read_real_array(struct dsa *dsa, char *name, char *fmt,\n      int n, double val[])\n{     int k, pos;\n      char str[80+1], *ptr;\n      if (parse_fmt(dsa, fmt)) return 1;\n      if (!(dsa->fmt_f != 'I' && dsa->fmt_w <= 80 &&\n            dsa->fmt_k * dsa->fmt_w <= 80))\n      {  xprintf(\n            \"%s:%d: can't read array '%s' - invalid format '%s'\\n\",\n            dsa->fname, dsa->seqn, name, fmt);\n         return 1;\n      }\n      for (k = 1, pos = INT_MAX; k <= n; k++, pos++)\n      {  if (pos >= dsa->fmt_k)\n         {  if (read_card(dsa)) return 1;\n            pos = 0;\n         }\n         memcpy(str, dsa->card + dsa->fmt_w * pos, dsa->fmt_w);\n         str[dsa->fmt_w] = '\\0';\n         strspx(str);\n         if (strchr(str, '.') == NULL && strcmp(str, \"0\"))\n         {  xprintf(\"%s(%d): can't read array '%s' - value '%s' has no \"\n               \"decimal point\\n\", dsa->fname, dsa->seqn, name, str);\n            return 1;\n         }\n         /* sometimes lower case letters appear */\n         for (ptr = str; *ptr; ptr++)\n            *ptr = (char)toupper((unsigned char)*ptr);\n         ptr = strchr(str, 'D');\n         if (ptr != NULL) *ptr = 'E';\n         /* value may appear with decimal exponent but without letters\n            E or D (for example, -123.456-012), so missing letter should\n            be inserted */\n         ptr = strchr(str+1, '+');\n         if (ptr == NULL) ptr = strchr(str+1, '-');\n         if (ptr != NULL && *(ptr-1) != 'E')\n         {  xassert(strlen(str) < 80);\n            memmove(ptr+1, ptr, strlen(ptr)+1);\n            *ptr = 'E';\n         }\n         if (str2num(str, &val[k]))\n         {  xprintf(\n               \"%s:%d: can't read array '%s' - invalid value '%s'\\n\",\n               dsa->fname, dsa->seqn, name, str);\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hbm_read_mat": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "HBM *hbm_read_mat(const char *fname)\n{     struct dsa _dsa, *dsa = &_dsa;\n      HBM *hbm = NULL;\n      dsa->fname = fname;\n      xprintf(\"hbm_read_mat: reading matrix from '%s'...\\n\",\n         dsa->fname);\n      dsa->fp = fopen(dsa->fname, \"r\");\n      if (dsa->fp == NULL)\n      {  xprintf(\"hbm_read_mat: unable to open '%s' - %s\\n\",\n#if 0 /* 29/I-2017 */\n            dsa->fname, strerror(errno));\n#else\n            dsa->fname, xstrerr(errno));\n#endif\n         goto fail;\n      }\n      dsa->seqn = 0;\n      hbm = xmalloc(sizeof(HBM));\n      memset(hbm, 0, sizeof(HBM));\n      /* read the first heading card */\n      if (read_card(dsa)) goto fail;\n      memcpy(hbm->title, dsa->card, 72), hbm->title[72] = '\\0';\n      strtrim(hbm->title);\n      xprintf(\"%s\\n\", hbm->title);\n      memcpy(hbm->key, dsa->card+72, 8), hbm->key[8] = '\\0';\n      strspx(hbm->key);\n      xprintf(\"key = %s\\n\", hbm->key);\n      /* read the second heading card */\n      if (read_card(dsa)) goto fail;\n      if (scan_int(dsa, \"totcrd\",  0, 14, &hbm->totcrd)) goto fail;\n      if (scan_int(dsa, \"ptrcrd\", 14, 14, &hbm->ptrcrd)) goto fail;\n      if (scan_int(dsa, \"indcrd\", 28, 14, &hbm->indcrd)) goto fail;\n      if (scan_int(dsa, \"valcrd\", 42, 14, &hbm->valcrd)) goto fail;\n      if (scan_int(dsa, \"rhscrd\", 56, 14, &hbm->rhscrd)) goto fail;\n      xprintf(\"totcrd = %d; ptrcrd = %d; indcrd = %d; valcrd = %d; rhsc\"\n         \"rd = %d\\n\", hbm->totcrd, hbm->ptrcrd, hbm->indcrd,\n         hbm->valcrd, hbm->rhscrd);\n      /* read the third heading card */\n      if (read_card(dsa)) goto fail;\n      memcpy(hbm->mxtype, dsa->card, 3), hbm->mxtype[3] = '\\0';\n      if (strchr(\"RCP\",   hbm->mxtype[0]) == NULL ||\n          strchr(\"SUHZR\", hbm->mxtype[1]) == NULL ||\n          strchr(\"AE\",    hbm->mxtype[2]) == NULL)\n      {  xprintf(\"%s:%d: matrix type '%s' not recognised\\n\",\n            dsa->fname, dsa->seqn, hbm->mxtype);\n         goto fail;\n      }\n      if (scan_int(dsa, \"nrow\", 14, 14, &hbm->nrow)) goto fail;\n      if (scan_int(dsa, \"ncol\", 28, 14, &hbm->ncol)) goto fail;\n      if (scan_int(dsa, \"nnzero\", 42, 14, &hbm->nnzero)) goto fail;\n      if (scan_int(dsa, \"neltvl\", 56, 14, &hbm->neltvl)) goto fail;\n      xprintf(\"mxtype = %s; nrow = %d; ncol = %d; nnzero = %d; neltvl =\"\n         \" %d\\n\", hbm->mxtype, hbm->nrow, hbm->ncol, hbm->nnzero,\n         hbm->neltvl);\n      /* read the fourth heading card */\n      if (read_card(dsa)) goto fail;\n      memcpy(hbm->ptrfmt, dsa->card, 16), hbm->ptrfmt[16] = '\\0';\n      strspx(hbm->ptrfmt);\n      memcpy(hbm->indfmt, dsa->card+16, 16), hbm->indfmt[16] = '\\0';\n      strspx(hbm->indfmt);\n      memcpy(hbm->valfmt, dsa->card+32, 20), hbm->valfmt[20] = '\\0';\n      strspx(hbm->valfmt);\n      memcpy(hbm->rhsfmt, dsa->card+52, 20), hbm->rhsfmt[20] = '\\0';\n      strspx(hbm->rhsfmt);\n      xprintf(\"ptrfmt = %s; indfmt = %s; valfmt = %s; rhsfmt = %s\\n\",\n         hbm->ptrfmt, hbm->indfmt, hbm->valfmt, hbm->rhsfmt);\n      /* read the fifth heading card (optional) */\n      if (hbm->rhscrd <= 0)\n      {  strcpy(hbm->rhstyp, \"???\");\n         hbm->nrhs = 0;\n         hbm->nrhsix = 0;\n      }\n      else\n      {  if (read_card(dsa)) goto fail;\n         memcpy(hbm->rhstyp, dsa->card, 3), hbm->rhstyp[3] = '\\0';\n         if (scan_int(dsa, \"nrhs\", 14, 14, &hbm->nrhs)) goto fail;\n         if (scan_int(dsa, \"nrhsix\", 28, 14, &hbm->nrhsix)) goto fail;\n         xprintf(\"rhstyp = '%s'; nrhs = %d; nrhsix = %d\\n\",\n            hbm->rhstyp, hbm->nrhs, hbm->nrhsix);\n      }\n      /* read matrix structure */\n      hbm->colptr = xcalloc(1+hbm->ncol+1, sizeof(int));\n      if (read_int_array(dsa, \"colptr\", hbm->ptrfmt, hbm->ncol+1,\n         hbm->colptr)) goto fail;\n      hbm->rowind = xcalloc(1+hbm->nnzero, sizeof(int));\n      if (read_int_array(dsa, \"rowind\", hbm->indfmt, hbm->nnzero,\n         hbm->rowind)) goto fail;\n      /* read matrix values */\n      if (hbm->valcrd <= 0) goto done;\n      if (hbm->mxtype[2] == 'A')\n      {  /* assembled matrix */\n         hbm->values = xcalloc(1+hbm->nnzero, sizeof(double));\n         if (read_real_array(dsa, \"values\", hbm->valfmt, hbm->nnzero,\n            hbm->values)) goto fail;\n      }\n      else\n      {  /* elemental (unassembled) matrix */\n         hbm->values = xcalloc(1+hbm->neltvl, sizeof(double));\n         if (read_real_array(dsa, \"values\", hbm->valfmt, hbm->neltvl,\n            hbm->values)) goto fail;\n      }\n      /* read right-hand sides */\n      if (hbm->nrhs <= 0) goto done;\n      if (hbm->rhstyp[0] == 'F')\n      {  /* dense format */\n         hbm->nrhsvl = hbm->nrow * hbm->nrhs;\n         hbm->rhsval = xcalloc(1+hbm->nrhsvl, sizeof(double));\n         if (read_real_array(dsa, \"rhsval\", hbm->rhsfmt, hbm->nrhsvl,\n            hbm->rhsval)) goto fail;\n      }\n      else if (hbm->rhstyp[0] == 'M' && hbm->mxtype[2] == 'A')\n      {  /* sparse format */\n         /* read pointers */\n         hbm->rhsptr = xcalloc(1+hbm->nrhs+1, sizeof(int));\n         if (read_int_array(dsa, \"rhsptr\", hbm->ptrfmt, hbm->nrhs+1,\n            hbm->rhsptr)) goto fail;\n         /* read sparsity pattern */\n         hbm->rhsind = xcalloc(1+hbm->nrhsix, sizeof(int));\n         if (read_int_array(dsa, \"rhsind\", hbm->indfmt, hbm->nrhsix,\n            hbm->rhsind)) goto fail;\n         /* read values */\n         hbm->rhsval = xcalloc(1+hbm->nrhsix, sizeof(double));\n         if (read_real_array(dsa, \"rhsval\", hbm->rhsfmt, hbm->nrhsix,\n            hbm->rhsval)) goto fail;\n      }\n      else if (hbm->rhstyp[0] == 'M' && hbm->mxtype[2] == 'E')\n      {  /* elemental format */\n         hbm->rhsval = xcalloc(1+hbm->nrhsvl, sizeof(double));\n         if (read_real_array(dsa, \"rhsval\", hbm->rhsfmt, hbm->nrhsvl,\n            hbm->rhsval)) goto fail;\n      }\n      else\n      {  xprintf(\"%s:%d: right-hand side type '%c' not recognised\\n\",\n            dsa->fname, dsa->seqn, hbm->rhstyp[0]);\n         goto fail;\n      }\n      /* read starting guesses */\n      if (hbm->rhstyp[1] == 'G')\n      {  hbm->nguess = hbm->nrow * hbm->nrhs;\n         hbm->sguess = xcalloc(1+hbm->nguess, sizeof(double));\n         if (read_real_array(dsa, \"sguess\", hbm->rhsfmt, hbm->nguess,\n            hbm->sguess)) goto fail;\n      }\n      /* read solution vectors */\n      if (hbm->rhstyp[2] == 'X')\n      {  hbm->nexact = hbm->nrow * hbm->nrhs;\n         hbm->xexact = xcalloc(1+hbm->nexact, sizeof(double));\n         if (read_real_array(dsa, \"xexact\", hbm->rhsfmt, hbm->nexact,\n            hbm->xexact)) goto fail;\n      }\ndone: /* reading has been completed */\n      xprintf(\"hbm_read_mat: %d cards were read\\n\", dsa->seqn);\n      fclose(dsa->fp);\n      return hbm;\nfail: /* something wrong in Danish kingdom */\n      if (hbm != NULL)\n      {  if (hbm->colptr != NULL) xfree(hbm->colptr);\n         if (hbm->rowind != NULL) xfree(hbm->rowind);\n         if (hbm->rhsptr != NULL) xfree(hbm->rhsptr);\n         if (hbm->rhsind != NULL) xfree(hbm->rhsind);\n         if (hbm->values != NULL) xfree(hbm->values);\n         if (hbm->rhsval != NULL) xfree(hbm->rhsval);\n         if (hbm->sguess != NULL) xfree(hbm->sguess);\n         if (hbm->xexact != NULL) xfree(hbm->xexact);\n         xfree(hbm);\n      }\n      if (dsa->fp != NULL) fclose(dsa->fp);\n      return NULL;\n}",
      "lines": 169,
      "depth": 13,
      "decorators": [
        "HBM",
        "*hbm_read_mat(const char *fname)",
        "*"
      ]
    },
    "hbm_free_mat": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "void hbm_free_mat(HBM *hbm)\n{     if (hbm->colptr != NULL) xfree(hbm->colptr);\n      if (hbm->rowind != NULL) xfree(hbm->rowind);\n      if (hbm->rhsptr != NULL) xfree(hbm->rhsptr);\n      if (hbm->rhsind != NULL) xfree(hbm->rhsind);\n      if (hbm->values != NULL) xfree(hbm->values);\n      if (hbm->rhsval != NULL) xfree(hbm->rhsval);\n      if (hbm->sguess != NULL) xfree(hbm->sguess);\n      if (hbm->xexact != NULL) xfree(hbm->xexact);\n      xfree(hbm);\n      return;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glphbm.h": {},
  "glpk/glpk-4.65/src/draft/glpios01.c": {
    "lpx_eval_tab_row": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "static int lpx_eval_tab_row(glp_prob *lp, int k, int ind[],\n      double val[])\n{     /* compute row of the simplex tableau */\n      return glp_eval_tab_row(lp, k, ind, val);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lpx_dual_ratio_test": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int lpx_dual_ratio_test(glp_prob *lp, int len, const int ind[],\n      const double val[], int how, double tol)\n{     /* perform dual ratio test */\n      int piv;\n      piv = glp_dual_rtest(lp, len, ind, val, how, tol);\n      xassert(0 <= piv && piv <= len);\n      return piv == 0 ? 0 : ind[piv];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ios_create_tree": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "glp_tree *ios_create_tree(glp_prob *mip, const glp_iocp *parm)\n{     int m = mip->m;\n      int n = mip->n;\n      glp_tree *tree;\n      int i, j;\n      xassert(mip->tree == NULL);\n      mip->tree = tree = xmalloc(sizeof(glp_tree));\n      tree->pool = dmp_create_pool();\n      tree->n = n;\n      /* save original problem components */\n      tree->orig_m = m;\n      tree->orig_type = xcalloc(1+m+n, sizeof(char));\n      tree->orig_lb = xcalloc(1+m+n, sizeof(double));\n      tree->orig_ub = xcalloc(1+m+n, sizeof(double));\n      tree->orig_stat = xcalloc(1+m+n, sizeof(char));\n      tree->orig_prim = xcalloc(1+m+n, sizeof(double));\n      tree->orig_dual = xcalloc(1+m+n, sizeof(double));\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = mip->row[i];\n         tree->orig_type[i] = (char)row->type;\n         tree->orig_lb[i] = row->lb;\n         tree->orig_ub[i] = row->ub;\n         tree->orig_stat[i] = (char)row->stat;\n         tree->orig_prim[i] = row->prim;\n         tree->orig_dual[i] = row->dual;\n      }\n      for (j = 1; j <= n; j++)\n      {  GLPCOL *col = mip->col[j];\n         tree->orig_type[m+j] = (char)col->type;\n         tree->orig_lb[m+j] = col->lb;\n         tree->orig_ub[m+j] = col->ub;\n         tree->orig_stat[m+j] = (char)col->stat;\n         tree->orig_prim[m+j] = col->prim;\n         tree->orig_dual[m+j] = col->dual;\n      }\n      tree->orig_obj = mip->obj_val;\n      /* initialize the branch-and-bound tree */\n      tree->nslots = 0;\n      tree->avail = 0;\n      tree->slot = NULL;\n      tree->head = tree->tail = NULL;\n      tree->a_cnt = tree->n_cnt = tree->t_cnt = 0;\n      /* the root subproblem is not solved yet, so its final components\n         are unknown so far */\n      tree->root_m = 0;\n      tree->root_type = NULL;\n      tree->root_lb = tree->root_ub = NULL;\n      tree->root_stat = NULL;\n      /* the current subproblem does not exist yet */\n      tree->curr = NULL;\n      tree->mip = mip;\n      /*tree->solved = 0;*/\n      tree->non_int = xcalloc(1+n, sizeof(char));\n      memset(&tree->non_int[1], 0, n);\n      /* arrays to save parent subproblem components will be allocated\n         later */\n      tree->pred_m = tree->pred_max = 0;\n      tree->pred_type = NULL;\n      tree->pred_lb = tree->pred_ub = NULL;\n      tree->pred_stat = NULL;\n      /* cut generators */\n      tree->local = ios_create_pool(tree);\n      /*tree->first_attempt = 1;*/\n      /*tree->max_added_cuts = 0;*/\n      /*tree->min_eff = 0.0;*/\n      /*tree->miss = 0;*/\n      /*tree->just_selected = 0;*/\n#ifdef NEW_COVER /* 13/II-2018 */\n      tree->cov_gen = NULL;\n#endif\n      tree->mir_gen = NULL;\n      tree->clq_gen = NULL;\n      /*tree->round = 0;*/\n#if 0\n      /* create the conflict graph */\n      tree->n_ref = xcalloc(1+n, sizeof(int));\n      memset(&tree->n_ref[1], 0, n * sizeof(int));\n      tree->c_ref = xcalloc(1+n, sizeof(int));\n      memset(&tree->c_ref[1], 0, n * sizeof(int));\n      tree->g = scg_create_graph(0);\n      tree->j_ref = xcalloc(1+tree->g->n_max, sizeof(int));\n#endif\n      /* pseudocost branching */\n      tree->pcost = NULL;\n      tree->iwrk = xcalloc(1+n, sizeof(int));\n      tree->dwrk = xcalloc(1+n, sizeof(double));\n      /* initialize control parameters */\n      tree->parm = parm;\n      tree->tm_beg = xtime();\n#if 0 /* 10/VI-2013 */\n      tree->tm_lag = xlset(0);\n#else\n      tree->tm_lag = 0.0;\n#endif\n      tree->sol_cnt = 0;\n#if 1 /* 11/VII-2013 */\n      tree->P = NULL;\n      tree->npp = NULL;\n      tree->save_sol = parm->save_sol;\n      tree->save_cnt = 0;\n#endif\n      /* initialize advanced solver interface */\n      tree->reason = 0;\n      tree->reopt = 0;\n      tree->reinv = 0;\n      tree->br_var = 0;\n      tree->br_sel = 0;\n      tree->child = 0;\n      tree->next_p = 0;\n      /*tree->btrack = NULL;*/\n      tree->stop = 0;\n      /* create the root subproblem, which initially is identical to\n         the original MIP */\n      new_node(tree, NULL);\n      return tree;\n}",
      "lines": 116,
      "depth": 11,
      "decorators": [
        "glp_tree",
        "*ios_create_tree(glp_prob *mip, const glp_iocp *parm)",
        "*"
      ]
    },
    "ios_revive_node": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void ios_revive_node(glp_tree *tree, int p)\n{     glp_prob *mip = tree->mip;\n      IOSNPD *node, *root;\n      /* obtain pointer to the specified subproblem */\n      xassert(1 <= p && p <= tree->nslots);\n      node = tree->slot[p].node;\n      xassert(node != NULL);\n      /* the specified subproblem must be active */\n      xassert(node->count == 0);\n      /* the current subproblem must not exist */\n      xassert(tree->curr == NULL);\n      /* the specified subproblem becomes current */\n      tree->curr = node;\n      /*tree->solved = 0;*/\n      /* obtain pointer to the root subproblem */\n      root = tree->slot[1].node;\n      xassert(root != NULL);\n      /* at this point problem object components correspond to the root\n         subproblem, so if the root subproblem should be revived, there\n         is nothing more to do */\n      if (node == root) goto done;\n      xassert(mip->m == tree->root_m);\n      /* build path from the root to the current node */\n      node->temp = NULL;\n      for (node = node; node != NULL; node = node->up)\n      {  if (node->up == NULL)\n            xassert(node == root);\n         else\n            node->up->temp = node;\n      }\n      /* go down from the root to the current node and make necessary\n         changes to restore components of the current subproblem */\n      for (node = root; node != NULL; node = node->temp)\n      {  int m = mip->m;\n         int n = mip->n;\n         /* if the current node is reached, the problem object at this\n            point corresponds to its parent, so save attributes of rows\n            and columns for the parent subproblem */\n         if (node->temp == NULL)\n         {  int i, j;\n            tree->pred_m = m;\n            /* allocate/reallocate arrays, if necessary */\n            if (tree->pred_max < m + n)\n            {  int new_size = m + n + 100;\n               if (tree->pred_type != NULL) xfree(tree->pred_type);\n               if (tree->pred_lb != NULL) xfree(tree->pred_lb);\n               if (tree->pred_ub != NULL) xfree(tree->pred_ub);\n               if (tree->pred_stat != NULL) xfree(tree->pred_stat);\n               tree->pred_max = new_size;\n               tree->pred_type = xcalloc(1+new_size, sizeof(char));\n               tree->pred_lb = xcalloc(1+new_size, sizeof(double));\n               tree->pred_ub = xcalloc(1+new_size, sizeof(double));\n               tree->pred_stat = xcalloc(1+new_size, sizeof(char));\n            }\n            /* save row attributes */\n            for (i = 1; i <= m; i++)\n            {  GLPROW *row = mip->row[i];\n               tree->pred_type[i] = (char)row->type;\n               tree->pred_lb[i] = row->lb;\n               tree->pred_ub[i] = row->ub;\n               tree->pred_stat[i] = (char)row->stat;\n            }\n            /* save column attributes */\n            for (j = 1; j <= n; j++)\n            {  GLPCOL *col = mip->col[j];\n               tree->pred_type[mip->m+j] = (char)col->type;\n               tree->pred_lb[mip->m+j] = col->lb;\n               tree->pred_ub[mip->m+j] = col->ub;\n               tree->pred_stat[mip->m+j] = (char)col->stat;\n            }\n         }\n         /* change bounds of rows and columns */\n         {  IOSBND *b;\n            for (b = node->b_ptr; b != NULL; b = b->next)\n            {  if (b->k <= m)\n                  glp_set_row_bnds(mip, b->k, b->type, b->lb, b->ub);\n               else\n                  glp_set_col_bnds(mip, b->k-m, b->type, b->lb, b->ub);\n            }\n         }\n         /* change statuses of rows and columns */\n         {  IOSTAT *s;\n            for (s = node->s_ptr; s != NULL; s = s->next)\n            {  if (s->k <= m)\n                  glp_set_row_stat(mip, s->k, s->stat);\n               else\n                  glp_set_col_stat(mip, s->k-m, s->stat);\n            }\n         }\n         /* add new rows */\n         if (node->r_ptr != NULL)\n         {  IOSROW *r;\n            IOSAIJ *a;\n            int i, len, *ind;\n            double *val;\n            ind = xcalloc(1+n, sizeof(int));\n            val = xcalloc(1+n, sizeof(double));\n            for (r = node->r_ptr; r != NULL; r = r->next)\n            {  i = glp_add_rows(mip, 1);\n               glp_set_row_name(mip, i, r->name);\n#if 1 /* 20/IX-2008 */\n               xassert(mip->row[i]->level == 0);\n               mip->row[i]->level = node->level;\n               mip->row[i]->origin = r->origin;\n               mip->row[i]->klass = r->klass;\n#endif\n               glp_set_row_bnds(mip, i, r->type, r->lb, r->ub);\n               len = 0;\n               for (a = r->ptr; a != NULL; a = a->next)\n                  len++, ind[len] = a->j, val[len] = a->val;\n               glp_set_mat_row(mip, i, len, ind, val);\n               glp_set_rii(mip, i, r->rii);\n               glp_set_row_stat(mip, i, r->stat);\n            }\n            xfree(ind);\n            xfree(val);\n         }\n#if 0\n         /* add new edges to the conflict graph */\n         /* add new cliques to the conflict graph */\n         /* (not implemented yet) */\n         xassert(node->own_nn == 0);\n         xassert(node->own_nc == 0);\n         xassert(node->e_ptr == NULL);\n#endif\n      }\n      /* the specified subproblem has been revived */\n      node = tree->curr;\n      /* delete its bound change list */\n      while (node->b_ptr != NULL)\n      {  IOSBND *b;\n         b = node->b_ptr;\n         node->b_ptr = b->next;\n         dmp_free_atom(tree->pool, b, sizeof(IOSBND));\n      }\n      /* delete its status change list */\n      while (node->s_ptr != NULL)\n      {  IOSTAT *s;\n         s = node->s_ptr;\n         node->s_ptr = s->next;\n         dmp_free_atom(tree->pool, s, sizeof(IOSTAT));\n      }\n#if 1 /* 20/XI-2009 */\n      /* delete its row addition list (additional rows may appear, for\n         example, due to branching on GUB constraints */\n      while (node->r_ptr != NULL)\n      {  IOSROW *r;\n         r = node->r_ptr;\n         node->r_ptr = r->next;\n         xassert(r->name == NULL);\n         while (r->ptr != NULL)\n         {  IOSAIJ *a;\n            a = r->ptr;\n            r->ptr = a->next;\n            dmp_free_atom(tree->pool, a, sizeof(IOSAIJ));\n         }\n         dmp_free_atom(tree->pool, r, sizeof(IOSROW));\n      }\n#endif\ndone: return;\n}",
      "lines": 161,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "ios_freeze_node": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "void ios_freeze_node(glp_tree *tree)\n{     glp_prob *mip = tree->mip;\n      int m = mip->m;\n      int n = mip->n;\n      IOSNPD *node;\n      /* obtain pointer to the current subproblem */\n      node = tree->curr;\n      xassert(node != NULL);\n      if (node->up == NULL)\n      {  /* freeze the root subproblem */\n         int k;\n         xassert(node->p == 1);\n         xassert(tree->root_m == 0);\n         xassert(tree->root_type == NULL);\n         xassert(tree->root_lb == NULL);\n         xassert(tree->root_ub == NULL);\n         xassert(tree->root_stat == NULL);\n         tree->root_m = m;\n         tree->root_type = xcalloc(1+m+n, sizeof(char));\n         tree->root_lb = xcalloc(1+m+n, sizeof(double));\n         tree->root_ub = xcalloc(1+m+n, sizeof(double));\n         tree->root_stat = xcalloc(1+m+n, sizeof(char));\n         for (k = 1; k <= m+n; k++)\n         {  if (k <= m)\n            {  GLPROW *row = mip->row[k];\n               tree->root_type[k] = (char)row->type;\n               tree->root_lb[k] = row->lb;\n               tree->root_ub[k] = row->ub;\n               tree->root_stat[k] = (char)row->stat;\n            }\n            else\n            {  GLPCOL *col = mip->col[k-m];\n               tree->root_type[k] = (char)col->type;\n               tree->root_lb[k] = col->lb;\n               tree->root_ub[k] = col->ub;\n               tree->root_stat[k] = (char)col->stat;\n            }\n         }\n      }\n      else\n      {  /* freeze non-root subproblem */\n         int root_m = tree->root_m;\n         int pred_m = tree->pred_m;\n         int i, j, k;\n         xassert(pred_m <= m);\n         /* build change lists for rows and columns which exist in the\n            parent subproblem */\n         xassert(node->b_ptr == NULL);\n         xassert(node->s_ptr == NULL);\n         for (k = 1; k <= pred_m + n; k++)\n         {  int pred_type, pred_stat, type, stat;\n            double pred_lb, pred_ub, lb, ub;\n            /* determine attributes in the parent subproblem */\n            pred_type = tree->pred_type[k];\n            pred_lb = tree->pred_lb[k];\n            pred_ub = tree->pred_ub[k];\n            pred_stat = tree->pred_stat[k];\n            /* determine attributes in the current subproblem */\n            if (k <= pred_m)\n            {  GLPROW *row = mip->row[k];\n               type = row->type;\n               lb = row->lb;\n               ub = row->ub;\n               stat = row->stat;\n            }\n            else\n            {  GLPCOL *col = mip->col[k - pred_m];\n               type = col->type;\n               lb = col->lb;\n               ub = col->ub;\n               stat = col->stat;\n            }\n            /* save type and bounds of a row/column, if changed */\n            if (!(pred_type == type && pred_lb == lb && pred_ub == ub))\n            {  IOSBND *b;\n               b = dmp_get_atom(tree->pool, sizeof(IOSBND));\n               b->k = k;\n               b->type = (unsigned char)type;\n               b->lb = lb;\n               b->ub = ub;\n               b->next = node->b_ptr;\n               node->b_ptr = b;\n            }\n            /* save status of a row/column, if changed */\n            if (pred_stat != stat)\n            {  IOSTAT *s;\n               s = dmp_get_atom(tree->pool, sizeof(IOSTAT));\n               s->k = k;\n               s->stat = (unsigned char)stat;\n               s->next = node->s_ptr;\n               node->s_ptr = s;\n            }\n         }\n         /* save new rows added to the current subproblem */\n         xassert(node->r_ptr == NULL);\n         if (pred_m < m)\n         {  int i, len, *ind;\n            double *val;\n            ind = xcalloc(1+n, sizeof(int));\n            val = xcalloc(1+n, sizeof(double));\n            for (i = m; i > pred_m; i--)\n            {  GLPROW *row = mip->row[i];\n               IOSROW *r;\n               const char *name;\n               r = dmp_get_atom(tree->pool, sizeof(IOSROW));\n               name = glp_get_row_name(mip, i);\n               if (name == NULL)\n                  r->name = NULL;\n               else\n               {  r->name = dmp_get_atom(tree->pool, strlen(name)+1);\n                  strcpy(r->name, name);\n               }\n#if 1 /* 20/IX-2008 */\n               r->origin = row->origin;\n               r->klass = row->klass;\n#endif\n               r->type = (unsigned char)row->type;\n               r->lb = row->lb;\n               r->ub = row->ub;\n               r->ptr = NULL;\n               len = glp_get_mat_row(mip, i, ind, val);\n               for (k = 1; k <= len; k++)\n               {  IOSAIJ *a;\n                  a = dmp_get_atom(tree->pool, sizeof(IOSAIJ));\n                  a->j = ind[k];\n                  a->val = val[k];\n                  a->next = r->ptr;\n                  r->ptr = a;\n               }\n               r->rii = row->rii;\n               r->stat = (unsigned char)row->stat;\n               r->next = node->r_ptr;\n               node->r_ptr = r;\n            }\n            xfree(ind);\n            xfree(val);\n         }\n         /* remove all rows missing in the root subproblem */\n         if (m != root_m)\n         {  int nrs, *num;\n            nrs = m - root_m;\n            xassert(nrs > 0);\n            num = xcalloc(1+nrs, sizeof(int));\n            for (i = 1; i <= nrs; i++) num[i] = root_m + i;\n            glp_del_rows(mip, nrs, num);\n            xfree(num);\n         }\n         m = mip->m;\n         /* and restore attributes of all rows and columns for the root\n            subproblem */\n         xassert(m == root_m);\n         for (i = 1; i <= m; i++)\n         {  glp_set_row_bnds(mip, i, tree->root_type[i],\n               tree->root_lb[i], tree->root_ub[i]);\n            glp_set_row_stat(mip, i, tree->root_stat[i]);\n         }\n         for (j = 1; j <= n; j++)\n         {  glp_set_col_bnds(mip, j, tree->root_type[m+j],\n               tree->root_lb[m+j], tree->root_ub[m+j]);\n            glp_set_col_stat(mip, j, tree->root_stat[m+j]);\n         }\n#if 1\n         /* remove all edges and cliques missing in the conflict graph\n            for the root subproblem */\n         /* (not implemented yet) */\n#endif\n      }\n      /* the current subproblem has been frozen */\n      tree->curr = NULL;\n      return;\n}",
      "lines": 171,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "get_slot": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "static int get_slot(glp_tree *tree)\n{     int p;\n      /* if no free slots are available, increase the room */\n      if (tree->avail == 0)\n      {  int nslots = tree->nslots;\n         IOSLOT *save = tree->slot;\n         if (nslots == 0)\n            tree->nslots = 20;\n         else\n         {  tree->nslots = nslots + nslots;\n            xassert(tree->nslots > nslots);\n         }\n         tree->slot = xcalloc(1+tree->nslots, sizeof(IOSLOT));\n         if (save != NULL)\n         {  memcpy(&tree->slot[1], &save[1], nslots * sizeof(IOSLOT));\n            xfree(save);\n         }\n         /* push more free slots into the stack */\n         for (p = tree->nslots; p > nslots; p--)\n         {  tree->slot[p].node = NULL;\n            tree->slot[p].next = tree->avail;\n            tree->avail = p;\n         }\n      }\n      /* pull a free slot from the stack */\n      p = tree->avail;\n      tree->avail = tree->slot[p].next;\n      xassert(tree->slot[p].node == NULL);\n      tree->slot[p].next = 0;\n      return p;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "new_node": {
      "start_point": [
        606,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "static IOSNPD *new_node(glp_tree *tree, IOSNPD *parent)\n{     IOSNPD *node;\n      int p;\n      /* pull a free slot for the new node */\n      p = get_slot(tree);\n      /* create descriptor of the new subproblem */\n      node = dmp_get_atom(tree->pool, sizeof(IOSNPD));\n      tree->slot[p].node = node;\n      node->p = p;\n      node->up = parent;\n      node->level = (parent == NULL ? 0 : parent->level + 1);\n      node->count = 0;\n      node->b_ptr = NULL;\n      node->s_ptr = NULL;\n      node->r_ptr = NULL;\n      node->solved = 0;\n#if 0\n      node->own_nn = node->own_nc = 0;\n      node->e_ptr = NULL;\n#endif\n#if 1 /* 04/X-2008 */\n      node->lp_obj = (parent == NULL ? (tree->mip->dir == GLP_MIN ?\n         -DBL_MAX : +DBL_MAX) : parent->lp_obj);\n#endif\n      node->bound = (parent == NULL ? (tree->mip->dir == GLP_MIN ?\n         -DBL_MAX : +DBL_MAX) : parent->bound);\n      node->br_var = 0;\n      node->br_val = 0.0;\n      node->ii_cnt = 0;\n      node->ii_sum = 0.0;\n#if 1 /* 30/XI-2009 */\n      node->changed = 0;\n#endif\n      if (tree->parm->cb_size == 0)\n         node->data = NULL;\n      else\n      {  node->data = dmp_get_atom(tree->pool, tree->parm->cb_size);\n         memset(node->data, 0, tree->parm->cb_size);\n      }\n      node->temp = NULL;\n      node->prev = tree->tail;\n      node->next = NULL;\n      /* add the new subproblem to the end of the active list */\n      if (tree->head == NULL)\n         tree->head = node;\n      else\n         tree->tail->next = node;\n      tree->tail = node;\n      tree->a_cnt++;\n      tree->n_cnt++;\n      tree->t_cnt++;\n      /* increase the number of child subproblems */\n      if (parent == NULL)\n         xassert(p == 1);\n      else\n         parent->count++;\n      return node;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "IOSNPD",
        "*new_node(glp_tree *tree, IOSNPD *parent)",
        "*"
      ]
    },
    "ios_clone_node": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "void ios_clone_node(glp_tree *tree, int p, int nnn, int ref[])\n{     IOSNPD *node;\n      int k;\n      /* obtain pointer to the subproblem to be cloned */\n      xassert(1 <= p && p <= tree->nslots);\n      node = tree->slot[p].node;\n      xassert(node != NULL);\n      /* the specified subproblem must be active */\n      xassert(node->count == 0);\n      /* and must be in the frozen state */\n      xassert(tree->curr != node);\n      /* remove the specified subproblem from the active list, because\n         it becomes inactive */\n      if (node->prev == NULL)\n         tree->head = node->next;\n      else\n         node->prev->next = node->next;\n      if (node->next == NULL)\n         tree->tail = node->prev;\n      else\n         node->next->prev = node->prev;\n      node->prev = node->next = NULL;\n      tree->a_cnt--;\n      /* create clone subproblems */\n      xassert(nnn > 0);\n      for (k = 1; k <= nnn; k++)\n         ref[k] = new_node(tree, node)->p;\n      return;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ios_delete_node": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "void ios_delete_node(glp_tree *tree, int p)\n{     IOSNPD *node, *temp;\n      /* obtain pointer to the subproblem to be deleted */\n      xassert(1 <= p && p <= tree->nslots);\n      node = tree->slot[p].node;\n      xassert(node != NULL);\n      /* the specified subproblem must be active */\n      xassert(node->count == 0);\n      /* and must be in the frozen state */\n      xassert(tree->curr != node);\n      /* remove the specified subproblem from the active list, because\n         it is gone from the tree */\n      if (node->prev == NULL)\n         tree->head = node->next;\n      else\n         node->prev->next = node->next;\n      if (node->next == NULL)\n         tree->tail = node->prev;\n      else\n         node->next->prev = node->prev;\n      node->prev = node->next = NULL;\n      tree->a_cnt--;\nloop: /* recursive deletion starts here */\n      /* delete the bound change list */\n      {  IOSBND *b;\n         while (node->b_ptr != NULL)\n         {  b = node->b_ptr;\n            node->b_ptr = b->next;\n            dmp_free_atom(tree->pool, b, sizeof(IOSBND));\n         }\n      }\n      /* delete the status change list */\n      {  IOSTAT *s;\n         while (node->s_ptr != NULL)\n         {  s = node->s_ptr;\n            node->s_ptr = s->next;\n            dmp_free_atom(tree->pool, s, sizeof(IOSTAT));\n         }\n      }\n      /* delete the row addition list */\n      while (node->r_ptr != NULL)\n      {  IOSROW *r;\n         r = node->r_ptr;\n         if (r->name != NULL)\n            dmp_free_atom(tree->pool, r->name, strlen(r->name)+1);\n         while (r->ptr != NULL)\n         {  IOSAIJ *a;\n            a = r->ptr;\n            r->ptr = a->next;\n            dmp_free_atom(tree->pool, a, sizeof(IOSAIJ));\n         }\n         node->r_ptr = r->next;\n         dmp_free_atom(tree->pool, r, sizeof(IOSROW));\n      }\n#if 0\n      /* delete the edge addition list */\n      /* delete the clique addition list */\n      /* (not implemented yet) */\n      xassert(node->own_nn == 0);\n      xassert(node->own_nc == 0);\n      xassert(node->e_ptr == NULL);\n#endif\n      /* free application-specific data */\n      if (tree->parm->cb_size == 0)\n         xassert(node->data == NULL);\n      else\n         dmp_free_atom(tree->pool, node->data, tree->parm->cb_size);\n      /* free the corresponding node slot */\n      p = node->p;\n      xassert(tree->slot[p].node == node);\n      tree->slot[p].node = NULL;\n      tree->slot[p].next = tree->avail;\n      tree->avail = p;\n      /* save pointer to the parent subproblem */\n      temp = node->up;\n      /* delete the subproblem descriptor */\n      dmp_free_atom(tree->pool, node, sizeof(IOSNPD));\n      tree->n_cnt--;\n      /* take pointer to the parent subproblem */\n      node = temp;\n      if (node != NULL)\n      {  /* the parent subproblem exists; decrease the number of its\n            child subproblems */\n         xassert(node->count > 0);\n         node->count--;\n         /* if now the parent subproblem has no childs, it also must be\n            deleted */\n         if (node->count == 0) goto loop;\n      }\n      return;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "ios_delete_tree": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "void ios_delete_tree(glp_tree *tree)\n{     glp_prob *mip = tree->mip;\n      int i, j;\n      int m = mip->m;\n      int n = mip->n;\n      xassert(mip->tree == tree);\n      /* remove all additional rows */\n      if (m != tree->orig_m)\n      {  int nrs, *num;\n         nrs = m - tree->orig_m;\n         xassert(nrs > 0);\n         num = xcalloc(1+nrs, sizeof(int));\n         for (i = 1; i <= nrs; i++) num[i] = tree->orig_m + i;\n         glp_del_rows(mip, nrs, num);\n         xfree(num);\n      }\n      m = tree->orig_m;\n      /* restore original attributes of rows and columns */\n      xassert(m == tree->orig_m);\n      xassert(n == tree->n);\n      for (i = 1; i <= m; i++)\n      {  glp_set_row_bnds(mip, i, tree->orig_type[i],\n            tree->orig_lb[i], tree->orig_ub[i]);\n         glp_set_row_stat(mip, i, tree->orig_stat[i]);\n         mip->row[i]->prim = tree->orig_prim[i];\n         mip->row[i]->dual = tree->orig_dual[i];\n      }\n      for (j = 1; j <= n; j++)\n      {  glp_set_col_bnds(mip, j, tree->orig_type[m+j],\n            tree->orig_lb[m+j], tree->orig_ub[m+j]);\n         glp_set_col_stat(mip, j, tree->orig_stat[m+j]);\n         mip->col[j]->prim = tree->orig_prim[m+j];\n         mip->col[j]->dual = tree->orig_dual[m+j];\n      }\n      mip->pbs_stat = mip->dbs_stat = GLP_FEAS;\n      mip->obj_val = tree->orig_obj;\n      /* delete the branch-and-bound tree */\n      xassert(tree->local != NULL);\n      ios_delete_pool(tree, tree->local);\n      dmp_delete_pool(tree->pool);\n      xfree(tree->orig_type);\n      xfree(tree->orig_lb);\n      xfree(tree->orig_ub);\n      xfree(tree->orig_stat);\n      xfree(tree->orig_prim);\n      xfree(tree->orig_dual);\n      xfree(tree->slot);\n      if (tree->root_type != NULL) xfree(tree->root_type);\n      if (tree->root_lb != NULL) xfree(tree->root_lb);\n      if (tree->root_ub != NULL) xfree(tree->root_ub);\n      if (tree->root_stat != NULL) xfree(tree->root_stat);\n      xfree(tree->non_int);\n#if 0\n      xfree(tree->n_ref);\n      xfree(tree->c_ref);\n      xfree(tree->j_ref);\n#endif\n      if (tree->pcost != NULL) ios_pcost_free(tree);\n      xfree(tree->iwrk);\n      xfree(tree->dwrk);\n#if 0\n      scg_delete_graph(tree->g);\n#endif\n      if (tree->pred_type != NULL) xfree(tree->pred_type);\n      if (tree->pred_lb != NULL) xfree(tree->pred_lb);\n      if (tree->pred_ub != NULL) xfree(tree->pred_ub);\n      if (tree->pred_stat != NULL) xfree(tree->pred_stat);\n#if 0\n      xassert(tree->cut_gen == NULL);\n#endif\n      xassert(tree->mir_gen == NULL);\n      xassert(tree->clq_gen == NULL);\n      xfree(tree);\n      mip->tree = NULL;\n      return;\n}",
      "lines": 76,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ios_eval_degrad": {
      "start_point": [
        921,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "void ios_eval_degrad(glp_tree *tree, int j, double *dn, double *up)\n{     glp_prob *mip = tree->mip;\n      int m = mip->m, n = mip->n;\n      int len, kase, k, t, stat;\n      double alfa, beta, gamma, delta, dz;\n      int *ind = tree->iwrk;\n      double *val = tree->dwrk;\n      /* current basis must be optimal */\n      xassert(glp_get_status(mip) == GLP_OPT);\n      /* basis factorization must exist */\n      xassert(glp_bf_exists(mip));\n      /* obtain (fractional) value of x[j] in optimal basic solution\n         to LP relaxation of the current subproblem */\n      xassert(1 <= j && j <= n);\n      beta = mip->col[j]->prim;\n      /* since the value of x[j] is fractional, it is basic; compute\n         corresponding row of the simplex table */\n      len = lpx_eval_tab_row(mip, m+j, ind, val);\n      /* kase < 0 means down-branch; kase > 0 means up-branch */\n      for (kase = -1; kase <= +1; kase += 2)\n      {  /* for down-branch we introduce new upper bound floor(beta)\n            for x[j]; similarly, for up-branch we introduce new lower\n            bound ceil(beta) for x[j]; in the current basis this new\n            upper/lower bound is violated, so in the adjacent basis\n            x[j] will leave the basis and go to its new upper/lower\n            bound; we need to know which non-basic variable x[k] should\n            enter the basis to keep dual feasibility */\n#if 0 /* 23/XI-2009 */\n         k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-7);\n#else\n         k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-9);\n#endif\n         /* if no variable has been chosen, current basis being primal\n            infeasible due to the new upper/lower bound of x[j] is dual\n            unbounded, therefore, LP relaxation to corresponding branch\n            has no primal feasible solution */\n         if (k == 0)\n         {  if (mip->dir == GLP_MIN)\n            {  if (kase < 0)\n                  *dn = +DBL_MAX;\n               else\n                  *up = +DBL_MAX;\n            }\n            else if (mip->dir == GLP_MAX)\n            {  if (kase < 0)\n                  *dn = -DBL_MAX;\n               else\n                  *up = -DBL_MAX;\n            }\n            else\n               xassert(mip != mip);\n            continue;\n         }\n         xassert(1 <= k && k <= m+n);\n         /* row of the simplex table corresponding to specified basic\n            variable x[j] is the following:\n               x[j] = ... + alfa * x[k] + ... ;\n            we need to know influence coefficient, alfa, at non-basic\n            variable x[k] chosen with the dual ratio test */\n         for (t = 1; t <= len; t++)\n            if (ind[t] == k) break;\n         xassert(1 <= t && t <= len);\n         alfa = val[t];\n         /* determine status and reduced cost of variable x[k] */\n         if (k <= m)\n         {  stat = mip->row[k]->stat;\n            gamma = mip->row[k]->dual;\n         }\n         else\n         {  stat = mip->col[k-m]->stat;\n            gamma = mip->col[k-m]->dual;\n         }\n         /* x[k] cannot be basic or fixed non-basic */\n         xassert(stat == GLP_NL || stat == GLP_NU || stat == GLP_NF);\n         /* if the current basis is dual degenerative, some reduced\n            costs, which are close to zero, may have wrong sign due to\n            round-off errors, so correct the sign of gamma */\n         if (mip->dir == GLP_MIN)\n         {  if (stat == GLP_NL && gamma < 0.0 ||\n                stat == GLP_NU && gamma > 0.0 ||\n                stat == GLP_NF) gamma = 0.0;\n         }\n         else if (mip->dir == GLP_MAX)\n         {  if (stat == GLP_NL && gamma > 0.0 ||\n                stat == GLP_NU && gamma < 0.0 ||\n                stat == GLP_NF) gamma = 0.0;\n         }\n         else\n            xassert(mip != mip);\n         /* determine the change of x[j] in the adjacent basis:\n            delta x[j] = new x[j] - old x[j] */\n         delta = (kase < 0 ? floor(beta) : ceil(beta)) - beta;\n         /* compute the change of x[k] in the adjacent basis:\n            delta x[k] = new x[k] - old x[k] = delta x[j] / alfa */\n         delta /= alfa;\n         /* compute the change of the objective in the adjacent basis:\n            delta z = new z - old z = gamma * delta x[k] */\n         dz = gamma * delta;\n         if (mip->dir == GLP_MIN)\n            xassert(dz >= 0.0);\n         else if (mip->dir == GLP_MAX)\n            xassert(dz <= 0.0);\n         else\n            xassert(mip != mip);\n         /* compute the new objective value in the adjacent basis:\n            new z = old z + delta z */\n         if (kase < 0)\n            *dn = mip->obj_val + dz;\n         else\n            *up = mip->obj_val + dz;\n      }\n      /*xprintf(\"obj = %g; dn = %g; up = %g\\n\",\n         mip->obj_val, *dn, *up);*/\n      return;\n}",
      "lines": 115,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ios_round_bound": {
      "start_point": [
        1093,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "double ios_round_bound(glp_tree *tree, double bound)\n{     glp_prob *mip = tree->mip;\n      int n = mip->n;\n      int d, j, nn, *c = tree->iwrk;\n      double s, h;\n      /* determine c[j] and compute s */\n      nn = 0, s = mip->c0, d = 0;\n      for (j = 1; j <= n; j++)\n      {  GLPCOL *col = mip->col[j];\n         if (col->coef == 0.0) continue;\n         if (col->type == GLP_FX)\n         {  /* fixed variable */\n            s += col->coef * col->prim;\n         }\n         else\n         {  /* non-fixed variable */\n            if (col->kind != GLP_IV) goto skip;\n            if (col->coef != floor(col->coef)) goto skip;\n            if (fabs(col->coef) <= (double)INT_MAX)\n               c[++nn] = (int)fabs(col->coef);\n            else\n               d = 1;\n         }\n      }\n      /* compute d = gcd(c[1],...c[nn]) */\n      if (d == 0)\n      {  if (nn == 0) goto skip;\n         d = gcdn(nn, c);\n      }\n      xassert(d > 0);\n      /* compute new local bound */\n      if (mip->dir == GLP_MIN)\n      {  if (bound != +DBL_MAX)\n         {  h = (bound - s) / (double)d;\n            if (h >= floor(h) + 0.001)\n            {  /* round up */\n               h = ceil(h);\n               /*xprintf(\"d = %d; old = %g; \", d, bound);*/\n               bound = (double)d * h + s;\n               /*xprintf(\"new = %g\\n\", bound);*/\n            }\n         }\n      }\n      else if (mip->dir == GLP_MAX)\n      {  if (bound != -DBL_MAX)\n         {  h = (bound - s) / (double)d;\n            if (h <= ceil(h) - 0.001)\n            {  /* round down */\n               h = floor(h);\n               bound = (double)d * h + s;\n            }\n         }\n      }\n      else\n         xassert(mip != mip);\nskip: return bound;\n}",
      "lines": 57,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "ios_is_hopeful": {
      "start_point": [
        1173,
        0
      ],
      "end_point": [
        1203,
        1
      ],
      "content": "int ios_is_hopeful(glp_tree *tree, double bound)\n{     glp_prob *mip = tree->mip;\n      int ret = 1;\n      double eps;\n      if (mip->mip_stat == GLP_FEAS)\n      {  eps = tree->parm->tol_obj * (1.0 + fabs(mip->mip_obj));\n         switch (mip->dir)\n         {  case GLP_MIN:\n               if (bound >= mip->mip_obj - eps) ret = 0;\n               break;\n            case GLP_MAX:\n               if (bound <= mip->mip_obj + eps) ret = 0;\n               break;\n            default:\n               xassert(mip != mip);\n         }\n      }\n      else\n      {  switch (mip->dir)\n         {  case GLP_MIN:\n               if (bound == +DBL_MAX) ret = 0;\n               break;\n            case GLP_MAX:\n               if (bound == -DBL_MAX) ret = 0;\n               break;\n            default:\n               xassert(mip != mip);\n         }\n      }\n      return ret;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "ios_best_node": {
      "start_point": [
        1230,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "int ios_best_node(glp_tree *tree)\n{     IOSNPD *node, *best = NULL;\n      switch (tree->mip->dir)\n      {  case GLP_MIN:\n            /* minimization */\n            for (node = tree->head; node != NULL; node = node->next)\n               if (best == NULL || best->bound > node->bound)\n                  best = node;\n            break;\n         case GLP_MAX:\n            /* maximization */\n            for (node = tree->head; node != NULL; node = node->next)\n               if (best == NULL || best->bound < node->bound)\n                  best = node;\n            break;\n         default:\n            xassert(tree != tree);\n      }\n      return best == NULL ? 0 : best->p;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "ios_relative_gap": {
      "start_point": [
        1276,
        0
      ],
      "end_point": [
        1298,
        1
      ],
      "content": "double ios_relative_gap(glp_tree *tree)\n{     glp_prob *mip = tree->mip;\n      int p;\n      double best_mip, best_bnd, gap;\n      if (mip->mip_stat == GLP_FEAS)\n      {  best_mip = mip->mip_obj;\n         p = ios_best_node(tree);\n         if (p == 0)\n         {  /* the tree is empty */\n            gap = 0.0;\n         }\n         else\n         {  best_bnd = tree->slot[p].node->bound;\n            gap = fabs(best_mip - best_bnd) / (fabs(best_mip) +\n               DBL_EPSILON);\n         }\n      }\n      else\n      {  /* no integer feasible solution has been found yet */\n         gap = DBL_MAX;\n      }\n      return gap;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "ios_solve_node": {
      "start_point": [
        1319,
        0
      ],
      "end_point": [
        1385,
        1
      ],
      "content": "int ios_solve_node(glp_tree *tree)\n{     glp_prob *mip = tree->mip;\n      glp_smcp parm;\n      int ret;\n      /* the current subproblem must exist */\n      xassert(tree->curr != NULL);\n      /* set some control parameters */\n      glp_init_smcp(&parm);\n      switch (tree->parm->msg_lev)\n      {  case GLP_MSG_OFF:\n            parm.msg_lev = GLP_MSG_OFF; break;\n         case GLP_MSG_ERR:\n            parm.msg_lev = GLP_MSG_ERR; break;\n         case GLP_MSG_ON:\n         case GLP_MSG_ALL:\n            parm.msg_lev = GLP_MSG_ON; break;\n         case GLP_MSG_DBG:\n            parm.msg_lev = GLP_MSG_ALL; break;\n         default:\n            xassert(tree != tree);\n      }\n      parm.meth = GLP_DUALP;\n#if 1 /* 16/III-2016 */\n      if (tree->parm->flip)\n         parm.r_test = GLP_RT_FLIP;\n#endif\n      /* respect time limit */\n      if (tree->parm->tm_lim < INT_MAX)\n         parm.tm_lim = tree->parm->tm_lim - (glp_time() - tree->tm_beg);\n      if (parm.tm_lim < 0)\n         parm.tm_lim = 0;\n      if (tree->parm->msg_lev < GLP_MSG_DBG)\n         parm.out_dly = tree->parm->out_dly;\n      else\n         parm.out_dly = 0;\n      /* if the incumbent objective value is already known, use it to\n         prematurely terminate the dual simplex search */\n      if (mip->mip_stat == GLP_FEAS)\n      {  switch (tree->mip->dir)\n         {  case GLP_MIN:\n               parm.obj_ul = mip->mip_obj;\n               break;\n            case GLP_MAX:\n               parm.obj_ll = mip->mip_obj;\n               break;\n            default:\n               xassert(mip != mip);\n         }\n      }\n      /* try to solve/re-optimize the LP relaxation */\n      ret = glp_simplex(mip, &parm);\n#if 1 /* 21/II-2016 by Chris */\n      if (ret == GLP_EFAIL)\n      {  /* retry with a new basis */\n         glp_adv_basis(mip, 0);\n         ret = glp_simplex(mip, &parm);\n      }\n#endif\n      tree->curr->solved++;\n#if 0\n      xprintf(\"ret = %d; status = %d; pbs = %d; dbs = %d; some = %d\\n\",\n         ret, glp_get_status(mip), mip->pbs_stat, mip->dbs_stat,\n         mip->some);\n      lpx_print_sol(mip, \"sol\");\n#endif\n      return ret;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "ios_create_pool": [
      {
        "start_point": [
          1390,
          0
        ],
        "end_point": [
          1396,
          1
        ],
        "content": "IOSPOOL *ios_create_pool(glp_tree *tree)\n{     /* create cut pool */\n      IOSPOOL *pool;\n      pool = glp_create_prob();\n      glp_add_cols(pool, tree->mip->n);\n      return pool;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "IOSPOOL",
          "*ios_create_pool(glp_tree *tree)",
          "*"
        ]
      },
      {
        "start_point": [
          1398,
          0
        ],
        "end_point": [
          1411,
          1
        ],
        "content": "IOSPOOL *ios_create_pool(glp_tree *tree)\n{     /* create cut pool */\n      IOSPOOL *pool;\n#if 0\n      pool = dmp_get_atom(tree->pool, sizeof(IOSPOOL));\n#else\n      xassert(tree == tree);\n      pool = xmalloc(sizeof(IOSPOOL));\n#endif\n      pool->size = 0;\n      pool->head = pool->tail = NULL;\n      pool->ord = 0, pool->curr = NULL;\n      return pool;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "IOSPOOL",
          "*ios_create_pool(glp_tree *tree)",
          "*"
        ]
      }
    ],
    "ios_add_row": [
      {
        "start_point": [
          1415,
          0
        ],
        "end_point": [
          1427,
          1
        ],
        "content": "int ios_add_row(glp_tree *tree, IOSPOOL *pool,\n      const char *name, int klass, int flags, int len, const int ind[],\n      const double val[], int type, double rhs)\n{     /* add row (constraint) to the cut pool */\n      int i;\n      i = glp_add_rows(pool, 1);\n      glp_set_row_name(pool, i, name);\n      pool->row[i]->klass = klass;\n      xassert(flags == 0);\n      glp_set_mat_row(pool, i, len, ind, val);\n      glp_set_row_bnds(pool, i, type, rhs, rhs);\n      return i;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1429,
          0
        ],
        "end_point": [
          1486,
          1
        ],
        "content": "int ios_add_row(glp_tree *tree, IOSPOOL *pool,\n      const char *name, int klass, int flags, int len, const int ind[],\n      const double val[], int type, double rhs)\n{     /* add row (constraint) to the cut pool */\n      IOSCUT *cut;\n      IOSAIJ *aij;\n      int k;\n      xassert(pool != NULL);\n      cut = dmp_get_atom(tree->pool, sizeof(IOSCUT));\n      if (name == NULL || name[0] == '\\0')\n         cut->name = NULL;\n      else\n      {  for (k = 0; name[k] != '\\0'; k++)\n         {  if (k == 256)\n               xerror(\"glp_ios_add_row: cut name too long\\n\");\n            if (iscntrl((unsigned char)name[k]))\n               xerror(\"glp_ios_add_row: cut name contains invalid chara\"\n                  \"cter(s)\\n\");\n         }\n         cut->name = dmp_get_atom(tree->pool, strlen(name)+1);\n         strcpy(cut->name, name);\n      }\n      if (!(0 <= klass && klass <= 255))\n         xerror(\"glp_ios_add_row: klass = %d; invalid cut class\\n\",\n            klass);\n      cut->klass = (unsigned char)klass;\n      if (flags != 0)\n         xerror(\"glp_ios_add_row: flags = %d; invalid cut flags\\n\",\n            flags);\n      cut->ptr = NULL;\n      if (!(0 <= len && len <= tree->n))\n         xerror(\"glp_ios_add_row: len = %d; invalid cut length\\n\",\n            len);\n      for (k = 1; k <= len; k++)\n      {  aij = dmp_get_atom(tree->pool, sizeof(IOSAIJ));\n         if (!(1 <= ind[k] && ind[k] <= tree->n))\n            xerror(\"glp_ios_add_row: ind[%d] = %d; column index out of \"\n               \"range\\n\", k, ind[k]);\n         aij->j = ind[k];\n         aij->val = val[k];\n         aij->next = cut->ptr;\n         cut->ptr = aij;\n      }\n      if (!(type == GLP_LO || type == GLP_UP || type == GLP_FX))\n         xerror(\"glp_ios_add_row: type = %d; invalid cut type\\n\",\n            type);\n      cut->type = (unsigned char)type;\n      cut->rhs = rhs;\n      cut->prev = pool->tail;\n      cut->next = NULL;\n      if (cut->prev == NULL)\n         pool->head = cut;\n      else\n         cut->prev->next = cut;\n      pool->tail = cut;\n      pool->size++;\n      return pool->size;\n}",
        "lines": 58,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "ios_find_row": [
      {
        "start_point": [
          1490,
          0
        ],
        "end_point": [
          1493,
          1
        ],
        "content": "IOSCUT *ios_find_row(IOSPOOL *pool, int i)\n{     /* find row (constraint) in the cut pool */\n      xassert(0);\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "IOSCUT",
          "*ios_find_row(IOSPOOL *pool, int i)",
          "*"
        ]
      },
      {
        "start_point": [
          1495,
          0
        ],
        "end_point": [
          1545,
          1
        ],
        "content": "IOSCUT *ios_find_row(IOSPOOL *pool, int i)\n{     /* find row (constraint) in the cut pool */\n      /* (smart linear search) */\n      xassert(pool != NULL);\n      xassert(1 <= i && i <= pool->size);\n      if (pool->ord == 0)\n      {  xassert(pool->curr == NULL);\n         pool->ord = 1;\n         pool->curr = pool->head;\n      }\n      xassert(pool->curr != NULL);\n      if (i < pool->ord)\n      {  if (i < pool->ord - i)\n         {  pool->ord = 1;\n            pool->curr = pool->head;\n            while (pool->ord != i)\n            {  pool->ord++;\n               xassert(pool->curr != NULL);\n               pool->curr = pool->curr->next;\n            }\n         }\n         else\n         {  while (pool->ord != i)\n            {  pool->ord--;\n               xassert(pool->curr != NULL);\n               pool->curr = pool->curr->prev;\n            }\n         }\n      }\n      else if (i > pool->ord)\n      {  if (i - pool->ord < pool->size - i)\n         {  while (pool->ord != i)\n            {  pool->ord++;\n               xassert(pool->curr != NULL);\n               pool->curr = pool->curr->next;\n            }\n         }\n         else\n         {  pool->ord = pool->size;\n            pool->curr = pool->tail;\n            while (pool->ord != i)\n            {  pool->ord--;\n               xassert(pool->curr != NULL);\n               pool->curr = pool->curr->prev;\n            }\n         }\n      }\n      xassert(pool->ord == i);\n      xassert(pool->curr != NULL);\n      return pool->curr;\n}",
        "lines": 51,
        "depth": 15,
        "decorators": [
          "IOSCUT",
          "*ios_find_row(IOSPOOL *pool, int i)",
          "*"
        ]
      }
    ],
    "ios_del_row": [
      {
        "start_point": [
          1549,
          0
        ],
        "end_point": [
          1552,
          1
        ],
        "content": "void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)\n{     /* remove row (constraint) from the cut pool */\n      xassert(0);\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1554,
          0
        ],
        "end_point": [
          1596,
          1
        ],
        "content": "void ios_del_row(glp_tree *tree, IOSPOOL *pool, int i)\n{     /* remove row (constraint) from the cut pool */\n      IOSCUT *cut;\n      IOSAIJ *aij;\n      xassert(pool != NULL);\n      if (!(1 <= i && i <= pool->size))\n         xerror(\"glp_ios_del_row: i = %d; cut number out of range\\n\",\n            i);\n      cut = ios_find_row(pool, i);\n      xassert(pool->curr == cut);\n      if (cut->next != NULL)\n         pool->curr = cut->next;\n      else if (cut->prev != NULL)\n         pool->ord--, pool->curr = cut->prev;\n      else\n         pool->ord = 0, pool->curr = NULL;\n      if (cut->name != NULL)\n         dmp_free_atom(tree->pool, cut->name, strlen(cut->name)+1);\n      if (cut->prev == NULL)\n      {  xassert(pool->head == cut);\n         pool->head = cut->next;\n      }\n      else\n      {  xassert(cut->prev->next == cut);\n         cut->prev->next = cut->next;\n      }\n      if (cut->next == NULL)\n      {  xassert(pool->tail == cut);\n         pool->tail = cut->prev;\n      }\n      else\n      {  xassert(cut->next->prev == cut);\n         cut->next->prev = cut->prev;\n      }\n      while (cut->ptr != NULL)\n      {  aij = cut->ptr;\n         cut->ptr = aij->next;\n         dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));\n      }\n      dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));\n      pool->size--;\n      return;\n}",
        "lines": 43,
        "depth": 11,
        "decorators": [
          "void"
        ]
      }
    ],
    "ios_clear_pool": [
      {
        "start_point": [
          1600,
          0
        ],
        "end_point": [
          1611,
          1
        ],
        "content": "void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)\n{     /* remove all rows (constraints) from the cut pool */\n      if (pool->m > 0)\n      {  int i, *num;\n         num = talloc(1+pool->m, int);\n         for (i = 1; i <= pool->m; i++)\n            num[i] = i;\n         glp_del_rows(pool, pool->m, num);\n         tfree(num);\n      }\n      return;\n}",
        "lines": 12,
        "depth": 11,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1613,
          0
        ],
        "end_point": [
          1632,
          1
        ],
        "content": "void ios_clear_pool(glp_tree *tree, IOSPOOL *pool)\n{     /* remove all rows (constraints) from the cut pool */\n      xassert(pool != NULL);\n      while (pool->head != NULL)\n      {  IOSCUT *cut = pool->head;\n         pool->head = cut->next;\n         if (cut->name != NULL)\n            dmp_free_atom(tree->pool, cut->name, strlen(cut->name)+1);\n         while (cut->ptr != NULL)\n         {  IOSAIJ *aij = cut->ptr;\n            cut->ptr = aij->next;\n            dmp_free_atom(tree->pool, aij, sizeof(IOSAIJ));\n         }\n         dmp_free_atom(tree->pool, cut, sizeof(IOSCUT));\n      }\n      pool->size = 0;\n      pool->head = pool->tail = NULL;\n      pool->ord = 0, pool->curr = NULL;\n      return;\n}",
        "lines": 20,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "ios_delete_pool": [
      {
        "start_point": [
          1636,
          0
        ],
        "end_point": [
          1641,
          1
        ],
        "content": "void ios_delete_pool(glp_tree *tree, IOSPOOL *pool)\n{     /* delete cut pool */\n      xassert(pool != NULL);\n      glp_delete_prob(pool);\n      return;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          1643,
          0
        ],
        "end_point": [
          1649,
          1
        ],
        "content": "void ios_delete_pool(glp_tree *tree, IOSPOOL *pool)\n{     /* delete cut pool */\n      xassert(pool != NULL);\n      ios_clear_pool(tree, pool);\n      xfree(pool);\n      return;\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ],
    "ios_process_sol": {
      "start_point": [
        1655,
        0
      ],
      "end_point": [
        1681,
        1
      ],
      "content": "void ios_process_sol(glp_tree *T)\n{     /* process integer feasible solution just found */\n      if (T->npp != NULL)\n      {  /* postprocess solution from transformed mip */\n         npp_postprocess(T->npp, T->mip);\n         /* store solution to problem passed to glp_intopt */\n         npp_unload_sol(T->npp, T->P);\n      }\n      xassert(T->P != NULL);\n      /* save solution to text file, if requested */\n      if (T->save_sol != NULL)\n      {  char *fn, *mark;\n         fn = talloc(strlen(T->save_sol) + 50, char);\n         mark = strrchr(T->save_sol, '*');\n         if (mark == NULL)\n            strcpy(fn, T->save_sol);\n         else\n         {  memcpy(fn, T->save_sol, mark - T->save_sol);\n            fn[mark - T->save_sol] = '\\0';\n            sprintf(fn + strlen(fn), \"%03d\", ++(T->save_cnt));\n            strcat(fn, &mark[1]);\n         }\n         glp_write_mip(T->P, fn);\n         tfree(fn);\n      }\n      return;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpios02.c": {
    "prepare_row_info": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void prepare_row_info(int n, const double a[], const double l[],\n      const double u[], struct f_info *f)\n{     int j, j_min, j_max;\n      double f_min, f_max;\n      xassert(n >= 0);\n      /* determine f_min and j_min */\n      f_min = 0.0, j_min = 0;\n      for (j = 1; j <= n; j++)\n      {  if (a[j] > 0.0)\n         {  if (l[j] == -DBL_MAX)\n            {  if (j_min == 0)\n                  j_min = j;\n               else\n               {  f_min = -DBL_MAX, j_min = 0;\n                  break;\n               }\n            }\n            else\n               f_min += a[j] * l[j];\n         }\n         else if (a[j] < 0.0)\n         {  if (u[j] == +DBL_MAX)\n            {  if (j_min == 0)\n                  j_min = j;\n               else\n               {  f_min = -DBL_MAX, j_min = 0;\n                  break;\n               }\n            }\n            else\n               f_min += a[j] * u[j];\n         }\n         else\n            xassert(a != a);\n      }\n      f->f_min = f_min, f->j_min = j_min;\n      /* determine f_max and j_max */\n      f_max = 0.0, j_max = 0;\n      for (j = 1; j <= n; j++)\n      {  if (a[j] > 0.0)\n         {  if (u[j] == +DBL_MAX)\n            {  if (j_max == 0)\n                  j_max = j;\n               else\n               {  f_max = +DBL_MAX, j_max = 0;\n                  break;\n               }\n            }\n            else\n               f_max += a[j] * u[j];\n         }\n         else if (a[j] < 0.0)\n         {  if (l[j] == -DBL_MAX)\n            {  if (j_max == 0)\n                  j_max = j;\n               else\n               {  f_max = +DBL_MAX, j_max = 0;\n                  break;\n               }\n            }\n            else\n               f_max += a[j] * l[j];\n         }\n         else\n            xassert(a != a);\n      }\n      f->f_max = f_max, f->j_max = j_max;\n      return;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "row_implied_bounds": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static void row_implied_bounds(const struct f_info *f, double *LL,\n      double *UU)\n{     *LL = (f->j_min == 0 ? f->f_min : -DBL_MAX);\n      *UU = (f->j_max == 0 ? f->f_max : +DBL_MAX);\n      return;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "col_implied_bounds": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "static void col_implied_bounds(const struct f_info *f, int n,\n      const double a[], double L, double U, const double l[],\n      const double u[], int k, double *ll, double *uu)\n{     double ilb, iub;\n      xassert(n >= 0);\n      xassert(1 <= k && k <= n);\n      /* determine implied lower bound of term a[k] * x[k] (14) */\n      if (L == -DBL_MAX || f->f_max == +DBL_MAX)\n         ilb = -DBL_MAX;\n      else if (f->j_max == 0)\n      {  if (a[k] > 0.0)\n         {  xassert(u[k] != +DBL_MAX);\n            ilb = L - (f->f_max - a[k] * u[k]);\n         }\n         else if (a[k] < 0.0)\n         {  xassert(l[k] != -DBL_MAX);\n            ilb = L - (f->f_max - a[k] * l[k]);\n         }\n         else\n            xassert(a != a);\n      }\n      else if (f->j_max == k)\n         ilb = L - f->f_max;\n      else\n         ilb = -DBL_MAX;\n      /* determine implied upper bound of term a[k] * x[k] (15) */\n      if (U == +DBL_MAX || f->f_min == -DBL_MAX)\n         iub = +DBL_MAX;\n      else if (f->j_min == 0)\n      {  if (a[k] > 0.0)\n         {  xassert(l[k] != -DBL_MAX);\n            iub = U - (f->f_min - a[k] * l[k]);\n         }\n         else if (a[k] < 0.0)\n         {  xassert(u[k] != +DBL_MAX);\n            iub = U - (f->f_min - a[k] * u[k]);\n         }\n         else\n            xassert(a != a);\n      }\n      else if (f->j_min == k)\n         iub = U - f->f_min;\n      else\n         iub = +DBL_MAX;\n      /* determine implied bounds of x[k] (16) and (17) */\n#if 1\n      /* do not use a[k] if it has small magnitude to prevent wrong\n         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where\n         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that\n         x1 >= 0 */\n      if (fabs(a[k]) < 1e-6)\n         *ll = -DBL_MAX, *uu = +DBL_MAX; else\n#endif\n      if (a[k] > 0.0)\n      {  *ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);\n         *uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);\n      }\n      else if (a[k] < 0.0)\n      {  *ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);\n         *uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);\n      }\n      else\n         xassert(a != a);\n      return;\n}",
      "lines": 65,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_row_bounds": {
      "start_point": [
        384,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static int check_row_bounds(const struct f_info *f, double *L_,\n      double *U_)\n{     int ret = 0;\n      double L = *L_, U = *U_, LL, UU;\n      /* determine implied bounds of the row */\n      row_implied_bounds(f, &LL, &UU);\n      /* check if the original lower bound is infeasible */\n      if (L != -DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(L));\n         if (UU < L - eps)\n         {  ret = 1;\n            goto done;\n         }\n      }\n      /* check if the original upper bound is infeasible */\n      if (U != +DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(U));\n         if (LL > U + eps)\n         {  ret = 1;\n            goto done;\n         }\n      }\n      /* check if the original lower bound is redundant */\n      if (L != -DBL_MAX)\n      {  double eps = 1e-12 * (1.0 + fabs(L));\n         if (LL > L - eps)\n         {  /* it cannot be active, so remove it */\n            *L_ = -DBL_MAX;\n         }\n      }\n      /* check if the original upper bound is redundant */\n      if (U != +DBL_MAX)\n      {  double eps = 1e-12 * (1.0 + fabs(U));\n         if (UU < U + eps)\n         {  /* it cannot be active, so remove it */\n            *U_ = +DBL_MAX;\n         }\n      }\ndone: return ret;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_col_bounds": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        522,
        1
      ],
      "content": "static int check_col_bounds(const struct f_info *f, int n,\n      const double a[], double L, double U, const double l[],\n      const double u[], int flag, int j, double *_lj, double *_uj)\n{     int ret = 0;\n      double lj, uj, ll, uu;\n      xassert(n >= 0);\n      xassert(1 <= j && j <= n);\n      lj = l[j], uj = u[j];\n      /* determine implied bounds of the column */\n      col_implied_bounds(f, n, a, L, U, l, u, j, &ll, &uu);\n      /* if x[j] is integral, round its implied bounds */\n      if (flag)\n      {  if (ll != -DBL_MAX)\n            ll = (ll - floor(ll) < 1e-3 ? floor(ll) : ceil(ll));\n         if (uu != +DBL_MAX)\n            uu = (ceil(uu) - uu < 1e-3 ? ceil(uu) : floor(uu));\n      }\n      /* check if the original lower bound is infeasible */\n      if (lj != -DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(lj));\n         if (uu < lj - eps)\n         {  ret = 1;\n            goto done;\n         }\n      }\n      /* check if the original upper bound is infeasible */\n      if (uj != +DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(uj));\n         if (ll > uj + eps)\n         {  ret = 1;\n            goto done;\n         }\n      }\n      /* check if the original lower bound is redundant */\n      if (ll != -DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(ll));\n         if (lj < ll - eps)\n         {  /* it cannot be active, so tighten it */\n            lj = ll;\n         }\n      }\n      /* check if the original upper bound is redundant */\n      if (uu != +DBL_MAX)\n      {  double eps = 1e-3 * (1.0 + fabs(uu));\n         if (uj > uu + eps)\n         {  /* it cannot be active, so tighten it */\n            uj = uu;\n         }\n      }\n      /* due to round-off errors it may happen that lj > uj (although\n         lj < uj + eps, since no primal infeasibility is detected), so\n         adjuct the new actual bounds to provide lj <= uj */\n      if (!(lj == -DBL_MAX || uj == +DBL_MAX))\n      {  double t1 = fabs(lj), t2 = fabs(uj);\n         double eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));\n         if (lj > uj - eps)\n         {  if (lj == l[j])\n               uj = lj;\n            else if (uj == u[j])\n               lj = uj;\n            else if (t1 <= t2)\n               uj = lj;\n            else\n               lj = uj;\n         }\n      }\n      *_lj = lj, *_uj = uj;\ndone: return ret;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_efficiency": {
      "start_point": [
        534,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "static int check_efficiency(int flag, double l, double u, double ll,\n      double uu)\n{     int eff = 0;\n      /* check efficiency for lower bound */\n      if (l < ll)\n      {  if (flag || l == -DBL_MAX)\n            eff++;\n         else\n         {  double r;\n            if (u == +DBL_MAX)\n               r = 1.0 + fabs(l);\n            else\n               r = 1.0 + (u - l);\n            if (ll - l >= 0.25 * r)\n               eff++;\n         }\n      }\n      /* check efficiency for upper bound */\n      if (u > uu)\n      {  if (flag || u == +DBL_MAX)\n            eff++;\n         else\n         {  double r;\n            if (l == -DBL_MAX)\n               r = 1.0 + fabs(u);\n            else\n               r = 1.0 + (u - l);\n            if (u - uu >= 0.25 * r)\n               eff++;\n         }\n      }\n      return eff;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "basic_preprocessing": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "static int basic_preprocessing(glp_prob *mip, double L[], double U[],\n      double l[], double u[], int nrs, const int num[], int max_pass)\n{     int m = mip->m;\n      int n = mip->n;\n      struct f_info f;\n      int i, j, k, len, size, ret = 0;\n      int *ind, *list, *mark, *pass;\n      double *val, *lb, *ub;\n      xassert(0 <= nrs && nrs <= m+1);\n      xassert(max_pass > 0);\n      /* allocate working arrays */\n      ind = xcalloc(1+n, sizeof(int));\n      list = xcalloc(1+m+1, sizeof(int));\n      mark = xcalloc(1+m+1, sizeof(int));\n      memset(&mark[0], 0, (m+1) * sizeof(int));\n      pass = xcalloc(1+m+1, sizeof(int));\n      memset(&pass[0], 0, (m+1) * sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      lb = xcalloc(1+n, sizeof(double));\n      ub = xcalloc(1+n, sizeof(double));\n      /* initialize the list of rows to be processed */\n      size = 0;\n      for (k = 1; k <= nrs; k++)\n      {  i = num[k];\n         xassert(0 <= i && i <= m);\n         /* duplicate row numbers are not allowed */\n         xassert(!mark[i]);\n         list[++size] = i, mark[i] = 1;\n      }\n      xassert(size == nrs);\n      /* process rows in the list until it becomes empty */\n      while (size > 0)\n      {  /* get a next row from the list */\n         i = list[size--], mark[i] = 0;\n         /* increase the row processing count */\n         pass[i]++;\n         /* if the row is free, skip it */\n         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\n         /* obtain coefficients of the row */\n         len = 0;\n         if (i == 0)\n         {  for (j = 1; j <= n; j++)\n            {  GLPCOL *col = mip->col[j];\n               if (col->coef != 0.0)\n                  len++, ind[len] = j, val[len] = col->coef;\n            }\n         }\n         else\n         {  GLPROW *row = mip->row[i];\n            GLPAIJ *aij;\n            for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n               len++, ind[len] = aij->col->j, val[len] = aij->val;\n         }\n         /* determine lower and upper bounds of columns corresponding\n            to non-zero row coefficients */\n         for (k = 1; k <= len; k++)\n            j = ind[k], lb[k] = l[j], ub[k] = u[j];\n         /* prepare the row info to determine implied bounds */\n         prepare_row_info(len, val, lb, ub, &f);\n         /* check and relax bounds of the row */\n         if (check_row_bounds(&f, &L[i], &U[i]))\n         {  /* the feasible region is empty */\n            ret = 1;\n            goto done;\n         }\n         /* if the row became free, drop it */\n         if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\n         /* process columns having non-zero coefficients in the row */\n         for (k = 1; k <= len; k++)\n         {  GLPCOL *col;\n            int flag, eff;\n            double ll, uu;\n            /* take a next column in the row */\n            j = ind[k], col = mip->col[j];\n            flag = col->kind != GLP_CV;\n            /* check and tighten bounds of the column */\n            if (check_col_bounds(&f, len, val, L[i], U[i], lb, ub,\n                flag, k, &ll, &uu))\n            {  /* the feasible region is empty */\n               ret = 1;\n               goto done;\n            }\n            /* check if change in the column bounds is efficient */\n            eff = check_efficiency(flag, l[j], u[j], ll, uu);\n            /* set new actual bounds of the column */\n            l[j] = ll, u[j] = uu;\n            /* if the change is efficient, add all rows affected by the\n               corresponding column, to the list */\n            if (eff > 0)\n            {  GLPAIJ *aij;\n               for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n               {  int ii = aij->row->i;\n                  /* if the row was processed maximal number of times,\n                     skip it */\n                  if (pass[ii] >= max_pass) continue;\n                  /* if the row is free, skip it */\n                  if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;\n                  /* put the row into the list */\n                  if (mark[ii] == 0)\n                  {  xassert(size <= m);\n                     list[++size] = ii, mark[ii] = 1;\n                  }\n               }\n            }\n         }\n      }\ndone: /* free working arrays */\n      xfree(ind);\n      xfree(list);\n      xfree(mark);\n      xfree(pass);\n      xfree(val);\n      xfree(lb);\n      xfree(ub);\n      return ret;\n}",
      "lines": 116,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ios_preprocess_node": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "int ios_preprocess_node(glp_tree *tree, int max_pass)\n{     glp_prob *mip = tree->mip;\n      int m = mip->m;\n      int n = mip->n;\n      int i, j, nrs, *num, ret = 0;\n      double *L, *U, *l, *u;\n      /* the current subproblem must exist */\n      xassert(tree->curr != NULL);\n      /* determine original row bounds */\n      L = xcalloc(1+m, sizeof(double));\n      U = xcalloc(1+m, sizeof(double));\n      switch (mip->mip_stat)\n      {  case GLP_UNDEF:\n            L[0] = -DBL_MAX, U[0] = +DBL_MAX;\n            break;\n         case GLP_FEAS:\n            switch (mip->dir)\n            {  case GLP_MIN:\n                  L[0] = -DBL_MAX, U[0] = mip->mip_obj - mip->c0;\n                  break;\n               case GLP_MAX:\n                  L[0] = mip->mip_obj - mip->c0, U[0] = +DBL_MAX;\n                  break;\n               default:\n                  xassert(mip != mip);\n            }\n            break;\n         default:\n            xassert(mip != mip);\n      }\n      for (i = 1; i <= m; i++)\n      {  L[i] = glp_get_row_lb(mip, i);\n         U[i] = glp_get_row_ub(mip, i);\n      }\n      /* determine original column bounds */\n      l = xcalloc(1+n, sizeof(double));\n      u = xcalloc(1+n, sizeof(double));\n      for (j = 1; j <= n; j++)\n      {  l[j] = glp_get_col_lb(mip, j);\n         u[j] = glp_get_col_ub(mip, j);\n      }\n      /* build the initial list of rows to be analyzed */\n      nrs = m + 1;\n      num = xcalloc(1+nrs, sizeof(int));\n      for (i = 1; i <= nrs; i++) num[i] = i - 1;\n      /* perform basic preprocessing */\n      if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))\n      {  ret = 1;\n         goto done;\n      }\n      /* set new actual (relaxed) row bounds */\n      for (i = 1; i <= m; i++)\n      {  /* consider only non-active rows to keep dual feasibility */\n         if (glp_get_row_stat(mip, i) == GLP_BS)\n         {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)\n               glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);\n            else if (U[i] == +DBL_MAX)\n               glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);\n            else if (L[i] == -DBL_MAX)\n               glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);\n         }\n      }\n      /* set new actual (tightened) column bounds */\n      for (j = 1; j <= n; j++)\n      {  int type;\n         if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)\n            type = GLP_FR;\n         else if (u[j] == +DBL_MAX)\n            type = GLP_LO;\n         else if (l[j] == -DBL_MAX)\n            type = GLP_UP;\n         else if (l[j] != u[j])\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(mip, j, type, l[j], u[j]);\n      }\ndone: /* free working arrays and return */\n      xfree(L);\n      xfree(U);\n      xfree(l);\n      xfree(u);\n      xfree(num);\n      return ret;\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpios03.c": {
    "show_progress": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void show_progress(glp_tree *T, int bingo)\n{     int p;\n      double temp;\n      char best_mip[50], best_bound[50], *rho, rel_gap[50];\n      /* format the best known integer feasible solution */\n      if (T->mip->mip_stat == GLP_FEAS)\n         sprintf(best_mip, \"%17.9e\", T->mip->mip_obj);\n      else\n         sprintf(best_mip, \"%17s\", \"not found yet\");\n      /* determine reference number of an active subproblem whose local\n         bound is best */\n      p = ios_best_node(T);\n      /* format the best bound */\n      if (p == 0)\n         sprintf(best_bound, \"%17s\", \"tree is empty\");\n      else\n      {  temp = T->slot[p].node->bound;\n         if (temp == -DBL_MAX)\n            sprintf(best_bound, \"%17s\", \"-inf\");\n         else if (temp == +DBL_MAX)\n            sprintf(best_bound, \"%17s\", \"+inf\");\n         else\n         {  if (fabs(temp) < 1e-9)\n               temp = 0;\n            sprintf(best_bound, \"%17.9e\", temp);\n         }\n      }\n      /* choose the relation sign between global bounds */\n      if (T->mip->dir == GLP_MIN)\n         rho = \">=\";\n      else if (T->mip->dir == GLP_MAX)\n         rho = \"<=\";\n      else\n         xassert(T != T);\n      /* format the relative mip gap */\n      temp = ios_relative_gap(T);\n      if (temp == 0.0)\n         sprintf(rel_gap, \"  0.0%%\");\n      else if (temp < 0.001)\n         sprintf(rel_gap, \"< 0.1%%\");\n      else if (temp <= 9.999)\n         sprintf(rel_gap, \"%5.1f%%\", 100.0 * temp);\n      else\n         sprintf(rel_gap, \"%6s\", \"\");\n      /* display progress of the search */\n      xprintf(\"+%6d: %s %s %s %s %s (%d; %d)\\n\",\n         T->mip->it_cnt, bingo ? \">>>>>\" : \"mip =\", best_mip, rho,\n         best_bound, rel_gap, T->a_cnt, T->t_cnt - T->n_cnt);\n      T->tm_lag = xtime();\n      return;\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_branch_hopeful": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int is_branch_hopeful(glp_tree *T, int p)\n{     xassert(1 <= p && p <= T->nslots);\n      xassert(T->slot[p].node != NULL);\n      return ios_is_hopeful(T, T->slot[p].node->bound);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_integrality": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "static void check_integrality(glp_tree *T)\n{     glp_prob *mip = T->mip;\n      int j, type, ii_cnt = 0;\n      double lb, ub, x, temp1, temp2, ii_sum = 0.0;\n      /* walk through the set of columns (structural variables) */\n      for (j = 1; j <= mip->n; j++)\n      {  GLPCOL *col = mip->col[j];\n         T->non_int[j] = 0;\n         /* if the column is not integer, skip it */\n         if (col->kind != GLP_IV) continue;\n         /* if the column is non-basic, it is integer feasible */\n         if (col->stat != GLP_BS) continue;\n         /* obtain the type and bounds of the column */\n         type = col->type, lb = col->lb, ub = col->ub;\n         /* obtain value of the column in optimal basic solution */\n         x = col->prim;\n         /* if the column's primal value is close to the lower bound,\n            the column is integer feasible within given tolerance */\n         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n         {  temp1 = lb - T->parm->tol_int;\n            temp2 = lb + T->parm->tol_int;\n            if (temp1 <= x && x <= temp2) continue;\n#if 0\n            /* the lower bound must not be violated */\n            xassert(x >= lb);\n#else\n            if (x < lb) continue;\n#endif\n         }\n         /* if the column's primal value is close to the upper bound,\n            the column is integer feasible within given tolerance */\n         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n         {  temp1 = ub - T->parm->tol_int;\n            temp2 = ub + T->parm->tol_int;\n            if (temp1 <= x && x <= temp2) continue;\n#if 0\n            /* the upper bound must not be violated */\n            xassert(x <= ub);\n#else\n            if (x > ub) continue;\n#endif\n         }\n         /* if the column's primal value is close to nearest integer,\n            the column is integer feasible within given tolerance */\n         temp1 = floor(x + 0.5) - T->parm->tol_int;\n         temp2 = floor(x + 0.5) + T->parm->tol_int;\n         if (temp1 <= x && x <= temp2) continue;\n         /* otherwise the column is integer infeasible */\n         T->non_int[j] = 1;\n         /* increase the number of fractional-valued columns */\n         ii_cnt++;\n         /* compute the sum of integer infeasibilities */\n         temp1 = x - floor(x);\n         temp2 = ceil(x) - x;\n         xassert(temp1 > 0.0 && temp2 > 0.0);\n         ii_sum += (temp1 <= temp2 ? temp1 : temp2);\n      }\n      /* store ii_cnt and ii_sum to the current problem descriptor */\n      xassert(T->curr != NULL);\n      T->curr->ii_cnt = ii_cnt;\n      T->curr->ii_sum = ii_sum;\n      /* and also display these parameters */\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n      {  if (ii_cnt == 0)\n            xprintf(\"There are no fractional columns\\n\");\n         else if (ii_cnt == 1)\n            xprintf(\"There is one fractional column, integer infeasibil\"\n               \"ity is %.3e\\n\", ii_sum);\n         else\n            xprintf(\"There are %d fractional columns, integer infeasibi\"\n               \"lity is %.3e\\n\", ii_cnt, ii_sum);\n      }\n      return;\n}",
      "lines": 74,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "record_solution": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static void record_solution(glp_tree *T)\n{     glp_prob *mip = T->mip;\n      int i, j;\n      mip->mip_stat = GLP_FEAS;\n      mip->mip_obj = mip->obj_val;\n      for (i = 1; i <= mip->m; i++)\n      {  GLPROW *row = mip->row[i];\n         row->mipx = row->prim;\n      }\n      for (j = 1; j <= mip->n; j++)\n      {  GLPCOL *col = mip->col[j];\n         if (col->kind == GLP_CV)\n            col->mipx = col->prim;\n         else if (col->kind == GLP_IV)\n         {  /* value of the integer column must be integral */\n            col->mipx = floor(col->prim + 0.5);\n         }\n         else\n            xassert(col != col);\n      }\n      T->sol_cnt++;\n      return;\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fix_by_red_cost": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "static void fix_by_red_cost(glp_tree *T)\n{     glp_prob *mip = T->mip;\n      int j, stat, fixed = 0;\n      double obj, lb, ub, dj;\n      /* the global bound must exist */\n      xassert(T->mip->mip_stat == GLP_FEAS);\n      /* basic solution of LP relaxation must be optimal */\n      xassert(mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS);\n      /* determine the objective function value */\n      obj = mip->obj_val;\n      /* walk through the column list */\n      for (j = 1; j <= mip->n; j++)\n      {  GLPCOL *col = mip->col[j];\n         /* if the column is not integer, skip it */\n         if (col->kind != GLP_IV) continue;\n         /* obtain bounds of j-th column */\n         lb = col->lb, ub = col->ub;\n         /* and determine its status and reduced cost */\n         stat = col->stat, dj = col->dual;\n         /* analyze the reduced cost */\n         switch (mip->dir)\n         {  case GLP_MIN:\n               /* minimization */\n               if (stat == GLP_NL)\n               {  /* j-th column is non-basic on its lower bound */\n                  if (dj < 0.0) dj = 0.0;\n                  if (obj + dj >= mip->mip_obj)\n                     glp_set_col_bnds(mip, j, GLP_FX, lb, lb), fixed++;\n               }\n               else if (stat == GLP_NU)\n               {  /* j-th column is non-basic on its upper bound */\n                  if (dj > 0.0) dj = 0.0;\n                  if (obj - dj >= mip->mip_obj)\n                     glp_set_col_bnds(mip, j, GLP_FX, ub, ub), fixed++;\n               }\n               break;\n            case GLP_MAX:\n               /* maximization */\n               if (stat == GLP_NL)\n               {  /* j-th column is non-basic on its lower bound */\n                  if (dj > 0.0) dj = 0.0;\n                  if (obj + dj <= mip->mip_obj)\n                     glp_set_col_bnds(mip, j, GLP_FX, lb, lb), fixed++;\n               }\n               else if (stat == GLP_NU)\n               {  /* j-th column is non-basic on its upper bound */\n                  if (dj < 0.0) dj = 0.0;\n                  if (obj - dj <= mip->mip_obj)\n                     glp_set_col_bnds(mip, j, GLP_FX, ub, ub), fixed++;\n               }\n               break;\n            default:\n               xassert(T != T);\n         }\n      }\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n      {  if (fixed == 0)\n            /* nothing to say */;\n         else if (fixed == 1)\n            xprintf(\"One column has been fixed by reduced cost\\n\");\n         else\n            xprintf(\"%d columns have been fixed by reduced costs\\n\",\n               fixed);\n      }\n      /* fixing non-basic columns on their current bounds does not\n         change the basic solution */\n      xassert(mip->pbs_stat == GLP_FEAS && mip->dbs_stat == GLP_FEAS);\n      return;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "branch_on": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "static int branch_on(glp_tree *T, int j, int next)\n{     glp_prob *mip = T->mip;\n      IOSNPD *node;\n      int m = mip->m;\n      int n = mip->n;\n      int type, dn_type, up_type, dn_bad, up_bad, p, ret, clone[1+2];\n      double lb, ub, beta, new_ub, new_lb, dn_lp, up_lp, dn_bnd, up_bnd;\n      /* determine bounds and value of x[j] in optimal solution to LP\n         relaxation of the current subproblem */\n      xassert(1 <= j && j <= n);\n      type = mip->col[j]->type;\n      lb = mip->col[j]->lb;\n      ub = mip->col[j]->ub;\n      beta = mip->col[j]->prim;\n      /* determine new bounds of x[j] for down- and up-branches */\n      new_ub = floor(beta);\n      new_lb = ceil(beta);\n      switch (type)\n      {  case GLP_FR:\n            dn_type = GLP_UP;\n            up_type = GLP_LO;\n            break;\n         case GLP_LO:\n            xassert(lb <= new_ub);\n            dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\n            xassert(lb + 1.0 <= new_lb);\n            up_type = GLP_LO;\n            break;\n         case GLP_UP:\n            xassert(new_ub <= ub - 1.0);\n            dn_type = GLP_UP;\n            xassert(new_lb <= ub);\n            up_type = (new_lb == ub ? GLP_FX : GLP_DB);\n            break;\n         case GLP_DB:\n            xassert(lb <= new_ub && new_ub <= ub - 1.0);\n            dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\n            xassert(lb + 1.0 <= new_lb && new_lb <= ub);\n            up_type = (new_lb == ub ? GLP_FX : GLP_DB);\n            break;\n         default:\n            xassert(type != type);\n      }\n      /* compute local bounds to LP relaxation for both branches */\n      ios_eval_degrad(T, j, &dn_lp, &up_lp);\n      /* and improve them by rounding */\n      dn_bnd = ios_round_bound(T, dn_lp);\n      up_bnd = ios_round_bound(T, up_lp);\n      /* check local bounds for down- and up-branches */\n      dn_bad = !ios_is_hopeful(T, dn_bnd);\n      up_bad = !ios_is_hopeful(T, up_bnd);\n      if (dn_bad && up_bad)\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Both down- and up-branches are hopeless\\n\");\n         ret = 2;\n         goto done;\n      }\n      else if (up_bad)\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Up-branch is hopeless\\n\");\n         glp_set_col_bnds(mip, j, dn_type, lb, new_ub);\n         T->curr->lp_obj = dn_lp;\n         if (mip->dir == GLP_MIN)\n         {  if (T->curr->bound < dn_bnd)\n                T->curr->bound = dn_bnd;\n         }\n         else if (mip->dir == GLP_MAX)\n         {  if (T->curr->bound > dn_bnd)\n                T->curr->bound = dn_bnd;\n         }\n         else\n            xassert(mip != mip);\n         ret = 1;\n         goto done;\n      }\n      else if (dn_bad)\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Down-branch is hopeless\\n\");\n         glp_set_col_bnds(mip, j, up_type, new_lb, ub);\n         T->curr->lp_obj = up_lp;\n         if (mip->dir == GLP_MIN)\n         {  if (T->curr->bound < up_bnd)\n                T->curr->bound = up_bnd;\n         }\n         else if (mip->dir == GLP_MAX)\n         {  if (T->curr->bound > up_bnd)\n                T->curr->bound = up_bnd;\n         }\n         else\n            xassert(mip != mip);\n         ret = 1;\n         goto done;\n      }\n      /* both down- and up-branches seem to be hopeful */\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n         xprintf(\"Branching on column %d, primal value is %.9e\\n\",\n            j, beta);\n      /* determine the reference number of the current subproblem */\n      xassert(T->curr != NULL);\n      p = T->curr->p;\n      T->curr->br_var = j;\n      T->curr->br_val = beta;\n      /* freeze the current subproblem */\n      ios_freeze_node(T);\n      /* create two clones of the current subproblem; the first clone\n         begins the down-branch, the second one begins the up-branch */\n      ios_clone_node(T, p, 2, clone);\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n         xprintf(\"Node %d begins down branch, node %d begins up branch \"\n            \"\\n\", clone[1], clone[2]);\n      /* set new upper bound of j-th column in the down-branch */\n      node = T->slot[clone[1]].node;\n      xassert(node != NULL);\n      xassert(node->up != NULL);\n      xassert(node->b_ptr == NULL);\n      node->b_ptr = dmp_get_atom(T->pool, sizeof(IOSBND));\n      node->b_ptr->k = m + j;\n      node->b_ptr->type = (unsigned char)dn_type;\n      node->b_ptr->lb = lb;\n      node->b_ptr->ub = new_ub;\n      node->b_ptr->next = NULL;\n      node->lp_obj = dn_lp;\n      if (mip->dir == GLP_MIN)\n      {  if (node->bound < dn_bnd)\n             node->bound = dn_bnd;\n      }\n      else if (mip->dir == GLP_MAX)\n      {  if (node->bound > dn_bnd)\n             node->bound = dn_bnd;\n      }\n      else\n         xassert(mip != mip);\n      /* set new lower bound of j-th column in the up-branch */\n      node = T->slot[clone[2]].node;\n      xassert(node != NULL);\n      xassert(node->up != NULL);\n      xassert(node->b_ptr == NULL);\n      node->b_ptr = dmp_get_atom(T->pool, sizeof(IOSBND));\n      node->b_ptr->k = m + j;\n      node->b_ptr->type = (unsigned char)up_type;\n      node->b_ptr->lb = new_lb;\n      node->b_ptr->ub = ub;\n      node->b_ptr->next = NULL;\n      node->lp_obj = up_lp;\n      if (mip->dir == GLP_MIN)\n      {  if (node->bound < up_bnd)\n             node->bound = up_bnd;\n      }\n      else if (mip->dir == GLP_MAX)\n      {  if (node->bound > up_bnd)\n             node->bound = up_bnd;\n      }\n      else\n         xassert(mip != mip);\n      /* suggest the subproblem to be solved next */\n      xassert(T->child == 0);\n      if (next == GLP_NO_BRNCH)\n         T->child = 0;\n      else if (next == GLP_DN_BRNCH)\n         T->child = clone[1];\n      else if (next == GLP_UP_BRNCH)\n         T->child = clone[2];\n      else\n         xassert(next != next);\n      ret = 0;\ndone: return ret;\n}",
      "lines": 167,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cleanup_the_tree": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "static void cleanup_the_tree(glp_tree *T)\n{     IOSNPD *node, *next_node;\n      int count = 0;\n      /* the global bound must exist */\n      xassert(T->mip->mip_stat == GLP_FEAS);\n      /* walk through the list of active subproblems */\n      for (node = T->head; node != NULL; node = next_node)\n      {  /* deleting some active problem node may involve deleting its\n            parents recursively; however, all its parents being created\n            *before* it are always *precede* it in the node list, so\n            the next problem node is never affected by such deletion */\n         next_node = node->next;\n         /* if the branch is hopeless, prune it */\n         if (!is_branch_hopeful(T, node->p))\n            ios_delete_node(T, node->p), count++;\n      }\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n      {  if (count == 1)\n            xprintf(\"One hopeless branch has been pruned\\n\");\n         else if (count > 1)\n            xprintf(\"%d hopeless branches have been pruned\\n\", count);\n      }\n      return;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "round_heur": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static int round_heur(glp_tree *T)\n{     glp_prob *P = T->mip;\n      /*int m = P->m;*/\n      int n = P->n;\n      int i, j, ret;\n      double *x;\n      /* compute rounded values of variables */\n      x = talloc(1+n, double);\n      for (j = 1; j <= n; j++)\n      {  GLPCOL *col = P->col[j];\n         if (col->kind == GLP_IV)\n         {  /* integer variable */\n            x[j] = floor(col->prim + 0.5);\n         }\n         else if (col->type == GLP_FX)\n         {  /* fixed variable */\n            x[j] = col->prim;\n         }\n         else\n         {  /* non-integer non-fixed variable */\n            ret = 3;\n            goto done;\n         }\n      }\n      /* check that no constraints are violated */\n      for (i = 1; i <= T->orig_m; i++)\n      {  int type = T->orig_type[i];\n         GLPAIJ *aij;\n         double sum;\n         if (type == GLP_FR)\n            continue;\n         /* compute value of linear form */\n         sum = 0.0;\n         for (aij = P->row[i]->ptr; aij != NULL; aij = aij->r_next)\n            sum += aij->val * x[aij->col->j];\n         /* check lower bound */\n         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n         {  if (sum < T->orig_lb[i] - 1e-9)\n            {  /* lower bound is violated */\n               ret = 2;\n               goto done;\n            }\n         }\n         /* check upper bound */\n         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n         {  if (sum > T->orig_ub[i] + 1e-9)\n            {  /* upper bound is violated */\n               ret = 2;\n               goto done;\n            }\n         }\n      }\n      /* rounded solution is integer feasible */\n      if (glp_ios_heur_sol(T, x) == 0)\n      {  /* solution is accepted */\n         ret = 0;\n      }\n      else\n      {  /* solution is rejected */\n         ret = 1;\n      }\ndone: tfree(x);\n      return ret;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gmi_gen": {
      "start_point": [
        641,
        0
      ],
      "end_point": [
        663,
        1
      ],
      "content": "static void gmi_gen(glp_tree *T)\n{     /* generate Gomory's mixed integer cuts */\n      glp_prob *P, *pool;\n      P = T->mip;\n      pool = glp_create_prob();\n      glp_add_cols(pool, P->n);\n      glp_gmi_gen(P, pool, 50);\n      if (pool->m > 0)\n      {  int i, len, *ind;\n         double *val;\n         ind = xcalloc(1+P->n, sizeof(int));\n         val = xcalloc(1+P->n, sizeof(double));\n         for (i = 1; i <= pool->m; i++)\n         {  len = glp_get_mat_row(pool, i, ind, val);\n            glp_ios_add_row(T, NULL, GLP_RF_GMI, 0, len, ind, val,\n               GLP_LO, pool->row[i]->lb);\n         }\n         xfree(ind);\n         xfree(val);\n      }\n      glp_delete_prob(pool);\n      return;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cov_gen": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void cov_gen(glp_tree *T)\n{     /* generate cover cuts */\n      glp_prob *P, *pool;\n      if (T->cov_gen == NULL)\n         return;\n      P = T->mip;\n      pool = glp_create_prob();\n      glp_add_cols(pool, P->n);\n      glp_cov_gen1(P, T->cov_gen, pool);\n      if (pool->m > 0)\n      {  int i, len, *ind;\n         double *val;\n         ind = xcalloc(1+P->n, sizeof(int));\n         val = xcalloc(1+P->n, sizeof(double));\n         for (i = 1; i <= pool->m; i++)\n         {  len = glp_get_mat_row(pool, i, ind, val);\n            glp_ios_add_row(T, NULL, GLP_RF_COV, 0, len, ind, val,\n               GLP_UP, pool->row[i]->ub);\n         }\n         xfree(ind);\n         xfree(val);\n      }\n      glp_delete_prob(pool);\n      return;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mir_gen": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "static void mir_gen(glp_tree *T)\n{     /* generate mixed integer rounding cuts */\n      glp_prob *P, *pool;\n      P = T->mip;\n      pool = glp_create_prob();\n      glp_add_cols(pool, P->n);\n      glp_mir_gen(P, T->mir_gen, pool);\n      if (pool->m > 0)\n      {  int i, len, *ind;\n         double *val;\n         ind = xcalloc(1+P->n, sizeof(int));\n         val = xcalloc(1+P->n, sizeof(double));\n         for (i = 1; i <= pool->m; i++)\n         {  len = glp_get_mat_row(pool, i, ind, val);\n            glp_ios_add_row(T, NULL, GLP_RF_MIR, 0, len, ind, val,\n               GLP_UP, pool->row[i]->ub);\n         }\n         xfree(ind);\n         xfree(val);\n      }\n      glp_delete_prob(pool);\n      return;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clq_gen": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        736,
        1
      ],
      "content": "static void clq_gen(glp_tree *T, glp_cfg *G)\n{     /* generate clique cut from conflict graph */\n      glp_prob *P = T->mip;\n      int n = P->n;\n      int len, *ind;\n      double *val;\n      ind = talloc(1+n, int);\n      val = talloc(1+n, double);\n      len = glp_clq_cut(T->mip, G, ind, val);\n      if (len > 0)\n         glp_ios_add_row(T, NULL, GLP_RF_CLQ, 0, len, ind, val, GLP_UP,\n            val[0]);\n      tfree(ind);\n      tfree(val);\n      return;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "remove_cuts": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "static void remove_cuts(glp_tree *T)\n{     /* remove inactive cuts (some valueable globally valid cut might\n         be saved in the global cut pool) */\n      int i, cnt = 0, *num = NULL;\n      xassert(T->curr != NULL);\n      for (i = T->orig_m+1; i <= T->mip->m; i++)\n      {  if (T->mip->row[i]->origin == GLP_RF_CUT &&\n             T->mip->row[i]->level == T->curr->level &&\n             T->mip->row[i]->stat == GLP_BS)\n         {  if (num == NULL)\n               num = xcalloc(1+T->mip->m, sizeof(int));\n            num[++cnt] = i;\n         }\n      }\n      if (cnt > 0)\n      {  glp_del_rows(T->mip, cnt, num);\n#if 0\n         xprintf(\"%d inactive cut(s) removed\\n\", cnt);\n#endif\n         xfree(num);\n         xassert(glp_factorize(T->mip) == 0);\n      }\n      return;\n}",
      "lines": 24,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_cut_info": {
      "start_point": [
        831,
        0
      ],
      "end_point": [
        862,
        1
      ],
      "content": "static void display_cut_info(glp_tree *T)\n{     glp_prob *mip = T->mip;\n      int i, gmi = 0, mir = 0, cov = 0, clq = 0, app = 0;\n      for (i = mip->m; i > 0; i--)\n      {  GLPROW *row;\n         row = mip->row[i];\n         /* if (row->level < T->curr->level) break; */\n         if (row->origin == GLP_RF_CUT)\n         {  if (row->klass == GLP_RF_GMI)\n               gmi++;\n            else if (row->klass == GLP_RF_MIR)\n               mir++;\n            else if (row->klass == GLP_RF_COV)\n               cov++;\n            else if (row->klass == GLP_RF_CLQ)\n               clq++;\n            else\n               app++;\n         }\n      }\n      xassert(T->curr != NULL);\n      if (gmi + mir + cov + clq + app > 0)\n      {  xprintf(\"Cuts on level %d:\", T->curr->level);\n         if (gmi > 0) xprintf(\" gmi = %d;\", gmi);\n         if (mir > 0) xprintf(\" mir = %d;\", mir);\n         if (cov > 0) xprintf(\" cov = %d;\", cov);\n         if (clq > 0) xprintf(\" clq = %d;\", clq);\n         if (app > 0) xprintf(\" app = %d;\", app);\n         xprintf(\"\\n\");\n      }\n      return;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ios_driver": {
      "start_point": [
        899,
        0
      ],
      "end_point": [
        1110,
        7
      ],
      "content": "int ios_driver(glp_tree *T)\n{     int p, curr_p, p_stat, d_stat, ret;\n#if 1 /* carry out to glp_tree */\n      int pred_p = 0;\n      /* if the current subproblem has been just created due to\n         branching, pred_p is the reference number of its parent\n         subproblem, otherwise pred_p is zero */\n#endif\n#if 1 /* 18/VII-2013 */\n      int bad_cut;\n      double old_obj;\n#endif\n#if 0 /* 10/VI-2013 */\n      glp_long ttt = T->tm_beg;\n#else\n      double ttt = T->tm_beg;\n#endif\n#if 1 /* 27/II-2016 by Chris */\n      int root_done = 0;\n#endif\n#if 0\n      ((glp_iocp *)T->parm)->msg_lev = GLP_MSG_DBG;\n#endif\n#if 1 /* 16/III-2016 */\n      if (((glp_iocp *)T->parm)->flip)\n#if 0 /* 20/I-2018 */\n         xprintf(\"WARNING: LONG-STEP DUAL SIMPLEX WILL BE USED\\n\");\n#else\n         xprintf(\"Long-step dual simplex will be used\\n\");\n#endif\n#endif\n      /* on entry to the B&B driver it is assumed that the active list\n         contains the only active (i.e. root) subproblem, which is the\n         original MIP problem to be solved */\nloop: /* main loop starts here */\n      /* at this point the current subproblem does not exist */\n      xassert(T->curr == NULL);\n      /* if the active list is empty, the search is finished */\n      if (T->head == NULL)\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Active list is empty!\\n\");\n#if 0 /* 10/VI-2013 */\n         xassert(dmp_in_use(T->pool).lo == 0);\n#else\n         xassert(dmp_in_use(T->pool) == 0);\n#endif\n         ret = 0;\n         goto done;\n      }\n      /* select some active subproblem to continue the search */\n      xassert(T->next_p == 0);\n      /* let the application program select subproblem */\n      if (T->parm->cb_func != NULL)\n      {  xassert(T->reason == 0);\n         T->reason = GLP_ISELECT;\n         T->parm->cb_func(T, T->parm->cb_info);\n         T->reason = 0;\n         if (T->stop)\n         {  ret = GLP_ESTOP;\n            goto done;\n         }\n      }\n      if (T->next_p != 0)\n      {  /* the application program has selected something */\n         ;\n      }\n      else if (T->a_cnt == 1)\n      {  /* the only active subproblem exists, so select it */\n         xassert(T->head->next == NULL);\n         T->next_p = T->head->p;\n      }\n      else if (T->child != 0)\n      {  /* select one of branching childs suggested by the branching\n            heuristic */\n         T->next_p = T->child;\n      }\n      else\n      {  /* select active subproblem as specified by the backtracking\n            technique option */\n         T->next_p = ios_choose_node(T);\n      }\n      /* the active subproblem just selected becomes current */\n      ios_revive_node(T, T->next_p);\n      T->next_p = T->child = 0;\n      /* invalidate pred_p, if it is not the reference number of the\n         parent of the current subproblem */\n      if (T->curr->up != NULL && T->curr->up->p != pred_p) pred_p = 0;\n      /* determine the reference number of the current subproblem */\n      p = T->curr->p;\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n      {  xprintf(\"-----------------------------------------------------\"\n            \"-------------------\\n\");\n         xprintf(\"Processing node %d at level %d\\n\", p, T->curr->level);\n      }\n#if 0\n      if (p == 1)\n         glp_write_lp(T->mip, NULL, \"root.lp\");\n#endif\n#if 1 /* 24/X-2015 */\n      if (p == 1)\n      {  if (T->parm->sr_heur == GLP_OFF)\n         {  if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"Simple rounding heuristic disabled\\n\");\n         }\n      }\n#endif\n      /* if it is the root subproblem, initialize cut generators */\n      if (p == 1)\n      {  if (T->parm->gmi_cuts == GLP_ON)\n         {  if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"Gomory's cuts enabled\\n\");\n         }\n         if (T->parm->mir_cuts == GLP_ON)\n         {  if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"MIR cuts enabled\\n\");\n            xassert(T->mir_gen == NULL);\n#if 0 /* 06/III-2016 */\n            T->mir_gen = ios_mir_init(T);\n#else\n            T->mir_gen = glp_mir_init(T->mip);\n#endif\n         }\n         if (T->parm->cov_cuts == GLP_ON)\n         {  if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"Cover cuts enabled\\n\");\n#ifdef NEW_COVER /* 13/II-2018 */\n            xassert(T->cov_gen == NULL);\n            T->cov_gen = glp_cov_init(T->mip);\n#endif\n         }\n         if (T->parm->clq_cuts == GLP_ON)\n         {  xassert(T->clq_gen == NULL);\n            if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"Clique cuts enabled\\n\");\n#if 0 /* 08/III-2016 */\n            T->clq_gen = ios_clq_init(T);\n#else\n            T->clq_gen = glp_cfg_init(T->mip);\n#endif\n         }\n      }\n#if 1 /* 18/VII-2013 */\n      bad_cut = 0;\n#endif\nmore: /* minor loop starts here */\n      /* at this point the current subproblem needs either to be solved\n         for the first time or re-optimized due to reformulation */\n      /* display current progress of the search */\n      if (T->parm->msg_lev >= GLP_MSG_DBG ||\n          T->parm->msg_lev >= GLP_MSG_ON &&\n        (double)(T->parm->out_frq - 1) <=\n            1000.0 * xdifftime(xtime(), T->tm_lag))\n         show_progress(T, 0);\n      if (T->parm->msg_lev >= GLP_MSG_ALL &&\n            xdifftime(xtime(), ttt) >= 60.0)\n#if 0 /* 16/II-2012 */\n      {  glp_long total;\n         glp_mem_usage(NULL, NULL, &total, NULL);\n         xprintf(\"Time used: %.1f secs.  Memory used: %.1f Mb.\\n\",\n            xdifftime(xtime(), T->tm_beg), xltod(total) / 1048576.0);\n         ttt = xtime();\n      }\n#else\n      {  size_t total;\n         glp_mem_usage(NULL, NULL, &total, NULL);\n         xprintf(\"Time used: %.1f secs.  Memory used: %.1f Mb.\\n\",\n            xdifftime(xtime(), T->tm_beg), (double)total / 1048576.0);\n         ttt = xtime();\n      }\n#endif\n      /* check the mip gap */\n      if (T->parm->mip_gap > 0.0 &&\n          ios_relative_gap(T) <= T->parm->mip_gap)\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Relative gap tolerance reached; search terminated \"\n               \"\\n\");\n         ret = GLP_EMIPGAP;\n         goto done;\n      }\n      /* check if the time limit has been exhausted */\n      if (T->parm->tm_lim < INT_MAX &&\n         (double)(T->parm->tm_lim - 1) <=\n         1000.0 * xdifftime(xtime(), T->tm_beg))\n      {  if (T->parm->msg_lev >= GLP_MSG_DBG)\n            xprintf(\"Time limit exhausted; search terminated\\n\");\n         ret = GLP_ETMLIM;\n         goto done;\n      }\n      /* let the application program preprocess the subproblem */\n      if (T->parm->cb_func != NULL)\n      {  xassert(T->reason == 0);\n         T->reason = GLP_IPREPRO;\n         T->parm->cb_func(T, T->parm->cb_info);\n         T->reason = 0;\n         if (T->stop)\n         {  ret = GLP_ESTOP;\n            goto done;\n         }\n      }\n      /* perform basic preprocessing */\n      if (T->parm->pp_tech == GLP_PP_NONE)\n         ;\n      else if (T->parm->pp_tech == GLP_PP_ROOT)\n#if 0 /* 27/II-2016 by Chris */\n      {  if (T->curr->level == 0)\n#else\n      {  if (!root_done)\n#endif\n         {  if (ios_preprocess_node(T, 100))\n               goto fath;\n         }\n      }",
      "lines": 212,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpios07.c": {
    "cover2": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static int cover2(int n, double a[], double b, double u, double x[],\n      double y, int cov[], double *_alfa, double *_beta)\n{     /* try to generate mixed cover cut using two-element cover */\n      int i, j, try = 0, ret = 0;\n      double eps, alfa, beta, temp, rmax = 0.001;\n      eps = 0.001 * (1.0 + fabs(b));\n      for (i = 0+1; i <= n; i++)\n      for (j = i+1; j <= n; j++)\n      {  /* C = {i, j} */\n         try++;\n         if (try > MAXTRY) goto done;\n         /* check if condition (8) is satisfied */\n         if (a[i] + a[j] + y > b + eps)\n         {  /* compute parameters for inequality (15) */\n            temp = a[i] + a[j] - b;\n            alfa = 1.0 / (temp + u);\n            beta = 2.0 - alfa * temp;\n            /* compute violation of inequality (15) */\n            temp = x[i] + x[j] + alfa * y - beta;\n            /* choose C providing maximum violation */\n            if (rmax < temp)\n            {  rmax = temp;\n               cov[1] = i;\n               cov[2] = j;\n               *_alfa = alfa;\n               *_beta = beta;\n               ret = 1;\n            }\n         }\n      }\ndone: return ret;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cover3": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static int cover3(int n, double a[], double b, double u, double x[],\n      double y, int cov[], double *_alfa, double *_beta)\n{     /* try to generate mixed cover cut using three-element cover */\n      int i, j, k, try = 0, ret = 0;\n      double eps, alfa, beta, temp, rmax = 0.001;\n      eps = 0.001 * (1.0 + fabs(b));\n      for (i = 0+1; i <= n; i++)\n      for (j = i+1; j <= n; j++)\n      for (k = j+1; k <= n; k++)\n      {  /* C = {i, j, k} */\n         try++;\n         if (try > MAXTRY) goto done;\n         /* check if condition (8) is satisfied */\n         if (a[i] + a[j] + a[k] + y > b + eps)\n         {  /* compute parameters for inequality (15) */\n            temp = a[i] + a[j] + a[k] - b;\n            alfa = 1.0 / (temp + u);\n            beta = 3.0 - alfa * temp;\n            /* compute violation of inequality (15) */\n            temp = x[i] + x[j] + x[k] + alfa * y - beta;\n            /* choose C providing maximum violation */\n            if (rmax < temp)\n            {  rmax = temp;\n               cov[1] = i;\n               cov[2] = j;\n               cov[3] = k;\n               *_alfa = alfa;\n               *_beta = beta;\n               ret = 1;\n            }\n         }\n      }\ndone: return ret;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cover4": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static int cover4(int n, double a[], double b, double u, double x[],\n      double y, int cov[], double *_alfa, double *_beta)\n{     /* try to generate mixed cover cut using four-element cover */\n      int i, j, k, l, try = 0, ret = 0;\n      double eps, alfa, beta, temp, rmax = 0.001;\n      eps = 0.001 * (1.0 + fabs(b));\n      for (i = 0+1; i <= n; i++)\n      for (j = i+1; j <= n; j++)\n      for (k = j+1; k <= n; k++)\n      for (l = k+1; l <= n; l++)\n      {  /* C = {i, j, k, l} */\n         try++;\n         if (try > MAXTRY) goto done;\n         /* check if condition (8) is satisfied */\n         if (a[i] + a[j] + a[k] + a[l] + y > b + eps)\n         {  /* compute parameters for inequality (15) */\n            temp = a[i] + a[j] + a[k] + a[l] - b;\n            alfa = 1.0 / (temp + u);\n            beta = 4.0 - alfa * temp;\n            /* compute violation of inequality (15) */\n            temp = x[i] + x[j] + x[k] + x[l] + alfa * y - beta;\n            /* choose C providing maximum violation */\n            if (rmax < temp)\n            {  rmax = temp;\n               cov[1] = i;\n               cov[2] = j;\n               cov[3] = k;\n               cov[4] = l;\n               *_alfa = alfa;\n               *_beta = beta;\n               ret = 1;\n            }\n         }\n      }\ndone: return ret;\n}",
      "lines": 36,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cover": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static int cover(int n, double a[], double b, double u, double x[],\n      double y, int cov[], double *alfa, double *beta)\n{     /* try to generate mixed cover cut;\n         input (see (5)):\n         n        is the number of binary variables;\n         a[1:n]   are coefficients at binary variables;\n         b        is the right-hand side;\n         u        is upper bound of continuous variable;\n         x[1:n]   are values of binary variables at current point;\n         y        is value of continuous variable at current point;\n         output (see (15), (16), (17)):\n         cov[1:r] are indices of binary variables included in cover C,\n                  where r is the set cardinality returned on exit;\n         alfa     coefficient at continuous variable;\n         beta     is the right-hand side; */\n      int j;\n      /* perform some sanity checks */\n      xassert(n >= 2);\n      for (j = 1; j <= n; j++) xassert(a[j] > 0.0);\n#if 1 /* ??? */\n      xassert(b > -1e-5);\n#else\n      xassert(b > 0.0);\n#endif\n      xassert(u >= 0.0);\n      for (j = 1; j <= n; j++) xassert(0.0 <= x[j] && x[j] <= 1.0);\n      xassert(0.0 <= y && y <= u);\n      /* try to generate mixed cover cut */\n      if (cover2(n, a, b, u, x, y, cov, alfa, beta)) return 2;\n      if (cover3(n, a, b, u, x, y, cov, alfa, beta)) return 3;\n      if (cover4(n, a, b, u, x, y, cov, alfa, beta)) return 4;\n      return 0;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lpx_cover_cut": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "static int lpx_cover_cut(glp_prob *lp, int len, int ind[],\n      double val[], double work[])\n{     int cov[1+4], j, k, nb, newlen, r;\n      double f_min, f_max, alfa, beta, u, *x = work, y;\n      /* substitute and remove fixed variables */\n      newlen = 0;\n      for (k = 1; k <= len; k++)\n      {  j = ind[k];\n         if (glp_get_col_type(lp, j) == GLP_FX)\n            val[0] -= val[k] * glp_get_col_lb(lp, j);\n         else\n         {  newlen++;\n            ind[newlen] = ind[k];\n            val[newlen] = val[k];\n         }\n      }\n      len = newlen;\n      /* move binary variables to the beginning of the list so that\n         elements 1, 2, ..., nb correspond to binary variables, and\n         elements nb+1, nb+2, ..., len correspond to rest variables */\n      nb = 0;\n      for (k = 1; k <= len; k++)\n      {  j = ind[k];\n         if (glp_get_col_kind(lp, j) == GLP_BV)\n         {  /* binary variable */\n            int ind_k;\n            double val_k;\n            nb++;\n            ind_k = ind[nb], val_k = val[nb];\n            ind[nb] = ind[k], val[nb] = val[k];\n            ind[k] = ind_k, val[k] = val_k;\n         }\n      }\n      /* now the specified row has the form:\n         sum a[j]*x[j] + sum a[j]*y[j] <= b,\n         where x[j] are binary variables, y[j] are rest variables */\n      /* at least two binary variables are needed */\n      if (nb < 2) return 0;\n      /* compute implied lower and upper bounds for sum a[j]*y[j] */\n      f_min = f_max = 0.0;\n      for (k = nb+1; k <= len; k++)\n      {  j = ind[k];\n         /* both bounds must be finite */\n         if (glp_get_col_type(lp, j) != GLP_DB) return 0;\n         if (val[k] > 0.0)\n         {  f_min += val[k] * glp_get_col_lb(lp, j);\n            f_max += val[k] * glp_get_col_ub(lp, j);\n         }\n         else\n         {  f_min += val[k] * glp_get_col_ub(lp, j);\n            f_max += val[k] * glp_get_col_lb(lp, j);\n         }\n      }\n      /* sum a[j]*x[j] + sum a[j]*y[j] <= b ===>\n         sum a[j]*x[j] + (sum a[j]*y[j] - f_min) <= b - f_min ===>\n         sum a[j]*x[j] + y <= b - f_min,\n         where y = sum a[j]*y[j] - f_min;\n         note that 0 <= y <= u, u = f_max - f_min */\n      /* determine upper bound of y */\n      u = f_max - f_min;\n      /* determine value of y at the current point */\n      y = 0.0;\n      for (k = nb+1; k <= len; k++)\n      {  j = ind[k];\n         y += val[k] * glp_get_col_prim(lp, j);\n      }\n      y -= f_min;\n      if (y < 0.0) y = 0.0;\n      if (y > u) y = u;\n      /* modify the right-hand side b */\n      val[0] -= f_min;\n      /* now the transformed row has the form:\n         sum a[j]*x[j] + y <= b, where 0 <= y <= u */\n      /* determine values of x[j] at the current point */\n      for (k = 1; k <= nb; k++)\n      {  j = ind[k];\n         x[k] = glp_get_col_prim(lp, j);\n         if (x[k] < 0.0) x[k] = 0.0;\n         if (x[k] > 1.0) x[k] = 1.0;\n      }\n      /* if a[j] < 0, replace x[j] by its complement 1 - x'[j] */\n      for (k = 1; k <= nb; k++)\n      {  if (val[k] < 0.0)\n         {  ind[k] = - ind[k];\n            val[k] = - val[k];\n            val[0] += val[k];\n            x[k] = 1.0 - x[k];\n         }\n      }\n      /* try to generate a mixed cover cut for the transformed row */\n      r = cover(nb, val, val[0], u, x, y, cov, &alfa, &beta);\n      if (r == 0) return 0;\n      xassert(2 <= r && r <= 4);\n      /* now the cut is in the form:\n         sum{j in C} x[j] + alfa * y <= beta */\n      /* store the right-hand side beta */\n      ind[0] = 0, val[0] = beta;\n      /* restore the original ordinal numbers of x[j] */\n      for (j = 1; j <= r; j++) cov[j] = ind[cov[j]];\n      /* store cut coefficients at binary variables complementing back\n         the variables having negative row coefficients */\n      xassert(r <= nb);\n      for (k = 1; k <= r; k++)\n      {  if (cov[k] > 0)\n         {  ind[k] = +cov[k];\n            val[k] = +1.0;\n         }\n         else\n         {  ind[k] = -cov[k];\n            val[k] = -1.0;\n            val[0] -= 1.0;\n         }\n      }\n      /* substitute y = sum a[j]*y[j] - f_min */\n      for (k = nb+1; k <= len; k++)\n      {  r++;\n         ind[r] = ind[k];\n         val[r] = alfa * val[k];\n      }\n      val[0] += alfa * f_min;\n      xassert(r <= len);\n      len = r;\n      return len;\n}",
      "lines": 124,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "lpx_eval_row": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "static double lpx_eval_row(glp_prob *lp, int len, int ind[],\n      double val[])\n{     int n = glp_get_num_cols(lp);\n      int j, k;\n      double sum = 0.0;\n      if (len < 0)\n         xerror(\"lpx_eval_row: len = %d; invalid row length\\n\", len);\n      for (k = 1; k <= len; k++)\n      {  j = ind[k];\n         if (!(1 <= j && j <= n))\n            xerror(\"lpx_eval_row: j = %d; column number out of range\\n\",\n               j);\n         sum += val[k] * glp_get_col_prim(lp, j);\n      }\n      return sum;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "ios_cov_gen": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        548,
        1
      ],
      "content": "void ios_cov_gen(glp_tree *tree)\n{     glp_prob *prob = tree->mip;\n      int m = glp_get_num_rows(prob);\n      int n = glp_get_num_cols(prob);\n      int i, k, type, kase, len, *ind;\n      double r, *val, *work;\n      xassert(glp_get_status(prob) == GLP_OPT);\n      /* allocate working arrays */\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      work = xcalloc(1+n, sizeof(double));\n      /* look through all rows */\n      for (i = 1; i <= m; i++)\n      for (kase = 1; kase <= 2; kase++)\n      {  type = glp_get_row_type(prob, i);\n         if (kase == 1)\n         {  /* consider rows of '<=' type */\n            if (!(type == GLP_UP || type == GLP_DB)) continue;\n            len = glp_get_mat_row(prob, i, ind, val);\n            val[0] = glp_get_row_ub(prob, i);\n         }\n         else\n         {  /* consider rows of '>=' type */\n            if (!(type == GLP_LO || type == GLP_DB)) continue;\n            len = glp_get_mat_row(prob, i, ind, val);\n            for (k = 1; k <= len; k++) val[k] = - val[k];\n            val[0] = - glp_get_row_lb(prob, i);\n         }\n         /* generate mixed cover cut:\n            sum{j in J} a[j] * x[j] <= b */\n         len = lpx_cover_cut(prob, len, ind, val, work);\n         if (len == 0) continue;\n         /* at the current point the cut inequality is violated, i.e.\n            sum{j in J} a[j] * x[j] - b > 0 */\n         r = lpx_eval_row(prob, len, ind, val) - val[0];\n         if (r < 1e-3) continue;\n         /* add the cut to the cut pool */\n         glp_ios_add_row(tree, NULL, GLP_RF_COV, 0, len, ind, val,\n            GLP_UP, val[0]);\n      }\n      /* free working arrays */\n      xfree(ind);\n      xfree(val);\n      xfree(work);\n      return;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpios09.c": {
    "ios_choose_var": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int ios_choose_var(glp_tree *T, int *next)\n{     int j;\n      if (T->parm->br_tech == GLP_BR_FFV)\n      {  /* branch on first fractional variable */\n         j = branch_first(T, next);\n      }\n      else if (T->parm->br_tech == GLP_BR_LFV)\n      {  /* branch on last fractional variable */\n         j = branch_last(T, next);\n      }\n      else if (T->parm->br_tech == GLP_BR_MFV)\n      {  /* branch on most fractional variable */\n         j = branch_mostf(T, next);\n      }\n      else if (T->parm->br_tech == GLP_BR_DTH)\n      {  /* branch using the heuristic by Dreebeck and Tomlin */\n         j = branch_drtom(T, next);\n      }\n      else if (T->parm->br_tech == GLP_BR_PCH)\n      {  /* hybrid pseudocost heuristic */\n         j = ios_pcost_branch(T, next);\n      }\n      else\n         xassert(T != T);\n      return j;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "branch_first": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int branch_first(glp_tree *T, int *_next)\n{     int j, next;\n      double beta;\n      /* choose the column to branch on */\n      for (j = 1; j <= T->n; j++)\n         if (T->non_int[j]) break;\n      xassert(1 <= j && j <= T->n);\n      /* select the branch to be solved next */\n      beta = glp_get_col_prim(T->mip, j);\n      if (beta - floor(beta) < ceil(beta) - beta)\n         next = GLP_DN_BRNCH;\n      else\n         next = GLP_UP_BRNCH;\n      *_next = next;\n      return j;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "branch_last": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static int branch_last(glp_tree *T, int *_next)\n{     int j, next;\n      double beta;\n      /* choose the column to branch on */\n      for (j = T->n; j >= 1; j--)\n         if (T->non_int[j]) break;\n      xassert(1 <= j && j <= T->n);\n      /* select the branch to be solved next */\n      beta = glp_get_col_prim(T->mip, j);\n      if (beta - floor(beta) < ceil(beta) - beta)\n         next = GLP_DN_BRNCH;\n      else\n         next = GLP_UP_BRNCH;\n      *_next = next;\n      return j;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "branch_mostf": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        166,
        1
      ],
      "content": "static int branch_mostf(glp_tree *T, int *_next)\n{     int j, jj, next;\n      double beta, most, temp;\n      /* choose the column to branch on */\n      jj = 0, most = DBL_MAX;\n      for (j = 1; j <= T->n; j++)\n      {  if (T->non_int[j])\n         {  beta = glp_get_col_prim(T->mip, j);\n            temp = floor(beta) + 0.5;\n            if (most > fabs(beta - temp))\n            {  jj = j, most = fabs(beta - temp);\n               if (beta < temp)\n                  next = GLP_DN_BRNCH;\n               else\n                  next = GLP_UP_BRNCH;\n            }\n         }\n      }\n      *_next = next;\n      return jj;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "branch_drtom": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static int branch_drtom(glp_tree *T, int *_next)\n{     glp_prob *mip = T->mip;\n      int m = mip->m;\n      int n = mip->n;\n      unsigned char *non_int = T->non_int;\n      int j, jj, k, t, next, kase, len, stat, *ind;\n      double x, dk, alfa, delta_j, delta_k, delta_z, dz_dn, dz_up,\n         dd_dn, dd_up, degrad, *val;\n      /* basic solution of LP relaxation must be optimal */\n      xassert(glp_get_status(mip) == GLP_OPT);\n      /* allocate working arrays */\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      /* nothing has been chosen so far */\n      jj = 0, degrad = -1.0;\n      /* walk through the list of columns (structural variables) */\n      for (j = 1; j <= n; j++)\n      {  /* if j-th column is not marked as fractional, skip it */\n         if (!non_int[j]) continue;\n         /* obtain (fractional) value of j-th column in basic solution\n            of LP relaxation */\n         x = glp_get_col_prim(mip, j);\n         /* since the value of j-th column is fractional, the column is\n            basic; compute corresponding row of the simplex table */\n         len = glp_eval_tab_row(mip, m+j, ind, val);\n         /* the following fragment computes a change in the objective\n            function: delta Z = new Z - old Z, where old Z is the\n            objective value in the current optimal basis, and new Z is\n            the objective value in the adjacent basis, for two cases:\n            1) if new upper bound ub' = floor(x[j]) is introduced for\n               j-th column (down branch);\n            2) if new lower bound lb' = ceil(x[j]) is introduced for\n               j-th column (up branch);\n            since in both cases the solution remaining dual feasible\n            becomes primal infeasible, one implicit simplex iteration\n            is performed to determine the change delta Z;\n            it is obvious that new Z, which is never better than old Z,\n            is a lower (minimization) or upper (maximization) bound of\n            the objective function for down- and up-branches. */\n         for (kase = -1; kase <= +1; kase += 2)\n         {  /* if kase < 0, the new upper bound of x[j] is introduced;\n               in this case x[j] should decrease in order to leave the\n               basis and go to its new upper bound */\n            /* if kase > 0, the new lower bound of x[j] is introduced;\n               in this case x[j] should increase in order to leave the\n               basis and go to its new lower bound */\n            /* apply the dual ratio test in order to determine which\n               auxiliary or structural variable should enter the basis\n               to keep dual feasibility */\n            k = glp_dual_rtest(mip, len, ind, val, kase, 1e-9);\n            if (k != 0) k = ind[k];\n            /* if no non-basic variable has been chosen, LP relaxation\n               of corresponding branch being primal infeasible and dual\n               unbounded has no primal feasible solution; in this case\n               the change delta Z is formally set to infinity */\n            if (k == 0)\n            {  delta_z =\n                  (T->mip->dir == GLP_MIN ? +DBL_MAX : -DBL_MAX);\n               goto skip;\n            }\n            /* row of the simplex table that corresponds to non-basic\n               variable x[k] choosen by the dual ratio test is:\n                  x[j] = ... + alfa * x[k] + ...\n               where alfa is the influence coefficient (an element of\n               the simplex table row) */\n            /* determine the coefficient alfa */\n            for (t = 1; t <= len; t++) if (ind[t] == k) break;\n            xassert(1 <= t && t <= len);\n            alfa = val[t];\n            /* since in the adjacent basis the variable x[j] becomes\n               non-basic, knowing its value in the current basis we can\n               determine its change delta x[j] = new x[j] - old x[j] */\n            delta_j = (kase < 0 ? floor(x) : ceil(x)) - x;\n            /* and knowing the coefficient alfa we can determine the\n               corresponding change delta x[k] = new x[k] - old x[k],\n               where old x[k] is a value of x[k] in the current basis,\n               and new x[k] is a value of x[k] in the adjacent basis */\n            delta_k = delta_j / alfa;\n            /* Tomlin noticed that if the variable x[k] is of integer\n               kind, its change cannot be less (eventually) than one in\n               the magnitude */\n            if (k > m && glp_get_col_kind(mip, k-m) != GLP_CV)\n            {  /* x[k] is structural integer variable */\n               if (fabs(delta_k - floor(delta_k + 0.5)) > 1e-3)\n               {  if (delta_k > 0.0)\n                     delta_k = ceil(delta_k);  /* +3.14 -> +4 */\n                  else\n                     delta_k = floor(delta_k); /* -3.14 -> -4 */\n               }\n            }\n            /* now determine the status and reduced cost of x[k] in the\n               current basis */\n            if (k <= m)\n            {  stat = glp_get_row_stat(mip, k);\n               dk = glp_get_row_dual(mip, k);\n            }\n            else\n            {  stat = glp_get_col_stat(mip, k-m);\n               dk = glp_get_col_dual(mip, k-m);\n            }\n            /* if the current basis is dual degenerate, some reduced\n               costs which are close to zero may have wrong sign due to\n               round-off errors, so correct the sign of d[k] */\n            switch (T->mip->dir)\n            {  case GLP_MIN:\n                  if (stat == GLP_NL && dk < 0.0 ||\n                      stat == GLP_NU && dk > 0.0 ||\n                      stat == GLP_NF) dk = 0.0;\n                  break;\n               case GLP_MAX:\n                  if (stat == GLP_NL && dk > 0.0 ||\n                      stat == GLP_NU && dk < 0.0 ||\n                      stat == GLP_NF) dk = 0.0;\n                  break;\n               default:\n                  xassert(T != T);\n            }\n            /* now knowing the change of x[k] and its reduced cost d[k]\n               we can compute the corresponding change in the objective\n               function delta Z = new Z - old Z = d[k] * delta x[k];\n               note that due to Tomlin's modification new Z can be even\n               worse than in the adjacent basis */\n            delta_z = dk * delta_k;\nskip:       /* new Z is never better than old Z, therefore the change\n               delta Z is always non-negative (in case of minimization)\n               or non-positive (in case of maximization) */\n            switch (T->mip->dir)\n            {  case GLP_MIN: xassert(delta_z >= 0.0); break;\n               case GLP_MAX: xassert(delta_z <= 0.0); break;\n               default: xassert(T != T);\n            }\n            /* save the change in the objective fnction for down- and\n               up-branches, respectively */\n            if (kase < 0) dz_dn = delta_z; else dz_up = delta_z;\n         }\n         /* thus, in down-branch no integer feasible solution can be\n            better than Z + dz_dn, and in up-branch no integer feasible\n            solution can be better than Z + dz_up, where Z is value of\n            the objective function in the current basis */\n         /* following the heuristic by Driebeck and Tomlin we choose a\n            column (i.e. structural variable) which provides largest\n            degradation of the objective function in some of branches;\n            besides, we select the branch with smaller degradation to\n            be solved next and keep other branch with larger degradation\n            in the active list hoping to minimize the number of further\n            backtrackings */\n         if (degrad < fabs(dz_dn) || degrad < fabs(dz_up))\n         {  jj = j;\n            if (fabs(dz_dn) < fabs(dz_up))\n            {  /* select down branch to be solved next */\n               next = GLP_DN_BRNCH;\n               degrad = fabs(dz_up);\n            }\n            else\n            {  /* select up branch to be solved next */\n               next = GLP_UP_BRNCH;\n               degrad = fabs(dz_dn);\n            }\n            /* save the objective changes for printing */\n            dd_dn = dz_dn, dd_up = dz_up;\n            /* if down- or up-branch has no feasible solution, we does\n               not need to consider other candidates (in principle, the\n               corresponding branch could be pruned right now) */\n            if (degrad == DBL_MAX) break;\n         }\n      }\n      /* free working arrays */\n      xfree(ind);\n      xfree(val);\n      /* something must be chosen */\n      xassert(1 <= jj && jj <= n);\n#if 1 /* 02/XI-2009 */\n      if (degrad < 1e-6 * (1.0 + 0.001 * fabs(mip->obj_val)))\n      {  jj = branch_mostf(T, &next);\n         goto done;\n      }\n#endif\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n      {  xprintf(\"branch_drtom: column %d chosen to branch on\\n\", jj);\n         if (fabs(dd_dn) == DBL_MAX)\n            xprintf(\"branch_drtom: down-branch is infeasible\\n\");\n         else\n            xprintf(\"branch_drtom: down-branch bound is %.9e\\n\",\n               glp_get_obj_val(mip) + dd_dn);\n         if (fabs(dd_up) == DBL_MAX)\n            xprintf(\"branch_drtom: up-branch   is infeasible\\n\");\n         else\n            xprintf(\"branch_drtom: up-branch   bound is %.9e\\n\",\n               glp_get_obj_val(mip) + dd_up);\n      }\ndone: *_next = next;\n      return jj;\n}",
      "lines": 193,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ios_pcost_init": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "void *ios_pcost_init(glp_tree *tree)\n{     /* initialize working data used on pseudocost branching */\n      struct csa *csa;\n      int n = tree->n, j;\n      csa = xmalloc(sizeof(struct csa));\n      csa->dn_cnt = xcalloc(1+n, sizeof(int));\n      csa->dn_sum = xcalloc(1+n, sizeof(double));\n      csa->up_cnt = xcalloc(1+n, sizeof(int));\n      csa->up_sum = xcalloc(1+n, sizeof(double));\n      for (j = 1; j <= n; j++)\n      {  csa->dn_cnt[j] = csa->up_cnt[j] = 0;\n         csa->dn_sum[j] = csa->up_sum[j] = 0.0;\n      }\n      return csa;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void",
        "*ios_pcost_init(glp_tree *tree)",
        "*"
      ]
    },
    "eval_degrad": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static double eval_degrad(glp_prob *P, int j, double bnd)\n{     /* compute degradation of the objective on fixing x[j] at given\n         value with a limited number of dual simplex iterations */\n      /* this routine fixes column x[j] at specified value bnd,\n         solves resulting LP, and returns a lower bound to degradation\n         of the objective, degrad >= 0 */\n      glp_prob *lp;\n      glp_smcp parm;\n      int ret;\n      double degrad;\n      /* the current basis must be optimal */\n      xassert(glp_get_status(P) == GLP_OPT);\n      /* create a copy of P */\n      lp = glp_create_prob();\n      glp_copy_prob(lp, P, 0);\n      /* fix column x[j] at specified value */\n      glp_set_col_bnds(lp, j, GLP_FX, bnd, bnd);\n      /* try to solve resulting LP */\n      glp_init_smcp(&parm);\n      parm.msg_lev = GLP_MSG_OFF;\n      parm.meth = GLP_DUAL;\n      parm.it_lim = 30;\n      parm.out_dly = 1000;\n      parm.meth = GLP_DUAL;\n      ret = glp_simplex(lp, &parm);\n      if (ret == 0 || ret == GLP_EITLIM)\n      {  if (glp_get_prim_stat(lp) == GLP_NOFEAS)\n         {  /* resulting LP has no primal feasible solution */\n            degrad = DBL_MAX;\n         }\n         else if (glp_get_dual_stat(lp) == GLP_FEAS)\n         {  /* resulting basis is optimal or at least dual feasible,\n               so we have the correct lower bound to degradation */\n            if (P->dir == GLP_MIN)\n               degrad = lp->obj_val - P->obj_val;\n            else if (P->dir == GLP_MAX)\n               degrad = P->obj_val - lp->obj_val;\n            else\n               xassert(P != P);\n            /* degradation cannot be negative by definition */\n            /* note that the lower bound to degradation may be close\n               to zero even if its exact value is zero due to round-off\n               errors on computing the objective value */\n            if (degrad < 1e-6 * (1.0 + 0.001 * fabs(P->obj_val)))\n               degrad = 0.0;\n         }\n         else\n         {  /* the final basis reported by the simplex solver is dual\n               infeasible, so we cannot determine a non-trivial lower\n               bound to degradation */\n            degrad = 0.0;\n         }\n      }\n      else\n      {  /* the simplex solver failed */\n         degrad = 0.0;\n      }\n      /* delete the copy of P */\n      glp_delete_prob(lp);\n      return degrad;\n}",
      "lines": 61,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "ios_pcost_update": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "void ios_pcost_update(glp_tree *tree)\n{     /* update history information for pseudocost branching */\n      /* this routine is called every time when LP relaxation of the\n         current subproblem has been solved to optimality with all lazy\n         and cutting plane constraints included */\n      int j;\n      double dx, dz, psi;\n      struct csa *csa = tree->pcost;\n      xassert(csa != NULL);\n      xassert(tree->curr != NULL);\n      /* if the current subproblem is the root, skip updating */\n      if (tree->curr->up == NULL) goto skip;\n      /* determine branching variable x[j], which was used in the\n         parent subproblem to create the current subproblem */\n      j = tree->curr->up->br_var;\n      xassert(1 <= j && j <= tree->n);\n      /* determine the change dx[j] = new x[j] - old x[j],\n         where new x[j] is a value of x[j] in optimal solution to LP\n         relaxation of the current subproblem, old x[j] is a value of\n         x[j] in optimal solution to LP relaxation of the parent\n         subproblem */\n      dx = tree->mip->col[j]->prim - tree->curr->up->br_val;\n      xassert(dx != 0.0);\n      /* determine corresponding change dz = new dz - old dz in the\n         objective function value */\n      dz = tree->mip->obj_val - tree->curr->up->lp_obj;\n      /* determine per unit degradation of the objective function */\n      psi = fabs(dz / dx);\n      /* update history information */\n      if (dx < 0.0)\n      {  /* the current subproblem is down-branch */\n         csa->dn_cnt[j]++;\n         csa->dn_sum[j] += psi;\n      }\n      else /* dx > 0.0 */\n      {  /* the current subproblem is up-branch */\n         csa->up_cnt[j]++;\n         csa->up_sum[j] += psi;\n      }\nskip: return;\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ios_pcost_free": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        538,
        1
      ],
      "content": "void ios_pcost_free(glp_tree *tree)\n{     /* free working area used on pseudocost branching */\n      struct csa *csa = tree->pcost;\n      xassert(csa != NULL);\n      xfree(csa->dn_cnt);\n      xfree(csa->dn_sum);\n      xfree(csa->up_cnt);\n      xfree(csa->up_sum);\n      xfree(csa);\n      tree->pcost = NULL;\n      return;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "eval_psi": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        580,
        1
      ],
      "content": "static double eval_psi(glp_tree *T, int j, int brnch)\n{     /* compute estimation of pseudocost of variable x[j] for down-\n         or up-branch */\n      struct csa *csa = T->pcost;\n      double beta, degrad, psi;\n      xassert(csa != NULL);\n      xassert(1 <= j && j <= T->n);\n      if (brnch == GLP_DN_BRNCH)\n      {  /* down-branch */\n         if (csa->dn_cnt[j] == 0)\n         {  /* initialize down pseudocost */\n            beta = T->mip->col[j]->prim;\n            degrad = eval_degrad(T->mip, j, floor(beta));\n            if (degrad == DBL_MAX)\n            {  psi = DBL_MAX;\n               goto done;\n            }\n            csa->dn_cnt[j] = 1;\n            csa->dn_sum[j] = degrad / (beta - floor(beta));\n         }\n         psi = csa->dn_sum[j] / (double)csa->dn_cnt[j];\n      }\n      else if (brnch == GLP_UP_BRNCH)\n      {  /* up-branch */\n         if (csa->up_cnt[j] == 0)\n         {  /* initialize up pseudocost */\n            beta = T->mip->col[j]->prim;\n            degrad = eval_degrad(T->mip, j, ceil(beta));\n            if (degrad == DBL_MAX)\n            {  psi = DBL_MAX;\n               goto done;\n            }\n            csa->up_cnt[j] = 1;\n            csa->up_sum[j] = degrad / (ceil(beta) - beta);\n         }\n         psi = csa->up_sum[j] / (double)csa->up_cnt[j];\n      }\n      else\n         xassert(brnch != brnch);\ndone: return psi;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "progress": {
      "start_point": [
        582,
        0
      ],
      "end_point": [
        595,
        1
      ],
      "content": "static void progress(glp_tree *T)\n{     /* display progress of pseudocost initialization */\n      struct csa *csa = T->pcost;\n      int j, nv = 0, ni = 0;\n      for (j = 1; j <= T->n; j++)\n      {  if (glp_ios_can_branch(T, j))\n         {  nv++;\n            if (csa->dn_cnt[j] > 0 && csa->up_cnt[j] > 0) ni++;\n         }\n      }\n      xprintf(\"Pseudocosts initialized for %d of %d variables\\n\",\n         ni, nv);\n      return;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ios_pcost_branch": {
      "start_point": [
        597,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "int ios_pcost_branch(glp_tree *T, int *_next)\n{     /* choose branching variable with pseudocost branching */\n#if 0 /* 10/VI-2013 */\n      glp_long t = xtime();\n#else\n      double t = xtime();\n#endif\n      int j, jjj, sel;\n      double beta, psi, d1, d2, d, dmax;\n      /* initialize the working arrays */\n      if (T->pcost == NULL)\n         T->pcost = ios_pcost_init(T);\n      /* nothing has been chosen so far */\n      jjj = 0, dmax = -1.0;\n      /* go through the list of branching candidates */\n      for (j = 1; j <= T->n; j++)\n      {  if (!glp_ios_can_branch(T, j)) continue;\n         /* determine primal value of x[j] in optimal solution to LP\n            relaxation of the current subproblem */\n         beta = T->mip->col[j]->prim;\n         /* estimate pseudocost of x[j] for down-branch */\n         psi = eval_psi(T, j, GLP_DN_BRNCH);\n         if (psi == DBL_MAX)\n         {  /* down-branch has no primal feasible solution */\n            jjj = j, sel = GLP_DN_BRNCH;\n            goto done;\n         }\n         /* estimate degradation of the objective for down-branch */\n         d1 = psi * (beta - floor(beta));\n         /* estimate pseudocost of x[j] for up-branch */\n         psi = eval_psi(T, j, GLP_UP_BRNCH);\n         if (psi == DBL_MAX)\n         {  /* up-branch has no primal feasible solution */\n            jjj = j, sel = GLP_UP_BRNCH;\n            goto done;\n         }\n         /* estimate degradation of the objective for up-branch */\n         d2 = psi * (ceil(beta) - beta);\n         /* determine d = max(d1, d2) */\n         d = (d1 > d2 ? d1 : d2);\n         /* choose x[j] which provides maximal estimated degradation of\n            the objective either in down- or up-branch */\n         if (dmax < d)\n         {  dmax = d;\n            jjj = j;\n            /* continue the search from a subproblem, where degradation\n               is less than in other one */\n            sel = (d1 <= d2 ? GLP_DN_BRNCH : GLP_UP_BRNCH);\n         }\n         /* display progress of pseudocost initialization */\n         if (T->parm->msg_lev >= GLP_ON)\n         {  if (xdifftime(xtime(), t) >= 10.0)\n            {  progress(T);\n               t = xtime();\n            }\n         }\n      }\n      if (dmax == 0.0)\n      {  /* no degradation is indicated; choose a variable having most\n            fractional value */\n         jjj = branch_mostf(T, &sel);\n      }\ndone: *_next = sel;\n      return jjj;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpios11.c": {
    "fcmp": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int CDECL fcmp(const void *arg1, const void *arg2)\n{     const struct info *info1 = arg1, *info2 = arg2;\n      if (info1->deg == 0.0 && info2->deg == 0.0)\n      {  if (info1->eff > info2->eff) return -1;\n         if (info1->eff < info2->eff) return +1;\n      }\n      else\n      {  if (info1->deg > info2->deg) return -1;\n         if (info1->deg < info2->deg) return +1;\n      }\n      return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "ios_process_cuts": [
      {
        "start_point": [
          84,
          0
        ],
        "end_point": [
          213,
          1
        ],
        "content": "void ios_process_cuts(glp_tree *T)\n{     IOSPOOL *pool;\n      IOSCUT *cut;\n      GLPAIJ *aij;\n      struct info *info;\n      int k, kk, max_cuts, len, ret, *ind;\n      double *val, *work, rhs;\n      /* the current subproblem must exist */\n      xassert(T->curr != NULL);\n      /* the pool must exist and be non-empty */\n      pool = T->local;\n      xassert(pool != NULL);\n      xassert(pool->m > 0);\n      /* allocate working arrays */\n      info = xcalloc(1+pool->m, sizeof(struct info));\n      ind = xcalloc(1+T->n, sizeof(int));\n      val = xcalloc(1+T->n, sizeof(double));\n      work = xcalloc(1+T->n, sizeof(double));\n      for (k = 1; k <= T->n; k++) work[k] = 0.0;\n      /* build the list of cuts stored in the cut pool */\n      for (k = 1; k <= pool->m; k++)\n         info[k].cut = pool->row[k], info[k].flag = 0;\n      /* estimate efficiency of all cuts in the cut pool */\n      for (k = 1; k <= pool->m; k++)\n      {  double temp, dy, dz;\n         cut = info[k].cut;\n         /* build the vector of cut coefficients and compute its\n            Euclidean norm */\n         len = 0; temp = 0.0;\n         for (aij = cut->ptr; aij != NULL; aij = aij->r_next)\n         {  xassert(1 <= aij->col->j && aij->col->j <= T->n);\n            len++, ind[len] = aij->col->j, val[len] = aij->val;\n            temp += aij->val * aij->val;\n         }\n         if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\n         /* transform the cut to express it only through non-basic\n            (auxiliary and structural) variables */\n         len = glp_transform_row(T->mip, len, ind, val);\n         /* determine change in the cut value and in the objective\n            value for the adjacent basis by simulating one step of the\n            dual simplex */\n         switch (cut->type)\n         {  case GLP_LO: rhs = cut->lb; break;\n            case GLP_UP: rhs = cut->ub; break;\n            default: xassert(cut != cut);\n         }\n         ret = _glp_analyze_row(T->mip, len, ind, val, cut->type,\n            rhs, 1e-9, NULL, NULL, NULL, NULL, &dy, &dz);\n         /* determine normalized residual and lower bound to objective\n            degradation */\n         if (ret == 0)\n         {  info[k].eff = fabs(dy) / sqrt(temp);\n            /* if some reduced costs violates (slightly) their zero\n               bounds (i.e. have wrong signs) due to round-off errors,\n               dz also may have wrong sign being close to zero */\n            if (T->mip->dir == GLP_MIN)\n            {  if (dz < 0.0) dz = 0.0;\n               info[k].deg = + dz;\n            }\n            else /* GLP_MAX */\n            {  if (dz > 0.0) dz = 0.0;\n               info[k].deg = - dz;\n            }\n         }\n         else if (ret == 1)\n         {  /* the constraint is not violated at the current point */\n            info[k].eff = info[k].deg = 0.0;\n         }\n         else if (ret == 2)\n         {  /* no dual feasible adjacent basis exists */\n            info[k].eff = 1.0;\n            info[k].deg = DBL_MAX;\n         }\n         else\n            xassert(ret != ret);\n         /* if the degradation is too small, just ignore it */\n         if (info[k].deg < 0.01) info[k].deg = 0.0;\n      }\n      /* sort the list of cuts by decreasing objective degradation and\n         then by decreasing efficacy */\n      qsort(&info[1], pool->m, sizeof(struct info), fcmp);\n      /* only first (most efficient) max_cuts in the list are qualified\n         as candidates to be added to the current subproblem */\n      max_cuts = (T->curr->level == 0 ? 90 : 10);\n      if (max_cuts > pool->m) max_cuts = pool->m;\n      /* add cuts to the current subproblem */\n#if 0\n      xprintf(\"*** adding cuts ***\\n\");\n#endif\n      for (k = 1; k <= max_cuts; k++)\n      {  int i, len;\n         /* if this cut seems to be inefficient, skip it */\n         if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;\n         /* if the angle between this cut and every other cut included\n            in the current subproblem is small, skip this cut */\n         for (kk = 1; kk < k; kk++)\n         {  if (info[kk].flag)\n            {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)\n                  break;\n            }\n         }\n         if (kk < k) continue;\n         /* add this cut to the current subproblem */\n#if 0\n         xprintf(\"eff = %g; deg = %g\\n\", info[k].eff, info[k].deg);\n#endif\n         cut = info[k].cut, info[k].flag = 1;\n         i = glp_add_rows(T->mip, 1);\n         if (cut->name != NULL)\n            glp_set_row_name(T->mip, i, cut->name);\n         xassert(T->mip->row[i]->origin == GLP_RF_CUT);\n         T->mip->row[i]->klass = cut->klass;\n         len = 0;\n         for (aij = cut->ptr; aij != NULL; aij = aij->r_next)\n            len++, ind[len] = aij->col->j, val[len] = aij->val;\n         glp_set_mat_row(T->mip, i, len, ind, val);\n         switch (cut->type)\n         {  case GLP_LO: rhs = cut->lb; break;\n            case GLP_UP: rhs = cut->ub; break;\n            default: xassert(cut != cut);\n         }\n         glp_set_row_bnds(T->mip, i, cut->type, rhs, rhs);\n      }\n      /* free working arrays */\n      xfree(info);\n      xfree(ind);\n      xfree(val);\n      xfree(work);\n      return;\n}",
        "lines": 130,
        "depth": 16,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          215,
          0
        ],
        "end_point": [
          336,
          1
        ],
        "content": "void ios_process_cuts(glp_tree *T)\n{     IOSPOOL *pool;\n      IOSCUT *cut;\n      IOSAIJ *aij;\n      struct info *info;\n      int k, kk, max_cuts, len, ret, *ind;\n      double *val, *work;\n      /* the current subproblem must exist */\n      xassert(T->curr != NULL);\n      /* the pool must exist and be non-empty */\n      pool = T->local;\n      xassert(pool != NULL);\n      xassert(pool->size > 0);\n      /* allocate working arrays */\n      info = xcalloc(1+pool->size, sizeof(struct info));\n      ind = xcalloc(1+T->n, sizeof(int));\n      val = xcalloc(1+T->n, sizeof(double));\n      work = xcalloc(1+T->n, sizeof(double));\n      for (k = 1; k <= T->n; k++) work[k] = 0.0;\n      /* build the list of cuts stored in the cut pool */\n      for (k = 0, cut = pool->head; cut != NULL; cut = cut->next)\n         k++, info[k].cut = cut, info[k].flag = 0;\n      xassert(k == pool->size);\n      /* estimate efficiency of all cuts in the cut pool */\n      for (k = 1; k <= pool->size; k++)\n      {  double temp, dy, dz;\n         cut = info[k].cut;\n         /* build the vector of cut coefficients and compute its\n            Euclidean norm */\n         len = 0; temp = 0.0;\n         for (aij = cut->ptr; aij != NULL; aij = aij->next)\n         {  xassert(1 <= aij->j && aij->j <= T->n);\n            len++, ind[len] = aij->j, val[len] = aij->val;\n            temp += aij->val * aij->val;\n         }\n         if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\n         /* transform the cut to express it only through non-basic\n            (auxiliary and structural) variables */\n         len = glp_transform_row(T->mip, len, ind, val);\n         /* determine change in the cut value and in the objective\n            value for the adjacent basis by simulating one step of the\n            dual simplex */\n         ret = _glp_analyze_row(T->mip, len, ind, val, cut->type,\n            cut->rhs, 1e-9, NULL, NULL, NULL, NULL, &dy, &dz);\n         /* determine normalized residual and lower bound to objective\n            degradation */\n         if (ret == 0)\n         {  info[k].eff = fabs(dy) / sqrt(temp);\n            /* if some reduced costs violates (slightly) their zero\n               bounds (i.e. have wrong signs) due to round-off errors,\n               dz also may have wrong sign being close to zero */\n            if (T->mip->dir == GLP_MIN)\n            {  if (dz < 0.0) dz = 0.0;\n               info[k].deg = + dz;\n            }\n            else /* GLP_MAX */\n            {  if (dz > 0.0) dz = 0.0;\n               info[k].deg = - dz;\n            }\n         }\n         else if (ret == 1)\n         {  /* the constraint is not violated at the current point */\n            info[k].eff = info[k].deg = 0.0;\n         }\n         else if (ret == 2)\n         {  /* no dual feasible adjacent basis exists */\n            info[k].eff = 1.0;\n            info[k].deg = DBL_MAX;\n         }\n         else\n            xassert(ret != ret);\n         /* if the degradation is too small, just ignore it */\n         if (info[k].deg < 0.01) info[k].deg = 0.0;\n      }\n      /* sort the list of cuts by decreasing objective degradation and\n         then by decreasing efficacy */\n      qsort(&info[1], pool->size, sizeof(struct info), fcmp);\n      /* only first (most efficient) max_cuts in the list are qualified\n         as candidates to be added to the current subproblem */\n      max_cuts = (T->curr->level == 0 ? 90 : 10);\n      if (max_cuts > pool->size) max_cuts = pool->size;\n      /* add cuts to the current subproblem */\n#if 0\n      xprintf(\"*** adding cuts ***\\n\");\n#endif\n      for (k = 1; k <= max_cuts; k++)\n      {  int i, len;\n         /* if this cut seems to be inefficient, skip it */\n         if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;\n         /* if the angle between this cut and every other cut included\n            in the current subproblem is small, skip this cut */\n         for (kk = 1; kk < k; kk++)\n         {  if (info[kk].flag)\n            {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)\n                  break;\n            }\n         }\n         if (kk < k) continue;\n         /* add this cut to the current subproblem */\n#if 0\n         xprintf(\"eff = %g; deg = %g\\n\", info[k].eff, info[k].deg);\n#endif\n         cut = info[k].cut, info[k].flag = 1;\n         i = glp_add_rows(T->mip, 1);\n         if (cut->name != NULL)\n            glp_set_row_name(T->mip, i, cut->name);\n         xassert(T->mip->row[i]->origin == GLP_RF_CUT);\n         T->mip->row[i]->klass = cut->klass;\n         len = 0;\n         for (aij = cut->ptr; aij != NULL; aij = aij->next)\n            len++, ind[len] = aij->j, val[len] = aij->val;\n         glp_set_mat_row(T->mip, i, len, ind, val);\n         xassert(cut->type == GLP_LO || cut->type == GLP_UP);\n         glp_set_row_bnds(T->mip, i, cut->type, cut->rhs, cut->rhs);\n      }\n      /* free working arrays */\n      xfree(info);\n      xfree(ind);\n      xfree(val);\n      xfree(work);\n      return;\n}",
        "lines": 122,
        "depth": 16,
        "decorators": [
          "void"
        ]
      }
    ],
    "efficacy": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static double efficacy(glp_tree *T, IOSCUT *cut)\n{     glp_prob *mip = T->mip;\n      IOSAIJ *aij;\n      double s = 0.0, t = 0.0, temp;\n      for (aij = cut->ptr; aij != NULL; aij = aij->next)\n      {  xassert(1 <= aij->j && aij->j <= mip->n);\n         s += aij->val * mip->col[aij->j]->prim;\n         t += aij->val * aij->val;\n      }\n      temp = sqrt(t);\n      if (temp < DBL_EPSILON) temp = DBL_EPSILON;\n      if (cut->type == GLP_LO)\n         temp = (s >= cut->rhs ? 0.0 : (cut->rhs - s) / temp);\n      else if (cut->type == GLP_UP)\n         temp = (s <= cut->rhs ? 0.0 : (s - cut->rhs) / temp);\n      else\n         xassert(cut != cut);\n      return temp;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "parallel": [
      {
        "start_point": [
          397,
          0
        ],
        "end_point": [
          413,
          1
        ],
        "content": "static double parallel(IOSCUT *a, IOSCUT *b, double work[])\n{     GLPAIJ *aij;\n      double s = 0.0, sa = 0.0, sb = 0.0, temp;\n      for (aij = a->ptr; aij != NULL; aij = aij->r_next)\n      {  work[aij->col->j] = aij->val;\n         sa += aij->val * aij->val;\n      }\n      for (aij = b->ptr; aij != NULL; aij = aij->r_next)\n      {  s += work[aij->col->j] * aij->val;\n         sb += aij->val * aij->val;\n      }\n      for (aij = a->ptr; aij != NULL; aij = aij->r_next)\n         work[aij->col->j] = 0.0;\n      temp = sqrt(sa) * sqrt(sb);\n      if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\n      return s / temp;\n}",
        "lines": 17,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "double"
        ]
      },
      {
        "start_point": [
          415,
          0
        ],
        "end_point": [
          431,
          1
        ],
        "content": "static double parallel(IOSCUT *a, IOSCUT *b, double work[])\n{     IOSAIJ *aij;\n      double s = 0.0, sa = 0.0, sb = 0.0, temp;\n      for (aij = a->ptr; aij != NULL; aij = aij->next)\n      {  work[aij->j] = aij->val;\n         sa += aij->val * aij->val;\n      }\n      for (aij = b->ptr; aij != NULL; aij = aij->next)\n      {  s += work[aij->j] * aij->val;\n         sb += aij->val * aij->val;\n      }\n      for (aij = a->ptr; aij != NULL; aij = aij->next)\n         work[aij->j] = 0.0;\n      temp = sqrt(sa) * sqrt(sb);\n      if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\n      return s / temp;\n}",
        "lines": 17,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "double"
        ]
      }
    ]
  },
  "glpk/glpk-4.65/src/draft/glpios12.c": {
    "ios_choose_node": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "int ios_choose_node(glp_tree *T)\n{     int p;\n      if (T->parm->bt_tech == GLP_BT_DFS)\n      {  /* depth first search */\n         xassert(T->tail != NULL);\n         p = T->tail->p;\n      }\n      else if (T->parm->bt_tech == GLP_BT_BFS)\n      {  /* breadth first search */\n         xassert(T->head != NULL);\n         p = T->head->p;\n      }\n      else if (T->parm->bt_tech == GLP_BT_BLB)\n      {  /* select node with best local bound */\n         p = best_node(T);\n      }\n      else if (T->parm->bt_tech == GLP_BT_BPH)\n      {  if (T->mip->mip_stat == GLP_UNDEF)\n         {  /* \"most integer feasible\" subproblem */\n            p = most_feas(T);\n         }\n         else\n         {  /* best projection heuristic */\n            p = best_proj(T);\n         }\n      }\n      else\n         xassert(T != T);\n      return p;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "most_feas": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int most_feas(glp_tree *T)\n{     /* select subproblem whose parent has minimal sum of integer\n         infeasibilities */\n      IOSNPD *node;\n      int p;\n      double best;\n      p = 0, best = DBL_MAX;\n      for (node = T->head; node != NULL; node = node->next)\n      {  xassert(node->up != NULL);\n         if (best > node->up->ii_sum)\n            p = node->p, best = node->up->ii_sum;\n      }\n      return p;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "best_proj": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int best_proj(glp_tree *T)\n{     /* select subproblem using the best projection heuristic */\n      IOSNPD *root, *node;\n      int p;\n      double best, deg, obj;\n      /* the global bound must exist */\n      xassert(T->mip->mip_stat == GLP_FEAS);\n      /* obtain pointer to the root node, which must exist */\n      root = T->slot[1].node;\n      xassert(root != NULL);\n      /* deg estimates degradation of the objective function per unit\n         of the sum of integer infeasibilities */\n      xassert(root->ii_sum > 0.0);\n      deg = (T->mip->mip_obj - root->bound) / root->ii_sum;\n      /* nothing has been selected so far */\n      p = 0, best = DBL_MAX;\n      /* walk through the list of active subproblems */\n      for (node = T->head; node != NULL; node = node->next)\n      {  xassert(node->up != NULL);\n         /* obj estimates optimal objective value if the sum of integer\n            infeasibilities were zero */\n         obj = node->up->bound + deg * node->up->ii_sum;\n         if (T->mip->dir == GLP_MAX) obj = - obj;\n         /* select the subproblem which has the best estimated optimal\n            objective value */\n         if (best > obj) p = node->p, best = obj;\n      }\n      return p;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "best_node": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static int best_node(glp_tree *T)\n{     /* select subproblem with best local bound */\n      IOSNPD *node, *best = NULL;\n      double bound, eps;\n      switch (T->mip->dir)\n      {  case GLP_MIN:\n            bound = +DBL_MAX;\n            for (node = T->head; node != NULL; node = node->next)\n               if (bound > node->bound) bound = node->bound;\n            xassert(bound != +DBL_MAX);\n            eps = 1e-10 * (1.0 + fabs(bound));\n            for (node = T->head; node != NULL; node = node->next)\n            {  if (node->bound <= bound + eps)\n               {  xassert(node->up != NULL);\n                  if (best == NULL ||\n#if 1\n                  best->up->ii_sum > node->up->ii_sum) best = node;\n#else\n                  best->lp_obj > node->lp_obj) best = node;\n#endif\n               }\n            }\n            break;\n         case GLP_MAX:\n            bound = -DBL_MAX;\n            for (node = T->head; node != NULL; node = node->next)\n               if (bound < node->bound) bound = node->bound;\n            xassert(bound != -DBL_MAX);\n            eps = 1e-10 * (1.0 + fabs(bound));\n            for (node = T->head; node != NULL; node = node->next)\n            {  if (node->bound >= bound - eps)\n               {  xassert(node->up != NULL);\n                  if (best == NULL ||\n#if 1\n                  best->up->ii_sum > node->up->ii_sum) best = node;\n#else\n                  best->lp_obj < node->lp_obj) best = node;\n#endif\n               }\n            }\n            break;\n         default:\n            xassert(T != T);\n      }\n      xassert(best != NULL);\n      return best->p;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpipm.c": {
    "initialize": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "static void initialize(struct csa *csa)\n{     int m = csa->m;\n      int n = csa->n;\n      int i;\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Matrix A has %d non-zeros\\n\", csa->A_ptr[m+1]-1);\n      csa->D = xcalloc(1+n, sizeof(double));\n      /* P := I */\n      csa->P = xcalloc(1+m+m, sizeof(int));\n      for (i = 1; i <= m; i++) csa->P[i] = csa->P[m+i] = i;\n      /* S := A*A', symbolically */\n      csa->S_ptr = xcalloc(1+m+1, sizeof(int));\n      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,\n         csa->S_ptr);\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Matrix S = A*A' has %d non-zeros (upper triangle)\\n\",\n            csa->S_ptr[m+1]-1 + m);\n      /* determine P using specified ordering algorithm */\n      if (csa->parm->ord_alg == GLP_ORD_NONE)\n      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"Original ordering is being used\\n\");\n         for (i = 1; i <= m; i++)\n            csa->P[i] = csa->P[m+i] = i;\n      }\n      else if (csa->parm->ord_alg == GLP_ORD_QMD)\n      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"Minimum degree ordering (QMD)...\\n\");\n         min_degree(m, csa->S_ptr, csa->S_ind, csa->P);\n      }\n      else if (csa->parm->ord_alg == GLP_ORD_AMD)\n      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"Approximate minimum degree ordering (AMD)...\\n\");\n         amd_order1(m, csa->S_ptr, csa->S_ind, csa->P);\n      }\n      else if (csa->parm->ord_alg == GLP_ORD_SYMAMD)\n      {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"Approximate minimum degree ordering (SYMAMD)...\\n\")\n               ;\n         symamd_ord(m, csa->S_ptr, csa->S_ind, csa->P);\n      }\n      else\n         xassert(csa != csa);\n      /* S := P*A*A'*P', symbolically */\n      xfree(csa->S_ind);\n      csa->S_ind = adat_symbolic(m, n, csa->P, csa->A_ptr, csa->A_ind,\n         csa->S_ptr);\n      csa->S_val = xcalloc(csa->S_ptr[m+1], sizeof(double));\n      csa->S_diag = xcalloc(1+m, sizeof(double));\n      /* compute Cholesky factorization S = U'*U, symbolically */\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Computing Cholesky factorization S = L*L'...\\n\");\n      csa->U_ptr = xcalloc(1+m+1, sizeof(int));\n      csa->U_ind = chol_symbolic(m, csa->S_ptr, csa->S_ind, csa->U_ptr);\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Matrix L has %d non-zeros\\n\", csa->U_ptr[m+1]-1 + m);\n      csa->U_val = xcalloc(csa->U_ptr[m+1], sizeof(double));\n      csa->U_diag = xcalloc(1+m, sizeof(double));\n      csa->iter = 0;\n      csa->obj = 0.0;\n      csa->rpi = 0.0;\n      csa->rdi = 0.0;\n      csa->gap = 0.0;\n      csa->phi = 0.0;\n      csa->mu = 0.0;\n      csa->rmu = 0.0;\n      csa->rmu0 = 0.0;\n      csa->phi_min = xcalloc(1+ITER_MAX, sizeof(double));\n      csa->best_iter = 0;\n      csa->best_x = xcalloc(1+n, sizeof(double));\n      csa->best_y = xcalloc(1+m, sizeof(double));\n      csa->best_z = xcalloc(1+n, sizeof(double));\n      csa->best_obj = 0.0;\n      csa->dx_aff = xcalloc(1+n, sizeof(double));\n      csa->dy_aff = xcalloc(1+m, sizeof(double));\n      csa->dz_aff = xcalloc(1+n, sizeof(double));\n      csa->alfa_aff_p = 0.0;\n      csa->alfa_aff_d = 0.0;\n      csa->mu_aff = 0.0;\n      csa->sigma = 0.0;\n      csa->dx_cc = xcalloc(1+n, sizeof(double));\n      csa->dy_cc = xcalloc(1+m, sizeof(double));\n      csa->dz_cc = xcalloc(1+n, sizeof(double));\n      csa->dx = csa->dx_aff;\n      csa->dy = csa->dy_aff;\n      csa->dz = csa->dz_aff;\n      csa->alfa_max_p = 0.0;\n      csa->alfa_max_d = 0.0;\n      return;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "A_by_vec": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "static void A_by_vec(struct csa *csa, double x[], double y[])\n{     /* compute y = A*x */\n      int m = csa->m;\n      int *A_ptr = csa->A_ptr;\n      int *A_ind = csa->A_ind;\n      double *A_val = csa->A_val;\n      int i, t, beg, end;\n      double temp;\n      for (i = 1; i <= m; i++)\n      {  temp = 0.0;\n         beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++) temp += A_val[t] * x[A_ind[t]];\n         y[i] = temp;\n      }\n      return;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "AT_by_vec": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static void AT_by_vec(struct csa *csa, double x[], double y[])\n{     /* compute y = A'*x, where A' is transposed to A */\n      int m = csa->m;\n      int n = csa->n;\n      int *A_ptr = csa->A_ptr;\n      int *A_ind = csa->A_ind;\n      double *A_val = csa->A_val;\n      int i, j, t, beg, end;\n      double temp;\n      for (j = 1; j <= n; j++) y[j] = 0.0;\n      for (i = 1; i <= m; i++)\n      {  temp = x[i];\n         if (temp == 0.0) continue;\n         beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++) y[A_ind[t]] += A_val[t] * temp;\n      }\n      return;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decomp_NE": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void decomp_NE(struct csa *csa)\n{     adat_numeric(csa->m, csa->n, csa->P, csa->A_ptr, csa->A_ind,\n         csa->A_val, csa->D, csa->S_ptr, csa->S_ind, csa->S_val,\n         csa->S_diag);\n      chol_numeric(csa->m, csa->S_ptr, csa->S_ind, csa->S_val,\n         csa->S_diag, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag);\n      return;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "solve_NE": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "static int solve_NE(struct csa *csa, double y[])\n{     int m = csa->m;\n      int n = csa->n;\n      int *P = csa->P;\n      int i, j, ret = 0;\n      double *h, *r, *w;\n      /* save vector of right-hand sides h */\n      h = xcalloc(1+m, sizeof(double));\n      for (i = 1; i <= m; i++) h[i] = y[i];\n      /* solve normal equation system (A*D*A')*y = h */\n      /* since S = P*A*D*A'*P' = U'*U, then A*D*A' = P'*U'*U*P, so we\n         have inv(A*D*A') = P'*inv(U)*inv(U')*P */\n      /* w := P*h */\n      w = xcalloc(1+m, sizeof(double));\n      for (i = 1; i <= m; i++) w[i] = y[P[i]];\n      /* w := inv(U')*w */\n      ut_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);\n      /* w := inv(U)*w */\n      u_solve(m, csa->U_ptr, csa->U_ind, csa->U_val, csa->U_diag, w);\n      /* y := P'*w */\n      for (i = 1; i <= m; i++) y[i] = w[P[m+i]];\n      xfree(w);\n      /* compute residual vector r = A*D*A'*y - h */\n      r = xcalloc(1+m, sizeof(double));\n      /* w := A'*y */\n      w = xcalloc(1+n, sizeof(double));\n      AT_by_vec(csa, y, w);\n      /* w := D*w */\n      for (j = 1; j <= n; j++) w[j] *= csa->D[j];\n      /* r := A*w */\n      A_by_vec(csa, w, r);\n      xfree(w);\n      /* r := r - h */\n      for (i = 1; i <= m; i++) r[i] -= h[i];\n      /* check for numeric stability */\n      for (i = 1; i <= m; i++)\n      {  if (fabs(r[i]) / (1.0 + fabs(h[i])) > 1e-4)\n         {  ret = 1;\n            break;\n         }\n      }\n      xfree(h);\n      xfree(r);\n      return ret;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "solve_NS": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "static int solve_NS(struct csa *csa, double p[], double q[], double r[],\n      double dx[], double dy[], double dz[])\n{     int m = csa->m;\n      int n = csa->n;\n      double *x = csa->x;\n      double *z = csa->z;\n      int i, j, ret;\n      double *w = dx;\n      /* compute the vector of right-hand sides A*inv(Z)*(X*q-r)+p for\n         the normal equation system */\n      for (j = 1; j <= n; j++)\n         w[j] = (x[j] * q[j] - r[j]) / z[j];\n      A_by_vec(csa, w, dy);\n      for (i = 1; i <= m; i++) dy[i] += p[i];\n      /* solve the normal equation system to compute vector dy */\n      ret = solve_NE(csa, dy);\n      /* compute vectors dx and dz */\n      AT_by_vec(csa, dy, dx);\n      for (j = 1; j <= n; j++)\n      {  dx[j] = (x[j] * (dx[j] - q[j]) + r[j]) / z[j];\n         dz[j] = (r[j] - z[j] * dx[j]) / x[j];\n      }\n      return ret;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "initial_point": {
      "start_point": [
        461,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "static void initial_point(struct csa *csa)\n{     int m = csa->m;\n      int n = csa->n;\n      double *b = csa->b;\n      double *c = csa->c;\n      double *x = csa->x;\n      double *y = csa->y;\n      double *z = csa->z;\n      double *D = csa->D;\n      int i, j;\n      double dp, dd, ex, ez, xz;\n      /* factorize A*A' */\n      for (j = 1; j <= n; j++) D[j] = 1.0;\n      decomp_NE(csa);\n      /* x~ = A'*inv(A*A')*b */\n      for (i = 1; i <= m; i++) y[i] = b[i];\n      solve_NE(csa, y);\n      AT_by_vec(csa, y, x);\n      /* y~ = inv(A*A')*A*c */\n      A_by_vec(csa, c, y);\n      solve_NE(csa, y);\n      /* z~ = c - A'*y~ */\n      AT_by_vec(csa, y,z);\n      for (j = 1; j <= n; j++) z[j] = c[j] - z[j];\n      /* use Mehrotra's heuristic in order to choose more appropriate\n         starting point with positive components of vectors x and z */\n      dp = dd = 0.0;\n      for (j = 1; j <= n; j++)\n      {  if (dp < -1.5 * x[j]) dp = -1.5 * x[j];\n         if (dd < -1.5 * z[j]) dd = -1.5 * z[j];\n      }\n      /* note that b = 0 involves x = 0, and c = 0 involves y = 0 and\n         z = 0, so we need to be careful */\n      if (dp == 0.0) dp = 1.5;\n      if (dd == 0.0) dd = 1.5;\n      ex = ez = xz = 0.0;\n      for (j = 1; j <= n; j++)\n      {  ex += (x[j] + dp);\n         ez += (z[j] + dd);\n         xz += (x[j] + dp) * (z[j] + dd);\n      }\n      dp += 0.5 * (xz / ez);\n      dd += 0.5 * (xz / ex);\n      for (j = 1; j <= n; j++)\n      {  x[j] += dp;\n         z[j] += dd;\n         xassert(x[j] > 0.0 && z[j] > 0.0);\n      }\n      return;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "basic_info": {
      "start_point": [
        550,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static void basic_info(struct csa *csa)\n{     int m = csa->m;\n      int n = csa->n;\n      double *b = csa->b;\n      double *c = csa->c;\n      double *x = csa->x;\n      double *y = csa->y;\n      double *z = csa->z;\n      int i, j;\n      double norm1, bnorm, norm2, cnorm, cx, by, *work, temp;\n      /* compute value of the objective function */\n      temp = c[0];\n      for (j = 1; j <= n; j++) temp += c[j] * x[j];\n      csa->obj = temp;\n      /* norm1 = ||A*x-b|| */\n      work = xcalloc(1+m, sizeof(double));\n      A_by_vec(csa, x, work);\n      norm1 = 0.0;\n      for (i = 1; i <= m; i++)\n         norm1 += (work[i] - b[i]) * (work[i] - b[i]);\n      norm1 = sqrt(norm1);\n      xfree(work);\n      /* bnorm = ||b|| */\n      bnorm = 0.0;\n      for (i = 1; i <= m; i++) bnorm += b[i] * b[i];\n      bnorm = sqrt(bnorm);\n      /* compute relative primal infeasibility */\n      csa->rpi = norm1 / (1.0 + bnorm);\n      /* norm2 = ||A'*y+z-c|| */\n      work = xcalloc(1+n, sizeof(double));\n      AT_by_vec(csa, y, work);\n      norm2 = 0.0;\n      for (j = 1; j <= n; j++)\n         norm2 += (work[j] + z[j] - c[j]) * (work[j] + z[j] - c[j]);\n      norm2 = sqrt(norm2);\n      xfree(work);\n      /* cnorm = ||c|| */\n      cnorm = 0.0;\n      for (j = 1; j <= n; j++) cnorm += c[j] * c[j];\n      cnorm = sqrt(cnorm);\n      /* compute relative dual infeasibility */\n      csa->rdi = norm2 / (1.0 + cnorm);\n      /* by = b'*y */\n      by = 0.0;\n      for (i = 1; i <= m; i++) by += b[i] * y[i];\n      /* cx = c'*x */\n      cx = 0.0;\n      for (j = 1; j <= n; j++) cx += c[j] * x[j];\n      /* compute primal-dual gap */\n      csa->gap = fabs(cx - by) / (1.0 + fabs(cx));\n      /* compute merit function */\n      csa->phi = 0.0;\n      csa->phi += norm1 / (bnorm > 1.0 ? bnorm : 1.0);\n      csa->phi += norm2 / (cnorm > 1.0 ? cnorm : 1.0);\n      temp = 1.0;\n      if (temp < bnorm) temp = bnorm;\n      if (temp < cnorm) temp = cnorm;\n      csa->phi += fabs(cx - by) / temp;\n      /* compute duality measure */\n      temp = 0.0;\n      for (j = 1; j <= n; j++) temp += x[j] * z[j];\n      csa->mu = temp / (double)n;\n      /* compute the ratio of infeasibility to mu */\n      csa->rmu = (norm1 > norm2 ? norm1 : norm2) / csa->mu;\n      return;\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "make_step": {
      "start_point": [
        692,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "static int make_step(struct csa *csa)\n{     int m = csa->m;\n      int n = csa->n;\n      double *b = csa->b;\n      double *c = csa->c;\n      double *x = csa->x;\n      double *y = csa->y;\n      double *z = csa->z;\n      double *dx_aff = csa->dx_aff;\n      double *dy_aff = csa->dy_aff;\n      double *dz_aff = csa->dz_aff;\n      double *dx_cc = csa->dx_cc;\n      double *dy_cc = csa->dy_cc;\n      double *dz_cc = csa->dz_cc;\n      double *dx = csa->dx;\n      double *dy = csa->dy;\n      double *dz = csa->dz;\n      int i, j, ret = 0;\n      double temp, gamma_p, gamma_d, *p, *q, *r;\n      /* allocate working arrays */\n      p = xcalloc(1+m, sizeof(double));\n      q = xcalloc(1+n, sizeof(double));\n      r = xcalloc(1+n, sizeof(double));\n      /* p = b - A*x */\n      A_by_vec(csa, x, p);\n      for (i = 1; i <= m; i++) p[i] = b[i] - p[i];\n      /* q = c - A'*y - z */\n      AT_by_vec(csa, y,q);\n      for (j = 1; j <= n; j++) q[j] = c[j] - q[j] - z[j];\n      /* r = - X * Z * e */\n      for (j = 1; j <= n; j++) r[j] = - x[j] * z[j];\n      /* solve the first Newtonian system */\n      if (solve_NS(csa, p, q, r, dx_aff, dy_aff, dz_aff))\n      {  ret = 1;\n         goto done;\n      }\n      /* alfa_aff_p = inf{0 <= alfa <= 1 | x + alfa*dx_aff >= 0} */\n      /* alfa_aff_d = inf{0 <= alfa <= 1 | z + alfa*dz_aff >= 0} */\n      csa->alfa_aff_p = csa->alfa_aff_d = 1.0;\n      for (j = 1; j <= n; j++)\n      {  if (dx_aff[j] < 0.0)\n         {  temp = - x[j] / dx_aff[j];\n            if (csa->alfa_aff_p > temp) csa->alfa_aff_p = temp;\n         }\n         if (dz_aff[j] < 0.0)\n         {  temp = - z[j] / dz_aff[j];\n            if (csa->alfa_aff_d > temp) csa->alfa_aff_d = temp;\n         }\n      }\n      /* mu_aff = (x+alfa_aff_p*dx_aff)' * (z+alfa_aff_d*dz_aff) / n */\n      temp = 0.0;\n      for (j = 1; j <= n; j++)\n         temp += (x[j] + csa->alfa_aff_p * dx_aff[j]) *\n                 (z[j] + csa->alfa_aff_d * dz_aff[j]);\n      csa->mu_aff = temp / (double)n;\n      /* sigma = (mu_aff/mu)^3 */\n      temp = csa->mu_aff / csa->mu;\n      csa->sigma = temp * temp * temp;\n      /* p = 0 */\n      for (i = 1; i <= m; i++) p[i] = 0.0;\n      /* q = 0 */\n      for (j = 1; j <= n; j++) q[j] = 0.0;\n      /* r = sigma * mu * e - X * Z * e */\n      for (j = 1; j <= n; j++)\n         r[j] = csa->sigma * csa->mu - dx_aff[j] * dz_aff[j];\n      /* solve the second Newtonian system with the same coefficients\n         but with altered right-hand sides */\n      if (solve_NS(csa, p, q, r, dx_cc, dy_cc, dz_cc))\n      {  ret = 1;\n         goto done;\n      }\n      /* (dx,dy,dz) = (dx_aff,dy_aff,dz_aff) + (dx_cc,dy_cc,dz_cc) */\n      for (j = 1; j <= n; j++) dx[j] = dx_aff[j] + dx_cc[j];\n      for (i = 1; i <= m; i++) dy[i] = dy_aff[i] + dy_cc[i];\n      for (j = 1; j <= n; j++) dz[j] = dz_aff[j] + dz_cc[j];\n      /* alfa_max_p = inf{0 <= alfa <= 1 | x + alfa*dx >= 0} */\n      /* alfa_max_d = inf{0 <= alfa <= 1 | z + alfa*dz >= 0} */\n      csa->alfa_max_p = csa->alfa_max_d = 1.0;\n      for (j = 1; j <= n; j++)\n      {  if (dx[j] < 0.0)\n         {  temp = - x[j] / dx[j];\n            if (csa->alfa_max_p > temp) csa->alfa_max_p = temp;\n         }\n         if (dz[j] < 0.0)\n         {  temp = - z[j] / dz[j];\n            if (csa->alfa_max_d > temp) csa->alfa_max_d = temp;\n         }\n      }\n      /* determine scale factors (not implemented yet) */\n      gamma_p = 0.90;\n      gamma_d = 0.90;\n      /* compute the next point */\n      for (j = 1; j <= n; j++)\n      {  x[j] += gamma_p * csa->alfa_max_p * dx[j];\n         xassert(x[j] > 0.0);\n      }\n      for (i = 1; i <= m; i++)\n         y[i] += gamma_d * csa->alfa_max_d * dy[i];\n      for (j = 1; j <= n; j++)\n      {  z[j] += gamma_d * csa->alfa_max_d * dz[j];\n         xassert(z[j] > 0.0);\n      }\ndone: /* free working arrays */\n      xfree(p);\n      xfree(q);\n      xfree(r);\n      return ret;\n}",
      "lines": 108,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "terminate": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "static void terminate(struct csa *csa)\n{     xfree(csa->D);\n      xfree(csa->P);\n      xfree(csa->S_ptr);\n      xfree(csa->S_ind);\n      xfree(csa->S_val);\n      xfree(csa->S_diag);\n      xfree(csa->U_ptr);\n      xfree(csa->U_ind);\n      xfree(csa->U_val);\n      xfree(csa->U_diag);\n      xfree(csa->phi_min);\n      xfree(csa->best_x);\n      xfree(csa->best_y);\n      xfree(csa->best_z);\n      xfree(csa->dx_aff);\n      xfree(csa->dy_aff);\n      xfree(csa->dz_aff);\n      xfree(csa->dx_cc);\n      xfree(csa->dy_cc);\n      xfree(csa->dz_cc);\n      return;\n}",
      "lines": 23,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ipm_main": {
      "start_point": [
        847,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "static int ipm_main(struct csa *csa)\n{     int m = csa->m;\n      int n = csa->n;\n      int i, j, status;\n      double temp;\n      /* choose initial point using Mehrotra's heuristic */\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Guessing initial point...\\n\");\n      initial_point(csa);\n      /* main loop starts here */\n      if (csa->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Optimization begins...\\n\");\n      for (;;)\n      {  /* perform basic computations at the current point */\n         basic_info(csa);\n         /* save initial value of rmu */\n         if (csa->iter == 0) csa->rmu0 = csa->rmu;\n         /* accumulate values of min(phi[k]) and save the best point */\n         xassert(csa->iter <= ITER_MAX);\n         if (csa->iter == 0 || csa->phi_min[csa->iter-1] > csa->phi)\n         {  csa->phi_min[csa->iter] = csa->phi;\n            csa->best_iter = csa->iter;\n            for (j = 1; j <= n; j++) csa->best_x[j] = csa->x[j];\n            for (i = 1; i <= m; i++) csa->best_y[i] = csa->y[i];\n            for (j = 1; j <= n; j++) csa->best_z[j] = csa->z[j];\n            csa->best_obj = csa->obj;\n         }\n         else\n            csa->phi_min[csa->iter] = csa->phi_min[csa->iter-1];\n         /* display information at the current point */\n         if (csa->parm->msg_lev >= GLP_MSG_ON)\n            xprintf(\"%3d: obj = %17.9e; rpi = %8.1e; rdi = %8.1e; gap =\"\n               \" %8.1e\\n\", csa->iter, csa->obj, csa->rpi, csa->rdi,\n               csa->gap);\n         /* check if the current point is optimal */\n         if (csa->rpi < 1e-8 && csa->rdi < 1e-8 && csa->gap < 1e-8)\n         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"OPTIMAL SOLUTION FOUND\\n\");\n            status = 0;\n            break;\n         }\n         /* check if the problem has no feasible solution */\n         temp = 1e5 * csa->phi_min[csa->iter];\n         if (temp < 1e-8) temp = 1e-8;\n         if (csa->phi >= temp)\n         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"PROBLEM HAS NO FEASIBLE PRIMAL/DUAL SOLUTION\\n\")\n                  ;\n            status = 1;\n            break;\n         }\n         /* check for very slow convergence or divergence */\n         if (((csa->rpi >= 1e-8 || csa->rdi >= 1e-8) && csa->rmu /\n               csa->rmu0 >= 1e6) ||\n               (csa->iter >= 30 && csa->phi_min[csa->iter] >= 0.5 *\n               csa->phi_min[csa->iter - 30]))\n         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"NO CONVERGENCE; SEARCH TERMINATED\\n\");\n            status = 2;\n            break;\n         }\n         /* check for maximal number of iterations */\n         if (csa->iter == ITER_MAX)\n         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\\n\");\n            status = 3;\n            break;\n         }\n         /* start the next iteration */\n         csa->iter++;\n         /* factorize normal equation system */\n         for (j = 1; j <= n; j++) csa->D[j] = csa->x[j] / csa->z[j];\n         decomp_NE(csa);\n         /* compute the next point using Mehrotra's predictor-corrector\n            technique */\n         if (make_step(csa))\n         {  if (csa->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"NUMERIC INSTABILITY; SEARCH TERMINATED\\n\");\n            status = 4;\n            break;\n         }\n      }\n      /* restore the best point */\n      if (status != 0)\n      {  for (j = 1; j <= n; j++) csa->x[j] = csa->best_x[j];\n         for (i = 1; i <= m; i++) csa->y[i] = csa->best_y[i];\n         for (j = 1; j <= n; j++) csa->z[j] = csa->best_z[j];\n         if (csa->parm->msg_lev >= GLP_MSG_ALL)\n            xprintf(\"Best point %17.9e was reached on iteration %d\\n\",\n               csa->best_obj, csa->best_iter);\n      }\n      /* return to the calling program */\n      return status;\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ipm_solve": {
      "start_point": [
        1023,
        0
      ],
      "end_point": [
        1141,
        1
      ],
      "content": "int ipm_solve(glp_prob *P, const glp_iptcp *parm)\n{     struct csa _dsa, *csa = &_dsa;\n      int m = P->m;\n      int n = P->n;\n      int nnz = P->nnz;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int i, j, loc, ret, *A_ind, *A_ptr;\n      double dir, *A_val, *b, *c, *x, *y, *z;\n      xassert(m > 0);\n      xassert(n > 0);\n      /* allocate working arrays */\n      A_ptr = xcalloc(1+m+1, sizeof(int));\n      A_ind = xcalloc(1+nnz, sizeof(int));\n      A_val = xcalloc(1+nnz, sizeof(double));\n      b = xcalloc(1+m, sizeof(double));\n      c = xcalloc(1+n, sizeof(double));\n      x = xcalloc(1+n, sizeof(double));\n      y = xcalloc(1+m, sizeof(double));\n      z = xcalloc(1+n, sizeof(double));\n      /* prepare rows and constraint coefficients */\n      loc = 1;\n      for (i = 1; i <= m; i++)\n      {  row = P->row[i];\n         xassert(row->type == GLP_FX);\n         b[i] = row->lb * row->rii;\n         A_ptr[i] = loc;\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  A_ind[loc] = aij->col->j;\n            A_val[loc] = row->rii * aij->val * aij->col->sjj;\n            loc++;\n         }\n      }\n      A_ptr[m+1] = loc;\n      xassert(loc-1 == nnz);\n      /* prepare columns and objective coefficients */\n      if (P->dir == GLP_MIN)\n         dir = +1.0;\n      else if (P->dir == GLP_MAX)\n         dir = -1.0;\n      else\n         xassert(P != P);\n      c[0] = dir * P->c0;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         xassert(col->type == GLP_LO && col->lb == 0.0);\n         c[j] = dir * col->coef * col->sjj;\n      }\n      /* allocate and initialize the common storage area */\n      csa->m = m;\n      csa->n = n;\n      csa->A_ptr = A_ptr;\n      csa->A_ind = A_ind;\n      csa->A_val = A_val;\n      csa->b = b;\n      csa->c = c;\n      csa->x = x;\n      csa->y = y;\n      csa->z = z;\n      csa->parm = parm;\n      initialize(csa);\n      /* solve LP with the interior-point method */\n      ret = ipm_main(csa);\n      /* deallocate the common storage area */\n      terminate(csa);\n      /* determine solution status */\n      if (ret == 0)\n      {  /* optimal solution found */\n         P->ipt_stat = GLP_OPT;\n         ret = 0;\n      }\n      else if (ret == 1)\n      {  /* problem has no feasible (primal or dual) solution */\n         P->ipt_stat = GLP_NOFEAS;\n         ret = 0;\n      }\n      else if (ret == 2)\n      {  /* no convergence */\n         P->ipt_stat = GLP_INFEAS;\n         ret = GLP_ENOCVG;\n      }\n      else if (ret == 3)\n      {  /* iteration limit exceeded */\n         P->ipt_stat = GLP_INFEAS;\n         ret = GLP_EITLIM;\n      }\n      else if (ret == 4)\n      {  /* numeric instability on solving Newtonian system */\n         P->ipt_stat = GLP_INFEAS;\n         ret = GLP_EINSTAB;\n      }\n      else\n         xassert(ret != ret);\n      /* store row solution components */\n      for (i = 1; i <= m; i++)\n      {  row = P->row[i];\n         row->pval = row->lb;\n         row->dval = dir * y[i] * row->rii;\n      }\n      /* store column solution components */\n      P->ipt_obj = P->c0;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         col->pval = x[j] * col->sjj;\n         col->dval = dir * z[j] / col->sjj;\n         P->ipt_obj += col->coef * col->pval;\n      }\n      /* free working arrays */\n      xfree(A_ptr);\n      xfree(A_ind);\n      xfree(A_val);\n      xfree(b);\n      xfree(c);\n      xfree(x);\n      xfree(y);\n      xfree(z);\n      return ret;\n}",
      "lines": 119,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpipm.h": {},
  "glpk/glpk-4.65/src/draft/glpmat.c": {
    "check_fvs": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int check_fvs(int n, int nnz, int ind[], double vec[])\n{     int i, t, ret, *flag = NULL;\n      /* check the number of elements */\n      if (n < 0)\n      {  ret = 1;\n         goto done;\n      }\n      /* check the number of non-zero elements */\n      if (nnz < 0)\n      {  ret = 2;\n         goto done;\n      }\n      /* check vector indices */\n      flag = xcalloc(1+n, sizeof(int));\n      for (i = 1; i <= n; i++) flag[i] = 0;\n      for (t = 1; t <= nnz; t++)\n      {  i = ind[t];\n         if (!(1 <= i && i <= n))\n         {  ret = 3;\n            goto done;\n         }\n         if (flag[i])\n         {  ret = 4;\n            goto done;\n         }\n         flag[i] = 1;\n      }\n      /* check vector elements */\n      for (i = 1; i <= n; i++)\n      {  if (!flag[i] && vec[i] != 0.0)\n         {  ret = 5;\n            goto done;\n         }\n      }\n      /* the vector is ok */\n      ret = 0;\ndone: if (flag != NULL) xfree(flag);\n      return ret;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "check_pattern": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "int check_pattern(int m, int n, int A_ptr[], int A_ind[])\n{     int i, j, ptr, ret, *flag = NULL;\n      /* check the number of rows */\n      if (m < 0)\n      {  ret = 1;\n         goto done;\n      }\n      /* check the number of columns */\n      if (n < 0)\n      {  ret = 2;\n         goto done;\n      }\n      /* check location A_ptr[1] */\n      if (A_ptr[1] != 1)\n      {  ret = 3;\n         goto done;\n      }\n      /* check row patterns */\n      flag = xcalloc(1+n, sizeof(int));\n      for (j = 1; j <= n; j++) flag[j] = 0;\n      for (i = 1; i <= m; i++)\n      {  /* check pattern of row i */\n         for (ptr = A_ptr[i]; ptr < A_ptr[i+1]; ptr++)\n         {  j = A_ind[ptr];\n            /* check column index */\n            if (!(1 <= j && j <= n))\n            {  ret = 4;\n               goto done;\n            }\n            /* check for duplication */\n            if (flag[j])\n            {  ret = 5;\n               goto done;\n            }\n            flag[j] = 1;\n         }\n         /* clear flags */\n         for (ptr = A_ptr[i]; ptr < A_ptr[i+1]; ptr++)\n         {  j = A_ind[ptr];\n            flag[j] = 0;\n         }\n      }\n      /* the pattern is ok */\n      ret = 0;\ndone: if (flag != NULL) xfree(flag);\n      return ret;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "transpose": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void transpose(int m, int n, int A_ptr[], int A_ind[], double A_val[],\n      int AT_ptr[], int AT_ind[], double AT_val[])\n{     int i, j, t, beg, end, pos, len;\n      /* determine row lengths of resultant matrix */\n      for (j = 1; j <= n; j++) AT_ptr[j] = 0;\n      for (i = 1; i <= m; i++)\n      {  beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++) AT_ptr[A_ind[t]]++;\n      }\n      /* set up row pointers of resultant matrix */\n      pos = 1;\n      for (j = 1; j <= n; j++)\n         len = AT_ptr[j], pos += len, AT_ptr[j] = pos;\n      AT_ptr[n+1] = pos;\n      /* build resultant matrix */\n      for (i = m; i >= 1; i--)\n      {  beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++)\n         {  pos = --AT_ptr[A_ind[t]];\n            AT_ind[pos] = i;\n            if (A_val != NULL) AT_val[pos] = A_val[t];\n         }\n      }\n      return;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "adat_symbolic": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "int *adat_symbolic(int m, int n, int P_per[], int A_ptr[], int A_ind[],\n      int S_ptr[])\n{     int i, j, t, ii, jj, tt, k, size, len;\n      int *S_ind, *AT_ptr, *AT_ind, *ind, *map, *temp;\n      /* build the pattern of A', which is a matrix transposed to A, to\n         efficiently access A in column-wise manner */\n      AT_ptr = xcalloc(1+n+1, sizeof(int));\n      AT_ind = xcalloc(A_ptr[m+1], sizeof(int));\n      transpose(m, n, A_ptr, A_ind, NULL, AT_ptr, AT_ind, NULL);\n      /* allocate the array S_ind */\n      size = A_ptr[m+1] - 1;\n      if (size < m) size = m;\n      S_ind = xcalloc(1+size, sizeof(int));\n      /* allocate and initialize working arrays */\n      ind = xcalloc(1+m, sizeof(int));\n      map = xcalloc(1+m, sizeof(int));\n      for (jj = 1; jj <= m; jj++) map[jj] = 0;\n      /* compute pattern of S; note that symbolically S = B*B', where\n         B = P*A, B' is matrix transposed to B */\n      S_ptr[1] = 1;\n      for (ii = 1; ii <= m; ii++)\n      {  /* compute pattern of ii-th row of S */\n         len = 0;\n         i = P_per[ii]; /* i-th row of A = ii-th row of B */\n         for (t = A_ptr[i]; t < A_ptr[i+1]; t++)\n         {  k = A_ind[t];\n            /* walk through k-th column of A */\n            for (tt = AT_ptr[k]; tt < AT_ptr[k+1]; tt++)\n            {  j = AT_ind[tt];\n               jj = P_per[m+j]; /* j-th row of A = jj-th row of B */\n               /* a[i,k] != 0 and a[j,k] != 0 ergo s[ii,jj] != 0 */\n               if (ii < jj && !map[jj]) ind[++len] = jj, map[jj] = 1;\n            }\n         }\n         /* now (ind) is pattern of ii-th row of S */\n         S_ptr[ii+1] = S_ptr[ii] + len;\n         /* at least (S_ptr[ii+1] - 1) locations should be available in\n            the array S_ind */\n         if (S_ptr[ii+1] - 1 > size)\n         {  temp = S_ind;\n            size += size;\n            S_ind = xcalloc(1+size, sizeof(int));\n            memcpy(&S_ind[1], &temp[1], (S_ptr[ii] - 1) * sizeof(int));\n            xfree(temp);\n         }\n         xassert(S_ptr[ii+1] - 1 <= size);\n         /* (ii-th row of S) := (ind) */\n         memcpy(&S_ind[S_ptr[ii]], &ind[1], len * sizeof(int));\n         /* clear the row pattern map */\n         for (t = 1; t <= len; t++) map[ind[t]] = 0;\n      }\n      /* free working arrays */\n      xfree(AT_ptr);\n      xfree(AT_ind);\n      xfree(ind);\n      xfree(map);\n      /* reallocate the array S_ind to free unused locations */\n      temp = S_ind;\n      size = S_ptr[m+1] - 1;\n      S_ind = xcalloc(1+size, sizeof(int));\n      memcpy(&S_ind[1], &temp[1], size * sizeof(int));\n      xfree(temp);\n      return S_ind;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "int",
        "*adat_symbolic(int m, int n, int P_per[], int A_ptr[], int A_ind[],\n      int S_ptr[])",
        "*"
      ]
    },
    "adat_numeric": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "void adat_numeric(int m, int n, int P_per[],\n      int A_ptr[], int A_ind[], double A_val[], double D_diag[],\n      int S_ptr[], int S_ind[], double S_val[], double S_diag[])\n{     int i, j, t, ii, jj, tt, beg, end, beg1, end1, k;\n      double sum, *work;\n      work = xcalloc(1+n, sizeof(double));\n      for (j = 1; j <= n; j++) work[j] = 0.0;\n      /* compute S = B*D*B', where B = P*A, B' is a matrix transposed\n         to B */\n      for (ii = 1; ii <= m; ii++)\n      {  i = P_per[ii]; /* i-th row of A = ii-th row of B */\n         /* (work) := (i-th row of A) */\n         beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++)\n            work[A_ind[t]] = A_val[t];\n         /* compute ii-th row of S */\n         beg = S_ptr[ii], end = S_ptr[ii+1];\n         for (t = beg; t < end; t++)\n         {  jj = S_ind[t];\n            j = P_per[jj]; /* j-th row of A = jj-th row of B */\n            /* s[ii,jj] := sum a[i,k] * d[k,k] * a[j,k] */\n            sum = 0.0;\n            beg1 = A_ptr[j], end1 = A_ptr[j+1];\n            for (tt = beg1; tt < end1; tt++)\n            {  k = A_ind[tt];\n               sum += work[k] * D_diag[k] * A_val[tt];\n            }\n            S_val[t] = sum;\n         }\n         /* s[ii,ii] := sum a[i,k] * d[k,k] * a[i,k] */\n         sum = 0.0;\n         beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++)\n         {  k = A_ind[t];\n            sum += A_val[t] * D_diag[k] * A_val[t];\n            work[k] = 0.0;\n         }\n         S_diag[ii] = sum;\n      }\n      xfree(work);\n      return;\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "min_degree": {
      "start_point": [
        432,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "void min_degree(int n, int A_ptr[], int A_ind[], int P_per[])\n{     int i, j, ne, t, pos, len;\n      int *xadj, *adjncy, *deg, *marker, *rchset, *nbrhd, *qsize,\n         *qlink, nofsub;\n      /* determine number of non-zeros in complete pattern */\n      ne = A_ptr[n+1] - 1;\n      ne += ne;\n      /* allocate working arrays */\n      xadj = xcalloc(1+n+1, sizeof(int));\n      adjncy = xcalloc(1+ne, sizeof(int));\n      deg = xcalloc(1+n, sizeof(int));\n      marker = xcalloc(1+n, sizeof(int));\n      rchset = xcalloc(1+n, sizeof(int));\n      nbrhd = xcalloc(1+n, sizeof(int));\n      qsize = xcalloc(1+n, sizeof(int));\n      qlink = xcalloc(1+n, sizeof(int));\n      /* determine row lengths in complete pattern */\n      for (i = 1; i <= n; i++) xadj[i] = 0;\n      for (i = 1; i <= n; i++)\n      {  for (t = A_ptr[i]; t < A_ptr[i+1]; t++)\n         {  j = A_ind[t];\n            xassert(i < j && j <= n);\n            xadj[i]++, xadj[j]++;\n         }\n      }\n      /* set up row pointers for complete pattern */\n      pos = 1;\n      for (i = 1; i <= n; i++)\n         len = xadj[i], pos += len, xadj[i] = pos;\n      xadj[n+1] = pos;\n      xassert(pos - 1 == ne);\n      /* construct complete pattern */\n      for (i = 1; i <= n; i++)\n      {  for (t = A_ptr[i]; t < A_ptr[i+1]; t++)\n         {  j = A_ind[t];\n            adjncy[--xadj[i]] = j, adjncy[--xadj[j]] = i;\n         }\n      }\n      /* call the main minimimum degree ordering routine */\n      genqmd(&n, xadj, adjncy, P_per, P_per + n, deg, marker, rchset,\n         nbrhd, qsize, qlink, &nofsub);\n      /* make sure that permutation matrix P is correct */\n      for (i = 1; i <= n; i++)\n      {  j = P_per[i];\n         xassert(1 <= j && j <= n);\n         xassert(P_per[n+j] == i);\n      }\n      /* free working arrays */\n      xfree(xadj);\n      xfree(adjncy);\n      xfree(deg);\n      xfree(marker);\n      xfree(rchset);\n      xfree(nbrhd);\n      xfree(qsize);\n      xfree(qlink);\n      return;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "amd_order1": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "void amd_order1(int n, int A_ptr[], int A_ind[], int P_per[])\n{     /* approximate minimum degree ordering (AMD) */\n      int k, ret;\n      double Control[AMD_CONTROL], Info[AMD_INFO];\n      /* get the default parameters */\n      amd_defaults(Control);\n#if 0\n      /* and print them */\n      amd_control(Control);\n#endif\n      /* make all indices 0-based */\n      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]--;\n      for (k = 1; k <= n+1; k++) A_ptr[k]--;\n      /* call the ordering routine */\n      ret = amd_order(n, &A_ptr[1], &A_ind[1], &P_per[1], Control, Info)\n         ;\n#if 0\n      amd_info(Info);\n#endif\n      xassert(ret == AMD_OK || ret == AMD_OK_BUT_JUMBLED);\n      /* retsore 1-based indices */\n      for (k = 1; k <= n+1; k++) A_ptr[k]++;\n      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]++;\n      /* patch up permutation matrix */\n      memset(&P_per[n+1], 0, n * sizeof(int));\n      for (k = 1; k <= n; k++)\n      {  P_per[k]++;\n         xassert(1 <= P_per[k] && P_per[k] <= n);\n         xassert(P_per[n+P_per[k]] == 0);\n         P_per[n+P_per[k]] = k;\n      }\n      return;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "allocate": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        534,
        1
      ],
      "content": "static void *allocate(size_t n, size_t size)\n{     void *ptr;\n      ptr = xcalloc(n, size);\n      memset(ptr, 0, n * size);\n      return ptr;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*allocate(size_t n, size_t size)",
        "*"
      ]
    },
    "release": {
      "start_point": [
        536,
        0
      ],
      "end_point": [
        539,
        1
      ],
      "content": "static void release(void *ptr)\n{     xfree(ptr);\n      return;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "symamd_ord": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "void symamd_ord(int n, int A_ptr[], int A_ind[], int P_per[])\n{     /* approximate minimum degree ordering (SYMAMD) */\n      int k, ok;\n      int stats[COLAMD_STATS];\n      /* make all indices 0-based */\n      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]--;\n      for (k = 1; k <= n+1; k++) A_ptr[k]--;\n      /* call the ordering routine */\n      ok = symamd(n, &A_ind[1], &A_ptr[1], &P_per[1], NULL, stats,\n         allocate, release);\n#if 0\n      symamd_report(stats);\n#endif\n      xassert(ok);\n      /* restore 1-based indices */\n      for (k = 1; k <= n+1; k++) A_ptr[k]++;\n      for (k = 1; k < A_ptr[n+1]; k++) A_ind[k]++;\n      /* patch up permutation matrix */\n      memset(&P_per[n+1], 0, n * sizeof(int));\n      for (k = 1; k <= n; k++)\n      {  P_per[k]++;\n         xassert(1 <= P_per[k] && P_per[k] <= n);\n         xassert(P_per[n+P_per[k]] == 0);\n         P_per[n+P_per[k]] = k;\n      }\n      return;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "chol_symbolic": {
      "start_point": [
        633,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "int *chol_symbolic(int n, int A_ptr[], int A_ind[], int U_ptr[])\n{     int i, j, k, t, len, size, beg, end, min_j, *U_ind, *head, *next,\n         *ind, *map, *temp;\n      /* initially we assume that on computing the pattern of U fill-in\n         will double the number of non-zeros in A */\n      size = A_ptr[n+1] - 1;\n      if (size < n) size = n;\n      size += size;\n      U_ind = xcalloc(1+size, sizeof(int));\n      /* allocate and initialize working arrays */\n      head = xcalloc(1+n, sizeof(int));\n      for (i = 1; i <= n; i++) head[i] = 0;\n      next = xcalloc(1+n, sizeof(int));\n      ind = xcalloc(1+n, sizeof(int));\n      map = xcalloc(1+n, sizeof(int));\n      for (j = 1; j <= n; j++) map[j] = 0;\n      /* compute the pattern of matrix U */\n      U_ptr[1] = 1;\n      for (k = 1; k <= n; k++)\n      {  /* compute the pattern of k-th row of U, which is the union of\n            k-th row of A and those rows of U (among 1, ..., k-1) whose\n            leftmost non-diagonal non-zero is placed in k-th column */\n         /* (ind) := (k-th row of A) */\n         len = A_ptr[k+1] - A_ptr[k];\n         memcpy(&ind[1], &A_ind[A_ptr[k]], len * sizeof(int));\n         for (t = 1; t <= len; t++)\n         {  j = ind[t];\n            xassert(k < j && j <= n);\n            map[j] = 1;\n         }\n         /* walk through rows of U whose leftmost non-diagonal non-zero\n            is placed in k-th column */\n         for (i = head[k]; i != 0; i = next[i])\n         {  /* (ind) := (ind) union (i-th row of U) */\n            beg = U_ptr[i], end = U_ptr[i+1];\n            for (t = beg; t < end; t++)\n            {  j = U_ind[t];\n               if (j > k && !map[j]) ind[++len] = j, map[j] = 1;\n            }\n         }\n         /* now (ind) is the pattern of k-th row of U */\n         U_ptr[k+1] = U_ptr[k] + len;\n         /* at least (U_ptr[k+1] - 1) locations should be available in\n            the array U_ind */\n         if (U_ptr[k+1] - 1 > size)\n         {  temp = U_ind;\n            size += size;\n            U_ind = xcalloc(1+size, sizeof(int));\n            memcpy(&U_ind[1], &temp[1], (U_ptr[k] - 1) * sizeof(int));\n            xfree(temp);\n         }\n         xassert(U_ptr[k+1] - 1 <= size);\n         /* (k-th row of U) := (ind) */\n         memcpy(&U_ind[U_ptr[k]], &ind[1], len * sizeof(int));\n         /* determine column index of leftmost non-diagonal non-zero in\n            k-th row of U and clear the row pattern map */\n         min_j = n + 1;\n         for (t = 1; t <= len; t++)\n         {  j = ind[t], map[j] = 0;\n            if (min_j > j) min_j = j;\n         }\n         /* include k-th row into corresponding linked list */\n         if (min_j <= n) next[k] = head[min_j], head[min_j] = k;\n      }\n      /* free working arrays */\n      xfree(head);\n      xfree(next);\n      xfree(ind);\n      xfree(map);\n      /* reallocate the array U_ind to free unused locations */\n      temp = U_ind;\n      size = U_ptr[n+1] - 1;\n      U_ind = xcalloc(1+size, sizeof(int));\n      memcpy(&U_ind[1], &temp[1], size * sizeof(int));\n      xfree(temp);\n      return U_ind;\n}",
      "lines": 77,
      "depth": 15,
      "decorators": [
        "int",
        "*chol_symbolic(int n, int A_ptr[], int A_ind[], int U_ptr[])",
        "*"
      ]
    },
    "chol_numeric": {
      "start_point": [
        790,
        0
      ],
      "end_point": [
        837,
        1
      ],
      "content": "int chol_numeric(int n,\n      int A_ptr[], int A_ind[], double A_val[], double A_diag[],\n      int U_ptr[], int U_ind[], double U_val[], double U_diag[])\n{     int i, j, k, t, t1, beg, end, beg1, end1, count = 0;\n      double ukk, uki, *work;\n      work = xcalloc(1+n, sizeof(double));\n      for (j = 1; j <= n; j++) work[j] = 0.0;\n      /* U := (upper triangle of A) */\n      /* note that the upper traingle of A is a subset of U */\n      for (i = 1; i <= n; i++)\n      {  beg = A_ptr[i], end = A_ptr[i+1];\n         for (t = beg; t < end; t++)\n            j = A_ind[t], work[j] = A_val[t];\n         beg = U_ptr[i], end = U_ptr[i+1];\n         for (t = beg; t < end; t++)\n            j = U_ind[t], U_val[t] = work[j], work[j] = 0.0;\n         U_diag[i] = A_diag[i];\n      }\n      /* main elimination loop */\n      for (k = 1; k <= n; k++)\n      {  /* transform k-th row of U */\n         ukk = U_diag[k];\n         if (ukk > 0.0)\n            U_diag[k] = ukk = sqrt(ukk);\n         else\n            U_diag[k] = ukk = DBL_MAX, count++;\n         /* (work) := (transformed k-th row) */\n         beg = U_ptr[k], end = U_ptr[k+1];\n         for (t = beg; t < end; t++)\n            work[U_ind[t]] = (U_val[t] /= ukk);\n         /* transform other rows of U */\n         for (t = beg; t < end; t++)\n         {  i = U_ind[t];\n            xassert(i > k);\n            /* (i-th row) := (i-th row) - u[k,i] * (k-th row) */\n            uki = work[i];\n            beg1 = U_ptr[i], end1 = U_ptr[i+1];\n            for (t1 = beg1; t1 < end1; t1++)\n               U_val[t1] -= uki * work[U_ind[t1]];\n            U_diag[i] -= uki * uki;\n         }\n         /* (work) := 0 */\n         for (t = beg; t < end; t++)\n            work[U_ind[t]] = 0.0;\n      }\n      xfree(work);\n      return count;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "u_solve": {
      "start_point": [
        866,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "void u_solve(int n, int U_ptr[], int U_ind[], double U_val[],\n      double U_diag[], double x[])\n{     int i, t, beg, end;\n      double temp;\n      for (i = n; i >= 1; i--)\n      {  temp = x[i];\n         beg = U_ptr[i], end = U_ptr[i+1];\n         for (t = beg; t < end; t++)\n            temp -= U_val[t] * x[U_ind[t]];\n         xassert(U_diag[i] != 0.0);\n         x[i] = temp / U_diag[i];\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ut_solve": {
      "start_point": [
        908,
        0
      ],
      "end_point": [
        921,
        1
      ],
      "content": "void ut_solve(int n, int U_ptr[], int U_ind[], double U_val[],\n      double U_diag[], double x[])\n{     int i, t, beg, end;\n      double temp;\n      for (i = 1; i <= n; i++)\n      {  xassert(U_diag[i] != 0.0);\n         temp = (x[i] /= U_diag[i]);\n         if (temp == 0.0) continue;\n         beg = U_ptr[i], end = U_ptr[i+1];\n         for (t = beg; t < end; t++)\n            x[U_ind[t]] -= U_val[t] * temp;\n      }\n      return;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpmat.h": {},
  "glpk/glpk-4.65/src/draft/glprgr.c": {
    "put_byte": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static void put_byte(FILE *fp, int c)\n{     fputc(c, fp);\n      return;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "put_word": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void put_word(FILE *fp, int w)\n{     /* big endian */\n      put_byte(fp, w);\n      put_byte(fp, w >> 8);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "put_dword": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void put_dword(FILE *fp, int d)\n{     /* big endian */\n      put_word(fp, d);\n      put_word(fp, d >> 16);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rgr_write_bmp16": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int rgr_write_bmp16(const char *fname, int m, int n, const char map[])\n{     FILE *fp;\n      int offset, bmsize, i, j, b, ret = 0;\n      if (!(1 <= m && m <= 32767))\n         xfault(\"rgr_write_bmp16: m = %d; invalid height\\n\", m);\n      if (!(1 <= n && n <= 32767))\n         xfault(\"rgr_write_bmp16: n = %d; invalid width\\n\", n);\n      fp = fopen(fname, \"wb\");\n      if (fp == NULL)\n      {  xprintf(\"rgr_write_bmp16: unable to create '%s' - %s\\n\",\n#if 0 /* 29/I-2017 */\n            fname, strerror(errno));\n#else\n            fname, xstrerr(errno));\n#endif\n         ret = 1;\n         goto fini;\n      }\n      offset = 14 + 40 + 16 * 4;\n      bmsize = (4 * n + 31) / 32;\n      /* struct BMPFILEHEADER (14 bytes) */\n      /* UINT bfType */          put_byte(fp, 'B'), put_byte(fp, 'M');\n      /* DWORD bfSize */         put_dword(fp, offset + bmsize * 4);\n      /* UINT bfReserved1 */     put_word(fp, 0);\n      /* UNIT bfReserved2 */     put_word(fp, 0);\n      /* DWORD bfOffBits */      put_dword(fp, offset);\n      /* struct BMPINFOHEADER (40 bytes) */\n      /* DWORD biSize */         put_dword(fp, 40);\n      /* LONG biWidth */         put_dword(fp, n);\n      /* LONG biHeight */        put_dword(fp, m);\n      /* WORD biPlanes */        put_word(fp, 1);\n      /* WORD biBitCount */      put_word(fp, 4);\n      /* DWORD biCompression */  put_dword(fp, 0 /* BI_RGB */);\n      /* DWORD biSizeImage */    put_dword(fp, 0);\n      /* LONG biXPelsPerMeter */ put_dword(fp, 2953 /* 75 dpi */);\n      /* LONG biYPelsPerMeter */ put_dword(fp, 2953 /* 75 dpi */);\n      /* DWORD biClrUsed */      put_dword(fp, 0);\n      /* DWORD biClrImportant */ put_dword(fp, 0);\n      /* struct RGBQUAD (16 * 4 = 64 bytes) */\n      /* CGA-compatible colors: */\n      /* 0x00 = black */         put_dword(fp, 0x000000);\n      /* 0x01 = blue */          put_dword(fp, 0x000080);\n      /* 0x02 = green */         put_dword(fp, 0x008000);\n      /* 0x03 = cyan */          put_dword(fp, 0x008080);\n      /* 0x04 = red */           put_dword(fp, 0x800000);\n      /* 0x05 = magenta */       put_dword(fp, 0x800080);\n      /* 0x06 = brown */         put_dword(fp, 0x808000);\n      /* 0x07 = light gray */    put_dword(fp, 0xC0C0C0);\n      /* 0x08 = dark gray */     put_dword(fp, 0x808080);\n      /* 0x09 = bright blue */   put_dword(fp, 0x0000FF);\n      /* 0x0A = bright green */  put_dword(fp, 0x00FF00);\n      /* 0x0B = bright cyan */   put_dword(fp, 0x00FFFF);\n      /* 0x0C = bright red */    put_dword(fp, 0xFF0000);\n      /* 0x0D = bright magenta */ put_dword(fp, 0xFF00FF);\n      /* 0x0E = yellow */        put_dword(fp, 0xFFFF00);\n      /* 0x0F = white */         put_dword(fp, 0xFFFFFF);\n      /* pixel data bits */\n      b = 0;\n      for (i = m - 1; i >= 0; i--)\n      {  for (j = 0; j < ((n + 7) / 8) * 8; j++)\n         {  b <<= 4;\n            b |= (j < n ? map[i * n + j] & 15 : 0);\n            if (j & 1) put_byte(fp, b);\n         }\n      }\n      fflush(fp);\n      if (ferror(fp))\n      {  xprintf(\"rgr_write_bmp16: write error on '%s' - %s\\n\",\n#if 0 /* 29/I-2017 */\n            fname, strerror(errno));\n#else\n            fname, xstrerr(errno));\n#endif\n         ret = 1;\n      }\nfini: if (fp != NULL) fclose(fp);\n      return ret;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glprgr.h": {},
  "glpk/glpk-4.65/src/draft/glpscl.c": {
    "min_row_aij": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static double min_row_aij(glp_prob *lp, int i, int scaled)\n{     GLPAIJ *aij;\n      double min_aij, temp;\n      xassert(1 <= i && i <= lp->m);\n      min_aij = 1.0;\n      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)\n      {  temp = fabs(aij->val);\n         if (scaled) temp *= (aij->row->rii * aij->col->sjj);\n         if (aij->r_prev == NULL || min_aij > temp)\n            min_aij = temp;\n      }\n      return min_aij;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "max_row_aij": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static double max_row_aij(glp_prob *lp, int i, int scaled)\n{     GLPAIJ *aij;\n      double max_aij, temp;\n      xassert(1 <= i && i <= lp->m);\n      max_aij = 1.0;\n      for (aij = lp->row[i]->ptr; aij != NULL; aij = aij->r_next)\n      {  temp = fabs(aij->val);\n         if (scaled) temp *= (aij->row->rii * aij->col->sjj);\n         if (aij->r_prev == NULL || max_aij < temp)\n            max_aij = temp;\n      }\n      return max_aij;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "min_col_aij": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static double min_col_aij(glp_prob *lp, int j, int scaled)\n{     GLPAIJ *aij;\n      double min_aij, temp;\n      xassert(1 <= j && j <= lp->n);\n      min_aij = 1.0;\n      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)\n      {  temp = fabs(aij->val);\n         if (scaled) temp *= (aij->row->rii * aij->col->sjj);\n         if (aij->c_prev == NULL || min_aij > temp)\n            min_aij = temp;\n      }\n      return min_aij;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "max_col_aij": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static double max_col_aij(glp_prob *lp, int j, int scaled)\n{     GLPAIJ *aij;\n      double max_aij, temp;\n      xassert(1 <= j && j <= lp->n);\n      max_aij = 1.0;\n      for (aij = lp->col[j]->ptr; aij != NULL; aij = aij->c_next)\n      {  temp = fabs(aij->val);\n         if (scaled) temp *= (aij->row->rii * aij->col->sjj);\n         if (aij->c_prev == NULL || max_aij < temp)\n            max_aij = temp;\n      }\n      return max_aij;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "min_mat_aij": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static double min_mat_aij(glp_prob *lp, int scaled)\n{     int i;\n      double min_aij, temp;\n      min_aij = 1.0;\n      for (i = 1; i <= lp->m; i++)\n      {  temp = min_row_aij(lp, i, scaled);\n         if (i == 1 || min_aij > temp)\n            min_aij = temp;\n      }\n      return min_aij;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "max_mat_aij": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static double max_mat_aij(glp_prob *lp, int scaled)\n{     int i;\n      double max_aij, temp;\n      max_aij = 1.0;\n      for (i = 1; i <= lp->m; i++)\n      {  temp = max_row_aij(lp, i, scaled);\n         if (i == 1 || max_aij < temp)\n            max_aij = temp;\n      }\n      return max_aij;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "eq_scaling": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "static void eq_scaling(glp_prob *lp, int flag)\n{     int i, j, pass;\n      double temp;\n      xassert(flag == 0 || flag == 1);\n      for (pass = 0; pass <= 1; pass++)\n      {  if (pass == flag)\n         {  /* scale rows */\n            for (i = 1; i <= lp->m; i++)\n            {  temp = max_row_aij(lp, i, 1);\n               glp_set_rii(lp, i, glp_get_rii(lp, i) / temp);\n            }\n         }\n         else\n         {  /* scale columns */\n            for (j = 1; j <= lp->n; j++)\n            {  temp = max_col_aij(lp, j, 1);\n               glp_set_sjj(lp, j, glp_get_sjj(lp, j) / temp);\n            }\n         }\n      }\n      return;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gm_scaling": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "static void gm_scaling(glp_prob *lp, int flag)\n{     int i, j, pass;\n      double temp;\n      xassert(flag == 0 || flag == 1);\n      for (pass = 0; pass <= 1; pass++)\n      {  if (pass == flag)\n         {  /* scale rows */\n            for (i = 1; i <= lp->m; i++)\n            {  temp = min_row_aij(lp, i, 1) * max_row_aij(lp, i, 1);\n               glp_set_rii(lp, i, glp_get_rii(lp, i) / sqrt(temp));\n            }\n         }\n         else\n         {  /* scale columns */\n            for (j = 1; j <= lp->n; j++)\n            {  temp = min_col_aij(lp, j, 1) * max_col_aij(lp, j, 1);\n               glp_set_sjj(lp, j, glp_get_sjj(lp, j) / sqrt(temp));\n            }\n         }\n      }\n      return;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "max_row_ratio": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "static double max_row_ratio(glp_prob *lp)\n{     int i;\n      double ratio, temp;\n      ratio = 1.0;\n      for (i = 1; i <= lp->m; i++)\n      {  temp = max_row_aij(lp, i, 1) / min_row_aij(lp, i, 1);\n         if (i == 1 || ratio < temp) ratio = temp;\n      }\n      return ratio;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "max_col_ratio": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static double max_col_ratio(glp_prob *lp)\n{     int j;\n      double ratio, temp;\n      ratio = 1.0;\n      for (j = 1; j <= lp->n; j++)\n      {  temp = max_col_aij(lp, j, 1) / min_col_aij(lp, j, 1);\n         if (j == 1 || ratio < temp) ratio = temp;\n      }\n      return ratio;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "gm_iterate": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static void gm_iterate(glp_prob *lp, int it_max, double tau)\n{     int k, flag;\n      double ratio = 0.0, r_old;\n      /* if the scaling \"quality\" for rows is better than for columns,\n         the rows are scaled first; otherwise, the columns are scaled\n         first */\n      flag = (max_row_ratio(lp) > max_col_ratio(lp));\n      for (k = 1; k <= it_max; k++)\n      {  /* save the scaling \"quality\" from previous iteration */\n         r_old = ratio;\n         /* determine the current scaling \"quality\" */\n         ratio = max_mat_aij(lp, 1) / min_mat_aij(lp, 1);\n#if 0\n         xprintf(\"k = %d; ratio = %g\\n\", k, ratio);\n#endif\n         /* if improvement is not enough, terminate scaling */\n         if (k > 1 && ratio > tau * r_old) break;\n         /* otherwise, perform another iteration */\n         gm_scaling(lp, flag);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "scale_prob": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void scale_prob(glp_prob *lp, int flags)\n{     static const char *fmt =\n         \"%s: min|aij| = %10.3e  max|aij| = %10.3e  ratio = %10.3e\\n\";\n      double min_aij, max_aij, ratio;\n      xprintf(\"Scaling...\\n\");\n      /* cancel the current scaling effect */\n      glp_unscale_prob(lp);\n      /* report original scaling \"quality\" */\n      min_aij = min_mat_aij(lp, 1);\n      max_aij = max_mat_aij(lp, 1);\n      ratio = max_aij / min_aij;\n      xprintf(fmt, \" A\", min_aij, max_aij, ratio);\n      /* check if the problem is well scaled */\n      if (min_aij >= 0.10 && max_aij <= 10.0)\n      {  xprintf(\"Problem data seem to be well scaled\\n\");\n         /* skip scaling, if required */\n         if (flags & GLP_SF_SKIP) goto done;\n      }\n      /* perform iterative geometric mean scaling, if required */\n      if (flags & GLP_SF_GM)\n      {  gm_iterate(lp, 15, 0.90);\n         min_aij = min_mat_aij(lp, 1);\n         max_aij = max_mat_aij(lp, 1);\n         ratio = max_aij / min_aij;\n         xprintf(fmt, \"GM\", min_aij, max_aij, ratio);\n      }\n      /* perform equilibration scaling, if required */\n      if (flags & GLP_SF_EQ)\n      {  eq_scaling(lp, max_row_ratio(lp) > max_col_ratio(lp));\n         min_aij = min_mat_aij(lp, 1);\n         max_aij = max_mat_aij(lp, 1);\n         ratio = max_aij / min_aij;\n         xprintf(fmt, \"EQ\", min_aij, max_aij, ratio);\n      }\n      /* round scale factors to nearest power of two, if required */\n      if (flags & GLP_SF_2N)\n      {  int i, j;\n         for (i = 1; i <= lp->m; i++)\n            glp_set_rii(lp, i, round2n(glp_get_rii(lp, i)));\n         for (j = 1; j <= lp->n; j++)\n            glp_set_sjj(lp, j, round2n(glp_get_sjj(lp, j)));\n         min_aij = min_mat_aij(lp, 1);\n         max_aij = max_mat_aij(lp, 1);\n         ratio = max_aij / min_aij;\n         xprintf(fmt, \"2N\", min_aij, max_aij, ratio);\n      }\ndone: return;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_scale_prob": {
      "start_point": [
        466,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "void glp_scale_prob(glp_prob *lp, int flags)\n{     if (flags & ~(GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP |\n                    GLP_SF_AUTO))\n         xerror(\"glp_scale_prob: flags = 0x%02X; invalid scaling option\"\n            \"s\\n\", flags);\n      if (flags & GLP_SF_AUTO)\n         flags = (GLP_SF_GM | GLP_SF_EQ | GLP_SF_SKIP);\n      scale_prob(lp, flags);\n      return;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpspm.c": {
    "spm_create_mat": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "SPM *spm_create_mat(int m, int n)\n{     SPM *A;\n      xassert(0 <= m && m < INT_MAX);\n      xassert(0 <= n && n < INT_MAX);\n      A = xmalloc(sizeof(SPM));\n      A->m = m;\n      A->n = n;\n      if (m == 0 || n == 0)\n      {  A->pool = NULL;\n         A->row = NULL;\n         A->col = NULL;\n      }\n      else\n      {  int i, j;\n         A->pool = dmp_create_pool();\n         A->row = xcalloc(1+m, sizeof(SPME *));\n         for (i = 1; i <= m; i++) A->row[i] = NULL;\n         A->col = xcalloc(1+n, sizeof(SPME *));\n         for (j = 1; j <= n; j++) A->col[j] = NULL;\n      }\n      return A;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "SPM",
        "*spm_create_mat(int m, int n)",
        "*"
      ]
    },
    "spm_new_elem": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "SPME *spm_new_elem(SPM *A, int i, int j, double val)\n{     SPME *e;\n      xassert(1 <= i && i <= A->m);\n      xassert(1 <= j && j <= A->n);\n      e = dmp_get_atom(A->pool, sizeof(SPME));\n      e->i = i;\n      e->j = j;\n      e->val = val;\n      e->r_prev = NULL;\n      e->r_next = A->row[i];\n      if (e->r_next != NULL) e->r_next->r_prev = e;\n      e->c_prev = NULL;\n      e->c_next = A->col[j];\n      if (e->c_next != NULL) e->c_next->c_prev = e;\n      A->row[i] = A->col[j] = e;\n      return e;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "SPME",
        "*spm_new_elem(SPM *A, int i, int j, double val)",
        "*"
      ]
    },
    "spm_delete_mat": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void spm_delete_mat(SPM *A)\n{     /* delete sparse matrix */\n      if (A->pool != NULL) dmp_delete_pool(A->pool);\n      if (A->row != NULL) xfree(A->row);\n      if (A->col != NULL) xfree(A->col);\n      xfree(A);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spm_test_mat_e": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "SPM *spm_test_mat_e(int n, int c)\n{     SPM *A;\n      int i;\n      xassert(n >= 3 && 2 <= c && c <= n-1);\n      A = spm_create_mat(n, n);\n      for (i = 1; i <= n; i++)\n         spm_new_elem(A, i, i, 4.0);\n      for (i = 1; i <= n-1; i++)\n      {  spm_new_elem(A, i, i+1, -1.0);\n         spm_new_elem(A, i+1, i, -1.0);\n      }\n      for (i = 1; i <= n-c; i++)\n      {  spm_new_elem(A, i, i+c, -1.0);\n         spm_new_elem(A, i+c, i, -1.0);\n      }\n      return A;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "SPM",
        "*spm_test_mat_e(int n, int c)",
        "*"
      ]
    },
    "spm_test_mat_d": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "SPM *spm_test_mat_d(int n, int c)\n{     SPM *A;\n      int i, j;\n      xassert(n >= 14 && 1 <= c && c <= n-13);\n      A = spm_create_mat(n, n);\n      for (i = 1; i <= n; i++)\n         spm_new_elem(A, i, i, 1.0);\n      for (i = 1; i <= n-c; i++)\n         spm_new_elem(A, i, i+c, (double)(i+1));\n      for (i = n-c+1; i <= n; i++)\n         spm_new_elem(A, i, i-n+c, (double)(i+1));\n      for (i = 1; i <= n-c-1; i++)\n         spm_new_elem(A, i, i+c+1, (double)(-i));\n      for (i = n-c; i <= n; i++)\n         spm_new_elem(A, i, i-n+c+1, (double)(-i));\n      for (i = 1; i <= n-c-2; i++)\n         spm_new_elem(A, i, i+c+2, 16.0);\n      for (i = n-c-1; i <= n; i++)\n         spm_new_elem(A, i, i-n+c+2, 16.0);\n      for (j = 1; j <= 10; j++)\n         for (i = 1; i <= 11-j; i++)\n            spm_new_elem(A, i, n-11+i+j, 100.0 * (double)j);\n      return A;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "SPM",
        "*spm_test_mat_d(int n, int c)",
        "*"
      ]
    },
    "spm_show_mat": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "int spm_show_mat(const SPM *A, const char *fname)\n{     int m = A->m;\n      int n = A->n;\n      int i, j, k, ret;\n      char *map;\n      xprintf(\"spm_show_mat: writing matrix pattern to '%s'...\\n\",\n         fname);\n      xassert(1 <= m && m <= 32767);\n      xassert(1 <= n && n <= 32767);\n      map = xmalloc(m * n);\n      memset(map, 0x08, m * n);\n      for (i = 1; i <= m; i++)\n      {  SPME *e;\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n         {  j = e->j;\n            xassert(1 <= j && j <= n);\n            k = n * (i - 1) + (j - 1);\n            if (map[k] != 0x08)\n               map[k] = 0x0C;\n            else if (e->val > 0.0)\n               map[k] = 0x0F;\n            else if (e->val < 0.0)\n               map[k] = 0x0B;\n            else\n               map[k] = 0x0A;\n         }\n      }\n      ret = rgr_write_bmp16(fname, m, n, map);\n      xfree(map);\n      return ret;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "spm_read_hbm": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "SPM *spm_read_hbm(const char *fname)\n{     SPM *A = NULL;\n      HBM *hbm;\n      int nrow, ncol, nnzero, i, j, beg, end, ptr, *colptr, *rowind;\n      double val, *values;\n      char *mxtype;\n      hbm = hbm_read_mat(fname);\n      if (hbm == NULL)\n      {  xprintf(\"spm_read_hbm: unable to read matrix\\n\");\n         goto fini;\n      }\n      mxtype = hbm->mxtype;\n      nrow = hbm->nrow;\n      ncol = hbm->ncol;\n      nnzero = hbm->nnzero;\n      colptr = hbm->colptr;\n      rowind = hbm->rowind;\n      values = hbm->values;\n      if (!(strcmp(mxtype, \"RSA\") == 0 || strcmp(mxtype, \"PSA\") == 0 ||\n            strcmp(mxtype, \"RUA\") == 0 || strcmp(mxtype, \"PUA\") == 0 ||\n            strcmp(mxtype, \"RRA\") == 0 || strcmp(mxtype, \"PRA\") == 0))\n      {  xprintf(\"spm_read_hbm: matrix type '%s' not supported\\n\",\n            mxtype);\n         goto fini;\n      }\n      A = spm_create_mat(nrow, ncol);\n      if (mxtype[1] == 'S' || mxtype[1] == 'U')\n         xassert(nrow == ncol);\n      for (j = 1; j <= ncol; j++)\n      {  beg = colptr[j];\n         end = colptr[j+1];\n         xassert(1 <= beg && beg <= end && end <= nnzero + 1);\n         for (ptr = beg; ptr < end; ptr++)\n         {  i = rowind[ptr];\n            xassert(1 <= i && i <= nrow);\n            if (mxtype[0] == 'R')\n               val = values[ptr];\n            else\n               val = 1.0;\n            spm_new_elem(A, i, j, val);\n            if (mxtype[1] == 'S' && i != j)\n               spm_new_elem(A, j, i, val);\n         }\n      }\nfini: if (hbm != NULL) hbm_free_mat(hbm);\n      return A;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "SPM",
        "*spm_read_hbm(const char *fname)",
        "*"
      ]
    },
    "spm_count_nnz": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "int spm_count_nnz(const SPM *A)\n{     SPME *e;\n      int i, nnz = 0;\n      for (i = 1; i <= A->m; i++)\n         for (e = A->row[i]; e != NULL; e = e->r_next) nnz++;\n      return nnz;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "spm_drop_zeros": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "int spm_drop_zeros(SPM *A, double eps)\n{     SPME *e, *next;\n      int i, count = 0;\n      for (i = 1; i <= A->m; i++)\n      {  for (e = A->row[i]; e != NULL; e = next)\n         {  next = e->r_next;\n            if (e->val == 0.0 || fabs(e->val) < eps)\n            {  /* remove element from the row list */\n               if (e->r_prev == NULL)\n                  A->row[e->i] = e->r_next;\n               else\n                  e->r_prev->r_next = e->r_next;\n               if (e->r_next == NULL)\n                  ;\n               else\n                  e->r_next->r_prev = e->r_prev;\n               /* remove element from the column list */\n               if (e->c_prev == NULL)\n                  A->col[e->j] = e->c_next;\n               else\n                  e->c_prev->c_next = e->c_next;\n               if (e->c_next == NULL)\n                  ;\n               else\n                  e->c_next->c_prev = e->c_prev;\n               /* return element to the memory pool */\n               dmp_free_atom(A->pool, e, sizeof(SPME));\n               count++;\n            }\n         }\n      }\n      return count;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "spm_read_mat": [
      {
        "start_point": [
          477,
          0
        ],
        "end_point": [
          480,
          1
        ],
        "content": "SPM *spm_read_mat(const char *fname)\n{     xassert(fname != fname);\n      return NULL;\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "SPM",
          "*spm_read_mat(const char *fname)",
          "*"
        ]
      },
      {
        "start_point": [
          482,
          0
        ],
        "end_point": [
          532,
          1
        ],
        "content": "SPM *spm_read_mat(const char *fname)\n{     SPM *A = NULL;\n      PDS *pds;\n      jmp_buf jump;\n      int i, j, k, m, n, nnz, fail = 0;\n      double val;\n      xprintf(\"spm_read_mat: reading matrix from '%s'...\\n\", fname);\n      pds = pds_open_file(fname);\n      if (pds == NULL)\n      {  xprintf(\"spm_read_mat: unable to open '%s' - %s\\n\", fname,\n            strerror(errno));\n         fail = 1;\n         goto done;\n      }\n      if (setjmp(jump))\n      {  fail = 1;\n         goto done;\n      }\n      pds_set_jump(pds, jump);\n      /* number of rows, number of columns, number of non-zeros */\n      m = pds_scan_int(pds);\n      if (m < 0)\n         pds_error(pds, \"invalid number of rows\\n\");\n      n = pds_scan_int(pds);\n      if (n < 0)\n         pds_error(pds, \"invalid number of columns\\n\");\n      nnz = pds_scan_int(pds);\n      if (nnz < 0)\n         pds_error(pds, \"invalid number of non-zeros\\n\");\n      /* create matrix */\n      xprintf(\"spm_read_mat: %d rows, %d columns, %d non-zeros\\n\",\n         m, n, nnz);\n      A = spm_create_mat(m, n);\n      /* read matrix elements */\n      for (k = 1; k <= nnz; k++)\n      {  /* row index, column index, element value */\n         i = pds_scan_int(pds);\n         if (!(1 <= i && i <= m))\n            pds_error(pds, \"row index out of range\\n\");\n         j = pds_scan_int(pds);\n         if (!(1 <= j && j <= n))\n            pds_error(pds, \"column index out of range\\n\");\n         val = pds_scan_num(pds);\n         /* add new element to the matrix */\n         spm_new_elem(A, i, j, val);\n      }\n      xprintf(\"spm_read_mat: %d lines were read\\n\", pds->count);\ndone: if (pds != NULL) pds_close_file(pds);\n      if (fail && A != NULL) spm_delete_mat(A), A = NULL;\n      return A;\n}",
        "lines": 51,
        "depth": 11,
        "decorators": [
          "SPM",
          "*spm_read_mat(const char *fname)",
          "*"
        ]
      }
    ],
    "spm_write_mat": [
      {
        "start_point": [
          575,
          0
        ],
        "end_point": [
          579,
          1
        ],
        "content": "int spm_write_mat(const SPM *A, const char *fname)\n{     xassert(A != A);\n      xassert(fname != fname);\n      return 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          581,
          0
        ],
        "end_point": [
          614,
          1
        ],
        "content": "int spm_write_mat(const SPM *A, const char *fname)\n{     FILE *fp;\n      int i, nnz, ret = 0;\n      xprintf(\"spm_write_mat: writing matrix to '%s'...\\n\", fname);\n      fp = fopen(fname, \"w\");\n      if (fp == NULL)\n      {  xprintf(\"spm_write_mat: unable to create '%s' - %s\\n\", fname,\n            strerror(errno));\n         ret = 1;\n         goto done;\n      }\n      /* number of rows, number of columns, number of non-zeros */\n      nnz = spm_count_nnz(A);\n      fprintf(fp, \"%d %d %d\\n\", A->m, A->n, nnz);\n      /* walk through rows of the matrix */\n      for (i = 1; i <= A->m; i++)\n      {  SPME *e;\n         /* walk through elements of i-th row */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n         {  /* row index, column index, element value */\n            fprintf(fp, \"%d %d %.*g\\n\", e->i, e->j, DBL_DIG, e->val);\n         }\n      }\n      fflush(fp);\n      if (ferror(fp))\n      {  xprintf(\"spm_write_mat: writing error on '%s' - %s\\n\", fname,\n            strerror(errno));\n         ret = 1;\n         goto done;\n      }\n      xprintf(\"spm_write_mat: %d lines were written\\n\", 1 + nnz);\ndone: if (fp != NULL) fclose(fp);\n      return ret;\n}",
        "lines": 34,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "spm_transpose": {
      "start_point": [
        632,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "SPM *spm_transpose(const SPM *A)\n{     SPM *B;\n      int i;\n      B = spm_create_mat(A->n, A->m);\n      for (i = 1; i <= A->m; i++)\n      {  SPME *e;\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n            spm_new_elem(B, e->j, i, e->val);\n      }\n      return B;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "SPM",
        "*spm_transpose(const SPM *A)",
        "*"
      ]
    },
    "spm_add_sym": {
      "start_point": [
        644,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "SPM *spm_add_sym(const SPM *A, const SPM *B)\n{     /* add two sparse matrices (symbolic phase) */\n      SPM *C;\n      int i, j, *flag;\n      xassert(A->m == B->m);\n      xassert(A->n == B->n);\n      /* create resultant matrix */\n      C = spm_create_mat(A->m, A->n);\n      /* allocate and clear the flag array */\n      flag = xcalloc(1+C->n, sizeof(int));\n      for (j = 1; j <= C->n; j++)\n         flag[j] = 0;\n      /* compute pattern of C = A + B */\n      for (i = 1; i <= C->m; i++)\n      {  SPME *e;\n         /* at the beginning i-th row of C is empty */\n         /* (i-th row of C) := (i-th row of C) union (i-th row of A) */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n         {  /* (note that i-th row of A may have duplicate elements) */\n            j = e->j;\n            if (!flag[j])\n            {  spm_new_elem(C, i, j, 0.0);\n               flag[j] = 1;\n            }\n         }\n         /* (i-th row of C) := (i-th row of C) union (i-th row of B) */\n         for (e = B->row[i]; e != NULL; e = e->r_next)\n         {  /* (note that i-th row of B may have duplicate elements) */\n            j = e->j;\n            if (!flag[j])\n            {  spm_new_elem(C, i, j, 0.0);\n               flag[j] = 1;\n            }\n         }\n         /* reset the flag array */\n         for (e = C->row[i]; e != NULL; e = e->r_next)\n            flag[e->j] = 0;\n      }\n      /* check and deallocate the flag array */\n      for (j = 1; j <= C->n; j++)\n         xassert(!flag[j]);\n      xfree(flag);\n      return C;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "SPM",
        "*spm_add_sym(const SPM *A, const SPM *B)",
        "*"
      ]
    },
    "spm_add_num": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "void spm_add_num(SPM *C, double alfa, const SPM *A, double beta,\n      const SPM *B)\n{     /* add two sparse matrices (numeric phase) */\n      int i, j;\n      double *work;\n      /* allocate and clear the working array */\n      work = xcalloc(1+C->n, sizeof(double));\n      for (j = 1; j <= C->n; j++)\n         work[j] = 0.0;\n      /* compute matrix C = alfa * A + beta * B */\n      for (i = 1; i <= C->n; i++)\n      {  SPME *e;\n         /* work := alfa * (i-th row of A) + beta * (i-th row of B) */\n         /* (note that A and/or B may have duplicate elements) */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n            work[e->j] += alfa * e->val;\n         for (e = B->row[i]; e != NULL; e = e->r_next)\n            work[e->j] += beta * e->val;\n         /* (i-th row of C) := work, work := 0 */\n         for (e = C->row[i]; e != NULL; e = e->r_next)\n         {  j = e->j;\n            e->val = work[j];\n            work[j] = 0.0;\n         }\n      }\n      /* check and deallocate the working array */\n      for (j = 1; j <= C->n; j++)\n         xassert(work[j] == 0.0);\n      xfree(work);\n      return;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spm_add_mat": {
      "start_point": [
        721,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "SPM *spm_add_mat(double alfa, const SPM *A, double beta, const SPM *B)\n{     /* add two sparse matrices (driver routine) */\n      SPM *C;\n      C = spm_add_sym(A, B);\n      spm_add_num(C, alfa, A, beta, B);\n      return C;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "SPM",
        "*spm_add_mat(double alfa, const SPM *A, double beta, const SPM *B)",
        "*"
      ]
    },
    "spm_mul_sym": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "SPM *spm_mul_sym(const SPM *A, const SPM *B)\n{     /* multiply two sparse matrices (symbolic phase) */\n      int i, j, k, *flag;\n      SPM *C;\n      xassert(A->n == B->m);\n      /* create resultant matrix */\n      C = spm_create_mat(A->m, B->n);\n      /* allocate and clear the flag array */\n      flag = xcalloc(1+C->n, sizeof(int));\n      for (j = 1; j <= C->n; j++)\n         flag[j] = 0;\n      /* compute pattern of C = A * B */\n      for (i = 1; i <= C->m; i++)\n      {  SPME *e, *ee;\n         /* compute pattern of i-th row of C */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n         {  k = e->j;\n            for (ee = B->row[k]; ee != NULL; ee = ee->r_next)\n            {  j = ee->j;\n               /* if a[i,k] != 0 and b[k,j] != 0 then c[i,j] != 0 */\n               if (!flag[j])\n               {  /* c[i,j] does not exist, so create it */\n                  spm_new_elem(C, i, j, 0.0);\n                  flag[j] = 1;\n               }\n            }\n         }\n         /* reset the flag array */\n         for (e = C->row[i]; e != NULL; e = e->r_next)\n            flag[e->j] = 0;\n      }\n      /* check and deallocate the flag array */\n      for (j = 1; j <= C->n; j++)\n         xassert(!flag[j]);\n      xfree(flag);\n      return C;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "SPM",
        "*spm_mul_sym(const SPM *A, const SPM *B)",
        "*"
      ]
    },
    "spm_mul_num": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "void spm_mul_num(SPM *C, const SPM *A, const SPM *B)\n{     /* multiply two sparse matrices (numeric phase) */\n      int i, j;\n      double *work;\n      /* allocate and clear the working array */\n      work = xcalloc(1+A->n, sizeof(double));\n      for (j = 1; j <= A->n; j++)\n         work[j] = 0.0;\n      /* compute matrix C = A * B */\n      for (i = 1; i <= C->m; i++)\n      {  SPME *e, *ee;\n         double temp;\n         /* work := (i-th row of A) */\n         /* (note that A may have duplicate elements) */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n            work[e->j] += e->val;\n         /* compute i-th row of C */\n         for (e = C->row[i]; e != NULL; e = e->r_next)\n         {  j = e->j;\n            /* c[i,j] := work * (j-th column of B) */\n            temp = 0.0;\n            for (ee = B->col[j]; ee != NULL; ee = ee->c_next)\n               temp += work[ee->i] * ee->val;\n            e->val = temp;\n         }\n         /* reset the working array */\n         for (e = A->row[i]; e != NULL; e = e->r_next)\n            work[e->j] = 0.0;\n      }\n      /* check and deallocate the working array */\n      for (j = 1; j <= A->n; j++)\n         xassert(work[j] == 0.0);\n      xfree(work);\n      return;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spm_mul_mat": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "SPM *spm_mul_mat(const SPM *A, const SPM *B)\n{     /* multiply two sparse matrices (driver routine) */\n      SPM *C;\n      C = spm_mul_sym(A, B);\n      spm_mul_num(C, A, B);\n      return C;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "SPM",
        "*spm_mul_mat(const SPM *A, const SPM *B)",
        "*"
      ]
    },
    "spm_create_per": {
      "start_point": [
        811,
        0
      ],
      "end_point": [
        824,
        1
      ],
      "content": "PER *spm_create_per(int n)\n{     /* create permutation matrix */\n      PER *P;\n      int k;\n      xassert(n >= 0);\n      P = xmalloc(sizeof(PER));\n      P->n = n;\n      P->row = xcalloc(1+n, sizeof(int));\n      P->col = xcalloc(1+n, sizeof(int));\n      /* initially it is identity matrix */\n      for (k = 1; k <= n; k++)\n         P->row[k] = P->col[k] = k;\n      return P;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "PER",
        "*spm_create_per(int n)",
        "*"
      ]
    },
    "spm_check_per": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "void spm_check_per(PER *P)\n{     /* check permutation matrix for correctness */\n      int i, j;\n      xassert(P->n >= 0);\n      for (i = 1; i <= P->n; i++)\n      {  j = P->row[i];\n         xassert(1 <= j && j <= P->n);\n         xassert(P->col[j] == i);\n      }\n      return;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "spm_delete_per": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        844,
        1
      ],
      "content": "void spm_delete_per(PER *P)\n{     /* delete permutation matrix */\n      xfree(P->row);\n      xfree(P->col);\n      xfree(P);\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpspm.h": {},
  "glpk/glpk-4.65/src/draft/glpssx.h": {},
  "glpk/glpk-4.65/src/draft/glpssx01.c": {
    "ssx_create": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "SSX *ssx_create(int m, int n, int nnz)\n{     SSX *ssx;\n      int i, j, k;\n      if (m < 1)\n         xfault(\"ssx_create: m = %d; invalid number of rows\\n\", m);\n      if (n < 1)\n         xfault(\"ssx_create: n = %d; invalid number of columns\\n\", n);\n      if (nnz < 0)\n         xfault(\"ssx_create: nnz = %d; invalid number of non-zero const\"\n            \"raint coefficients\\n\", nnz);\n      ssx = xmalloc(sizeof(SSX));\n      ssx->m = m;\n      ssx->n = n;\n      ssx->type = xcalloc(1+m+n, sizeof(int));\n      ssx->lb = xcalloc(1+m+n, sizeof(mpq_t));\n      for (k = 1; k <= m+n; k++) mpq_init(ssx->lb[k]);\n      ssx->ub = xcalloc(1+m+n, sizeof(mpq_t));\n      for (k = 1; k <= m+n; k++) mpq_init(ssx->ub[k]);\n      ssx->coef = xcalloc(1+m+n, sizeof(mpq_t));\n      for (k = 0; k <= m+n; k++) mpq_init(ssx->coef[k]);\n      ssx->A_ptr = xcalloc(1+n+1, sizeof(int));\n      ssx->A_ptr[n+1] = nnz+1;\n      ssx->A_ind = xcalloc(1+nnz, sizeof(int));\n      ssx->A_val = xcalloc(1+nnz, sizeof(mpq_t));\n      for (k = 1; k <= nnz; k++) mpq_init(ssx->A_val[k]);\n      ssx->stat = xcalloc(1+m+n, sizeof(int));\n      ssx->Q_row = xcalloc(1+m+n, sizeof(int));\n      ssx->Q_col = xcalloc(1+m+n, sizeof(int));\n      ssx->binv = bfx_create_binv();\n      ssx->bbar = xcalloc(1+m, sizeof(mpq_t));\n      for (i = 0; i <= m; i++) mpq_init(ssx->bbar[i]);\n      ssx->pi = xcalloc(1+m, sizeof(mpq_t));\n      for (i = 1; i <= m; i++) mpq_init(ssx->pi[i]);\n      ssx->cbar = xcalloc(1+n, sizeof(mpq_t));\n      for (j = 1; j <= n; j++) mpq_init(ssx->cbar[j]);\n      ssx->rho = xcalloc(1+m, sizeof(mpq_t));\n      for (i = 1; i <= m; i++) mpq_init(ssx->rho[i]);\n      ssx->ap = xcalloc(1+n, sizeof(mpq_t));\n      for (j = 1; j <= n; j++) mpq_init(ssx->ap[j]);\n      ssx->aq = xcalloc(1+m, sizeof(mpq_t));\n      for (i = 1; i <= m; i++) mpq_init(ssx->aq[i]);\n      mpq_init(ssx->delta);\n      return ssx;\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "SSX",
        "*ssx_create(int m, int n, int nnz)",
        "*"
      ]
    },
    "basis_col": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static int basis_col(void *info, int j, int ind[], mpq_t val[])\n{     /* this auxiliary routine provides row indices and numeric values\n         of non-zero elements in j-th column of the matrix B */\n      SSX *ssx = info;\n      int m = ssx->m;\n      int n = ssx->n;\n      int *A_ptr = ssx->A_ptr;\n      int *A_ind = ssx->A_ind;\n      mpq_t *A_val = ssx->A_val;\n      int *Q_col = ssx->Q_col;\n      int k, len, ptr;\n      xassert(1 <= j && j <= m);\n      k = Q_col[j]; /* x[k] = xB[j] */\n      xassert(1 <= k && k <= m+n);\n      /* j-th column of the matrix B is k-th column of the augmented\n         constraint matrix (I | -A) */\n      if (k <= m)\n      {  /* it is a column of the unity matrix I */\n         len = 1, ind[1] = k, mpq_set_si(val[1], 1, 1);\n      }\n      else\n      {  /* it is a column of the original constraint matrix -A */\n         len = 0;\n         for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)\n         {  len++;\n            ind[len] = A_ind[ptr];\n            mpq_neg(val[len], A_val[ptr]);\n         }\n      }\n      return len;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ssx_factorize": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int ssx_factorize(SSX *ssx)\n{     int ret;\n      ret = bfx_factorize(ssx->binv, ssx->m, basis_col, ssx);\n      return ret;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "ssx_get_xNj": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void ssx_get_xNj(SSX *ssx, int j, mpq_t x)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *lb = ssx->lb;\n      mpq_t *ub = ssx->ub;\n      int *stat = ssx->stat;\n      int *Q_col = ssx->Q_col;\n      int k;\n      xassert(1 <= j && j <= n);\n      k = Q_col[m+j]; /* x[k] = xN[j] */\n      xassert(1 <= k && k <= m+n);\n      switch (stat[k])\n      {  case SSX_NL:\n            /* xN[j] is on its lower bound */\n            mpq_set(x, lb[k]); break;\n         case SSX_NU:\n            /* xN[j] is on its upper bound */\n            mpq_set(x, ub[k]); break;\n         case SSX_NF:\n            /* xN[j] is free variable */\n            mpq_set_si(x, 0, 1); break;\n         case SSX_NS:\n            /* xN[j] is fixed variable */\n            mpq_set(x, lb[k]); break;\n         default:\n            xassert(stat != stat);\n      }\n      return;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_bbar": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void ssx_eval_bbar(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *coef = ssx->coef;\n      int *A_ptr = ssx->A_ptr;\n      int *A_ind = ssx->A_ind;\n      mpq_t *A_val = ssx->A_val;\n      int *Q_col = ssx->Q_col;\n      mpq_t *bbar = ssx->bbar;\n      int i, j, k, ptr;\n      mpq_t x, temp;\n      mpq_init(x);\n      mpq_init(temp);\n      /* bbar := 0 */\n      for (i = 1; i <= m; i++)\n         mpq_set_si(bbar[i], 0, 1);\n      /* bbar := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n] */\n      for (j = 1; j <= n; j++)\n      {  ssx_get_xNj(ssx, j, x);\n         if (mpq_sgn(x) == 0) continue;\n         k = Q_col[m+j]; /* x[k] = xN[j] */\n         if (k <= m)\n         {  /* N[j] is a column of the unity matrix I */\n            mpq_sub(bbar[k], bbar[k], x);\n         }\n         else\n         {  /* N[j] is a column of the original constraint matrix -A */\n            for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)\n            {  mpq_mul(temp, A_val[ptr], x);\n               mpq_add(bbar[A_ind[ptr]], bbar[A_ind[ptr]], temp);\n            }\n         }\n      }\n      /* bbar := inv(B) * bbar */\n      bfx_ftran(ssx->binv, bbar, 0);\n#if 1\n      /* compute value of the objective function */\n      /* bbar[0] := c[0] */\n      mpq_set(bbar[0], coef[0]);\n      /* bbar[0] := bbar[0] + sum{i in B} cB[i] * xB[i] */\n      for (i = 1; i <= m; i++)\n      {  k = Q_col[i]; /* x[k] = xB[i] */\n         if (mpq_sgn(coef[k]) == 0) continue;\n         mpq_mul(temp, coef[k], bbar[i]);\n         mpq_add(bbar[0], bbar[0], temp);\n      }\n      /* bbar[0] := bbar[0] + sum{j in N} cN[j] * xN[j] */\n      for (j = 1; j <= n; j++)\n      {  k = Q_col[m+j]; /* x[k] = xN[j] */\n         if (mpq_sgn(coef[k]) == 0) continue;\n         ssx_get_xNj(ssx, j, x);\n         mpq_mul(temp, coef[k], x);\n         mpq_add(bbar[0], bbar[0], temp);\n      }\n#endif\n      mpq_clear(x);\n      mpq_clear(temp);\n      return;\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_pi": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "void ssx_eval_pi(SSX *ssx)\n{     int m = ssx->m;\n      mpq_t *coef = ssx->coef;\n      int *Q_col = ssx->Q_col;\n      mpq_t *pi = ssx->pi;\n      int i;\n      /* pi := cB */\n      for (i = 1; i <= m; i++) mpq_set(pi[i], coef[Q_col[i]]);\n      /* pi := inv(B') * cB */\n      bfx_btran(ssx->binv, pi);\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_dj": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void ssx_eval_dj(SSX *ssx, int j, mpq_t dj)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *coef = ssx->coef;\n      int *A_ptr = ssx->A_ptr;\n      int *A_ind = ssx->A_ind;\n      mpq_t *A_val = ssx->A_val;\n      int *Q_col = ssx->Q_col;\n      mpq_t *pi = ssx->pi;\n      int k, ptr, end;\n      mpq_t temp;\n      mpq_init(temp);\n      xassert(1 <= j && j <= n);\n      k = Q_col[m+j]; /* x[k] = xN[j] */\n      xassert(1 <= k && k <= m+n);\n      /* j-th column of the matrix N is k-th column of the augmented\n         constraint matrix (I | -A) */\n      if (k <= m)\n      {  /* it is a column of the unity matrix I */\n         mpq_sub(dj, coef[k], pi[k]);\n      }\n      else\n      {  /* it is a column of the original constraint matrix -A */\n         mpq_set(dj, coef[k]);\n         for (ptr = A_ptr[k-m], end = A_ptr[k-m+1]; ptr < end; ptr++)\n         {  mpq_mul(temp, A_val[ptr], pi[A_ind[ptr]]);\n            mpq_add(dj, dj, temp);\n         }\n      }\n      mpq_clear(temp);\n      return;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_cbar": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "void ssx_eval_cbar(SSX *ssx)\n{     int n = ssx->n;\n      mpq_t *cbar = ssx->cbar;\n      int j;\n      for (j = 1; j <= n; j++)\n         ssx_eval_dj(ssx, j, cbar[j]);\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_rho": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void ssx_eval_rho(SSX *ssx)\n{     int m = ssx->m;\n      int p = ssx->p;\n      mpq_t *rho = ssx->rho;\n      int i;\n      xassert(1 <= p && p <= m);\n      /* rho := 0 */\n      for (i = 1; i <= m; i++) mpq_set_si(rho[i], 0, 1);\n      /* rho := e[p] */\n      mpq_set_si(rho[p], 1, 1);\n      /* rho := inv(B') * rho */\n      bfx_btran(ssx->binv, rho);\n      return;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_row": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void ssx_eval_row(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int *A_ptr = ssx->A_ptr;\n      int *A_ind = ssx->A_ind;\n      mpq_t *A_val = ssx->A_val;\n      int *Q_col = ssx->Q_col;\n      mpq_t *rho = ssx->rho;\n      mpq_t *ap = ssx->ap;\n      int j, k, ptr;\n      mpq_t temp;\n      mpq_init(temp);\n      for (j = 1; j <= n; j++)\n      {  /* ap[j] := - N'[j] * rho (inner product) */\n         k = Q_col[m+j]; /* x[k] = xN[j] */\n         if (k <= m)\n            mpq_neg(ap[j], rho[k]);\n         else\n         {  mpq_set_si(ap[j], 0, 1);\n            for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)\n            {  mpq_mul(temp, A_val[ptr], rho[A_ind[ptr]]);\n               mpq_add(ap[j], ap[j], temp);\n            }\n         }\n      }\n      mpq_clear(temp);\n      return;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ssx_eval_col": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "void ssx_eval_col(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int *A_ptr = ssx->A_ptr;\n      int *A_ind = ssx->A_ind;\n      mpq_t *A_val = ssx->A_val;\n      int *Q_col = ssx->Q_col;\n      int q = ssx->q;\n      mpq_t *aq = ssx->aq;\n      int i, k, ptr;\n      xassert(1 <= q && q <= n);\n      /* aq := 0 */\n      for (i = 1; i <= m; i++) mpq_set_si(aq[i], 0, 1);\n      /* aq := N[q] */\n      k = Q_col[m+q]; /* x[k] = xN[q] */\n      if (k <= m)\n      {  /* N[q] is a column of the unity matrix I */\n         mpq_set_si(aq[k], 1, 1);\n      }\n      else\n      {  /* N[q] is a column of the original constraint matrix -A */\n         for (ptr = A_ptr[k-m]; ptr < A_ptr[k-m+1]; ptr++)\n            mpq_neg(aq[A_ind[ptr]], A_val[ptr]);\n      }\n      /* aq := inv(B) * aq */\n      bfx_ftran(ssx->binv, aq, 1);\n      /* aq := - aq */\n      for (i = 1; i <= m; i++) mpq_neg(aq[i], aq[i]);\n      return;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ssx_chuzc": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "void ssx_chuzc(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int dir = (ssx->dir == SSX_MIN ? +1 : -1);\n      int *Q_col = ssx->Q_col;\n      int *stat = ssx->stat;\n      mpq_t *cbar = ssx->cbar;\n      int j, k, s, q, q_dir;\n      double best, temp;\n      /* nothing is chosen so far */\n      q = 0, q_dir = 0, best = 0.0;\n      /* look through the list of non-basic variables */\n      for (j = 1; j <= n; j++)\n      {  k = Q_col[m+j]; /* x[k] = xN[j] */\n         s = dir * mpq_sgn(cbar[j]);\n         if ((stat[k] == SSX_NF || stat[k] == SSX_NL) && s < 0 ||\n             (stat[k] == SSX_NF || stat[k] == SSX_NU) && s > 0)\n         {  /* reduced cost of xN[j] indicates possible improving of\n               the objective function */\n            temp = fabs(mpq_get_d(cbar[j]));\n            xassert(temp != 0.0);\n            if (q == 0 || best < temp)\n               q = j, q_dir = - s, best = temp;\n         }\n      }\n      ssx->q = q, ssx->q_dir = q_dir;\n      return;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ssx_chuzr": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "void ssx_chuzr(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int *type = ssx->type;\n      mpq_t *lb = ssx->lb;\n      mpq_t *ub = ssx->ub;\n      int *Q_col = ssx->Q_col;\n      mpq_t *bbar = ssx->bbar;\n      int q = ssx->q;\n      mpq_t *aq = ssx->aq;\n      int q_dir = ssx->q_dir;\n      int i, k, s, t, p, p_stat;\n      mpq_t teta, temp;\n      mpq_init(teta);\n      mpq_init(temp);\n      xassert(1 <= q && q <= n);\n      xassert(q_dir == +1 || q_dir == -1);\n      /* nothing is chosen so far */\n      p = 0, p_stat = 0;\n      /* look through the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  s = q_dir * mpq_sgn(aq[i]);\n         if (s < 0)\n         {  /* xB[i] decreases */\n            k = Q_col[i]; /* x[k] = xB[i] */\n            t = type[k];\n            if (t == SSX_LO || t == SSX_DB || t == SSX_FX)\n            {  /* xB[i] has finite lower bound */\n               mpq_sub(temp, bbar[i], lb[k]);\n               mpq_div(temp, temp, aq[i]);\n               mpq_abs(temp, temp);\n               if (p == 0 || mpq_cmp(teta, temp) > 0)\n               {  p = i;\n                  p_stat = (t == SSX_FX ? SSX_NS : SSX_NL);\n                  mpq_set(teta, temp);\n               }\n            }\n         }\n         else if (s > 0)\n         {  /* xB[i] increases */\n            k = Q_col[i]; /* x[k] = xB[i] */\n            t = type[k];\n            if (t == SSX_UP || t == SSX_DB || t == SSX_FX)\n            {  /* xB[i] has finite upper bound */\n               mpq_sub(temp, bbar[i], ub[k]);\n               mpq_div(temp, temp, aq[i]);\n               mpq_abs(temp, temp);\n               if (p == 0 || mpq_cmp(teta, temp) > 0)\n               {  p = i;\n                  p_stat = (t == SSX_FX ? SSX_NS : SSX_NU);\n                  mpq_set(teta, temp);\n               }\n            }\n         }\n         /* if something has been chosen and the ratio test indicates\n            exact degeneracy, the search can be finished */\n         if (p != 0 && mpq_sgn(teta) == 0) break;\n      }\n      /* if xN[q] is double-bounded, check if it can reach its opposite\n         bound before any basic variable */\n      k = Q_col[m+q]; /* x[k] = xN[q] */\n      if (type[k] == SSX_DB)\n      {  mpq_sub(temp, ub[k], lb[k]);\n         if (p == 0 || mpq_cmp(teta, temp) > 0)\n         {  p = -1;\n            p_stat = -1;\n            mpq_set(teta, temp);\n         }\n      }\n      ssx->p = p;\n      ssx->p_stat = p_stat;\n      /* if xB[p] has been chosen, determine its actual change in the\n         adjacent basis (it has the same sign as q_dir) */\n      if (p != 0)\n      {  xassert(mpq_sgn(teta) >= 0);\n         if (q_dir > 0)\n            mpq_set(ssx->delta, teta);\n         else\n            mpq_neg(ssx->delta, teta);\n      }\n      mpq_clear(teta);\n      mpq_clear(temp);\n      return;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "ssx_update_bbar": {
      "start_point": [
        615,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "void ssx_update_bbar(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *bbar = ssx->bbar;\n      mpq_t *cbar = ssx->cbar;\n      int p = ssx->p;\n      int q = ssx->q;\n      mpq_t *aq = ssx->aq;\n      int i;\n      mpq_t temp;\n      mpq_init(temp);\n      xassert(1 <= q && q <= n);\n      if (p < 0)\n      {  /* xN[q] is double-bounded and goes to its opposite bound */\n         /* nop */;\n      }\n      else\n      {  /* xN[q] becomes xB[p] in the adjacent basis */\n         /* xB.new[p] = xN[q] + delta xN[q] */\n         xassert(1 <= p && p <= m);\n         ssx_get_xNj(ssx, q, temp);\n         mpq_add(bbar[p], temp, ssx->delta);\n      }\n      /* update values of other basic variables depending on xN[q] */\n      for (i = 1; i <= m; i++)\n      {  if (i == p) continue;\n         /* xB.new[i] = xB[i] + alfa[i,q] * delta xN[q] */\n         if (mpq_sgn(aq[i]) == 0) continue;\n         mpq_mul(temp, aq[i], ssx->delta);\n         mpq_add(bbar[i], bbar[i], temp);\n      }\n#if 1\n      /* update value of the objective function */\n      /* z.new = z + d[q] * delta xN[q] */\n      mpq_mul(temp, cbar[q], ssx->delta);\n      mpq_add(bbar[0], bbar[0], temp);\n#endif\n      mpq_clear(temp);\n      return;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ssx_update_pi": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "void ssx_update_pi(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *pi = ssx->pi;\n      mpq_t *cbar = ssx->cbar;\n      int p = ssx->p;\n      int q = ssx->q;\n      mpq_t *aq = ssx->aq;\n      mpq_t *rho = ssx->rho;\n      int i;\n      mpq_t new_dq, temp;\n      mpq_init(new_dq);\n      mpq_init(temp);\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n);\n      /* compute d[q] in the adjacent basis */\n      mpq_div(new_dq, cbar[q], aq[p]);\n      /* update the vector of simplex multipliers */\n      for (i = 1; i <= m; i++)\n      {  if (mpq_sgn(rho[i]) == 0) continue;\n         mpq_mul(temp, new_dq, rho[i]);\n         mpq_sub(pi[i], pi[i], temp);\n      }\n      mpq_clear(new_dq);\n      mpq_clear(temp);\n      return;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ssx_update_cbar": {
      "start_point": [
        696,
        0
      ],
      "end_point": [
        721,
        1
      ],
      "content": "void ssx_update_cbar(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      mpq_t *cbar = ssx->cbar;\n      int p = ssx->p;\n      int q = ssx->q;\n      mpq_t *ap = ssx->ap;\n      int j;\n      mpq_t temp;\n      mpq_init(temp);\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n);\n      /* compute d[q] in the adjacent basis */\n      /* d.new[q] = d[q] / alfa[p,q] */\n      mpq_div(cbar[q], cbar[q], ap[q]);\n      /* update reduced costs of other non-basic variables */\n      for (j = 1; j <= n; j++)\n      {  if (j == q) continue;\n         /* d.new[j] = d[j] - (alfa[p,j] / alfa[p,q]) * d[q] */\n         if (mpq_sgn(ap[j]) == 0) continue;\n         mpq_mul(temp, ap[j], cbar[q]);\n         mpq_sub(cbar[j], cbar[j], temp);\n      }\n      mpq_clear(temp);\n      return;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ssx_change_basis": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "void ssx_change_basis(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int *type = ssx->type;\n      int *stat = ssx->stat;\n      int *Q_row = ssx->Q_row;\n      int *Q_col = ssx->Q_col;\n      int p = ssx->p;\n      int q = ssx->q;\n      int p_stat = ssx->p_stat;\n      int k, kp, kq;\n      if (p < 0)\n      {  /* special case: xN[q] goes to its opposite bound */\n         xassert(1 <= q && q <= n);\n         k = Q_col[m+q]; /* x[k] = xN[q] */\n         xassert(type[k] == SSX_DB);\n         switch (stat[k])\n         {  case SSX_NL:\n               stat[k] = SSX_NU;\n               break;\n            case SSX_NU:\n               stat[k] = SSX_NL;\n               break;\n            default:\n               xassert(stat != stat);\n         }\n      }\n      else\n      {  /* xB[p] leaves the basis, xN[q] enters the basis */\n         xassert(1 <= p && p <= m);\n         xassert(1 <= q && q <= n);\n         kp = Q_col[p];   /* x[kp] = xB[p] */\n         kq = Q_col[m+q]; /* x[kq] = xN[q] */\n         /* check non-basic status of xB[p] which becomes xN[q] */\n         switch (type[kp])\n         {  case SSX_FR:\n               xassert(p_stat == SSX_NF);\n               break;\n            case SSX_LO:\n               xassert(p_stat == SSX_NL);\n               break;\n            case SSX_UP:\n               xassert(p_stat == SSX_NU);\n               break;\n            case SSX_DB:\n               xassert(p_stat == SSX_NL || p_stat == SSX_NU);\n               break;\n            case SSX_FX:\n               xassert(p_stat == SSX_NS);\n               break;\n            default:\n               xassert(type != type);\n         }\n         /* swap xB[p] and xN[q] */\n         stat[kp] = (char)p_stat, stat[kq] = SSX_BS;\n         Q_row[kp] = m+q, Q_row[kq] = p;\n         Q_col[p] = kq, Q_col[m+q] = kp;\n         /* update factorization of the basis matrix */\n         if (bfx_update(ssx->binv, p))\n         {  if (ssx_factorize(ssx))\n               xassert((\"Internal error: basis matrix is singular\", 0));\n         }\n      }\n      return;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "ssx_delete": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "void ssx_delete(SSX *ssx)\n{     int m = ssx->m;\n      int n = ssx->n;\n      int nnz = ssx->A_ptr[n+1]-1;\n      int i, j, k;\n      xfree(ssx->type);\n      for (k = 1; k <= m+n; k++) mpq_clear(ssx->lb[k]);\n      xfree(ssx->lb);\n      for (k = 1; k <= m+n; k++) mpq_clear(ssx->ub[k]);\n      xfree(ssx->ub);\n      for (k = 0; k <= m+n; k++) mpq_clear(ssx->coef[k]);\n      xfree(ssx->coef);\n      xfree(ssx->A_ptr);\n      xfree(ssx->A_ind);\n      for (k = 1; k <= nnz; k++) mpq_clear(ssx->A_val[k]);\n      xfree(ssx->A_val);\n      xfree(ssx->stat);\n      xfree(ssx->Q_row);\n      xfree(ssx->Q_col);\n      bfx_delete_binv(ssx->binv);\n      for (i = 0; i <= m; i++) mpq_clear(ssx->bbar[i]);\n      xfree(ssx->bbar);\n      for (i = 1; i <= m; i++) mpq_clear(ssx->pi[i]);\n      xfree(ssx->pi);\n      for (j = 1; j <= n; j++) mpq_clear(ssx->cbar[j]);\n      xfree(ssx->cbar);\n      for (i = 1; i <= m; i++) mpq_clear(ssx->rho[i]);\n      xfree(ssx->rho);\n      for (j = 1; j <= n; j++) mpq_clear(ssx->ap[j]);\n      xfree(ssx->ap);\n      for (i = 1; i <= m; i++) mpq_clear(ssx->aq[i]);\n      xfree(ssx->aq);\n      mpq_clear(ssx->delta);\n      xfree(ssx);\n      return;\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/glpssx02.c": {
    "show_progress": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "static void show_progress(SSX *ssx, int phase)\n{     /* this auxiliary routine displays information about progress of\n         the search */\n      int i, def = 0;\n      for (i = 1; i <= ssx->m; i++)\n         if (ssx->type[ssx->Q_col[i]] == SSX_FX) def++;\n      xprintf(\"%s%6d:   %s = %22.15g   (%d)\\n\", phase == 1 ? \" \" : \"*\",\n         ssx->it_cnt, phase == 1 ? \"infsum\" : \"objval\",\n         mpq_get_d(ssx->bbar[0]), def);\n#if 0\n      ssx->tm_lag = utime();\n#else\n      ssx->tm_lag = xtime();\n#endif\n      return;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/ios.h": {},
  "glpk/glpk-4.65/src/draft/lux.c": {
    "lux_create": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "LUX *lux_create(int n)\n{     LUX *lux;\n      int k;\n      if (n < 1)\n         xfault(\"lux_create: n = %d; invalid parameter\\n\", n);\n      lux = xmalloc(sizeof(LUX));\n      lux->n = n;\n      lux->pool = dmp_create_poolx(sizeof(LUXELM));\n      lux->F_row = xcalloc(1+n, sizeof(LUXELM *));\n      lux->F_col = xcalloc(1+n, sizeof(LUXELM *));\n      lux->V_piv = xcalloc(1+n, sizeof(mpq_t));\n      lux->V_row = xcalloc(1+n, sizeof(LUXELM *));\n      lux->V_col = xcalloc(1+n, sizeof(LUXELM *));\n      lux->P_row = xcalloc(1+n, sizeof(int));\n      lux->P_col = xcalloc(1+n, sizeof(int));\n      lux->Q_row = xcalloc(1+n, sizeof(int));\n      lux->Q_col = xcalloc(1+n, sizeof(int));\n      for (k = 1; k <= n; k++)\n      {  lux->F_row[k] = lux->F_col[k] = NULL;\n         mpq_init(lux->V_piv[k]);\n         mpq_set_si(lux->V_piv[k], 1, 1);\n         lux->V_row[k] = lux->V_col[k] = NULL;\n         lux->P_row[k] = lux->P_col[k] = k;\n         lux->Q_row[k] = lux->Q_col[k] = k;\n      }\n      lux->rank = n;\n      return lux;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "LUX",
        "*lux_create(int n)",
        "*"
      ]
    },
    "initialize": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void initialize(LUX *lux, int (*col)(void *info, int j,\n      int ind[], mpq_t val[]), void *info, LUXWKA *wka)\n{     int n = lux->n;\n      DMP *pool = lux->pool;\n      LUXELM **F_row = lux->F_row;\n      LUXELM **F_col = lux->F_col;\n      mpq_t *V_piv = lux->V_piv;\n      LUXELM **V_row = lux->V_row;\n      LUXELM **V_col = lux->V_col;\n      int *P_row = lux->P_row;\n      int *P_col = lux->P_col;\n      int *Q_row = lux->Q_row;\n      int *Q_col = lux->Q_col;\n      int *R_len = wka->R_len;\n      int *R_head = wka->R_head;\n      int *R_prev = wka->R_prev;\n      int *R_next = wka->R_next;\n      int *C_len = wka->C_len;\n      int *C_head = wka->C_head;\n      int *C_prev = wka->C_prev;\n      int *C_next = wka->C_next;\n      LUXELM *fij, *vij;\n      int i, j, k, len, *ind;\n      mpq_t *val;\n      /* F := I */\n      for (i = 1; i <= n; i++)\n      {  while (F_row[i] != NULL)\n         {  fij = F_row[i], F_row[i] = fij->r_next;\n            mpq_clear(fij->val);\n            dmp_free_atom(pool, fij, sizeof(LUXELM));\n         }\n      }\n      for (j = 1; j <= n; j++) F_col[j] = NULL;\n      /* V := 0 */\n      for (k = 1; k <= n; k++) mpq_set_si(V_piv[k], 0, 1);\n      for (i = 1; i <= n; i++)\n      {  while (V_row[i] != NULL)\n         {  vij = V_row[i], V_row[i] = vij->r_next;\n            mpq_clear(vij->val);\n            dmp_free_atom(pool, vij, sizeof(LUXELM));\n         }\n      }\n      for (j = 1; j <= n; j++) V_col[j] = NULL;\n      /* V := A */\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(mpq_t));\n      for (k = 1; k <= n; k++) mpq_init(val[k]);\n      for (j = 1; j <= n; j++)\n      {  /* obtain j-th column of matrix A */\n         len = col(info, j, ind, val);\n         if (!(0 <= len && len <= n))\n            xfault(\"lux_decomp: j = %d: len = %d; invalid column length\"\n               \"\\n\", j, len);\n         /* copy elements of j-th column to matrix V */\n         for (k = 1; k <= len; k++)\n         {  /* get row index of a[i,j] */\n            i = ind[k];\n            if (!(1 <= i && i <= n))\n               xfault(\"lux_decomp: j = %d: i = %d; row index out of ran\"\n                  \"ge\\n\", j, i);\n            /* check for duplicate indices */\n            if (V_row[i] != NULL && V_row[i]->j == j)\n               xfault(\"lux_decomp: j = %d: i = %d; duplicate row indice\"\n                  \"s not allowed\\n\", j, i);\n            /* check for zero value */\n            if (mpq_sgn(val[k]) == 0)\n               xfault(\"lux_decomp: j = %d: i = %d; zero elements not al\"\n                  \"lowed\\n\", j, i);\n            /* add new element v[i,j] = a[i,j] to V */\n            vij = dmp_get_atom(pool, sizeof(LUXELM));\n            vij->i = i, vij->j = j;\n            mpq_init(vij->val);\n            mpq_set(vij->val, val[k]);\n            vij->r_prev = NULL;\n            vij->r_next = V_row[i];\n            vij->c_prev = NULL;\n            vij->c_next = V_col[j];\n            if (vij->r_next != NULL) vij->r_next->r_prev = vij;\n            if (vij->c_next != NULL) vij->c_next->c_prev = vij;\n            V_row[i] = V_col[j] = vij;\n         }\n      }\n      xfree(ind);\n      for (k = 1; k <= n; k++) mpq_clear(val[k]);\n      xfree(val);\n      /* P := Q := I */\n      for (k = 1; k <= n; k++)\n         P_row[k] = P_col[k] = Q_row[k] = Q_col[k] = k;\n      /* the rank of A and V is not determined yet */\n      lux->rank = -1;\n      /* initially the entire matrix V is active */\n      /* determine its row lengths */\n      for (i = 1; i <= n; i++)\n      {  len = 0;\n         for (vij = V_row[i]; vij != NULL; vij = vij->r_next) len++;\n         R_len[i] = len;\n      }\n      /* build linked lists of active rows */\n      for (len = 0; len <= n; len++) R_head[len] = 0;\n      for (i = 1; i <= n; i++)\n      {  len = R_len[i];\n         R_prev[i] = 0;\n         R_next[i] = R_head[len];\n         if (R_next[i] != 0) R_prev[R_next[i]] = i;\n         R_head[len] = i;\n      }\n      /* determine its column lengths */\n      for (j = 1; j <= n; j++)\n      {  len = 0;\n         for (vij = V_col[j]; vij != NULL; vij = vij->c_next) len++;\n         C_len[j] = len;\n      }\n      /* build linked lists of active columns */\n      for (len = 0; len <= n; len++) C_head[len] = 0;\n      for (j = 1; j <= n; j++)\n      {  len = C_len[j];\n         C_prev[j] = 0;\n         C_next[j] = C_head[len];\n         if (C_next[j] != 0) C_prev[C_next[j]] = j;\n         C_head[len] = j;\n      }\n      return;\n}",
      "lines": 123,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_pivot": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "static LUXELM *find_pivot(LUX *lux, LUXWKA *wka)\n{     int n = lux->n;\n      LUXELM **V_row = lux->V_row;\n      LUXELM **V_col = lux->V_col;\n      int *R_len = wka->R_len;\n      int *R_head = wka->R_head;\n      int *R_next = wka->R_next;\n      int *C_len = wka->C_len;\n      int *C_head = wka->C_head;\n      int *C_next = wka->C_next;\n      LUXELM *piv, *some, *vij;\n      int i, j, len, min_len, ncand, piv_lim = 5;\n      double best, cost;\n      /* nothing is chosen so far */\n      piv = NULL, best = DBL_MAX, ncand = 0;\n      /* if in the active submatrix there is a column that has the only\n         non-zero (column singleton), choose it as a pivot */\n      j = C_head[1];\n      if (j != 0)\n      {  xassert(C_len[j] == 1);\n         piv = V_col[j];\n         xassert(piv != NULL && piv->c_next == NULL);\n         goto done;\n      }\n      /* if in the active submatrix there is a row that has the only\n         non-zero (row singleton), choose it as a pivot */\n      i = R_head[1];\n      if (i != 0)\n      {  xassert(R_len[i] == 1);\n         piv = V_row[i];\n         xassert(piv != NULL && piv->r_next == NULL);\n         goto done;\n      }\n      /* there are no singletons in the active submatrix; walk through\n         other non-empty rows and columns */\n      for (len = 2; len <= n; len++)\n      {  /* consider active columns having len non-zeros */\n         for (j = C_head[len]; j != 0; j = C_next[j])\n         {  /* j-th column has len non-zeros */\n            /* find an element in the row of minimal length */\n            some = NULL, min_len = INT_MAX;\n            for (vij = V_col[j]; vij != NULL; vij = vij->c_next)\n            {  if (min_len > R_len[vij->i])\n                  some = vij, min_len = R_len[vij->i];\n               /* if Markowitz cost of this element is not greater than\n                  (len-1)**2, it can be chosen right now; this heuristic\n                  reduces the search and works well in many cases */\n               if (min_len <= len)\n               {  piv = some;\n                  goto done;\n               }\n            }\n            /* j-th column has been scanned */\n            /* the minimal element found is a next pivot candidate */\n            xassert(some != NULL);\n            ncand++;\n            /* compute its Markowitz cost */\n            cost = (double)(min_len - 1) * (double)(len - 1);\n            /* choose between the current candidate and this element */\n            if (cost < best) piv = some, best = cost;\n            /* if piv_lim candidates have been considered, there is a\n               doubt that a much better candidate exists; therefore it\n               is the time to terminate the search */\n            if (ncand == piv_lim) goto done;\n         }\n         /* now consider active rows having len non-zeros */\n         for (i = R_head[len]; i != 0; i = R_next[i])\n         {  /* i-th row has len non-zeros */\n            /* find an element in the column of minimal length */\n            some = NULL, min_len = INT_MAX;\n            for (vij = V_row[i]; vij != NULL; vij = vij->r_next)\n            {  if (min_len > C_len[vij->j])\n                  some = vij, min_len = C_len[vij->j];\n               /* if Markowitz cost of this element is not greater than\n                  (len-1)**2, it can be chosen right now; this heuristic\n                  reduces the search and works well in many cases */\n               if (min_len <= len)\n               {  piv = some;\n                  goto done;\n               }\n            }\n            /* i-th row has been scanned */\n            /* the minimal element found is a next pivot candidate */\n            xassert(some != NULL);\n            ncand++;\n            /* compute its Markowitz cost */\n            cost = (double)(len - 1) * (double)(min_len - 1);\n            /* choose between the current candidate and this element */\n            if (cost < best) piv = some, best = cost;\n            /* if piv_lim candidates have been considered, there is a\n               doubt that a much better candidate exists; therefore it\n               is the time to terminate the search */\n            if (ncand == piv_lim) goto done;\n         }\n      }\ndone: /* bring the pivot v[p,q] to the factorizing routine */\n      return piv;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "LUXELM",
        "*find_pivot(LUX *lux, LUXWKA *wka)",
        "*"
      ]
    },
    "eliminate": {
      "start_point": [
        418,
        0
      ],
      "end_point": [
        662,
        1
      ],
      "content": "static void eliminate(LUX *lux, LUXWKA *wka, LUXELM *piv, int flag[],\n      mpq_t work[])\n{     DMP *pool = lux->pool;\n      LUXELM **F_row = lux->F_row;\n      LUXELM **F_col = lux->F_col;\n      mpq_t *V_piv = lux->V_piv;\n      LUXELM **V_row = lux->V_row;\n      LUXELM **V_col = lux->V_col;\n      int *R_len = wka->R_len;\n      int *R_head = wka->R_head;\n      int *R_prev = wka->R_prev;\n      int *R_next = wka->R_next;\n      int *C_len = wka->C_len;\n      int *C_head = wka->C_head;\n      int *C_prev = wka->C_prev;\n      int *C_next = wka->C_next;\n      LUXELM *fip, *vij, *vpj, *viq, *next;\n      mpq_t temp;\n      int i, j, p, q;\n      mpq_init(temp);\n      /* determine row and column indices of the pivot v[p,q] */\n      xassert(piv != NULL);\n      p = piv->i, q = piv->j;\n      /* remove p-th (pivot) row from the active set; it will never\n         return there */\n      if (R_prev[p] == 0)\n         R_head[R_len[p]] = R_next[p];\n      else\n         R_next[R_prev[p]] = R_next[p];\n      if (R_next[p] == 0)\n         ;\n      else\n         R_prev[R_next[p]] = R_prev[p];\n      /* remove q-th (pivot) column from the active set; it will never\n         return there */\n      if (C_prev[q] == 0)\n         C_head[C_len[q]] = C_next[q];\n      else\n         C_next[C_prev[q]] = C_next[q];\n      if (C_next[q] == 0)\n         ;\n      else\n         C_prev[C_next[q]] = C_prev[q];\n      /* store the pivot value in a separate array */\n      mpq_set(V_piv[p], piv->val);\n      /* remove the pivot from p-th row */\n      if (piv->r_prev == NULL)\n         V_row[p] = piv->r_next;\n      else\n         piv->r_prev->r_next = piv->r_next;\n      if (piv->r_next == NULL)\n         ;\n      else\n         piv->r_next->r_prev = piv->r_prev;\n      R_len[p]--;\n      /* remove the pivot from q-th column */\n      if (piv->c_prev == NULL)\n         V_col[q] = piv->c_next;\n      else\n         piv->c_prev->c_next = piv->c_next;\n      if (piv->c_next == NULL)\n         ;\n      else\n         piv->c_next->c_prev = piv->c_prev;\n      C_len[q]--;\n      /* free the space occupied by the pivot */\n      mpq_clear(piv->val);\n      dmp_free_atom(pool, piv, sizeof(LUXELM));\n      /* walk through p-th (pivot) row, which already does not contain\n         the pivot v[p,q], and do the following... */\n      for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)\n      {  /* get column index of v[p,j] */\n         j = vpj->j;\n         /* store v[p,j] in the working array */\n         flag[j] = 1;\n         mpq_set(work[j], vpj->val);\n         /* remove j-th column from the active set; it will return there\n            later with a new length */\n         if (C_prev[j] == 0)\n            C_head[C_len[j]] = C_next[j];\n         else\n            C_next[C_prev[j]] = C_next[j];\n         if (C_next[j] == 0)\n            ;\n         else\n            C_prev[C_next[j]] = C_prev[j];\n         /* v[p,j] leaves the active submatrix, so remove it from j-th\n            column; however, v[p,j] is kept in p-th row */\n         if (vpj->c_prev == NULL)\n            V_col[j] = vpj->c_next;\n         else\n            vpj->c_prev->c_next = vpj->c_next;\n         if (vpj->c_next == NULL)\n            ;\n         else\n            vpj->c_next->c_prev = vpj->c_prev;\n         C_len[j]--;\n      }\n      /* now walk through q-th (pivot) column, which already does not\n         contain the pivot v[p,q], and perform gaussian elimination */\n      while (V_col[q] != NULL)\n      {  /* element v[i,q] has to be eliminated */\n         viq = V_col[q];\n         /* get row index of v[i,q] */\n         i = viq->i;\n         /* remove i-th row from the active set; later it will return\n            there with a new length */\n         if (R_prev[i] == 0)\n            R_head[R_len[i]] = R_next[i];\n         else\n            R_next[R_prev[i]] = R_next[i];\n         if (R_next[i] == 0)\n            ;\n         else\n            R_prev[R_next[i]] = R_prev[i];\n         /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] and\n            store it in the matrix F */\n         fip = dmp_get_atom(pool, sizeof(LUXELM));\n         fip->i = i, fip->j = p;\n         mpq_init(fip->val);\n         mpq_div(fip->val, viq->val, V_piv[p]);\n         fip->r_prev = NULL;\n         fip->r_next = F_row[i];\n         fip->c_prev = NULL;\n         fip->c_next = F_col[p];\n         if (fip->r_next != NULL) fip->r_next->r_prev = fip;\n         if (fip->c_next != NULL) fip->c_next->c_prev = fip;\n         F_row[i] = F_col[p] = fip;\n         /* v[i,q] has to be eliminated, so remove it from i-th row */\n         if (viq->r_prev == NULL)\n            V_row[i] = viq->r_next;\n         else\n            viq->r_prev->r_next = viq->r_next;\n         if (viq->r_next == NULL)\n            ;\n         else\n            viq->r_next->r_prev = viq->r_prev;\n         R_len[i]--;\n         /* and also from q-th column */\n         V_col[q] = viq->c_next;\n         C_len[q]--;\n         /* free the space occupied by v[i,q] */\n         mpq_clear(viq->val);\n         dmp_free_atom(pool, viq, sizeof(LUXELM));\n         /* perform gaussian transformation:\n            (i-th row) := (i-th row) - f[i,p] * (p-th row)\n            note that now p-th row, which is in the working array,\n            does not contain the pivot v[p,q], and i-th row does not\n            contain the element v[i,q] to be eliminated */\n         /* walk through i-th row and transform existing non-zero\n            elements */\n         for (vij = V_row[i]; vij != NULL; vij = next)\n         {  next = vij->r_next;\n            /* get column index of v[i,j] */\n            j = vij->j;\n            /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */\n            if (flag[j])\n            {  /* v[p,j] != 0 */\n               flag[j] = 0;\n               mpq_mul(temp, fip->val, work[j]);\n               mpq_sub(vij->val, vij->val, temp);\n               if (mpq_sgn(vij->val) == 0)\n               {  /* new v[i,j] is zero, so remove it from the active\n                     submatrix */\n                  /* remove v[i,j] from i-th row */\n                  if (vij->r_prev == NULL)\n                     V_row[i] = vij->r_next;\n                  else\n                     vij->r_prev->r_next = vij->r_next;\n                  if (vij->r_next == NULL)\n                     ;\n                  else\n                     vij->r_next->r_prev = vij->r_prev;\n                  R_len[i]--;\n                  /* remove v[i,j] from j-th column */\n                  if (vij->c_prev == NULL)\n                     V_col[j] = vij->c_next;\n                  else\n                     vij->c_prev->c_next = vij->c_next;\n                  if (vij->c_next == NULL)\n                     ;\n                  else\n                     vij->c_next->c_prev = vij->c_prev;\n                  C_len[j]--;\n                  /* free the space occupied by v[i,j] */\n                  mpq_clear(vij->val);\n                  dmp_free_atom(pool, vij, sizeof(LUXELM));\n               }\n            }\n         }\n         /* now flag is the pattern of the set v[p,*] \\ v[i,*] */\n         /* walk through p-th (pivot) row and create new elements in\n            i-th row, which appear due to fill-in */\n         for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)\n         {  j = vpj->j;\n            if (flag[j])\n            {  /* create new non-zero v[i,j] = 0 - f[i,p] * v[p,j] and\n                  add it to i-th row and j-th column */\n               vij = dmp_get_atom(pool, sizeof(LUXELM));\n               vij->i = i, vij->j = j;\n               mpq_init(vij->val);\n               mpq_mul(vij->val, fip->val, work[j]);\n               mpq_neg(vij->val, vij->val);\n               vij->r_prev = NULL;\n               vij->r_next = V_row[i];\n               vij->c_prev = NULL;\n               vij->c_next = V_col[j];\n               if (vij->r_next != NULL) vij->r_next->r_prev = vij;\n               if (vij->c_next != NULL) vij->c_next->c_prev = vij;\n               V_row[i] = V_col[j] = vij;\n               R_len[i]++, C_len[j]++;\n            }\n            else\n            {  /* there is no fill-in, because v[i,j] already exists in\n                  i-th row; restore the flag, which was reset before */\n               flag[j] = 1;\n            }\n         }\n         /* now i-th row has been completely transformed and can return\n            to the active set with a new length */\n         R_prev[i] = 0;\n         R_next[i] = R_head[R_len[i]];\n         if (R_next[i] != 0) R_prev[R_next[i]] = i;\n         R_head[R_len[i]] = i;\n      }\n      /* at this point q-th (pivot) column must be empty */\n      xassert(C_len[q] == 0);\n      /* walk through p-th (pivot) row again and do the following... */\n      for (vpj = V_row[p]; vpj != NULL; vpj = vpj->r_next)\n      {  /* get column index of v[p,j] */\n         j = vpj->j;\n         /* erase v[p,j] from the working array */\n         flag[j] = 0;\n         mpq_set_si(work[j], 0, 1);\n         /* now j-th column has been completely transformed, so it can\n            return to the active list with a new length */\n         C_prev[j] = 0;\n         C_next[j] = C_head[C_len[j]];\n         if (C_next[j] != 0) C_prev[C_next[j]] = j;\n         C_head[C_len[j]] = j;\n      }\n      mpq_clear(temp);\n      /* return to the factorizing routine */\n      return;\n}",
      "lines": 245,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "lux_decomp": {
      "start_point": [
        737,
        0
      ],
      "end_point": [
        827,
        1
      ],
      "content": "int lux_decomp(LUX *lux, int (*col)(void *info, int j, int ind[],\n      mpq_t val[]), void *info)\n{     int n = lux->n;\n      LUXELM **V_row = lux->V_row;\n      LUXELM **V_col = lux->V_col;\n      int *P_row = lux->P_row;\n      int *P_col = lux->P_col;\n      int *Q_row = lux->Q_row;\n      int *Q_col = lux->Q_col;\n      LUXELM *piv, *vij;\n      LUXWKA *wka;\n      int i, j, k, p, q, t, *flag;\n      mpq_t *work;\n      /* allocate working area */\n      wka = xmalloc(sizeof(LUXWKA));\n      wka->R_len = xcalloc(1+n, sizeof(int));\n      wka->R_head = xcalloc(1+n, sizeof(int));\n      wka->R_prev = xcalloc(1+n, sizeof(int));\n      wka->R_next = xcalloc(1+n, sizeof(int));\n      wka->C_len = xcalloc(1+n, sizeof(int));\n      wka->C_head = xcalloc(1+n, sizeof(int));\n      wka->C_prev = xcalloc(1+n, sizeof(int));\n      wka->C_next = xcalloc(1+n, sizeof(int));\n      /* initialize LU-factorization data structures */\n      initialize(lux, col, info, wka);\n      /* allocate working arrays */\n      flag = xcalloc(1+n, sizeof(int));\n      work = xcalloc(1+n, sizeof(mpq_t));\n      for (k = 1; k <= n; k++)\n      {  flag[k] = 0;\n         mpq_init(work[k]);\n      }\n      /* main elimination loop */\n      for (k = 1; k <= n; k++)\n      {  /* choose a pivot element v[p,q] */\n         piv = find_pivot(lux, wka);\n         if (piv == NULL)\n         {  /* no pivot can be chosen, because the active submatrix is\n               empty */\n            break;\n         }\n         /* determine row and column indices of the pivot element */\n         p = piv->i, q = piv->j;\n         /* let v[p,q] correspond to u[i',j']; permute k-th and i'-th\n            rows and k-th and j'-th columns of the matrix U = P*V*Q to\n            move the element u[i',j'] to the position u[k,k] */\n         i = P_col[p], j = Q_row[q];\n         xassert(k <= i && i <= n && k <= j && j <= n);\n         /* permute k-th and i-th rows of the matrix U */\n         t = P_row[k];\n         P_row[i] = t, P_col[t] = i;\n         P_row[k] = p, P_col[p] = k;\n         /* permute k-th and j-th columns of the matrix U */\n         t = Q_col[k];\n         Q_col[j] = t, Q_row[t] = j;\n         Q_col[k] = q, Q_row[q] = k;\n         /* eliminate subdiagonal elements of k-th column of the matrix\n            U = P*V*Q using the pivot element u[k,k] = v[p,q] */\n         eliminate(lux, wka, piv, flag, work);\n      }\n      /* determine the rank of A (and V) */\n      lux->rank = k - 1;\n      /* free working arrays */\n      xfree(flag);\n      for (k = 1; k <= n; k++) mpq_clear(work[k]);\n      xfree(work);\n      /* build column lists of the matrix V using its row lists */\n      for (j = 1; j <= n; j++)\n         xassert(V_col[j] == NULL);\n      for (i = 1; i <= n; i++)\n      {  for (vij = V_row[i]; vij != NULL; vij = vij->r_next)\n         {  j = vij->j;\n            vij->c_prev = NULL;\n            vij->c_next = V_col[j];\n            if (vij->c_next != NULL) vij->c_next->c_prev = vij;\n            V_col[j] = vij;\n         }\n      }\n      /* free working area */\n      xfree(wka->R_len);\n      xfree(wka->R_head);\n      xfree(wka->R_prev);\n      xfree(wka->R_next);\n      xfree(wka->C_len);\n      xfree(wka->C_head);\n      xfree(wka->C_prev);\n      xfree(wka->C_next);\n      xfree(wka);\n      /* return to the calling program */\n      return (lux->rank < n);\n}",
      "lines": 91,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "lux_f_solve": {
      "start_point": [
        849,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "void lux_f_solve(LUX *lux, int tr, mpq_t x[])\n{     int n = lux->n;\n      LUXELM **F_row = lux->F_row;\n      LUXELM **F_col = lux->F_col;\n      int *P_row = lux->P_row;\n      LUXELM *fik, *fkj;\n      int i, j, k;\n      mpq_t temp;\n      mpq_init(temp);\n      if (!tr)\n      {  /* solve the system F*x = b */\n         for (j = 1; j <= n; j++)\n         {  k = P_row[j];\n            if (mpq_sgn(x[k]) != 0)\n            {  for (fik = F_col[k]; fik != NULL; fik = fik->c_next)\n               {  mpq_mul(temp, fik->val, x[k]);\n                  mpq_sub(x[fik->i], x[fik->i], temp);\n               }\n            }\n         }\n      }\n      else\n      {  /* solve the system F'*x = b */\n         for (i = n; i >= 1; i--)\n         {  k = P_row[i];\n            if (mpq_sgn(x[k]) != 0)\n            {  for (fkj = F_row[k]; fkj != NULL; fkj = fkj->r_next)\n               {  mpq_mul(temp, fkj->val, x[k]);\n                  mpq_sub(x[fkj->j], x[fkj->j], temp);\n               }\n            }\n         }\n      }\n      mpq_clear(temp);\n      return;\n}",
      "lines": 36,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "lux_v_solve": {
      "start_point": [
        906,
        0
      ],
      "end_point": [
        952,
        1
      ],
      "content": "void lux_v_solve(LUX *lux, int tr, mpq_t x[])\n{     int n = lux->n;\n      mpq_t *V_piv = lux->V_piv;\n      LUXELM **V_row = lux->V_row;\n      LUXELM **V_col = lux->V_col;\n      int *P_row = lux->P_row;\n      int *Q_col = lux->Q_col;\n      LUXELM *vij;\n      int i, j, k;\n      mpq_t *b, temp;\n      b = xcalloc(1+n, sizeof(mpq_t));\n      for (k = 1; k <= n; k++)\n         mpq_init(b[k]), mpq_set(b[k], x[k]), mpq_set_si(x[k], 0, 1);\n      mpq_init(temp);\n      if (!tr)\n      {  /* solve the system V*x = b */\n         for (k = n; k >= 1; k--)\n         {  i = P_row[k], j = Q_col[k];\n            if (mpq_sgn(b[i]) != 0)\n            {  mpq_set(x[j], b[i]);\n               mpq_div(x[j], x[j], V_piv[i]);\n               for (vij = V_col[j]; vij != NULL; vij = vij->c_next)\n               {  mpq_mul(temp, vij->val, x[j]);\n                  mpq_sub(b[vij->i], b[vij->i], temp);\n               }\n            }\n         }\n      }\n      else\n      {  /* solve the system V'*x = b */\n         for (k = 1; k <= n; k++)\n         {  i = P_row[k], j = Q_col[k];\n            if (mpq_sgn(b[j]) != 0)\n            {  mpq_set(x[i], b[j]);\n               mpq_div(x[i], x[i], V_piv[i]);\n               for (vij = V_row[i]; vij != NULL; vij = vij->r_next)\n               {  mpq_mul(temp, vij->val, x[i]);\n                  mpq_sub(b[vij->j], b[vij->j], temp);\n               }\n            }\n         }\n      }\n      for (k = 1; k <= n; k++) mpq_clear(b[k]);\n      mpq_clear(temp);\n      xfree(b);\n      return;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "lux_solve": {
      "start_point": [
        974,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "void lux_solve(LUX *lux, int tr, mpq_t x[])\n{     if (lux->rank < lux->n)\n         xfault(\"lux_solve: LU-factorization has incomplete rank\\n\");\n      if (!tr)\n      {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */\n         lux_f_solve(lux, 0, x);\n         lux_v_solve(lux, 0, x);\n      }\n      else\n      {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */\n         lux_v_solve(lux, 1, x);\n         lux_f_solve(lux, 1, x);\n      }\n      return;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "lux_delete": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1027,
        1
      ],
      "content": "void lux_delete(LUX *lux)\n{     int n = lux->n;\n      LUXELM *fij, *vij;\n      int i;\n      for (i = 1; i <= n; i++)\n      {  for (fij = lux->F_row[i]; fij != NULL; fij = fij->r_next)\n            mpq_clear(fij->val);\n         mpq_clear(lux->V_piv[i]);\n         for (vij = lux->V_row[i]; vij != NULL; vij = vij->r_next)\n            mpq_clear(vij->val);\n      }\n      dmp_delete_pool(lux->pool);\n      xfree(lux->F_row);\n      xfree(lux->F_col);\n      xfree(lux->V_piv);\n      xfree(lux->V_row);\n      xfree(lux->V_col);\n      xfree(lux->P_row);\n      xfree(lux->P_col);\n      xfree(lux->Q_row);\n      xfree(lux->Q_col);\n      xfree(lux);\n      return;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/draft/lux.h": {},
  "glpk/glpk-4.65/src/env/alloc.c": {
    "dma": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void *dma(const char *func, void *ptr, size_t size)\n{     ENV *env = get_env_ptr();\n      MBD *mbd;\n      if (ptr == NULL)\n      {  /* new memory block will be allocated */\n         mbd = NULL;\n      }\n      else\n      {  /* allocated memory block will be reallocated or freed */\n         /* get pointer to the block descriptor */\n         mbd = (MBD *)((char *)ptr - MBD_SIZE);\n         /* make sure that the block descriptor is valid */\n         if (mbd->self != mbd)\n            xerror(\"%s: ptr = %p; invalid pointer\\n\", func, ptr);\n         /* remove the block from the linked list */\n         mbd->self = NULL;\n         if (mbd->prev == NULL)\n            env->mem_ptr = mbd->next;\n         else\n            mbd->prev->next = mbd->next;\n         if (mbd->next == NULL)\n            ;\n         else\n            mbd->next->prev = mbd->prev;\n         /* decrease usage counts */\n         if (!(env->mem_count >= 1 && env->mem_total >= mbd->size))\n            xerror(\"%s: memory allocation error\\n\", func);\n         env->mem_count--;\n         env->mem_total -= mbd->size;\n         if (size == 0)\n         {  /* free the memory block */\n            free(mbd);\n            return NULL;\n         }\n      }\n      /* allocate/reallocate memory block */\n      if (size > SIZE_T_MAX - MBD_SIZE)\n         xerror(\"%s: block too large\\n\", func);\n      size += MBD_SIZE;\n      if (size > env->mem_limit - env->mem_total)\n         xerror(\"%s: memory allocation limit exceeded\\n\", func);\n      if (env->mem_count == INT_MAX)\n         xerror(\"%s: too many memory blocks allocated\\n\", func);\n      mbd = (mbd == NULL ? malloc(size) : realloc(mbd, size));\n      if (mbd == NULL)\n         xerror(\"%s: no memory available\\n\", func);\n      /* setup the block descriptor */\n      mbd->size = size;\n      mbd->self = mbd;\n      mbd->prev = NULL;\n      mbd->next = env->mem_ptr;\n      /* add the block to the beginning of the linked list */\n      if (mbd->next != NULL)\n         mbd->next->prev = mbd;\n      env->mem_ptr = mbd;\n      /* increase usage counts */\n      env->mem_count++;\n      if (env->mem_cpeak < env->mem_count)\n         env->mem_cpeak = env->mem_count;\n      env->mem_total += size;\n      if (env->mem_tpeak < env->mem_total)\n         env->mem_tpeak = env->mem_total;\n      return (char *)mbd + MBD_SIZE;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*dma(const char *func, void *ptr, size_t size)",
        "*"
      ]
    },
    "glp_alloc": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void *glp_alloc(int n, int size)\n{     if (n < 1)\n         xerror(\"glp_alloc: n = %d; invalid parameter\\n\", n);\n      if (size < 1)\n         xerror(\"glp_alloc: size = %d; invalid parameter\\n\", size);\n      if ((size_t)n > SIZE_T_MAX / (size_t)size)\n         xerror(\"glp_alloc: n = %d, size = %d; block too large\\n\",\n            n, size);\n      return dma(\"glp_alloc\", NULL, (size_t)n * (size_t)size);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void",
        "*glp_alloc(int n, int size)",
        "*"
      ]
    },
    "glp_realloc": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void *glp_realloc(void *ptr, int n, int size)\n{     /* reallocate memory block */\n      if (ptr == NULL)\n         xerror(\"glp_realloc: ptr = %p; invalid pointer\\n\", ptr);\n      if (n < 1)\n         xerror(\"glp_realloc: n = %d; invalid parameter\\n\", n);\n      if (size < 1)\n         xerror(\"glp_realloc: size = %d; invalid parameter\\n\", size);\n      if ((size_t)n > SIZE_T_MAX / (size_t)size)\n         xerror(\"glp_realloc: n = %d, size = %d; block too large\\n\",\n            n, size);\n      return dma(\"glp_realloc\", ptr, (size_t)n * (size_t)size);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void",
        "*glp_realloc(void *ptr, int n, int size)",
        "*"
      ]
    },
    "glp_free": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void glp_free(void *ptr)\n{     if (ptr == NULL)\n         xerror(\"glp_free: ptr = %p; invalid pointer\\n\", ptr);\n      dma(\"glp_free\", ptr, 0);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glp_mem_limit": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void glp_mem_limit(int limit)\n{     ENV *env = get_env_ptr();\n      if (limit < 1)\n         xerror(\"glp_mem_limit: limit = %d; invalid parameter\\n\",\n            limit);\n      if ((size_t)limit <= (SIZE_T_MAX >> 20))\n         env->mem_limit = (size_t)limit << 20;\n      else\n         env->mem_limit = SIZE_T_MAX;\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "glp_mem_usage": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "void glp_mem_usage(int *count, int *cpeak, size_t *total,\n      size_t *tpeak)\n{     ENV *env = get_env_ptr();\n      if (count != NULL)\n         *count = env->mem_count;\n      if (cpeak != NULL)\n         *cpeak = env->mem_cpeak;\n      if (total != NULL)\n         *total = env->mem_total;\n      if (tpeak != NULL)\n         *tpeak = env->mem_tpeak;\n      return;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/dlsup.c": {
    "xdlopen": [
      {
        "start_point": [
          35,
          0
        ],
        "end_point": [
          49,
          1
        ],
        "content": "void *xdlopen(const char *module)\n{     /* open dynamically linked library */\n      void *h = NULL;\n      if (lt_dlinit() != 0)\n      {  put_err_msg(lt_dlerror());\n         goto done;\n      }\n      h = lt_dlopen(module);\n      if (h == NULL)\n      {  put_err_msg(lt_dlerror());\n         if (lt_dlexit() != 0)\n            xerror(\"xdlopen: %s\\n\", lt_dlerror());\n      }\ndone: return h;\n}",
        "lines": 15,
        "depth": 11,
        "decorators": [
          "void",
          "*xdlopen(const char *module)",
          "*"
        ]
      },
      {
        "start_point": [
          77,
          0
        ],
        "end_point": [
          84,
          1
        ],
        "content": "void *xdlopen(const char *module)\n{     /* open dynamically linked library */\n      void *h;\n      h = dlopen(module, RTLD_NOW);\n      if (h == NULL)\n         put_err_msg(dlerror());\n      return h;\n}",
        "lines": 8,
        "depth": 9,
        "decorators": [
          "void",
          "*xdlopen(const char *module)",
          "*"
        ]
      },
      {
        "start_point": [
          110,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "void *xdlopen(const char *module)\n{     /* open dynamically linked library */\n      void *h;\n      h = LoadLibrary(module);\n      if (h == NULL)\n      {  char msg[20];\n         sprintf(msg, \"Error %d\", GetLastError());\n         put_err_msg(msg);\n      }\n      return h;\n}",
        "lines": 11,
        "depth": 10,
        "decorators": [
          "void",
          "*xdlopen(const char *module)",
          "*"
        ]
      },
      {
        "start_point": [
          144,
          0
        ],
        "end_point": [
          149,
          1
        ],
        "content": "void *xdlopen(const char *module)\n{     /* open dynamically linked library */\n      xassert(module == module);\n      put_err_msg(\"Shared libraries not supported\");\n      return NULL;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "void",
          "*xdlopen(const char *module)",
          "*"
        ]
      }
    ],
    "xdlsym": [
      {
        "start_point": [
          51,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "void *xdlsym(void *h, const char *symbol)\n{     /* obtain address of symbol from dynamically linked library */\n      void *ptr;\n      xassert(h != NULL);\n      ptr = lt_dlsym(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: %s\\n\", symbol, lt_dlerror());\n      return ptr;\n}",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "void",
          "*xdlsym(void *h, const char *symbol)",
          "*"
        ]
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          94,
          1
        ],
        "content": "void *xdlsym(void *h, const char *symbol)\n{     /* obtain address of symbol from dynamically linked library */\n      void *ptr;\n      xassert(h != NULL);\n      ptr = dlsym(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: %s\\n\", symbol, dlerror());\n      return ptr;\n}",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "void",
          "*xdlsym(void *h, const char *symbol)",
          "*"
        ]
      },
      {
        "start_point": [
          122,
          0
        ],
        "end_point": [
          130,
          1
        ],
        "content": "void *xdlsym(void *h, const char *symbol)\n{     /* obtain address of symbol from dynamically linked library */\n      void *ptr;\n      xassert(h != NULL);\n      ptr = GetProcAddress(h, symbol);\n      if (ptr == NULL)\n         xerror(\"xdlsym: %s: Error %d\\n\", symbol, GetLastError());\n      return ptr;\n}",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "void",
          "*xdlsym(void *h, const char *symbol)",
          "*"
        ]
      },
      {
        "start_point": [
          151,
          0
        ],
        "end_point": [
          156,
          1
        ],
        "content": "void *xdlsym(void *h, const char *symbol)\n{     /* obtain address of symbol from dynamically linked library */\n      xassert(h != h);\n      xassert(symbol != symbol);\n      return NULL;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "void",
          "*xdlsym(void *h, const char *symbol)",
          "*"
        ]
      }
    ],
    "xdlclose": [
      {
        "start_point": [
          61,
          0
        ],
        "end_point": [
          69,
          1
        ],
        "content": "void xdlclose(void *h)\n{     /* close dynamically linked library */\n      xassert(h != NULL);\n      if (lt_dlclose(h) != 0)\n         xerror(\"xdlclose: %s\\n\", lt_dlerror());\n      if (lt_dlexit() != 0)\n         xerror(\"xdlclose: %s\\n\", lt_dlerror());\n      return;\n}",
        "lines": 9,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "void xdlclose(void *h)\n{     /* close dynamically linked library */\n      xassert(h != NULL);\n      if (dlclose(h) != 0)\n         xerror(\"xdlclose: %s\\n\", dlerror());\n      return;\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          132,
          0
        ],
        "end_point": [
          138,
          1
        ],
        "content": "void xdlclose(void *h)\n{     /* close dynamically linked library */\n      xassert(h != NULL);\n      if (!FreeLibrary(h))\n         xerror(\"xdlclose: Error %d\\n\", GetLastError());\n      return;\n}",
        "lines": 7,
        "depth": 9,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          158,
          0
        ],
        "end_point": [
          162,
          1
        ],
        "content": "void xdlclose(void *h)\n{     /* close dynamically linked library */\n      xassert(h != h);\n      return;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "glpk/glpk-4.65/src/env/env.c": {
    "glp_init_env": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int glp_init_env(void)\n{     ENV *env;\n      int ok;\n      /* check if the programming model is supported */\n      ok = (CHAR_BIT == 8 && sizeof(char) == 1 &&\n         sizeof(short) == 2 && sizeof(int) == 4 &&\n         (sizeof(void *) == 4 || sizeof(void *) == 8));\n      if (!ok)\n         return 3;\n      /* check if the environment is already initialized */\n      if (tls_get_ptr() != NULL)\n         return 1;\n      /* allocate and initialize the environment block */\n      env = malloc(sizeof(ENV));\n      if (env == NULL)\n         return 2;\n      memset(env, 0, sizeof(ENV));\n#if 0 /* 14/I-2017 */\n      sprintf(env->version, \"%d.%d\",\n         GLP_MAJOR_VERSION, GLP_MINOR_VERSION);\n#endif\n      env->self = env;\n      env->term_buf = malloc(TBUF_SIZE);\n      if (env->term_buf == NULL)\n      {  free(env);\n         return 2;\n      }\n      env->term_out = GLP_ON;\n      env->term_hook = NULL;\n      env->term_info = NULL;\n      env->tee_file = NULL;\n#if 1 /* 23/XI-2015 */\n      env->err_st = 0;\n#endif\n      env->err_file = NULL;\n      env->err_line = 0;\n      env->err_hook = NULL;\n      env->err_info = NULL;\n      env->err_buf = malloc(EBUF_SIZE);\n      if (env->err_buf == NULL)\n      {  free(env->term_buf);\n         free(env);\n         return 2;\n      }\n      env->err_buf[0] = '\\0';\n      env->mem_limit = SIZE_T_MAX;\n      env->mem_ptr = NULL;\n      env->mem_count = env->mem_cpeak = 0;\n      env->mem_total = env->mem_tpeak = 0;\n#if 1 /* 23/XI-2015 */\n      env->gmp_pool = NULL;\n      env->gmp_size = 0;\n      env->gmp_work = NULL;\n#endif\n      env->h_odbc = env->h_mysql = NULL;\n      /* save pointer to the environment block */\n      tls_set_ptr(env);\n      /* initialization successful */\n      return 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "get_env_ptr": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "ENV *get_env_ptr(void)\n{     ENV *env = tls_get_ptr();\n      /* check if the environment has been initialized */\n      if (env == NULL)\n      {  /* not initialized yet; perform initialization */\n         if (glp_init_env() != 0)\n         {  /* initialization failed; display an error message */\n            fprintf(stderr, \"GLPK initialization failed\\n\");\n            fflush(stderr);\n            /* and abnormally terminate the program */\n            abort();\n         }\n         /* initialization successful; retrieve the pointer */\n         env = tls_get_ptr();\n      }\n      /* check if the environment block is valid */\n      if (env->self != env)\n      {  fprintf(stderr, \"Invalid GLPK environment\\n\");\n         fflush(stderr);\n         abort();\n      }\n      return env;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "ENV",
        "*get_env_ptr(void)",
        "*"
      ]
    },
    "glp_config": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "const char *glp_config(const char *option)\n{     const char *s;\n      if (strcmp(option, \"TLS\") == 0)\n#ifndef TLS\n         s = NULL;\n#else\n         s = xstr(TLS);\n#endif\n      else if (strcmp(option, \"ODBC_DLNAME\") == 0)\n#ifndef ODBC_DLNAME\n         s = NULL;\n#else\n         s = ODBC_DLNAME;\n#endif\n      else if (strcmp(option, \"MYSQL_DLNAME\") == 0)\n#ifndef MYSQL_DLNAME\n         s = NULL;\n#else\n         s = MYSQL_DLNAME;\n#endif\n      else\n      {  /* invalid option is always disabled */\n         s = NULL;\n      }\n      return s;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*glp_config(const char *option)",
        "*"
      ]
    },
    "glp_free_env": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int glp_free_env(void)\n{     ENV *env = tls_get_ptr();\n      MBD *desc;\n      /* check if the environment is active */\n      if (env == NULL)\n         return 1;\n      /* check if the environment block is valid */\n      if (env->self != env)\n      {  fprintf(stderr, \"Invalid GLPK environment\\n\");\n         fflush(stderr);\n         abort();\n      }\n      /* close handles to shared libraries */\n      if (env->h_odbc != NULL)\n         xdlclose(env->h_odbc);\n      if (env->h_mysql != NULL)\n         xdlclose(env->h_mysql);\n      /* free memory blocks which are still allocated */\n      while (env->mem_ptr != NULL)\n      {  desc = env->mem_ptr;\n         env->mem_ptr = desc->next;\n         free(desc);\n      }\n      /* close text file used for copying terminal output */\n      if (env->tee_file != NULL)\n         fclose(env->tee_file);\n      /* invalidate the environment block */\n      env->self = NULL;\n      /* free memory allocated to the environment block */\n      free(env->term_buf);\n      free(env->err_buf);\n      free(env);\n      /* reset a pointer to the environment block */\n      tls_set_ptr(NULL);\n      /* termination successful */\n      return 0;\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/env.h": {},
  "glpk/glpk-4.65/src/env/error.c": {
    "errfunc": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void errfunc(const char *fmt, ...)\n{     ENV *env = get_env_ptr();\n      va_list arg;\n#if 1 /* 07/XI-2015 */\n      env->err_st = 1;\n#endif\n      env->term_out = GLP_ON;\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      xprintf(\"Error detected in file %s at line %d\\n\",\n         env->err_file, env->err_line);\n      if (env->err_hook != NULL)\n         env->err_hook(env->err_info);\n      abort();\n      exit(EXIT_FAILURE);\n      /* no return */\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_error_": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "glp_errfunc glp_error_(const char *file, int line)\n{     ENV *env = get_env_ptr();\n      env->err_file = file;\n      env->err_line = line;\n      return errfunc;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "glp_errfunc"
      ]
    },
    "glp_at_error": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int glp_at_error(void)\n{     ENV *env = get_env_ptr();\n      return env->err_st;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "glp_assert_": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void glp_assert_(const char *expr, const char *file, int line)\n{     glp_error_(file, line)(\"Assertion failed: %s\\n\", expr);\n      /* no return */\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "glp_error_hook": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void glp_error_hook(void (*func)(void *info), void *info)\n{     ENV *env = get_env_ptr();\n      if (func == NULL)\n      {  env->err_hook = NULL;\n         env->err_info = NULL;\n      }\n      else\n      {  env->err_hook = func;\n         env->err_info = info;\n      }\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "put_err_msg": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void put_err_msg(const char *msg)\n{     ENV *env = get_env_ptr();\n      int len;\n      len = strlen(msg);\n      if (len >= EBUF_SIZE)\n         len = EBUF_SIZE - 1;\n      memcpy(env->err_buf, msg, len);\n      if (len > 0 && env->err_buf[len-1] == '\\n')\n         len--;\n      env->err_buf[len] = '\\0';\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "get_err_msg": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "const char *get_err_msg(void)\n{     ENV *env = get_env_ptr();\n      return env->err_buf;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*get_err_msg(void)",
        "*"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/stdc.c": {
    "xgmtime": [
      {
        "start_point": [
          34,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "struct tm *xgmtime(const time_t *timer)\n{     return\n         gmtime(timer);\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "struct tm",
          "struct",
          "tm",
          "*xgmtime(const time_t *timer)",
          "*"
        ]
      },
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          59,
          1
        ],
        "content": "struct tm *xgmtime(const time_t *timer)\n{     static TLS struct tm result;\n      gmtime_s(&result, timer);\n      return &result;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "struct tm",
          "struct",
          "tm",
          "*xgmtime(const time_t *timer)",
          "*"
        ]
      },
      {
        "start_point": [
          78,
          0
        ],
        "end_point": [
          82,
          1
        ],
        "content": "struct tm *xgmtime(const time_t *timer)\n{     static TLS struct tm result;\n      gmtime_r(timer, &result);\n      return &result;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "struct tm",
          "struct",
          "tm",
          "*xgmtime(const time_t *timer)",
          "*"
        ]
      }
    ],
    "xstrerr": [
      {
        "start_point": [
          39,
          0
        ],
        "end_point": [
          42,
          1
        ],
        "content": "char *xstrerr(int errnum)\n{     return\n         strerror(errnum);\n}",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "char",
          "*xstrerr(int errnum)",
          "*"
        ]
      },
      {
        "start_point": [
          61,
          0
        ],
        "end_point": [
          65,
          1
        ],
        "content": "char *xstrerr(int errnum)\n{     static TLS char s[1023+1];\n      strerror_s(s, sizeof(s), errnum);\n      return s;\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "char",
          "*xstrerr(int errnum)",
          "*"
        ]
      },
      {
        "start_point": [
          84,
          0
        ],
        "end_point": [
          88,
          1
        ],
        "content": "char *xstrerr(int errnum)\n{     static TLS char s[1023+1];\n      strerror_r(errnum, s, sizeof(s));\n      return s;\n}",
        "lines": 5,
        "depth": 8,
        "decorators": [
          "char",
          "*xstrerr(int errnum)",
          "*"
        ]
      }
    ],
    "xstrtok": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          47,
          1
        ],
        "content": "char *xstrtok(char *s1, const char *s2)\n{     return\n         strtok(s1, s2);\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "char",
          "*xstrtok(char *s1, const char *s2)",
          "*"
        ]
      },
      {
        "start_point": [
          67,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "char *xstrtok(char *s1, const char *s2)\n{     static TLS char *ptr;\n      return strtok_s(s1, s2, &ptr);\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "char",
          "*xstrtok(char *s1, const char *s2)",
          "*"
        ]
      },
      {
        "start_point": [
          90,
          0
        ],
        "end_point": [
          93,
          1
        ],
        "content": "char *xstrtok(char *s1, const char *s2)\n{     static TLS char *ptr;\n      return strtok_r(s1, s2, &ptr);\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "char",
          "*xstrtok(char *s1, const char *s2)",
          "*"
        ]
      }
    ]
  },
  "glpk/glpk-4.65/src/env/stdc.h": {},
  "glpk/glpk-4.65/src/env/stdout.c": {
    "glp_puts": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void glp_puts(const char *s)\n{     ENV *env = get_env_ptr();\n      /* if terminal output is disabled, do nothing */\n      if (!env->term_out)\n         goto skip;\n      /* pass the string to the hook routine, if defined */\n      if (env->term_hook != NULL)\n      {  if (env->term_hook(env->term_info, s) != 0)\n            goto skip;\n      }\n      /* write the string on the terminal */\n      fputs(s, stdout);\n      fflush(stdout);\n      /* write the string on the tee file, if required */\n      if (env->tee_file != NULL)\n      {  fputs(s, env->tee_file);\n         fflush(env->tee_file);\n      }\nskip: return;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "glp_printf": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void glp_printf(const char *fmt, ...)\n{     ENV *env = get_env_ptr();\n      va_list arg;\n      /* if terminal output is disabled, do nothing */\n      if (!env->term_out)\n         goto skip;\n      /* format the output */\n      va_start(arg, fmt);\n      vsprintf(env->term_buf, fmt, arg);\n      /* (do not use xassert) */\n      assert(strlen(env->term_buf) < TBUF_SIZE);\n      va_end(arg);\n      /* write the formatted output on the terminal */\n      glp_puts(env->term_buf);\nskip: return;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_vprintf": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void glp_vprintf(const char *fmt, va_list arg)\n{     ENV *env = get_env_ptr();\n      /* if terminal output is disabled, do nothing */\n      if (!env->term_out)\n         goto skip;\n      /* format the output */\n      vsprintf(env->term_buf, fmt, arg);\n      /* (do not use xassert) */\n      assert(strlen(env->term_buf) < TBUF_SIZE);\n      /* write the formatted output on the terminal */\n      glp_puts(env->term_buf);\nskip: return;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "glp_term_out": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int glp_term_out(int flag)\n{     ENV *env = get_env_ptr();\n      int old = env->term_out;\n      if (!(flag == GLP_ON || flag == GLP_OFF))\n         xerror(\"glp_term_out: flag = %d; invalid parameter\\n\", flag);\n      env->term_out = flag;\n      return old;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glp_term_hook": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void glp_term_hook(int (*func)(void *info, const char *s), void *info)\n{     ENV *env = get_env_ptr();\n      if (func == NULL)\n      {  env->term_hook = NULL;\n         env->term_info = NULL;\n      }\n      else\n      {  env->term_hook = func;\n         env->term_info = info;\n      }\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "glp_open_tee": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "int glp_open_tee(const char *name)\n{     ENV *env = get_env_ptr();\n      if (env->tee_file != NULL)\n      {  /* copying terminal output is already active */\n         return 1;\n      }\n      env->tee_file = fopen(name, \"w\");\n      if (env->tee_file == NULL)\n      {  /* unable to create output file */\n         return 2;\n      }\n      return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glp_close_tee": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "int glp_close_tee(void)\n{     ENV *env = get_env_ptr();\n      if (env->tee_file == NULL)\n      {  /* copying terminal output was not started */\n         return 1;\n      }\n      fclose(env->tee_file);\n      env->tee_file = NULL;\n      return 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/stream.c": {
    "glp_open": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "glp_file *glp_open(const char *name, const char *mode)\n{     glp_file *f;\n      int flag;\n      void *file;\n      if (strcmp(mode, \"r\") == 0 || strcmp(mode, \"rb\") == 0)\n         flag = 0;\n      else if (strcmp(mode, \"w\") == 0 || strcmp(mode, \"wb\") == 0)\n         flag = IOWRT;\n#if 1 /* 08/V-2014 */\n      else if (strcmp(mode, \"a\") == 0 || strcmp(mode, \"ab\") == 0)\n         flag = IOWRT;\n#endif\n      else\n         xerror(\"glp_open: invalid mode string\\n\");\n      if (strcmp(name, \"/dev/null\") == 0)\n      {  flag |= IONULL;\n         file = NULL;\n      }\n      else if (strcmp(name, \"/dev/stdin\") == 0)\n      {  flag |= IOSTD;\n         file = stdin;\n      }\n      else if (strcmp(name, \"/dev/stdout\") == 0)\n      {  flag |= IOSTD;\n         file = stdout;\n      }\n      else if (strcmp(name, \"/dev/stderr\") == 0)\n      {  flag |= IOSTD;\n         file = stderr;\n      }\n      else\n      {  char *ext = strrchr(name, '.');\n         if (ext == NULL || strcmp(ext, \".gz\") != 0)\n         {  file = fopen(name, mode);\n            if (file == NULL)\n#if 0 /* 29/I-2017 */\n            {  put_err_msg(strerror(errno));\n#else\n            {  put_err_msg(xstrerr(errno));\n#endif\n               return NULL;\n            }\n         }\n         else\n         {  flag |= IOGZIP;\n            if (strcmp(mode, \"r\") == 0)\n               mode = \"rb\";\n            else if (strcmp(mode, \"w\") == 0)\n               mode = \"wb\";\n#if 1 /* 08/V-2014; this mode seems not to work */\n            else if (strcmp(mode, \"a\") == 0)\n               mode = \"ab\";\n#endif\n            file = gzopen(name, mode);\n            if (file == NULL)\n#if 0 /* 29/I-2017 */\n            {  put_err_msg(strerror(errno));\n#else\n            {  put_err_msg(xstrerr(errno));\n#endif\n               return NULL;\n            }\n         }\n      }\n      f = talloc(1, glp_file);\n      f->base = talloc(BUFSIZ, char);\n      f->size = BUFSIZ;\n      f->ptr = f->base;\n      f->cnt = 0;\n      f->flag = flag;\n      f->file = file;\n      return f;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "glp_file",
        "*glp_open(const char *name, const char *mode)",
        "*"
      ]
    },
    "glp_eof": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "int glp_eof(glp_file *f)\n{     return\n         f->flag & IOEOF;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_ioerr": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "int glp_ioerr(glp_file *f)\n{     return\n         f->flag & IOERR;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "glp_read": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int glp_read(glp_file *f, void *buf, int nnn)\n{     int nrd, cnt;\n      if (f->flag & IOWRT)\n         xerror(\"glp_read: attempt to read from output stream\\n\");\n      if (nnn < 1)\n         xerror(\"glp_read: nnn = %d; invalid parameter\\n\", nnn);\n      for (nrd = 0; nrd < nnn; nrd += cnt)\n      {  if (f->cnt == 0)\n         {  /* buffer is empty; fill it */\n            if (f->flag & IONULL)\n               cnt = 0;\n            else if (!(f->flag & IOGZIP))\n            {  cnt = fread(f->base, 1, f->size, (FILE *)(f->file));\n               if (ferror((FILE *)(f->file)))\n               {  f->flag |= IOERR;\n#if 0 /* 29/I-2017 */\n                  put_err_msg(strerror(errno));\n#else\n                  put_err_msg(xstrerr(errno));\n#endif\n                  return EOF;\n               }\n            }\n            else\n            {  int errnum;\n               const char *msg;\n               cnt = gzread((gzFile)(f->file), f->base, f->size);\n               if (cnt < 0)\n               {  f->flag |= IOERR;\n                  msg = gzerror((gzFile)(f->file), &errnum);\n                  if (errnum == Z_ERRNO)\n#if 0 /* 29/I-2017 */\n                     put_err_msg(strerror(errno));\n#else\n                     put_err_msg(xstrerr(errno));\n#endif\n                  else\n                     put_err_msg(msg);\n                  return EOF;\n               }\n            }\n            if (cnt == 0)\n            {  if (nrd == 0)\n                  f->flag |= IOEOF;\n               break;\n            }\n            f->ptr = f->base;\n            f->cnt = cnt;\n         }\n         cnt = nnn - nrd;\n         if (cnt > f->cnt)\n            cnt = f->cnt;\n         memcpy((char *)buf + nrd, f->ptr, cnt);\n         f->ptr += cnt;\n         f->cnt -= cnt;\n      }\n      return nrd;\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "glp_getc": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "int glp_getc(glp_file *f)\n{     unsigned char buf[1];\n      if (f->flag & IOWRT)\n         xerror(\"glp_getc: attempt to read from output stream\\n\");\n      if (glp_read(f, buf, 1) != 1)\n         return EOF;\n      return buf[0];\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "do_flush": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "static int do_flush(glp_file *f)\n{     xassert(f->flag & IOWRT);\n      if (f->cnt > 0)\n      {  if (f->flag & IONULL)\n            ;\n         else if (!(f->flag & IOGZIP))\n         {  if ((int)fwrite(f->base, 1, f->cnt, (FILE *)(f->file))\n               != f->cnt)\n            {  f->flag |= IOERR;\n#if 0 /* 29/I-2017 */\n               put_err_msg(strerror(errno));\n#else\n               put_err_msg(xstrerr(errno));\n#endif\n               return EOF;\n            }\n         }\n         else\n         {  int errnum;\n            const char *msg;\n            if (gzwrite((gzFile)(f->file), f->base, f->cnt) != f->cnt)\n            {  f->flag |= IOERR;\n               msg = gzerror((gzFile)(f->file), &errnum);\n               if (errnum == Z_ERRNO)\n#if 0 /* 29/I-2017 */\n                  put_err_msg(strerror(errno));\n#else\n                  put_err_msg(xstrerr(errno));\n#endif\n               else\n                  put_err_msg(msg);\n               return EOF;\n            }\n         }\n      }\n      f->ptr = f->base;\n      f->cnt = 0;\n      return 0;\n}",
      "lines": 39,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "glp_write": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "int glp_write(glp_file *f, const void *buf, int nnn)\n{     int nwr, cnt;\n      if (!(f->flag & IOWRT))\n         xerror(\"glp_write: attempt to write to input stream\\n\");\n      if (nnn < 1)\n         xerror(\"glp_write: nnn = %d; invalid parameter\\n\", nnn);\n      for (nwr = 0; nwr < nnn; nwr += cnt)\n      {  cnt = nnn - nwr;\n         if (cnt > f->size - f->cnt)\n            cnt = f->size - f->cnt;\n         memcpy(f->ptr, (const char *)buf + nwr, cnt);\n         f->ptr += cnt;\n         f->cnt += cnt;\n         if (f->cnt == f->size)\n         {  /* buffer is full; flush it */\n            if (do_flush(f) != 0)\n               return EOF;\n         }\n      }\n      return nwr;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glp_format": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int glp_format(glp_file *f, const char *fmt, ...)\n{     ENV *env = get_env_ptr();\n      va_list arg;\n      int nnn;\n      if (!(f->flag & IOWRT))\n         xerror(\"glp_format: attempt to write to input stream\\n\");\n      va_start(arg, fmt);\n      nnn = vsprintf(env->term_buf, fmt, arg);\n      xassert(0 <= nnn && nnn < TBUF_SIZE);\n      va_end(arg);\n      return nnn == 0 ? 0 : glp_write(f, env->term_buf, nnn);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glp_close": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        516,
        9
      ],
      "content": "int glp_close(glp_file *f)\n{     int ret = 0;\n      if (f->flag & IOWRT)\n      {  if (do_flush(f) != 0)\n            ret = EOF;\n      }\n      if (f->flag & (IONULL | IOSTD))\n         ;\n      else if (!(f->flag & IOGZIP))\n      {  if (fclose((FILE *)(f->file)) != 0)\n         {  if (ret == 0)\n#if 0 /* 29/I-2017 */\n            {  put_err_msg(strerror(errno));\n#else\n            {  put_err_msg(xstrerr(errno));\n#endif\n               ret = EOF;\n            }\n         }\n      }\n      else\n      {  int errnum;\n         errnum = gzclose((gzFile)(f->file));\n         if (errnum == Z_OK)\n            ;\n         else if (errnum == Z_ERRNO)\n         {  if (ret == 0)\n#if 0 /* 29/I-2017 */\n            {  put_err_msg(strerror(errno));\n#else\n            {  put_err_msg(xstrerr(errno));\n#endif\n               ret = EOF;\n            }\n         }\n#if 1 /* FIXME */\n         else\n         {  if (ret == 0)\n            {  ENV *env = get_env_ptr();\n               sprintf(env->term_buf, \"gzclose returned %d\", errnum);\n               put_err_msg(env->term_buf);\n               ret = EOF;\n            }\n         }\n#endif\n      }\n      tfree(f->base);\n      tfree(f);\n      return ret;\n}\n\n/* eof */",
      "lines": 52,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/time.c": {
    "glp_time": [
      {
        "start_point": [
          54,
          0
        ],
        "end_point": [
          71,
          1
        ],
        "content": "double glp_time(void)\n{     struct timeval tv;\n      struct tm *tm;\n      int j;\n      double t;\n      gettimeofday(&tv, NULL);\n#if 0 /* 29/I-2017 */\n      tm = gmtime(&tv.tv_sec);\n#else\n      tm = xgmtime(&tv.tv_sec);\n#endif\n      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);\n      xassert(j >= 0);\n      t = ((((double)(j - EPOCH) * 24.0 + (double)tm->tm_hour) * 60.0 +\n         (double)tm->tm_min) * 60.0 + (double)tm->tm_sec) * 1000.0 +\n         (double)(tv.tv_usec / 1000);\n      return t;\n}",
        "lines": 18,
        "depth": 19,
        "decorators": [
          "double"
        ]
      },
      {
        "start_point": [
          75,
          0
        ],
        "end_point": [
          82,
          1
        ],
        "content": "double glp_time(void)\n{     struct timeval tv;\n      double t;\n      gettimeofday(&tv, NULL);\n      t = (double)tv.tv_sec + (double)(tv.tv_usec) / 1e6;\n      xassert(0.0 <= t && t < 4294967296.0);\n      return 1000.0 * t;\n}",
        "lines": 8,
        "depth": 10,
        "decorators": [
          "double"
        ]
      },
      {
        "start_point": [
          91,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "double glp_time(void)\n{     SYSTEMTIME st;\n      int j;\n      double t;\n      GetSystemTime(&st);\n      j = jday(st.wDay, st.wMonth, st.wYear);\n      xassert(j >= 0);\n      t = ((((double)(j - EPOCH) * 24.0 + (double)st.wHour) * 60.0 +\n         (double)st.wMinute) * 60.0 + (double)st.wSecond) * 1000.0 +\n         (double)st.wMilliseconds;\n      return t;\n}",
        "lines": 12,
        "depth": 19,
        "decorators": [
          "double"
        ]
      },
      {
        "start_point": [
          110,
          0
        ],
        "end_point": [
          126,
          1
        ],
        "content": "double glp_time(void)\n{     time_t timer;\n      struct tm *tm;\n      int j;\n      double t;\n      timer = time(NULL);\n#if 0 /* 29/I-2017 */\n      tm = gmtime(&timer);\n#else\n      tm = xgmtime(&timer);\n#endif\n      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);\n      xassert(j >= 0);\n      t = ((((double)(j - EPOCH) * 24.0 + (double)tm->tm_hour) * 60.0 +\n         (double)tm->tm_min) * 60.0 + (double)tm->tm_sec) * 1000.0;\n      return t;\n}",
        "lines": 17,
        "depth": 18,
        "decorators": [
          "double"
        ]
      }
    ],
    "glp_difftime": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "double glp_difftime(double t1, double t0)\n{     return\n         (t1 - t0) / 1000.0;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/env/tls.c": {
    "tls_set_ptr": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void tls_set_ptr(void *ptr)\n{     tls = ptr;\n      return;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "tls_get_ptr": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void *tls_get_ptr(void)\n{     void *ptr;\n      ptr = tls;\n      return ptr;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void",
        "*tls_get_ptr(void)",
        "*"
      ]
    },
    "DllMain": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID\n      lpvReserved)\n{     DWORD version;\n      DWORD major_version;\n#ifdef TLS\n      switch (fdwReason)\n      {  case DLL_PROCESS_ATTACH:\n         /* @TODO:\n          * GetVersion is deprecated but the version help functions are\n          * not available in Visual Studio 2010. So lets use it until\n          * we remove the outdated Build files. */\n         version = GetVersion();\n         major_version = version & 0xff;\n         if (major_version < VISTA)\n         {  MessageBoxA(NULL,\n               \"The GLPK library called by this application is configur\"\n               \"ed to use thread local storage which is not fully suppo\"\n               \"rted by your version of Microsoft Windows.\\n\\n\"\n               \"Microsoft Windows Vista or a later version of Windows i\"\n               \"s required to run this application.\",\n               \"GLPK\", MB_OK | MB_ICONERROR);\n            return FALSE;\n         }\n         break;\n      }\n#endif /* TLS */\n      return TRUE;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "BOOL",
        "WINAPI",
        "WINAPI"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/cfg.c": {
    "cfg_create_graph": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "CFG *cfg_create_graph(int n, int nv_max)\n{     CFG *G;\n      xassert(n >= 0);\n      xassert(0 <= nv_max && nv_max <= n + n);\n      G = talloc(1, CFG);\n      G->n = n;\n      G->pos = talloc(1+n, int);\n      memset(&G->pos[1], 0, n * sizeof(int));\n      G->neg = talloc(1+n, int);\n      memset(&G->neg[1], 0, n * sizeof(int));\n      G->pool = dmp_create_pool();\n      G->nv_max = nv_max;\n      G->nv = 0;\n      G->ref = talloc(1+nv_max, int);\n      G->vptr = talloc(1+nv_max, CFGVLE *);\n      G->cptr = talloc(1+nv_max, CFGCLE *);\n      return G;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "CFG",
        "*cfg_create_graph(int n, int nv_max)",
        "*"
      ]
    },
    "add_edge": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void add_edge(CFG *G, int v, int w)\n{     /* add clique of size 2 */\n      DMP *pool = G->pool;\n      int nv = G->nv;\n      CFGVLE **vptr = G->vptr;\n      CFGVLE *vle;\n      xassert(1 <= v && v <= nv);\n      xassert(1 <= w && w <= nv);\n      xassert(v != w);\n      vle = dmp_talloc(pool, CFGVLE);\n      vle->v = w;\n      vle->next = vptr[v];\n      vptr[v] = vle;\n      vle = dmp_talloc(pool, CFGVLE);\n      vle->v = v;\n      vle->next = vptr[w];\n      vptr[w] = vle;\n      return;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfg_add_clique": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void cfg_add_clique(CFG *G, int size, const int ind[])\n{     int n = G->n;\n      int *pos = G->pos;\n      int *neg = G->neg;\n      DMP *pool = G->pool;\n      int nv_max = G->nv_max;\n      int *ref = G->ref;\n      CFGVLE **vptr = G->vptr;\n      CFGCLE **cptr = G->cptr;\n      int j, k, v;\n      xassert(2 <= size && size <= nv_max);\n      /* add new vertices to the conflict graph */\n      for (k = 1; k <= size; k++)\n      {  j = ind[k];\n         if (j > 0)\n         {  /* vertex corresponds to x[j] */\n            xassert(1 <= j && j <= n);\n            if (pos[j] == 0)\n            {  /* no such vertex exists; add it */\n               v = pos[j] = ++(G->nv);\n               xassert(v <= nv_max);\n               ref[v] = j;\n               vptr[v] = NULL;\n               cptr[v] = NULL;\n               if (neg[j] != 0)\n               {  /* now both vertices for x[j] and (1 - x[j]) exist */\n                  add_edge(G, v, neg[j]);\n               }\n            }\n         }\n         else\n         {  /* vertex corresponds to (1 - x[j]) */\n            j = -j;\n            xassert(1 <= j && j <= n);\n            if (neg[j] == 0)\n            {  /* no such vertex exists; add it */\n               v = neg[j] = ++(G->nv);\n               xassert(v <= nv_max);\n               ref[v] = j;\n               vptr[v] = NULL;\n               cptr[v] = NULL;\n               if (pos[j] != 0)\n               {  /* now both vertices for x[j] and (1 - x[j]) exist */\n                  add_edge(G, v, pos[j]);\n               }\n            }\n         }\n      }\n      /* add specified clique to the conflict graph */\n      if (size == 2)\n         add_edge(G,\n            ind[1] > 0 ? pos[+ind[1]] : neg[-ind[1]],\n            ind[2] > 0 ? pos[+ind[2]] : neg[-ind[2]]);\n      else\n      {  CFGVLE *vp, *vle;\n         CFGCLE *cle;\n         /* build list of clique vertices */\n         vp = NULL;\n         for (k = 1; k <= size; k++)\n         {  vle = dmp_talloc(pool, CFGVLE);\n            vle->v = ind[k] > 0 ? pos[+ind[k]] : neg[-ind[k]];\n            vle->next = vp;\n            vp = vle;\n         }\n         /* attach the clique to all its vertices */\n         for (k = 1; k <= size; k++)\n         {  cle = dmp_talloc(pool, CFGCLE);\n            cle->vptr = vp;\n            v = ind[k] > 0 ? pos[+ind[k]] : neg[-ind[k]];\n            cle->next = cptr[v];\n            cptr[v] = cle;\n         }\n      }\n      return;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "cfg_get_adjacent": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int cfg_get_adjacent(CFG *G, int v, int ind[])\n{     int nv = G->nv;\n      int *ref = G->ref;\n      CFGVLE **vptr = G->vptr;\n      CFGCLE **cptr = G->cptr;\n      CFGVLE *vle;\n      CFGCLE *cle;\n      int k, w, len;\n      xassert(1 <= v && v <= nv);\n      len = 0;\n      /* walk thru the list of adjacent vertices */\n      for (vle = vptr[v]; vle != NULL; vle = vle->next)\n      {  w = vle->v;\n         xassert(1 <= w && w <= nv);\n         xassert(w != v);\n         if (ref[w] > 0)\n         {  ind[++len] = w;\n            ref[w] = -ref[w];\n         }\n      }\n      /* walk thru the list of incident cliques */\n      for (cle = cptr[v]; cle != NULL; cle = cle->next)\n      {  /* walk thru the list of clique vertices */\n         for (vle = cle->vptr; vle != NULL; vle = vle->next)\n         {  w = vle->v;\n            xassert(1 <= w && w <= nv);\n            if (w != v && ref[w] > 0)\n            {  ind[++len] = w;\n               ref[w] = -ref[w];\n            }\n         }\n      }\n      xassert(1 <= len && len < nv);\n      /* unmark vertices included in the resultant adjacency list */\n      for (k = 1; k <= len; k++)\n      {  w = ind[k];\n         ref[w] = -ref[w];\n      }\n      return len;\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "intersection": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "static int intersection(int d_len, int d_ind[], int d_pos[], int len,\n      const int ind[])\n{     /* compute intersection D := D inter W, where W is some specified\n       * set of vertices */\n      int k, t, v, new_len;\n      /* walk thru vertices in W and mark vertices in D */\n      for (t = 1; t <= len; t++)\n      {  /* v in W */\n         v = ind[t];\n         /* determine position of v in D */\n         k = d_pos[v];\n         if (k != 0)\n         {  /* v in D */\n            xassert(d_ind[k] == v);\n            /* mark v to keep it in D */\n            d_ind[k] = -v;\n         }\n      }\n      /* remove all unmarked vertices from D */\n      new_len = 0;\n      for (k = 1; k <= d_len; k++)\n      {  /* v in D */\n         v = d_ind[k];\n         if (v < 0)\n         {  /* v is marked; keep it */\n            v = -v;\n            new_len++;\n            d_ind[new_len] = v;\n            d_pos[v] = new_len;\n         }\n         else\n         {  /* v is not marked; remove it */\n            d_pos[v] = 0;\n         }\n      }\n      return new_len;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cfg_expand_clique": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "int cfg_expand_clique(CFG *G, int c_len, int c_ind[])\n{     int nv = G->nv;\n      int d_len, *d_ind, *d_pos, len, *ind;\n      int k, v;\n      xassert(0 <= c_len && c_len <= nv);\n      /* allocate working arrays */\n      d_ind = talloc(1+nv, int);\n      d_pos = talloc(1+nv, int);\n      ind = talloc(1+nv, int);\n      /* initialize C := 0, D := V */\n      d_len = nv;\n      for (k = 1; k <= nv; k++)\n         d_ind[k] = d_pos[k] = k;\n      /* expand C by vertices of specified initial clique C0 */\n      for (k = 1; k <= c_len; k++)\n      {  /* v in C0 */\n         v = c_ind[k];\n         xassert(1 <= v && v <= nv);\n         /* since C0 is clique, v should be in D */\n         xassert(d_pos[v] != 0);\n         /* W := set of vertices adjacent to v */\n         len = cfg_get_adjacent(G, v, ind);\n         /* D := D inter W */\n         d_len = intersection(d_len, d_ind, d_pos, len, ind);\n         /* since v not in W, now v should be not in D */\n         xassert(d_pos[v] == 0);\n      }\n      /* expand C by some other vertices until D is empty */\n      while (d_len > 0)\n      {  /* v in D */\n         v = d_ind[1];\n         xassert(1 <= v && v <= nv);\n         /* note that v is adjacent to all vertices in C (by design),\n          * so add v to C */\n         c_ind[++c_len] = v;\n         /* W := set of vertices adjacent to v */\n         len = cfg_get_adjacent(G, v, ind);\n         /* D := D inter W */\n         d_len = intersection(d_len, d_ind, d_pos, len, ind);\n         /* since v not in W, now v should be not in D */\n         xassert(d_pos[v] == 0);\n      }\n      /* free working arrays */\n      tfree(d_ind);\n      tfree(d_pos);\n      tfree(ind);\n      /* bring maximal clique to calling routine */\n      return c_len;\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "cfg_check_clique": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "void cfg_check_clique(CFG *G, int c_len, const int c_ind[])\n{     int nv = G->nv;\n      int k, kk, v, w, len, *ind;\n      char *flag;\n      ind = talloc(1+nv, int);\n      flag = talloc(1+nv, char);\n      memset(&flag[1], 0, nv);\n      /* walk thru clique vertices */\n      xassert(c_len >= 0);\n      for (k = 1; k <= c_len; k++)\n      {  /* get clique vertex v */\n         v = c_ind[k];\n         xassert(1 <= v && v <= nv);\n         /* get vertices adjacent to vertex v */\n         len = cfg_get_adjacent(G, v, ind);\n         for (kk = 1; kk <= len; kk++)\n         {  w = ind[kk];\n            xassert(1 <= w && w <= nv);\n            xassert(w != v);\n            flag[w] = 1;\n         }\n         /* check that all clique vertices other than v are adjacent\n            to v */\n         for (kk = 1; kk <= c_len; kk++)\n         {  w = c_ind[kk];\n            xassert(1 <= w && w <= nv);\n            if (w != v)\n               xassert(flag[w]);\n         }\n         /* reset vertex flags */\n         for (kk = 1; kk <= len; kk++)\n            flag[ind[kk]] = 0;\n      }\n      tfree(ind);\n      tfree(flag);\n      return;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cfg_delete_graph": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "void cfg_delete_graph(CFG *G)\n{     tfree(G->pos);\n      tfree(G->neg);\n      dmp_delete_pool(G->pool);\n      tfree(G->ref);\n      tfree(G->vptr);\n      tfree(G->cptr);\n      tfree(G);\n      return;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/cfg.h": {},
  "glpk/glpk-4.65/src/intopt/cfg1.c": {
    "fcmp": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static int CDECL fcmp(const void *e1, const void *e2)\n{     /* auxiliary routine called from qsort */\n      const struct term *t1 = e1, *t2 = e2;\n      if (t1->val > t2->val)\n         return -1;\n      else if (t1->val < t2->val)\n         return +1;\n      else\n         return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "analyze_ineq": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "static void analyze_ineq(glp_prob *P, CFG *G, int len, int ind[],\n      double val[], double rhs, struct term t[])\n{     /* analyze inequality constraint (6) */\n      /* P is the original MIP\n       * G is the conflict graph to be built\n       * len is the number of terms in the constraint\n       * ind[1], ..., ind[len] are indices of variables x[j]\n       * val[1], ..., val[len] are constraint coefficients a[j]\n       * rhs is the right-hand side b\n       * t[1+len] is a working array */\n      int j, k, kk, p, q, type, new_len;\n      /* eliminate non-binary variables; see (7) and (8) */\n      new_len = 0;\n      for (k = 1; k <= len; k++)\n      {  /* get index of variable x[j] */\n         j = ind[k];\n         if (is_binary(j))\n         {  /* x[j] remains in relaxed constraint */\n            new_len++;\n            ind[new_len] = j;\n            val[new_len] = val[k];\n         }\n         else if (val[k] > 0.0)\n         {  /* eliminate non-binary x[j] in case a[j] > 0 */\n            /* b := b - a[j] * l[j]; see (8) */\n            type = P->col[j]->type;\n            if (type == GLP_FR || type == GLP_UP)\n            {  /* x[j] has no lower bound */\n               goto done;\n            }\n            rhs -= val[k] * P->col[j]->lb;\n         }\n         else /* val[j] < 0.0 */\n         {  /* eliminate non-binary x[j] in case a[j] < 0 */\n            /* b := b - a[j] * u[j]; see (8) */\n            type = P->col[j]->type;\n            if (type == GLP_FR || type == GLP_LO)\n            {  /* x[j] has no upper bound */\n               goto done;\n            }\n            rhs -= val[k] * P->col[j]->ub;\n         }\n      }\n      len = new_len;\n      /* now we have the constraint (9) */\n      if (len <= 1)\n      {  /* at least two terms are needed */\n         goto done;\n      }\n      /* make all constraint coefficients positive; see (10) */\n      for (k = 1; k <= len; k++)\n      {  if (val[k] < 0.0)\n         {  /* a[j] < 0; substitute x[j] = 1 - x'[j], where x'[j] is\n             * a complement binary variable */\n            ind[k] = -ind[k];\n            val[k] = -val[k];\n            rhs += val[k];\n         }\n      }\n      /* now we have 0-1 knapsack inequality (11) */\n      /* increase the right-hand side a bit to avoid false checks due\n       * to rounding errors */\n      rhs += 0.001 * (1.0 + fabs(rhs));\n      /*** first case ***/\n      /* find two minimal coefficients a[p] and a[q] */\n      p = 0;\n      for (k = 1; k <= len; k++)\n      {  if (p == 0 || val[p] > val[k])\n            p = k;\n      }\n      q = 0;\n      for (k = 1; k <= len; k++)\n      {  if (k != p && (q == 0 || val[q] > val[k]))\n            q = k;\n      }\n      xassert(p != 0 && q != 0 && p != q);\n      /* check condition (14) */\n      if (val[p] + val[q] > rhs)\n      {  /* all z[j] define a clique in the conflict graph */\n         cfg_add_clique(G, len, ind);\n         goto done;\n      }\n      /*** second case ***/\n      /* find two maximal coefficients a[p] and a[q] */\n      p = 0;\n      for (k = 1; k <= len; k++)\n      {  if (p == 0 || val[p] < val[k])\n            p = k;\n      }\n      q = 0;\n      for (k = 1; k <= len; k++)\n      {  if (k != p && (q == 0 || val[q] < val[k]))\n            q = k;\n      }\n      xassert(p != 0 && q != 0 && p != q);\n      /* check condition (18) */\n      if (val[p] + val[q] <= rhs)\n      {  /* no valid edge inequalities exist */\n         goto done;\n      }\n      /*** third case ***/\n      xassert(len >= 3);\n      /* sort terms in descending order of coefficient values */\n      for (k = 1; k <= len; k++)\n      {  t[k].ind = ind[k];\n         t[k].val = val[k];\n      }\n      qsort(&t[1], len, sizeof(struct term), fcmp);\n      for (k = 1; k <= len; k++)\n      {  ind[k] = t[k].ind;\n         val[k] = t[k].val;\n      }\n      /* now a[1] >= a[2] >= ... >= a[len-1] >= a[len] */\n      /* note that a[1] + a[2] > b and a[len-1] + a[len] <= b due two\n       * the former two cases */\n      xassert(val[1] + val[2] > rhs);\n      xassert(val[len-1] + val[len] <= rhs);\n      /* find p according to conditions (20) and (21) */\n      for (p = 2; p < len; p++)\n      {  if (val[p] + val[p+1] <= rhs)\n            break;\n      }\n      xassert(p < len);\n      /* z[1], ..., z[p] define a clique in the conflict graph */\n      cfg_add_clique(G, p, ind);\n      /* discover other edge inequalities */\n      for (k = 1; k <= p; k++)\n      {  for (kk = p; kk <= len; kk++)\n         {  if (k != kk && val[k] + val[kk] > rhs)\n            {  int iii[1+2];\n               iii[1] = ind[k];\n               iii[2] = ind[kk];\n               cfg_add_clique(G, 2, iii);\n            }\n         }\n      }\ndone: return;\n}",
      "lines": 138,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cfg_build_graph": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "CFG *cfg_build_graph(void *P_)\n{     glp_prob *P = P_;\n      int m = P->m;\n      int n = P->n;\n      CFG *G;\n      int i, k, type, len, *ind;\n      double *val;\n      struct term *t;\n      /* create the conflict graph (number of its vertices cannot be\n       * greater than double number of binary variables) */\n      G = cfg_create_graph(n, 2 * glp_get_num_bin(P));\n      /* allocate working arrays */\n      ind = talloc(1+n, int);\n      val = talloc(1+n, double);\n      t = talloc(1+n, struct term);\n      /* analyze constraints to discover edge inequalities */\n      for (i = 1; i <= m; i++)\n      {  type = P->row[i]->type;\n         if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\n         {  /* i-th row has lower bound */\n            /* analyze inequality sum (-a[j]) * x[j] <= -lb */\n            len = glp_get_mat_row(P, i, ind, val);\n            for (k = 1; k <= len; k++)\n               val[k] = -val[k];\n            analyze_ineq(P, G, len, ind, val, -P->row[i]->lb, t);\n         }\n         if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\n         {  /* i-th row has upper bound */\n            /* analyze inequality sum (+a[j]) * x[j] <= +ub */\n            len = glp_get_mat_row(P, i, ind, val);\n            analyze_ineq(P, G, len, ind, val, +P->row[i]->ub, t);\n         }\n      }\n      /* free working arrays */\n      tfree(ind);\n      tfree(val);\n      tfree(t);\n      return G;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "CFG",
        "*cfg_build_graph(void *P_)",
        "*"
      ]
    },
    "build_subgraph": {
      "start_point": [
        456,
        0
      ],
      "end_point": [
        529,
        1
      ],
      "content": "static void build_subgraph(struct csa *csa)\n{     /* build induced subgraph */\n      glp_prob *P = csa->P;\n      int n = P->n;\n      CFG *G = csa->G;\n      int *ind = csa->ind;\n      int *pos = G->pos;\n      int *neg = G->neg;\n      int nv = G->nv;\n      int *ref = G->ref;\n      int *vtoi = csa->vtoi;\n      int *itov = csa->itov;\n      double *wgt = csa->wgt;\n      int j, k, v, w, nn, len;\n      double z, sum;\n      /* initially induced subgraph is empty */\n      nn = 0;\n      /* walk thru vertices of original conflict graph */\n      for (v = 1; v <= nv; v++)\n      {  /* determine value of binary variable z[j] that corresponds to\n          * vertex v */\n         j = ref[v];\n         xassert(1 <= j && j <= n);\n         if (pos[j] == v)\n         {  /* z[j] = x[j], where x[j] is original variable */\n            z = P->col[j]->prim;\n         }\n         else if (neg[j] == v)\n         {  /* z[j] = 1 - x[j], where x[j] is original variable */\n            z = 1.0 - P->col[j]->prim;\n         }\n         else\n            xassert(v != v);\n         /* if z[j] is close to zero, do not include v in the induced\n          * subgraph */\n         if (z < 0.001)\n         {  vtoi[v] = 0;\n            continue;\n         }\n         /* calculate cumulative weight of vertex v */\n         sum = z;\n         /* walk thru all vertices adjacent to v */\n         len = cfg_get_adjacent(G, v, ind);\n         for (k = 1; k <= len; k++)\n         {  /* there is an edge (v,w) in the conflict graph */\n            w = ind[k];\n            xassert(w != v);\n            /* add value of z[j] that corresponds to vertex w */\n            j = ref[w];\n            xassert(1 <= j && j <= n);\n            if (pos[j] == w)\n               sum += P->col[j]->prim;\n            else if (neg[j] == w)\n               sum += 1.0 - P->col[j]->prim;\n            else\n               xassert(w != w);\n         }\n         /* cumulative weight of vertex v is an upper bound of weight\n          * of any clique containing v; so if it not greater than 1, do\n          * not include v in the induced subgraph */\n         if (sum < 1.010)\n         {  vtoi[v] = 0;\n            continue;\n         }\n         /* include vertex v in the induced subgraph */\n         nn++;\n         vtoi[v] = nn;\n         itov[nn] = v;\n         wgt[nn] = z;\n      }\n      /* induced subgraph has been built */\n      csa->nn = nn;\n      return;\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sub_adjacent": {
      "start_point": [
        531,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static int sub_adjacent(struct csa *csa, int i, int adj[])\n{     /* retrieve vertices of induced subgraph adjacent to specified\n       * vertex */\n      CFG *G = csa->G;\n      int nv = G->nv;\n      int *ind = csa->ind;\n      int nn = csa->nn;\n      int *vtoi = csa->vtoi;\n      int *itov = csa->itov;\n      int j, k, v, w, len, len1;\n      /* determine original vertex v corresponding to vertex i */\n      xassert(1 <= i && i <= nn);\n      v = itov[i];\n      /* retrieve vertices adjacent to vertex v in original graph */\n      len1 = cfg_get_adjacent(G, v, ind);\n      /* keep only adjacent vertices which are in induced subgraph and\n       * change their numbers appropriately */\n      len = 0;\n      for (k = 1; k <= len1; k++)\n      {  /* there exists edge (v, w) in original graph */\n         w = ind[k];\n         xassert(1 <= w && w <= nv && w != v);\n         j = vtoi[w];\n         if (j != 0)\n         {  /* vertex w is vertex j in induced subgraph */\n            xassert(1 <= j && j <= nn && j != i);\n            adj[++len] = j;\n         }\n      }\n      return len;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_clique": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "static int find_clique(struct csa *csa, int c_ind[])\n{     /* find maximum weight clique in induced subgraph with exact\n       * Ostergard's algorithm */\n      int nn = csa->nn;\n      double *wgt = csa->wgt;\n      int i, j, k, p, q, t, ne, nb, len, *iwt, *ind;\n      unsigned char *a;\n      xassert(nn >= 2);\n      /* allocate working array */\n      ind = talloc(1+nn, int);\n      /* calculate the number of elements in lower triangle (without\n       * diagonal) of adjacency matrix of induced subgraph */\n      ne = (nn * (nn - 1)) / 2;\n      /* calculate the number of bytes needed to store lower triangle\n       * of adjacency matrix */\n      nb = (ne + (CHAR_BIT - 1)) / CHAR_BIT;\n      /* allocate lower triangle of adjacency matrix */\n      a = talloc(nb, unsigned char);\n      /* fill lower triangle of adjacency matrix */\n      memset(a, 0, nb);\n      for (p = 1; p <= nn; p++)\n      {  /* retrieve vertices adjacent to vertex p */\n         len = sub_adjacent(csa, p, ind);\n         for (k = 1; k <= len; k++)\n         {  /* there exists edge (p, q) in induced subgraph */\n            q = ind[k];\n            xassert(1 <= q && q <= nn && q != p);\n            /* determine row and column indices of this edge in lower\n             * triangle of adjacency matrix */\n            if (p > q)\n               i = p, j = q;\n            else /* p < q */\n               i = q, j = p;\n            /* set bit a[i,j] to 1, i > j */\n            t = ((i - 1) * (i - 2)) / 2 + (j - 1);\n            a[t / CHAR_BIT] |=\n               (unsigned char)(1 << ((CHAR_BIT - 1) - t % CHAR_BIT));\n         }\n      }\n      /* scale vertex weights by 1000 and convert them to integers as\n       * required by Ostergard's algorithm */\n      iwt = ind;\n      for (i = 1; i <= nn; i++)\n      {  /* it is assumed that 0 <= wgt[i] <= 1 */\n         t = (int)(1000.0 * wgt[i] + 0.5);\n         if (t < 0)\n            t = 0;\n         else if (t > 1000)\n            t = 1000;\n         iwt[i] = t;\n      }\n      /* find maximum weight clique */\n      len = wclique(nn, iwt, a, c_ind);\n      /* free working arrays */\n      tfree(ind);\n      tfree(a);\n      /* return clique size to calling routine */\n      return len;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "func": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        628,
        1
      ],
      "content": "static int func(void *info, int i, int ind[])\n{     /* auxiliary routine used by routine find_clique1 */\n      struct csa *csa = info;\n      xassert(1 <= i && i <= csa->nn);\n      return sub_adjacent(csa, i, ind);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_clique1": {
      "start_point": [
        630,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "static int find_clique1(struct csa *csa, int c_ind[])\n{     /* find maximum weight clique in induced subgraph with greedy\n       * heuristic */\n      int nn = csa->nn;\n      double *wgt = csa->wgt;\n      int len;\n      xassert(nn >= 2);\n      len = wclique1(nn, wgt, func, csa, c_ind);\n      /* return clique size to calling routine */\n      return len;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cfg_find_clique": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "int cfg_find_clique(void *P, CFG *G, int ind[], double *sum_)\n{     int nv = G->nv;\n      struct csa csa;\n      int i, k, len;\n      double sum;\n      /* initialize common storage area */\n      csa.P = P;\n      csa.G = G;\n      csa.ind = talloc(1+nv, int);\n      csa.nn = -1;\n      csa.vtoi = talloc(1+nv, int);\n      csa.itov = talloc(1+nv, int);\n      csa.wgt = talloc(1+nv, double);\n      /* build induced subgraph */\n      build_subgraph(&csa);\n#ifdef GLP_DEBUG\n      xprintf(\"nn = %d\\n\", csa.nn);\n#endif\n      /* if subgraph has less than two vertices, do nothing */\n      if (csa.nn < 2)\n      {  len = 0;\n         sum = 0.0;\n         goto skip;\n      }\n      /* find maximum weight clique in induced subgraph */\n#if 1 /* FIXME */\n      if (csa.nn <= 50)\n#endif\n      {  /* induced subgraph is small; use exact algorithm */\n         len = find_clique(&csa, ind);\n      }\n      else\n      {  /* induced subgraph is large; use greedy heuristic */\n         len = find_clique1(&csa, ind);\n      }\n      /* do not report clique, if it has less than two vertices */\n      if (len < 2)\n      {  len = 0;\n         sum = 0.0;\n         goto skip;\n      }\n      /* convert indices of clique vertices from induced subgraph to\n       * original conflict graph and compute clique weight */\n      sum = 0.0;\n      for (k = 1; k <= len; k++)\n      {  i = ind[k];\n         xassert(1 <= i && i <= csa.nn);\n         sum += csa.wgt[i];\n         ind[k] = csa.itov[i];\n      }\nskip: /* free working arrays */\n      tfree(csa.ind);\n      tfree(csa.vtoi);\n      tfree(csa.itov);\n      tfree(csa.wgt);\n      /* return to calling routine */\n      *sum_ = sum;\n      return len;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/cfg2.c": {
    "glp_cfg_init": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "glp_cfg *glp_cfg_init(glp_prob *P)\n{     glp_cfg *G;\n      int j, n1, n2;\n      xprintf(\"Constructing conflict graph...\\n\");\n      G = cfg_build_graph(P);\n      n1 = n2 = 0;\n      for (j = 1; j <= P->n; j++)\n      {  if (G->pos[j])\n            n1 ++;\n         if (G->neg[j])\n            n2++;\n      }\n      if (n1 == 0 && n2 == 0)\n      {  xprintf(\"No conflicts found\\n\");\n         cfg_delete_graph(G);\n         G = NULL;\n      }\n      else\n         xprintf(\"Conflict graph has %d + %d = %d vertices\\n\",\n            n1, n2, G->nv);\n      return G;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "glp_cfg",
        "*glp_cfg_init(glp_prob *P)",
        "*"
      ]
    },
    "glp_cfg_free": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void glp_cfg_free(glp_cfg *G)\n{     xassert(G != NULL);\n      cfg_delete_graph(G);\n      return;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/clqcut.c": {
    "glp_clq_cut": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int glp_clq_cut(glp_prob *P, glp_cfg *G, int ind[], double val[])\n{     int n = P->n;\n      int *pos = G->pos;\n      int *neg = G->neg;\n      int nv = G->nv;\n      int *ref = G->ref;\n      int j, k, v, len;\n      double rhs, sum;\n      xassert(G->n == n);\n      /* find maximum weight clique in conflict graph */\n      len = cfg_find_clique(P, G, ind, &sum);\n#ifdef GLP_DEBUG\n      xprintf(\"len = %d; sum = %g\\n\", len, sum);\n      cfg_check_clique(G, len, ind);\n#endif\n      /* check if clique inequality is violated */\n      if (sum < 1.07)\n         return 0;\n      /* expand clique to maximal one */\n      len = cfg_expand_clique(G, len, ind);\n#ifdef GLP_DEBUG\n      xprintf(\"maximal clique size = %d\\n\", len);\n      cfg_check_clique(G, len, ind);\n#endif\n      /* construct clique cut (fixed binary variables are removed, so\n         this cut is only locally valid) */\n      rhs = 1.0;\n      for (j = 1; j <= n; j++)\n         val[j] = 0.0;\n      for (k = 1; k <= len; k++)\n      {  /* v is clique vertex */\n         v = ind[k];\n         xassert(1 <= v && v <= nv);\n         /* j is number of corresponding binary variable */\n         j = ref[v];\n         xassert(1 <= j && j <= n);\n         if (pos[j] == v)\n         {  /* v corresponds to x[j] */\n            if (P->col[j]->type == GLP_FX)\n            {  /* x[j] is fixed */\n               rhs -= P->col[j]->prim;\n            }\n            else\n            {  /* x[j] is not fixed */\n               val[j] += 1.0;\n            }\n         }\n         else if (neg[j] == v)\n         {  /* v corresponds to (1 - x[j]) */\n            if (P->col[j]->type == GLP_FX)\n            {  /* x[j] is fixed */\n               rhs -= (1.0 - P->col[j]->prim);\n            }\n            else\n            {  /* x[j] is not fixed */\n               val[j] -= 1.0;\n               rhs -= 1.0;\n            }\n         }\n         else\n            xassert(v != v);\n      }\n      /* convert cut inequality to sparse format */\n      len = 0;\n      for (j = 1; j <= n; j++)\n      {  if (val[j] != 0.0)\n         {  len++;\n            ind[len] = j;\n            val[len] = val[j];\n         }\n      }\n      ind[0] = 0, val[0] = rhs;\n      return len;\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/covgen.c": {
    "init_bounds": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void init_bounds(struct csa *csa)\n{     glp_prob *P = csa->P;\n      struct bnd *l = csa->l, *u = csa->u;\n      int j;\n      for (j = 1; j <= P->n; j++)\n      {  l[j].z = u[j].z = 0;\n         l[j].a = u[j].a = 0;\n         l[j].b = glp_get_col_lb(P, j);\n         u[j].b = glp_get_col_ub(P, j);\n      }\n      return;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_vb": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static int check_vb(struct csa *csa, int i, int *x, int *z, double *a,\n      double *b)\n{     glp_prob *P = csa->P;\n      GLPROW *row;\n      GLPAIJ *a1, *a2;\n      int type;\n      double rhs;\n      xassert(1 <= i && i <= P->m);\n      row = P->row[i];\n      /* check row type */\n      switch (row->type)\n      {  case GLP_LO:\n         case GLP_UP:\n            break;\n         default:\n            return 0;\n      }\n      /* take first term of the row */\n      a1 = row->ptr;\n      if (a1 == NULL)\n         return 0;\n      /* take second term of the row */\n      a2 = a1->r_next;\n      if (a2 == NULL)\n         return 0;\n      /* there should be exactly two terms in the row */\n      if (a2->r_next != NULL)\n         return 0;\n      /* if first term is a binary variable, swap the terms */\n      if (glp_get_col_kind(P, a1->col->j) == GLP_BV)\n      {  GLPAIJ *a;\n         a = a1, a1 = a2, a2 = a;\n      }\n      /* now first term should be a non-fixed continuous or general\n       * integer variable */\n      if (a1->col->type == GLP_FX)\n         return 0;\n      if (glp_get_col_kind(P, a1->col->j) == GLP_BV)\n         return 0;\n      /* and second term should be a binary variable */\n      if (glp_get_col_kind(P, a2->col->j) != GLP_BV)\n         return 0;\n      /* VLB/VUB row has been identified */\n      switch (row->type)\n      {  case GLP_LO:\n            type = a1->val > 0 ? GLP_LO : GLP_UP;\n            rhs = row->lb;\n            break;\n         case GLP_UP:\n            type = a1->val > 0 ? GLP_UP : GLP_LO;\n            rhs = row->ub;\n            break;\n         default:\n            xassert(type != type);\n      }\n      *x = a1->col->j;\n      *z = a2->col->j;\n      *a = - a2->val / a1->val;\n      *b = rhs / a1->val;\n      return type;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_vb": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void set_vb(struct csa *csa, int type, int x, int z, double a,\n      double b)\n{     glp_prob *P = csa->P;\n      struct bnd *l = csa->l, *u = csa->u;\n      xassert(glp_get_col_type(P, x) != GLP_FX);\n      xassert(glp_get_col_kind(P, x) != GLP_BV);\n      xassert(glp_get_col_kind(P, z) == GLP_BV);\n      xassert(a != 0);\n      switch (type)\n      {  case GLP_LO:\n            /* FIXME: check existing simple lower bound? */\n            l[x].z = z, l[x].a = a, l[x].b = b;\n            break;\n         case GLP_UP:\n            /* FIXME: check existing simple upper bound? */\n            u[x].z = z, u[x].a = a, u[x].b = b;\n            break;\n         default:\n            xassert(type != type);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "obtain_vbs": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static void obtain_vbs(struct csa *csa)\n{     glp_prob *P = csa->P;\n      int i, x, z, type, save;\n      double a, b;\n      for (i = 1; i <= P->m; i++)\n      {  switch (P->row[i]->type)\n         {  case GLP_FR:\n               break;\n            case GLP_LO:\n            case GLP_UP:\n               type = check_vb(csa, i, &x, &z, &a, &b);\n               if (type)\n                  set_vb(csa, type, x, z, a, b);\n               break;\n            case GLP_DB:\n            case GLP_FX:\n               /* double-side inequality l <= ... <= u and equality\n                * ... = l = u are considered as two single inequalities\n                * ... >= l and ... <= u */\n               save = P->row[i]->type;\n               P->row[i]->type = GLP_LO;\n               type = check_vb(csa, i, &x, &z, &a, &b);\n               if (type)\n                  set_vb(csa, type, x, z, a, b);\n               P->row[i]->type = GLP_UP;\n               type = check_vb(csa, i, &x, &z, &a, &b);\n               if (type)\n                  set_vb(csa, type, x, z, a, b);\n               P->row[i]->type = save;\n               break;\n            default:\n               xassert(P != P);\n         }\n      }\n      return;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_term": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static void add_term(FVS *v, int j, double a)\n{     xassert(1 <= j && j <= v->n);\n      xassert(a != 0);\n      if (v->vec[j] == 0)\n      {  /* create j-th component */\n         v->nnz++;\n         xassert(v->nnz <= v->n);\n         v->ind[v->nnz] = j;\n      }\n      /* perform addition */\n      v->vec[j] += a;\n      if (fabs(v->vec[j]) < 1e-9 * (1 + fabs(a)))\n      {  /* remove j-th component */\n         v->vec[j] = DBL_MIN;\n      }\n      return;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_ks": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "static int build_ks(struct csa *csa, int n, int ind[], double a[],\n      double *b, FVS *v)\n{     glp_prob *P = csa->P;\n      struct bnd *l = csa->l, *u = csa->u;\n      int j, k;\n      /* check that v = 0 */\n#ifdef GLP_DEBUG\n      fvs_check_vec(v);\n#endif\n      xassert(v->nnz == 0);\n      /* walk thru terms of original inequality */\n      for (j = 1; j <= n; j++)\n      {  /* process term a[j]*x[j] */\n         k = ind[j]; /* original number of x[j] in mip */\n         if (glp_get_col_kind(P, k) == GLP_BV)\n         {  /* x[j] is a binary variable */\n            /* include its term into resulting inequality */\n            add_term(v, k, a[j]);\n         }\n         else if (a[j] > 0)\n         {  /* substitute x[j] by its lower bound */\n            if (l[k].b == -DBL_MAX)\n            {  /* x[j] has no lower bound */\n               n = -1;\n               goto skip;\n            }\n            else if (l[k].z == 0)\n            {  /* x[j] has simple lower bound */\n               *b -= a[j] * l[k].b;\n            }\n            else\n            {  /* x[j] has variable lower bound (a * z + b) */\n               add_term(v, l[k].z, a[j] * l[k].a);\n               *b -= a[j] * l[k].b;\n            }\n         }\n         else /* a[j] < 0 */\n         {  /* substitute x[j] by its upper bound */\n            if (u[k].b == +DBL_MAX)\n            {  /* x[j] has no upper bound */\n               n = -1;\n               goto skip;\n            }\n            else if (u[k].z == 0)\n            {  /* x[j] has simple upper bound */\n               *b -= a[j] * u[k].b;\n            }\n            else\n            {  /* x[j] has variable upper bound (a * z + b) */\n               add_term(v, u[k].z, a[j] * u[k].a);\n               *b -= a[j] * u[k].b;\n            }\n         }\n      }\n      /* replace tiny coefficients by exact zeros (see add_term) */\n      fvs_adjust_vec(v, 2 * DBL_MIN);\n      /* copy terms of resulting inequality */\n      xassert(v->nnz <= n);\n      n = v->nnz;\n      for (j = 1; j <= n; j++)\n      {  ind[j] = v->ind[j];\n         a[j] = v->vec[ind[j]];\n      }\nskip: /* restore zero content of v */\n      fvs_clear_vec(v);\n      return n;\n}",
      "lines": 67,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "can_be_active": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "static int can_be_active(int n, const double a[], double b)\n{     int j;\n      double s;\n      s = 0;\n      for (j = 1; j <= n; j++)\n      {  if (a[j] > 0)\n            s += a[j];\n      }\n      return s > b + .001 * (1 + fabs(b));\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_sos_ineq": {
      "start_point": [
        430,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "static int is_sos_ineq(int n, const double a[], double b)\n{     int j, p, q;\n      xassert(n >= 2);\n      /* compute b := b - sum{j : a[j] < 0} */\n      for (j = 1; j <= n; j++)\n      {  if (a[j] < 0)\n            b -= a[j];\n      }\n      /* find a[p] = min{j in 1..n} a[j] */\n      p = 1;\n      for (j = 2; j <= n; j++)\n      {  if (fabs(a[p]) > fabs(a[j]))\n            p = j;\n      }\n      /* find a[q] = min{j in 1..n : j != p} a[j] */\n      q = 0;\n      for (j = 1; j <= n; j++)\n      {  if (j != p)\n         {  if (q == 0 || fabs(a[q]) > fabs(a[j]))\n               q = j;\n         }\n      }\n      xassert(q != 0);\n      /* check condition a[p] + a[q] > b */\n      return fabs(a[p]) + fabs(a[q]) > b + .001 * (1 + fabs(b));\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_ineq": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static void process_ineq(struct csa *csa, int n, int ind[], double a[],\n      double b, FVS *v)\n{     int i;\n      /* attempt to transform the specified inequality to equivalent or\n       * relaxed \"0-1 knapsack\" inequality */\n      n = build_ks(csa, n, ind, a, &b, v);\n      if (n <= 1)\n      {  /* uninteresting inequality (in principle, such inequalities\n          * should be removed by the preprocessor) */\n         goto done;\n      }\n      if (!can_be_active(n, a, b))\n      {  /* inequality is redundant (i.e. cannot be active) */\n         goto done;\n      }\n      if (is_sos_ineq(n, a, b))\n      {  /* packing (SOS) inequality is useless for generating cover\n          * cuts; currently such inequalities are just ignored */\n         goto done;\n      }\n      /* add resulting \"0-1 knapsack\" inequality to the set */\n      i = glp_add_rows(csa->set, 1);\n      glp_set_mat_row(csa->set, i, n, ind, a);\n      glp_set_row_bnds(csa->set, i, GLP_UP, b, b);\ndone: return;\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_cov_init": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        594,
        1
      ],
      "content": "glp_cov *glp_cov_init(glp_prob *P)\n{     /* create and initialize cover cut generator */\n      glp_cov *cov;\n      struct csa csa;\n      int i, k, len, *ind;\n      double rhs, *val;\n      FVS fvs;\n      csa.P = P;\n      csa.l = talloc(1+P->n, struct bnd);\n      csa.u = talloc(1+P->n, struct bnd);\n      csa.set = glp_create_prob();\n      glp_add_cols(csa.set, P->n);\n      /* initialize bounds of variables with simple bounds */\n      init_bounds(&csa);\n      /* obtain and set variable bounds */\n      obtain_vbs(&csa);\n      /* allocate working arrays */\n      ind = talloc(1+P->n, int);\n      val = talloc(1+P->n, double);\n      fvs_alloc_vec(&fvs, P->n);\n      /* process all rows of the root mip */\n      for (i = 1; i <= P->m; i++)\n      {  switch (P->row[i]->type)\n         {  case GLP_FR:\n               break;\n            case GLP_LO:\n               /* obtain row of \">=\" type */\n               len = glp_get_mat_row(P, i, ind, val);\n               rhs = P->row[i]->lb;\n               /* transforms it to row of \"<=\" type */\n               for (k = 1; k <= len; k++)\n                  val[k] = - val[k];\n               rhs = - rhs;\n               /* process the row */\n               process_ineq(&csa, len, ind, val, rhs, &fvs);\n               break;\n            case GLP_UP:\n               /* obtain row of \"<=\" type */\n               len = glp_get_mat_row(P, i, ind, val);\n               rhs = P->row[i]->ub;\n               /* and process it */\n               process_ineq(&csa, len, ind, val, rhs, &fvs);\n               break;\n            case GLP_DB:\n            case GLP_FX:\n               /* double-sided inequalitiy and equality constraints are\n                * processed as two separate inequalities */\n               /* obtain row as if it were of \">=\" type */\n               len = glp_get_mat_row(P, i, ind, val);\n               rhs = P->row[i]->lb;\n               /* transforms it to row of \"<=\" type */\n               for (k = 1; k <= len; k++)\n                  val[k] = - val[k];\n               rhs = - rhs;\n               /* and process it */\n               process_ineq(&csa, len, ind, val, rhs, &fvs);\n               /* obtain the same row as if it were of \"<=\" type */\n               len = glp_get_mat_row(P, i, ind, val);\n               rhs = P->row[i]->ub;\n               /* and process it */\n               process_ineq(&csa, len, ind, val, rhs, &fvs);\n               break;\n            default:\n               xassert(P != P);\n         }\n      }\n      /* free working arrays */\n      tfree(ind);\n      tfree(val);\n      fvs_check_vec(&fvs);\n      fvs_free_vec(&fvs);\n      /* the set of \"0-1 knapsack\" inequalities has been built */\n      if (csa.set->m == 0)\n      {  /* the set is empty */\n         xprintf(\"No 0-1 knapsack inequalities detected\\n\");\n         cov = NULL;\n         glp_delete_prob(csa.set);\n      }\n      else\n      {  /* create the cover cut generator working area */\n         xprintf(\"Number of 0-1 knapsack inequalities = %d\\n\",\n            csa.set->m);\n         cov = talloc(1, glp_cov);\n         cov->n = P->n;\n         cov->set = csa.set;\n#if 0\n         glp_write_lp(cov->set, 0, \"set.lp\");\n#endif\n      }\n      tfree(csa.l);\n      tfree(csa.u);\n      return cov;\n}",
      "lines": 93,
      "depth": 13,
      "decorators": [
        "glp_cov",
        "*glp_cov_init(glp_prob *P)",
        "*"
      ]
    },
    "solve_ks": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        629,
        1
      ],
      "content": "static int solve_ks(int n, const int a[], int b, const int c[],\n      char x[])\n{     int z;\n      /* surprisingly, even for some small instances (n = 50-100)\n       * MT1 routine takes too much time, so it is used only for tiny\n       * instances */\n      if (n <= 16)\n#if 0\n         z = ks_enum(n, a, b, c, x);\n#else\n         z = ks_mt1(n, a, b, c, x);\n#endif\n      else\n         z = ks_greedy(n, a, b, c, x);\n      return z;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "simple_cover": {
      "start_point": [
        706,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "static double simple_cover(int n, const double a[], double b, const\n      double x[], char z[])\n{     int j, *aa, bb, *cc;\n      double max_aj, min_aj, s, eps;\n      xassert(n >= 3);\n      /* allocate working arrays */\n      aa = talloc(1+n, int);\n      cc = talloc(1+n, int);\n      /* compute max{j in 1..n} a[j] and min{j in 1..n} a[j] */\n      max_aj = 0, min_aj = DBL_MAX;\n      for (j = 1; j <= n; j++)\n      {  xassert(a[j] > 0);\n         if (max_aj < a[j])\n            max_aj = a[j];\n         if (min_aj > a[j])\n            min_aj = a[j];\n      }\n      /* scale and round constraint parameters to make them integral;\n       * note that we make the resulting inequality stronger than (11),\n       * so a[j]'s are rounded up while rhs is rounded down */\n      s = 0;\n      for (j = 1; j <= n; j++)\n      {  s += a[j];\n         aa[j] = ceil(a[j] / max_aj * 1000);\n      }\n      bb = floor((s - b) / max_aj * 1000) - 1;\n      /* scale and round obj. coefficients to make them integral;\n       * again we make the objective function stronger than (10), so\n       * the coefficients are rounded down */\n      for (j = 1; j <= n; j++)\n      {  xassert(0 <= x[j] && x[j] <= 1);\n         cc[j] = floor((1 - x[j]) * 1000);\n      }\n      /* solve separation problem */\n      if (solve_ks(n, aa, bb, cc, z) == INT_MIN)\n      {  /* no cover exists */\n         s = DBL_MAX;\n         goto skip;\n      }\n      /* determine z[j] = 1 - z'[j] */\n      for (j = 1; j <= n; j++)\n      {  xassert(z[j] == 0 || z[j] == 1);\n         z[j] ^= 1;\n      }\n      /* check condition (11) for original (non-scaled) parameters */\n      s = 0;\n      for (j = 1; j <= n; j++)\n      {  if (z[j])\n            s += a[j];\n      }\n      eps = 0.01 * (min_aj >= 1 ? min_aj : 1);\n      if (!(s >= b + eps))\n      {  /* no cover found within a precision req'd */\n         s = DBL_MAX;\n         goto skip;\n      }\n      /* compute corresponding zeta (4) for cover found */\n      s = 0;\n      for (j = 1; j <= n; j++)\n      {  if (z[j])\n            s += 1 - x[j];\n      }\nskip: /* free working arrays */\n      tfree(aa);\n      tfree(cc);\n      return s;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "glp_cov_gen1": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "void glp_cov_gen1(glp_prob *P, glp_cov *cov, glp_prob *pool)\n{     /* generate locally valid simple cover cuts */\n      int i, k, len, new_len, *ind;\n      double *val, rhs, *x, zeta;\n      char *z;\n      xassert(P->n == cov->n && P->n == cov->set->n);\n      xassert(glp_get_status(P) == GLP_OPT);\n      /* allocate working arrays */\n      ind = talloc(1+P->n, int);\n      val = talloc(1+P->n, double);\n      x = talloc(1+P->n, double);\n      z = talloc(1+P->n, char);\n      /* walk thru 0-1 knapsack inequalities */\n      for (i = 1; i <= cov->set->m; i++)\n      {  /* retrieve 0-1 knapsack inequality */\n         len = glp_get_mat_row(cov->set, i, ind, val);\n         rhs = glp_get_row_ub(cov->set, i);\n         xassert(rhs != +DBL_MAX);\n         /* FIXME: skip, if slack is too large? */\n         /* substitute and eliminate binary variables which have been\n          * fixed in the current subproblem (this makes the inequality\n          * only locally valid) */\n         new_len = 0;\n         for (k = 1; k <= len; k++)\n         {  if (glp_get_col_type(P, ind[k]) == GLP_FX)\n               rhs -= val[k] * glp_get_col_prim(P, ind[k]);\n            else\n            {  new_len++;\n               ind[new_len] = ind[k];\n               val[new_len] = val[k];\n            }\n         }\n         len = new_len;\n         /* we need at least 3 binary variables in the inequality */\n         if (len <= 2)\n            continue;\n         /* obtain values of binary variables from optimal solution to\n          * LP relaxation of current subproblem */\n         for (k = 1; k <= len; k++)\n         {  xassert(glp_get_col_kind(P, ind[k]) == GLP_BV);\n            x[k] = glp_get_col_prim(P, ind[k]);\n            if (x[k] < 0.00001)\n               x[k] = 0;\n            else if (x[k] > 0.99999)\n               x[k] = 1;\n            /* if val[k] < 0, perform substitution x[k] = 1 - x'[k] to\n             * make all coefficients positive */\n            if (val[k] < 0)\n            {  ind[k] = - ind[k]; /* x[k] is complemented */\n               val[k] = - val[k];\n               rhs += val[k];\n               x[k] = 1 - x[k];\n            }\n         }\n         /* find locally valid simple cover cut */\n         zeta = simple_cover(len, val, rhs, x, z);\n         if (zeta > 0.95)\n         {  /* no violation or insufficient violation; see (2) */\n            continue;\n         }\n         /* construct cover inequality (2) for the cover found, which\n          * for original binary variables x[k] is equivalent to:\n          *    sum{k in C'} x[k] + sum{k in C\"} x'[k] <= |C| - 1\n          * or\n          *    sum{k in C'} x[k] + sum{k in C\"} (1 - x[k]) <= |C| - 1\n          * or\n          *    sum{k in C'} x[k] - sum{k in C\"} x[k] <= |C'| - 1\n          * since |C| - |C\"| = |C'| */\n         new_len = 0;\n         rhs = -1;\n         for (k = 1; k <= len; k++)\n         {  if (z[k])\n            {  new_len++;\n               if (ind[k] > 0)\n               {  ind[new_len] = +ind[k];\n                  val[new_len] = +1;\n                  rhs++;\n               }\n               else /* ind[k] < 0 */\n               {  ind[new_len] = -ind[k];\n                  val[new_len] = -1;\n               }\n            }\n         }\n         len = new_len;\n         /* add the cover inequality to the local cut pool */\n         k = glp_add_rows(pool, 1);\n         glp_set_mat_row(pool, k, len, ind, val);\n         glp_set_row_bnds(pool, k, GLP_UP, rhs, rhs);\n      }\n      /* free working arrays */\n      tfree(ind);\n      tfree(val);\n      tfree(x);\n      tfree(z);\n      return;\n}",
      "lines": 97,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "glp_cov_free": {
      "start_point": [
        876,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "void glp_cov_free(glp_cov *cov)\n{     /* delete cover cut generator workspace */\n      xassert(cov != NULL);\n      glp_delete_prob(cov->set);\n      tfree(cov);\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/fpump.c": {
    "fcmp": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int CDECL fcmp(const void *x, const void *y)\n{     /* comparison routine */\n      const struct VAR *vx = x, *vy = y;\n      if (vx->d > vy->d)\n         return -1;\n      else if (vx->d < vy->d)\n         return +1;\n      else\n         return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "ios_feas_pump": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "void ios_feas_pump(glp_tree *T)\n{     glp_prob *P = T->mip;\n      int n = P->n;\n      glp_prob *lp = NULL;\n      struct VAR *var = NULL;\n      RNG *rand = NULL;\n      GLPCOL *col;\n      glp_smcp parm;\n      int j, k, new_x, nfail, npass, nv, ret, stalling;\n      double dist, tol;\n      xassert(glp_get_status(P) == GLP_OPT);\n      /* this heuristic is applied only once on the root level */\n      if (!(T->curr->level == 0 && T->curr->solved == 1)) goto done;\n      /* determine number of binary variables */\n      nv = 0;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         /* if x[j] is continuous, skip it */\n         if (col->kind == GLP_CV) continue;\n         /* if x[j] is fixed, skip it */\n         if (col->type == GLP_FX) continue;\n         /* x[j] is non-fixed integer */\n         xassert(col->kind == GLP_IV);\n         if (col->type == GLP_DB && col->lb == 0.0 && col->ub == 1.0)\n         {  /* x[j] is binary */\n            nv++;\n         }\n         else\n         {  /* x[j] is general integer */\n            if (T->parm->msg_lev >= GLP_MSG_ALL)\n               xprintf(\"FPUMP heuristic cannot be applied due to genera\"\n                  \"l integer variables\\n\");\n            goto done;\n         }\n      }\n      /* there must be at least one binary variable */\n      if (nv == 0) goto done;\n      if (T->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Applying FPUMP heuristic...\\n\");\n      /* build the list of binary variables */\n      var = xcalloc(1+nv, sizeof(struct VAR));\n      k = 0;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         if (col->kind == GLP_IV && col->type == GLP_DB)\n            var[++k].j = j;\n      }\n      xassert(k == nv);\n      /* create working problem object */\n      lp = glp_create_prob();\nmore: /* copy the original problem object to keep it intact */\n      glp_copy_prob(lp, P, GLP_OFF);\n      /* we are interested to find an integer feasible solution, which\n         is better than the best known one */\n      if (P->mip_stat == GLP_FEAS)\n      {  int *ind;\n         double *val, bnd;\n         /* add a row and make it identical to the objective row */\n         glp_add_rows(lp, 1);\n         ind = xcalloc(1+n, sizeof(int));\n         val = xcalloc(1+n, sizeof(double));\n         for (j = 1; j <= n; j++)\n         {  ind[j] = j;\n            val[j] = P->col[j]->coef;\n         }\n         glp_set_mat_row(lp, lp->m, n, ind, val);\n         xfree(ind);\n         xfree(val);\n         /* introduce upper (minimization) or lower (maximization)\n            bound to the original objective function; note that this\n            additional constraint is not violated at the optimal point\n            to LP relaxation */\n#if 0 /* modified by xypron <xypron.glpk@gmx.de> */\n         if (P->dir == GLP_MIN)\n         {  bnd = P->mip_obj - 0.10 * (1.0 + fabs(P->mip_obj));\n            if (bnd < P->obj_val) bnd = P->obj_val;\n            glp_set_row_bnds(lp, lp->m, GLP_UP, 0.0, bnd - P->c0);\n         }\n         else if (P->dir == GLP_MAX)\n         {  bnd = P->mip_obj + 0.10 * (1.0 + fabs(P->mip_obj));\n            if (bnd > P->obj_val) bnd = P->obj_val;\n            glp_set_row_bnds(lp, lp->m, GLP_LO, bnd - P->c0, 0.0);\n         }\n         else\n            xassert(P != P);\n#else\n         bnd = 0.1 * P->obj_val + 0.9 * P->mip_obj;\n         /* xprintf(\"bnd = %f\\n\", bnd); */\n         if (P->dir == GLP_MIN)\n            glp_set_row_bnds(lp, lp->m, GLP_UP, 0.0, bnd - P->c0);\n         else if (P->dir == GLP_MAX)\n            glp_set_row_bnds(lp, lp->m, GLP_LO, bnd - P->c0, 0.0);\n         else\n            xassert(P != P);\n#endif\n      }\n      /* reset pass count */\n      npass = 0;\n      /* invalidate the rounded point */\n      for (k = 1; k <= nv; k++)\n         var[k].x = -1;\npass: /* next pass starts here */\n      npass++;\n      if (T->parm->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Pass %d\\n\", npass);\n      /* initialize minimal distance between the basic point and the\n         rounded one obtained during this pass */\n      dist = DBL_MAX;\n      /* reset failure count (the number of succeeded iterations failed\n         to improve the distance) */\n      nfail = 0;\n      /* if it is not the first pass, perturb the last rounded point\n         rather than construct it from the basic solution */\n      if (npass > 1)\n      {  double rho, temp;\n         if (rand == NULL)\n            rand = rng_create_rand();\n         for (k = 1; k <= nv; k++)\n         {  j = var[k].j;\n            col = lp->col[j];\n            rho = rng_uniform(rand, -0.3, 0.7);\n            if (rho < 0.0) rho = 0.0;\n            temp = fabs((double)var[k].x - col->prim);\n            if (temp + rho > 0.5) var[k].x = 1 - var[k].x;\n         }\n         goto skip;\n      }\nloop: /* innermost loop begins here */\n      /* round basic solution (which is assumed primal feasible) */\n      stalling = 1;\n      for (k = 1; k <= nv; k++)\n      {  col = lp->col[var[k].j];\n         if (col->prim < 0.5)\n         {  /* rounded value is 0 */\n            new_x = 0;\n         }\n         else\n         {  /* rounded value is 1 */\n            new_x = 1;\n         }\n         if (var[k].x != new_x)\n         {  stalling = 0;\n            var[k].x = new_x;\n         }\n      }\n      /* if the rounded point has not changed (stalling), choose and\n         flip some its entries heuristically */\n      if (stalling)\n      {  /* compute d[j] = |x[j] - round(x[j])| */\n         for (k = 1; k <= nv; k++)\n         {  col = lp->col[var[k].j];\n            var[k].d = fabs(col->prim - (double)var[k].x);\n         }\n         /* sort the list of binary variables by descending d[j] */\n         qsort(&var[1], nv, sizeof(struct VAR), fcmp);\n         /* choose and flip some rounded components */\n         for (k = 1; k <= nv; k++)\n         {  if (k >= 5 && var[k].d < 0.35 || k >= 10) break;\n            var[k].x = 1 - var[k].x;\n         }\n      }\nskip: /* check if the time limit has been exhausted */\n      if (T->parm->tm_lim < INT_MAX &&\n         (double)(T->parm->tm_lim - 1) <=\n         1000.0 * xdifftime(xtime(), T->tm_beg)) goto done;\n      /* build the objective, which is the distance between the current\n         (basic) point and the rounded one */\n      lp->dir = GLP_MIN;\n      lp->c0 = 0.0;\n      for (j = 1; j <= n; j++)\n         lp->col[j]->coef = 0.0;\n      for (k = 1; k <= nv; k++)\n      {  j = var[k].j;\n         if (var[k].x == 0)\n            lp->col[j]->coef = +1.0;\n         else\n         {  lp->col[j]->coef = -1.0;\n            lp->c0 += 1.0;\n         }\n      }\n      /* minimize the distance with the simplex method */\n      glp_init_smcp(&parm);\n      if (T->parm->msg_lev <= GLP_MSG_ERR)\n         parm.msg_lev = T->parm->msg_lev;\n      else if (T->parm->msg_lev <= GLP_MSG_ALL)\n      {  parm.msg_lev = GLP_MSG_ON;\n         parm.out_dly = 10000;\n      }\n      ret = glp_simplex(lp, &parm);\n      if (ret != 0)\n      {  if (T->parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"Warning: glp_simplex returned %d\\n\", ret);\n         goto done;\n      }\n      ret = glp_get_status(lp);\n      if (ret != GLP_OPT)\n      {  if (T->parm->msg_lev >= GLP_MSG_ERR)\n            xprintf(\"Warning: glp_get_status returned %d\\n\", ret);\n         goto done;\n      }\n      if (T->parm->msg_lev >= GLP_MSG_DBG)\n         xprintf(\"delta = %g\\n\", lp->obj_val);\n      /* check if the basic solution is integer feasible; note that it\n         may be so even if the minimial distance is positive */\n      tol = 0.3 * T->parm->tol_int;\n      for (k = 1; k <= nv; k++)\n      {  col = lp->col[var[k].j];\n         if (tol < col->prim && col->prim < 1.0 - tol) break;\n      }\n      if (k > nv)\n      {  /* okay; the basic solution seems to be integer feasible */\n         double *x = xcalloc(1+n, sizeof(double));\n         for (j = 1; j <= n; j++)\n         {  x[j] = lp->col[j]->prim;\n            if (P->col[j]->kind == GLP_IV) x[j] = floor(x[j] + 0.5);\n         }\n#if 1 /* modified by xypron <xypron.glpk@gmx.de> */\n         /* reset direction and right-hand side of objective */\n         lp->c0  = P->c0;\n         lp->dir = P->dir;\n         /* fix integer variables */\n         for (k = 1; k <= nv; k++)\n#if 0 /* 18/VI-2013; fixed by mao\n       * this bug causes numerical instability, because column statuses\n       * are not changed appropriately */\n         {  lp->col[var[k].j]->lb   = x[var[k].j];\n            lp->col[var[k].j]->ub   = x[var[k].j];\n            lp->col[var[k].j]->type = GLP_FX;\n         }\n#else\n            glp_set_col_bnds(lp, var[k].j, GLP_FX, x[var[k].j], 0.);\n#endif\n         /* copy original objective function */\n         for (j = 1; j <= n; j++)\n            lp->col[j]->coef = P->col[j]->coef;\n         /* solve original LP and copy result */\n         ret = glp_simplex(lp, &parm);\n         if (ret != 0)\n         {  if (T->parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"Warning: glp_simplex returned %d\\n\", ret);\n#if 1 /* 17/III-2016: fix memory leak */\n            xfree(x);\n#endif\n            goto done;\n         }\n         ret = glp_get_status(lp);\n         if (ret != GLP_OPT)\n         {  if (T->parm->msg_lev >= GLP_MSG_ERR)\n               xprintf(\"Warning: glp_get_status returned %d\\n\", ret);\n#if 1 /* 17/III-2016: fix memory leak */\n            xfree(x);\n#endif\n            goto done;\n         }\n         for (j = 1; j <= n; j++)\n            if (P->col[j]->kind != GLP_IV) x[j] = lp->col[j]->prim;\n#endif\n         ret = glp_ios_heur_sol(T, x);\n         xfree(x);\n         if (ret == 0)\n         {  /* the integer solution is accepted */\n            if (ios_is_hopeful(T, T->curr->bound))\n            {  /* it is reasonable to apply the heuristic once again */\n               goto more;\n            }\n            else\n            {  /* the best known integer feasible solution just found\n                  is close to optimal solution to LP relaxation */\n               goto done;\n            }\n         }\n      }\n      /* the basic solution is fractional */\n      if (dist == DBL_MAX ||\n          lp->obj_val <= dist - 1e-6 * (1.0 + dist))\n      {  /* the distance is reducing */\n         nfail = 0, dist = lp->obj_val;\n      }\n      else\n      {  /* improving the distance failed */\n         nfail++;\n      }\n      if (nfail < 3) goto loop;\n      if (npass < 5) goto pass;\ndone: /* delete working objects */\n      if (lp != NULL) glp_delete_prob(lp);\n      if (var != NULL) xfree(var);\n      if (rand != NULL) rng_delete_rand(rand);\n      return;\n}",
      "lines": 290,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/gmicut.c": {
    "glp_gmi_cut": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int glp_gmi_cut(glp_prob *P, int j,\n      int ind[/*1+n*/], double val[/*1+n*/], double phi[/*1+m+n*/])\n{     int m = P->m;\n      int n = P->n;\n      GLPROW *row;\n      GLPCOL *col;\n      GLPAIJ *aij;\n      int i, k, len, kind, stat;\n      double lb, ub, alfa, beta, ksi, phi1, rhs;\n      /* sanity checks */\n      if (!(P->m == 0 || P->valid))\n      {  /* current basis factorization is not valid */\n         return -1;\n      }\n      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))\n      {  /* current basic solution is not optimal */\n         return -2;\n      }\n      if (!(1 <= j && j <= n))\n      {  /* column ordinal number is out of range */\n         return -3;\n      }\n      col = P->col[j];\n      if (col->kind != GLP_IV)\n      {  /* x[j] is not of integral kind */\n         return -4;\n      }\n      if (col->type == GLP_FX || col->stat != GLP_BS)\n      {  /* x[j] is either fixed or non-basic */\n         return -5;\n      }\n      if (fabs(col->prim - floor(col->prim + 0.5)) < 0.001)\n      {  /* primal value of x[j] is too close to nearest integer */\n         return -6;\n      }\n      /* compute row of the simplex tableau, which (row) corresponds\n       * to specified basic variable xB[i] = x[j]; see (23) */\n      len = glp_eval_tab_row(P, m+j, ind, val);\n      /* determine beta[i], which a value of xB[i] in optimal solution\n       * to current LP relaxation; note that this value is the same as\n       * if it would be computed with formula (27); it is assumed that\n       * beta[i] is fractional enough */\n      beta = P->col[j]->prim;\n      /* compute cut coefficients phi and right-hand side rho, which\n       * correspond to formula (30); dense format is used, because rows\n       * of the simplex tableau are usually dense */\n      for (k = 1; k <= m+n; k++)\n         phi[k] = 0.0;\n      rhs = f(beta); /* initial value of rho; see (28), (32) */\n      for (j = 1; j <= len; j++)\n      {  /* determine original number of non-basic variable xN[j] */\n         k = ind[j];\n         xassert(1 <= k && k <= m+n);\n         /* determine the kind, bounds and current status of xN[j] in\n          * optimal solution to LP relaxation */\n         if (k <= m)\n         {  /* auxiliary variable */\n            row = P->row[k];\n            kind = GLP_CV;\n            lb = row->lb;\n            ub = row->ub;\n            stat = row->stat;\n         }\n         else\n         {  /* structural variable */\n            col = P->col[k-m];\n            kind = col->kind;\n            lb = col->lb;\n            ub = col->ub;\n            stat = col->stat;\n         }\n         /* xN[j] cannot be basic */\n         xassert(stat != GLP_BS);\n         /* determine row coefficient ksi[i,j] at xN[j]; see (23) */\n         ksi = val[j];\n         /* if ksi[i,j] is too large in magnitude, report failure */\n         if (fabs(ksi) > 1e+05)\n            return -7;\n         /* if ksi[i,j] is too small in magnitude, skip it */\n         if (fabs(ksi) < 1e-10)\n            goto skip;\n         /* compute row coefficient alfa[i,j] at y[j]; see (26) */\n         switch (stat)\n         {  case GLP_NF:\n               /* xN[j] is free (unbounded) having non-zero ksi[i,j];\n                * report failure */\n               return -8;\n            case GLP_NL:\n               /* xN[j] has active lower bound */\n               alfa = - ksi;\n               break;\n            case GLP_NU:\n               /* xN[j] has active upper bound */\n               alfa = + ksi;\n               break;\n            case GLP_NS:\n               /* xN[j] is fixed; skip it */\n               goto skip;\n            default:\n               xassert(stat != stat);\n         }\n         /* compute cut coefficient phi'[j] at y[j]; see (21), (28) */\n         switch (kind)\n         {  case GLP_IV:\n               /* y[j] is integer */\n               if (fabs(alfa - floor(alfa + 0.5)) < 1e-10)\n               {  /* alfa[i,j] is close to nearest integer; skip it */\n                  goto skip;\n               }\n               else if (f(alfa) <= f(beta))\n                  phi1 = f(alfa);\n               else\n                  phi1 = (f(beta) / (1.0 - f(beta))) * (1.0 - f(alfa));\n               break;\n            case GLP_CV:\n               /* y[j] is continuous */\n               if (alfa >= 0.0)\n                  phi1 = + alfa;\n               else\n                  phi1 = (f(beta) / (1.0 - f(beta))) * (- alfa);\n               break;\n            default:\n               xassert(kind != kind);\n         }\n         /* compute cut coefficient phi[j] at xN[j] and update right-\n          * hand side rho; see (31), (32) */\n         switch (stat)\n         {  case GLP_NL:\n               /* xN[j] has active lower bound */\n               phi[k] = + phi1;\n               rhs += phi1 * lb;\n               break;\n            case GLP_NU:\n               /* xN[j] has active upper bound */\n               phi[k] = - phi1;\n               rhs -= phi1 * ub;\n               break;\n            default:\n               xassert(stat != stat);\n         }\nskip:    ;\n      }\n      /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut\n       * coefficients are stored in the array phi in dense format;\n       * x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-\n       * tural variables; see (30) */\n      /* eliminate auxiliary variables in order to express the cut only\n       * through structural variables; see (33) */\n      for (i = 1; i <= m; i++)\n      {  if (fabs(phi[i]) < 1e-10)\n            continue;\n         /* auxiliary variable x[i] has non-zero cut coefficient */\n         row = P->row[i];\n         /* x[i] cannot be fixed variable */\n         xassert(row->type != GLP_FX);\n         /* substitute x[i] = sum_j a[i,j] * x[m+j] */\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n            phi[m+aij->col->j] += phi[i] * aij->val;\n      }\n      /* convert the final cut to sparse format and substitute fixed\n       * (structural) variables */\n      len = 0;\n      for (j = 1; j <= n; j++)\n      {  if (fabs(phi[m+j]) < 1e-10)\n            continue;\n         /* structural variable x[m+j] has non-zero cut coefficient */\n         col = P->col[j];\n         if (col->type == GLP_FX)\n         {  /* eliminate x[m+j] */\n            rhs -= phi[m+j] * col->lb;\n         }\n         else\n         {  len++;\n            ind[len] = j;\n            val[len] = phi[m+j];\n         }\n      }\n      if (fabs(rhs) < 1e-12)\n         rhs = 0.0;\n      ind[0] = 0, val[0] = rhs;\n      /* the cut has been successfully generated */\n      return len;\n}",
      "lines": 183,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/gmigen.c": {
    "fcmp": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static int CDECL fcmp(const void *p1, const void *p2)\n{     const struct var *v1 = p1, *v2 = p2;\n      if (v1->f > v2->f) return -1;\n      if (v1->f < v2->f) return +1;\n      return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "glp_gmi_gen": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "int glp_gmi_gen(glp_prob *P, glp_prob *pool, int max_cuts)\n{     int m = P->m;\n      int n = P->n;\n      GLPCOL *col;\n      struct var *var;\n      int i, j, k, t, len, nv, nnn, *ind;\n      double frac, *val, *phi;\n      /* sanity checks */\n      if (!(P->m == 0 || P->valid))\n         xerror(\"glp_gmi_gen: basis factorization does not exist\\n\");\n      if (!(P->pbs_stat == GLP_FEAS && P->dbs_stat == GLP_FEAS))\n         xerror(\"glp_gmi_gen: optimal basic solution required\\n\");\n      if (pool->n != n)\n         xerror(\"glp_gmi_gen: cut pool has wrong number of columns\\n\");\n      /* allocate working arrays */\n      var = xcalloc(1+n, sizeof(struct var));\n      ind = xcalloc(1+n, sizeof(int));\n      val = xcalloc(1+n, sizeof(double));\n      phi = xcalloc(1+m+n, sizeof(double));\n      /* build the list of integer structural variables, which are\n       * basic and have integer infeasible (fractional) primal values\n       * in optimal solution to specified LP */\n      nv = 0;\n      for (j = 1; j <= n; j++)\n      {  col = P->col[j];\n         if (col->kind != GLP_IV)\n            continue;\n         if (col->type == GLP_FX)\n            continue;\n         if (col->stat != GLP_BS)\n            continue;\n         frac = f(col->prim);\n         if (!(0.05 <= frac && frac <= 0.95))\n            continue;\n         /* add variable to the list */\n         nv++, var[nv].j = j, var[nv].f = frac;\n      }\n      /* sort the list by descending fractionality */\n      qsort(&var[1], nv, sizeof(struct var), fcmp);\n      /* try to generate cuts by one for each variable in the list, but\n       * not more than max_cuts cuts */\n      nnn = 0;\n      for (t = 1; t <= nv; t++)\n      {  len = glp_gmi_cut(P, var[t].j, ind, val, phi);\n         if (len < 1)\n            goto skip;\n         /* if the cut inequality seems to be badly scaled, reject it\n          * to avoid numerical difficulties */\n         for (k = 1; k <= len; k++)\n         {  if (fabs(val[k]) < 1e-03)\n               goto skip;\n            if (fabs(val[k]) > 1e+03)\n               goto skip;\n         }\n         /* add the cut to the cut pool for further consideration */\n         i = glp_add_rows(pool, 1);\n         glp_set_row_bnds(pool, i, GLP_LO, val[0], 0);\n         glp_set_mat_row(pool, i, len, ind, val);\n         /* one cut has been generated */\n         nnn++;\n         if (nnn == max_cuts)\n            break;\nskip:    ;\n      }\n      /* free working arrays */\n      xfree(var);\n      xfree(ind);\n      xfree(val);\n      xfree(phi);\n      return nnn;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/mirgen.c": {
    "set_row_attrib": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static void set_row_attrib(glp_prob *mip, glp_mir *mir)\n{     /* set global row attributes */\n      int m = mir->m;\n      int k;\n      for (k = 1; k <= m; k++)\n      {  GLPROW *row = mip->row[k];\n         mir->skip[k] = 0;\n         mir->isint[k] = 0;\n         switch (row->type)\n         {  case GLP_FR:\n               mir->lb[k] = -DBL_MAX, mir->ub[k] = +DBL_MAX; break;\n            case GLP_LO:\n               mir->lb[k] = row->lb, mir->ub[k] = +DBL_MAX; break;\n            case GLP_UP:\n               mir->lb[k] = -DBL_MAX, mir->ub[k] = row->ub; break;\n            case GLP_DB:\n               mir->lb[k] = row->lb, mir->ub[k] = row->ub; break;\n            case GLP_FX:\n               mir->lb[k] = mir->ub[k] = row->lb; break;\n            default:\n               xassert(row != row);\n         }\n         mir->vlb[k] = mir->vub[k] = 0;\n      }\n      return;\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_col_attrib": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static void set_col_attrib(glp_prob *mip, glp_mir *mir)\n{     /* set global column attributes */\n      int m = mir->m;\n      int n = mir->n;\n      int k;\n      for (k = m+1; k <= m+n; k++)\n      {  GLPCOL *col = mip->col[k-m];\n         switch (col->kind)\n         {  case GLP_CV:\n               mir->isint[k] = 0; break;\n            case GLP_IV:\n               mir->isint[k] = 1; break;\n            default:\n               xassert(col != col);\n         }\n         switch (col->type)\n         {  case GLP_FR:\n               mir->lb[k] = -DBL_MAX, mir->ub[k] = +DBL_MAX; break;\n            case GLP_LO:\n               mir->lb[k] = col->lb, mir->ub[k] = +DBL_MAX; break;\n            case GLP_UP:\n               mir->lb[k] = -DBL_MAX, mir->ub[k] = col->ub; break;\n            case GLP_DB:\n               mir->lb[k] = col->lb, mir->ub[k] = col->ub; break;\n            case GLP_FX:\n               mir->lb[k] = mir->ub[k] = col->lb; break;\n            default:\n               xassert(col != col);\n         }\n         mir->vlb[k] = mir->vub[k] = 0;\n      }\n      return;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_var_bounds": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static void set_var_bounds(glp_prob *mip, glp_mir *mir)\n{     /* set variable bounds */\n      int m = mir->m;\n      GLPAIJ *aij;\n      int i, k1, k2;\n      double a1, a2;\n      for (i = 1; i <= m; i++)\n      {  /* we need the row to be '>= 0' or '<= 0' */\n         if (!(mir->lb[i] == 0.0 && mir->ub[i] == +DBL_MAX ||\n               mir->lb[i] == -DBL_MAX && mir->ub[i] == 0.0)) continue;\n         /* take first term */\n         aij = mip->row[i]->ptr;\n         if (aij == NULL) continue;\n         k1 = m + aij->col->j, a1 = aij->val;\n         /* take second term */\n         aij = aij->r_next;\n         if (aij == NULL) continue;\n         k2 = m + aij->col->j, a2 = aij->val;\n         /* there must be only two terms */\n         if (aij->r_next != NULL) continue;\n         /* interchange terms, if needed */\n         if (!mir->isint[k1] && mir->isint[k2])\n            ;\n         else if (mir->isint[k1] && !mir->isint[k2])\n         {  k2 = k1, a2 = a1;\n            k1 = m + aij->col->j, a1 = aij->val;\n         }\n         else\n         {  /* both terms are either continuous or integer */\n            continue;\n         }\n         /* x[k2] should be double-bounded */\n         if (mir->lb[k2] == -DBL_MAX || mir->ub[k2] == +DBL_MAX ||\n             mir->lb[k2] == mir->ub[k2]) continue;\n         /* change signs, if necessary */\n         if (mir->ub[i] == 0.0) a1 = - a1, a2 = - a2;\n         /* now the row has the form a1 * x1 + a2 * x2 >= 0, where x1\n            is continuous, x2 is integer */\n         if (a1 > 0.0)\n         {  /* x1 >= - (a2 / a1) * x2 */\n            if (mir->vlb[k1] == 0)\n            {  /* set variable lower bound for x1 */\n               mir->lb[k1] = - a2 / a1;\n               mir->vlb[k1] = k2;\n               /* the row should not be used */\n               mir->skip[i] = 1;\n            }\n         }\n         else /* a1 < 0.0 */\n         {  /* x1 <= - (a2 / a1) * x2 */\n            if (mir->vub[k1] == 0)\n            {  /* set variable upper bound for x1 */\n               mir->ub[k1] = - a2 / a1;\n               mir->vub[k1] = k2;\n               /* the row should not be used */\n               mir->skip[i] = 1;\n            }\n         }\n      }\n      return;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mark_useless_rows": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "static void mark_useless_rows(glp_prob *mip, glp_mir *mir)\n{     /* mark rows which should not be used */\n      int m = mir->m;\n      GLPAIJ *aij;\n      int i, k, nv;\n      for (i = 1; i <= m; i++)\n      {  /* free rows should not be used */\n         if (mir->lb[i] == -DBL_MAX && mir->ub[i] == +DBL_MAX)\n         {  mir->skip[i] = 1;\n            continue;\n         }\n         nv = 0;\n         for (aij = mip->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         {  k = m + aij->col->j;\n            /* rows with free variables should not be used */\n            if (mir->lb[k] == -DBL_MAX && mir->ub[k] == +DBL_MAX)\n            {  mir->skip[i] = 1;\n               break;\n            }\n            /* rows with integer variables having infinite (lower or\n               upper) bound should not be used */\n            if (mir->isint[k] && mir->lb[k] == -DBL_MAX ||\n                mir->isint[k] && mir->ub[k] == +DBL_MAX)\n            {  mir->skip[i] = 1;\n               break;\n            }\n            /* count non-fixed variables */\n            if (!(mir->vlb[k] == 0 && mir->vub[k] == 0 &&\n                  mir->lb[k] == mir->ub[k])) nv++;\n         }\n         /* rows with all variables fixed should not be used */\n         if (nv == 0)\n         {  mir->skip[i] = 1;\n            continue;\n         }\n      }\n      return;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_mir_init": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "glp_mir *glp_mir_init(glp_prob *mip)\n{     /* create and initialize MIR cut generator */\n      int m = mip->m;\n      int n = mip->n;\n      glp_mir *mir;\n#if MIR_DEBUG\n      xprintf(\"ios_mir_init: warning: debug mode enabled\\n\");\n#endif\n      /* allocate working area */\n      mir = xmalloc(sizeof(glp_mir));\n      mir->m = m;\n      mir->n = n;\n      mir->skip = xcalloc(1+m, sizeof(char));\n      mir->isint = xcalloc(1+m+n, sizeof(char));\n      mir->lb = xcalloc(1+m+n, sizeof(double));\n      mir->vlb = xcalloc(1+m+n, sizeof(int));\n      mir->ub = xcalloc(1+m+n, sizeof(double));\n      mir->vub = xcalloc(1+m+n, sizeof(int));\n      mir->x = xcalloc(1+m+n, sizeof(double));\n      mir->agg_row = xcalloc(1+MAXAGGR, sizeof(int));\n      mir->agg_vec = spv_create_vec(m+n);\n      mir->subst = xcalloc(1+m+n, sizeof(char));\n      mir->mod_vec = spv_create_vec(m+n);\n      mir->cut_vec = spv_create_vec(m+n);\n      /* set global row attributes */\n      set_row_attrib(mip, mir);\n      /* set global column attributes */\n      set_col_attrib(mip, mir);\n      /* set variable bounds */\n      set_var_bounds(mip, mir);\n      /* mark rows which should not be used */\n      mark_useless_rows(mip, mir);\n      return mir;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "glp_mir",
        "*glp_mir_init(glp_prob *mip)",
        "*"
      ]
    },
    "get_current_point": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static void get_current_point(glp_prob *mip, glp_mir *mir)\n{     /* obtain current point */\n      int m = mir->m;\n      int n = mir->n;\n      int k;\n      for (k = 1; k <= m; k++)\n         mir->x[k] = mip->row[k]->prim;\n      for (k = m+1; k <= m+n; k++)\n         mir->x[k] = mip->col[k-m]->prim;\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_current_point": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        416,
        1
      ],
      "content": "static void check_current_point(glp_mir *mir)\n{     /* check current point */\n      int m = mir->m;\n      int n = mir->n;\n      int k, kk;\n      double lb, ub, eps;\n      for (k = 1; k <= m+n; k++)\n      {  /* determine lower bound */\n         lb = mir->lb[k];\n         kk = mir->vlb[k];\n         if (kk != 0)\n         {  xassert(lb != -DBL_MAX);\n            xassert(!mir->isint[k]);\n            xassert(mir->isint[kk]);\n            lb *= mir->x[kk];\n         }\n         /* check lower bound */\n         if (lb != -DBL_MAX)\n         {  eps = 1e-6 * (1.0 + fabs(lb));\n            xassert(mir->x[k] >= lb - eps);\n         }\n         /* determine upper bound */\n         ub = mir->ub[k];\n         kk = mir->vub[k];\n         if (kk != 0)\n         {  xassert(ub != +DBL_MAX);\n            xassert(!mir->isint[k]);\n            xassert(mir->isint[kk]);\n            ub *= mir->x[kk];\n         }\n         /* check upper bound */\n         if (ub != +DBL_MAX)\n         {  eps = 1e-6 * (1.0 + fabs(ub));\n            xassert(mir->x[k] <= ub + eps);\n         }\n      }\n      return;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "initial_agg_row": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "static void initial_agg_row(glp_prob *mip, glp_mir *mir, int i)\n{     /* use original i-th row as initial aggregated constraint */\n      int m = mir->m;\n      GLPAIJ *aij;\n      xassert(1 <= i && i <= m);\n      xassert(!mir->skip[i]);\n      /* mark i-th row in order not to use it in the same aggregated\n         constraint */\n      mir->skip[i] = 2;\n      mir->agg_cnt = 1;\n      mir->agg_row[1] = i;\n      /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary\n         variable of row i, x[m+j] are structural variables */\n      spv_clear_vec(mir->agg_vec);\n      spv_set_vj(mir->agg_vec, i, 1.0);\n      for (aij = mip->row[i]->ptr; aij != NULL; aij = aij->r_next)\n         spv_set_vj(mir->agg_vec, m + aij->col->j, - aij->val);\n      mir->agg_rhs = 0.0;\n#if MIR_DEBUG\n      spv_check_vec(mir->agg_vec);\n#endif\n      return;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_agg_row": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static void check_agg_row(glp_mir *mir)\n{     /* check aggregated constraint */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k;\n      double r, big;\n      /* compute the residual r = sum a[k] * x[k] - b and determine\n         big = max(1, |a[k]|, |b|) */\n      r = 0.0, big = 1.0;\n      for (j = 1; j <= mir->agg_vec->nnz; j++)\n      {  k = mir->agg_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         r += mir->agg_vec->val[j] * mir->x[k];\n         if (big < fabs(mir->agg_vec->val[j]))\n            big = fabs(mir->agg_vec->val[j]);\n      }\n      r -= mir->agg_rhs;\n      if (big < fabs(mir->agg_rhs))\n         big = fabs(mir->agg_rhs);\n      /* the residual must be close to zero */\n      xassert(fabs(r) <= 1e-6 * big);\n      return;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_fixed_vars": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static void subst_fixed_vars(glp_mir *mir)\n{     /* substitute fixed variables into aggregated constraint */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k;\n      for (j = 1; j <= mir->agg_vec->nnz; j++)\n      {  k = mir->agg_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->vlb[k] == 0 && mir->vub[k] == 0 &&\n             mir->lb[k] == mir->ub[k])\n         {  /* x[k] is fixed */\n            mir->agg_rhs -= mir->agg_vec->val[j] * mir->lb[k];\n            mir->agg_vec->val[j] = 0.0;\n         }\n      }\n      /* remove terms corresponding to fixed variables */\n      spv_clean_vec(mir->agg_vec, DBL_EPSILON);\n#if MIR_DEBUG\n      spv_check_vec(mir->agg_vec);\n#endif\n      return;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bound_subst_heur": {
      "start_point": [
        492,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "static void bound_subst_heur(glp_mir *mir)\n{     /* bound substitution heuristic */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k, kk;\n      double d1, d2;\n      for (j = 1; j <= mir->agg_vec->nnz; j++)\n      {  k = mir->agg_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->isint[k]) continue; /* skip integer variable */\n         /* compute distance from x[k] to its lower bound */\n         kk = mir->vlb[k];\n         if (kk == 0)\n         {  if (mir->lb[k] == -DBL_MAX)\n               d1 = DBL_MAX;\n            else\n               d1 = mir->x[k] - mir->lb[k];\n         }\n         else\n         {  xassert(1 <= kk && kk <= m+n);\n            xassert(mir->isint[kk]);\n            xassert(mir->lb[k] != -DBL_MAX);\n            d1 = mir->x[k] - mir->lb[k] * mir->x[kk];\n         }\n         /* compute distance from x[k] to its upper bound */\n         kk = mir->vub[k];\n         if (kk == 0)\n         {  if (mir->vub[k] == +DBL_MAX)\n               d2 = DBL_MAX;\n            else\n               d2 = mir->ub[k] - mir->x[k];\n         }\n         else\n         {  xassert(1 <= kk && kk <= m+n);\n            xassert(mir->isint[kk]);\n            xassert(mir->ub[k] != +DBL_MAX);\n            d2 = mir->ub[k] * mir->x[kk] - mir->x[k];\n         }\n         /* x[k] cannot be free */\n         xassert(d1 != DBL_MAX || d2 != DBL_MAX);\n         /* choose the bound which is closer to x[k] */\n         xassert(mir->subst[k] == '?');\n         if (d1 <= d2)\n            mir->subst[k] = 'L';\n         else\n            mir->subst[k] = 'U';\n      }\n      return;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "build_mod_row": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static void build_mod_row(glp_mir *mir)\n{     /* substitute bounds and build modified constraint */\n      int m = mir->m;\n      int n = mir->n;\n      int j, jj, k, kk;\n      /* initially modified constraint is aggregated constraint */\n      spv_copy_vec(mir->mod_vec, mir->agg_vec);\n      mir->mod_rhs = mir->agg_rhs;\n#if MIR_DEBUG\n      spv_check_vec(mir->mod_vec);\n#endif\n      /* substitute bounds for continuous variables; note that due to\n         substitution of variable bounds additional terms may appear in\n         modified constraint */\n      for (j = mir->mod_vec->nnz; j >= 1; j--)\n      {  k = mir->mod_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->isint[k]) continue; /* skip integer variable */\n         if (mir->subst[k] == 'L')\n         {  /* x[k] = (lower bound) + x'[k] */\n            xassert(mir->lb[k] != -DBL_MAX);\n            kk = mir->vlb[k];\n            if (kk == 0)\n            {  /* x[k] = lb[k] + x'[k] */\n               mir->mod_rhs -= mir->mod_vec->val[j] * mir->lb[k];\n            }\n            else\n            {  /* x[k] = lb[k] * x[kk] + x'[k] */\n               xassert(mir->isint[kk]);\n               jj = mir->mod_vec->pos[kk];\n               if (jj == 0)\n               {  spv_set_vj(mir->mod_vec, kk, 1.0);\n                  jj = mir->mod_vec->pos[kk];\n                  mir->mod_vec->val[jj] = 0.0;\n               }\n               mir->mod_vec->val[jj] +=\n                  mir->mod_vec->val[j] * mir->lb[k];\n            }\n         }\n         else if (mir->subst[k] == 'U')\n         {  /* x[k] = (upper bound) - x'[k] */\n            xassert(mir->ub[k] != +DBL_MAX);\n            kk = mir->vub[k];\n            if (kk == 0)\n            {  /* x[k] = ub[k] - x'[k] */\n               mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];\n            }\n            else\n            {  /* x[k] = ub[k] * x[kk] - x'[k] */\n               xassert(mir->isint[kk]);\n               jj = mir->mod_vec->pos[kk];\n               if (jj == 0)\n               {  spv_set_vj(mir->mod_vec, kk, 1.0);\n                  jj = mir->mod_vec->pos[kk];\n                  mir->mod_vec->val[jj] = 0.0;\n               }\n               mir->mod_vec->val[jj] +=\n                  mir->mod_vec->val[j] * mir->ub[k];\n            }\n            mir->mod_vec->val[j] = - mir->mod_vec->val[j];\n         }\n         else\n            xassert(k != k);\n      }\n#if MIR_DEBUG\n      spv_check_vec(mir->mod_vec);\n#endif\n      /* substitute bounds for integer variables */\n      for (j = 1; j <= mir->mod_vec->nnz; j++)\n      {  k = mir->mod_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (!mir->isint[k]) continue; /* skip continuous variable */\n         xassert(mir->subst[k] == '?');\n         xassert(mir->vlb[k] == 0 && mir->vub[k] == 0);\n         xassert(mir->lb[k] != -DBL_MAX && mir->ub[k] != +DBL_MAX);\n         if (fabs(mir->lb[k]) <= fabs(mir->ub[k]))\n         {  /* x[k] = lb[k] + x'[k] */\n            mir->subst[k] = 'L';\n            mir->mod_rhs -= mir->mod_vec->val[j] * mir->lb[k];\n         }\n         else\n         {  /* x[k] = ub[k] - x'[k] */\n            mir->subst[k] = 'U';\n            mir->mod_rhs -= mir->mod_vec->val[j] * mir->ub[k];\n            mir->mod_vec->val[j] = - mir->mod_vec->val[j];\n         }\n      }\n#if MIR_DEBUG\n      spv_check_vec(mir->mod_vec);\n#endif\n      return;\n}",
      "lines": 92,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_mod_row": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "static void check_mod_row(glp_mir *mir)\n{     /* check modified constraint */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k, kk;\n      double r, big, x;\n      /* compute the residual r = sum a'[k] * x'[k] - b' and determine\n         big = max(1, |a[k]|, |b|) */\n      r = 0.0, big = 1.0;\n      for (j = 1; j <= mir->mod_vec->nnz; j++)\n      {  k = mir->mod_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->subst[k] == 'L')\n         {  /* x'[k] = x[k] - (lower bound) */\n            xassert(mir->lb[k] != -DBL_MAX);\n            kk = mir->vlb[k];\n            if (kk == 0)\n               x = mir->x[k] - mir->lb[k];\n            else\n               x = mir->x[k] - mir->lb[k] * mir->x[kk];\n         }\n         else if (mir->subst[k] == 'U')\n         {  /* x'[k] = (upper bound) - x[k] */\n            xassert(mir->ub[k] != +DBL_MAX);\n            kk = mir->vub[k];\n            if (kk == 0)\n               x = mir->ub[k] - mir->x[k];\n            else\n               x = mir->ub[k] * mir->x[kk] - mir->x[k];\n         }\n         else\n            xassert(k != k);\n         r += mir->mod_vec->val[j] * x;\n         if (big < fabs(mir->mod_vec->val[j]))\n            big = fabs(mir->mod_vec->val[j]);\n      }\n      r -= mir->mod_rhs;\n      if (big < fabs(mir->mod_rhs))\n         big = fabs(mir->mod_rhs);\n      /* the residual must be close to zero */\n      xassert(fabs(r) <= 1e-6 * big);\n      return;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mir_ineq": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "static int mir_ineq(const int n, const double a[], const double b,\n      double alpha[], double *beta, double *gamma)\n{     int j;\n      double f, t;\n      if (fabs(b - floor(b + .5)) < 0.01)\n         return 1;\n      f = b - floor(b);\n      for (j = 1; j <= n; j++)\n      {  t = (a[j] - floor(a[j])) - f;\n         if (t <= 0.0)\n            alpha[j] = floor(a[j]);\n         else\n            alpha[j] = floor(a[j]) + t / (1.0 - f);\n      }\n      *beta = floor(b);\n      *gamma = 1.0 / (1.0 - f);\n      return 0;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmir_ineq": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        764,
        1
      ],
      "content": "static int cmir_ineq(const int n, const double a[], const double b,\n      const double u[], const char cset[], const double delta,\n      double alpha[], double *beta, double *gamma)\n{     int j;\n      double *aa, bb;\n      aa = alpha, bb = b;\n      for (j = 1; j <= n; j++)\n      {  aa[j] = a[j] / delta;\n         if (cset[j])\n            aa[j] = - aa[j], bb -= a[j] * u[j];\n      }\n      bb /= delta;\n      if (mir_ineq(n, aa, bb, alpha, beta, gamma)) return 1;\n      for (j = 1; j <= n; j++)\n      {  if (cset[j])\n            alpha[j] = - alpha[j], *beta += alpha[j] * u[j];\n      }\n      *gamma /= delta;\n      return 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmir_cmp": {
      "start_point": [
        800,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "static int CDECL cmir_cmp(const void *p1, const void *p2)\n{     const struct vset *v1 = p1, *v2 = p2;\n      if (v1->v < v2->v) return -1;\n      if (v1->v > v2->v) return +1;\n      return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "cmir_sep": {
      "start_point": [
        807,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static double cmir_sep(const int n, const double a[], const double b,\n      const double u[], const double x[], const double s,\n      double alpha[], double *beta, double *gamma)\n{     int fail, j, k, nv, v;\n      double delta, eps, d_try[1+3], r, r_best;\n      char *cset;\n      struct vset *vset;\n      /* allocate working arrays */\n      cset = xcalloc(1+n, sizeof(char));\n      vset = xcalloc(1+n, sizeof(struct vset));\n      /* choose initial C */\n      for (j = 1; j <= n; j++)\n         cset[j] = (char)(x[j] >= 0.5 * u[j]);\n      /* choose initial delta */\n      r_best = delta = 0.0;\n      for (j = 1; j <= n; j++)\n      {  xassert(a[j] != 0.0);\n         /* if x[j] is close to its bounds, skip it */\n         eps = 1e-9 * (1.0 + fabs(u[j]));\n         if (x[j] < eps || x[j] > u[j] - eps) continue;\n         /* try delta = |a[j]| to construct c-MIR inequality */\n         fail = cmir_ineq(n, a, b, u, cset, fabs(a[j]), alpha, beta,\n            gamma);\n         if (fail) continue;\n         /* compute violation */\n         r = - (*beta) - (*gamma) * s;\n         for (k = 1; k <= n; k++) r += alpha[k] * x[k];\n         if (r_best < r) r_best = r, delta = fabs(a[j]);\n      }\n      if (r_best < 0.001) r_best = 0.0;\n      if (r_best == 0.0) goto done;\n      xassert(delta > 0.0);\n      /* try to increase violation by dividing delta by 2, 4, and 8,\n         respectively */\n      d_try[1] = delta / 2.0;\n      d_try[2] = delta / 4.0;\n      d_try[3] = delta / 8.0;\n      for (j = 1; j <= 3; j++)\n      {  /* construct c-MIR inequality */\n         fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha, beta,\n            gamma);\n         if (fail) continue;\n         /* compute violation */\n         r = - (*beta) - (*gamma) * s;\n         for (k = 1; k <= n; k++) r += alpha[k] * x[k];\n         if (r_best < r) r_best = r, delta = d_try[j];\n      }\n      /* build subset of variables lying strictly between their bounds\n         and order it by nondecreasing values of |x[j] - u[j]/2| */\n      nv = 0;\n      for (j = 1; j <= n; j++)\n      {  /* if x[j] is close to its bounds, skip it */\n         eps = 1e-9 * (1.0 + fabs(u[j]));\n         if (x[j] < eps || x[j] > u[j] - eps) continue;\n         /* add x[j] to the subset */\n         nv++;\n         vset[nv].j = j;\n         vset[nv].v = fabs(x[j] - 0.5 * u[j]);\n      }\n      qsort(&vset[1], nv, sizeof(struct vset), cmir_cmp);\n      /* try to increase violation by successively complementing each\n         variable in the subset */\n      for (v = 1; v <= nv; v++)\n      {  j = vset[v].j;\n         /* replace x[j] by its complement or vice versa */\n         cset[j] = (char)!cset[j];\n         /* construct c-MIR inequality */\n         fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);\n         /* restore the variable */\n         cset[j] = (char)!cset[j];\n         /* do not replace the variable in case of failure */\n         if (fail) continue;\n         /* compute violation */\n         r = - (*beta) - (*gamma) * s;\n         for (k = 1; k <= n; k++) r += alpha[k] * x[k];\n         if (r_best < r) r_best = r, cset[j] = (char)!cset[j];\n      }\n      /* construct the best c-MIR inequality chosen */\n      fail = cmir_ineq(n, a, b, u, cset, delta, alpha, beta, gamma);\n      xassert(!fail);\ndone: /* free working arrays */\n      xfree(cset);\n      xfree(vset);\n      /* return to the calling routine */\n      return r_best;\n}",
      "lines": 86,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "generate": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        1034,
        1
      ],
      "content": "static double generate(glp_mir *mir)\n{     /* try to generate violated c-MIR cut for modified constraint */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k, kk, nint;\n      double s, *u, *x, *alpha, r_best = 0.0, b, beta, gamma;\n      spv_copy_vec(mir->cut_vec, mir->mod_vec);\n      mir->cut_rhs = mir->mod_rhs;\n      /* remove small terms, which can appear due to substitution of\n         variable bounds */\n      spv_clean_vec(mir->cut_vec, DBL_EPSILON);\n#if MIR_DEBUG\n      spv_check_vec(mir->cut_vec);\n#endif\n      /* remove positive continuous terms to obtain MK relaxation */\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (!mir->isint[k] && mir->cut_vec->val[j] > 0.0)\n            mir->cut_vec->val[j] = 0.0;\n      }\n      spv_clean_vec(mir->cut_vec, 0.0);\n#if MIR_DEBUG\n      spv_check_vec(mir->cut_vec);\n#endif\n      /* move integer terms to the beginning of the sparse vector and\n         determine the number of integer variables */\n      nint = 0;\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->isint[k])\n         {  double temp;\n            nint++;\n            /* interchange elements [nint] and [j] */\n            kk = mir->cut_vec->ind[nint];\n            mir->cut_vec->pos[k] = nint;\n            mir->cut_vec->pos[kk] = j;\n            mir->cut_vec->ind[nint] = k;\n            mir->cut_vec->ind[j] = kk;\n            temp = mir->cut_vec->val[nint];\n            mir->cut_vec->val[nint] = mir->cut_vec->val[j];\n            mir->cut_vec->val[j] = temp;\n         }\n      }\n#if MIR_DEBUG\n      spv_check_vec(mir->cut_vec);\n#endif\n      /* if there is no integer variable, nothing to generate */\n      if (nint == 0) goto done;\n      /* allocate working arrays */\n      u = xcalloc(1+nint, sizeof(double));\n      x = xcalloc(1+nint, sizeof(double));\n      alpha = xcalloc(1+nint, sizeof(double));\n      /* determine u and x */\n      for (j = 1; j <= nint; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(m+1 <= k && k <= m+n);\n         xassert(mir->isint[k]);\n         u[j] = mir->ub[k] - mir->lb[k];\n         xassert(u[j] >= 1.0);\n         if (mir->subst[k] == 'L')\n            x[j] = mir->x[k] - mir->lb[k];\n         else if (mir->subst[k] == 'U')\n            x[j] = mir->ub[k] - mir->x[k];\n         else\n            xassert(k != k);\n#if 0 /* 06/III-2016; notorious bug reported many times */\n         xassert(x[j] >= -0.001);\n#else\n         if (x[j] < -0.001)\n         {  xprintf(\"glp_mir_gen: warning: x[%d] = %g\\n\", j, x[j]);\n            r_best = 0.0;\n            goto skip;\n         }\n#endif\n         if (x[j] < 0.0) x[j] = 0.0;\n      }\n      /* compute s = - sum of continuous terms */\n      s = 0.0;\n      for (j = nint+1; j <= mir->cut_vec->nnz; j++)\n      {  double x;\n         k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         /* must be continuous */\n         xassert(!mir->isint[k]);\n         if (mir->subst[k] == 'L')\n         {  xassert(mir->lb[k] != -DBL_MAX);\n            kk = mir->vlb[k];\n            if (kk == 0)\n               x = mir->x[k] - mir->lb[k];\n            else\n               x = mir->x[k] - mir->lb[k] * mir->x[kk];\n         }\n         else if (mir->subst[k] == 'U')\n         {  xassert(mir->ub[k] != +DBL_MAX);\n            kk = mir->vub[k];\n            if (kk == 0)\n               x = mir->ub[k] - mir->x[k];\n            else\n               x = mir->ub[k] * mir->x[kk] - mir->x[k];\n         }\n         else\n            xassert(k != k);\n#if 0 /* 06/III-2016; notorious bug reported many times */\n         xassert(x >= -0.001);\n#else\n         if (x < -0.001)\n         {  xprintf(\"glp_mir_gen: warning: x = %g\\n\", x);\n            r_best = 0.0;\n            goto skip;\n         }\n#endif\n         if (x < 0.0) x = 0.0;\n         s -= mir->cut_vec->val[j] * x;\n      }\n      xassert(s >= 0.0);\n      /* apply heuristic to obtain most violated c-MIR inequality */\n      b = mir->cut_rhs;\n      r_best = cmir_sep(nint, mir->cut_vec->val, b, u, x, s, alpha,\n         &beta, &gamma);\n      if (r_best == 0.0) goto skip;\n      xassert(r_best > 0.0);\n      /* convert to raw cut */\n      /* sum alpha[j] * x[j] <= beta + gamma * s */\n      for (j = 1; j <= nint; j++)\n         mir->cut_vec->val[j] = alpha[j];\n      for (j = nint+1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         if (k <= m+n) mir->cut_vec->val[j] *= gamma;\n      }\n      mir->cut_rhs = beta;\n#if MIR_DEBUG\n      spv_check_vec(mir->cut_vec);\n#endif\nskip: /* free working arrays */\n      xfree(u);\n      xfree(x);\n      xfree(alpha);\ndone: return r_best;\n}",
      "lines": 141,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "check_raw_cut": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1077,
        1
      ],
      "content": "static void check_raw_cut(glp_mir *mir, double r_best)\n{     /* check raw cut before back bound substitution */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k, kk;\n      double r, big, x;\n      /* compute the residual r = sum a[k] * x[k] - b and determine\n         big = max(1, |a[k]|, |b|) */\n      r = 0.0, big = 1.0;\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->subst[k] == 'L')\n         {  xassert(mir->lb[k] != -DBL_MAX);\n            kk = mir->vlb[k];\n            if (kk == 0)\n               x = mir->x[k] - mir->lb[k];\n            else\n               x = mir->x[k] - mir->lb[k] * mir->x[kk];\n         }\n         else if (mir->subst[k] == 'U')\n         {  xassert(mir->ub[k] != +DBL_MAX);\n            kk = mir->vub[k];\n            if (kk == 0)\n               x = mir->ub[k] - mir->x[k];\n            else\n               x = mir->ub[k] * mir->x[kk] - mir->x[k];\n         }\n         else\n            xassert(k != k);\n         r += mir->cut_vec->val[j] * x;\n         if (big < fabs(mir->cut_vec->val[j]))\n            big = fabs(mir->cut_vec->val[j]);\n      }\n      r -= mir->cut_rhs;\n      if (big < fabs(mir->cut_rhs))\n         big = fabs(mir->cut_rhs);\n      /* the residual must be close to r_best */\n      xassert(fabs(r - r_best) <= 1e-6 * big);\n      return;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "back_subst": {
      "start_point": [
        1080,
        0
      ],
      "end_point": [
        1167,
        1
      ],
      "content": "static void back_subst(glp_mir *mir)\n{     /* back substitution of original bounds */\n      int m = mir->m;\n      int n = mir->n;\n      int j, jj, k, kk;\n      /* at first, restore bounds of integer variables (because on\n         restoring variable bounds of continuous variables we need\n         original, not shifted, bounds of integer variables) */\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (!mir->isint[k]) continue; /* skip continuous */\n         if (mir->subst[k] == 'L')\n         {  /* x'[k] = x[k] - lb[k] */\n            xassert(mir->lb[k] != -DBL_MAX);\n            xassert(mir->vlb[k] == 0);\n            mir->cut_rhs += mir->cut_vec->val[j] * mir->lb[k];\n         }\n         else if (mir->subst[k] == 'U')\n         {  /* x'[k] = ub[k] - x[k] */\n            xassert(mir->ub[k] != +DBL_MAX);\n            xassert(mir->vub[k] == 0);\n            mir->cut_rhs -= mir->cut_vec->val[j] * mir->ub[k];\n            mir->cut_vec->val[j] = - mir->cut_vec->val[j];\n         }\n         else\n            xassert(k != k);\n      }\n      /* now restore bounds of continuous variables */\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (mir->isint[k]) continue; /* skip integer */\n         if (mir->subst[k] == 'L')\n         {  /* x'[k] = x[k] - (lower bound) */\n            xassert(mir->lb[k] != -DBL_MAX);\n            kk = mir->vlb[k];\n            if (kk == 0)\n            {  /* x'[k] = x[k] - lb[k] */\n               mir->cut_rhs += mir->cut_vec->val[j] * mir->lb[k];\n            }\n            else\n            {  /* x'[k] = x[k] - lb[k] * x[kk] */\n               jj = mir->cut_vec->pos[kk];\n#if 0\n               xassert(jj != 0);\n#else\n               if (jj == 0)\n               {  spv_set_vj(mir->cut_vec, kk, 1.0);\n                  jj = mir->cut_vec->pos[kk];\n                  xassert(jj != 0);\n                  mir->cut_vec->val[jj] = 0.0;\n               }\n#endif\n               mir->cut_vec->val[jj] -= mir->cut_vec->val[j] *\n                  mir->lb[k];\n            }\n         }\n         else if (mir->subst[k] == 'U')\n         {  /* x'[k] = (upper bound) - x[k] */\n            xassert(mir->ub[k] != +DBL_MAX);\n            kk = mir->vub[k];\n            if (kk == 0)\n            {  /* x'[k] = ub[k] - x[k] */\n               mir->cut_rhs -= mir->cut_vec->val[j] * mir->ub[k];\n            }\n            else\n            {  /* x'[k] = ub[k] * x[kk] - x[k] */\n               jj = mir->cut_vec->pos[kk];\n               if (jj == 0)\n               {  spv_set_vj(mir->cut_vec, kk, 1.0);\n                  jj = mir->cut_vec->pos[kk];\n                  xassert(jj != 0);\n                  mir->cut_vec->val[jj] = 0.0;\n               }\n               mir->cut_vec->val[jj] += mir->cut_vec->val[j] *\n                  mir->ub[k];\n            }\n            mir->cut_vec->val[j] = - mir->cut_vec->val[j];\n         }\n         else\n            xassert(k != k);\n      }\n#if MIR_DEBUG\n      spv_check_vec(mir->cut_vec);\n#endif\n      return;\n}",
      "lines": 88,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_cut_row": {
      "start_point": [
        1170,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static void check_cut_row(glp_mir *mir, double r_best)\n{     /* check the cut after back bound substitution or elimination of\n         auxiliary variables */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k;\n      double r, big;\n      /* compute the residual r = sum a[k] * x[k] - b and determine\n         big = max(1, |a[k]|, |b|) */\n      r = 0.0, big = 1.0;\n      for (j = 1; j <= mir->cut_vec->nnz; j++)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         r += mir->cut_vec->val[j] * mir->x[k];\n         if (big < fabs(mir->cut_vec->val[j]))\n            big = fabs(mir->cut_vec->val[j]);\n      }\n      r -= mir->cut_rhs;\n      if (big < fabs(mir->cut_rhs))\n         big = fabs(mir->cut_rhs);\n      /* the residual must be close to r_best */\n      xassert(fabs(r - r_best) <= 1e-6 * big);\n      return;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "subst_aux_vars": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1220,
        1
      ],
      "content": "static void subst_aux_vars(glp_prob *mip, glp_mir *mir)\n{     /* final substitution to eliminate auxiliary variables */\n      int m = mir->m;\n      int n = mir->n;\n      GLPAIJ *aij;\n      int j, k, kk, jj;\n      for (j = mir->cut_vec->nnz; j >= 1; j--)\n      {  k = mir->cut_vec->ind[j];\n         xassert(1 <= k && k <= m+n);\n         if (k > m) continue; /* skip structurals */\n         for (aij = mip->row[k]->ptr; aij != NULL; aij = aij->r_next)\n         {  kk = m + aij->col->j; /* structural */\n            jj = mir->cut_vec->pos[kk];\n            if (jj == 0)\n            {  spv_set_vj(mir->cut_vec, kk, 1.0);\n               jj = mir->cut_vec->pos[kk];\n               mir->cut_vec->val[jj] = 0.0;\n            }\n            mir->cut_vec->val[jj] += mir->cut_vec->val[j] * aij->val;\n         }\n         mir->cut_vec->val[j] = 0.0;\n      }\n      spv_clean_vec(mir->cut_vec, 0.0);\n      return;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "add_cut": {
      "start_point": [
        1222,
        0
      ],
      "end_point": [
        1253,
        1
      ],
      "content": "static void add_cut(glp_mir *mir, glp_prob *pool)\n{     /* add constructed cut inequality to the cut pool */\n      int m = mir->m;\n      int n = mir->n;\n      int j, k, len;\n      int *ind = xcalloc(1+n, sizeof(int));\n      double *val = xcalloc(1+n, sizeof(double));\n      len = 0;\n      for (j = mir->cut_vec->nnz; j >= 1; j--)\n      {  k = mir->cut_vec->ind[j];\n         xassert(m+1 <= k && k <= m+n);\n         len++, ind[len] = k - m, val[len] = mir->cut_vec->val[j];\n      }\n#if 0\n#if 0\n      ios_add_cut_row(tree, pool, GLP_RF_MIR, len, ind, val, GLP_UP,\n         mir->cut_rhs);\n#else\n      glp_ios_add_row(tree, NULL, GLP_RF_MIR, 0, len, ind, val, GLP_UP,\n         mir->cut_rhs);\n#endif\n#else\n      {  int i;\n         i = glp_add_rows(pool, 1);\n         glp_set_row_bnds(pool, i, GLP_UP, 0, mir->cut_rhs);\n         glp_set_mat_row(pool, i, len, ind, val);\n      }\n#endif\n      xfree(ind);\n      xfree(val);\n      return;\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glp_mir_gen": {
      "start_point": [
        1385,
        0
      ],
      "end_point": [
        1495,
        1
      ],
      "content": "int glp_mir_gen(glp_prob *mip, glp_mir *mir, glp_prob *pool)\n{     /* main routine to generate MIR cuts */\n      int m = mir->m;\n      int n = mir->n;\n      int i, nnn = 0;\n      double r_best;\n#if 1 /* 29/II-2016 by Chris */\n      SPV *work;\n#endif\n      xassert(mip->m >= m);\n      xassert(mip->n == n);\n      /* obtain current point */\n      get_current_point(mip, mir);\n#if MIR_DEBUG\n      /* check current point */\n      check_current_point(mir);\n#endif\n      /* reset bound substitution flags */\n      memset(&mir->subst[1], '?', m+n);\n#if 1 /* 29/II-2016 by Chris */\n      work = spv_create_vec(m+n);\n#endif\n      /* try to generate a set of violated MIR cuts */\n      for (i = 1; i <= m; i++)\n      {  if (mir->skip[i]) continue;\n         /* use original i-th row as initial aggregated constraint */\n         initial_agg_row(mip, mir, i);\nloop:    ;\n#if MIR_DEBUG\n         /* check aggregated row */\n         check_agg_row(mir);\n#endif\n         /* substitute fixed variables into aggregated constraint */\n         subst_fixed_vars(mir);\n#if MIR_DEBUG\n         /* check aggregated row */\n         check_agg_row(mir);\n#endif\n#if MIR_DEBUG\n         /* check bound substitution flags */\n         {  int k;\n            for (k = 1; k <= m+n; k++)\n               xassert(mir->subst[k] == '?');\n         }\n#endif\n         /* apply bound substitution heuristic */\n         bound_subst_heur(mir);\n         /* substitute bounds and build modified constraint */\n         build_mod_row(mir);\n#if MIR_DEBUG\n         /* check modified row */\n         check_mod_row(mir);\n#endif\n         /* try to generate violated c-MIR cut for modified row */\n         r_best = generate(mir);\n         if (r_best > 0.0)\n         {  /* success */\n#if MIR_DEBUG\n            /* check raw cut before back bound substitution */\n            check_raw_cut(mir, r_best);\n#endif\n            /* back substitution of original bounds */\n            back_subst(mir);\n#if MIR_DEBUG\n            /* check the cut after back bound substitution */\n            check_cut_row(mir, r_best);\n#endif\n            /* final substitution to eliminate auxiliary variables */\n            subst_aux_vars(mip, mir);\n#if MIR_DEBUG\n            /* check the cut after elimination of auxiliaries */\n            check_cut_row(mir, r_best);\n#endif\n            /* add constructed cut inequality to the cut pool */\n            add_cut(mir, pool), nnn++;\n         }\n         /* reset bound substitution flags */\n         {  int j, k;\n            for (j = 1; j <= mir->mod_vec->nnz; j++)\n            {  k = mir->mod_vec->ind[j];\n               xassert(1 <= k && k <= m+n);\n               xassert(mir->subst[k] != '?');\n               mir->subst[k] = '?';\n            }\n         }\n         if (r_best == 0.0)\n         {  /* failure */\n            if (mir->agg_cnt < MAXAGGR)\n            {  /* try to aggregate another row */\n#if 0 /* 29/II-2016 by Chris */\n               if (aggregate_row(mip, mir) == 0) goto loop;\n#else\n               if (aggregate_row(mip, mir, work) == 0) goto loop;\n#endif\n            }\n         }\n         /* unmark rows used in the aggregated constraint */\n         {  int k, ii;\n            for (k = 1; k <= mir->agg_cnt; k++)\n            {  ii = mir->agg_row[k];\n               xassert(1 <= ii && ii <= m);\n               xassert(mir->skip[ii] == 2);\n               mir->skip[ii] = 0;\n            }\n         }\n      }\n#if 1 /* 29/II-2016 by Chris */\n      spv_delete_vec(work);\n#endif\n      return nnn;\n}",
      "lines": 111,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "glp_mir_free": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1526,
        1
      ],
      "content": "void glp_mir_free(glp_mir *mir)\n{     xfree(mir->skip);\n      xfree(mir->isint);\n      xfree(mir->lb);\n      xfree(mir->vlb);\n      xfree(mir->ub);\n      xfree(mir->vub);\n      xfree(mir->x);\n      xfree(mir->agg_row);\n      spv_delete_vec(mir->agg_vec);\n      xfree(mir->subst);\n      spv_delete_vec(mir->mod_vec);\n      spv_delete_vec(mir->cut_vec);\n      xfree(mir);\n      return;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/spv.c": {
    "spv_create_vec": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "SPV *spv_create_vec(int n)\n{     SPV *v;\n      xassert(n >= 0);\n      v = xmalloc(sizeof(SPV));\n      v->n = n;\n      v->nnz = 0;\n      v->pos = xcalloc(1+n, sizeof(int));\n      memset(&v->pos[1], 0, n * sizeof(int));\n      v->ind = xcalloc(1+n, sizeof(int));\n      v->val = xcalloc(1+n, sizeof(double));\n      return v;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "SPV",
        "*spv_create_vec(int n)",
        "*"
      ]
    },
    "spv_check_vec": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void spv_check_vec(SPV *v)\n{     int j, k, nnz;\n      xassert(v->n >= 0);\n      nnz = 0;\n      for (j = v->n; j >= 1; j--)\n      {  k = v->pos[j];\n         xassert(0 <= k && k <= v->nnz);\n         if (k != 0)\n         {  xassert(v->ind[k] == j);\n            nnz++;\n         }\n      }\n      xassert(v->nnz == nnz);\n      return;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spv_get_vj": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "double spv_get_vj(SPV *v, int j)\n{     int k;\n      xassert(1 <= j && j <= v->n);\n      k = v->pos[j];\n      xassert(0 <= k && k <= v->nnz);\n      return (k == 0 ? 0.0 : v->val[k]);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "spv_set_vj": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void spv_set_vj(SPV *v, int j, double val)\n{     int k;\n      xassert(1 <= j && j <= v->n);\n      k = v->pos[j];\n      if (val == 0.0)\n      {  if (k != 0)\n         {  /* remove j-th component */\n            v->pos[j] = 0;\n            if (k < v->nnz)\n            {  v->pos[v->ind[v->nnz]] = k;\n               v->ind[k] = v->ind[v->nnz];\n               v->val[k] = v->val[v->nnz];\n            }\n            v->nnz--;\n         }\n      }\n      else\n      {  if (k == 0)\n         {  /* create j-th component */\n            k = ++(v->nnz);\n            v->pos[j] = k;\n            v->ind[k] = j;\n         }\n         v->val[k] = val;\n      }\n      return;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "spv_clear_vec": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "void spv_clear_vec(SPV *v)\n{     int k;\n      for (k = 1; k <= v->nnz; k++)\n         v->pos[v->ind[k]] = 0;\n      v->nnz = 0;\n      return;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spv_clean_vec": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "void spv_clean_vec(SPV *v, double eps)\n{     int k, nnz;\n      nnz = 0;\n      for (k = 1; k <= v->nnz; k++)\n      {  if (fabs(v->val[k]) == 0.0 || fabs(v->val[k]) < eps)\n         {  /* remove component */\n            v->pos[v->ind[k]] = 0;\n         }\n         else\n         {  /* keep component */\n            nnz++;\n            v->pos[v->ind[k]] = nnz;\n            v->ind[nnz] = v->ind[k];\n            v->val[nnz] = v->val[k];\n         }\n      }\n      v->nnz = nnz;\n      return;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spv_copy_vec": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void spv_copy_vec(SPV *x, SPV *y)\n{     int j;\n      xassert(x != y);\n      xassert(x->n == y->n);\n      spv_clear_vec(x);\n      x->nnz = y->nnz;\n      memcpy(&x->ind[1], &y->ind[1], x->nnz * sizeof(int));\n      memcpy(&x->val[1], &y->val[1], x->nnz * sizeof(double));\n      for (j = 1; j <= x->nnz; j++)\n         x->pos[x->ind[j]] = j;\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spv_linear_comb": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void spv_linear_comb(SPV *x, double a, SPV *y)\n{     int j, k;\n      double xj, yj;\n      xassert(x != y);\n      xassert(x->n == y->n);\n      for (k = 1; k <= y->nnz; k++)\n      {  j = y->ind[k];\n         xj = spv_get_vj(x, j);\n         yj = y->val[k];\n         spv_set_vj(x, j, xj + a * yj);\n      }\n      return;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spv_delete_vec": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void spv_delete_vec(SPV *v)\n{     /* delete sparse vector */\n      xfree(v->pos);\n      xfree(v->ind);\n      xfree(v->val);\n      xfree(v);\n      return;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/intopt/spv.h": {},
  "glpk/glpk-4.65/src/minisat/minisat.c": {
    "ymalloc": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static void *ymalloc(int size)\n{     void *ptr;\n      xassert(size > 0);\n      ptr = malloc(size);\n      if (ptr == NULL)\n         xerror(\"MiniSat: no memory available\\n\");\n      return ptr;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*ymalloc(int size)",
        "*"
      ]
    },
    "yrealloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void *yrealloc(void *ptr, int size)\n{     xassert(size > 0);\n      if (ptr == NULL)\n         ptr = malloc(size);\n      else\n         ptr = realloc(ptr, size);\n      if (ptr == NULL)\n         xerror(\"MiniSat: no memory available\\n\");\n      return ptr;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*yrealloc(void *ptr, int size)",
        "*"
      ]
    },
    "yfree": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void yfree(void *ptr)\n{     xassert(ptr != NULL);\n      free(ptr);\n      return;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        87,
        52
      ],
      "content": "static inline void check(int expr) { assert(expr); }",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "printlits": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void printlits(lit* begin, lit* end)\n{\n    int i;\n    for (i = 0; i < end - begin; i++)\n        printf(L_LIT\" \",L_lit(begin[i]));\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "drand": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        32
      ],
      "content": "static inline double drand(double* seed) {\n    int q;\n    *seed *= 1389796;\n    q = (int)(*seed / 2147483647);\n    *seed -= (double)q * 2147483647;\n    return *seed / 2147483647; }",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "double"
      ]
    },
    "irand": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        112,
        39
      ],
      "content": "static inline int irand(double* seed, int size) {\n    return (int)(drand(seed) * size); }",
      "lines": 2,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "vecp_remove": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static inline void    vecp_remove(vecp* v, void* e)\n{\n    void** ws = vecp_begin(v);\n    int    j  = 0;\n\n    for (; ws[j] != e  ; j++);\n    assert(j < vecp_size(v));\n    for (; j < vecp_size(v)-1; j++) ws[j] = ws[j+1];\n    vecp_resize(v,vecp_size(v)-1);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "order_update": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static inline void order_update(solver* s, int v)\n{   /* updateorder */\n    int*    orderpos = s->orderpos;\n    double* activity = s->activity;\n    int*    heap     = veci_begin(&s->order);\n    int     i        = orderpos[v];\n    int     x        = heap[i];\n    int     parent   = (i - 1) / 2;\n\n    assert(s->orderpos[v] != -1);\n\n    while (i != 0 && activity[x] > activity[heap[parent]]){\n        heap[i]           = heap[parent];\n        orderpos[heap[i]] = i;\n        i                 = parent;\n        parent            = (i - 1) / 2;\n    }\n    heap[i]     = x;\n    orderpos[x] = i;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "order_unassigned": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static inline void order_unassigned(solver* s, int v)\n{   /* undoorder */\n    int* orderpos = s->orderpos;\n    if (orderpos[v] == -1){\n        orderpos[v] = veci_size(&s->order);\n        veci_push(&s->order,v);\n        order_update(s,v);\n    }\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "order_select": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "static int order_select(solver* s, float random_var_freq)\n{   /* selectvar */\n    int*    heap;\n    double* activity;\n    int*    orderpos;\n\n    lbool* values = s->assigns;\n\n    /* Random decision: */\n    if (drand(&s->random_seed) < random_var_freq){\n        int next = irand(&s->random_seed,s->size);\n        assert(next >= 0 && next < s->size);\n        if (values[next] == l_Undef)\n            return next;\n    }\n\n    /* Activity based decision: */\n\n    heap     = veci_begin(&s->order);\n    activity = s->activity;\n    orderpos = s->orderpos;\n\n    while (veci_size(&s->order) > 0){\n        int    next  = heap[0];\n        int    size  = veci_size(&s->order)-1;\n        int    x     = heap[size];\n\n        veci_resize(&s->order,size);\n\n        orderpos[next] = -1;\n\n        if (size > 0){\n            double act   = activity[x];\n\n            int    i     = 0;\n            int    child = 1;\n\n            while (child < size){\n                if (child+1 < size\n                    && activity[heap[child]] < activity[heap[child+1]])\n                    child++;\n\n                assert(child < size);\n\n                if (act >= activity[heap[child]])\n                    break;\n\n                heap[i]           = heap[child];\n                orderpos[heap[i]] = i;\n                i                 = child;\n                child             = 2 * child + 1;\n            }\n            heap[i]           = x;\n            orderpos[heap[i]] = i;\n        }\n\n        if (values[next] == l_Undef)\n            return next;\n    }\n\n    return var_Undef;\n}",
      "lines": 62,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "act_var_rescale": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static inline void act_var_rescale(solver* s) {\n    double* activity = s->activity;\n    int i;\n    for (i = 0; i < s->size; i++)\n        activity[i] *= 1e-100;\n    s->var_inc *= 1e-100;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "act_var_bump": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "static inline void act_var_bump(solver* s, int v) {\n    double* activity = s->activity;\n    if ((activity[v] += s->var_inc) > 1e100)\n        act_var_rescale(s);\n\n    /* printf(\"bump %d %f\\n\", v-1, activity[v]); */\n\n    if (s->orderpos[v] != -1)\n        order_update(s,v);\n\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "act_var_decay": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        309,
        35
      ],
      "content": "static inline void act_var_decay(solver* s)\n    { s->var_inc *= s->var_decay; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "act_clause_rescale": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static inline void act_clause_rescale(solver* s) {\n    clause** cs = (clause**)vecp_begin(&s->learnts);\n    int i;\n    for (i = 0; i < vecp_size(&s->learnts); i++){\n        float a = clause_activity(cs[i]);\n        clause_setactivity(cs[i], a * (float)1e-20);\n    }\n    s->cla_inc *= (float)1e-20;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "act_clause_bump": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "static inline void act_clause_bump(solver* s, clause *c) {\n    float a = clause_activity(c) + s->cla_inc;\n    clause_setactivity(c,a);\n    if (a > 1e20) act_clause_rescale(s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "act_clause_decay": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        328,
        35
      ],
      "content": "static inline void act_clause_decay(solver* s)\n    { s->cla_inc *= s->cla_decay; }",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "clause_new": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        377,
        1
      ],
      "content": "static clause* clause_new(solver* s, lit* begin, lit* end, int learnt)\n{\n    int size;\n    clause* c;\n    int i;\n\n    assert(end - begin > 1);\n    assert(learnt >= 0 && learnt < 2);\n    size           = end - begin;\n    c              = (clause*)malloc(sizeof(clause)\n                     + sizeof(lit) * size + learnt * sizeof(float));\n    c->size_learnt = (size << 1) | learnt;\n#if 1 /* by mao & cmatraki; non-portable check that is a fundamental  \\\n       * assumption of minisat code: bit 0 is used as a flag (zero    \\\n       * for pointer, one for shifted int) so allocated memory should \\\n       * be at least 16-bit aligned */\n    assert(((size_t)c & 1) == 0);\n#endif\n\n    for (i = 0; i < size; i++)\n        c->lits[i] = begin[i];\n\n    if (learnt)\n        *((float*)&c->lits[size]) = 0.0;\n\n    assert(begin[0] >= 0);\n    assert(begin[0] < s->size*2);\n    assert(begin[1] >= 0);\n    assert(begin[1] < s->size*2);\n\n    assert(lit_neg(begin[0]) < s->size*2);\n    assert(lit_neg(begin[1]) < s->size*2);\n\n    /* vecp_push(solver_read_wlist(s,lit_neg(begin[0])),(void*)c); */\n    /* vecp_push(solver_read_wlist(s,lit_neg(begin[1])),(void*)c); */\n\n    vecp_push(solver_read_wlist(s,lit_neg(begin[0])),\n        (void*)(size > 2 ? c : clause_from_lit(begin[1])));\n    vecp_push(solver_read_wlist(s,lit_neg(begin[1])),\n        (void*)(size > 2 ? c : clause_from_lit(begin[0])));\n\n    return c;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "clause",
        "* clause_new(solver* s, lit* begin, lit* end, int learnt)",
        "*"
      ]
    },
    "clause_remove": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static void clause_remove(solver* s, clause* c)\n{\n    lit* lits = clause_begin(c);\n    assert(lit_neg(lits[0]) < s->size*2);\n    assert(lit_neg(lits[1]) < s->size*2);\n\n    /* vecp_remove(solver_read_wlist(s,lit_neg(lits[0])),(void*)c); */\n    /* vecp_remove(solver_read_wlist(s,lit_neg(lits[1])),(void*)c); */\n\n    assert(lits[0] < s->size*2);\n    vecp_remove(solver_read_wlist(s,lit_neg(lits[0])),\n        (void*)(clause_size(c) > 2 ? c : clause_from_lit(lits[1])));\n    vecp_remove(solver_read_wlist(s,lit_neg(lits[1])),\n        (void*)(clause_size(c) > 2 ? c : clause_from_lit(lits[0])));\n\n    if (clause_learnt(c)){\n        s->stats.learnts--;\n        s->stats.learnts_literals -= clause_size(c);\n    }else{\n        s->stats.clauses--;\n        s->stats.clauses_literals -= clause_size(c);\n    }\n\n    free(c);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clause_simplify": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "static lbool clause_simplify(solver* s, clause* c)\n{\n    lit*   lits   = clause_begin(c);\n    lbool* values = s->assigns;\n    int i;\n\n    assert(solver_dlevel(s) == 0);\n\n    for (i = 0; i < clause_size(c); i++){\n        lbool sig = !lit_sign(lits[i]); sig += sig - 1;\n        if (values[lit_var(lits[i])] == sig)\n            return l_True;\n    }\n    return l_False;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "lbool"
      ]
    },
    "solver_setnvars": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "void solver_setnvars(solver* s,int n)\n{\n    int var;\n\n    if (s->cap < n){\n\n        while (s->cap < n) s->cap = s->cap*2+1;\n\n        s->wlists    = (vecp*)   realloc(s->wlists,\n                                 sizeof(vecp)*s->cap*2);\n        s->activity  = (double*) realloc(s->activity,\n                                 sizeof(double)*s->cap);\n        s->assigns   = (lbool*)  realloc(s->assigns,\n                                 sizeof(lbool)*s->cap);\n        s->orderpos  = (int*)    realloc(s->orderpos,\n                                 sizeof(int)*s->cap);\n        s->reasons   = (clause**)realloc(s->reasons,\n                                 sizeof(clause*)*s->cap);\n        s->levels    = (int*)    realloc(s->levels,\n                                 sizeof(int)*s->cap);\n        s->tags      = (lbool*)  realloc(s->tags,\n                                 sizeof(lbool)*s->cap);\n        s->trail     = (lit*)    realloc(s->trail,\n                                 sizeof(lit)*s->cap);\n    }\n\n    for (var = s->size; var < n; var++){\n        vecp_new(&s->wlists[2*var]);\n        vecp_new(&s->wlists[2*var+1]);\n        s->activity [var] = 0;\n        s->assigns  [var] = l_Undef;\n        s->orderpos [var] = veci_size(&s->order);\n        s->reasons  [var] = (clause*)0;\n        s->levels   [var] = 0;\n        s->tags     [var] = l_Undef;\n\n        /* does not hold because variables enqueued at top level will\n           not be reinserted in the heap\n           assert(veci_size(&s->order) == var);\n         */\n        veci_push(&s->order,var);\n        order_update(s, var);\n    }\n\n    s->size = n > s->size ? n : s->size;\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "enqueue": {
      "start_point": [
        471,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "static inline bool enqueue(solver* s, lit l, clause* from)\n{\n    lbool* values = s->assigns;\n    int    v      = lit_var(l);\n    lbool  val    = values[v];\n    lbool  sig;\n#ifdef VERBOSEDEBUG\n    printf(L_IND\"enqueue(\"L_LIT\")\\n\", L_ind, L_lit(l));\n#endif\n\n    /* lbool */ sig = !lit_sign(l); sig += sig - 1;\n    if (val != l_Undef){\n        return val == sig;\n    }else{\n        /* New fact -- store it. */\n        int*     levels;\n        clause** reasons;\n#ifdef VERBOSEDEBUG\n        printf(L_IND\"bind(\"L_LIT\")\\n\", L_ind, L_lit(l));\n#endif\n        /* int*     */ levels  = s->levels;\n        /* clause** */ reasons = s->reasons;\n\n        values [v] = sig;\n        levels [v] = solver_dlevel(s);\n        reasons[v] = from;\n        s->trail[s->qtail++] = l;\n\n        order_assigned(s, v);\n        return true;\n    }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "bool"
      ]
    },
    "assume": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        512,
        1
      ],
      "content": "static inline void assume(solver* s, lit l){\n    assert(s->qtail == s->qhead);\n    assert(s->assigns[lit_var(l)] == l_Undef);\n#ifdef VERBOSEDEBUG\n    printf(L_IND\"assume(\"L_LIT\")\\n\", L_ind, L_lit(l));\n#endif\n    veci_push(&s->trail_lim,s->qtail);\n    enqueue(s,l,(clause*)0);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "solver_canceluntil": {
      "start_point": [
        514,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "static inline void solver_canceluntil(solver* s, int level) {\n    lit*     trail;\n    lbool*   values;\n    clause** reasons;\n    int      bound;\n    int      c;\n\n    if (solver_dlevel(s) <= level)\n        return;\n\n    trail   = s->trail;\n    values  = s->assigns;\n    reasons = s->reasons;\n    bound   = (veci_begin(&s->trail_lim))[level];\n\n    for (c = s->qtail-1; c >= bound; c--) {\n        int     x  = lit_var(trail[c]);\n        values [x] = l_Undef;\n        reasons[x] = (clause*)0;\n    }\n\n    for (c = s->qhead-1; c >= bound; c--)\n        order_unassigned(s,lit_var(trail[c]));\n\n    s->qhead = s->qtail = bound;\n    veci_resize(&s->trail_lim,level);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "solver_record": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "static void solver_record(solver* s, veci* cls)\n{\n    lit*    begin = veci_begin(cls);\n    lit*    end   = begin + veci_size(cls);\n    clause* c     = (veci_size(cls) > 1) ? clause_new(s,begin,end,1)\n                                         : (clause*)0;\n    enqueue(s,*begin,c);\n\n    assert(veci_size(cls) > 0);\n\n    if (c != 0) {\n        vecp_push(&s->learnts,c);\n        act_clause_bump(s,c);\n        s->stats.learnts++;\n        s->stats.learnts_literals += veci_size(cls);\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "solver_progress": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "static double solver_progress(solver* s)\n{\n    lbool*  values = s->assigns;\n    int*    levels = s->levels;\n    int     i;\n\n    double  progress = 0;\n    double  F        = 1.0 / s->size;\n    for (i = 0; i < s->size; i++)\n        if (values[i] != l_Undef)\n            progress += pow(F, levels[i]);\n    return progress / s->size;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "solver_lit_removable": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "static bool solver_lit_removable(solver* s, lit l, int minl)\n{\n    lbool*   tags    = s->tags;\n    clause** reasons = s->reasons;\n    int*     levels  = s->levels;\n    int      top     = veci_size(&s->tagged);\n\n    assert(lit_var(l) >= 0 && lit_var(l) < s->size);\n    assert(reasons[lit_var(l)] != 0);\n    veci_resize(&s->stack,0);\n    veci_push(&s->stack,lit_var(l));\n\n    while (veci_size(&s->stack) > 0){\n        clause* c;\n        int v = veci_begin(&s->stack)[veci_size(&s->stack)-1];\n        assert(v >= 0 && v < s->size);\n        veci_resize(&s->stack,veci_size(&s->stack)-1);\n        assert(reasons[v] != 0);\n        c    = reasons[v];\n\n        if (clause_is_lit(c)){\n            int v = lit_var(clause_read_lit(c));\n            if (tags[v] == l_Undef && levels[v] != 0){\n                if (reasons[v] != 0\n                    && ((1 << (levels[v] & 31)) & minl)){\n                    veci_push(&s->stack,v);\n                    tags[v] = l_True;\n                    veci_push(&s->tagged,v);\n                }else{\n                    int* tagged = veci_begin(&s->tagged);\n                    int j;\n                    for (j = top; j < veci_size(&s->tagged); j++)\n                        tags[tagged[j]] = l_Undef;\n                    veci_resize(&s->tagged,top);\n                    return false;\n                }\n            }\n        }else{\n            lit*    lits = clause_begin(c);\n            int     i, j;\n\n            for (i = 1; i < clause_size(c); i++){\n                int v = lit_var(lits[i]);\n                if (tags[v] == l_Undef && levels[v] != 0){\n                    if (reasons[v] != 0\n                        && ((1 << (levels[v] & 31)) & minl)){\n\n                        veci_push(&s->stack,lit_var(lits[i]));\n                        tags[v] = l_True;\n                        veci_push(&s->tagged,v);\n                    }else{\n                        int* tagged = veci_begin(&s->tagged);\n                        for (j = top; j < veci_size(&s->tagged); j++)\n                            tags[tagged[j]] = l_Undef;\n                        veci_resize(&s->tagged,top);\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}",
      "lines": 64,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "solver_analyze": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        761,
        1
      ],
      "content": "static void solver_analyze(solver* s, clause* c, veci* learnt)\n{\n    lit*     trail   = s->trail;\n    lbool*   tags    = s->tags;\n    clause** reasons = s->reasons;\n    int*     levels  = s->levels;\n    int      cnt     = 0;\n    lit      p       = lit_Undef;\n    int      ind     = s->qtail-1;\n    lit*     lits;\n    int      i, j, minl;\n    int*     tagged;\n\n    veci_push(learnt,lit_Undef);\n\n    do{\n        assert(c != 0);\n\n        if (clause_is_lit(c)){\n            lit q = clause_read_lit(c);\n            assert(lit_var(q) >= 0 && lit_var(q) < s->size);\n            if (tags[lit_var(q)] == l_Undef && levels[lit_var(q)] > 0){\n                tags[lit_var(q)] = l_True;\n                veci_push(&s->tagged,lit_var(q));\n                act_var_bump(s,lit_var(q));\n                if (levels[lit_var(q)] == solver_dlevel(s))\n                    cnt++;\n                else\n                    veci_push(learnt,q);\n            }\n        }else{\n\n            if (clause_learnt(c))\n                act_clause_bump(s,c);\n\n            lits = clause_begin(c);\n            /* printlits(lits,lits+clause_size(c)); printf(\"\\n\"); */\n            for (j = (p == lit_Undef ? 0 : 1); j < clause_size(c); j++){\n                lit q = lits[j];\n                assert(lit_var(q) >= 0 && lit_var(q) < s->size);\n                if (tags[lit_var(q)] == l_Undef\n                    && levels[lit_var(q)] > 0){\n                    tags[lit_var(q)] = l_True;\n                    veci_push(&s->tagged,lit_var(q));\n                    act_var_bump(s,lit_var(q));\n                    if (levels[lit_var(q)] == solver_dlevel(s))\n                        cnt++;\n                    else\n                        veci_push(learnt,q);\n                }\n            }\n        }\n\n        while (tags[lit_var(trail[ind--])] == l_Undef);\n\n        p = trail[ind+1];\n        c = reasons[lit_var(p)];\n        cnt--;\n\n    }while (cnt > 0);\n\n    *veci_begin(learnt) = lit_neg(p);\n\n    lits = veci_begin(learnt);\n    minl = 0;\n    for (i = 1; i < veci_size(learnt); i++){\n        int lev = levels[lit_var(lits[i])];\n        minl    |= 1 << (lev & 31);\n    }\n\n    /* simplify (full) */\n    for (i = j = 1; i < veci_size(learnt); i++){\n        if (reasons[lit_var(lits[i])] == 0\n            || !solver_lit_removable(s,lits[i],minl))\n            lits[j++] = lits[i];\n    }\n\n    /* update size of learnt + statistics */\n    s->stats.max_literals += veci_size(learnt);\n    veci_resize(learnt,j);\n    s->stats.tot_literals += j;\n\n    /* clear tags */\n    tagged = veci_begin(&s->tagged);\n    for (i = 0; i < veci_size(&s->tagged); i++)\n        tags[tagged[i]] = l_Undef;\n    veci_resize(&s->tagged,0);\n\n#ifdef DEBUG\n    for (i = 0; i < s->size; i++)\n        assert(tags[i] == l_Undef);\n#endif\n\n#ifdef VERBOSEDEBUG\n    printf(L_IND\"Learnt {\", L_ind);\n    for (i = 0; i < veci_size(learnt); i++)\n        printf(\" \"L_LIT, L_lit(lits[i]));\n#endif\n    if (veci_size(learnt) > 1){\n        int max_i = 1;\n        int max   = levels[lit_var(lits[1])];\n        lit tmp;\n\n        for (i = 2; i < veci_size(learnt); i++)\n            if (levels[lit_var(lits[i])] > max){\n                max   = levels[lit_var(lits[i])];\n                max_i = i;\n            }\n\n        tmp         = lits[1];\n        lits[1]     = lits[max_i];\n        lits[max_i] = tmp;\n    }\n#ifdef VERBOSEDEBUG\n    {\n        int lev = veci_size(learnt) > 1 ? levels[lit_var(lits[1])] : 0;\n        printf(\" } at level %d\\n\", lev);\n    }\n#endif\n}",
      "lines": 120,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "solver_propagate": {
      "start_point": [
        763,
        0
      ],
      "end_point": [
        849,
        1
      ],
      "content": "clause* solver_propagate(solver* s)\n{\n    lbool*  values = s->assigns;\n    clause* confl  = (clause*)0;\n    lit*    lits;\n\n    /* printf(\"solver_propagate\\n\"); */\n    while (confl == 0 && s->qtail - s->qhead > 0){\n        lit  p  = s->trail[s->qhead++];\n        vecp* ws = solver_read_wlist(s,p);\n        clause **begin = (clause**)vecp_begin(ws);\n        clause **end   = begin + vecp_size(ws);\n        clause **i, **j;\n\n        s->stats.propagations++;\n        s->simpdb_props--;\n\n        /* printf(\"checking lit %d: \"L_LIT\"\\n\", veci_size(ws),\n               L_lit(p)); */\n        for (i = j = begin; i < end; ){\n            if (clause_is_lit(*i)){\n                *j++ = *i;\n                if (!enqueue(s,clause_read_lit(*i),clause_from_lit(p))){\n                    confl = s->binary;\n                    (clause_begin(confl))[1] = lit_neg(p);\n                    (clause_begin(confl))[0] = clause_read_lit(*i++);\n\n                    /* Copy the remaining watches: */\n                    while (i < end)\n                        *j++ = *i++;\n                }\n            }else{\n                lit false_lit;\n                lbool sig;\n\n                lits = clause_begin(*i);\n\n                /* Make sure the false literal is data[1]: */\n                false_lit = lit_neg(p);\n                if (lits[0] == false_lit){\n                    lits[0] = lits[1];\n                    lits[1] = false_lit;\n                }\n                assert(lits[1] == false_lit);\n                /* printf(\"checking clause: \");\n                   printlits(lits, lits+clause_size(*i));\n                   printf(\"\\n\"); */\n\n                /* If 0th watch is true, then clause is already\n                   satisfied. */\n                sig = !lit_sign(lits[0]); sig += sig - 1;\n                if (values[lit_var(lits[0])] == sig){\n                    *j++ = *i;\n                }else{\n                    /* Look for new watch: */\n                    lit* stop = lits + clause_size(*i);\n                    lit* k;\n                    for (k = lits + 2; k < stop; k++){\n                        lbool sig = lit_sign(*k); sig += sig - 1;\n                        if (values[lit_var(*k)] != sig){\n                            lits[1] = *k;\n                            *k = false_lit;\n                            vecp_push(solver_read_wlist(s,\n                                lit_neg(lits[1])),*i);\n                            goto next; }\n                    }\n\n                    *j++ = *i;\n                    /* Clause is unit under assignment: */\n                    if (!enqueue(s,lits[0], *i)){\n                        confl = *i++;\n                        /* Copy the remaining watches: */\n                        while (i < end)\n                            *j++ = *i++;\n                    }\n                }\n            }\n        next:\n            i++;\n        }\n\n        s->stats.inspects += j - (clause**)vecp_begin(ws);\n        vecp_resize(ws,j - (clause**)vecp_begin(ws));\n    }\n\n    return confl;\n}",
      "lines": 87,
      "depth": 23,
      "decorators": [
        "clause",
        "* solver_propagate(solver* s)",
        "*"
      ]
    },
    "clause_cmp": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        855,
        60
      ],
      "content": "static inline int clause_cmp (const void* x, const void* y) {\n    return clause_size((clause*)x) > 2\n           && (clause_size((clause*)y) == 2\n               || clause_activity((clause*)x)\n                  < clause_activity((clause*)y)) ? -1 : 1; }",
      "lines": 5,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "solver_reducedb": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "void solver_reducedb(solver* s)\n{\n    int      i, j;\n    double   extra_lim = s->cla_inc / vecp_size(&s->learnts);\n             /* Remove any clause below this activity */\n    clause** learnts = (clause**)vecp_begin(&s->learnts);\n    clause** reasons = s->reasons;\n\n    sort(vecp_begin(&s->learnts), vecp_size(&s->learnts), clause_cmp);\n\n    for (i = j = 0; i < vecp_size(&s->learnts) / 2; i++){\n        if (clause_size(learnts[i]) > 2\n            && reasons[lit_var(*clause_begin(learnts[i]))]\n               != learnts[i])\n            clause_remove(s,learnts[i]);\n        else\n            learnts[j++] = learnts[i];\n    }\n    for (; i < vecp_size(&s->learnts); i++){\n        if (clause_size(learnts[i]) > 2\n            && reasons[lit_var(*clause_begin(learnts[i]))]\n               != learnts[i]\n            && clause_activity(learnts[i]) < extra_lim)\n            clause_remove(s,learnts[i]);\n        else\n            learnts[j++] = learnts[i];\n    }\n\n    /* printf(\"reducedb deleted %d\\n\", vecp_size(&s->learnts) - j); */\n\n    vecp_resize(&s->learnts,j);\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "solver_search": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "static lbool solver_search(solver* s, int nof_conflicts,\n                           int nof_learnts)\n{\n    int*    levels          = s->levels;\n    double  var_decay       = 0.95;\n    double  clause_decay    = 0.999;\n    double  random_var_freq = 0.02;\n\n    int     conflictC       = 0;\n    veci    learnt_clause;\n\n    assert(s->root_level == solver_dlevel(s));\n\n    s->stats.starts++;\n    s->var_decay = (float)(1 / var_decay   );\n    s->cla_decay = (float)(1 / clause_decay);\n    veci_resize(&s->model,0);\n    veci_new(&learnt_clause);\n\n    for (;;){\n        clause* confl = solver_propagate(s);\n        if (confl != 0){\n            /* CONFLICT */\n            int blevel;\n\n#ifdef VERBOSEDEBUG\n            printf(L_IND\"**CONFLICT**\\n\", L_ind);\n#endif\n            s->stats.conflicts++; conflictC++;\n            if (solver_dlevel(s) == s->root_level){\n                veci_delete(&learnt_clause);\n                return l_False;\n            }\n\n            veci_resize(&learnt_clause,0);\n            solver_analyze(s, confl, &learnt_clause);\n            blevel = veci_size(&learnt_clause) > 1\n                     ? levels[lit_var(veci_begin(&learnt_clause)[1])]\n                     : s->root_level;\n            blevel = s->root_level > blevel ? s->root_level : blevel;\n            solver_canceluntil(s,blevel);\n            solver_record(s,&learnt_clause);\n            act_var_decay(s);\n            act_clause_decay(s);\n\n        }else{\n            /* NO CONFLICT */\n            int next;\n\n            if (nof_conflicts >= 0 && conflictC >= nof_conflicts){\n                /* Reached bound on number of conflicts: */\n                s->progress_estimate = solver_progress(s);\n                solver_canceluntil(s,s->root_level);\n                veci_delete(&learnt_clause);\n                return l_Undef; }\n\n            if (solver_dlevel(s) == 0)\n                /* Simplify the set of problem clauses: */\n                solver_simplify(s);\n\n            if (nof_learnts >= 0\n                && vecp_size(&s->learnts) - s->qtail >= nof_learnts)\n                /* Reduce the set of learnt clauses: */\n                solver_reducedb(s);\n\n            /* New variable decision: */\n            s->stats.decisions++;\n            next = order_select(s,(float)random_var_freq);\n\n            if (next == var_Undef){\n                /* Model found: */\n                lbool* values = s->assigns;\n                int i;\n                for (i = 0; i < s->size; i++)\n                    veci_push(&s->model,(int)values[i]);\n                solver_canceluntil(s,s->root_level);\n                veci_delete(&learnt_clause);\n\n                /*\n                veci apa; veci_new(&apa);\n                for (i = 0; i < s->size; i++)\n                    veci_push(&apa,(int)(s->model.ptr[i] == l_True\n                        ? toLit(i) : lit_neg(toLit(i))));\n                printf(\"model: \");\n                printlits((lit*)apa.ptr,\n                    (lit*)apa.ptr + veci_size(&apa)); printf(\"\\n\");\n                veci_delete(&apa);\n                */\n\n                return l_True;\n            }\n\n            assume(s,lit_neg(toLit(next)));\n        }\n    }\n\n#if 0 /* by mao; unreachable code */\n    return l_Undef; /* cannot happen */\n#endif\n}",
      "lines": 100,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "lbool"
      ]
    },
    "solver_new": {
      "start_point": [
        994,
        0
      ],
      "end_point": [
        1049,
        1
      ],
      "content": "solver* solver_new(void)\n{\n    solver* s = (solver*)malloc(sizeof(solver));\n\n    /* initialize vectors */\n    vecp_new(&s->clauses);\n    vecp_new(&s->learnts);\n    veci_new(&s->order);\n    veci_new(&s->trail_lim);\n    veci_new(&s->tagged);\n    veci_new(&s->stack);\n    veci_new(&s->model);\n\n    /* initialize arrays */\n    s->wlists    = 0;\n    s->activity  = 0;\n    s->assigns   = 0;\n    s->orderpos  = 0;\n    s->reasons   = 0;\n    s->levels    = 0;\n    s->tags      = 0;\n    s->trail     = 0;\n\n    /* initialize other vars */\n    s->size                   = 0;\n    s->cap                    = 0;\n    s->qhead                  = 0;\n    s->qtail                  = 0;\n    s->cla_inc                = 1;\n    s->cla_decay              = 1;\n    s->var_inc                = 1;\n    s->var_decay              = 1;\n    s->root_level             = 0;\n    s->simpdb_assigns         = 0;\n    s->simpdb_props           = 0;\n    s->random_seed            = 91648253;\n    s->progress_estimate      = 0;\n    s->binary                 = (clause*)malloc(sizeof(clause)\n                                                + sizeof(lit)*2);\n    s->binary->size_learnt    = (2 << 1);\n    s->verbosity              = 0;\n\n    s->stats.starts           = 0;\n    s->stats.decisions        = 0;\n    s->stats.propagations     = 0;\n    s->stats.inspects         = 0;\n    s->stats.conflicts        = 0;\n    s->stats.clauses          = 0;\n    s->stats.clauses_literals = 0;\n    s->stats.learnts          = 0;\n    s->stats.learnts_literals = 0;\n    s->stats.max_literals     = 0;\n    s->stats.tot_literals     = 0;\n\n    return s;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "solver",
        "* solver_new(void)",
        "*"
      ]
    },
    "solver_delete": {
      "start_point": [
        1051,
        0
      ],
      "end_point": [
        1088,
        1
      ],
      "content": "void solver_delete(solver* s)\n{\n    int i;\n    for (i = 0; i < vecp_size(&s->clauses); i++)\n        free(vecp_begin(&s->clauses)[i]);\n\n    for (i = 0; i < vecp_size(&s->learnts); i++)\n        free(vecp_begin(&s->learnts)[i]);\n\n    /* delete vectors */\n    vecp_delete(&s->clauses);\n    vecp_delete(&s->learnts);\n    veci_delete(&s->order);\n    veci_delete(&s->trail_lim);\n    veci_delete(&s->tagged);\n    veci_delete(&s->stack);\n    veci_delete(&s->model);\n    free(s->binary);\n\n    /* delete arrays */\n    if (s->wlists != 0){\n        int i;\n        for (i = 0; i < s->size*2; i++)\n            vecp_delete(&s->wlists[i]);\n\n        /* if one is different from null, all are */\n        free(s->wlists);\n        free(s->activity );\n        free(s->assigns  );\n        free(s->orderpos );\n        free(s->reasons  );\n        free(s->levels   );\n        free(s->trail    );\n        free(s->tags     );\n    }\n\n    free(s);\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "solver_addclause": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1140,
        1
      ],
      "content": "bool solver_addclause(solver* s, lit* begin, lit* end)\n{\n    lit *i,*j;\n    int maxvar;\n    lbool* values;\n    lit last;\n\n    if (begin == end) return false;\n\n    /* printlits(begin,end); printf(\"\\n\"); */\n    /* insertion sort */\n    maxvar = lit_var(*begin);\n    for (i = begin + 1; i < end; i++){\n        lit l = *i;\n        maxvar = lit_var(l) > maxvar ? lit_var(l) : maxvar;\n        for (j = i; j > begin && *(j-1) > l; j--)\n            *j = *(j-1);\n        *j = l;\n    }\n    solver_setnvars(s,maxvar+1);\n\n    /* printlits(begin,end); printf(\"\\n\"); */\n    values = s->assigns;\n\n    /* delete duplicates */\n    last = lit_Undef;\n    for (i = j = begin; i < end; i++){\n        /* printf(\"lit: \"L_LIT\", value = %d\\n\", L_lit(*i),\n        (lit_sign(*i) ? -values[lit_var(*i)] : values[lit_var(*i)])); */\n        lbool sig = !lit_sign(*i); sig += sig - 1;\n        if (*i == lit_neg(last) || sig == values[lit_var(*i)])\n            return true;   /* tautology */\n        else if (*i != last && values[lit_var(*i)] == l_Undef)\n            last = *j++ = *i;\n    }\n\n    /* printf(\"final: \"); printlits(begin,j); printf(\"\\n\"); */\n\n    if (j == begin)          /* empty clause */\n        return false;\n    else if (j - begin == 1) /* unit clause */\n        return enqueue(s,*begin,(clause*)0);\n\n    /* create new clause */\n    vecp_push(&s->clauses,clause_new(s,begin,j,0));\n\n    s->stats.clauses++;\n    s->stats.clauses_literals += j - begin;\n\n    return true;\n}",
      "lines": 51,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "solver_simplify": {
      "start_point": [
        1142,
        0
      ],
      "end_point": [
        1177,
        1
      ],
      "content": "bool   solver_simplify(solver* s)\n{\n    clause** reasons;\n    int type;\n\n    assert(solver_dlevel(s) == 0);\n\n    if (solver_propagate(s) != 0)\n        return false;\n\n    if (s->qhead == s->simpdb_assigns || s->simpdb_props > 0)\n        return true;\n\n    reasons = s->reasons;\n    for (type = 0; type < 2; type++){\n        vecp*    cs  = type ? &s->learnts : &s->clauses;\n        clause** cls = (clause**)vecp_begin(cs);\n\n        int i, j;\n        for (j = i = 0; i < vecp_size(cs); i++){\n            if (reasons[lit_var(*clause_begin(cls[i]))] != cls[i] &&\n                clause_simplify(s,cls[i]) == l_True)\n                clause_remove(s,cls[i]);\n            else\n                cls[j++] = cls[i];\n        }\n        vecp_resize(cs,j);\n    }\n\n    s->simpdb_assigns = s->qhead;\n    /* (shouldn't depend on 'stats' really, but it will do for now) */\n    s->simpdb_props   = (int)(s->stats.clauses_literals\n                              + s->stats.learnts_literals);\n\n    return true;\n}",
      "lines": 36,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "solver_solve": {
      "start_point": [
        1179,
        0
      ],
      "end_point": [
        1244,
        1
      ],
      "content": "bool   solver_solve(solver* s, lit* begin, lit* end)\n{\n    double  nof_conflicts = 100;\n    double  nof_learnts   = solver_nclauses(s) / 3;\n    lbool   status        = l_Undef;\n    lbool*  values        = s->assigns;\n    lit*    i;\n\n    /* printf(\"solve: \"); printlits(begin, end); printf(\"\\n\"); */\n    for (i = begin; i < end; i++){\n        switch (lit_sign(*i) ? -values[lit_var(*i)]\n                             : values[lit_var(*i)]){\n        case 1: /* l_True: */\n            break;\n        case 0: /* l_Undef */\n            assume(s, *i);\n            if (solver_propagate(s) == NULL)\n                break;\n            /* falltrough */\n        case -1: /* l_False */\n            solver_canceluntil(s, 0);\n            return false;\n        }\n    }\n\n    s->root_level = solver_dlevel(s);\n\n    if (s->verbosity >= 1){\n        printf(\"==================================[MINISAT]============\"\n               \"=======================\\n\");\n        printf(\"| Conflicts |     ORIGINAL     |              LEARNT   \"\n               \"           | Progress |\\n\");\n        printf(\"|           | Clauses Literals |   Limit Clauses Litera\"\n               \"ls  Lit/Cl |          |\\n\");\n        printf(\"=======================================================\"\n               \"=======================\\n\");\n    }\n\n    while (status == l_Undef){\n        double Ratio = (s->stats.learnts == 0)? 0.0 :\n            s->stats.learnts_literals / (double)s->stats.learnts;\n\n        if (s->verbosity >= 1){\n            printf(\"| %9.0f | %7.0f %8.0f | %7.0f %7.0f %8.0f %7.1f | %\"\n                   \"6.3f %% |\\n\",\n                (double)s->stats.conflicts,\n                (double)s->stats.clauses,\n                (double)s->stats.clauses_literals,\n                (double)nof_learnts,\n                (double)s->stats.learnts,\n                (double)s->stats.learnts_literals,\n                Ratio,\n                s->progress_estimate*100);\n            fflush(stdout);\n        }\n        status = solver_search(s,(int)nof_conflicts, (int)nof_learnts);\n        nof_conflicts *= 1.5;\n        nof_learnts   *= 1.1;\n    }\n    if (s->verbosity >= 1)\n        printf(\"=======================================================\"\n               \"=======================\\n\");\n\n    solver_canceluntil(s,0);\n    return status != l_False;\n}",
      "lines": 66,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "solver_nvars": {
      "start_point": [
        1246,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "int solver_nvars(solver* s)\n{\n    return s->size;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "solver_nclauses": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "int solver_nclauses(solver* s)\n{\n    return vecp_size(&s->clauses);\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "solver_nconflicts": {
      "start_point": [
        1256,
        0
      ],
      "end_point": [
        1259,
        1
      ],
      "content": "int solver_nconflicts(solver* s)\n{\n    return (int)s->stats.conflicts;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "selectionsort": {
      "start_point": [
        1264,
        0
      ],
      "end_point": [
        1278,
        1
      ],
      "content": "static inline void selectionsort(void** array, int size,\n                                 int(*comp)(const void *, const void *))\n{\n    int     i, j, best_i;\n    void*   tmp;\n\n    for (i = 0; i < size-1; i++){\n        best_i = i;\n        for (j = i+1; j < size; j++){\n            if (comp(array[j], array[best_i]) < 0)\n                best_i = j;\n        }\n        tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;\n    }\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "sortrnd": {
      "start_point": [
        1280,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "static void sortrnd(void** array, int size,\n                    int(*comp)(const void *, const void *),\n                    double* seed)\n{\n    if (size <= 15)\n        selectionsort(array, size, comp);\n\n    else{\n        void*       pivot = array[irand(seed, size)];\n        void*       tmp;\n        int         i = -1;\n        int         j = size;\n\n        for(;;){\n            do i++; while(comp(array[i], pivot)<0);\n            do j--; while(comp(pivot, array[j])<0);\n\n            if (i >= j) break;\n\n            tmp = array[i]; array[i] = array[j]; array[j] = tmp;\n        }\n\n        sortrnd(array    , i     , comp, seed);\n        sortrnd(&array[i], size-i, comp, seed);\n    }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sort": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1312,
        1
      ],
      "content": "static void sort(void** array, int size,\n          int(*comp)(const void *, const void *))\n{\n    double seed = 91648253;\n    sortrnd(array,size,comp,&seed);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/minisat/minisat.h": {},
  "glpk/glpk-4.65/src/misc/avl.c": {
    "avl_create_tree": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "AVL *avl_create_tree(int (*fcmp)(void *info, const void *key1,\n      const void *key2), void *info)\n{     /* create AVL tree */\n      AVL *tree;\n      tree = xmalloc(sizeof(AVL));\n      tree->pool = dmp_create_pool();\n      tree->root = NULL;\n      tree->fcmp = fcmp;\n      tree->info = info;\n      tree->size = 0;\n      tree->height = 0;\n      return tree;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "AVL",
        "*avl_create_tree(int (*fcmp)(void *info, const void *key1,\n      const void *key2), void *info)",
        "*"
      ]
    },
    "avl_strcmp": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int avl_strcmp(void *info, const void *key1, const void *key2)\n{     /* compare character string keys */\n      xassert(info == info);\n      return strcmp(key1, key2);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "avl_insert_node": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "AVLNODE *avl_insert_node(AVL *tree, const void *key)\n{     /* insert new node into AVL tree */\n      AVLNODE *p, *q, *r;\n      short int flag;\n      /* find an appropriate point for insertion */\n      p = NULL; q = tree->root;\n      while (q != NULL)\n      {  p = q;\n         if (tree->fcmp(tree->info, key, p->key) <= 0)\n         {  flag = 0;\n            q = p->left;\n            p->rank++;\n         }\n         else\n         {  flag = 1;\n            q = p->right;\n         }\n      }\n      /* create new node and insert it into the tree */\n      r = dmp_get_atom(tree->pool, sizeof(AVLNODE));\n      r->key = key; r->type = 0; r->link = NULL;\n      r->rank = 1; r->up = p;\n      r->flag = (short int)(p == NULL ? 0 : flag);\n      r->bal = 0; r->left = NULL; r->right = NULL;\n      tree->size++;\n      if (p == NULL)\n         tree->root = r;\n      else\n         if (flag == 0) p->left = r; else p->right = r;\n      /* go upstairs to the root and correct all subtrees affected by\n         insertion */\n      while (p != NULL)\n      {  if (flag == 0)\n         {  /* the height of the left subtree of [p] is increased */\n            if (p->bal > 0)\n            {  p->bal = 0;\n               break;\n            }\n            if (p->bal < 0)\n            {  rotate_subtree(tree, p);\n               break;\n            }\n            p->bal = -1; flag = p->flag; p = p->up;\n         }\n         else\n         {  /* the height of the right subtree of [p] is increased */\n            if (p->bal < 0)\n            {  p->bal = 0;\n               break;\n            }\n            if (p->bal > 0)\n            {  rotate_subtree(tree, p);\n               break;\n            }\n            p->bal = +1; flag = p->flag; p = p->up;\n         }\n      }\n      /* if the root has been reached, the height of the entire tree is\n         increased */\n      if (p == NULL) tree->height++;\n      return r;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "AVLNODE",
        "*avl_insert_node(AVL *tree, const void *key)",
        "*"
      ]
    },
    "avl_set_node_type": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void avl_set_node_type(AVLNODE *node, int type)\n{     /* assign the type field of specified node */\n      node->type = type;\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "avl_set_node_link": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "void avl_set_node_link(AVLNODE *node, void *link)\n{     /* assign the link field of specified node */\n      node->link = link;\n      return;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "avl_find_node": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "AVLNODE *avl_find_node(AVL *tree, const void *key)\n{     /* find node in AVL tree */\n      AVLNODE *p;\n      int c;\n      p = tree->root;\n      while (p != NULL)\n      {  c = tree->fcmp(tree->info, key, p->key);\n         if (c == 0) break;\n         p = (c < 0 ? p->left : p->right);\n      }\n      return p;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "AVLNODE",
        "*avl_find_node(AVL *tree, const void *key)",
        "*"
      ]
    },
    "avl_get_node_type": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int avl_get_node_type(AVLNODE *node)\n{     /* retrieve the type field of specified node */\n      return node->type;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "avl_get_node_link": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void *avl_get_node_link(AVLNODE *node)\n{     /* retrieve the link field of specified node */\n      return node->link;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*avl_get_node_link(AVLNODE *node)",
        "*"
      ]
    },
    "find_next_node": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static AVLNODE *find_next_node(AVL *tree, AVLNODE *node)\n{     /* find next node in AVL tree */\n      AVLNODE *p, *q;\n      if (tree->root == NULL) return NULL;\n      p = node;\n      q = (p == NULL ? tree->root : p->right);\n      if (q == NULL)\n      {  /* go upstairs from the left subtree */\n         for (;;)\n         {  q = p->up;\n            if (q == NULL) break;\n            if (p->flag == 0) break;\n            p = q;\n         }\n      }\n      else\n      {  /* go downstairs into the right subtree */\n         for (;;)\n         {  p = q->left;\n            if (p == NULL) break;\n            q = p;\n         }\n      }\n      return q;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "AVLNODE",
        "*find_next_node(AVL *tree, AVLNODE *node)",
        "*"
      ]
    },
    "avl_delete_node": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "void avl_delete_node(AVL *tree, AVLNODE *node)\n{     /* delete specified node from AVL tree */\n      AVLNODE *f, *p, *q, *r, *s, *x, *y;\n      short int flag;\n      p = node;\n      /* if both subtrees of the specified node are non-empty, the node\n         should be interchanged with the next one, at least one subtree\n         of which is always empty */\n      if (p->left == NULL || p->right == NULL) goto skip;\n      f = p->up; q = p->left;\n      r = find_next_node(tree, p); s = r->right;\n      if (p->right == r)\n      {  if (f == NULL)\n            tree->root = r;\n         else\n            if (p->flag == 0) f->left = r; else f->right = r;\n         r->rank = p->rank; r->up = f;\n         r->flag = p->flag; r->bal = p->bal;\n         r->left = q; r->right = p;\n         q->up = r;\n         p->rank = 1; p->up = r; p->flag = 1;\n         p->bal = (short int)(s == NULL ? 0 : +1);\n         p->left = NULL; p->right = s;\n         if (s != NULL) s->up = p;\n      }\n      else\n      {  x = p->right; y = r->up;\n         if (f == NULL)\n            tree->root = r;\n         else\n            if (p->flag == 0) f->left = r; else f->right = r;\n         r->rank = p->rank; r->up = f;\n         r->flag = p->flag; r->bal = p->bal;\n         r->left = q; r->right = x;\n         q->up = r; x->up = r; y->left = p;\n         p->rank = 1; p->up = y; p->flag = 0;\n         p->bal = (short int)(s == NULL ? 0 : +1);\n         p->left = NULL; p->right = s;\n         if (s != NULL) s->up = p;\n      }\nskip: /* now the specified node [p] has at least one empty subtree;\n         go upstairs to the root and adjust the rank field of all nodes\n         affected by deletion */\n      q = p; f = q->up;\n      while (f != NULL)\n      {  if (q->flag == 0) f->rank--;\n         q = f; f = q->up;\n      }\n      /* delete the specified node from the tree */\n      f = p->up; flag = p->flag;\n      q = p->left != NULL ? p->left : p->right;\n      if (f == NULL)\n         tree->root = q;\n      else\n         if (flag == 0) f->left = q; else f->right = q;\n      if (q != NULL) q->up = f, q->flag = flag;\n      tree->size--;\n      /* go upstairs to the root and correct all subtrees affected by\n         deletion */\n      while (f != NULL)\n      {  if (flag == 0)\n         {  /* the height of the left subtree of [f] is decreased */\n            if (f->bal == 0)\n            {  f->bal = +1;\n               break;\n            }\n            if (f->bal < 0)\n               f->bal = 0;\n            else\n            {  f = rotate_subtree(tree, f);\n               if (f->bal < 0) break;\n            }\n            flag = f->flag; f = f->up;\n         }\n         else\n         {  /* the height of the right subtree of [f] is decreased */\n            if (f->bal == 0)\n            {  f->bal = -1;\n               break;\n            }\n            if (f->bal > 0)\n               f->bal = 0;\n            else\n            {  f = rotate_subtree(tree, f);\n               if (f->bal > 0) break;\n            }\n            flag = f->flag; f = f->up;\n         }\n      }\n      /* if the root has been reached, the height of the entire tree is\n         decreased */\n      if (f == NULL) tree->height--;\n      /* returns the deleted node to the memory pool */\n      dmp_free_atom(tree->pool, p, sizeof(AVLNODE));\n      return;\n}",
      "lines": 96,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rotate_subtree": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        395,
        1
      ],
      "content": "static AVLNODE *rotate_subtree(AVL *tree, AVLNODE *node)\n{     /* restore balance of AVL subtree */\n      AVLNODE *f, *p, *q, *r, *x, *y;\n      xassert(node != NULL);\n      p = node;\n      if (p->bal < 0)\n      {  /* perform negative (left) rotation */\n         f = p->up; q = p->left; r = q->right;\n         if (q->bal <= 0)\n         {  /* perform single negative rotation */\n            if (f == NULL)\n               tree->root = q;\n            else\n               if (p->flag == 0) f->left = q; else f->right = q;\n            p->rank -= q->rank;\n            q->up = f; q->flag = p->flag; q->bal++; q->right = p;\n            p->up = q; p->flag = 1;\n            p->bal = (short int)(-q->bal); p->left = r;\n            if (r != NULL) r->up = p, r->flag = 0;\n            node = q;\n         }\n         else\n         {  /* perform double negative rotation */\n            x = r->left; y = r->right;\n            if (f == NULL)\n               tree->root = r;\n            else\n               if (p->flag == 0) f->left = r; else f->right = r;\n            p->rank -= (q->rank + r->rank);\n            r->rank += q->rank;\n            p->bal = (short int)(r->bal >= 0 ? 0 : +1);\n            q->bal = (short int)(r->bal <= 0 ? 0 : -1);\n            r->up = f; r->flag = p->flag; r->bal = 0;\n            r->left = q; r->right = p;\n            p->up = r; p->flag = 1; p->left = y;\n            q->up = r; q->flag = 0; q->right = x;\n            if (x != NULL) x->up = q, x->flag = 1;\n            if (y != NULL) y->up = p, y->flag = 0;\n            node = r;\n         }\n      }\n      else\n      {  /* perform positive (right) rotation */\n         f = p->up; q = p->right; r = q->left;\n         if (q->bal >= 0)\n         {  /* perform single positive rotation */\n            if (f == NULL)\n               tree->root = q;\n            else\n               if (p->flag == 0) f->left = q; else f->right = q;\n            q->rank += p->rank;\n            q->up = f; q->flag = p->flag; q->bal--; q->left = p;\n            p->up = q; p->flag = 0;\n            p->bal = (short int)(-q->bal); p->right = r;\n            if (r != NULL) r->up = p, r->flag = 1;\n            node = q;\n         }\n         else\n         {  /* perform double positive rotation */\n            x = r->left; y = r->right;\n            if (f == NULL)\n               tree->root = r;\n            else\n               if (p->flag == 0) f->left = r; else f->right = r;\n            q->rank -= r->rank;\n            r->rank += p->rank;\n            p->bal = (short int)(r->bal <= 0 ? 0 : -1);\n            q->bal = (short int)(r->bal >= 0 ? 0 : +1);\n            r->up = f; r->flag = p->flag; r->bal = 0;\n            r->left = p; r->right = q;\n            p->up = r; p->flag = 0; p->right = x;\n            q->up = r; q->flag = 1; q->left = y;\n            if (x != NULL) x->up = p, x->flag = 1;\n            if (y != NULL) y->up = q, y->flag = 0;\n            node = r;\n         }\n      }\n      return node;\n}",
      "lines": 79,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "AVLNODE",
        "*rotate_subtree(AVL *tree, AVLNODE *node)",
        "*"
      ]
    },
    "avl_delete_tree": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "void avl_delete_tree(AVL *tree)\n{     /* delete AVL tree */\n      dmp_delete_pool(tree->pool);\n      xfree(tree);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/avl.h": {},
  "glpk/glpk-4.65/src/misc/bignum.c": {
    "bigmul": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void bigmul(int n, int m, unsigned short x[], unsigned short y[])\n{     int i, j;\n      unsigned int t;\n      xassert(n >= 1);\n      xassert(m >= 1);\n      for (j = 0; j < m; j++) x[j] = 0;\n      for (i = 0; i < n; i++)\n      {  if (x[i+m])\n         {  t = 0;\n            for (j = 0; j < m; j++)\n            {  t += (unsigned int)x[i+m] * (unsigned int)y[j] +\n                    (unsigned int)x[i+j];\n               x[i+j] = (unsigned short)t;\n               t >>= 16;\n            }\n            x[i+m] = (unsigned short)t;\n         }\n      }\n      return;\n}",
      "lines": 20,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "bigdiv": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        227,
        1
      ],
      "content": "void bigdiv(int n, int m, unsigned short x[], unsigned short y[])\n{     int i, j;\n      unsigned int t;\n      unsigned short d, q, r;\n      xassert(n >= 0);\n      xassert(m >= 1);\n      xassert(y[m-1] != 0);\n      /* special case when divisor has the only digit */\n      if (m == 1)\n      {  d = 0;\n         for (i = n; i >= 0; i--)\n         {  t = ((unsigned int)d << 16) + (unsigned int)x[i];\n            x[i+1] = (unsigned short)(t / y[0]);\n            d = (unsigned short)(t % y[0]);\n         }\n         x[0] = d;\n         goto done;\n      }\n      /* multiply dividend and divisor by a normalizing coefficient in\n       * order to provide the condition y[m-1] >= base / 2 */\n      d = (unsigned short)(0x10000 / ((unsigned int)y[m-1] + 1));\n      if (d == 1)\n         x[n+m] = 0;\n      else\n      {  t = 0;\n         for (i = 0; i < n+m; i++)\n         {  t += (unsigned int)x[i] * (unsigned int)d;\n            x[i] = (unsigned short)t;\n            t >>= 16;\n         }\n         x[n+m] = (unsigned short)t;\n         t = 0;\n         for (j = 0; j < m; j++)\n         {  t += (unsigned int)y[j] * (unsigned int)d;\n            y[j] = (unsigned short)t;\n            t >>= 16;\n         }\n      }\n      /* main loop */\n      for (i = n; i >= 0; i--)\n      {  /* estimate and correct the current digit of quotient */\n         if (x[i+m] < y[m-1])\n         {  t = ((unsigned int)x[i+m] << 16) + (unsigned int)x[i+m-1];\n            q = (unsigned short)(t / (unsigned int)y[m-1]);\n            r = (unsigned short)(t % (unsigned int)y[m-1]);\n            if (q == 0) goto putq; else goto test;\n         }\n         q = 0;\n         r = x[i+m-1];\ndecr:    q--; /* if q = 0 then q-- = 0xFFFF */\n         t = (unsigned int)r + (unsigned int)y[m-1];\n         r = (unsigned short)t;\n         if (t > 0xFFFF) goto msub;\ntest:    t = (unsigned int)y[m-2] * (unsigned int)q;\n         if ((unsigned short)(t >> 16) > r) goto decr;\n         if ((unsigned short)(t >> 16) < r) goto msub;\n         if ((unsigned short)t > x[i+m-2]) goto decr;\nmsub:    /* now subtract divisor multiplied by the current digit of\n          * quotient from the current dividend */\n         if (q == 0) goto putq;\n         t = 0;\n         for (j = 0; j < m; j++)\n         {  t += (unsigned int)y[j] * (unsigned int)q;\n            if (x[i+j] < (unsigned short)t) t += 0x10000;\n            x[i+j] -= (unsigned short)t;\n            t >>= 16;\n         }\n         if (x[i+m] >= (unsigned short)t) goto putq;\n         /* perform correcting addition, because the current digit of\n          * quotient is greater by one than its correct value */\n         q--;\n         t = 0;\n         for (j = 0; j < m; j++)\n         {  t += (unsigned int)x[i+j] + (unsigned int)y[j];\n            x[i+j] = (unsigned short)t;\n            t >>= 16;\n         }\nputq:    /* store the current digit of quotient */\n         x[i+m] = q;\n      }\n      /* divide divisor and remainder by the normalizing coefficient in\n       * order to restore their original values */\n      if (d > 1)\n      {  t = 0;\n         for (i = m-1; i >= 0; i--)\n         {  t = (t << 16) + (unsigned int)x[i];\n            x[i] = (unsigned short)(t / (unsigned int)d);\n            t %= (unsigned int)d;\n         }\n         t = 0;\n         for (j = m-1; j >= 0; j--)\n         {  t = (t << 16) + (unsigned int)y[j];\n            y[j] = (unsigned short)(t / (unsigned int)d);\n            t %= (unsigned int)d;\n         }\n      }\ndone: return;\n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "int main(void)\n{     RNG *rand;\n      int d, j, n, m, test;\n      unsigned short x[N_MAX], y[M_MAX], z[N_MAX+M_MAX];\n      rand = rng_create_rand();\n      for (test = 1; test <= N_TEST; test++)\n      {  /* x[0,...,n-1] := multiplicand */\n         n = 1 + rng_unif_rand(rand, N_MAX-1);\n         assert(1 <= n && n <= N_MAX);\n         for (j = 0; j < n; j++)\n         {  d = rng_unif_rand(rand, 65536);\n            assert(0 <= d && d <= 65535);\n            x[j] = (unsigned short)d;\n         }\n         /* y[0,...,m-1] := multiplier */\n         m = 1 + rng_unif_rand(rand, M_MAX-1);\n         assert(1 <= m && m <= M_MAX);\n         for (j = 0; j < m; j++)\n         {  d = rng_unif_rand(rand, 65536);\n            assert(0 <= d && d <= 65535);\n            y[j] = (unsigned short)d;\n         }\n         if (y[m-1] == 0) y[m-1] = 1;\n         /* z[0,...,n+m-1] := x * y */\n         for (j = 0; j < n; j++) z[m+j] = x[j];\n         bigmul(n, m, z, y);\n         /* z[0,...,m-1] := z mod y, z[m,...,n+m-1] := z div y */\n         bigdiv(n, m, z, y);\n         /* z mod y must be 0 */\n         for (j = 0; j < m; j++) assert(z[j] == 0);\n         /* z div y must be x */\n         for (j = 0; j < n; j++) assert(z[m+j] == x[j]);\n      }\n      fprintf(stderr, \"%d tests successfully passed\\n\", N_TEST);\n      rng_delete_rand(rand);\n      return 0;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/bignum.h": {},
  "glpk/glpk-4.65/src/misc/dimacs.c": {
    "dmx_error": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void dmx_error(DMX *csa, const char *fmt, ...)\n{     /* print error message and terminate processing */\n      va_list arg;\n      xprintf(\"%s:%d: error: \", csa->fname, csa->count);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      xprintf(\"\\n\");\n      longjmp(csa->jump, 1);\n      /* no return */\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dmx_warning": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void dmx_warning(DMX *csa, const char *fmt, ...)\n{     /* print warning message and continue processing */\n      va_list arg;\n      xprintf(\"%s:%d: warning: \", csa->fname, csa->count);\n      va_start(arg, fmt);\n      xvprintf(fmt, arg);\n      va_end(arg);\n      xprintf(\"\\n\");\n      return;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dmx_read_char": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void dmx_read_char(DMX *csa)\n{     /* read character from input text file */\n      int c;\n      if (csa->c == '\\n') csa->count++;\n      c = glp_getc(csa->fp);\n      if (c < 0)\n      {  if (glp_ioerr(csa->fp))\n            dmx_error(csa, \"read error - %s\", get_err_msg());\n         else if (csa->c == '\\n')\n            dmx_error(csa, \"unexpected end of file\");\n         else\n         {  dmx_warning(csa, \"missing final end of line\");\n            c = '\\n';\n         }\n      }\n      else if (c == '\\n')\n         ;\n      else if (isspace(c))\n         c = ' ';\n      else if (iscntrl(c))\n         dmx_error(csa, \"invalid control character 0x%02X\", c);\n      csa->c = c;\n      return;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dmx_read_designator": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void dmx_read_designator(DMX *csa)\n{     /* read one-character line designator */\n      xassert(csa->c == '\\n');\n      dmx_read_char(csa);\n      for (;;)\n      {  /* skip preceding white-space characters */\n         while (csa->c == ' ')\n            dmx_read_char(csa);\n         if (csa->c == '\\n')\n         {  /* ignore empty line */\n            if (!csa->empty)\n            {  dmx_warning(csa, \"empty line ignored\");\n               csa->empty = 1;\n            }\n            dmx_read_char(csa);\n         }\n         else if (csa->c == 'c')\n         {  /* skip comment line */\n            while (csa->c != '\\n')\n               dmx_read_char(csa);\n            dmx_read_char(csa);\n         }\n         else\n         {  /* hmm... looks like a line designator */\n            csa->field[0] = (char)csa->c, csa->field[1] = '\\0';\n            /* check that it is followed by a white-space character */\n            dmx_read_char(csa);\n            if (!(csa->c == ' ' || csa->c == '\\n'))\n               dmx_error(csa, \"line designator missing or invalid\");\n            break;\n         }\n      }\n      return;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "dmx_read_field": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void dmx_read_field(DMX *csa)\n{     /* read data field */\n      int len = 0;\n      /* skip preceding white-space characters */\n      while (csa->c == ' ')\n         dmx_read_char(csa);\n      /* scan data field */\n      if (csa->c == '\\n')\n         dmx_error(csa, \"unexpected end of line\");\n      while (!(csa->c == ' ' || csa->c == '\\n'))\n      {  if (len == sizeof(csa->field)-1)\n            dmx_error(csa, \"data field '%.15s...' too long\",\n               csa->field);\n         csa->field[len++] = (char)csa->c;\n         dmx_read_char(csa);\n      }\n      csa->field[len] = '\\0';\n      return;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "dmx_end_of_line": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void dmx_end_of_line(DMX *csa)\n{     /* skip white-space characters until end of line */\n      while (csa->c == ' ')\n         dmx_read_char(csa);\n      if (csa->c != '\\n')\n         dmx_error(csa, \"too many data fields specified\");\n      return;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "dmx_check_int": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "void dmx_check_int(DMX *csa, double num)\n{     /* print a warning if non-integer data are detected */\n      if (!csa->nonint && num != floor(num))\n      {  dmx_warning(csa, \"non-integer data detected\");\n         csa->nonint = 1;\n      }\n      return;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/dimacs.h": {},
  "glpk/glpk-4.65/src/misc/dmp.c": {
    "dmp_create_pool": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "DMP *dmp_create_pool(void)\n{     DMP *pool;\n      int k;\n      xassert(sizeof(void *) <= 8);\n      if (dmp_debug)\n         xprintf(\"dmp_create_pool: warning: debug mode is on\\n\");\n      pool = talloc(1, DMP);\n      for (k = 0; k <= 31; k++)\n         pool->avail[k] = NULL;\n      pool->block = NULL;\n      pool->used = DMP_BLK_SIZE;\n      pool->count = 0;\n      return pool;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "DMP",
        "*dmp_create_pool(void)",
        "*"
      ]
    },
    "dmp_get_atom": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void *dmp_get_atom(DMP *pool, int size)\n{     void *atom;\n      int k, need;\n      xassert(1 <= size && size <= 256);\n      /* round up atom size to multiple of 8 bytes */\n      need = (size + 7) & ~7;\n      /* determine number of corresponding list of free atoms */\n      k = (need >> 3) - 1;\n      /* obtain free atom */\n      if (pool->avail[k] == NULL)\n      {  /* corresponding list of free atoms is empty */\n         /* if debug mode is on, add atom prefix size */\n         if (dmp_debug)\n            need += prefix_size;\n         if (pool->used + need > DMP_BLK_SIZE)\n         {  /* allocate new memory block */\n            void *block = talloc(DMP_BLK_SIZE, char);\n            *(void **)block = pool->block;\n            pool->block = block;\n            pool->used = 8; /* sufficient to store pointer */\n         }\n         /* allocate new atom in current memory block */\n         atom = (char *)pool->block + pool->used;\n         pool->used += need;\n      }\n      else\n      {  /* obtain atom from corresponding list of free atoms */\n         atom  = pool->avail[k];\n         pool->avail[k] = *(void **)atom;\n      }\n      /* if debug mode is on, fill atom prefix */\n      if (dmp_debug)\n      {  ((struct prefix *)atom)->pool = pool;\n         ((struct prefix *)atom)->size = size;\n         atom = (char *)atom + prefix_size;\n      }\n      /* increase number of allocated atoms */\n      pool->count++;\n      return atom;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "void",
        "*dmp_get_atom(DMP *pool, int size)",
        "*"
      ]
    },
    "dmp_free_atom": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void dmp_free_atom(DMP *pool, void *atom, int size)\n{     int k;\n      xassert(1 <= size && size <= 256);\n      /* determine number of corresponding list of free atoms */\n      k = ((size + 7) >> 3) - 1;\n      /* if debug mode is on, check atom prefix */\n      if (dmp_debug)\n      {  atom = (char *)atom - prefix_size;\n         xassert(((struct prefix *)atom)->pool == pool);\n         xassert(((struct prefix *)atom)->size == size);\n      }\n      /* return atom to corresponding list of free atoms */\n      *(void **)atom = pool->avail[k];\n      pool->avail[k] = atom;\n      /* decrease number of allocated atoms */\n      xassert(pool->count > 0);\n      pool->count--;\n      return;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "dmp_in_use": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "size_t dmp_in_use(DMP *pool)\n{     return\n         pool->count;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "dmp_delete_pool": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void dmp_delete_pool(DMP *pool)\n{     while (pool->block != NULL)\n      {  void *block = pool->block;\n         pool->block = *(void **)block;\n         tfree(block);\n      }\n      tfree(pool);\n      return;\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/dmp.h": {},
  "glpk/glpk-4.65/src/misc/ffalg.c": {
    "ffalg": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void ffalg(int nv, int na, const int tail[], const int head[],\n      int s, int t, const int cap[], int x[], char cut[])\n{     int a, delta, i, j, k, pos1, pos2, temp,\n         *ptr, *arc, *link, *list;\n      /* sanity checks */\n      xassert(nv >= 2);\n      xassert(na >= 0);\n      xassert(1 <= s && s <= nv);\n      xassert(1 <= t && t <= nv);\n      xassert(s != t);\n      for (a = 1; a <= na; a++)\n      {  i = tail[a], j = head[a];\n         xassert(1 <= i && i <= nv);\n         xassert(1 <= j && j <= nv);\n         xassert(i != j);\n         xassert(cap[a] >= 0);\n      }\n      /* allocate working arrays */\n      ptr = xcalloc(1+nv+1, sizeof(int));\n      arc = xcalloc(1+na+na, sizeof(int));\n      link = xcalloc(1+nv, sizeof(int));\n      list = xcalloc(1+nv, sizeof(int));\n      /* ptr[i] := (degree of node i) */\n      for (i = 1; i <= nv; i++)\n         ptr[i] = 0;\n      for (a = 1; a <= na; a++)\n      {  ptr[tail[a]]++;\n         ptr[head[a]]++;\n      }\n      /* initialize arc pointers */\n      ptr[1]++;\n      for (i = 1; i < nv; i++)\n         ptr[i+1] += ptr[i];\n      ptr[nv+1] = ptr[nv];\n      /* build arc lists */\n      for (a = 1; a <= na; a++)\n      {  arc[--ptr[tail[a]]] = a;\n         arc[--ptr[head[a]]] = a;\n      }\n      xassert(ptr[1] == 1);\n      xassert(ptr[nv+1] == na+na+1);\n      /* now the indices of arcs incident to node i are stored in\n       * locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */\n      /* initialize arc flows */\n      for (a = 1; a <= na; a++)\n         x[a] = 0;\nloop: /* main loop starts here */\n      /* build augmenting tree rooted at s */\n      /* link[i] = 0 means that node i is not labelled yet;\n       * link[i] = a means that arc a immediately precedes node i */\n      /* initially node s is labelled as the root */\n      for (i = 1; i <= nv; i++)\n         link[i] = 0;\n      link[s] = -1, list[1] = s, pos1 = pos2 = 1;\n      /* breadth first search */\n      while (pos1 <= pos2)\n      {  /* dequeue node i */\n         i = list[pos1++];\n         /* consider all arcs incident to node i */\n         for (k = ptr[i]; k < ptr[i+1]; k++)\n         {  a = arc[k];\n            if (tail[a] == i)\n            {  /* a = i->j is a forward arc from s to t */\n               j = head[a];\n               /* if node j has been labelled, skip the arc */\n               if (link[j] != 0) continue;\n               /* if the arc does not allow increasing the flow through\n                * it, skip the arc */\n               if (x[a] == cap[a]) continue;\n            }\n            else if (head[a] == i)\n            {  /* a = i<-j is a backward arc from s to t */\n               j = tail[a];\n               /* if node j has been labelled, skip the arc */\n               if (link[j] != 0) continue;\n               /* if the arc does not allow decreasing the flow through\n                * it, skip the arc */\n               if (x[a] == 0) continue;\n            }\n            else\n               xassert(a != a);\n            /* label node j and enqueue it */\n            link[j] = a, list[++pos2] = j;\n            /* check for breakthrough */\n            if (j == t) goto brkt;\n         }\n      }\n      /* NONBREAKTHROUGH */\n      /* no augmenting path exists; current flow is maximal */\n      /* store minimal cut information, if necessary */\n      if (cut != NULL)\n      {  for (i = 1; i <= nv; i++)\n            cut[i] = (char)(link[i] != 0);\n      }\n      goto done;\nbrkt: /* BREAKTHROUGH */\n      /* walk through arcs of the augmenting path (s, ..., t) found in\n       * the reverse order and determine maximal change of the flow */\n      delta = 0;\n      for (j = t; j != s; j = i)\n      {  /* arc a immediately precedes node j in the path */\n         a = link[j];\n         if (head[a] == j)\n         {  /* a = i->j is a forward arc of the cycle */\n            i = tail[a];\n            /* x[a] may be increased until its upper bound */\n            temp = cap[a] - x[a];\n         }\n         else if (tail[a] == j)\n         {  /* a = i<-j is a backward arc of the cycle */\n            i = head[a];\n            /* x[a] may be decreased until its lower bound */\n            temp = x[a];\n         }\n         else\n            xassert(a != a);\n         if (delta == 0 || delta > temp) delta = temp;\n      }\n      xassert(delta > 0);\n      /* increase the flow along the path */\n      for (j = t; j != s; j = i)\n      {  /* arc a immediately precedes node j in the path */\n         a = link[j];\n         if (head[a] == j)\n         {  /* a = i->j is a forward arc of the cycle */\n            i = tail[a];\n            x[a] += delta;\n         }\n         else if (tail[a] == j)\n         {  /* a = i<-j is a backward arc of the cycle */\n            i = head[a];\n            x[a] -= delta;\n         }\n         else\n            xassert(a != a);\n      }\n      goto loop;\ndone: /* free working arrays */\n      xfree(ptr);\n      xfree(arc);\n      xfree(link);\n      xfree(list);\n      return;\n}",
      "lines": 144,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/ffalg.h": {},
  "glpk/glpk-4.65/src/misc/fp2rat.c": {
    "fp2rat": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int fp2rat(double x, double eps, double *p, double *q)\n{     int k;\n      double xk, Akm1, Ak, Bkm1, Bk, ak, bk, fk, temp;\n      xassert(0.0 <= x && x < 1.0);\n      for (k = 0; ; k++)\n      {  xassert(k <= 100);\n         if (k == 0)\n         {  /* x[0] = x */\n            xk = x;\n            /* A[-1] = 1 */\n            Akm1 = 1.0;\n            /* A[0] = b[0] = floor(x[0]) = 0 */\n            Ak = 0.0;\n            /* B[-1] = 0 */\n            Bkm1 = 0.0;\n            /* B[0] = 1 */\n            Bk = 1.0;\n         }\n         else\n         {  /* x[k] = 1 / frac(x[k-1]) */\n            temp = xk - floor(xk);\n            xassert(temp != 0.0);\n            xk = 1.0 / temp;\n            /* a[k] = 1 */\n            ak = 1.0;\n            /* b[k] = floor(x[k]) */\n            bk = floor(xk);\n            /* A[k] = b[k] * A[k-1] + a[k] * A[k-2] */\n            temp = bk * Ak + ak * Akm1;\n            Akm1 = Ak, Ak = temp;\n            /* B[k] = b[k] * B[k-1] + a[k] * B[k-2] */\n            temp = bk * Bk + ak * Bkm1;\n            Bkm1 = Bk, Bk = temp;\n         }\n         /* f[k] = A[k] / B[k] */\n         fk = Ak / Bk;\n#if 0\n         print(\"%.*g / %.*g = %.*g\",\n            DBL_DIG, Ak, DBL_DIG, Bk, DBL_DIG, fk);\n#endif\n         if (fabs(x - fk) <= eps)\n            break;\n      }\n      *p = Ak;\n      *q = Bk;\n      return k;\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/fvs.c": {
    "fvs_alloc_vec": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void fvs_alloc_vec(FVS *x, int n)\n{     /* allocate sparse vector */\n      int j;\n      xassert(n >= 0);\n      x->n = n;\n      x->nnz = 0;\n      x->ind = talloc(1+n, int);\n      x->vec = talloc(1+n, double);\n      for (j = 1; j <= n; j++)\n         x->vec[j] = 0.0;\n      return;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fvs_check_vec": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void fvs_check_vec(const FVS *x)\n{     /* check sparse vector */\n      /* NOTE: for testing/debugging only */\n      int n = x->n;\n      int nnz = x->nnz;\n      int *ind = x->ind;\n      double *vec = x->vec;\n      char *map;\n      int j, k;\n      xassert(n >= 0);\n      xassert(0 <= nnz && nnz <= n);\n      map = talloc(1+n, char);\n      for (j = 1; j <= n; j++)\n         map[j] = (vec[j] != 0.0);\n      for (k = 1; k <= nnz; k++)\n      {  j = ind[k];\n         xassert(1 <= j && j <= n);\n         xassert(map[j]);\n         map[j] = 0;\n      }\n      for (j = 1; j <= n; j++)\n         xassert(!map[j]);\n      tfree(map);\n      return;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fvs_gather_vec": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void fvs_gather_vec(FVS *x, double eps)\n{     /* gather sparse vector */\n      int n = x->n;\n      int *ind = x->ind;\n      double *vec = x->vec;\n      int j, nnz = 0;\n      for (j = n; j >= 1; j--)\n      {  if (-eps < vec[j] && vec[j] < +eps)\n            vec[j] = 0.0;\n         else\n            ind[++nnz] = j;\n      }\n      x->nnz = nnz;\n      return;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fvs_clear_vec": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void fvs_clear_vec(FVS *x)\n{     /* clear sparse vector */\n      int *ind = x->ind;\n      double *vec = x->vec;\n      int k;\n      for (k = x->nnz; k >= 1; k--)\n         vec[ind[k]] = 0.0;\n      x->nnz = 0;\n      return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "fvs_copy_vec": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void fvs_copy_vec(FVS *x, const FVS *y)\n{     /* copy sparse vector */\n      int *x_ind = x->ind;\n      double *x_vec = x->vec;\n      int *y_ind = y->ind;\n      double *y_vec = y->vec;\n      int j, k;\n      xassert(x != y);\n      xassert(x->n == y->n);\n      fvs_clear_vec(x);\n      for (k = x->nnz = y->nnz; k >= 1; k--)\n      {  j = x_ind[k] = y_ind[k];\n         x_vec[j] = y_vec[j];\n      }\n      return;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "fvs_adjust_vec": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void fvs_adjust_vec(FVS *x, double eps)\n{     /* replace tiny vector elements by exact zeros */\n      int nnz = x->nnz;\n      int *ind = x->ind;\n      double *vec = x->vec;\n      int j, k, cnt = 0;\n      for (k = 1; k <= nnz; k++)\n      {  j = ind[k];\n         if (-eps < vec[j] && vec[j] < +eps)\n            vec[j] = 0.0;\n         else\n            ind[++cnt] = j;\n      }\n      x->nnz = cnt;\n      return;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "fvs_free_vec": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void fvs_free_vec(FVS *x)\n{     /* deallocate sparse vector */\n      tfree(x->ind);\n      tfree(x->vec);\n      x->n = x->nnz = -1;\n      x->ind = NULL;\n      x->vec = NULL;\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/fvs.h": {},
  "glpk/glpk-4.65/src/misc/gcd.c": {
    "gcd": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int gcd(int x, int y)\n{     int r;\n      xassert(x > 0 && y > 0);\n      while (y > 0)\n         r = x % y, x = y, y = r;\n      return x;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gcdn": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int gcdn(int n, int x[])\n{     int d, j;\n      xassert(n > 0);\n      for (j = 1; j <= n; j++)\n      {  xassert(x[j] > 0);\n         if (j == 1)\n            d = x[1];\n         else\n            d = gcd(d, x[j]);\n         if (d == 1)\n            break;\n      }\n      return d;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/jd.c": {
    "jday": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int jday(int d, int m, int y)\n{     int c, ya, j, dd;\n      if (!(1 <= d && d <= 31 &&\n            1 <= m && m <= 12 &&\n            1 <= y && y <= 4000))\n         return -1;\n      if (m >= 3)\n         m -= 3;\n      else\n         m += 9, y--;\n      c = y / 100;\n      ya = y - 100 * c;\n      j = (146097 * c) / 4 + (1461 * ya) / 4 + (153 * m + 2) / 5 + d +\n         1721119;\n      jdate(j, &dd, NULL, NULL);\n      if (d != dd)\n         return -1;\n      return j;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "jdate": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int jdate(int j, int *d_, int *m_, int *y_)\n{     int d, m, y;\n      if (!(1721426 <= j && j <= 3182395))\n         return 1;\n      j -= 1721119;\n      y = (4 * j - 1) / 146097;\n      j = (4 * j - 1) % 146097;\n      d = j / 4;\n      j = (4 * d + 3) / 1461;\n      d = (4 * d + 3) % 1461;\n      d = (d + 4) / 4;\n      m = (5 * d - 3) / 153;\n      d = (5 * d - 3) % 153;\n      d = (d + 5) / 5;\n      y = 100 * y + j;\n      if (m <= 9)\n         m += 3;\n      else m -= 9,\n         y++;\n      if (d_ != NULL) *d_ = d;\n      if (m_ != NULL) *m_ = m;\n      if (y_ != NULL) *y_ = y;\n      return 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int main(void)\n{     int jbeg, jend, j, d, m, y;\n      jbeg = jday(1, 1, 1);\n      jend = jday(31, 12, 4000);\n      for (j = jbeg; j <= jend; j++)\n      {  assert(jdate(j, &d, &m, &y) == 0);\n         assert(jday(d, m, y) == j);\n      }\n      printf(\"Routines jday and jdate work correctly.\\n\");\n      return 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/jd.h": {},
  "glpk/glpk-4.65/src/misc/keller.c": {
    "kellerman": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int kellerman(int n, int (*func)(void *info, int i, int ind[]),\n      void *info, void /* glp_graph */ *H_)\n{     glp_graph *H = H_;\n      struct set W_, *W = &W_, V_, *V = &V_;\n      glp_arc *a;\n      int i, j, k, m, t, len, card, best;\n      xassert(n >= 0);\n      /* H := (V, 0; 0), where V is the set of vertices of graph G */\n      glp_erase_graph(H, H->v_size, H->a_size);\n      glp_add_vertices(H, n);\n      /* W := 0 */\n      W->size = 0;\n      W->list = xcalloc(1+n, sizeof(int));\n      W->pos = xcalloc(1+n, sizeof(int));\n      memset(&W->pos[1], 0, sizeof(int) * n);\n      /* V := 0 */\n      V->size = 0;\n      V->list = xcalloc(1+n, sizeof(int));\n      V->pos = xcalloc(1+n, sizeof(int));\n      memset(&V->pos[1], 0, sizeof(int) * n);\n      /* main loop */\n      for (i = 1; i <= n; i++)\n      {  /* W must be empty */\n         xassert(W->size == 0);\n         /* W := { j : i > j and (i,j) in E } */\n         len = func(info, i, W->list);\n         xassert(0 <= len && len <= n);\n         for (t = 1; t <= len; t++)\n         {  j = W->list[t];\n            xassert(1 <= j && j <= n);\n            if (j >= i) continue;\n            xassert(W->pos[j] == 0);\n            W->list[++W->size] = j, W->pos[j] = W->size;\n         }\n         /* on i-th iteration we need to cover edges (i,j) for all\n          * j in W */\n         /* if W is empty, it is a special case */\n         if (W->size == 0)\n         {  /* set k := k + 1 and create new clique C[k] = { i } */\n            k = glp_add_vertices(H, 1) - n;\n            glp_add_arc(H, i, n + k);\n            continue;\n         }\n         /* try to include vertex i into existing cliques */\n         /* V must be empty */\n         xassert(V->size == 0);\n         /* k is the number of cliques found so far */\n         k = H->nv - n;\n         for (m = 1; m <= k; m++)\n         {  /* do while V != W; since here V is within W, we can use\n             * equivalent condition: do while |V| < |W| */\n            if (V->size == W->size) break;\n            /* check if C[m] is within W */\n            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)\n            {  j = a->tail->i;\n               if (W->pos[j] == 0) break;\n            }\n            if (a != NULL) continue;\n            /* C[m] is within W, expand clique C[m] with vertex i */\n            /* C[m] := C[m] union {i} */\n            glp_add_arc(H, i, n + m);\n            /* V is a set of vertices whose incident edges are already\n             * covered by existing cliques */\n            /* V := V union C[m] */\n            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)\n            {  j = a->tail->i;\n               if (V->pos[j] == 0)\n                  V->list[++V->size] = j, V->pos[j] = V->size;\n            }\n         }\n         /* remove from set W the vertices whose incident edges are\n          * already covered by existing cliques */\n         /* W := W \\ V, V := 0 */\n         for (t = 1; t <= V->size; t++)\n         {  j = V->list[t], V->pos[j] = 0;\n            if (W->pos[j] != 0)\n            {  /* remove vertex j from W */\n               if (W->pos[j] != W->size)\n               {  int jj = W->list[W->size];\n                  W->list[W->pos[j]] = jj;\n                  W->pos[jj] = W->pos[j];\n               }\n               W->size--, W->pos[j] = 0;\n            }\n         }\n         V->size = 0;\n         /* now set W contains only vertices whose incident edges are\n          * still not covered by existing cliques; create new cliques\n          * to cover remaining edges until set W becomes empty */\n         while (W->size > 0)\n         {  /* find clique C[m], 1 <= m <= k, which shares maximal\n             * number of vertices with W; to break ties choose clique\n             * having smallest number m */\n            m = 0, best = -1;\n            k = H->nv - n;\n            for (t = 1; t <= k; t++)\n            {  /* compute cardinality of intersection of W and C[t] */\n               card = 0;\n               for (a = H->v[n + t]->in; a != NULL; a = a->h_next)\n               {  j = a->tail->i;\n                  if (W->pos[j] != 0) card++;\n               }\n               if (best < card)\n                  m = t, best = card;\n            }\n            xassert(m > 0);\n            /* set k := k + 1 and create new clique:\n             * C[k] := (W intersect C[m]) union { i }, which covers all\n             * edges incident to vertices from (W intersect C[m]) */\n            k = glp_add_vertices(H, 1) - n;\n            for (a = H->v[n + m]->in; a != NULL; a = a->h_next)\n            {  j = a->tail->i;\n               if (W->pos[j] != 0)\n               {  /* vertex j is in both W and C[m]; include it in new\n                   * clique C[k] */\n                  glp_add_arc(H, j, n + k);\n                  /* remove vertex j from W, since edge (i,j) will be\n                   * covered by new clique C[k] */\n                  if (W->pos[j] != W->size)\n                  {  int jj = W->list[W->size];\n                     W->list[W->pos[j]] = jj;\n                     W->pos[jj] = W->pos[j];\n                  }\n                  W->size--, W->pos[j] = 0;\n               }\n            }\n            /* include vertex i to new clique C[k] to cover edges (i,j)\n             * incident to all vertices j just removed from W */\n            glp_add_arc(H, i, n + k);\n         }\n      }\n      /* free working arrays */\n      xfree(W->list);\n      xfree(W->pos);\n      xfree(V->list);\n      xfree(V->pos);\n      /* return the number of cliques in the edge covering found */\n      return H->nv - n;\n}",
      "lines": 139,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/keller.h": {},
  "glpk/glpk-4.65/src/misc/ks.c": {
    "ks_enum": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int ks_enum(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],\n      char x[/*1+n*/])\n{     int j, s, z, z_best;\n      char x_best[1+N_MAX];\n      xassert(0 <= n && n <= N_MAX);\n      /* initialization */\n      memset(&x[1], 0, n * sizeof(char));\n      z_best = INT_MIN;\nloop: /* compute constraint and objective at current x */\n      s = z = 0;\n      for (j = 1; j <= n; j++)\n      {  if (x[j])\n            s += a[j], z += c[j];\n      }\n      /* check constraint violation */\n      if (s > b)\n         goto next;\n      /* check objective function */\n      if (z_best < z)\n      {  /* better solution has been found */\n         memcpy(&x_best[1], &x[1], n * sizeof(char));\n         z_best = z;\n      }\nnext: /* generate next x */\n      for (j = 1; j <= n; j++)\n      {  if (!x[j])\n         {  x[j] = 1;\n            goto loop;\n         }\n         x[j] = 0;\n      }\n      /* report best (optimal) solution */\n      memcpy(&x[1], &x_best[1], n * sizeof(char));\n      return z_best;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "reduce": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static struct ks *reduce(const int n, const int a[/*1+n*/], int b,\n      const int c[/*1+n*/])\n{     struct ks *ks;\n      int j, s;\n      xassert(n >= 0);\n      /* initially reduced instance is the same as original one */\n      ks = talloc(1, struct ks);\n      ks->orig_n = n;\n      ks->n = 0;\n      ks->a = talloc(1+n, int);\n      memcpy(&ks->a[1], &a[1], n * sizeof(int));\n      ks->b = b;\n      ks->c = talloc(1+n, int);\n      memcpy(&ks->c[1], &c[1], n * sizeof(int));\n      ks->c0 = 0;\n      ks->x = talloc(1+n, char);\n      /* make all a[j] non-negative */\n      for (j = 1; j <= n; j++)\n      {  if (a[j] >= 0)\n         {  /* keep original x[j] */\n            ks->x[j] = 0x10;\n         }\n         else /* a[j] < 0 */\n         {  /* substitute x[j] = 1 - x'[j] */\n            ks->x[j] = 0x11;\n            /* ... + a[j]x[j]        + ... <= b\n             * ... + a[j](1 - x'[j]) + ... <= b\n             * ... - a[j]x'[j]       + ... <= b - a[j] */\n            ks->a[j] = - ks->a[j];\n            ks->b += ks->a[j];\n            /* z = ... + c[j]x[j]        + ... + c0 =\n             *   = ... + c[j](1 - x'[j]) + ... + c0 =\n             *   = ... - c[j]x'[j]       + ... + (c0 + c[j]) */\n            ks->c0 += ks->c[j];\n            ks->c[j] = - ks->c[j];\n         }\n      }\n      /* now a[j] >= 0 for all j in 1..n */\n      if (ks->b < 0)\n      {  /* instance is infeasible */\n         free_ks(ks);\n         return NULL;\n      }\n      /* build reduced instance */\n      for (j = 1; j <= n; j++)\n      {  if (ks->a[j] == 0)\n         {  if (ks->c[j] <= 0)\n            {  /* fix x[j] at 0 */\n               ks->x[j] ^= 0x10;\n            }\n            else\n            {  /* fix x[j] at 1 */\n               ks->x[j] ^= 0x11;\n               ks->c0 += ks->c[j];\n            }\n         }\n         else if (ks->a[j] > ks->b || ks->c[j] <= 0)\n         {  /* fix x[j] at 0 */\n            ks->x[j] ^= 0x10;\n         }\n         else\n         {  /* include x[j] in reduced instance */\n            ks->n++;\n            ks->a[ks->n] = ks->a[j];\n            ks->c[ks->n] = ks->c[j];\n         }\n      }\n      /* now conditions (5) and (7) are met */\n      /* check condition (6) */\n      s = 0;\n      for (j = 1; j <= ks->n; j++)\n      {  xassert(1 <= ks->a[j] && ks->a[j] <= ks->b);\n         xassert(ks->c[j] >= 1);\n         s += ks->a[j];\n      }\n      if (s <= ks->b)\n      {  /* sum{j in 1..n} a[j] <= b */\n         /* fix all remaining x[j] at 1 to obtain trivial solution */\n         for (j = 1; j <= n; j++)\n         {  if (ks->x[j] & 0x10)\n               ks->x[j] ^= 0x11;\n         }\n         for (j = 1; j <= ks->n; j++)\n            ks->c0 += ks->c[j];\n         /* reduced instance is empty */\n         ks->n = 0;\n      }\n      /* here n = 0 or n >= 2 due to condition (6) */\n      xassert(ks->n == 0 || ks->n >= 2);\n      return ks;\n}",
      "lines": 91,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct ks",
        "struct",
        "ks",
        "*reduce(const int n, const int a[/*1+n*/], int b,\n      const int c[/*1+n*/])",
        "*"
      ]
    },
    "restore": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int restore(struct ks *ks, char x[])\n{     int j, k, z;\n      z = ks->c0;\n      for (j = 1, k = 0; j <= ks->orig_n; j++)\n      {  if (ks->x[j] & 0x10)\n         {  k++;\n            xassert(k <= ks->n);\n            xassert(x[k] == 0 || x[k] == 1);\n            if (ks->x[j] & 1)\n               ks->x[j] = 1 - x[k];\n            else\n               ks->x[j] = x[k];\n            if (x[k])\n               z += ks->c[k];\n         }\n      }\n      xassert(k == ks->n);\n      return z;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "free_ks": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "static void free_ks(struct ks *ks)\n{     xassert(ks != NULL);\n      tfree(ks->a);\n      tfree(ks->c);\n      tfree(ks->x);\n      tfree(ks);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fcmp": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int CDECL fcmp(const void *p1, const void *p2)\n{     if (((struct mt *)p1)->r > ((struct mt *)p2)->r)\n         return -1;\n      else if (((struct mt *)p1)->r < ((struct mt *)p2)->r)\n         return +1;\n      else\n         return 0;\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "mt1a": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "static int mt1a(int n, const int a[], int b, const int c[], char x[])\n{     /* interface routine to MT1 */\n      struct mt *mt;\n      int j, z, *p, *w, *x1, *xx, *min, *psign, *wsign, *zsign;\n      xassert(n >= 2);\n      /* allocate working arrays */\n      mt = talloc(1+n, struct mt);\n      p = talloc(1+n+1, int);\n      w = talloc(1+n+1, int);\n      x1 = talloc(1+n+1, int);\n      xx = talloc(1+n+1, int);\n      min = talloc(1+n+1, int);\n      psign = talloc(1+n+1, int);\n      wsign = talloc(1+n+1, int);\n      zsign = talloc(1+n+1, int);\n      /* reorder items to provide c[j] / a[j] >= a[j+1] / a[j+1] */\n      for (j = 1; j <= n; j++)\n      {  mt[j].j = j;\n         mt[j].r = (float)c[j] / (float)a[j];\n      }\n      qsort(&mt[1], n, sizeof(struct mt), fcmp);\n      /* load instance parameters */\n      for (j = 1; j <= n; j++)\n      {  p[j] = c[mt[j].j];\n         w[j] = a[mt[j].j];\n      }\n      /* find optimal solution */\n      z = mt1(n, p, w, b, x1, 1, xx, min, psign, wsign, zsign);\n      xassert(z >= 0);\n      /* store optimal point found */\n      for (j = 1; j <= n; j++)\n      {  xassert(x1[j] == 0 || x1[j] == 1);\n         x[mt[j].j] = x1[j];\n      }\n      /* free working arrays */\n      tfree(mt);\n      tfree(p);\n      tfree(w);\n      tfree(x1);\n      tfree(xx);\n      tfree(min);\n      tfree(psign);\n      tfree(wsign);\n      tfree(zsign);\n      return z;\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ks_mt1": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "int ks_mt1(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],\n      char x[/*1+n*/])\n{     struct ks *ks;\n      int j, s1, s2, z;\n      xassert(n >= 0);\n      /* prepare reduced instance */\n      ks = reduce(n, a, b, c);\n      if (ks == NULL)\n      {  /* original instance is infeasible */\n         return INT_MIN;\n      }\n      /* find optimal solution to reduced instance */\n      if (ks->n > 0)\n         mt1a(ks->n, ks->a, ks->b, ks->c, x);\n      /* restore solution to original instance */\n      z = restore(ks, x);\n      memcpy(&x[1], &ks->x[1], n * sizeof(char));\n      free_ks(ks);\n      /* check solution found */\n      s1 = s2 = 0;\n      for (j = 1; j <= n; j++)\n      {  xassert(x[j] == 0 || x[j] == 1);\n         if (x[j])\n            s1 += a[j], s2 += c[j];\n      }\n      xassert(s1 <= b);\n      xassert(s2 == z);\n      return z;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "greedy": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static int greedy(int n, const int a[], int b, const int c[], char x[])\n{     /* core routine for normalized 0-1 knapsack instance */\n      struct mt *mt;\n      int j, s, z;\n      xassert(n >= 2);\n      /* reorder items to provide c[j] / a[j] >= a[j+1] / a[j+1] */\n      mt = talloc(1+n, struct mt);\n      for (j = 1; j <= n; j++)\n      {  mt[j].j = j;\n         mt[j].r = (float)c[j] / (float)a[j];\n      }\n      qsort(&mt[1], n, sizeof(struct mt), fcmp);\n      /* take items starting from most valuable ones until the knapsack\n       * is full */\n      s = z = 0;\n      for (j = 1; j <= n; j++)\n      {  if (s + a[mt[j].j] > b)\n            break;\n         x[mt[j].j] = 1;\n         s += a[mt[j].j];\n         z += c[mt[j].j];\n      }\n      /* don't take remaining items */\n      for (j = j; j <= n; j++)\n         x[mt[j].j] = 0;\n      tfree(mt);\n      return z;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ks_greedy": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "int ks_greedy(int n, const int a[/*1+n*/], int b, const int c[/*1+n*/],\n      char x[/*1+n*/])\n{     struct ks *ks;\n      int j, s1, s2, z;\n      xassert(n >= 0);\n      /* prepare reduced instance */\n      ks = reduce(n, a, b, c);\n      if (ks == NULL)\n      {  /* original instance is infeasible */\n         return INT_MIN;\n      }\n      /* find suboptimal solution to reduced instance */\n      if (ks->n > 0)\n         greedy(ks->n, ks->a, ks->b, ks->c, x);\n      /* restore solution to original instance */\n      z = restore(ks, x);\n      memcpy(&x[1], &ks->x[1], n * sizeof(char));\n      free_ks(ks);\n      /* check solution found */\n      s1 = s2 = 0;\n      for (j = 1; j <= n; j++)\n      {  xassert(x[j] == 0 || x[j] == 1);\n         if (x[j])\n            s1 += a[j], s2 += c[j];\n      }\n      xassert(s1 <= b);\n      xassert(s2 == z);\n      return z;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/ks.h": {},
  "glpk/glpk-4.65/src/misc/mc13d.c": {
    "mc13d": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int mc13d(int n, const int icn[], const int ip[], const int lenr[],\n      int ior[], int ib[], int lowl[], int numb[], int prev[])\n{     int *arp = ior;\n      int dummy, i, i1, i2, icnt, ii, isn, ist, ist1, iv, iw, j, lcnt,\n         nnm1, num, stp;\n      /* icnt is the number of nodes whose positions in final ordering\n       * have been found. */\n      icnt = 0;\n      /* num is the number of blocks that have been found. */\n      num = 0;\n      nnm1 = n + n - 1;\n      /* Initialization of arrays. */\n      for (j = 1; j <= n; j++)\n      {  numb[j] = 0;\n         arp[j] = lenr[j] - 1;\n      }\n      for (isn = 1; isn <= n; isn++)\n      {  /* Look for a starting node. */\n         if (numb[isn] != 0) continue;\n         iv = isn;\n         /* ist is the number of nodes on the stack ... it is the stack\n          * pointer. */\n         ist = 1;\n         /* Put node iv at beginning of stack. */\n         lowl[iv] = numb[iv] = 1;\n         ib[n] = iv;\n         /* The body of this loop puts a new node on the stack or\n          * backtracks. */\n         for (dummy = 1; dummy <= nnm1; dummy++)\n         {  i1 = arp[iv];\n            /* Have all edges leaving node iv been searched? */\n            if (i1 >= 0)\n            {  i2 = ip[iv] + lenr[iv] - 1;\n               i1 = i2 - i1;\n               /* Look at edges leaving node iv until one enters a new\n                * node or all edges are exhausted. */\n               for (ii = i1; ii <= i2; ii++)\n               {  iw = icn[ii];\n                  /* Has node iw been on stack already? */\n                  if (numb[iw] == 0) goto L70;\n                  /* Update value of lowl[iv] if necessary. */\n                  if (lowl[iw] < lowl[iv]) lowl[iv] = lowl[iw];\n               }\n               /* There are no more edges leaving node iv. */\n               arp[iv] = -1;\n            }\n            /* Is node iv the root of a block? */\n            if (lowl[iv] < numb[iv]) goto L60;\n            /* Order nodes in a block. */\n            num++;\n            ist1 = n + 1 - ist;\n            lcnt = icnt + 1;\n            /* Peel block off the top of the stack starting at the top\n             * and working down to the root of the block. */\n            for (stp = ist1; stp <= n; stp++)\n            {  iw = ib[stp];\n               lowl[iw] = n + 1;\n               numb[iw] = ++icnt;\n               if (iw == iv) break;\n            }\n            ist = n - stp;\n            ib[num] = lcnt;\n            /* Are there any nodes left on the stack? */\n            if (ist != 0) goto L60;\n            /* Have all the nodes been ordered? */\n            if (icnt < n) break;\n            goto L100;\nL60:        /* Backtrack to previous node on path. */\n            iw = iv;\n            iv = prev[iv];\n            /* Update value of lowl[iv] if necessary. */\n            if (lowl[iw] < lowl[iv]) lowl[iv] = lowl[iw];\n            continue;\nL70:        /* Put new node on the stack. */\n            arp[iv] = i2 - ii - 1;\n            prev[iw] = iv;\n            iv = iw;\n            lowl[iv] = numb[iv] = ++ist;\n            ib[n+1-ist] = iv;\n         }\n      }\nL100: /* Put permutation in the required form. */\n      for (i = 1; i <= n; i++)\n         arp[numb[i]] = i;\n      return num;\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "int main(void)\n{     /* test program for routine mc13d */\n      test( 1,   0);\n      test( 2,   1);\n      test( 2,   2);\n      test( 3,   3);\n      test( 4,   4);\n      test( 5,  10);\n      test(10,  10);\n      test(10,  20);\n      test(20,  20);\n      test(20,  50);\n      test(50,  50);\n      test(50, 200);\n      return 0;\n}",
      "lines": 16,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "test": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void test(int n, int ipp)\n{     int ip[1+50], icn[1+1000], ior[1+50], ib[1+51], iw[1+150],\n         lenr[1+50];\n      char a[1+50][1+50], hold[1+100];\n      int i, ii, iblock, ij, index, j, jblock, jj, k9, num;\n      xprintf(\"\\n\\n\\nMatrix is of order %d and has %d off-diagonal non-\"\n         \"zeros\\n\", n, ipp);\n      for (j = 1; j <= n; j++)\n      {  for (i = 1; i <= n; i++)\n            a[i][j] = 0;\n         a[j][j] = 1;\n      }\n      for (k9 = 1; k9 <= ipp; k9++)\n      {  /* these statements should be replaced by calls to your\n          * favorite random number generator to place two pseudo-random\n          * numbers between 1 and n in the variables i and j */\n         for (;;)\n         {  fa01bs(n, &i);\n            fa01bs(n, &j);\n            if (!a[i][j]) break;\n         }\n         a[i][j] = 1;\n      }\n      /* setup converts matrix a[i,j] to required sparsity-oriented\n       * storage format */\n      setup(n, a, ip, icn, lenr);\n      num = mc13d(n, icn, ip, lenr, ior, ib, &iw[0], &iw[n], &iw[n+n]);\n      /* output reordered matrix with blocking to improve clarity */\n      xprintf(\"\\nThe reordered matrix which has %d block%s is of the fo\"\n         \"rm\\n\", num, num == 1 ? \"\" : \"s\");\n      ib[num+1] = n + 1;\n      index = 100;\n      iblock = 1;\n      for (i = 1; i <= n; i++)\n      {  for (ij = 1; ij <= index; ij++)\n            hold[ij] = ' ';\n         if (i == ib[iblock])\n         {  xprintf(\"\\n\");\n            iblock++;\n         }\n         jblock = 1;\n         index = 0;\n         for (j = 1; j <= n; j++)\n         {  if (j == ib[jblock])\n            {  hold[++index] = ' ';\n               jblock++;\n            }\n            ii = ior[i];\n            jj = ior[j];\n            hold[++index] = (char)(a[ii][jj] ? 'X' : '0');\n         }\n         xprintf(\"%.*s\\n\", index, &hold[1]);\n      }\n      xprintf(\"\\nThe starting point for each block is given by\\n\");\n      for (i = 1; i <= num; i++)\n      {  if ((i - 1) % 12 == 0) xprintf(\"\\n\");\n         xprintf(\" %4d\", ib[i]);\n      }\n      xprintf(\"\\n\");\n      return;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "setup": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "void setup(int n, char a[1+50][1+50], int ip[], int icn[], int lenr[])\n{     int i, j, ind;\n      for (i = 1; i <= n; i++)\n         lenr[i] = 0;\n      ind = 1;\n      for (i = 1; i <= n; i++)\n      {  ip[i] = ind;\n         for (j = 1; j <= n; j++)\n         {  if (a[i][j])\n            {  lenr[i]++;\n               icn[ind++] = j;\n            }\n         }\n      }\n      return;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fa01as": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "double fa01as(int i)\n{     /* random number generator */\n      g = fmod(g * 9228907.0, 4294967296.0);\n      if (i >= 0)\n         return g / 4294967296.0;\n      else\n         return 2.0 * g / 4294967296.0 - 1.0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fa01bs": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void fa01bs(int max, int *nrand)\n{     *nrand = (int)(fa01as(1) * (double)max) + 1;\n      return;\n}",
      "lines": 4,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/mc13d.h": {},
  "glpk/glpk-4.65/src/misc/mc21a.c": {
    "mc21a": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "int mc21a(int n, const int icn[], const int ip[], const int lenr[],\n      int iperm[], int pr[], int arp[], int cv[], int out[])\n{     int i, ii, in1, in2, j, j1, jord, k, kk, numnz;\n      /* Initialization of arrays. */\n      for (i = 1; i <= n; i++)\n      {  arp[i] = lenr[i] - 1;\n         cv[i] = iperm[i] = 0;\n      }\n      numnz = 0;\n      /* Main loop. */\n      /* Each pass round this loop either results in a new assignment\n       * or gives a row with no assignment. */\n      for (jord = 1; jord <= n; jord++)\n      {  j = jord;\n         pr[j] = -1;\n         for (k = 1; k <= jord; k++)\n         {  /* Look for a cheap assignment. */\n            in1 = arp[j];\n            if (in1 >= 0)\n            {  in2 = ip[j] + lenr[j] - 1;\n               in1 = in2 - in1;\n               for (ii = in1; ii <= in2; ii++)\n               {  i = icn[ii];\n                  if (iperm[i] == 0) goto L110;\n               }\n               /* No cheap assignment in row. */\n               arp[j] = -1;\n            }\n            /* Begin looking for assignment chain starting with row j.*/\n            out[j] = lenr[j] - 1;\n            /* Inner loop. Extends chain by one or backtracks. */\n            for (kk = 1; kk <= jord; kk++)\n            {  in1 = out[j];\n               if (in1 >= 0)\n               {  in2 = ip[j] + lenr[j] - 1;\n                  in1 = in2 - in1;\n                  /* Forward scan. */\n                  for (ii = in1; ii <= in2; ii++)\n                  {  i = icn[ii];\n                     if (cv[i] != jord)\n                     {  /* Column i has not yet been accessed during\n                         * this pass. */\n                        j1 = j;\n                        j = iperm[i];\n                        cv[i] = jord;\n                        pr[j] = j1;\n                        out[j1] = in2 - ii - 1;\n                        goto L100;\n                     }\n                  }\n               }\n               /* Backtracking step. */\n               j = pr[j];\n               if (j == -1) goto L130;\n            }\nL100:       ;\n         }\nL110:    /* New assignment is made. */\n         iperm[i] = j;\n         arp[j] = in2 - ii - 1;\n         numnz++;\n         for (k = 1; k <= jord; k++)\n         {  j = pr[j];\n            if (j == -1) break;\n            ii = ip[j] + lenr[j] - out[j] - 2;\n            i = icn[ii];\n            iperm[i] = j;\n         }\nL130:    ;\n      }\n      /* If matrix is structurally singular, we now complete the\n       * permutation iperm. */\n      if (numnz < n)\n      {  for (i = 1; i <= n; i++)\n            arp[i] = 0;\n         k = 0;\n         for (i = 1; i <= n; i++)\n         {  if (iperm[i] == 0)\n               out[++k] = i;\n            else\n               arp[iperm[i]] = i;\n         }\n         k = 0;\n         for (i = 1; i <= n; i++)\n         {  if (arp[i] == 0)\n               iperm[out[++k]] = i;\n         }\n      }\n      return numnz;\n}",
      "lines": 90,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int main(void)\n{     /* test program for the routine mc21a */\n      /* these runs on random matrices cause all possible statements in\n       * mc21a to be executed */\n      int i, iold, j, j1, j2, jj, knum, l, licn, n, nov4, num, numnz;\n      int ip[1+21], icn[1+1000], iperm[1+20], lenr[1+20], iw1[1+80];\n      licn = 1000;\n      /* run on random matrices of orders 1 through 20 */\n      for (n = 1; n <= 20; n++)\n      {  nov4 = n / 4;\n         if (nov4 < 1) nov4 = 1;\nL10:     fa01bs(nov4, &l);\n         knum = l * n;\n         /* knum is requested number of non-zeros in random matrix */\n         if (knum > licn) goto L10;\n         /* if sing is false, matrix is guaranteed structurally\n          * non-singular */\n         sing = ((n / 2) * 2 == n);\n         /* call to subroutine to generate random matrix */\n         ranmat(n, n, icn, ip, n+1, &knum, iw1);\n         /* knum is now actual number of non-zeros in random matrix */\n         if (knum > licn) goto L10;\n         xprintf(\"n = %2d; nz = %4d; sing = %d\\n\", n, knum, sing);\n         /* set up array of row lengths */\n         for (i = 1; i <= n; i++)\n            lenr[i] = ip[i+1] - ip[i];\n         /* call to mc21a */\n         numnz = mc21a(n, icn, ip, lenr, iperm, &iw1[0], &iw1[n],\n            &iw1[n+n], &iw1[n+n+n]);\n         /* testing to see if there are numnz non-zeros on the diagonal\n          * of the permuted matrix. */\n         num = 0;\n         for (i = 1; i <= n; i++)\n         {  iold = iperm[i];\n            j1 = ip[iold];\n            j2 = j1 + lenr[iold] - 1;\n            if (j2 < j1) continue;\n            for (jj = j1; jj <= j2; jj++)\n            {  j = icn[jj];\n               if (j == i)\n               {  num++;\n                  break;\n               }\n            }\n         }\n         if (num != numnz)\n            xprintf(\"Failure in mc21a, numnz = %d instead of %d\\n\",\n               numnz, num);\n      }\n      return 0;\n}",
      "lines": 51,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "ranmat": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "void ranmat(int m, int n, int icn[], int iptr[], int nnnp1, int *knum,\n      int iw[])\n{     /* subroutine to generate random matrix */\n      int i, ii, inum, j, lrow, matnum;\n      inum = (*knum / n) * 2;\n      if (inum > n-1) inum = n-1;\n      matnum = 1;\n      /* each pass through this loop generates a row of the matrix */\n      for (j = 1; j <= m; j++)\n      {  iptr[j] = matnum;\n         if (!(sing || j > n))\n            icn[matnum++] = j;\n         if (n == 1) continue;\n         for (i = 1; i <= n; i++) iw[i] = 0;\n         if (!sing) iw[j] = 1;\n         fa01bs(inum, &lrow);\n         lrow--;\n         if (lrow == 0) continue;\n         /* lrow off-diagonal non-zeros in row j of the matrix */\n         for (ii = 1; ii <= lrow; ii++)\n         {  for (;;)\n            {  fa01bs(n, &i);\n               if (iw[i] != 1) break;\n            }\n            iw[i] = 1;\n            icn[matnum++] = i;\n         }\n      }\n      for (i = m+1; i <= nnnp1; i++)\n         iptr[i] = matnum;\n      *knum = matnum - 1;\n      return;\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "fa01as": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "double fa01as(int i)\n{     /* random number generator */\n      g = fmod(g * 9228907.0, 4294967296.0);\n      if (i >= 0)\n         return g / 4294967296.0;\n      else\n         return 2.0 * g / 4294967296.0 - 1.0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fa01bs": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "void fa01bs(int max, int *nrand)\n{     *nrand = (int)(fa01as(1) * (double)max) + 1;\n      return;\n}",
      "lines": 4,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/mc21a.h": {},
  "glpk/glpk-4.65/src/misc/misc.h": {},
  "glpk/glpk-4.65/src/misc/mt1.c": {
    "mt1_": {
      "start_point": [
        60,
        17
      ],
      "end_point": [
        941,
        1
      ],
      "content": "int mt1_(integer *n, integer *p, integer *w, integer *c__,\n\tinteger *z__, integer *x, integer *jdim, integer *jck, integer *xx,\n\tinteger *min__, integer *psign, integer *wsign, integer *zsign)\n{\n    /* System generated locals */\n    integer i__1;\n\n    /* Local variables */\n    static real a, b;\n    static integer j, r__, t, j1, n1, ch, ii, jj, kk, in, ll, ip, nn, iu, ii1,\n\t     chs, lim, lim1, diff, lold, mink;\n    extern /* Subroutine */ int chmt1_(integer *, integer *, integer *,\n\t    integer *, integer *, integer *);\n    static integer profit;\n\n\n/* THIS SUBROUTINE SOLVES THE 0-1 SINGLE KNAPSACK PROBLEM */\n\n/* MAXIMIZE  Z = P(1)*X(1) + ... + P(N)*X(N) */\n\n/* SUBJECT TO:   W(1)*X(1) + ... + W(N)*X(N) .LE. C , */\n/*               X(J) = 0 OR 1  FOR J=1,...,N. */\n\n/* THE PROGRAM IS INCLUDED IN THE VOLUME */\n/*   S. MARTELLO, P. TOTH, \"KNAPSACK PROBLEMS: ALGORITHMS */\n/*   AND COMPUTER IMPLEMENTATIONS\", JOHN WILEY, 1990 */\n/* AND IMPLEMENTS THE BRANCH-AND-BOUND ALGORITHM DESCRIBED IN */\n/* SECTION  2.5.2 . */\n/* THE PROGRAM DERIVES FROM AN EARLIER CODE PRESENTED IN */\n/*  S. MARTELLO, P. TOTH, \"ALGORITHM FOR THE SOLUTION OF THE 0-1 SINGLE */\n/*  KNAPSACK PROBLEM\", COMPUTING, 1978. */\n\n/* THE INPUT PROBLEM MUST SATISFY THE CONDITIONS */\n\n/*   1) 2 .LE. N .LE. JDIM - 1 ; */\n/*   2) P(J), W(J), C  POSITIVE INTEGERS; */\n/*   3) MAX (W(J)) .LE. C ; */\n/*   4) W(1) + ... + W(N) .GT. C ; */\n/*   5) P(J)/W(J) .GE. P(J+1)/W(J+1) FOR J=1,...,N-1. */\n\n/* MT1 CALLS  1  PROCEDURE: CHMT1. */\n\n/* THE PROGRAM IS COMPLETELY SELF-CONTAINED AND COMMUNICATION TO IT IS */\n/* ACHIEVED SOLELY THROUGH THE PARAMETER LIST OF MT1. */\n/* NO MACHINE-DEPENDENT CONSTANT IS USED. */\n/* THE PROGRAM IS WRITTEN IN 1967 AMERICAN NATIONAL STANDARD FORTRAN */\n/* AND IS ACCEPTED BY THE PFORT VERIFIER (PFORT IS THE PORTABLE */\n/* SUBSET OF ANSI DEFINED BY THE ASSOCIATION FOR COMPUTING MACHINERY). */\n/* THE PROGRAM HAS BEEN TESTED ON A DIGITAL VAX 11/780 AND AN H.P. */\n/* 9000/840. */\n\n/* MT1 NEEDS  8  ARRAYS ( P ,  W ,  X ,  XX ,  MIN ,  PSIGN ,  WSIGN */\n/*                        AND  ZSIGN ) OF LENGTH AT LEAST  N + 1 . */\n\n/* MEANING OF THE INPUT PARAMETERS: */\n/* N    = NUMBER OF ITEMS; */\n/* P(J) = PROFIT OF ITEM  J  (J=1,...,N); */\n/* W(J) = WEIGHT OF ITEM  J  (J=1,...,N); */\n/* C    = CAPACITY OF THE KNAPSACK; */\n/* JDIM = DIMENSION OF THE 8 ARRAYS; */\n/* JCK  = 1 IF CHECK ON THE INPUT DATA IS DESIRED, */\n/*      = 0 OTHERWISE. */\n\n/* MEANING OF THE OUTPUT PARAMETERS: */\n/* Z    = VALUE OF THE OPTIMAL SOLUTION IF  Z .GT. 0 , */\n/*      = ERROR IN THE INPUT DATA (WHEN JCK=1) IF Z .LT. 0 : CONDI- */\n/*        TION  - Z  IS VIOLATED; */\n/* X(J) = 1 IF ITEM  J  IS IN THE OPTIMAL SOLUTION, */\n/*      = 0 OTHERWISE. */\n\n/* ARRAYS XX, MIN, PSIGN, WSIGN AND ZSIGN ARE DUMMY. */\n\n/* ALL THE PARAMETERS ARE INTEGER. ON RETURN OF MT1 ALL THE INPUT */\n/* PARAMETERS ARE UNCHANGED. */\n\n/*<       INTEGER P(JDIM),W(JDIM),X(JDIM),C,Z >*/\n/*<       INTEGER XX(JDIM),MIN(JDIM),PSIGN(JDIM),WSIGN(JDIM),ZSIGN(JDIM) >*/\n/*<       INTEGER CH,CHS,DIFF,PROFIT,R,T >*/\n/*<       Z = 0 >*/\n#line 65 \"\"\n    /* Parameter adjustments */\n#line 65 \"\"\n    --zsign;\n#line 65 \"\"\n    --wsign;\n#line 65 \"\"\n    --psign;\n#line 65 \"\"\n    --min__;\n#line 65 \"\"\n    --xx;\n#line 65 \"\"\n    --x;\n#line 65 \"\"\n    --w;\n#line 65 \"\"\n    --p;\n#line 65 \"\"\n\n#line 65 \"\"\n    /* Function Body */\n#line 65 \"\"\n    *z__ = 0;\n/*<       IF ( JCK .EQ. 1 ) CALL CHMT1(N,P,W,C,Z,JDIM) >*/\n#line 66 \"\"\n    if (*jck == 1) {\n#line 66 \"\"\n\tchmt1_(n, &p[1], &w[1], c__, z__, jdim);\n#line 66 \"\"\n    }\n/*<       IF ( Z .LT. 0 ) RETURN >*/\n#line 67 \"\"\n    if (*z__ < 0) {\n#line 67 \"\"\n\treturn 0;\n#line 67 \"\"\n    }\n/* INITIALIZE. */\n/*<       CH = C >*/\n#line 69 \"\"\n    ch = *c__;\n/*<       IP = 0 >*/\n#line 70 \"\"\n    ip = 0;\n/*<       CHS = CH >*/\n#line 71 \"\"\n    chs = ch;\n/*<       DO 10 LL=1,N >*/\n#line 72 \"\"\n    i__1 = *n;\n#line 72 \"\"\n    for (ll = 1; ll <= i__1; ++ll) {\n/*<         IF ( W(LL) .GT. CHS ) GO TO 20 >*/\n#line 73 \"\"\n\tif (w[ll] > chs) {\n#line 73 \"\"\n\t    goto L20;\n#line 73 \"\"\n\t}\n/*<         IP = IP + P(LL) >*/\n#line 74 \"\"\n\tip += p[ll];\n/*<         CHS = CHS - W(LL) >*/\n#line 75 \"\"\n\tchs -= w[ll];\n/*<    10 CONTINUE >*/\n#line 76 \"\"\n/* L10: */\n#line 76 \"\"\n    }\n/*<    20 LL = LL - 1 >*/\n#line 77 \"\"\nL20:\n#line 77 \"\"\n    --ll;\n/*<       IF ( CHS .EQ. 0 ) GO TO 50 >*/\n#line 78 \"\"\n    if (chs == 0) {\n#line 78 \"\"\n\tgoto L50;\n#line 78 \"\"\n    }\n/*<       P(N+1) = 0 >*/\n#line 79 \"\"\n    p[*n + 1] = 0;\n/*<       W(N+1) = CH + 1 >*/\n#line 80 \"\"\n    w[*n + 1] = ch + 1;\n/*<       LIM = IP + CHS*P(LL+2)/W(LL+2) >*/\n#line 81 \"\"\n    lim = ip + chs * p[ll + 2] / w[ll + 2];\n/*<       A = W(LL+1) - CHS >*/\n#line 82 \"\"\n    a = (real) (w[ll + 1] - chs);\n/*<       B = IP + P(LL+1) >*/\n#line 83 \"\"\n    b = (real) (ip + p[ll + 1]);\n/*<       LIM1 = B - A*FLOAT(P(LL))/FLOAT(W(LL)) >*/\n#line 84 \"\"\n    lim1 = b - a * (real) p[ll] / (real) w[ll];\n/*<       IF ( LIM1 .GT. LIM ) LIM = LIM1 >*/\n#line 85 \"\"\n    if (lim1 > lim) {\n#line 85 \"\"\n\tlim = lim1;\n#line 85 \"\"\n    }\n/*<       MINK = CH + 1 >*/\n#line 86 \"\"\n    mink = ch + 1;\n/*<       MIN(N) = MINK >*/\n#line 87 \"\"\n    min__[*n] = mink;\n/*<       DO 30 J=2,N >*/\n#line 88 \"\"\n    i__1 = *n;\n#line 88 \"\"\n    for (j = 2; j <= i__1; ++j) {\n/*<         KK = N + 2 - J >*/\n#line 89 \"\"\n\tkk = *n + 2 - j;\n/*<         IF ( W(KK) .LT. MINK ) MINK = W(KK) >*/\n#line 90 \"\"\n\tif (w[kk] < mink) {\n#line 90 \"\"\n\t    mink = w[kk];\n#line 90 \"\"\n\t}\n/*<         MIN(KK-1) = MINK >*/\n#line 91 \"\"\n\tmin__[kk - 1] = mink;\n/*<    30 CONTINUE >*/\n#line 92 \"\"\n/* L30: */\n#line 92 \"\"\n    }\n/*<       DO 40 J=1,N >*/\n#line 93 \"\"\n    i__1 = *n;\n#line 93 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         XX(J) = 0 >*/\n#line 94 \"\"\n\txx[j] = 0;\n/*<    40 CONTINUE >*/\n#line 95 \"\"\n/* L40: */\n#line 95 \"\"\n    }\n/*<       Z = 0 >*/\n#line 96 \"\"\n    *z__ = 0;\n/*<       PROFIT = 0 >*/\n#line 97 \"\"\n    profit = 0;\n/*<       LOLD = N >*/\n#line 98 \"\"\n    lold = *n;\n/*<       II = 1 >*/\n#line 99 \"\"\n    ii = 1;\n/*<       GO TO 170 >*/\n#line 100 \"\"\n    goto L170;\n/*<    50 Z = IP >*/\n#line 101 \"\"\nL50:\n#line 101 \"\"\n    *z__ = ip;\n/*<       DO 60 J=1,LL >*/\n#line 102 \"\"\n    i__1 = ll;\n#line 102 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         X(J) = 1 >*/\n#line 103 \"\"\n\tx[j] = 1;\n/*<    60 CONTINUE >*/\n#line 104 \"\"\n/* L60: */\n#line 104 \"\"\n    }\n/*<       NN = LL + 1 >*/\n#line 105 \"\"\n    nn = ll + 1;\n/*<       DO 70 J=NN,N >*/\n#line 106 \"\"\n    i__1 = *n;\n#line 106 \"\"\n    for (j = nn; j <= i__1; ++j) {\n/*<         X(J) = 0 >*/\n#line 107 \"\"\n\tx[j] = 0;\n/*<    70 CONTINUE >*/\n#line 108 \"\"\n/* L70: */\n#line 108 \"\"\n    }\n/*<       RETURN >*/\n#line 109 \"\"\n    return 0;\n/* TRY TO INSERT THE II-TH ITEM INTO THE CURRENT SOLUTION. */\n/*<    80 IF ( W(II) .LE. CH ) GO TO 90 >*/\n#line 111 \"\"\nL80:\n#line 111 \"\"\n    if (w[ii] <= ch) {\n#line 111 \"\"\n\tgoto L90;\n#line 111 \"\"\n    }\n/*<       II1 = II + 1 >*/\n#line 112 \"\"\n    ii1 = ii + 1;\n/*<       IF ( Z .GE. CH*P(II1)/W(II1) + PROFIT ) GO TO 280 >*/\n#line 113 \"\"\n    if (*z__ >= ch * p[ii1] / w[ii1] + profit) {\n#line 113 \"\"\n\tgoto L280;\n#line 113 \"\"\n    }\n/*<       II = II1 >*/\n#line 114 \"\"\n    ii = ii1;\n/*<       GO TO 80 >*/\n#line 115 \"\"\n    goto L80;\n/* BUILD A NEW CURRENT SOLUTION. */\n/*<    90 IP = PSIGN(II) >*/\n#line 117 \"\"\nL90:\n#line 117 \"\"\n    ip = psign[ii];\n/*<       CHS = CH - WSIGN(II) >*/\n#line 118 \"\"\n    chs = ch - wsign[ii];\n/*<       IN = ZSIGN(II) >*/\n#line 119 \"\"\n    in = zsign[ii];\n/*<       DO 100 LL=IN,N >*/\n#line 120 \"\"\n    i__1 = *n;\n#line 120 \"\"\n    for (ll = in; ll <= i__1; ++ll) {\n/*<         IF ( W(LL) .GT. CHS ) GO TO 160 >*/\n#line 121 \"\"\n\tif (w[ll] > chs) {\n#line 121 \"\"\n\t    goto L160;\n#line 121 \"\"\n\t}\n/*<         IP = IP + P(LL) >*/\n#line 122 \"\"\n\tip += p[ll];\n/*<         CHS = CHS - W(LL) >*/\n#line 123 \"\"\n\tchs -= w[ll];\n/*<   100 CONTINUE >*/\n#line 124 \"\"\n/* L100: */\n#line 124 \"\"\n    }\n/*<       LL = N >*/\n#line 125 \"\"\n    ll = *n;\n/*<   110 IF ( Z .GE. IP + PROFIT ) GO TO 280 >*/\n#line 126 \"\"\nL110:\n#line 126 \"\"\n    if (*z__ >= ip + profit) {\n#line 126 \"\"\n\tgoto L280;\n#line 126 \"\"\n    }\n/*<       Z = IP + PROFIT >*/\n#line 127 \"\"\n    *z__ = ip + profit;\n/*<       NN = II - 1 >*/\n#line 128 \"\"\n    nn = ii - 1;\n/*<       DO 120 J=1,NN >*/\n#line 129 \"\"\n    i__1 = nn;\n#line 129 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         X(J) = XX(J) >*/\n#line 130 \"\"\n\tx[j] = xx[j];\n/*<   120 CONTINUE >*/\n#line 131 \"\"\n/* L120: */\n#line 131 \"\"\n    }\n/*<       DO 130 J=II,LL >*/\n#line 132 \"\"\n    i__1 = ll;\n#line 132 \"\"\n    for (j = ii; j <= i__1; ++j) {\n/*<         X(J) = 1 >*/\n#line 133 \"\"\n\tx[j] = 1;\n/*<   130 CONTINUE >*/\n#line 134 \"\"\n/* L130: */\n#line 134 \"\"\n    }\n/*<       IF ( LL .EQ. N ) GO TO 150 >*/\n#line 135 \"\"\n    if (ll == *n) {\n#line 135 \"\"\n\tgoto L150;\n#line 135 \"\"\n    }\n/*<       NN = LL + 1 >*/\n#line 136 \"\"\n    nn = ll + 1;\n/*<       DO 140 J=NN,N >*/\n#line 137 \"\"\n    i__1 = *n;\n#line 137 \"\"\n    for (j = nn; j <= i__1; ++j) {\n/*<         X(J) = 0 >*/\n#line 138 \"\"\n\tx[j] = 0;\n/*<   140 CONTINUE >*/\n#line 139 \"\"\n/* L140: */\n#line 139 \"\"\n    }\n/*<   150 IF ( Z .NE. LIM ) GO TO 280 >*/\n#line 140 \"\"\nL150:\n#line 140 \"\"\n    if (*z__ != lim) {\n#line 140 \"\"\n\tgoto L280;\n#line 140 \"\"\n    }\n/*<       RETURN >*/\n#line 141 \"\"\n    return 0;\n/*<   160 IU = CHS*P(LL)/W(LL) >*/\n#line 142 \"\"\nL160:\n#line 142 \"\"\n    iu = chs * p[ll] / w[ll];\n/*<       LL = LL - 1 >*/\n#line 143 \"\"\n    --ll;\n/*<       IF ( IU .EQ. 0 ) GO TO 110 >*/\n#line 144 \"\"\n    if (iu == 0) {\n#line 144 \"\"\n\tgoto L110;\n#line 144 \"\"\n    }\n/*<       IF ( Z .GE. PROFIT + IP + IU ) GO TO 280 >*/\n#line 145 \"\"\n    if (*z__ >= profit + ip + iu) {\n#line 145 \"\"\n\tgoto L280;\n#line 145 \"\"\n    }\n/* SAVE THE CURRENT SOLUTION. */\n/*<   170 WSIGN(II) = CH - CHS >*/\n#line 147 \"\"\nL170:\n#line 147 \"\"\n    wsign[ii] = ch - chs;\n/*<       PSIGN(II) = IP >*/\n#line 148 \"\"\n    psign[ii] = ip;\n/*<       ZSIGN(II) = LL + 1 >*/\n#line 149 \"\"\n    zsign[ii] = ll + 1;\n/*<       XX(II) = 1 >*/\n#line 150 \"\"\n    xx[ii] = 1;\n/*<       NN = LL - 1 >*/\n#line 151 \"\"\n    nn = ll - 1;\n/*<       IF ( NN .LT. II) GO TO 190 >*/\n#line 152 \"\"\n    if (nn < ii) {\n#line 152 \"\"\n\tgoto L190;\n#line 152 \"\"\n    }\n/*<       DO 180 J=II,NN >*/\n#line 153 \"\"\n    i__1 = nn;\n#line 153 \"\"\n    for (j = ii; j <= i__1; ++j) {\n/*<         WSIGN(J+1) = WSIGN(J) - W(J) >*/\n#line 154 \"\"\n\twsign[j + 1] = wsign[j] - w[j];\n/*<         PSIGN(J+1) = PSIGN(J) - P(J) >*/\n#line 155 \"\"\n\tpsign[j + 1] = psign[j] - p[j];\n/*<         ZSIGN(J+1) = LL + 1 >*/\n#line 156 \"\"\n\tzsign[j + 1] = ll + 1;\n/*<         XX(J+1) = 1 >*/\n#line 157 \"\"\n\txx[j + 1] = 1;\n/*<   180 CONTINUE >*/\n#line 158 \"\"\n/* L180: */\n#line 158 \"\"\n    }\n/*<   190 J1 = LL + 1 >*/\n#line 159 \"\"\nL190:\n#line 159 \"\"\n    j1 = ll + 1;\n/*<       DO 200 J=J1,LOLD >*/\n#line 160 \"\"\n    i__1 = lold;\n#line 160 \"\"\n    for (j = j1; j <= i__1; ++j) {\n/*<         WSIGN(J) = 0 >*/\n#line 161 \"\"\n\twsign[j] = 0;\n/*<         PSIGN(J) = 0 >*/\n#line 162 \"\"\n\tpsign[j] = 0;\n/*<         ZSIGN(J) = J >*/\n#line 163 \"\"\n\tzsign[j] = j;\n/*<   200 CONTINUE >*/\n#line 164 \"\"\n/* L200: */\n#line 164 \"\"\n    }\n/*<       LOLD = LL >*/\n#line 165 \"\"\n    lold = ll;\n/*<       CH = CHS >*/\n#line 166 \"\"\n    ch = chs;\n/*<       PROFIT = PROFIT + IP >*/\n#line 167 \"\"\n    profit += ip;\n/*<       IF ( LL - (N - 2) ) 240, 220, 210 >*/\n#line 168 \"\"\n    if ((i__1 = ll - (*n - 2)) < 0) {\n#line 168 \"\"\n\tgoto L240;\n#line 168 \"\"\n    } else if (i__1 == 0) {\n#line 168 \"\"\n\tgoto L220;\n#line 168 \"\"\n    } else {\n#line 168 \"\"\n\tgoto L210;\n#line 168 \"\"\n    }\n/*<   210 II = N >*/\n#line 169 \"\"\nL210:\n#line 169 \"\"\n    ii = *n;\n/*<       GO TO 250 >*/\n#line 170 \"\"\n    goto L250;\n/*<   220 IF ( CH .LT. W(N) ) GO TO 230 >*/\n#line 171 \"\"\nL220:\n#line 171 \"\"\n    if (ch < w[*n]) {\n#line 171 \"\"\n\tgoto L230;\n#line 171 \"\"\n    }\n/*<       CH = CH - W(N) >*/\n#line 172 \"\"\n    ch -= w[*n];\n/*<       PROFIT = PROFIT + P(N) >*/\n#line 173 \"\"\n    profit += p[*n];\n/*<       XX(N) = 1 >*/\n#line 174 \"\"\n    xx[*n] = 1;\n/*<   230 II = N - 1 >*/\n#line 175 \"\"\nL230:\n#line 175 \"\"\n    ii = *n - 1;\n/*<       GO TO 250 >*/\n#line 176 \"\"\n    goto L250;\n/*<   240 II = LL + 2 >*/\n#line 177 \"\"\nL240:\n#line 177 \"\"\n    ii = ll + 2;\n/*<       IF ( CH .GE. MIN(II-1) ) GO TO 80 >*/\n#line 178 \"\"\n    if (ch >= min__[ii - 1]) {\n#line 178 \"\"\n\tgoto L80;\n#line 178 \"\"\n    }\n/* SAVE THE CURRENT OPTIMAL SOLUTION. */\n/*<   250 IF ( Z .GE. PROFIT ) GO TO 270 >*/\n#line 180 \"\"\nL250:\n#line 180 \"\"\n    if (*z__ >= profit) {\n#line 180 \"\"\n\tgoto L270;\n#line 180 \"\"\n    }\n/*<       Z = PROFIT >*/\n#line 181 \"\"\n    *z__ = profit;\n/*<       DO 260 J=1,N >*/\n#line 182 \"\"\n    i__1 = *n;\n#line 182 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         X(J) = XX(J) >*/\n#line 183 \"\"\n\tx[j] = xx[j];\n/*<   260 CONTINUE >*/\n#line 184 \"\"\n/* L260: */\n#line 184 \"\"\n    }\n/*<       IF ( Z .EQ. LIM ) RETURN >*/\n#line 185 \"\"\n    if (*z__ == lim) {\n#line 185 \"\"\n\treturn 0;\n#line 185 \"\"\n    }\n/*<   270 IF ( XX(N) .EQ. 0 ) GO TO 280 >*/\n#line 186 \"\"\nL270:\n#line 186 \"\"\n    if (xx[*n] == 0) {\n#line 186 \"\"\n\tgoto L280;\n#line 186 \"\"\n    }\n/*<       XX(N) = 0 >*/\n#line 187 \"\"\n    xx[*n] = 0;\n/*<       CH = CH + W(N) >*/\n#line 188 \"\"\n    ch += w[*n];\n/*<       PROFIT = PROFIT - P(N) >*/\n#line 189 \"\"\n    profit -= p[*n];\n/* BACKTRACK. */\n/*<   280 NN = II - 1 >*/\n#line 191 \"\"\nL280:\n#line 191 \"\"\n    nn = ii - 1;\n/*<       IF ( NN .EQ. 0 ) RETURN >*/\n#line 192 \"\"\n    if (nn == 0) {\n#line 192 \"\"\n\treturn 0;\n#line 192 \"\"\n    }\n/*<       DO 290 J=1,NN >*/\n#line 193 \"\"\n    i__1 = nn;\n#line 193 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         KK = II - J >*/\n#line 194 \"\"\n\tkk = ii - j;\n/*<         IF ( XX(KK) .EQ. 1 ) GO TO 300 >*/\n#line 195 \"\"\n\tif (xx[kk] == 1) {\n#line 195 \"\"\n\t    goto L300;\n#line 195 \"\"\n\t}\n/*<   290 CONTINUE >*/\n#line 196 \"\"\n/* L290: */\n#line 196 \"\"\n    }\n/*<       RETURN >*/\n#line 197 \"\"\n    return 0;\n/*<   300 R = CH >*/\n#line 198 \"\"\nL300:\n#line 198 \"\"\n    r__ = ch;\n/*<       CH = CH + W(KK) >*/\n#line 199 \"\"\n    ch += w[kk];\n/*<       PROFIT = PROFIT - P(KK) >*/\n#line 200 \"\"\n    profit -= p[kk];\n/*<       XX(KK) = 0 >*/\n#line 201 \"\"\n    xx[kk] = 0;\n/*<       IF ( R .LT. MIN(KK) ) GO TO 310 >*/\n#line 202 \"\"\n    if (r__ < min__[kk]) {\n#line 202 \"\"\n\tgoto L310;\n#line 202 \"\"\n    }\n/*<       II = KK + 1 >*/\n#line 203 \"\"\n    ii = kk + 1;\n/*<       GO TO 80 >*/\n#line 204 \"\"\n    goto L80;\n/*<   310 NN = KK + 1 >*/\n#line 205 \"\"\nL310:\n#line 205 \"\"\n    nn = kk + 1;\n/*<       II = KK >*/\n#line 206 \"\"\n    ii = kk;\n/* TRY TO SUBSTITUTE THE NN-TH ITEM FOR THE KK-TH. */\n/*<   320 IF ( Z .GE. PROFIT + CH*P(NN)/W(NN) ) GO TO 280 >*/\n#line 208 \"\"\nL320:\n#line 208 \"\"\n    if (*z__ >= profit + ch * p[nn] / w[nn]) {\n#line 208 \"\"\n\tgoto L280;\n#line 208 \"\"\n    }\n/*<       DIFF = W(NN) - W(KK) >*/\n#line 209 \"\"\n    diff = w[nn] - w[kk];\n/*<       IF ( DIFF ) 370, 330, 340 >*/\n#line 210 \"\"\n    if (diff < 0) {\n#line 210 \"\"\n\tgoto L370;\n#line 210 \"\"\n    } else if (diff == 0) {\n#line 210 \"\"\n\tgoto L330;\n#line 210 \"\"\n    } else {\n#line 210 \"\"\n\tgoto L340;\n#line 210 \"\"\n    }\n/*<   330 NN = NN + 1 >*/\n#line 211 \"\"\nL330:\n#line 211 \"\"\n    ++nn;\n/*<       GO TO 320 >*/\n#line 212 \"\"\n    goto L320;\n/*<   340 IF ( DIFF .GT. R ) GO TO 330 >*/\n#line 213 \"\"\nL340:\n#line 213 \"\"\n    if (diff > r__) {\n#line 213 \"\"\n\tgoto L330;\n#line 213 \"\"\n    }\n/*<       IF ( Z .GE. PROFIT + P(NN) ) GO TO 330 >*/\n#line 214 \"\"\n    if (*z__ >= profit + p[nn]) {\n#line 214 \"\"\n\tgoto L330;\n#line 214 \"\"\n    }\n/*<       Z = PROFIT + P(NN) >*/\n#line 215 \"\"\n    *z__ = profit + p[nn];\n/*<       DO 350 J=1,KK >*/\n#line 216 \"\"\n    i__1 = kk;\n#line 216 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         X(J) = XX(J) >*/\n#line 217 \"\"\n\tx[j] = xx[j];\n/*<   350 CONTINUE >*/\n#line 218 \"\"\n/* L350: */\n#line 218 \"\"\n    }\n/*<       JJ = KK + 1 >*/\n#line 219 \"\"\n    jj = kk + 1;\n/*<       DO 360 J=JJ,N >*/\n#line 220 \"\"\n    i__1 = *n;\n#line 220 \"\"\n    for (j = jj; j <= i__1; ++j) {\n/*<         X(J) = 0 >*/\n#line 221 \"\"\n\tx[j] = 0;\n/*<   360 CONTINUE >*/\n#line 222 \"\"\n/* L360: */\n#line 222 \"\"\n    }\n/*<       X(NN) = 1 >*/\n#line 223 \"\"\n    x[nn] = 1;\n/*<       IF ( Z .EQ. LIM ) RETURN >*/\n#line 224 \"\"\n    if (*z__ == lim) {\n#line 224 \"\"\n\treturn 0;\n#line 224 \"\"\n    }\n/*<       R = R - DIFF >*/\n#line 225 \"\"\n    r__ -= diff;\n/*<       KK = NN >*/\n#line 226 \"\"\n    kk = nn;\n/*<       NN = NN + 1 >*/\n#line 227 \"\"\n    ++nn;\n/*<       GO TO 320 >*/\n#line 228 \"\"\n    goto L320;\n/*<   370 T = R - DIFF >*/\n#line 229 \"\"\nL370:\n#line 229 \"\"\n    t = r__ - diff;\n/*<       IF ( T .LT. MIN(NN) ) GO TO 330 >*/\n#line 230 \"\"\n    if (t < min__[nn]) {\n#line 230 \"\"\n\tgoto L330;\n#line 230 \"\"\n    }\n/*<       IF ( Z .GE. PROFIT + P(NN) + T*P(NN+1)/W(NN+1)) GO TO 280 >*/\n#line 231 \"\"\n    if (*z__ >= profit + p[nn] + t * p[nn + 1] / w[nn + 1]) {\n#line 231 \"\"\n\tgoto L280;\n#line 231 \"\"\n    }\n/*<       CH = CH - W(NN) >*/\n#line 232 \"\"\n    ch -= w[nn];\n/*<       PROFIT = PROFIT + P(NN) >*/\n#line 233 \"\"\n    profit += p[nn];\n/*<       XX(NN) = 1 >*/\n#line 234 \"\"\n    xx[nn] = 1;\n/*<       II = NN + 1 >*/\n#line 235 \"\"\n    ii = nn + 1;\n/*<       WSIGN(NN) = W(NN) >*/\n#line 236 \"\"\n    wsign[nn] = w[nn];\n/*<       PSIGN(NN) = P(NN) >*/\n#line 237 \"\"\n    psign[nn] = p[nn];\n/*<       ZSIGN(NN) = II >*/\n#line 238 \"\"\n    zsign[nn] = ii;\n/*<       N1 = NN + 1 >*/\n#line 239 \"\"\n    n1 = nn + 1;\n/*<       DO 380 J=N1,LOLD >*/\n#line 240 \"\"\n    i__1 = lold;\n#line 240 \"\"\n    for (j = n1; j <= i__1; ++j) {\n/*<         WSIGN(J) = 0 >*/\n#line 241 \"\"\n\twsign[j] = 0;\n/*<         PSIGN(J) = 0 >*/\n#line 242 \"\"\n\tpsign[j] = 0;\n/*<         ZSIGN(J) = J >*/\n#line 243 \"\"\n\tzsign[j] = j;\n/*<   380 CONTINUE >*/\n#line 244 \"\"\n/* L380: */\n#line 244 \"\"\n    }\n/*<       LOLD = NN >*/\n#line 245 \"\"\n    lold = nn;\n/*<       GO TO 80 >*/\n#line 246 \"\"\n    goto L80;\n/*<       END >*/\n}",
      "lines": 882,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "chmt1_": {
      "start_point": [
        947,
        17
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "int chmt1_(integer *n, integer *p, integer *w, integer *c__,\n\tinteger *z__, integer *jdim)\n{\n    /* System generated locals */\n    integer i__1;\n\n    /* Local variables */\n    static integer j;\n    static real r__, rr;\n    static integer jsw;\n\n\n/* CHECK THE INPUT DATA. */\n\n/*<       INTEGER P(JDIM),W(JDIM),C,Z >*/\n/*<       IF ( N .GE. 2 .AND. N .LE. JDIM - 1 ) GO TO 10 >*/\n#line 253 \"\"\n    /* Parameter adjustments */\n#line 253 \"\"\n    --w;\n#line 253 \"\"\n    --p;\n#line 253 \"\"\n\n#line 253 \"\"\n    /* Function Body */\n#line 253 \"\"\n    if (*n >= 2 && *n <= *jdim - 1) {\n#line 253 \"\"\n\tgoto L10;\n#line 253 \"\"\n    }\n/*<       Z = - 1 >*/\n#line 254 \"\"\n    *z__ = -1;\n/*<       RETURN >*/\n#line 255 \"\"\n    return 0;\n/*<    10 IF ( C .GT. 0 ) GO TO 30 >*/\n#line 256 \"\"\nL10:\n#line 256 \"\"\n    if (*c__ > 0) {\n#line 256 \"\"\n\tgoto L30;\n#line 256 \"\"\n    }\n/*<    20 Z = - 2 >*/\n#line 257 \"\"\nL20:\n#line 257 \"\"\n    *z__ = -2;\n/*<       RETURN >*/\n#line 258 \"\"\n    return 0;\n/*<    30 JSW = 0 >*/\n#line 259 \"\"\nL30:\n#line 259 \"\"\n    jsw = 0;\n/*<       RR = FLOAT(P(1))/FLOAT(W(1)) >*/\n#line 260 \"\"\n    rr = (real) p[1] / (real) w[1];\n/*<       DO 50 J=1,N >*/\n#line 261 \"\"\n    i__1 = *n;\n#line 261 \"\"\n    for (j = 1; j <= i__1; ++j) {\n/*<         R = RR >*/\n#line 262 \"\"\n\tr__ = rr;\n/*<         IF ( P(J) .LE. 0 ) GO TO 20 >*/\n#line 263 \"\"\n\tif (p[j] <= 0) {\n#line 263 \"\"\n\t    goto L20;\n#line 263 \"\"\n\t}\n/*<         IF ( W(J) .LE. 0 ) GO TO 20 >*/\n#line 264 \"\"\n\tif (w[j] <= 0) {\n#line 264 \"\"\n\t    goto L20;\n#line 264 \"\"\n\t}\n/*<         JSW = JSW + W(J) >*/\n#line 265 \"\"\n\tjsw += w[j];\n/*<         IF ( W(J) .LE. C ) GO TO 40 >*/\n#line 266 \"\"\n\tif (w[j] <= *c__) {\n#line 266 \"\"\n\t    goto L40;\n#line 266 \"\"\n\t}\n/*<         Z = - 3 >*/\n#line 267 \"\"\n\t*z__ = -3;\n/*<         RETURN >*/\n#line 268 \"\"\n\treturn 0;\n/*<    40   RR = FLOAT(P(J))/FLOAT(W(J)) >*/\n#line 269 \"\"\nL40:\n#line 269 \"\"\n\trr = (real) p[j] / (real) w[j];\n/*<         IF ( RR .LE. R ) GO TO 50 >*/\n#line 270 \"\"\n\tif (rr <= r__) {\n#line 270 \"\"\n\t    goto L50;\n#line 270 \"\"\n\t}\n/*<         Z = - 5 >*/\n#line 271 \"\"\n\t*z__ = -5;\n/*<         RETURN >*/\n#line 272 \"\"\n\treturn 0;\n/*<    50 CONTINUE >*/\n#line 273 \"\"\nL50:\n#line 273 \"\"\n\t;\n#line 273 \"\"\n    }\n/*<       IF ( JSW .GT. C ) RETURN >*/\n#line 274 \"\"\n    if (jsw > *c__) {\n#line 274 \"\"\n\treturn 0;\n#line 274 \"\"\n    }\n/*<       Z = - 4 >*/\n#line 275 \"\"\n    *z__ = -4;\n/*<       RETURN >*/\n#line 276 \"\"\n    return 0;\n/*<       END >*/\n}",
      "lines": 141,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mt1": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1106,
        1
      ],
      "content": "int mt1(int n, int p[], int w[], int c, int x[], int jck, int xx[],\n      int min[], int psign[], int wsign[], int zsign[])\n{     /* solve 0-1 knapsack problem */\n      int z, jdim = n+1, j, s1, s2;\n      mt1_(&n, &p[1], &w[1], &c, &z, &x[1], &jdim, &jck, &xx[1],\n         &min[1], &psign[1], &wsign[1], &zsign[1]);\n      /* check solution found */\n      s1 = s2 = 0;\n      for (j = 1; j <= n; j++)\n      {  xassert(x[j] == 0 || x[j] == 1);\n         if (x[j])\n            s1 += p[j], s2 += w[j];\n      }\n      xassert(s1 == z);\n      xassert(s2 <= c);\n      return z;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/mt1.h": {},
  "glpk/glpk-4.65/src/misc/mygmp.c": {
    "gmp_get_atom": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *gmp_get_atom(int size)\n{     ENV *env = get_env_ptr();\n      if (gmp_pool == NULL)\n         gmp_pool = dmp_create_pool();\n      return dmp_get_atom(gmp_pool, size);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void",
        "*gmp_get_atom(int size)",
        "*"
      ]
    },
    "gmp_free_atom": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void gmp_free_atom(void *ptr, int size)\n{     ENV *env = get_env_ptr();\n      xassert(gmp_pool != NULL);\n      dmp_free_atom(gmp_pool, ptr, size);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "gmp_pool_count": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int gmp_pool_count(void)\n{     ENV *env = get_env_ptr();\n      if (gmp_pool == NULL)\n         return 0;\n      else\n         return dmp_in_use(gmp_pool);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "gmp_get_work": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "unsigned short *gmp_get_work(int size)\n{     ENV *env = get_env_ptr();\n      xassert(size > 0);\n      if (gmp_size < size)\n      {  if (gmp_size == 0)\n         {  xassert(gmp_work == NULL);\n            gmp_size = 100;\n         }\n         else\n         {  xassert(gmp_work != NULL);\n            xfree(gmp_work);\n         }\n         while (gmp_size < size)\n            gmp_size += gmp_size;\n         gmp_work = xcalloc(gmp_size, sizeof(unsigned short));\n      }\n      return gmp_work;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "unsigned short",
        "unsigned",
        "short",
        "*gmp_get_work(int size)",
        "*"
      ]
    },
    "gmp_free_mem": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void gmp_free_mem(void)\n{     ENV *env = get_env_ptr();\n      if (gmp_pool != NULL)\n         dmp_delete_pool(gmp_pool);\n      if (gmp_work != NULL)\n         xfree(gmp_work);\n      gmp_pool = NULL;\n      gmp_size = 0;\n      gmp_work = NULL;\n      return;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "_mpz_init": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "mpz_t _mpz_init(void)\n{     /* initialize x and set its value to 0 */\n      mpz_t x;\n      x = gmp_get_atom(sizeof(struct mpz));\n      x->val = 0;\n      x->ptr = NULL;\n      return x;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "mpz_t"
      ]
    },
    "mpz_clear": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void mpz_clear(mpz_t x)\n{     /* free the space occupied by x */\n      mpz_set_si(x, 0);\n      xassert(x->ptr == NULL);\n      /* free the number descriptor */\n      gmp_free_atom(x, sizeof(struct mpz));\n      return;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_set": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void mpz_set(mpz_t z, mpz_t x)\n{     /* set the value of z from x */\n      struct mpz_seg *e, *ee, *es;\n      if (z != x)\n      {  mpz_set_si(z, 0);\n         z->val = x->val;\n         xassert(z->ptr == NULL);\n         for (e = x->ptr, es = NULL; e != NULL; e = e->next)\n         {  ee = gmp_get_atom(sizeof(struct mpz_seg));\n            memcpy(ee->d, e->d, 12);\n            ee->next = NULL;\n            if (z->ptr == NULL)\n               z->ptr = ee;\n            else\n               es->next = ee;\n            es = ee;\n         }\n      }\n      return;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "mpz_set_si": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void mpz_set_si(mpz_t x, int val)\n{     /* set the value of x to val */\n      struct mpz_seg *e;\n      /* free existing segments, if any */\n      while (x->ptr != NULL)\n      {  e = x->ptr;\n         x->ptr = e->next;\n         gmp_free_atom(e, sizeof(struct mpz_seg));\n      }\n      /* assign new value */\n      if (val == 0x80000000)\n      {  /* long format is needed */\n         x->val = -1;\n         x->ptr = e = gmp_get_atom(sizeof(struct mpz_seg));\n         memset(e->d, 0, 12);\n         e->d[1] = 0x8000;\n         e->next = NULL;\n      }\n      else\n      {  /* short format is enough */\n         x->val = val;\n      }\n      return;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_get_d": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "double mpz_get_d(mpz_t x)\n{     /* convert x to a double, truncating if necessary */\n      struct mpz_seg *e;\n      int j;\n      double val, deg;\n      if (x->ptr == NULL)\n         val = (double)x->val;\n      else\n      {  xassert(x->val != 0);\n         val = 0.0;\n         deg = 1.0;\n         for (e = x->ptr; e != NULL; e = e->next)\n         {  for (j = 0; j <= 5; j++)\n            {  val += deg * (double)((int)e->d[j]);\n               deg *= 65536.0;\n            }\n         }\n         if (x->val < 0)\n            val = - val;\n      }\n      return val;\n}",
      "lines": 22,
      "depth": 17,
      "decorators": [
        "double"
      ]
    },
    "mpz_get_d_2exp": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "double mpz_get_d_2exp(int *exp, mpz_t x)\n{     /* convert x to a double, truncating if necessary (i.e. rounding\n       * towards zero), and returning the exponent separately;\n       * the return value is in the range 0.5 <= |d| < 1 and the\n       * exponent is stored to *exp; d*2^exp is the (truncated) x value;\n       * if x is zero, the return is 0.0 and 0 is stored to *exp;\n       * this is similar to the standard C frexp function */\n      struct mpz_seg *e;\n      int j, n, n1;\n      double val;\n      if (x->ptr == NULL)\n         val = (double)x->val, n = 0;\n      else\n      {  xassert(x->val != 0);\n         val = 0.0, n = 0;\n         for (e = x->ptr; e != NULL; e = e->next)\n         {  for (j = 0; j <= 5; j++)\n            {  val += (double)((int)e->d[j]);\n               val /= 65536.0, n += 16;\n            }\n         }\n         if (x->val < 0)\n            val = - val;\n      }\n      val = frexp(val, &n1);\n      *exp = n + n1;\n      return val;\n}",
      "lines": 28,
      "depth": 16,
      "decorators": [
        "double"
      ]
    },
    "mpz_swap": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void mpz_swap(mpz_t x, mpz_t y)\n{     /* swap the values x and y efficiently */\n      int val;\n      void *ptr;\n      val = x->val, ptr = x->ptr;\n      x->val = y->val, x->ptr = y->ptr;\n      y->val = val, y->ptr = ptr;\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "normalize": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "static void normalize(mpz_t x)\n{     /* normalize integer x that includes removing non-significant\n       * (leading) zeros and converting to short format, if possible */\n      struct mpz_seg *es, *e;\n      /* if the integer is in short format, it remains unchanged */\n      if (x->ptr == NULL)\n      {  xassert(x->val != 0x80000000);\n         goto done;\n      }\n      xassert(x->val == +1 || x->val == -1);\n      /* find the last (most significant) non-zero segment */\n      es = NULL;\n      for (e = x->ptr; e != NULL; e = e->next)\n      {  if (e->d[0] || e->d[1] || e->d[2] ||\n             e->d[3] || e->d[4] || e->d[5])\n            es = e;\n      }\n      /* if all segments contain zeros, the integer is zero */\n      if (es == NULL)\n      {  mpz_set_si(x, 0);\n         goto done;\n      }\n      /* remove non-significant (leading) zero segments */\n      while (es->next != NULL)\n      {  e = es->next;\n         es->next = e->next;\n         gmp_free_atom(e, sizeof(struct mpz_seg));\n      }\n      /* convert the integer to short format, if possible */\n      e = x->ptr;\n      if (e->next == NULL && e->d[1] <= 0x7FFF &&\n         !e->d[2] && !e->d[3] && !e->d[4] && !e->d[5])\n      {  int val;\n         val = (int)e->d[0] + ((int)e->d[1] << 16);\n         if (x->val < 0)\n            val = - val;\n         mpz_set_si(x, val);\n      }\ndone: return;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_add": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "void mpz_add(mpz_t z, mpz_t x, mpz_t y)\n{     /* set z to x + y */\n      static struct mpz_seg zero = { { 0, 0, 0, 0, 0, 0 }, NULL };\n      struct mpz_seg dumx, dumy, *ex, *ey, *ez, *es, *ee;\n      int k, sx, sy, sz;\n      unsigned int t;\n      /* if [x] = 0 then [z] = [y] */\n      if (x->val == 0)\n      {  xassert(x->ptr == NULL);\n         mpz_set(z, y);\n         goto done;\n      }\n      /* if [y] = 0 then [z] = [x] */\n      if (y->val == 0)\n      {  xassert(y->ptr == NULL);\n         mpz_set(z, x);\n         goto done;\n      }\n      /* special case when both [x] and [y] are in short format */\n      if (x->ptr == NULL && y->ptr == NULL)\n      {  int xval = x->val, yval = y->val, zval = x->val + y->val;\n         xassert(xval != 0x80000000 && yval != 0x80000000);\n         if (!(xval > 0 && yval > 0 && zval <= 0 ||\n               xval < 0 && yval < 0 && zval >= 0))\n         {  mpz_set_si(z, zval);\n            goto done;\n         }\n      }\n      /* convert [x] to long format, if necessary */\n      if (x->ptr == NULL)\n      {  xassert(x->val != 0x80000000);\n         if (x->val >= 0)\n         {  sx = +1;\n            t = (unsigned int)(+ x->val);\n         }\n         else\n         {  sx = -1;\n            t = (unsigned int)(- x->val);\n         }\n         ex = &dumx;\n         ex->d[0] = (unsigned short)t;\n         ex->d[1] = (unsigned short)(t >> 16);\n         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;\n         ex->next = NULL;\n      }\n      else\n      {  sx = x->val;\n         xassert(sx == +1 || sx == -1);\n         ex = x->ptr;\n      }\n      /* convert [y] to long format, if necessary */\n      if (y->ptr == NULL)\n      {  xassert(y->val != 0x80000000);\n         if (y->val >= 0)\n         {  sy = +1;\n            t = (unsigned int)(+ y->val);\n         }\n         else\n         {  sy = -1;\n            t = (unsigned int)(- y->val);\n         }\n         ey = &dumy;\n         ey->d[0] = (unsigned short)t;\n         ey->d[1] = (unsigned short)(t >> 16);\n         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;\n         ey->next = NULL;\n      }\n      else\n      {  sy = y->val;\n         xassert(sy == +1 || sy == -1);\n         ey = y->ptr;\n      }\n      /* main fragment */\n      sz = sx;\n      ez = es = NULL;\n      if (sx > 0 && sy > 0 || sx < 0 && sy < 0)\n      {  /* [x] and [y] have identical signs -- addition */\n         t = 0;\n         for (; ex || ey; ex = ex->next, ey = ey->next)\n         {  if (ex == NULL)\n               ex = &zero;\n            if (ey == NULL)\n               ey = &zero;\n            ee = gmp_get_atom(sizeof(struct mpz_seg));\n            for (k = 0; k <= 5; k++)\n            {  t += (unsigned int)ex->d[k];\n               t += (unsigned int)ey->d[k];\n               ee->d[k] = (unsigned short)t;\n               t >>= 16;\n            }\n            ee->next = NULL;\n            if (ez == NULL)\n               ez = ee;\n            else\n               es->next = ee;\n            es = ee;\n         }\n         if (t)\n         {  /* overflow -- one extra digit is needed */\n            ee = gmp_get_atom(sizeof(struct mpz_seg));\n            ee->d[0] = 1;\n            ee->d[1] = ee->d[2] = ee->d[3] = ee->d[4] = ee->d[5] = 0;\n            ee->next = NULL;\n            xassert(es != NULL);\n            es->next = ee;\n         }\n      }\n      else\n      {  /* [x] and [y] have different signs -- subtraction */\n         t = 1;\n         for (; ex || ey; ex = ex->next, ey = ey->next)\n         {  if (ex == NULL)\n               ex = &zero;\n            if (ey == NULL)\n               ey = &zero;\n            ee = gmp_get_atom(sizeof(struct mpz_seg));\n            for (k = 0; k <= 5; k++)\n            {  t += (unsigned int)ex->d[k];\n               t += (0xFFFF - (unsigned int)ey->d[k]);\n               ee->d[k] = (unsigned short)t;\n               t >>= 16;\n            }\n            ee->next = NULL;\n            if (ez == NULL)\n               ez = ee;\n            else\n               es->next = ee;\n            es = ee;\n         }\n         if (!t)\n         {  /* |[x]| < |[y]| -- result in complement coding */\n            sz = - sz;\n            t = 1;\n            for (ee = ez; ee != NULL; ee = ee->next)\n            {  for (k = 0; k <= 5; k++)\n               {  t += (0xFFFF - (unsigned int)ee->d[k]);\n                  ee->d[k] = (unsigned short)t;\n                  t >>= 16;\n               }\n            }\n         }\n      }\n      /* contruct and normalize result */\n      mpz_set_si(z, 0);\n      z->val = sz;\n      z->ptr = ez;\n      normalize(z);\ndone: return;\n}",
      "lines": 149,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "mpz_sub": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "void mpz_sub(mpz_t z, mpz_t x, mpz_t y)\n{     /* set z to x - y */\n      if (x == y)\n         mpz_set_si(z, 0);\n      else\n      {  y->val = - y->val;\n         mpz_add(z, x, y);\n         if (y != z)\n            y->val = - y->val;\n      }\n      return;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "void mpz_mul(mpz_t z, mpz_t x, mpz_t y)\n{     /* set z to x * y */\n      struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;\n      int sx, sy, k, nx, ny, n;\n      unsigned int t;\n      unsigned short *work, *wx, *wy;\n      /* if [x] = 0 then [z] = 0 */\n      if (x->val == 0)\n      {  xassert(x->ptr == NULL);\n         mpz_set_si(z, 0);\n         goto done;\n      }\n      /* if [y] = 0 then [z] = 0 */\n      if (y->val == 0)\n      {  xassert(y->ptr == NULL);\n         mpz_set_si(z, 0);\n         goto done;\n      }\n      /* special case when both [x] and [y] are in short format */\n      if (x->ptr == NULL && y->ptr == NULL)\n      {  int xval = x->val, yval = y->val, sz = +1;\n         xassert(xval != 0x80000000 && yval != 0x80000000);\n         if (xval < 0)\n            xval = - xval, sz = - sz;\n         if (yval < 0)\n            yval = - yval, sz = - sz;\n         if (xval <= 0x7FFFFFFF / yval)\n         {  mpz_set_si(z, sz * (xval * yval));\n            goto done;\n         }\n      }\n      /* convert [x] to long format, if necessary */\n      if (x->ptr == NULL)\n      {  xassert(x->val != 0x80000000);\n         if (x->val >= 0)\n         {  sx = +1;\n            t = (unsigned int)(+ x->val);\n         }\n         else\n         {  sx = -1;\n            t = (unsigned int)(- x->val);\n         }\n         ex = &dumx;\n         ex->d[0] = (unsigned short)t;\n         ex->d[1] = (unsigned short)(t >> 16);\n         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;\n         ex->next = NULL;\n      }\n      else\n      {  sx = x->val;\n         xassert(sx == +1 || sx == -1);\n         ex = x->ptr;\n      }\n      /* convert [y] to long format, if necessary */\n      if (y->ptr == NULL)\n      {  xassert(y->val != 0x80000000);\n         if (y->val >= 0)\n         {  sy = +1;\n            t = (unsigned int)(+ y->val);\n         }\n         else\n         {  sy = -1;\n            t = (unsigned int)(- y->val);\n         }\n         ey = &dumy;\n         ey->d[0] = (unsigned short)t;\n         ey->d[1] = (unsigned short)(t >> 16);\n         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;\n         ey->next = NULL;\n      }\n      else\n      {  sy = y->val;\n         xassert(sy == +1 || sy == -1);\n         ey = y->ptr;\n      }\n      /* determine the number of digits of [x] */\n      nx = n = 0;\n      for (e = ex; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++)\n         {  n++;\n            if (e->d[k])\n               nx = n;\n         }\n      }\n      xassert(nx > 0);\n      /* determine the number of digits of [y] */\n      ny = n = 0;\n      for (e = ey; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++)\n         {  n++;\n            if (e->d[k])\n               ny = n;\n         }\n      }\n      xassert(ny > 0);\n      /* we need working array containing at least nx+ny+ny places */\n      work = gmp_get_work(nx+ny+ny);\n      /* load digits of [x] */\n      wx = &work[0];\n      for (n = 0; n < nx; n++)\n         wx[ny+n] = 0;\n      for (n = 0, e = ex; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++, n++)\n         {  if (e->d[k])\n               wx[ny+n] = e->d[k];\n         }\n      }\n      /* load digits of [y] */\n      wy = &work[nx+ny];\n      for (n = 0; n < ny; n++) wy[n] = 0;\n      for (n = 0, e = ey; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++, n++)\n         {  if (e->d[k])\n               wy[n] = e->d[k];\n         }\n      }\n      /* compute [x] * [y] */\n      bigmul(nx, ny, wx, wy);\n      /* construct and normalize result */\n      mpz_set_si(z, 0);\n      z->val = sx * sy;\n      es = NULL;\n      k = 6;\n      for (n = 0; n < nx+ny; n++)\n      {  if (k > 5)\n         {  e = gmp_get_atom(sizeof(struct mpz_seg));\n            e->d[0] = e->d[1] = e->d[2] = 0;\n            e->d[3] = e->d[4] = e->d[5] = 0;\n            e->next = NULL;\n            if (z->ptr == NULL)\n               z->ptr = e;\n            else\n               es->next = e;\n            es = e;\n            k = 0;\n         }\n         es->d[k++] = wx[n];\n      }\n      normalize(z);\ndone: return;\n}",
      "lines": 141,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "mpz_neg": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "void mpz_neg(mpz_t z, mpz_t x)\n{     /* set z to 0 - x */\n      mpz_set(z, x);\n      z->val = - z->val;\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_abs": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "void mpz_abs(mpz_t z, mpz_t x)\n{     /* set z to the absolute value of x */\n      mpz_set(z, x);\n      if (z->val < 0)\n         z->val = - z->val;\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_div": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "void mpz_div(mpz_t q, mpz_t r, mpz_t x, mpz_t y)\n{     /* divide x by y, forming quotient q and/or remainder r\n       * if q = NULL then quotient is not stored; if r = NULL then\n       * remainder is not stored\n       * the sign of quotient is determined as in algebra while the\n       * sign of remainder is the same as the sign of dividend:\n       * +26 : +7 = +3, remainder is +5\n       * -26 : +7 = -3, remainder is -5\n       * +26 : -7 = -3, remainder is +5\n       * -26 : -7 = +3, remainder is -5 */\n      struct mpz_seg dumx, dumy, *ex, *ey, *es, *e;\n      int sx, sy, k, nx, ny, n;\n      unsigned int t;\n      unsigned short *work, *wx, *wy;\n      /* divide by zero is not allowed */\n      if (y->val == 0)\n      {  xassert(y->ptr == NULL);\n         xerror(\"mpz_div: divide by zero not allowed\\n\");\n      }\n      /* if [x] = 0 then [q] = [r] = 0 */\n      if (x->val == 0)\n      {  xassert(x->ptr == NULL);\n         if (q != NULL)\n            mpz_set_si(q, 0);\n         if (r != NULL)\n            mpz_set_si(r, 0);\n         goto done;\n      }\n      /* special case when both [x] and [y] are in short format */\n      if (x->ptr == NULL && y->ptr == NULL)\n      {  int xval = x->val, yval = y->val;\n         xassert(xval != 0x80000000 && yval != 0x80000000);\n         /* FIXME: use div function */\n         if (q != NULL)\n            mpz_set_si(q, xval / yval);\n         if (r != NULL)\n            mpz_set_si(r, xval % yval);\n         goto done;\n      }\n      /* convert [x] to long format, if necessary */\n      if (x->ptr == NULL)\n      {  xassert(x->val != 0x80000000);\n         if (x->val >= 0)\n         {  sx = +1;\n            t = (unsigned int)(+ x->val);\n         }\n         else\n         {  sx = -1;\n            t = (unsigned int)(- x->val);\n         }\n         ex = &dumx;\n         ex->d[0] = (unsigned short)t;\n         ex->d[1] = (unsigned short)(t >> 16);\n         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;\n         ex->next = NULL;\n      }\n      else\n      {  sx = x->val;\n         xassert(sx == +1 || sx == -1);\n         ex = x->ptr;\n      }\n      /* convert [y] to long format, if necessary */\n      if (y->ptr == NULL)\n      {  xassert(y->val != 0x80000000);\n         if (y->val >= 0)\n         {  sy = +1;\n            t = (unsigned int)(+ y->val);\n         }\n         else\n         {  sy = -1;\n            t = (unsigned int)(- y->val);\n         }\n         ey = &dumy;\n         ey->d[0] = (unsigned short)t;\n         ey->d[1] = (unsigned short)(t >> 16);\n         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;\n         ey->next = NULL;\n      }\n      else\n      {  sy = y->val;\n         xassert(sy == +1 || sy == -1);\n         ey = y->ptr;\n      }\n      /* determine the number of digits of [x] */\n      nx = n = 0;\n      for (e = ex; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++)\n         {  n++;\n            if (e->d[k])\n               nx = n;\n         }\n      }\n      xassert(nx > 0);\n      /* determine the number of digits of [y] */\n      ny = n = 0;\n      for (e = ey; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++)\n         {  n++;\n            if (e->d[k])\n               ny = n;\n         }\n      }\n      xassert(ny > 0);\n      /* if nx < ny then [q] = 0 and [r] = [x] */\n      if (nx < ny)\n      {  if (r != NULL)\n            mpz_set(r, x);\n         if (q != NULL)\n            mpz_set_si(q, 0);\n         goto done;\n      }\n      /* we need working array containing at least nx+ny+1 places */\n      work = gmp_get_work(nx+ny+1);\n      /* load digits of [x] */\n      wx = &work[0];\n      for (n = 0; n < nx; n++)\n         wx[n] = 0;\n      for (n = 0, e = ex; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++, n++)\n            if (e->d[k]) wx[n] = e->d[k];\n      }\n      /* load digits of [y] */\n      wy = &work[nx+1];\n      for (n = 0; n < ny; n++)\n         wy[n] = 0;\n      for (n = 0, e = ey; e != NULL; e = e->next)\n      {  for (k = 0; k <= 5; k++, n++)\n            if (e->d[k]) wy[n] = e->d[k];\n      }\n      /* compute quotient and remainder */\n      xassert(wy[ny-1] != 0);\n      bigdiv(nx-ny, ny, wx, wy);\n      /* construct and normalize quotient */\n      if (q != NULL)\n      {  mpz_set_si(q, 0);\n         q->val = sx * sy;\n         es = NULL;\n         k = 6;\n         for (n = ny; n <= nx; n++)\n         {  if (k > 5)\n            {  e = gmp_get_atom(sizeof(struct mpz_seg));\n               e->d[0] = e->d[1] = e->d[2] = 0;\n               e->d[3] = e->d[4] = e->d[5] = 0;\n               e->next = NULL;\n               if (q->ptr == NULL)\n                  q->ptr = e;\n               else\n                  es->next = e;\n               es = e;\n               k = 0;\n            }\n            es->d[k++] = wx[n];\n         }\n         normalize(q);\n      }\n      /* construct and normalize remainder */\n      if (r != NULL)\n      {  mpz_set_si(r, 0);\n         r->val = sx;\n         es = NULL;\n         k = 6;\n         for (n = 0; n < ny; n++)\n         {  if (k > 5)\n            {  e = gmp_get_atom(sizeof(struct mpz_seg));\n               e->d[0] = e->d[1] = e->d[2] = 0;\n               e->d[3] = e->d[4] = e->d[5] = 0;\n               e->next = NULL;\n               if (r->ptr == NULL)\n                  r->ptr = e;\n               else\n                  es->next = e;\n               es = e;\n               k = 0;\n            }\n            es->d[k++] = wx[n];\n         }\n         normalize(r);\n      }\ndone: return;\n}",
      "lines": 180,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "mpz_gcd": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        782,
        1
      ],
      "content": "void mpz_gcd(mpz_t z, mpz_t x, mpz_t y)\n{     /* set z to the greatest common divisor of x and y */\n      /* in case of arbitrary integers GCD(x, y) = GCD(|x|, |y|), and,\n       * in particular, GCD(0, 0) = 0 */\n      mpz_t u, v, r;\n      mpz_init(u);\n      mpz_init(v);\n      mpz_init(r);\n      mpz_abs(u, x);\n      mpz_abs(v, y);\n      while (mpz_sgn(v))\n      {  mpz_div(NULL, r, u, v);\n         mpz_set(u, v);\n         mpz_set(v, r);\n      }\n      mpz_set(z, u);\n      mpz_clear(u);\n      mpz_clear(v);\n      mpz_clear(r);\n      return;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_cmp": {
      "start_point": [
        784,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "int mpz_cmp(mpz_t x, mpz_t y)\n{     /* compare x and y; return a positive value if x > y, zero if\n       * x = y, or a nefative value if x < y */\n      static struct mpz_seg zero = { { 0, 0, 0, 0, 0, 0 }, NULL };\n      struct mpz_seg dumx, dumy, *ex, *ey;\n      int cc, sx, sy, k;\n      unsigned int t;\n      if (x == y)\n      {  cc = 0;\n         goto done;\n      }\n      /* special case when both [x] and [y] are in short format */\n      if (x->ptr == NULL && y->ptr == NULL)\n      {  int xval = x->val, yval = y->val;\n         xassert(xval != 0x80000000 && yval != 0x80000000);\n         cc = (xval > yval ? +1 : xval < yval ? -1 : 0);\n         goto done;\n      }\n      /* special case when [x] and [y] have different signs */\n      if (x->val > 0 && y->val <= 0 || x->val == 0 && y->val < 0)\n      {  cc = +1;\n         goto done;\n      }\n      if (x->val < 0 && y->val >= 0 || x->val == 0 && y->val > 0)\n      {  cc = -1;\n         goto done;\n      }\n      /* convert [x] to long format, if necessary */\n      if (x->ptr == NULL)\n      {  xassert(x->val != 0x80000000);\n         if (x->val >= 0)\n         {  sx = +1;\n            t = (unsigned int)(+ x->val);\n         }\n         else\n         {  sx = -1;\n            t = (unsigned int)(- x->val);\n         }\n         ex = &dumx;\n         ex->d[0] = (unsigned short)t;\n         ex->d[1] = (unsigned short)(t >> 16);\n         ex->d[2] = ex->d[3] = ex->d[4] = ex->d[5] = 0;\n         ex->next = NULL;\n      }\n      else\n      {  sx = x->val;\n         xassert(sx == +1 || sx == -1);\n         ex = x->ptr;\n      }\n      /* convert [y] to long format, if necessary */\n      if (y->ptr == NULL)\n      {  xassert(y->val != 0x80000000);\n         if (y->val >= 0)\n         {  sy = +1;\n            t = (unsigned int)(+ y->val);\n         }\n         else\n         {  sy = -1;\n            t = (unsigned int)(- y->val);\n         }\n         ey = &dumy;\n         ey->d[0] = (unsigned short)t;\n         ey->d[1] = (unsigned short)(t >> 16);\n         ey->d[2] = ey->d[3] = ey->d[4] = ey->d[5] = 0;\n         ey->next = NULL;\n      }\n      else\n      {  sy = y->val;\n         xassert(sy == +1 || sy == -1);\n         ey = y->ptr;\n      }\n      /* main fragment */\n      xassert(sx > 0 && sy > 0 || sx < 0 && sy < 0);\n      cc = 0;\n      for (; ex || ey; ex = ex->next, ey = ey->next)\n      {  if (ex == NULL)\n            ex = &zero;\n         if (ey == NULL)\n            ey = &zero;\n         for (k = 0; k <= 5; k++)\n         {  if (ex->d[k] > ey->d[k])\n               cc = +1;\n            if (ex->d[k] < ey->d[k])\n               cc = -1;\n         }\n      }\n      if (sx < 0) cc = - cc;\ndone: return cc;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpz_sgn": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "int mpz_sgn(mpz_t x)\n{     /* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */\n      int s;\n      s = (x->val > 0 ? +1 : x->val < 0 ? -1 : 0);\n      return s;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpz_out_str": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "int mpz_out_str(void *_fp, int base, mpz_t x)\n{     /* output x on stream fp, as a string in given base; the base\n       * may vary from 2 to 36;\n       * return the number of bytes written, or if an error occurred,\n       * return 0 */\n      FILE *fp = _fp;\n      mpz_t b, y, r;\n      int n, j, nwr = 0;\n      unsigned char *d;\n      static char *set = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n      if (!(2 <= base && base <= 36))\n         xerror(\"mpz_out_str: base = %d; invalid base\\n\", base);\n      mpz_init(b);\n      mpz_set_si(b, base);\n      mpz_init(y);\n      mpz_init(r);\n      /* determine the number of digits */\n      mpz_abs(y, x);\n      for (n = 0; mpz_sgn(y) != 0; n++)\n         mpz_div(y, NULL, y, b);\n      if (n == 0) n = 1;\n      /* compute the digits */\n      d = xmalloc(n);\n      mpz_abs(y, x);\n      for (j = 0; j < n; j++)\n      {  mpz_div(y, r, y, b);\n         xassert(0 <= r->val && r->val < base && r->ptr == NULL);\n         d[j] = (unsigned char)r->val;\n      }\n      /* output the integer to the stream */\n      if (fp == NULL)\n         fp = stdout;\n      if (mpz_sgn(x) < 0)\n         fputc('-', fp), nwr++;\n      for (j = n-1; j >= 0; j--)\n         fputc(set[d[j]], fp), nwr++;\n      if (ferror(fp))\n         nwr = 0;\n      mpz_clear(b);\n      mpz_clear(y);\n      mpz_clear(r);\n      xfree(d);\n      return nwr;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_mpq_init": {
      "start_point": [
        928,
        0
      ],
      "end_point": [
        937,
        1
      ],
      "content": "mpq_t _mpq_init(void)\n{     /* initialize x, and set its value to 0/1 */\n      mpq_t x;\n      x = gmp_get_atom(sizeof(struct mpq));\n      x->p.val = 0;\n      x->p.ptr = NULL;\n      x->q.val = 1;\n      x->q.ptr = NULL;\n      return x;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "mpq_t"
      ]
    },
    "mpq_clear": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        948,
        1
      ],
      "content": "void mpq_clear(mpq_t x)\n{     /* free the space occupied by x */\n      mpz_set_si(&x->p, 0);\n      xassert(x->p.ptr == NULL);\n      mpz_set_si(&x->q, 0);\n      xassert(x->q.ptr == NULL);\n      /* free the number descriptor */\n      gmp_free_atom(x, sizeof(struct mpq));\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpq_canonicalize": {
      "start_point": [
        950,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "void mpq_canonicalize(mpq_t x)\n{     /* remove any factors that are common to the numerator and\n       * denominator of x, and make the denominator positive */\n      mpz_t f;\n      xassert(x->q.val != 0);\n      if (x->q.val < 0)\n      {  mpz_neg(&x->p, &x->p);\n         mpz_neg(&x->q, &x->q);\n      }\n      mpz_init(f);\n      mpz_gcd(f, &x->p, &x->q);\n      if (!(f->val == 1 && f->ptr == NULL))\n      {  mpz_div(&x->p, NULL, &x->p, f);\n         mpz_div(&x->q, NULL, &x->q, f);\n      }\n      mpz_clear(f);\n      return;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpq_set": {
      "start_point": [
        969,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "void mpq_set(mpq_t z, mpq_t x)\n{     /* set the value of z from x */\n      if (z != x)\n      {  mpz_set(&z->p, &x->p);\n         mpz_set(&z->q, &x->q);\n      }\n      return;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpq_set_si": {
      "start_point": [
        978,
        0
      ],
      "end_point": [
        986,
        1
      ],
      "content": "void mpq_set_si(mpq_t x, int p, unsigned int q)\n{     /* set the value of x to p/q */\n      if (q == 0)\n         xerror(\"mpq_set_si: zero denominator not allowed\\n\");\n      mpz_set_si(&x->p, p);\n      xassert(q <= 0x7FFFFFFF);\n      mpz_set_si(&x->q, q);\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_get_d": {
      "start_point": [
        988,
        0
      ],
      "end_point": [
        995,
        1
      ],
      "content": "double mpq_get_d(mpq_t x)\n{     /* convert x to a double, truncating if necessary */\n      int np, nq;\n      double p, q;\n      p = mpz_get_d_2exp(&np, &x->p);\n      q = mpz_get_d_2exp(&nq, &x->q);\n      return ldexp(p / q, np - nq);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "mpq_set_d": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1038,
        1
      ],
      "content": "void mpq_set_d(mpq_t x, double val)\n{     /* set x to val; there is no rounding, the conversion is exact */\n      int s, n, d, j;\n      double f;\n      mpz_t temp;\n      xassert(-DBL_MAX <= val && val <= +DBL_MAX);\n      mpq_set_si(x, 0, 1);\n      if (val > 0.0)\n         s = +1;\n      else if (val < 0.0)\n         s = -1;\n      else\n         goto done;\n      f = frexp(fabs(val), &n);\n      /* |val| = f * 2^n, where 0.5 <= f < 1.0 */\n      mpz_init(temp);\n      while (f != 0.0)\n      {  f *= 16.0, n -= 4;\n         d = (int)f;\n         xassert(0 <= d && d <= 15);\n         f -= (double)d;\n         /* x := 16 * x + d */\n         mpz_set_si(temp, 16);\n         mpz_mul(&x->p, &x->p, temp);\n         mpz_set_si(temp, d);\n         mpz_add(&x->p, &x->p, temp);\n      }\n      mpz_clear(temp);\n      /* x := x * 2^n */\n      if (n > 0)\n      {  for (j = 1; j <= n; j++)\n            mpz_add(&x->p, &x->p, &x->p);\n      }\n      else if (n < 0)\n      {  for (j = 1; j <= -n; j++)\n            mpz_add(&x->q, &x->q, &x->q);\n         mpq_canonicalize(x);\n      }\n      if (s < 0)\n         mpq_neg(x, x);\ndone: return;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpq_add": {
      "start_point": [
        1040,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "void mpq_add(mpq_t z, mpq_t x, mpq_t y)\n{     /* set z to x + y */\n      mpz_t p, q;\n      mpz_init(p);\n      mpz_init(q);\n      mpz_mul(p, &x->p, &y->q);\n      mpz_mul(q, &x->q, &y->p);\n      mpz_add(p, p, q);\n      mpz_mul(q, &x->q, &y->q);\n      mpz_set(&z->p, p);\n      mpz_set(&z->q, q);\n      mpz_clear(p);\n      mpz_clear(q);\n      mpq_canonicalize(z);\n      return;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_sub": {
      "start_point": [
        1057,
        0
      ],
      "end_point": [
        1072,
        1
      ],
      "content": "void mpq_sub(mpq_t z, mpq_t x, mpq_t y)\n{     /* set z to x - y */\n      mpz_t p, q;\n      mpz_init(p);\n      mpz_init(q);\n      mpz_mul(p, &x->p, &y->q);\n      mpz_mul(q, &x->q, &y->p);\n      mpz_sub(p, p, q);\n      mpz_mul(q, &x->q, &y->q);\n      mpz_set(&z->p, p);\n      mpz_set(&z->q, q);\n      mpz_clear(p);\n      mpz_clear(q);\n      mpq_canonicalize(z);\n      return;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_mul": {
      "start_point": [
        1074,
        0
      ],
      "end_point": [
        1080,
        1
      ],
      "content": "void mpq_mul(mpq_t z, mpq_t x, mpq_t y)\n{     /* set z to x * y */\n      mpz_mul(&z->p, &x->p, &y->p);\n      mpz_mul(&z->q, &x->q, &y->q);\n      mpq_canonicalize(z);\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_div": {
      "start_point": [
        1082,
        0
      ],
      "end_point": [
        1097,
        1
      ],
      "content": "void mpq_div(mpq_t z, mpq_t x, mpq_t y)\n{     /* set z to x / y */\n      mpz_t p, q;\n      if (mpq_sgn(y) == 0)\n         xerror(\"mpq_div: zero divisor not allowed\\n\");\n      mpz_init(p);\n      mpz_init(q);\n      mpz_mul(p, &x->p, &y->q);\n      mpz_mul(q, &x->q, &y->p);\n      mpz_set(&z->p, p);\n      mpz_set(&z->q, q);\n      mpz_clear(p);\n      mpz_clear(q);\n      mpq_canonicalize(z);\n      return;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_neg": {
      "start_point": [
        1099,
        0
      ],
      "end_point": [
        1104,
        1
      ],
      "content": "void mpq_neg(mpq_t z, mpq_t x)\n{     /* set z to 0 - x */\n      mpq_set(z, x);\n      mpz_neg(&z->p, &z->p);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpq_abs": {
      "start_point": [
        1106,
        0
      ],
      "end_point": [
        1112,
        1
      ],
      "content": "void mpq_abs(mpq_t z, mpq_t x)\n{     /* set z to the absolute value of x */\n      mpq_set(z, x);\n      mpz_abs(&z->p, &z->p);\n      xassert(mpz_sgn(&x->q) > 0);\n      return;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpq_cmp": {
      "start_point": [
        1114,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "int mpq_cmp(mpq_t x, mpq_t y)\n{     /* compare x and y; return a positive value if x > y, zero if\n       * x = y, or a negative value if x < y */\n      mpq_t temp;\n      int s;\n      mpq_init(temp);\n      mpq_sub(temp, x, y);\n      s = mpq_sgn(temp);\n      mpq_clear(temp);\n      return s;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpq_sgn": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "int mpq_sgn(mpq_t x)\n{     /* return +1 if x > 0, 0 if x = 0, and -1 if x < 0 */\n      int s;\n      s = mpz_sgn(&x->p);\n      xassert(mpz_sgn(&x->q) > 0);\n      return s;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpq_out_str": {
      "start_point": [
        1134,
        0
      ],
      "end_point": [
        1157,
        1
      ],
      "content": "int mpq_out_str(void *_fp, int base, mpq_t x)\n{     /* output x on stream fp, as a string in given base; the base\n       * may vary from 2 to 36; output is in the form 'num/den' or if\n       * the denominator is 1 then just 'num';\n       * if the parameter fp is a null pointer, stdout is assumed;\n       * return the number of bytes written, or if an error occurred,\n       * return 0 */\n      FILE *fp = _fp;\n      int nwr;\n      if (!(2 <= base && base <= 36))\n         xerror(\"mpq_out_str: base = %d; invalid base\\n\", base);\n      if (fp == NULL)\n         fp = stdout;\n      nwr = mpz_out_str(fp, base, &x->p);\n      if (x->q.val == 1 && x->q.ptr == NULL)\n         ;\n      else\n      {  fputc('/', fp), nwr++;\n         nwr += mpz_out_str(fp, base, &x->q);\n      }\n      if (ferror(fp))\n         nwr = 0;\n      return nwr;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/mygmp.h": {},
  "glpk/glpk-4.65/src/misc/okalg.c": {
    "overflow": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int overflow(int u, int v)\n{     /* check for integer overflow on computing u + v */\n      if (u > 0 && v > 0 && u + v < 0) return 1;\n      if (u < 0 && v < 0 && u + v > 0) return 1;\n      return 0;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "okalg": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "int okalg(int nv, int na, const int tail[], const int head[],\n      const int low[], const int cap[], const int cost[], int x[],\n      int pi[])\n{     int a, aok, delta, i, j, k, lambda, pos1, pos2, s, t, temp, ret,\n         *ptr, *arc, *link, *list;\n      /* sanity checks */\n      xassert(nv >= 0);\n      xassert(na >= 0);\n      for (a = 1; a <= na; a++)\n      {  i = tail[a], j = head[a];\n         xassert(1 <= i && i <= nv);\n         xassert(1 <= j && j <= nv);\n         xassert(i != j);\n         xassert(0 <= low[a] && low[a] <= cap[a]);\n      }\n      /* allocate working arrays */\n      ptr = xcalloc(1+nv+1, sizeof(int));\n      arc = xcalloc(1+na+na, sizeof(int));\n      link = xcalloc(1+nv, sizeof(int));\n      list = xcalloc(1+nv, sizeof(int));\n      /* ptr[i] := (degree of node i) */\n      for (i = 1; i <= nv; i++)\n         ptr[i] = 0;\n      for (a = 1; a <= na; a++)\n      {  ptr[tail[a]]++;\n         ptr[head[a]]++;\n      }\n      /* initialize arc pointers */\n      ptr[1]++;\n      for (i = 1; i < nv; i++)\n         ptr[i+1] += ptr[i];\n      ptr[nv+1] = ptr[nv];\n      /* build arc lists */\n      for (a = 1; a <= na; a++)\n      {  arc[--ptr[tail[a]]] = a;\n         arc[--ptr[head[a]]] = a;\n      }\n      xassert(ptr[1] == 1);\n      xassert(ptr[nv+1] == na+na+1);\n      /* now the indices of arcs incident to node i are stored in\n       * locations arc[ptr[i]], arc[ptr[i]+1], ..., arc[ptr[i+1]-1] */\n      /* initialize arc flows and node potentials */\n      for (a = 1; a <= na; a++)\n         x[a] = 0;\n      for (i = 1; i <= nv; i++)\n         pi[i] = 0;\nloop: /* main loop starts here */\n      /* find out-of-kilter arc */\n      aok = 0;\n      for (a = 1; a <= na; a++)\n      {  i = tail[a], j = head[a];\n         if (overflow(cost[a], pi[i] - pi[j]))\n         {  ret = 2;\n            goto done;\n         }\n         lambda = cost[a] + (pi[i] - pi[j]);\n         if (x[a] < low[a] || (lambda < 0 && x[a] < cap[a]))\n         {  /* arc a = i->j is out of kilter, and we need to increase\n             * the flow through this arc */\n            aok = a, s = j, t = i;\n            break;\n         }\n         if (x[a] > cap[a] || (lambda > 0 && x[a] > low[a]))\n         {  /* arc a = i->j is out of kilter, and we need to decrease\n             * the flow through this arc */\n            aok = a, s = i, t = j;\n            break;\n         }\n      }\n      if (aok == 0)\n      {  /* all arcs are in kilter */\n         /* check for feasibility */\n         for (a = 1; a <= na; a++)\n         {  if (!(low[a] <= x[a] && x[a] <= cap[a]))\n            {  ret = 3;\n               goto done;\n            }\n         }\n         for (i = 1; i <= nv; i++)\n         {  temp = 0;\n            for (k = ptr[i]; k < ptr[i+1]; k++)\n            {  a = arc[k];\n               if (tail[a] == i)\n               {  /* a is outgoing arc */\n                  temp += x[a];\n               }\n               else if (head[a] == i)\n               {  /* a is incoming arc */\n                  temp -= x[a];\n               }\n               else\n                  xassert(a != a);\n            }\n            if (temp != 0)\n            {  ret = 3;\n               goto done;\n            }\n         }\n         /* check for optimality */\n         for (a = 1; a <= na; a++)\n         {  i = tail[a], j = head[a];\n            lambda = cost[a] + (pi[i] - pi[j]);\n            if ((lambda > 0 && x[a] != low[a]) ||\n                (lambda < 0 && x[a] != cap[a]))\n            {  ret = 3;\n               goto done;\n            }\n         }\n         /* current circulation is optimal */\n         ret = 0;\n         goto done;\n      }\n      /* now we need to find a cycle (t, a, s, ..., t), which allows\n       * increasing the flow along it, where a is the out-of-kilter arc\n       * just found */\n      /* link[i] = 0 means that node i is not labelled yet;\n       * link[i] = a means that arc a immediately precedes node i */\n      /* initially only node s is labelled */\n      for (i = 1; i <= nv; i++)\n         link[i] = 0;\n      link[s] = aok, list[1] = s, pos1 = pos2 = 1;\n      /* breadth first search */\n      while (pos1 <= pos2)\n      {  /* dequeue node i */\n         i = list[pos1++];\n         /* consider all arcs incident to node i */\n         for (k = ptr[i]; k < ptr[i+1]; k++)\n         {  a = arc[k];\n            if (tail[a] == i)\n            {  /* a = i->j is a forward arc from s to t */\n               j = head[a];\n               /* if node j has been labelled, skip the arc */\n               if (link[j] != 0) continue;\n               /* if the arc does not allow increasing the flow through\n                * it, skip the arc */\n               if (x[a] >= cap[a]) continue;\n               if (overflow(cost[a], pi[i] - pi[j]))\n               {  ret = 2;\n                  goto done;\n               }\n               lambda = cost[a] + (pi[i] - pi[j]);\n               if (lambda > 0 && x[a] >= low[a]) continue;\n            }\n            else if (head[a] == i)\n            {  /* a = i<-j is a backward arc from s to t */\n               j = tail[a];\n               /* if node j has been labelled, skip the arc */\n               if (link[j] != 0) continue;\n               /* if the arc does not allow decreasing the flow through\n                * it, skip the arc */\n               if (x[a] <= low[a]) continue;\n               if (overflow(cost[a], pi[j] - pi[i]))\n               {  ret = 2;\n                  goto done;\n               }\n               lambda = cost[a] + (pi[j] - pi[i]);\n               if (lambda < 0 && x[a] <= cap[a]) continue;\n            }\n            else\n               xassert(a != a);\n            /* label node j and enqueue it */\n            link[j] = a, list[++pos2] = j;\n            /* check for breakthrough */\n            if (j == t) goto brkt;\n         }\n      }\n      /* NONBREAKTHROUGH */\n      /* consider all arcs, whose one endpoint is labelled and other is\n       * not, and determine maximal change of node potentials */\n      delta = 0;\n      for (a = 1; a <= na; a++)\n      {  i = tail[a], j = head[a];\n         if (link[i] != 0 && link[j] == 0)\n         {  /* a = i->j, where node i is labelled, node j is not */\n            if (overflow(cost[a], pi[i] - pi[j]))\n            {  ret = 2;\n               goto done;\n            }\n            lambda = cost[a] + (pi[i] - pi[j]);\n            if (x[a] <= cap[a] && lambda > 0)\n               if (delta == 0 || delta > + lambda) delta = + lambda;\n         }\n         else if (link[i] == 0 && link[j] != 0)\n         {  /* a = j<-i, where node j is labelled, node i is not */\n            if (overflow(cost[a], pi[i] - pi[j]))\n            {  ret = 2;\n               goto done;\n            }\n            lambda = cost[a] + (pi[i] - pi[j]);\n            if (x[a] >= low[a] && lambda < 0)\n               if (delta == 0 || delta > - lambda) delta = - lambda;\n         }\n      }\n      if (delta == 0)\n      {  /* there is no feasible circulation */\n         ret = 1;\n         goto done;\n      }\n      /* increase potentials of all unlabelled nodes */\n      for (i = 1; i <= nv; i++)\n      {  if (link[i] == 0)\n         {  if (overflow(pi[i], delta))\n            {  ret = 2;\n               goto done;\n            }\n            pi[i] += delta;\n         }\n      }\n      goto loop;\nbrkt: /* BREAKTHROUGH */\n      /* walk through arcs of the cycle (t, a, s, ..., t) found in the\n       * reverse order and determine maximal change of the flow */\n      delta = 0;\n      for (j = t;; j = i)\n      {  /* arc a immediately precedes node j in the cycle */\n         a = link[j];\n         if (head[a] == j)\n         {  /* a = i->j is a forward arc of the cycle */\n            i = tail[a];\n            lambda = cost[a] + (pi[i] - pi[j]);\n            if (lambda > 0 && x[a] < low[a])\n            {  /* x[a] may be increased until its lower bound */\n               temp = low[a] - x[a];\n            }\n            else if (lambda <= 0 && x[a] < cap[a])\n            {  /* x[a] may be increased until its upper bound */\n               temp = cap[a] - x[a];\n            }\n            else\n               xassert(a != a);\n         }\n         else if (tail[a] == j)\n         {  /* a = i<-j is a backward arc of the cycle */\n            i = head[a];\n            lambda = cost[a] + (pi[j] - pi[i]);\n            if (lambda < 0 && x[a] > cap[a])\n            {  /* x[a] may be decreased until its upper bound */\n               temp = x[a] - cap[a];\n            }\n            else if (lambda >= 0 && x[a] > low[a])\n            {  /* x[a] may be decreased until its lower bound */\n               temp = x[a] - low[a];\n            }\n            else\n               xassert(a != a);\n         }\n         else\n            xassert(a != a);\n         if (delta == 0 || delta > temp) delta = temp;\n         /* check for end of the cycle */\n         if (i == t) break;\n      }\n      xassert(delta > 0);\n      /* increase the flow along the cycle */\n      for (j = t;; j = i)\n      {  /* arc a immediately precedes node j in the cycle */\n         a = link[j];\n         if (head[a] == j)\n         {  /* a = i->j is a forward arc of the cycle */\n            i = tail[a];\n            /* overflow cannot occur */\n            x[a] += delta;\n         }\n         else if (tail[a] == j)\n         {  /* a = i<-j is a backward arc of the cycle */\n            i = head[a];\n            /* overflow cannot occur */\n            x[a] -= delta;\n         }\n         else\n            xassert(a != a);\n         /* check for end of the cycle */\n         if (i == t) break;\n      }\n      goto loop;\ndone: /* free working arrays */\n      xfree(ptr);\n      xfree(arc);\n      xfree(link);\n      xfree(list);\n      return ret;\n}",
      "lines": 282,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/okalg.h": {},
  "glpk/glpk-4.65/src/misc/qmd.c": {
    "genqmd": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void genqmd(int *_neqns, int xadj[], int adjncy[], int perm[],\n      int invp[], int deg[], int marker[], int rchset[], int nbrhd[],\n      int qsize[], int qlink[], int *_nofsub)\n{     int inode, ip, irch, j, mindeg, ndeg, nhdsze, node, np, num,\n         nump1, nxnode, rchsze, search, thresh;\n#     define neqns  (*_neqns)\n#     define nofsub (*_nofsub)\n      /* Initialize degree vector and other working variables. */\n      mindeg = neqns;\n      nofsub = 0;\n      for (node = 1; node <= neqns; node++)\n      {  perm[node] = node;\n         invp[node] = node;\n         marker[node] = 0;\n         qsize[node] = 1;\n         qlink[node] = 0;\n         ndeg = xadj[node+1] - xadj[node];\n         deg[node] = ndeg;\n         if (ndeg < mindeg) mindeg = ndeg;\n      }\n      num = 0;\n      /* Perform threshold search to get a node of min degree.\n       * Variable search point to where search should start. */\ns200: search = 1;\n      thresh = mindeg;\n      mindeg = neqns;\ns300: nump1 = num + 1;\n      if (nump1 > search) search = nump1;\n      for (j = search; j <= neqns; j++)\n      {  node = perm[j];\n         if (marker[node] >= 0)\n         {  ndeg = deg[node];\n            if (ndeg <= thresh) goto s500;\n            if (ndeg < mindeg) mindeg = ndeg;\n         }\n      }\n      goto s200;\n      /* Node has minimum degree. Find its reachable sets by calling\n       * qmdrch. */\ns500: search = j;\n      nofsub += deg[node];\n      marker[node] = 1;\n      qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset, &nhdsze,\n         nbrhd);\n      /* Eliminate all nodes indistinguishable from node. They are given\n       * by node, qlink[node], ... . */\n      nxnode = node;\ns600: num++;\n      np = invp[nxnode];\n      ip = perm[num];\n      perm[np] = ip;\n      invp[ip] = np;\n      perm[num] = nxnode;\n      invp[nxnode] = num;\n      deg[nxnode] = -1;\n      nxnode = qlink[nxnode];\n      if (nxnode > 0) goto s600;\n      if (rchsze > 0)\n      {  /* Update the degrees of the nodes in the reachable set and\n          * identify indistinguishable nodes. */\n         qmdupd(xadj, adjncy, &rchsze, rchset, deg, qsize, qlink,\n            marker, &rchset[rchsze+1], &nbrhd[nhdsze+1]);\n         /* Reset marker value of nodes in reach set. Update threshold\n          * value for cyclic search. Also call qmdqt to form new\n          * quotient graph. */\n         marker[node] = 0;\n         for (irch = 1; irch <= rchsze; irch++)\n         {  inode = rchset[irch];\n            if (marker[inode] >= 0)\n            {  marker[inode] = 0;\n               ndeg = deg[inode];\n               if (ndeg < mindeg) mindeg = ndeg;\n               if (ndeg <= thresh)\n               {  mindeg = thresh;\n                  thresh = ndeg;\n                  search = invp[inode];\n               }\n            }\n         }\n         if (nhdsze > 0)\n            qmdqt(&node, xadj, adjncy, marker, &rchsze, rchset, nbrhd);\n      }\n      if (num < neqns) goto s300;\n      return;\n#     undef neqns\n#     undef nofsub\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "qmdrch": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void qmdrch(int *_root, int xadj[], int adjncy[], int deg[],\n      int marker[], int *_rchsze, int rchset[], int *_nhdsze,\n      int nbrhd[])\n{     int i, istop, istrt, j, jstop, jstrt, nabor, node;\n#     define root   (*_root)\n#     define rchsze (*_rchsze)\n#     define nhdsze (*_nhdsze)\n      /* Loop through the neighbors of root in the quotient graph. */\n      nhdsze = 0;\n      rchsze = 0;\n      istrt = xadj[root];\n      istop = xadj[root+1] - 1;\n      if (istop < istrt) return;\n      for (i = istrt; i <= istop; i++)\n      {  nabor = adjncy[i];\n         if (nabor == 0) return;\n         if (marker[nabor] == 0)\n         {  if (deg[nabor] >= 0)\n            {  /* Include nabor into the reachable set. */\n               rchsze++;\n               rchset[rchsze] = nabor;\n               marker[nabor] = 1;\n               goto s600;\n            }\n            /* nabor has been eliminated. Find nodes reachable from\n             * it. */\n            marker[nabor] = -1;\n            nhdsze++;\n            nbrhd[nhdsze] = nabor;\ns300:       jstrt = xadj[nabor];\n            jstop = xadj[nabor+1] - 1;\n            for (j = jstrt; j <= jstop; j++)\n            {  node = adjncy[j];\n               nabor = - node;\n               if (node < 0) goto s300;\n               if (node == 0) goto s600;\n               if (marker[node] == 0)\n               {  rchsze++;\n                  rchset[rchsze] = node;\n                  marker[node] = 1;\n               }\n            }\n         }\ns600:    ;\n      }\n      return;\n#     undef root\n#     undef rchsze\n#     undef nhdsze\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "qmdqt": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "void qmdqt(int *_root, int xadj[], int adjncy[], int marker[],\n      int *_rchsze, int rchset[], int nbrhd[])\n{     int inhd, irch, j, jstop, jstrt, link, nabor, node;\n#     define root   (*_root)\n#     define rchsze (*_rchsze)\n      irch = 0;\n      inhd = 0;\n      node = root;\ns100: jstrt = xadj[node];\n      jstop = xadj[node+1] - 2;\n      if (jstop >= jstrt)\n      {  /* Place reach nodes into the adjacent list of node. */\n         for (j = jstrt; j <= jstop; j++)\n         {  irch++;\n            adjncy[j] = rchset[irch];\n            if (irch >= rchsze) goto s400;\n         }\n      }\n      /* Link to other space provided by the nbrhd set. */\n      link = adjncy[jstop+1];\n      node = - link;\n      if (link >= 0)\n      {  inhd++;\n         node = nbrhd[inhd];\n         adjncy[jstop+1] = - node;\n      }\n      goto s100;\n      /* All reachable nodes have been saved. End the adjacent list.\n       * Add root to the neighborhood list of each node in the reach\n       * set. */\ns400: adjncy[j+1] = 0;\n      for (irch = 1; irch <= rchsze; irch++)\n      {  node = rchset[irch];\n         if (marker[node] >= 0)\n         {  jstrt = xadj[node];\n            jstop = xadj[node+1] - 1;\n            for (j = jstrt; j <= jstop; j++)\n            {  nabor = adjncy[j];\n               if (marker[nabor] < 0)\n               {  adjncy[j] = root;\n                  goto s600;\n               }\n            }\n         }\ns600:    ;\n      }\n      return;\n#     undef root\n#     undef rchsze\n}",
      "lines": 50,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "qmdupd": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        447,
        1
      ],
      "content": "void qmdupd(int xadj[], int adjncy[], int *_nlist, int list[],\n      int deg[], int qsize[], int qlink[], int marker[], int rchset[],\n      int nbrhd[])\n{     int deg0, deg1, il, inhd, inode, irch, j, jstop, jstrt, mark,\n         nabor, nhdsze, node, rchsze;\n#     define nlist  (*_nlist)\n      /* Find all eliminated supernodes that are adjacent to some nodes\n       * in the given list. Put them into (nhdsze, nbrhd). deg0 contains\n       * the number of nodes in the list. */\n      if (nlist <= 0) return;\n      deg0 = 0;\n      nhdsze = 0;\n      for (il = 1; il <= nlist; il++)\n      {  node = list[il];\n         deg0 += qsize[node];\n         jstrt = xadj[node];\n         jstop = xadj[node+1] - 1;\n         for (j = jstrt; j <= jstop; j++)\n         {  nabor = adjncy[j];\n            if (marker[nabor] == 0 && deg[nabor] < 0)\n            {  marker[nabor] = -1;\n               nhdsze++;\n               nbrhd[nhdsze] = nabor;\n            }\n         }\n      }\n      /* Merge indistinguishable nodes in the list by calling the\n       * subroutine qmdmrg. */\n      if (nhdsze > 0)\n         qmdmrg(xadj, adjncy, deg, qsize, qlink, marker, &deg0, &nhdsze,\n            nbrhd, rchset, &nbrhd[nhdsze+1]);\n      /* Find the new degrees of the nodes that have not been merged. */\n      for (il = 1; il <= nlist; il++)\n      {  node = list[il];\n         mark = marker[node];\n         if (mark == 0 || mark == 1)\n         {  marker[node] = 2;\n            qmdrch(&node, xadj, adjncy, deg, marker, &rchsze, rchset,\n               &nhdsze, nbrhd);\n            deg1 = deg0;\n            if (rchsze > 0)\n            {  for (irch = 1; irch <= rchsze; irch++)\n               {  inode = rchset[irch];\n                  deg1 += qsize[inode];\n                  marker[inode] = 0;\n               }\n            }\n            deg[node] = deg1 - 1;\n            if (nhdsze > 0)\n            {  for (inhd = 1; inhd <= nhdsze; inhd++)\n               {  inode = nbrhd[inhd];\n                  marker[inode] = 0;\n               }\n            }\n         }\n      }\n      return;\n#     undef nlist\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "qmdmrg": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        581,
        1
      ],
      "content": "void qmdmrg(int xadj[], int adjncy[], int deg[], int qsize[],\n      int qlink[], int marker[], int *_deg0, int *_nhdsze, int nbrhd[],\n      int rchset[], int ovrlp[])\n{     int deg1, head, inhd, iov, irch, j, jstop, jstrt, link, lnode,\n         mark, mrgsze, nabor, node, novrlp, rchsze, root;\n#     define deg0   (*_deg0)\n#     define nhdsze (*_nhdsze)\n      /* Initialization. */\n      if (nhdsze <= 0) return;\n      for (inhd = 1; inhd <= nhdsze; inhd++)\n      {  root = nbrhd[inhd];\n         marker[root] = 0;\n      }\n      /* Loop through each eliminated supernode in the set\n       * (nhdsze, nbrhd). */\n      for (inhd = 1; inhd <= nhdsze; inhd++)\n      {  root = nbrhd[inhd];\n         marker[root] = -1;\n         rchsze = 0;\n         novrlp = 0;\n         deg1 = 0;\ns200:    jstrt = xadj[root];\n         jstop = xadj[root+1] - 1;\n         /* Determine the reachable set and its intersection with the\n          * input reachable set. */\n         for (j = jstrt; j <= jstop; j++)\n         {  nabor = adjncy[j];\n            root = - nabor;\n            if (nabor < 0) goto s200;\n            if (nabor == 0) break;\n            mark = marker[nabor];\n            if (mark == 0)\n            {  rchsze++;\n               rchset[rchsze] = nabor;\n               deg1 += qsize[nabor];\n               marker[nabor] = 1;\n            }\n            else if (mark == 1)\n            {  novrlp++;\n               ovrlp[novrlp] = nabor;\n               marker[nabor] = 2;\n            }\n         }\n         /* From the overlapped set, determine the nodes that can be\n          * merged together. */\n         head = 0;\n         mrgsze = 0;\n         for (iov = 1; iov <= novrlp; iov++)\n         {  node = ovrlp[iov];\n            jstrt = xadj[node];\n            jstop = xadj[node+1] - 1;\n            for (j = jstrt; j <= jstop; j++)\n            {  nabor = adjncy[j];\n               if (marker[nabor] == 0)\n               {  marker[node] = 1;\n                  goto s1100;\n               }\n            }\n            /* Node belongs to the new merged supernode. Update the\n             * vectors qlink and qsize. */\n            mrgsze += qsize[node];\n            marker[node] = -1;\n            lnode = node;\ns900:       link = qlink[lnode];\n            if (link > 0)\n            {  lnode = link;\n               goto s900;\n            }\n            qlink[lnode] = head;\n            head = node;\ns1100:      ;\n         }\n         if (head > 0)\n         {  qsize[head] = mrgsze;\n            deg[head] = deg0 + deg1 - 1;\n            marker[head] = 2;\n         }\n         /* Reset marker values. */\n         root = nbrhd[inhd];\n         marker[root] = 0;\n         if (rchsze > 0)\n         {  for (irch = 1; irch <= rchsze; irch++)\n            {  node = rchset[irch];\n               marker[node] = 0;\n            }\n         }\n      }\n      return;\n#     undef deg0\n#     undef nhdsze\n}",
      "lines": 91,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/qmd.h": {},
  "glpk/glpk-4.65/src/misc/relax4.c": {
    "relax4": {
      "start_point": [
        241,
        0
      ],
      "end_point": [
        1428,
        1
      ],
      "content": "int relax4(struct relax4_csa *csa)\n{     /* input parameters */\n      int n = csa->n;\n      int na = csa->na;\n      int large = csa->large;\n      int repeat = csa->repeat;\n      int crash = csa->crash;\n      int *startn = csa->startn;\n      int *endn = csa->endn;\n      int *fou = csa->fou;\n      int *nxtou = csa->nxtou;\n      int *fin = csa->fin;\n      int *nxtin = csa->nxtin;\n      /* updated parameters */\n      int *rc = csa->rc;\n      int *u = csa->u;\n      int *dfct = csa->dfct;\n      /* output parameters */\n      int *x = csa->x;\n#     define nmultinode (csa->nmultinode)\n#     define iter (csa->iter)\n#     define num_augm (csa->num_augm)\n#     define num_ascnt (csa->num_ascnt)\n#     define nsp (csa->nsp)\n      /* working parameters */\n      int *label = csa->label;\n      int *prdcsr = csa->prdcsr;\n      int *save = csa->save;\n      int *tfstou = csa->tfstou;\n      int *tnxtou = csa->tnxtou;\n      int *tfstin = csa->tfstin;\n      int *tnxtin = csa->tnxtin;\n      int *nxtqueue = csa->nxtqueue;\n      char *scan = csa->scan;\n      char *mark = csa->mark;\n      int *ddpos = tfstou;\n      int *ddneg = tfstin;\n      /* local variables */\n      int arc, augnod, capin, capout, defcit, delprc, delx, dm, dp,\n         dx, feasbl, i, ib, indef, j, lastqueue, maxcap, narc, nb,\n         nlabel, node, node2, node_def, naugnod, nscan, num_passes,\n         numnz, numnz_new, numpasses, nxtarc, nxtbrk, nxtnode, passes,\n         pchange, posit, prevnode, prvarc, quit, rdcost, scapin,\n         scapou, svitch, t, t1, t2, tmparc, tp, trc, ts;\n      /*--------------------------------------------------------------*/\n      /* Initialization phase I */\n      /* In this phase, we reduce the arc capacities by as much as\n       * possible without changing the problem; then we set the initial\n       * flow array x, together with the corresponding arrays u and\n       * dfct. */\n      /* This phase and phase II (from here up to line labeled 90) can\n       * be skipped (by setting repeat to true) if the calling program\n       * places in common user-chosen values for the arc flows, the\n       * residual arc capacities, and the nodal deficits. When this is\n       * done, it is critical that the flow and the reduced cost for\n       * each arc satisfy complementary slackness and the dfct array\n       * properly correspond to the initial arc/flows. */\n      if (repeat)\n         goto L90;\n      for (node = 1; node <= n; node++)\n      {  node_def = dfct[node];\n         ddpos[node] = node_def;\n         ddneg[node] = -node_def;\n         maxcap = 0;\n         scapou = 0;\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  if (scapou <= large - u[arc])\n               scapou += u[arc];\n            else\n               goto L10;\n         }\n         if (scapou <= large - node_def)\n            capout = scapou + node_def;\n         else\n            goto L10;\n         if (capout < 0)\n         {  /* problem is infeasible */\n            /* exogenous flow into node exceeds out capacity */\n            return 1;\n         }\n         scapin = 0;\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  if (u[arc] > capout)\n               u[arc] = capout;\n            if (maxcap < u[arc])\n               maxcap = u[arc];\n            if (scapin <= large - u[arc])\n               scapin += u[arc];\n            else\n               goto L10;\n         }\n         if (scapin <= large + node_def)\n            capin = scapin - node_def;\n         else\n            goto L10;\n         if (capin < 0)\n         {  /* problem is infeasible */\n            /* exogenous flow out of node exceeds in capacity */\n            return 2;\n         }\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  if (u[arc] > capin)\n               u[arc] = capin;\n         }\nL10:     ;\n      }\n      /*--------------------------------------------------------------*/\n      /* Initialization phase II */\n      /* In this phase, we initialize the prices and flows by either\n       * calling the routine auction or by performing only single node\n       * (coordinate) relaxation iterations. */\n      if (crash == 1)\n      {  nsp = 0;\n         if (auction(csa) != 0)\n         {  /* problem is found to be infeasible */\n            return 3;\n         }\n         goto L70;\n      }\n      /* Initialize the arc flows to satisfy complementary slackness\n       * with the prices. u[arc] is the residual capacity of arc, and\n       * x[arc] is the flow. These two always add up to the total\n       * capacity for arc. Also compute the directional derivatives for\n       * each coordinate and compute the actual deficits. */\n      for (arc = 1; arc <= na; arc++)\n      {  x[arc] = 0;\n         if (rc[arc] <= 0)\n         {  t = u[arc];\n            t1 = startn[arc];\n            t2 = endn[arc];\n            ddpos[t1] += t;\n            ddneg[t2] += t;\n            if (rc[arc] < 0)\n            {  x[arc] = t;\n               u[arc] = 0;\n               dfct[t1] += t;\n               dfct[t2] -= t;\n               ddneg[t1] -= t;\n               ddpos[t2] -= t;\n            }\n         }\n      }\n      /* Make 2 or 3 passes through all nodes, performing only single\n       * node relaxation iterations. The number of passes depends on the\n       * density of the network. */\n      if (na > n * 10)\n         numpasses = 2;\n      else\n         numpasses = 3;\n      for (passes = 1; passes <= numpasses; passes++)\n      for (node = 1; node <= n; node++)\n      {  if (dfct[node] == 0)\n            continue;\n         if (ddpos[node] <= 0)\n         {  /* Compute delprc, the stepsize to the next breakpoint in\n             * the dual cost as the price of node is increased.\n             * [Since the reduced cost of all outgoing (resp., incoming)\n             * arcs will decrease (resp., increase) as the price of node\n             * is increased, the next breakpoint is the minimum of the\n             * positive reduced cost on outgoing arcs and of the\n             * negative reduced cost on incoming arcs.] */\n            delprc = large;\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  trc = rc[arc];\n               if ((trc > 0) && (trc < delprc))\n                  delprc = trc;\n            }\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  trc = rc[arc];\n               if ((trc < 0) && (trc > -delprc))\n                  delprc = -trc;\n            }\n            /* If no breakpoint is left and dual ascent is still\n             * possible, the problem is infeasible. */\n            if (delprc >= large)\n            {  if (ddpos[node] == 0)\n                  continue;\n               return 4;\n            }\n            /* delprc is the stepsize to next breakpoint. Increase\n             * price of node by delprc and compute the stepsize to the\n             * next breakpoint in the dual cost. */\nL53:        nxtbrk = large;\n            /* Look at all arcs out of node. */\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  trc = rc[arc];\n               if (trc == 0)\n               {  t1 = endn[arc];\n                  t = u[arc];\n                  if (t > 0)\n                  {  dfct[node] += t;\n                     dfct[t1] -= t;\n                     x[arc] = t;\n                     u[arc] = 0;\n                  }\n                  else\n                     t = x[arc];\n                  ddneg[node] -= t;\n                  ddpos[t1] -= t;\n               }\n               /* Decrease the reduced costs on all outgoing arcs. */\n               trc -= delprc;\n               if ((trc > 0) && (trc < nxtbrk))\n                  nxtbrk = trc;\n               else if (trc == 0)\n               {  /* Arc goes from inactive to balanced. Update the rate\n                   * of dual ascent at node and at its neighbor. */\n                  ddpos[node] += u[arc];\n                  ddneg[endn[arc]] += u[arc];\n               }\n               rc[arc] = trc;\n            }\n            /* Look at all arcs into node. */\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  trc = rc[arc];\n               if (trc == 0)\n               {  t1 = startn[arc];\n                  t = x[arc];\n                  if (t > 0)\n                  {  dfct[node] += t;\n                     dfct[t1] -= t;\n                     u[arc] = t;\n                     x[arc] = 0;\n                  }\n                  else\n                     t = u[arc];\n                  ddpos[t1] -= t;\n                  ddneg[node] -= t;\n               }\n               /* Increase the reduced cost on all incoming arcs. */\n               trc += delprc;\n               if ((trc < 0) && (trc > -nxtbrk))\n                  nxtbrk = -trc;\n               else if (trc == 0)\n               {  /* Arc goes from active to balanced. Update the rate\n                   * of dual ascent at node and at its neighbor. */\n                  ddneg[startn[arc]] += x[arc];\n                  ddpos[node] += x[arc];\n               }\n               rc[arc] = trc;\n            }\n            /* If price of node can be increased further without\n             * decreasing the dual cost (even the dual cost doesn't\n             * increase), return to increase the price further. */\n            if ((ddpos[node] <= 0) && (nxtbrk < large))\n            {  delprc = nxtbrk;\n               goto L53;\n            }\n         }\n         else if (ddneg[node] <= 0)\n         {  /* Compute delprc, the stepsize to the next breakpoint in\n             * the dual cost as the price of node is decreased.\n             * [Since the reduced cost of all outgoing (resp., incoming)\n             * arcs will increase (resp., decrease) as the price of node\n             * is decreased, the next breakpoint is the minimum of the\n             * negative reduced cost on outgoing arcs and of the\n             * positive reduced cost on incoming arcs.] */\n            delprc = large;\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  trc = rc[arc];\n               if ((trc < 0) && (trc > -delprc))\n                  delprc = -trc;\n            }\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  trc = rc[arc];\n               if ((trc > 0) && (trc < delprc))\n                  delprc = trc;\n            }\n            /* If no breakpoint is left and dual ascent is still\n             * possible, the problem is infeasible. */\n            if (delprc == large)\n            {  if (ddneg[node] == 0)\n                  continue;\n               return 5;\n            }\n            /* delprc is the stepsize to next breakpoint. Decrease\n             * price of node by delprc and compute the stepsize to the\n             * next breakpoint in the dual cost. */\nL63:        nxtbrk = large;\n            /* Look at all arcs out of node. */\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  trc = rc[arc];\n               if (trc == 0)\n               {  t1 = endn[arc];\n                  t = x[arc];\n                  if (t > 0)\n                  {  dfct[node] -= t;\n                     dfct[t1] += t;\n                     u[arc] = t;\n                     x[arc] = 0;\n                  }\n                  else\n                     t = u[arc];\n                  ddpos[node] -= t;\n                  ddneg[t1] -= t;\n               }\n               /* Increase the reduced cost on all outgoing arcs. */\n               trc += delprc;\n               if ((trc < 0) && (trc > -nxtbrk))\n                  nxtbrk = -trc;\n               else if (trc == 0)\n               {  /* Arc goes from active to balanced. Update the rate\n                   * of dual ascent at node and at its neighbor. */\n                  ddneg[node] += x[arc];\n                  ddpos[endn[arc]] += x[arc];\n               }\n               rc[arc] = trc;\n            }\n            /* Look at all arcs into node. */\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  trc = rc[arc];\n               if (trc == 0)\n               {  t1 = startn[arc];\n                  t = u[arc];\n                  if (t > 0)\n                  {  dfct[node] -= t;\n                     dfct[t1] += t;\n                     x[arc] = t;\n                     u[arc] = 0;\n                  }\n                  else\n                     t = x[arc];\n                  ddneg[t1] -= t;\n                  ddpos[node] -= t;\n               }\n               /* Decrease the reduced cost on all incoming arcs. */\n               trc -= delprc;\n               if ((trc > 0) && (trc < nxtbrk))\n                  nxtbrk = trc;\n               else if (trc == 0)\n               {  /* Arc goes from inactive to balanced. Update the rate\n                   * of dual ascent at node and at its neighbor. */\n                  ddpos[startn[arc]] += u[arc];\n                  ddneg[node] += u[arc];\n               }\n               rc[arc] = trc;\n            }\n            /* If price of node can be decreased further without\n             * decreasing the dual cost (even the dual cost doesn't\n             * increase), return to decrease the price further. */\n            if ((ddneg[node] <= 0) && (nxtbrk < large))\n            {  delprc = nxtbrk;\n               goto L63;\n            }\n         }\n      }\n      /*--------------------------------------------------------------*/\nL70:  /* Initialize tree data structure. */\n      for (i = 1; i <= n; i++)\n         tfstou[i] = tfstin[i] = 0;\n      for (i = 1; i <= na; i++)\n      {  tnxtin[i] = tnxtou[i] = -1;\n         if (rc[i] == 0)\n         {  tnxtou[i] = tfstou[startn[i]];\n            tfstou[startn[i]] = i;\n            tnxtin[i] = tfstin[endn[i]];\n            tfstin[endn[i]] = i;\n         }\n      }\nL90:  /* Initialize other variables. */\n      feasbl = true;\n      iter = 0;\n      nmultinode = 0;\n      num_augm = 0;\n      num_ascnt = 0;\n      num_passes = 0;\n      numnz = n;\n      numnz_new = 0;\n      svitch = false;\n      for (i = 1; i <= n; i++)\n         mark[i] = scan[i] = false;\n      nlabel = 0;\n      /* RELAX4 uses an adaptive strategy to decide whether to continue\n       * the scanning process after a multinode price change.\n       * The threshold parameter tp and ts that control this strategy\n       * are set in the next two lines. */\n      tp = 10;\n      ts = n / 15;\n      /* Initialize the queue of nodes with nonzero deficit. */\n      for (node = 1; node <= n - 1; node++)\n         nxtqueue[node] = node + 1;\n      nxtqueue[n] = 1;\n      node = lastqueue = n;\n      /*--------------------------------------------------------------*/\n      /* Start the relaxation algorithm. */\nL100: /* Code for advancing the queue of nonzero deficit nodes. */\n      prevnode = node;\n      node = nxtqueue[node];\n      defcit = dfct[node];\n      if (node == lastqueue)\n      {  numnz = numnz_new;\n         numnz_new = 0;\n         lastqueue = prevnode;\n         num_passes++;\n      }\n      /* Code for deleting a node from the queue. */\n      if (defcit == 0)\n      {  nxtnode = nxtqueue[node];\n         if (node == nxtnode)\n            return 0;\n         else\n         {  nxtqueue[prevnode] = nxtnode;\n            nxtqueue[node] = 0;\n            node = nxtnode;\n            goto L100;\n         }\n      }\n      else\n         posit = (defcit > 0);\n      iter++;\n      numnz_new++;\n      if (posit)\n      {  /* Attempt a single node iteration from node with positive\n          * deficit. */\n         pchange = false;\n         indef = defcit;\n         delx = 0;\n         nb = 0;\n         /* Check outgoing (probably) balanced arcs from node. */\n         for (arc = tfstou[node]; arc > 0; arc = tnxtou[arc])\n         {  if ((rc[arc] == 0) && (x[arc] > 0))\n            {  delx += x[arc];\n               nb++;\n               save[nb] = arc;\n            }\n         }\n         /* Check incoming arcs. */\n         for (arc = tfstin[node]; arc > 0; arc = tnxtin[arc])\n         {  if ((rc[arc] == 0) && (u[arc] > 0))\n            {  delx += u[arc];\n               nb++;\n               save[nb] = -arc;\n            }\n         }\n         /* End of initial node scan. */\nL4018:   /* If no price change is possible, exit. */\n         if (delx > defcit)\n         {  quit = (defcit < indef);\n            goto L4016;\n         }\n         /* RELAX4 searches along the ascent direction for the best\n          * price by checking the slope of the dual cost at successive\n          * break points. First, we compute the distance to the next\n          * break point. */\n         delprc = large;\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  rdcost = rc[arc];\n            if ((rdcost < 0) && (rdcost > -delprc))\n               delprc = -rdcost;\n         }\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  rdcost = rc[arc];\n            if ((rdcost > 0) && (rdcost < delprc))\n               delprc = rdcost;\n         }\n         /* Check if problem is infeasible. */\n         if ((delx < defcit) && (delprc == large))\n         {  /* The dual cost can be decreased without bound. */\n            return 6;\n         }\n         /* Skip flow adjustment if there is no flow to modify. */\n         if (delx == 0)\n            goto L4014;\n         /* Adjust the flow on the balanced arcs incident to node to\n          * maintain complementary slackness after the price change. */\n         for (j = 1; j <= nb; j++)\n         {  arc = save[j];\n            if (arc > 0)\n            {  node2 = endn[arc];\n               t1 = x[arc];\n               dfct[node2] += t1;\n               if (nxtqueue[node2] == 0)\n               {  nxtqueue[prevnode] = node2;\n                  nxtqueue[node2] = node;\n                  prevnode = node2;\n               }\n               u[arc] += t1;\n               x[arc] = 0;\n            }\n            else\n            {  narc = -arc;\n               node2 = startn[narc];\n               t1 = u[narc];\n               dfct[node2] += t1;\n               if (nxtqueue[node2] == 0)\n               {  nxtqueue[prevnode] = node2;\n                  nxtqueue[node2] = node;\n                  prevnode = node2;\n               }\n               x[narc] += t1;\n               u[narc] = 0;\n            }\n         }\n         defcit -= delx;\nL4014:   if (delprc == large)\n         {  quit = true;\n            goto L4019;\n         }\n         /* Node corresponds to a dual ascent direction. Decrease the\n          * price of node by delprc and compute the stepsize to the next\n          * breakpoint in the dual cost. */\n         nb = 0;\n         pchange = true;\n         dp = delprc;\n         delprc = large;\n         delx = 0;\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  rdcost = rc[arc] + dp;\n            rc[arc] = rdcost;\n            if (rdcost == 0)\n            {  nb++;\n               save[nb] = arc;\n               delx += x[arc];\n            }\n            if ((rdcost < 0) && (rdcost > -delprc))\n               delprc = -rdcost;\n         }\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  rdcost = rc[arc] - dp;\n            rc[arc] = rdcost;\n            if (rdcost == 0)\n            {  nb++;\n               save[nb] = -arc;\n               delx += u[arc];\n            }\n            if ((rdcost > 0) && (rdcost < delprc))\n               delprc = rdcost;\n         }\n         /* Return to check if another price change is possible. */\n         goto L4018;\nL4016:   /* Perform flow augmentation at node. */\n         for (j = 1; j <= nb; j++)\n         {  arc = save[j];\n            if (arc > 0)\n            {  /* arc is an outgoing arc from node. */\n               node2 = endn[arc];\n               t1 = dfct[node2];\n               if (t1 < 0)\n               {  /* Decrease the total deficit by decreasing flow of\n                   * arc. */\n                  quit = true;\n                  t2 = x[arc];\n                  dx = defcit;\n                  if (dx > -t1) dx = -t1;\n                  if (dx > t2) dx = t2;\n                  defcit -= dx;\n                  dfct[node2] = t1 + dx;\n                  if (nxtqueue[node2] == 0)\n                  {  nxtqueue[prevnode] = node2;\n                     nxtqueue[node2] = node;\n                     prevnode = node2;\n                  }\n                  x[arc] = t2 - dx;\n                  u[arc] += dx;\n                  if (defcit == 0)\n                     break;\n               }\n            }\n            else\n            {  /* -arc is an incoming arc to node. */\n               narc = -arc;\n               node2 = startn[narc];\n               t1 = dfct[node2];\n               if (t1 < 0)\n               {  /* Decrease the total deficit by increasing flow of\n                   * -arc. */\n                  quit = true;\n                  t2 = u[narc];\n                  dx = defcit;\n                  if (dx > -t1) dx = -t1;\n                  if (dx > t2) dx = t2;\n                  defcit -= dx;\n                  dfct[node2] = t1 + dx;\n                  if (nxtqueue[node2] == 0)\n                  {  nxtqueue[prevnode] = node2;\n                     nxtqueue[node2] = node;\n                     prevnode = node2;\n                  }\n                  x[narc] += dx;\n                  u[narc] = t2 - dx;\n                  if (defcit == 0)\n                     break;\n               }\n            }\n         }\nL4019:   dfct[node] = defcit;\n         /* Reconstruct the linked list of balance arcs incident to this\n          * node. For each adjacent node, we add any newly balanced arcs\n          * to the list, but do not bother removing formerly balanced\n          * ones (they will be removed the next time each adjacent node\n          * is scanned). */\n         if (pchange)\n         {  arc = tfstou[node];\n            tfstou[node] = 0;\n            while (arc > 0)\n            {  nxtarc = tnxtou[arc];\n               tnxtou[arc] = -1;\n               arc = nxtarc;\n            }\n            arc = tfstin[node];\n            tfstin[node] = 0;\n            while (arc > 0)\n            {  nxtarc = tnxtin[arc];\n               tnxtin[arc] = -1;\n               arc = nxtarc;\n            }\n            /* Now add the currently balanced arcs to the list for this\n             * node (which is now empty), and the appropriate adjacent\n             * ones. */\n            for (j = 1; j <= nb; j++)\n            {  arc = save[j];\n               if (arc < 0)\n                  arc = -arc;\n               if (tnxtou[arc] < 0)\n               {  tnxtou[arc] = tfstou[startn[arc]];\n                  tfstou[startn[arc]] = arc;\n               }\n               if (tnxtin[arc] < 0)\n               {  tnxtin[arc] = tfstin[endn[arc]];\n                  tfstin[endn[arc]] = arc;\n               }\n            }\n         }\n         /* End of single node iteration for positive deficit node. */\n      }\n      else\n      {  /* Attempt a single node iteration from node with negative\n          * deficit. */\n         pchange = false;\n         defcit = -defcit;\n         indef = defcit;\n         delx = 0;\n         nb = 0;\n         for (arc = tfstin[node]; arc > 0; arc = tnxtin[arc])\n         {  if ((rc[arc] == 0) && (x[arc] > 0))\n            {  delx += x[arc];\n               nb++;\n               save[nb] = arc;\n            }\n         }\n         for (arc = tfstou[node]; arc > 0; arc = tnxtou[arc])\n         {  if ((rc[arc] == 0) && (u[arc] > 0))\n            {  delx += u[arc];\n               nb++;\n               save[nb] = -arc;\n            }\n         }\nL4028:   if (delx >= defcit)\n         {  quit = (defcit < indef);\n            goto L4026;\n         }\n         /* Compute distance to next breakpoint. */\n         delprc = large;\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  rdcost = rc[arc];\n            if ((rdcost < 0) && (rdcost > -delprc))\n               delprc = -rdcost;\n         }\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  rdcost = rc[arc];\n            if ((rdcost > 0) && (rdcost < delprc))\n               delprc = rdcost;\n         }\n         /* Check if problem is infeasible. */\n         if ((delx < defcit) && (delprc == large))\n            return 7;\n         if (delx == 0)\n            goto L4024;\n         /* Flow augmentation is possible. */\n         for (j = 1; j <= nb; j++)\n         {  arc = save[j];\n            if (arc > 0)\n            {  node2 = startn[arc];\n               t1 = x[arc];\n               dfct[node2] -= t1;\n               if (nxtqueue[node2] == 0)\n               {  nxtqueue[prevnode] = node2;\n                  nxtqueue[node2] = node;\n                  prevnode = node2;\n               }\n               u[arc] += t1;\n               x[arc] = 0;\n            }\n            else\n            {  narc = -arc;\n               node2 = endn[narc];\n               t1 = u[narc];\n               dfct[node2] -= t1;\n               if (nxtqueue[node2] == 0)\n               {  nxtqueue[prevnode] = node2;\n                  nxtqueue[node2] = node;\n                  prevnode = node2;\n               }\n               x[narc] += t1;\n               u[narc] = 0;\n            }\n         }\n         defcit -= delx;\nL4024:   if (delprc == large)\n         {  quit = true;\n            goto L4029;\n         }\n         /* Price increase at node is possible. */\n         nb = 0;\n         pchange = true;\n         dp = delprc;\n         delprc = large;\n         delx = 0;\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  rdcost = rc[arc] + dp;\n            rc[arc] = rdcost;\n            if (rdcost == 0)\n            {  nb++;\n               save[nb] = arc;\n               delx += x[arc];\n            }\n            if ((rdcost < 0) && (rdcost > -delprc))\n               delprc = -rdcost;\n         }\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  rdcost = rc[arc] - dp;\n            rc[arc] = rdcost;\n            if (rdcost == 0)\n            {  nb++;\n               save[nb] = -arc;\n               delx += u[arc];\n            }\n            if ((rdcost > 0) && (rdcost < delprc))\n               delprc = rdcost;\n         }\n         goto L4028;\nL4026:   /* Perform flow augmentation at node. */\n         for (j = 1; j <= nb; j++)\n         {  arc = save[j];\n            if (arc > 0)\n            {  /* arc is an incoming arc to node. */\n               node2 = startn[arc];\n               t1 = dfct[node2];\n               if (t1 > 0)\n               {  quit = true;\n                  t2 = x[arc];\n                  dx = defcit;\n                  if (dx > t1) dx = t1;\n                  if (dx > t2) dx = t2;\n                  defcit -= dx;\n                  dfct[node2] = t1 - dx;\n                  if (nxtqueue[node2] == 0)\n                  {  nxtqueue[prevnode] = node2;\n                     nxtqueue[node2] = node;\n                     prevnode = node2;\n                  }\n                  x[arc] = t2 - dx;\n                  u[arc] += dx;\n                  if (defcit == 0)\n                     break;\n               }\n            }\n            else\n            {  /* -arc is an outgoing arc from node. */\n               narc = -arc;\n               node2 = endn[narc];\n               t1 = dfct[node2];\n               if (t1 > 0)\n               {  quit = true;\n                  t2 = u[narc];\n                  dx = defcit;\n                  if (dx > t1) dx = t1;\n                  if (dx > t2) dx = t2;\n                  defcit -= dx;\n                  dfct[node2] = t1 - dx;\n                  if (nxtqueue[node2] == 0)\n                  {  nxtqueue[prevnode] = node2;\n                     nxtqueue[node2] = node;\n                     prevnode = node2;\n                  }\n                  x[narc] += dx;\n                  u[narc] = t2 - dx;\n                  if (defcit == 0)\n                     break;\n               }\n            }\n         }\nL4029:   dfct[node] = -defcit;\n         /* Reconstruct the list of balanced arcs incident to node. */\n         if (pchange)\n         {  arc = tfstou[node];\n            tfstou[node] = 0;\n            while (arc > 0)\n            {  nxtarc = tnxtou[arc];\n               tnxtou[arc] = -1;\n               arc = nxtarc;\n            }\n            arc = tfstin[node];\n            tfstin[node] = 0;\n            while (arc > 0)\n            {  nxtarc = tnxtin[arc];\n               tnxtin[arc] = -1;\n               arc = nxtarc;\n            }\n            /* Now add the currently balanced arcs to the list for this\n             * node (which is now empty), and the appropriate adjacent\n             * ones. */\n            for (j = 1; j <= nb; j++)\n            {  arc = save[j];\n               if (arc <= 0)\n                  arc = -arc;\n               if (tnxtou[arc] < 0)\n               {  tnxtou[arc] = tfstou[startn[arc]];\n                  tfstou[startn[arc]] = arc;\n               }\n               if (tnxtin[arc] < 0)\n               {  tnxtin[arc] = tfstin[endn[arc]];\n                  tfstin[endn[arc]] = arc;\n               }\n            }\n         }\n         /* End of single node iteration for a negative deficit node. */\n      }\n      if (quit || (num_passes <= 3))\n         goto L100;\n      /* Do a multinode iteration from node. */\n      nmultinode++;\n      /* If number of nonzero deficit nodes is small, continue labeling\n       * until a flow augmentation is done. */\n      svitch = (numnz < tp);\n      /* Unmark nodes labeled earlier. */\n      for (j = 1; j <= nlabel; j++)\n      {  node2 = label[j];\n         mark[node2] = scan[node2] = false;\n      }\n      /* Initialize labeling. */\n      nlabel = 1;\n      label[1] = node;\n      mark[node] = true;\n      prdcsr[node] = 0;\n      /* Scan starting node. */\n      scan[node] = true;\n      nscan = 1;\n      dm = dfct[node];\n      delx = 0;\n      for (j = 1; j <= nb; j++)\n      {  arc = save[j];\n         if (arc > 0)\n         {  if (posit)\n               node2 = endn[arc];\n            else\n               node2 = startn[arc];\n            if (!mark[node2])\n            {  nlabel++;\n               label[nlabel] = node2;\n               prdcsr[node2] = arc;\n               mark[node2] = true;\n               delx += x[arc];\n            }\n         }\n         else\n         {  narc = -arc;\n            if (posit)\n               node2 = startn[narc];\n            else\n               node2 = endn[narc];\n            if (!mark[node2])\n            {  nlabel++;\n               label[nlabel] = node2;\n               prdcsr[node2] = arc;\n               mark[node2] = true;\n               delx += u[narc];\n            }\n         }\n      }\nL4120:/* Start scanning a labeled but unscanned node. */\n      nscan++;\n      /* Check to see if switch needs to be set to true so to continue\n       * scanning even after a price change. */\n      svitch = svitch || ((nscan > ts) && (numnz < ts));\n      /* Scanning will continue until either an overestimate of the\n       * residual capacity across the cut corresponding to the scanned\n       * set of nodes (called delx) exceeds the absolute value of the\n       * total deficit of the scanned nodes (called dm), or else an\n       * augmenting path is found. Arcs that are in the tree but are not\n       * balanced are removed as part of the scanning process. */\n      i = label[nscan];\n      scan[i] = true;\n      naugnod = 0;\n      if (posit)\n      {  /* Scanning node i in case of positive deficit. */\n         prvarc = 0;\n         arc = tfstou[i];\n         while (arc > 0)\n         {  /* arc is an outgoing arc from node. */\n            if (rc[arc] == 0)\n            {  if (x[arc] > 0)\n               {  node2 = endn[arc];\n                  if (!mark[node2])\n                  {  /* node2 is not labeled, so add node2 to the\n                        labeled set. */\n                     prdcsr[node2] = arc;\n                     if (dfct[node2] < 0)\n                     {  naugnod++;\n                        save[naugnod] = node2;\n                     }\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                     delx += x[arc];\n                  }\n               }\n               prvarc = arc;\n               arc = tnxtou[arc];\n            }\n            else\n            {  tmparc = arc;\n               arc = tnxtou[arc];\n               tnxtou[tmparc] = -1;\n               if (prvarc == 0)\n                  tfstou[i] = arc;\n               else\n                  tnxtou[prvarc] = arc;\n            }\n         }\n         prvarc = 0;\n         arc = tfstin[i];\n         while (arc > 0)\n         {  /* arc is an incoming arc into node. */\n            if (rc[arc] == 0)\n            {  if (u[arc] > 0)\n               {  node2 = startn[arc];\n                  if (!mark[node2])\n                  {  /* node2 is not labeled, so add node2 to the\n                      * labeled set. */\n                     prdcsr[node2] = -arc;\n                     if (dfct[node2] < 0)\n                     {  naugnod++;\n                        save[naugnod] = node2;\n                     }\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                     delx += u[arc];\n                  }\n               }\n               prvarc = arc;\n               arc = tnxtin[arc];\n            }\n            else\n            {  tmparc = arc;\n               arc = tnxtin[arc];\n               tnxtin[tmparc] = -1;\n               if (prvarc == 0)\n                  tfstin[i] = arc;\n               else\n                  tnxtin[prvarc] = arc;\n            }\n         }\n         /* Correct the residual capacity of the scanned node cut. */\n         arc = prdcsr[i];\n         if (arc > 0)\n            delx -= x[arc];\n         else\n            delx -= u[-arc];\n         /* End of scanning of node i for positive deficit case. */\n      }\n      else\n      {  /* Scanning node i for negative deficit case. */\n         prvarc = 0;\n         arc = tfstin[i];\n         while (arc > 0)\n         {  if (rc[arc] == 0)\n            {  if (x[arc] > 0)\n               {  node2 = startn[arc];\n                  if (!mark[node2])\n                  {  prdcsr[node2] = arc;\n                     if (dfct[node2] > 0)\n                     {  naugnod++;\n                        save[naugnod] = node2;\n                     }\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                     delx += x[arc];\n                  }\n               }\n               prvarc = arc;\n               arc = tnxtin[arc];\n            }\n            else\n            {  tmparc = arc;\n               arc = tnxtin[arc];\n               tnxtin[tmparc] = -1;\n               if (prvarc == 0)\n                  tfstin[i] = arc;\n               else\n                  tnxtin[prvarc] = arc;\n            }\n         }\n         prvarc = 0;\n         arc = tfstou[i];\n         while (arc > 0)\n         {  if (rc[arc] == 0)\n            {  if (u[arc] > 0)\n               {  node2 = endn[arc];\n                  if (!mark[node2])\n                  {  prdcsr[node2] = -arc;\n                     if (dfct[node2] > 0)\n                     {  naugnod++;\n                        save[naugnod] = node2;\n                     }\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                     delx += u[arc];\n                  }\n               }\n               prvarc = arc;\n               arc = tnxtou[arc];\n            }\n            else\n            {  tmparc = arc;\n               arc = tnxtou[arc];\n               tnxtou[tmparc] = -1;\n               if (prvarc == 0)\n                  tfstou[i] = arc;\n               else\n                  tnxtou[prvarc] = arc;\n            }\n         }\n         arc = prdcsr[i];\n         if (arc > 0)\n            delx -= x[arc];\n         else\n            delx -= u[-arc];\n      }\n      /* Add deficit of node scanned to dm. */\n      dm += dfct[i];\n      /* Check if the set of scanned nodes correspond to a dual ascent\n       * direction; if yes, perform a price adjustment step, otherwise\n       * continue labeling. */\n      if (nscan < nlabel)\n      {  if (svitch)\n            goto L4210;\n         if ((delx >= dm) && (delx >= -dm))\n            goto L4210;\n      }\n      /* Try a price change.\n       * [Note that since delx - abs(dm) is an overestimate of ascent\n       * slope, we may occasionally try a direction that is not an\n       * ascent direction. In this case the ascnt routines return with\n       * quit = false, so we continue labeling nodes.] */\n      if (posit)\n      {  ascnt1(csa, dm, &delx, &nlabel, &feasbl, &svitch, nscan, node,\n            &prevnode);\n         num_ascnt++;\n      }\n      else\n      {  ascnt2(csa, dm, &delx, &nlabel, &feasbl, &svitch, nscan, node,\n            &prevnode);\n         num_ascnt++;\n      }\n      if (!feasbl)\n         return 8;\n      if (!svitch)\n         goto L100;\n      /* Store those newly labeled nodes to which flow augmentation is\n       * possible. */\n      naugnod = 0;\n      for (j = nscan + 1; j <= nlabel; j++)\n      {  node2 = label[j];\n         if (posit && (dfct[node2] < 0))\n         {  naugnod++;\n            save[naugnod] = node2;\n         }\n         else if ((!posit) && (dfct[node2] > 0))\n         {  naugnod++;\n            save[naugnod] = node2;\n         }\n      }\nL4210:/* Check if flow augmentation is possible. If not, return to scan\n       * another node. */\n      if (naugnod == 0)\n         goto L4120;\n      for (j = 1; j <= naugnod; j++)\n      {  num_augm++;\n         augnod = save[j];\n         if (posit)\n         {  /* Do the augmentation from node with positive deficit. */\n            dx = -dfct[augnod];\n            ib = augnod;\n            while (ib != node)\n            {  arc = prdcsr[ib];\n               if (arc > 0)\n               {  if (dx > x[arc]) dx = x[arc];\n                  ib = startn[arc];\n               }\n               else\n               {  if (dx > u[-arc]) dx = u[-arc];\n                  ib = endn[-arc];\n               }\n            }\n            if (dx > dfct[node]) dx = dfct[node];\n            if (dx > 0)\n            {  /* Increase (decrease) the flow of all forward (backward)\n                * arcs in the flow augmenting path. Adjust node deficit\n                * accordingly. */\n               if (nxtqueue[augnod] == 0)\n               {  nxtqueue[prevnode] = augnod;\n                  nxtqueue[augnod] = node;\n                  prevnode = augnod;\n               }\n               dfct[augnod] += dx;\n               dfct[node] -= dx;\n               ib = augnod;\n               while (ib != node)\n               {  arc = prdcsr[ib];\n                  if (arc > 0)\n                  {  x[arc] -= dx;\n                     u[arc] += dx;\n                     ib = startn[arc];\n                  }\n                  else\n                  {  narc = -arc;\n                     x[narc] += dx;\n                     u[narc] -= dx;\n                     ib = endn[narc];\n                  }\n               }\n            }\n         }\n         else\n         {  /* Do the augmentation from node with negative deficit. */\n            dx = dfct[augnod];\n            ib = augnod;\n            while (ib != node)\n            {  arc = prdcsr[ib];\n               if (arc > 0)\n               {  if (dx > x[arc]) dx = x[arc];\n                  ib = endn[arc];\n               }\n               else\n               {  if (dx > u[-arc]) dx = u[-arc];\n                  ib = startn[-arc];\n               }\n            }\n            if (dx > -dfct[node]) dx = -dfct[node];\n            if (dx > 0)\n            {  /* Update the flow and deficits. */\n               if (nxtqueue[augnod] == 0)\n               {  nxtqueue[prevnode] = augnod;\n                  nxtqueue[augnod] = node;\n                  prevnode = augnod;\n               }\n               dfct[augnod] -= dx;\n               dfct[node] += dx;\n               ib = augnod;\n               while (ib != node)\n               {  arc = prdcsr[ib];\n                  if (arc > 0)\n                  {  x[arc] -= dx;\n                     u[arc] += dx;\n                     ib = endn[arc];\n                  }\n                  else\n                  {  narc = -arc;\n                     x[narc] += dx;\n                     u[narc] -= dx;\n                     ib = startn[narc];\n                  }\n               }\n            }\n         }\n         if (dfct[node] == 0)\n            goto L100;\n         if (dfct[augnod] != 0)\n            svitch = false;\n      }\n      /* If node still has nonzero deficit and all newly labeled nodes\n       * have same sign for their deficit as node, we can continue\n       * labeling. In this case, continue labeling only when flow\n       * augmentation is done relatively infrequently. */\n      if (svitch && (iter > 8 * num_augm))\n         goto L4120;\n      /* Return to do another relaxation iteration. */\n      goto L100;\n#     undef nmultinode\n#     undef iter\n#     undef num_augm\n#     undef num_ascnt\n#     undef nsp\n}",
      "lines": 1188,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "relax4_inidat": {
      "start_point": [
        1460,
        0
      ],
      "end_point": [
        1496,
        1
      ],
      "content": "void relax4_inidat(struct relax4_csa *csa)\n{     /* input parameters */\n      int n = csa->n;\n      int na = csa->na;\n      int *startn = csa->startn;\n      int *endn = csa->endn;\n      /* output parameters */\n      int *fou = csa->fou;\n      int *nxtou = csa->nxtou;\n      int *fin = csa->fin;\n      int *nxtin = csa->nxtin;\n      /* working parameters */\n      int *tempin = csa->label;\n      int *tempou = csa->prdcsr;\n      /* local variables */\n      int i, i1, i2;\n      for (i = 1; i <= n; i++)\n      {  fin[i] = fou[i] = 0;\n         tempin[i] = tempou[i] = 0;\n      }\n      for (i = 1; i <= na; i++)\n      {  nxtin[i] = nxtou[i] = 0;\n         i1 = startn[i];\n         i2 = endn[i];\n         if (fou[i1] != 0)\n            nxtou[tempou[i1]] = i;\n         else\n            fou[i1] = i;\n         tempou[i1] = i;\n         if (fin[i2] != 0)\n            nxtin[tempin[i2]] = i;\n         else\n            fin[i2] = i;\n         tempin[i2] = i;\n      }\n      return;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ascnt1": {
      "start_point": [
        1567,
        0
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "static void ascnt1(struct relax4_csa *csa, int dm, int *delx,\n      int *nlabel, int *feasbl, int *svitch, int nscan, int curnode,\n      int *prevnode)\n{     /* input parameters */\n      int n = csa->n;\n      /* int na = csa->na; */\n      int large = csa->large;\n      int *startn = csa->startn;\n      int *endn = csa->endn;\n      int *fou = csa->fou;\n      int *nxtou = csa->nxtou;\n      int *fin = csa->fin;\n      int *nxtin = csa->nxtin;\n      /* updated parameters */\n#     define delx (*delx)\n#     define nlabel (*nlabel)\n#     define feasbl (*feasbl)\n#     define svitch (*svitch)\n#     define prevnode (*prevnode)\n      int *rc = csa->rc;\n      int *u = csa->u;\n      int *x = csa->x;\n      int *dfct = csa->dfct;\n      int *label = csa->label;\n      int *prdcsr = csa->prdcsr;\n      int *tfstou = csa->tfstou;\n      int *tnxtou = csa->tnxtou;\n      int *tfstin = csa->tfstin;\n      int *tnxtin = csa->tnxtin;\n      int *nxtqueue = csa->nxtqueue;\n      char *scan = csa->scan;\n      char *mark = csa->mark;\n      int *save = csa->save;\n      /* local variables */\n      int arc, delprc, dlx, i, j, nb, node, node2, nsave, rdcost, t1,\n         t2, t3;\n      /* Store the arcs between the set of scanned nodes and its\n       * complement in save and compute delprc, the stepsize to the next\n       * breakpoint in the dual cost in the direction of decreasing\n       * prices of the scanned nodes.\n       * [The arcs are stored into save by looking at the arcs incident\n       * to either the set of scanned nodes or its complement, depending\n       * on whether nscan > n/2 or not. This improves the efficiency of\n       * storing.] */\n      delprc = large;\n      dlx = 0;\n      nsave = 0;\n      if (nscan <= n / 2)\n      {  for (i = 1; i <= nscan; i++)\n         {  node = label[i];\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  /* arc points from scanned node to an unscanned node. */\n               node2 = endn[arc];\n               if (!scan[node2])\n               {  nsave++;\n                  save[nsave] = arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node2] != arc))\n                     dlx += x[arc];\n                  if ((rdcost < 0) && (rdcost > -delprc))\n                     delprc = -rdcost;\n               }\n            }\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  /* arc points from unscanned node to scanned node. */\n               node2 = startn[arc];\n               if (!scan[node2])\n               {  nsave++;\n                  save[nsave] = -arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node2] != -arc))\n                     dlx += u[arc];\n                  if ((rdcost > 0) && (rdcost < delprc))\n                     delprc = rdcost;\n               }\n            }\n         }\n      }\n      else\n      {  for (node = 1; node <= n; node++)\n         {  if (scan[node])\n               continue;\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  node2 = startn[arc];\n               if (scan[node2])\n               {  nsave++;\n                  save[nsave] = arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node] != arc))\n                     dlx += x[arc];\n                  if ((rdcost < 0) && (rdcost > -delprc))\n                     delprc = -rdcost;\n               }\n            }\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  node2 = endn[arc];\n               if (scan[node2])\n               {  nsave++;\n                  save[nsave] = -arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node] != -arc))\n                     dlx += u[arc];\n                  if ((rdcost > 0) && (rdcost < delprc))\n                     delprc = rdcost;\n               }\n            }\n         }\n      }\n      /* Check if the set of scanned nodes truly corresponds to a dual\n       * ascent direction. [Here delx + dlx is the exact sum of the flow\n       * on arcs from the scanned set to the unscanned set plus the\n       * (capacity - flow) on arcs from the unscanned set to the scanned\n       * set.] If this were not the case, set switch to true and exit\n       * subroutine. */\n      if ((!svitch) && (delx + dlx >= dm))\n      {  svitch = true;\n         return;\n      }\n      delx += dlx;\nL4:   /* Check that the problem is feasible. */\n      if (delprc == large)\n      {  /* We can increase the dual cost without bound, so the primal\n          * problem is infeasible. */\n         feasbl = false;\n         return;\n      }\n      /* Decrease the prices of the scanned nodes, add more nodes to\n       * the labeled set and check if a newly labeled node has negative\n       * deficit. */\n      if (svitch)\n      {  for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  rc[arc] += delprc;\n               if (rc[arc] == 0)\n               {  node2 = endn[arc];\n                  if (tnxtou[arc] < 0)\n                  {  tnxtou[arc] = tfstou[startn[arc]];\n                     tfstou[startn[arc]] = arc;\n                  }\n                  if (tnxtin[arc] < 0)\n                  {  tnxtin[arc] = tfstin[node2];\n                     tfstin[node2] = arc;\n                  }\n                  if (!mark[node2])\n                  {  prdcsr[node2] = arc;\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                  }\n               }\n            }\n            else\n            {  arc = -arc;\n               rc[arc] -= delprc;\n               if (rc[arc] == 0)\n               {  node2 = startn[arc];\n                  if (tnxtou[arc] < 0)\n                  {  tnxtou[arc] = tfstou[node2];\n                     tfstou[node2] = arc;\n                  }\n                  if (tnxtin[arc] < 0)\n                  {  tnxtin[arc] = tfstin[endn[arc]];\n                     tfstin[endn[arc]] = arc;\n                  }\n                  if (!mark[node2])\n                  {  prdcsr[node2] = -arc;\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                  }\n               }\n            }\n         }\n         return;\n      }\n      else\n      {  /* Decrease the prices of the scanned nodes by delprc. Adjust\n          * flow to maintain complementary slackness with the prices. */\n         nb = 0;\n         for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  t1 = rc[arc];\n               if (t1 == 0)\n               {  t2 = x[arc];\n                  t3 = startn[arc];\n                  dfct[t3] -= t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  t3 = endn[arc];\n                  dfct[t3] += t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  u[arc] += t2;\n                  x[arc] = 0;\n               }\n               rc[arc] = t1 + delprc;\n#if 0 /* by mao; 26/IV-2013 */\n               if (rc[arc] == 0)\n#else\n               if (rc[arc] == 0 && nb < n)\n#endif\n               {  delx += x[arc];\n                  nb++;\n                  prdcsr[nb] = arc;\n               }\n            }\n            else\n            {  arc = -arc;\n               t1 = rc[arc];\n               if (t1 == 0)\n               {  t2 = u[arc];\n                  t3 = startn[arc];\n                  dfct[t3] += t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  t3 = endn[arc];\n                  dfct[t3] -= t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  x[arc] += t2;\n                  u[arc] = 0;\n               }\n               rc[arc] = t1 - delprc;\n#if 0 /* by mao; 26/IV-2013 */\n               if (rc[arc] == 0)\n#else\n               if (rc[arc] == 0 && nb < n)\n#endif\n               {  delx += u[arc];\n                  nb++;\n                  prdcsr[nb] = arc;\n               }\n            }\n         }\n      }\n      if (delx <= dm)\n      {  /* The set of scanned nodes still corresponds to a dual\n          * (possibly degenerate) ascent direction. Compute the stepsize\n          * delprc to the next breakpoint in the dual cost. */\n         delprc = large;\n         for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  rdcost = rc[arc];\n               if ((rdcost < 0) && (rdcost > -delprc))\n                  delprc = -rdcost;\n            }\n            else\n            {  arc = -arc;\n               rdcost = rc[arc];\n               if ((rdcost > 0) && (rdcost < delprc))\n                  delprc = rdcost;\n            }\n         }\n         if ((delprc != large) || (delx < dm))\n            goto L4;\n      }\n      /* Add new balanced arcs to the superset of balanced arcs. */\n      for (i = 1; i <= nb; i++)\n      {  arc = prdcsr[i];\n         if (tnxtin[arc] == -1)\n         {  j = endn[arc];\n            tnxtin[arc] = tfstin[j];\n            tfstin[j] = arc;\n         }\n         if (tnxtou[arc] == -1)\n         {  j = startn[arc];\n            tnxtou[arc] = tfstou[j];\n            tfstou[j] = arc;\n         }\n      }\n      return;\n#     undef delx\n#     undef nlabel\n#     undef feasbl\n#     undef svitch\n#     undef prevnode\n}",
      "lines": 292,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ascnt2": {
      "start_point": [
        1870,
        0
      ],
      "end_point": [
        2142,
        1
      ],
      "content": "static void ascnt2(struct relax4_csa *csa, int dm, int *delx,\n      int *nlabel, int *feasbl, int *svitch, int nscan, int curnode,\n      int *prevnode)\n{     /* input parameters */\n      int n = csa->n;\n      /* int na = csa->na; */\n      int large = csa->large;\n      int *startn = csa->startn;\n      int *endn = csa->endn;\n      int *fou = csa->fou;\n      int *nxtou = csa->nxtou;\n      int *fin = csa->fin;\n      int *nxtin = csa->nxtin;\n      /* updated parameters */\n#     define delx (*delx)\n#     define nlabel (*nlabel)\n#     define feasbl (*feasbl)\n#     define svitch (*svitch)\n#     define prevnode (*prevnode)\n      int *rc = csa->rc;\n      int *u = csa->u;\n      int *x = csa->x;\n      int *dfct = csa->dfct;\n      int *label = csa->label;\n      int *prdcsr = csa->prdcsr;\n      int *tfstou = csa->tfstou;\n      int *tnxtou = csa->tnxtou;\n      int *tfstin = csa->tfstin;\n      int *tnxtin = csa->tnxtin;\n      int *nxtqueue = csa->nxtqueue;\n      char *scan = csa->scan;\n      char *mark = csa->mark;\n      int *save = csa->save;\n      /* local variables */\n      int arc, delprc, dlx, i, j, nb, node, node2, nsave, rdcost, t1,\n         t2, t3;\n      /* Store the arcs between the set of scanned nodes and its\n       * complement in save and compute delprc, the stepsize to the next\n       * breakpoint in the dual cost in the direction of increasing\n       * prices of the scanned nodes. */\n      delprc = large;\n      dlx = 0;\n      nsave = 0;\n      if (nscan <= n / 2)\n      {  for (i = 1; i <= nscan; i++)\n         {  node = label[i];\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  node2 = startn[arc];\n               if (!scan[node2])\n               {  nsave++;\n                  save[nsave] = arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node2] != arc))\n                     dlx += x[arc];\n                  if ((rdcost < 0) && (rdcost > -delprc))\n                     delprc = -rdcost;\n               }\n            }\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  node2 = endn[arc];\n               if (!scan[node2])\n               {  nsave++;\n                  save[nsave] = -arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node2] != -arc))\n                     dlx += u[arc];\n                  if ((rdcost > 0) && (rdcost < delprc))\n                     delprc = rdcost;\n               }\n            }\n         }\n      }\n      else\n      {  for (node = 1; node <= n; node++)\n         {  if (scan[node])\n               continue;\n            for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n            {  node2 = endn[arc];\n               if (scan[node2])\n               {  nsave++;\n                  save[nsave] = arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node] != arc))\n                     dlx += x[arc];\n                  if ((rdcost < 0) && (rdcost > -delprc))\n                     delprc = -rdcost;\n               }\n            }\n            for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n            {  node2 = startn[arc];\n               if (scan[node2])\n               {  nsave++;\n                  save[nsave] = -arc;\n                  rdcost = rc[arc];\n                  if ((rdcost == 0) && (prdcsr[node] != -arc))\n                     dlx += u[arc];\n                  if ((rdcost > 0) && (rdcost < delprc))\n                     delprc = rdcost;\n               }\n            }\n         }\n      }\n      if ((!svitch) && (delx + dlx >= -dm))\n      {  svitch = true;\n         return;\n      }\n      delx += dlx;\n      /* Check that the problem is feasible. */\nL4:   if (delprc == large)\n      {  feasbl = false;\n         return;\n      }\n      /* Increase the prices of the scanned nodes, add more nodes to\n       * the labeled set and check if a newly labeled node has positive\n       * deficit. */\n      if (svitch)\n      {  for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  rc[arc] += delprc;\n               if (rc[arc] == 0)\n               {  node2 = startn[arc];\n                  if (tnxtou[arc] < 0)\n                  {  tnxtou[arc] = tfstou[node2];\n                     tfstou[node2] = arc;\n                  }\n                  if (tnxtin[arc] < 0)\n                  {  tnxtin[arc] = tfstin[endn[arc]];\n                     tfstin[endn[arc]] = arc;\n                  }\n                  if (!mark[node2])\n                  {  prdcsr[node2] = arc;\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                  }\n               }\n            }\n            else\n            {  arc = -arc;\n               rc[arc] -= delprc;\n               if (rc[arc] == 0)\n               {  node2 = endn[arc];\n                  if (tnxtou[arc] < 0)\n                  {  tnxtou[arc] = tfstou[startn[arc]];\n                     tfstou[startn[arc]] = arc;\n                  }\n                  if (tnxtin[arc] < 0)\n                  {  tnxtin[arc] = tfstin[node2];\n                     tfstin[node2] = arc;\n                  }\n                  if (!mark[node2])\n                  {  prdcsr[node2] = -arc;\n                     nlabel++;\n                     label[nlabel] = node2;\n                     mark[node2] = true;\n                  }\n               }\n            }\n         }\n         return;\n      }\n      else\n      {  nb = 0;\n         for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  t1 = rc[arc];\n               if (t1 == 0)\n               {  t2 = x[arc];\n                  t3 = startn[arc];\n                  dfct[t3] -= t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  t3 = endn[arc];\n                  dfct[t3] += t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  u[arc] += t2;\n                  x[arc] = 0;\n               }\n               rc[arc] = t1 + delprc;\n#if 0 /* by mao; 26/IV-2013 */\n               if (rc[arc] == 0)\n#else\n               if (rc[arc] == 0 && nb < n)\n#endif\n               {  delx += x[arc];\n                  nb++;\n                  prdcsr[nb] = arc;\n               }\n            }\n            else\n            {  arc = -arc;\n               t1 = rc[arc];\n               if (t1 == 0)\n               {  t2 = u[arc];\n                  t3 = startn[arc];\n                  dfct[t3] += t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  t3 = endn[arc];\n                  dfct[t3] -= t2;\n                  if (nxtqueue[t3] == 0)\n                  {  nxtqueue[prevnode] = t3;\n                     nxtqueue[t3] = curnode;\n                     prevnode = t3;\n                  }\n                  x[arc] += t2;\n                  u[arc] = 0;\n               }\n               rc[arc] = t1 - delprc;\n#if 0 /* by mao; 26/IV-2013 */\n               if (rc[arc] == 0)\n#else\n               if (rc[arc] == 0 && nb < n)\n#endif\n               {  delx += u[arc];\n                  nb++;\n                  prdcsr[nb] = arc;\n               }\n            }\n         }\n      }\n      if (delx <= -dm)\n      {  delprc = large;\n         for (i = 1; i <= nsave; i++)\n         {  arc = save[i];\n            if (arc > 0)\n            {  rdcost = rc[arc];\n               if ((rdcost < 0) && (rdcost > -delprc))\n                  delprc = -rdcost;\n            }\n            else\n            {  arc = -arc;\n               rdcost = rc[arc];\n               if ((rdcost > 0) && (rdcost < delprc))\n                  delprc = rdcost;\n            }\n         }\n         if ((delprc != large) || (delx < -dm))\n            goto L4;\n      }\n      /* Add new balanced arcs to the superset of balanced arcs. */\n      for (i = 1; i <= nb; i++)\n      {  arc = prdcsr[i];\n         if (tnxtin[arc] == -1)\n         {  j = endn[arc];\n            tnxtin[arc] = tfstin[j];\n            tfstin[j] = arc;\n         }\n         if (tnxtou[arc] == -1)\n         {  j = startn[arc];\n            tnxtou[arc] = tfstou[j];\n            tfstou[j] = arc;\n         }\n      }\n      return;\n#     undef delx\n#     undef nlabel\n#     undef feasbl\n#     undef svitch\n#     undef prevnode\n}",
      "lines": 273,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "auction": {
      "start_point": [
        2191,
        0
      ],
      "end_point": [
        2847,
        1
      ],
      "content": "static int auction(struct relax4_csa *csa)\n{     /* input parameters */\n      int n = csa->n;\n      int na = csa->na;\n      int large = csa->large;\n      int *startn = csa->startn;\n      int *endn = csa->endn;\n      int *fou = csa->fou;\n      int *nxtou = csa->nxtou;\n      int *fin = csa->fin;\n      int *nxtin = csa->nxtin;\n      /* updated parameters */\n#     define crash (csa->crash)\n      int *rc = csa->rc;\n      int *u = csa->u;\n      int *x = csa->x;\n      int *dfct = csa->dfct;\n      /* output parameters */\n#     define nsp (csa->nsp)\n      /* working parameters */\n      int *p = csa->label;\n      int *prdcsr = csa->prdcsr;\n      int *save = csa->save;\n      int *fpushf = csa->tfstou;\n      int *nxtpushf = csa->tnxtou;\n      int *fpushb = csa->tfstin;\n      int *nxtpushb = csa->tnxtin;\n      int *nxtqueue = csa->nxtqueue;\n      int *extend_arc = csa->extend_arc;\n      int *sb_level = csa->sb_level;\n      int *sb_arc = csa->sb_arc;\n      char *path_id = csa->mark;\n      /* local variables */\n      int arc, bstlevel, end, eps, extarc, factor, flow, i, incr,\n         last, lastqueue, maxcost, mincost, nas, naug, new_level, node,\n         nolist, num_passes, nxtnode, pass, pend, pr_term, prd,\n         prevarc, prevlevel, prevnode, pstart, pterm, rdcost, red_cost,\n         resid, root, secarc, seclevel, start, term, thresh_dfct;\n      /* start initialization using auction */\n      naug = 0;\n      pass = 0;\n      thresh_dfct = 0;\n      /* factor determines by how much epsilon is reduced at each\n       * minimization */\n      factor = 3;\n      /* num_passes determines how many auction scaling phases are\n       * performed */\n      num_passes = 1;\n      /* set arc flows to satisfy cs and calculate maxcost and\n       * mincost */\n      maxcost = -large;\n      mincost = large;\n      for (arc = 1; arc <= na; arc++)\n      {  start = startn[arc];\n         end = endn[arc];\n         rdcost = rc[arc];\n         if (maxcost < rdcost)\n            maxcost = rdcost;\n         if (mincost > rdcost)\n            mincost = rdcost;\n         if (rdcost < 0)\n         {  dfct[start] += u[arc];\n            dfct[end] -= u[arc];\n            x[arc] = u[arc];\n            u[arc] = 0;\n         }\n         else\n            x[arc] = 0;\n      }\n      /* set initial epsilon */\n      if ((maxcost - mincost) >= 8)\n         eps = (maxcost - mincost) / 8;\n      else\n         eps = 1;\n      /* set initial prices to zero */\n      for (node = 1; node <= n; node++)\n         p[node] = 0;\n      /* Initialization using auction/shortest paths. */\nL100: /* Start of the first scaling phase. */\n      pass++;\n      if ((pass == num_passes) || (eps == 1))\n         crash = 0;\n      nolist = 0;\n      /* construct list of positive surplus nodes and queue of negative\n       * surplus nodes */\n      for (node = 1; node <= n; node++)\n      {  prdcsr[node] = 0;\n         path_id[node] = false;\n         extend_arc[node] = 0;\n         sb_level[node] = -large;\n         nxtqueue[node] = node + 1;\n         if (dfct[node] > 0)\n         {  nolist++;\n            save[nolist] = node;\n         }\n      }\n      nxtqueue[n] = 1;\n      root = 1;\n      prevnode = lastqueue = n;\n      /* initialization with down iterations for negative surplus\n       * nodes */\n      for (i = 1; i <= nolist; i++)\n      {  node = save[i];\n         nsp++;\n         /* build the list of arcs w/ room for pushing flow and find\n          * proper price for down iteration */\n         bstlevel = -large;\n         fpushf[node] = 0;\n         for (arc = fou[node]; arc > 0; arc = nxtou[arc])\n         {  if (u[arc] > 0)\n            {  if (fpushf[node] == 0)\n               {  fpushf[node] = arc;\n                  nxtpushf[arc] = 0;\n                  last = arc;\n               }\n               else\n               {  nxtpushf[last] = arc;\n                  nxtpushf[arc] = 0;\n                  last = arc;\n               }\n            }\n            if (x[arc] > 0)\n            {  new_level = p[endn[arc]] + rc[arc];\n               if (new_level > bstlevel)\n               {  bstlevel = new_level;\n                  extarc = arc;\n               }\n            }\n         }\n         fpushb[node] = 0;\n         for (arc = fin[node]; arc > 0; arc = nxtin[arc])\n         {  if (x[arc] > 0)\n            {  if (fpushb[node] == 0)\n               {  fpushb[node] = arc;\n                  nxtpushb[arc] = 0;\n                  last = arc;\n               }\n               else\n               {  nxtpushb[last] = arc;\n                  nxtpushb[arc] = 0;\n                  last = arc;\n               }\n            }\n            if (u[arc] > 0)\n            {  new_level = p[startn[arc]] - rc[arc];\n               if (new_level > bstlevel)\n               {  bstlevel = new_level;\n                  extarc = -arc;\n               }\n            }\n         }\n         extend_arc[node] = extarc;\n         p[node] = bstlevel - eps;\n      }\nL200: /* Start the augmentation cycles of the new scaling phase. */\n      if (dfct[root] >= thresh_dfct)\n         goto L3000;\n      term = root;\n      path_id[root] = true;\nL500: /* Main forward algorithm with root as origin. */\n      /* start of a new forward iteration */\n      pterm = p[term];\n      extarc = extend_arc[term];\n      if (extarc == 0)\n      {  /* build the list of arcs w/ room for pushing flow */\n         fpushf[term] = 0;\n         for (arc = fou[term]; arc > 0; arc = nxtou[arc])\n         {  if (u[arc] > 0)\n            {  if (fpushf[term] == 0)\n               {  fpushf[term] = arc;\n                  nxtpushf[arc] = 0;\n                  last = arc;\n               }\n               else\n               {  nxtpushf[last] = arc;\n                  nxtpushf[arc] = 0;\n                  last = arc;\n               }\n            }\n         }\n         fpushb[term] = 0;\n         for (arc = fin[term]; arc > 0; arc = nxtin[arc])\n         {  if (x[arc] > 0)\n            {  if (fpushb[term] == 0)\n               {  fpushb[term] = arc;\n                  nxtpushb[arc] = 0;\n                  last = arc;\n               }\n               else\n               {  nxtpushb[last] = arc;\n                  nxtpushb[arc] = 0;\n                  last = arc;\n               }\n            }\n         }\n         goto L600;\n      }\n      /* speculative path extension attempt */\n      /* note: arc > 0 means that arc is oriented from the root to the\n       * destinations\n       * arc < 0 means that arc is oriented from the destinations to the\n       * root\n       * extarc = 0 or prdarc = 0, means the extension arc or the\n       * predecessor arc, respectively, has not been established */\n      if (extarc > 0)\n      {  if (u[extarc] == 0)\n         {  seclevel = sb_level[term];\n            goto L580;\n         }\n         end = endn[extarc];\n         bstlevel = p[end] + rc[extarc];\n         if (pterm >= bstlevel)\n         {  if (path_id[end])\n               goto L1200;\n            term = end;\n            prdcsr[term] = extarc;\n            path_id[term] = true;\n            /* if negative surplus node is found, do an augmentation */\n            if (dfct[term] > 0)\n               goto L2000;\n            /* return for another iteration */\n            goto L500;\n         }\n      }\n      else\n      {  extarc = -extarc;\n         if (x[extarc] == 0)\n         {  seclevel = sb_level[term];\n            goto L580;\n         }\n         start = startn[extarc];\n         bstlevel = p[start] - rc[extarc];\n         if (pterm >= bstlevel)\n         {  if (path_id[start])\n               goto L1200;\n            term = start;\n            prdcsr[term] = -extarc;\n            path_id[term] = true;\n            /* if negative surplus node is found, do an augmentation */\n            if (dfct[term] > 0)\n               goto L2000;\n            /* return for another iteration */\n            goto L500;\n         }\n      }\nL550: /* second best logic test applied to save a full node scan\n       * if old best level continues to be best go for another\n       * contraction */\n      seclevel = sb_level[term];\n      if (bstlevel <= seclevel)\n         goto L800;\nL580: /* if second best can be used do either a contraction or start\n       * over with a speculative extension */\n      if (seclevel > -large)\n      {  extarc = sb_arc[term];\n         if (extarc > 0)\n         {  if (u[extarc] == 0)\n               goto L600;\n            bstlevel = p[endn[extarc]] + rc[extarc];\n         }\n         else\n         {  if (x[-extarc] == 0)\n               goto L600;\n            bstlevel = p[startn[-extarc]] - rc[-extarc];\n         }\n         if (bstlevel == seclevel)\n         {  sb_level[term] = -large;\n            extend_arc[term] = extarc;\n            goto L800;\n         }\n      }\nL600: /* extension/contraction attempt was unsuccessful, so scan\n       * terminal node */\n      nsp++;\n      bstlevel = seclevel = large;\n      for (arc = fpushf[term]; arc > 0; arc = nxtpushf[arc])\n      {  new_level = p[endn[arc]] + rc[arc];\n         if (new_level < seclevel)\n         {  if (new_level < bstlevel)\n            {  seclevel = bstlevel;\n               bstlevel = new_level;\n               secarc = extarc;\n               extarc = arc;\n            }\n            else\n            {  seclevel = new_level;\n               secarc = arc;\n            }\n         }\n      }\n      for (arc = fpushb[term]; arc > 0; arc = nxtpushb[arc])\n      {  new_level = p[startn[arc]] - rc[arc];\n         if (new_level < seclevel)\n         {  if (new_level < bstlevel)\n            {  seclevel = bstlevel;\n               bstlevel = new_level;\n               secarc = extarc;\n               extarc = -arc;\n            }\n            else\n            {  seclevel = new_level;\n               secarc = -arc;\n            }\n         }\n      }\n      sb_level[term] = seclevel;\n      sb_arc[term] = secarc;\n      extend_arc[term] = extarc;\nL800: /* End of node scan. */\n      /* if the terminal node is the root, adjust its price and change\n       * root */\n      if (term == root)\n      {  p[term] = bstlevel + eps;\n         if (p[term] >= large)\n         {  /* no path to the destination */\n            /* problem is found to be infeasible */\n            return 1;\n         }\n         path_id[root] = false;\n         prevnode = root;\n         root = nxtqueue[root];\n         goto L200;\n      }\n      /* check whether extension or contraction */\n      prd = prdcsr[term];\n      if (prd > 0)\n      {  pr_term = startn[prd];\n         prevlevel = p[pr_term] - rc[prd];\n      }\n      else\n      {  pr_term = endn[-prd];\n         prevlevel = p[pr_term] + rc[-prd];\n      }\n      if (prevlevel > bstlevel)\n      {  /* path extension */\n         if (prevlevel >= bstlevel + eps)\n            p[term] = bstlevel + eps;\n         else\n            p[term] = prevlevel;\n         if (extarc > 0)\n         {  end = endn[extarc];\n            if (path_id[end])\n               goto L1200;\n            term = end;\n         }\n         else\n         {  start = startn[-extarc];\n            if (path_id[start])\n               goto L1200;\n            term = start;\n         }\n         prdcsr[term] = extarc;\n         path_id[term] = true;\n         /* if negative surplus node is found, do an augmentation */\n         if (dfct[term] > 0)\n            goto L2000;\n         /* return for another iteration */\n         goto L500;\n      }\n      else\n      {  /* path contraction */\n         p[term] = bstlevel + eps;\n         path_id[term] = false;\n         term = pr_term;\n         if (pr_term != root)\n         {  if (bstlevel <= pterm + eps)\n               goto L2000;\n         }\n         pterm = p[term];\n         extarc = prd;\n         if (prd > 0)\n            bstlevel += eps + rc[prd];\n         else\n            bstlevel += eps - rc[-prd];\n         /* do a second best test and if that fails, do a full node\n          * scan */\n         goto L550;\n      }\nL1200:/* A cycle is about to form; do a retreat sequence. */\n      node = term;\nL1600:if (node != root)\n      {  path_id[node] = false;\n         prd = prdcsr[node];\n         if (prd > 0)\n         {  pr_term = startn[prd];\n            if (p[pr_term] == p[node] + rc[prd] + eps)\n            {  node = pr_term;\n               goto L1600;\n            }\n         }\n         else\n         {  pr_term = endn[-prd];\n            if (p[pr_term] == p[node] - rc[-prd] + eps)\n            {  node = pr_term;\n               goto L1600;\n            }\n         }\n         /* do a full scan and price rise at pr_term */\n         nsp++;\n         bstlevel = seclevel = large;\n         for (arc = fpushf[pr_term]; arc > 0; arc = nxtpushf[arc])\n         {  new_level = p[endn[arc]] + rc[arc];\n            if (new_level < seclevel)\n            {  if (new_level < bstlevel)\n               {  seclevel = bstlevel;\n                  bstlevel = new_level;\n                  secarc = extarc;\n                  extarc = arc;\n               }\n               else\n               {  seclevel = new_level;\n                  secarc = arc;\n               }\n            }\n         }\n         for (arc = fpushb[pr_term]; arc > 0; arc = nxtpushb[arc])\n         {  new_level = p[startn[arc]] - rc[arc];\n            if (new_level < seclevel)\n            {  if (new_level < bstlevel)\n               {  seclevel = bstlevel;\n                  bstlevel = new_level;\n                  secarc = extarc;\n                  extarc = -arc;\n               }\n               else\n               {  seclevel = new_level;\n                  secarc = -arc;\n               }\n            }\n         }\n         sb_level[pr_term] = seclevel;\n         sb_arc[pr_term] = secarc;\n         extend_arc[pr_term] = extarc;\n         p[pr_term] = bstlevel + eps;\n         if (pr_term == root)\n         {  prevnode = root;\n            path_id[root] = false;\n            root = nxtqueue[root];\n            goto L200;\n         }\n         path_id[pr_term] = false;\n         prd = prdcsr[pr_term];\n         if (prd > 0)\n            term = startn[prd];\n         else\n            term = endn[-prd];\n         if (term == root)\n         {  prevnode = root;\n            path_id[root] = false;\n            root = nxtqueue[root];\n            goto L200;\n         }\n         else\n            goto L2000;\n      }\nL2000:/* End of auction/shortest path routine. */\n      /* do augmentation from root and correct the push lists */\n      incr = -dfct[root];\n      for (node = root;;)\n      {  extarc = extend_arc[node];\n         path_id[node] = false;\n         if (extarc > 0)\n         {  node = endn[extarc];\n            if (incr > u[extarc])\n               incr = u[extarc];\n         }\n         else\n         {  node = startn[-extarc];\n            if (incr > x[-extarc])\n               incr = x[-extarc];\n         }\n         if (node == term)\n            break;\n      }\n      path_id[term] = false;\n      if (dfct[term] > 0)\n      {  if (incr > dfct[term])\n            incr = dfct[term];\n      }\n      for (node = root;;)\n      {  extarc = extend_arc[node];\n         if (extarc > 0)\n         {  end = endn[extarc];\n            /* add arc to the reduced graph */\n            if (x[extarc] == 0)\n            {  nxtpushb[extarc] = fpushb[end];\n               fpushb[end] = extarc;\n               new_level = p[node] - rc[extarc];\n               if (sb_level[end] > new_level)\n               {  sb_level[end] = new_level;\n                  sb_arc[end] = -extarc;\n               }\n            }\n            x[extarc] += incr;\n            u[extarc] -= incr;\n            /* remove arc from the reduced graph */\n            if (u[extarc] == 0)\n            {  nas++;\n               arc = fpushf[node];\n               if (arc == extarc)\n                  fpushf[node] = nxtpushf[arc];\n               else\n               {  prevarc = arc;\n                  arc = nxtpushf[arc];\n                  while (arc > 0)\n                  {  if (arc == extarc)\n                     {  nxtpushf[prevarc] = nxtpushf[arc];\n                        break;\n                     }\n                     prevarc = arc;\n                     arc = nxtpushf[arc];\n                  }\n               }\n            }\n            node = end;\n         }\n         else\n         {  extarc = -extarc;\n            start = startn[extarc];\n            /* add arc to the reduced graph */\n            if (u[extarc] == 0)\n            {  nxtpushf[extarc] = fpushf[start];\n               fpushf[start] = extarc;\n               new_level = p[node] + rc[extarc];\n               if (sb_level[start] > new_level)\n               {  sb_level[start] = new_level;\n                  sb_arc[start] = extarc;\n               }\n            }\n            u[extarc] += incr;\n            x[extarc] -= incr;\n            /* remove arc from the reduced graph */\n            if (x[extarc] == 0)\n            {  nas++;\n               arc = fpushb[node];\n               if (arc == extarc)\n                  fpushb[node] = nxtpushb[arc];\n               else\n               {  prevarc = arc;\n                  arc = nxtpushb[arc];\n                  while (arc > 0)\n                  {  if (arc == extarc)\n                     {  nxtpushb[prevarc] = nxtpushb[arc];\n                        break;\n                     }\n                     prevarc = arc;\n                     arc = nxtpushb[arc];\n                  }\n               }\n            }\n            node = start;\n         }\n         if (node == term)\n            break;\n      }\n      dfct[term] -= incr;\n      dfct[root] += incr;\n      /* insert term in the queue if it has a large enough surplus */\n      if (dfct[term] < thresh_dfct)\n      {  if (nxtqueue[term] == 0)\n         {  nxtnode = nxtqueue[root];\n            if ((p[term] >= p[nxtnode]) && (root != nxtnode))\n            {  nxtqueue[root] = term;\n               nxtqueue[term] = nxtnode;\n            }\n            else\n            {  nxtqueue[prevnode] = term;\n               nxtqueue[term] = root;\n               prevnode = term;\n            }\n         }\n      }\n      /* if root has a large enough surplus, keep it in the queue and\n       * return for another iteration */\n      if (dfct[root] < thresh_dfct)\n      {  prevnode = root;\n         root = nxtqueue[root];\n         goto L200;\n      }\nL3000:/* end of augmentation cycle */\n      /* Check for termination of scaling phase. If scaling phase is not\n       * finished, advance the queue and return to take another node. */\n      nxtnode = nxtqueue[root];\n      if (root != nxtnode)\n      {  nxtqueue[root] = 0;\n         nxtqueue[prevnode] = nxtnode;\n         root = nxtnode;\n         goto L200;\n      }\n      /* End of subproblem (scaling phase). */\n      /* Reduce epsilon. */\n      eps /= factor;\n      if (eps < 1) eps = 1;\n      thresh_dfct /= factor;\n      if (eps == 1) thresh_dfct = 0;\n      /* if another auction scaling phase remains, reset the flows &\n       * the push lists; else reset arc flows to satisfy cs and compute\n       * reduced costs */\n      if (crash == 1)\n      {  for (arc = 1; arc <= na; arc++)\n         {  start = startn[arc];\n            end = endn[arc];\n            pstart = p[start];\n            pend = p[end];\n            if (pstart > pend + eps + rc[arc])\n            {  resid = u[arc];\n               if (resid > 0)\n               {  dfct[start] += resid;\n                  dfct[end] -= resid;\n                  x[arc] += resid;\n                  u[arc] = 0;\n               }\n            }\n            else if (pstart < pend - eps + rc[arc])\n            {  flow = x[arc];\n               if (flow > 0)\n               {  dfct[start] -= flow;\n                  dfct[end] += flow;\n                  x[arc] = 0;\n                  u[arc] += flow;\n               }\n            }\n         }\n         /* return for another phase */\n         goto L100;\n      }\n      else\n      {  crash = 1;\n         for (arc = 1; arc <= na; arc++)\n         {  start = startn[arc];\n            end = endn[arc];\n            red_cost = rc[arc] + p[end] - p[start];\n            if (red_cost < 0)\n            {  resid = u[arc];\n               if (resid > 0)\n               {  dfct[start] += resid;\n                  dfct[end] -= resid;\n                  x[arc] += resid;\n                  u[arc] = 0;\n               }\n            }\n            else if (red_cost > 0)\n            {  flow = x[arc];\n               if (flow > 0)\n               {  dfct[start] -= flow;\n                  dfct[end] += flow;\n                  x[arc] = 0;\n                  u[arc] += flow;\n               }\n            }\n            rc[arc] = red_cost;\n         }\n      }\n      return 0;\n#     undef crash\n#     undef nsp\n}",
      "lines": 657,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/relax4.h": {},
  "glpk/glpk-4.65/src/misc/rng.c": {
    "flip_cycle": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int flip_cycle(RNG *rand)\n{     /* this is an auxiliary routine to do 55 more steps of the basic\n       * recurrence, at high speed, and to reset fptr */\n      int *ii, *jj;\n      for (ii = &A[1], jj = &A[32]; jj <= &A[55]; ii++, jj++)\n         *ii = mod_diff(*ii, *jj);\n      for (jj = &A[1]; ii <= &A[55]; ii++, jj++)\n         *ii = mod_diff(*ii, *jj);\n      fptr = &A[54];\n      return A[55];\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rng_create_rand": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "RNG *rng_create_rand(void)\n{     RNG *rand;\n      int i;\n      rand = talloc(1, RNG);\n      A[0] = -1;\n      for (i = 1; i <= 55; i++) A[i] = 0;\n      fptr = A;\n      rng_init_rand(rand, 1);\n      return rand;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "RNG",
        "*rng_create_rand(void)",
        "*"
      ]
    },
    "rng_init_rand": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void rng_init_rand(RNG *rand, int seed)\n{     int i;\n      int prev = seed, next = 1;\n      seed = prev = mod_diff(prev, 0);\n      A[55] = prev;\n      for (i = 21; i; i = (i + 21) % 55)\n      {  A[i] = next;\n         next = mod_diff(prev, next);\n         if (seed & 1)\n            seed = 0x40000000 + (seed >> 1);\n         else\n            seed >>= 1;\n         next = mod_diff(next, seed);\n         prev = A[i];\n      }\n      flip_cycle(rand);\n      flip_cycle(rand);\n      flip_cycle(rand);\n      flip_cycle(rand);\n      flip_cycle(rand);\n      return;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rng_next_rand": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int rng_next_rand(RNG *rand)\n{     return\n         *fptr >= 0 ? *fptr-- : flip_cycle(rand);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rng_unif_rand": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "int rng_unif_rand(RNG *rand, int m)\n{     unsigned int t = two_to_the_31 - (two_to_the_31 % m);\n      int r;\n      xassert(m > 0);\n      do { r = rng_next_rand(rand); } while (t <= (unsigned int)r);\n      return r % m;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rng_delete_rand": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void rng_delete_rand(RNG *rand)\n{     tfree(rand);\n      return;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "int main(void)\n{     RNG *rand;\n      int j;\n      rand = rng_create_rand();\n      rng_init_rand(rand, -314159);\n      if (rng_next_rand(rand) != 119318998)\n      {  fprintf(stderr, \"Failure on the first try!\\n\");\n         return -1;\n      }\n      for (j = 1; j <= 133; j++) rng_next_rand(rand);\n      if (rng_unif_rand(rand, 0x55555555) != 748103812)\n      {  fprintf(stderr, \"Failure on the second try!\\n\");\n         return -2;\n      }\n      fprintf(stderr, \"OK, the random-number generator routines seem to\"\n         \" work!\\n\");\n      rng_delete_rand(rand);\n      return 0;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/rng.h": {},
  "glpk/glpk-4.65/src/misc/rng1.c": {
    "rng_unif_01": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "double rng_unif_01(RNG *rand)\n{     double x;\n      x = (double)rng_next_rand(rand) / 2147483647.0;\n      xassert(0.0 <= x && x <= 1.0);\n      return x;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "rng_uniform": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "double rng_uniform(RNG *rand, double a, double b)\n{     double x;\n      xassert(a < b);\n      x = rng_unif_01(rand);\n      x = a * (1.0 - x) + b * x;\n      xassert(a <= x && x <= b);\n      return x;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/round2n.c": {
    "round2n": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "double round2n(double x)\n{     int e;\n      double f;\n      xassert(x > 0.0);\n      f = frexp(x, &e);\n      return ldexp(1.0, f <= 0.75 ? e-1 : e);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "double"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/str2int.c": {
    "str2int": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int str2int(const char *str, int *val_)\n{     int d, k, s, val = 0;\n      /* scan optional sign */\n      if (str[0] == '+')\n         s = +1, k = 1;\n      else if (str[0] == '-')\n         s = -1, k = 1;\n      else\n         s = +1, k = 0;\n      /* check for the first digit */\n      if (!isdigit((unsigned char)str[k]))\n         return 2;\n      /* scan digits */\n      while (isdigit((unsigned char)str[k]))\n      {  d = str[k++] - '0';\n         if (s > 0)\n         {  if (val > INT_MAX / 10)\n               return 1;\n            val *= 10;\n            if (val > INT_MAX - d)\n               return 1;\n            val += d;\n         }\n         else /* s < 0 */\n         {  if (val < INT_MIN / 10)\n               return 1;\n            val *= 10;\n            if (val < INT_MIN + d)\n               return 1;\n            val -= d;\n         }\n      }\n      /* check for terminator */\n      if (str[k] != '\\0')\n         return 2;\n      /* conversion has been done */\n      *val_ = val;\n      return 0;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/str2num.c": {
    "str2num": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int str2num(const char *str, double *val_)\n{     int k;\n      double val;\n      /* scan optional sign */\n      k = (str[0] == '+' || str[0] == '-' ? 1 : 0);\n      /* check for decimal point */\n      if (str[k] == '.')\n      {  k++;\n         /* a digit should follow it */\n         if (!isdigit((unsigned char)str[k]))\n            return 2;\n         k++;\n         goto frac;\n      }\n      /* integer part should start with a digit */\n      if (!isdigit((unsigned char)str[k]))\n         return 2;\n      /* scan integer part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for decimal point */\n      if (str[k] == '.') k++;\nfrac: /* scan optional fraction part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for decimal exponent */\n      if (str[k] == 'E' || str[k] == 'e')\n      {  k++;\n         /* scan optional sign */\n         if (str[k] == '+' || str[k] == '-')\n            k++;\n         /* a digit should follow E, E+ or E- */\n         if (!isdigit((unsigned char)str[k]))\n            return 2;\n      }\n      /* scan optional exponent part */\n      while (isdigit((unsigned char)str[k]))\n         k++;\n      /* check for terminator */\n      if (str[k] != '\\0')\n         return 2;\n      /* perform conversion */\n      {  char *endptr;\n         val = strtod(str, &endptr);\n         if (*endptr != '\\0')\n            return 2;\n      }\n      /* check for overflow */\n      if (!(-DBL_MAX <= val && val <= +DBL_MAX))\n         return 1;\n      /* check for underflow */\n      if (-DBL_MIN < val && val < +DBL_MIN)\n         val = 0.0;\n      /* conversion has been done */\n      *val_ = val;\n      return 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/strspx.c": {
    "strspx": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "char *strspx(char *str)\n{     char *s, *t;\n      for (s = t = str; *s; s++)\n      {  if (*s != ' ')\n            *t++ = *s;\n      }\n      *t = '\\0';\n      return str;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "char",
        "*strspx(char *str)",
        "*"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/strtrim.c": {
    "strtrim": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "char *strtrim(char *str)\n{     char *t;\n      for (t = strrchr(str, '\\0') - 1; t >= str; t--)\n      {  if (*t != ' ')\n            break;\n         *t = '\\0';\n      }\n      return str;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "char",
        "*strtrim(char *str)",
        "*"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/triang.c": {
    "triang": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "int triang(int m, int n, int (*mat)(void *info, int k, int ind[],\n      double val[]), void *info, double tol, int rn[], int cn[])\n{     int head, i, j, jj, k, kk, ks, len, len2, next_j, ns, size;\n      int *cind, *rind, *cnt, *ptr, *list, *prev, *next;\n      double *cval, *rval, *big;\n      char *flag;\n      /* allocate working arrays */\n      cind = talloc(1+m, int);\n      cval = talloc(1+m, double);\n      rind = talloc(1+n, int);\n      rval = talloc(1+n, double);\n      cnt = ptr = talloc(1+m, int);\n      list = talloc(1+n, int);\n      prev = talloc(1+n, int);\n      next = talloc(1+n, int);\n      big = talloc(1+n, double);\n      flag = talloc(1+n, char);\n      /*--------------------------------------------------------------*/\n      /* build linked lists of columns having equal lengths           */\n      /*--------------------------------------------------------------*/\n      /* ptr[len], 0 <= len <= m, is number of first column of length\n       * len;\n       * next[j], 1 <= j <= n, is number of next column having the same\n       * length as column j;\n       * big[j], 1 <= j <= n, is maximal magnitude of elements in j-th\n       * column */\n      for (len = 0; len <= m; len++)\n         ptr[len] = 0;\n      for (j = 1; j <= n; j++)\n      {  /* get j-th column */\n         len = mat(info, -j, cind, cval);\n         xassert(0 <= len && len <= m);\n         /* add this column to beginning of list ptr[len] */\n         next[j] = ptr[len];\n         ptr[len] = j;\n         /* determine maximal magnitude of elements in this column */\n         big[j] = 0.0;\n         for (k = 1; k <= len; k++)\n         {  if (big[j] < fabs(cval[k]))\n               big[j] = fabs(cval[k]);\n         }\n      }\n      /*--------------------------------------------------------------*/\n      /* build doubly linked list of columns ordered by decreasing    */\n      /* column lengths                                               */\n      /*--------------------------------------------------------------*/\n      /* head is number of first column in the list;\n       * prev[j], 1 <= j <= n, is number of column that precedes j-th\n       * column in the list;\n       * next[j], 1 <= j <= n, is number of column that follows j-th\n       * column in the list */\n      head = 0;\n      for (len = 0; len <= m; len++)\n      {  /* walk thru list of columns of length len */\n         for (j = ptr[len]; j != 0; j = next_j)\n         {  next_j = next[j];\n            /* add j-th column to beginning of the column list */\n            prev[j] = 0;\n            next[j] = head;\n            if (head != 0)\n               prev[head] = j;\n            head = j;\n         }\n      }\n      /*--------------------------------------------------------------*/\n      /* build initial singleton list                                 */\n      /*--------------------------------------------------------------*/\n      /* there are used two list of columns:\n       * 1) doubly linked list of active columns, in which all columns\n       *    are ordered by decreasing column lengths;\n       * 2) singleton list; an active column is included in this list\n       *    if it has at least one row singleton in active submatrix */\n      /* flag[j], 1 <= j <= n, is a flag of j-th column:\n       * 0  j-th column is inactive;\n       * 1  j-th column is active;\n       * 2  j-th column is active and has row singleton(s) */\n      /* initially all columns are active */\n      for (j = 1; j <= n; j++)\n         flag[j] = 1;\n      /* initialize row counts and build initial singleton list */\n      /* cnt[i], 1 <= i <= m, is number of non-zeros, which i-th row\n       * has in active submatrix;\n       * ns is size of singleton list;\n       * list[1], ..., list[ns] are numbers of active columns included\n       * in the singleton list */\n      ns = 0;\n      for (i = 1; i <= m; i++)\n      {  /* get i-th row */\n         len = cnt[i] = mat(info, +i, rind, rval);\n         xassert(0 <= len && len <= n);\n         if (len == 1)\n         {  /* a[i,j] is row singleton */\n            j = rind[1];\n            xassert(1 <= j && j <= n);\n            if (flag[j] != 2)\n            {  /* include j-th column in singleton list */\n               flag[j] = 2;\n               list[++ns] = j;\n            }\n         }\n      }\n      /*--------------------------------------------------------------*/\n      /* main loop                                                    */\n      /*--------------------------------------------------------------*/\n      size = 0; /* size of triangular part */\n      /* loop until active column list is non-empty, i.e. until the\n       * active submatrix has at least one column */\n      while (head != 0)\n      {  if (ns == 0)\n         {  /* singleton list is empty */\n            /* remove from the active submatrix a column of maximal\n             * length in the hope that some row singletons appear */\n            j = head;\n            len = mat(info, -j, cind, cval);\n            xassert(0 <= len && len <= m);\n            goto drop;\n         }\n         /* take column j from the singleton list */\n         j = list[ns--];\n         xassert(flag[j] == 2);\n         /* j-th column has at least one row singleton in the active\n          * submatrix; choose one having maximal magnitude */\n         len = mat(info, -j, cind, cval);\n         xassert(0 <= len && len <= m);\n         kk = 0;\n         for (k = 1; k <= len; k++)\n         {  i = cind[k];\n            xassert(1 <= i && i <= m);\n            if (cnt[i] == 1)\n            {  /* a[i,j] is row singleton */\n               if (kk == 0 || fabs(cval[kk]) < fabs(cval[k]))\n                  kk = k;\n            }\n         }\n         xassert(kk > 0);\n         /* check magnitude of the row singleton chosen */\n         if (fabs(cval[kk]) < tol * big[j])\n         {  /* all row singletons are too small in magnitude; drop j-th\n             * column */\n            goto drop;\n         }\n         /* row singleton a[i,j] is ok; add i-th row and j-th column to\n          * the triangular part */\n         size++;\n         rn[size] = cind[kk];\n         cn[size] = j;\ndrop:    /* remove j-th column from the active submatrix */\n         xassert(flag[j]);\n         flag[j] = 0;\n         if (prev[j] == 0)\n            head = next[j];\n         else\n            next[prev[j]] = next[j];\n         if (next[j] == 0)\n            ;\n         else\n            prev[next[j]] = prev[j];\n         /* decrease row counts */\n         for (k = 1; k <= len; k++)\n         {  i = cind[k];\n            xassert(1 <= i && i <= m);\n            xassert(cnt[i] > 0);\n            cnt[i]--;\n            if (cnt[i] == 1)\n            {  /* new singleton appeared in i-th row; determine number\n                * of corresponding column (it is the only active column\n                * in this row) */\n               len2 = mat(info, +i, rind, rval);\n               xassert(0 <= len2 && len2 <= n);\n               ks = 0;\n               for (kk = 1; kk <= len2; kk++)\n               {  jj = rind[kk];\n                  xassert(1 <= jj && jj <= n);\n                  if (flag[jj])\n                  {  xassert(ks == 0);\n                     ks = kk;\n                  }\n               }\n               xassert(ks > 0);\n               /* a[i,jj] is new row singleton */\n               jj = rind[ks];\n               if (flag[jj] != 2)\n               {  /* include jj-th column in the singleton list */\n                  flag[jj] = 2;\n                  list[++ns] = jj;\n               }\n            }\n         }\n      }\n      /* now all row counts should be zero */\n      for (i = 1; i <= m; i++)\n         xassert(cnt[i] == 0);\n      /* deallocate working arrays */\n      tfree(cind);\n      tfree(cval);\n      tfree(rind);\n      tfree(rval);\n      tfree(ptr);\n      tfree(list);\n      tfree(prev);\n      tfree(next);\n      tfree(big);\n      tfree(flag);\n      return size;\n}",
      "lines": 205,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/triang.h": {},
  "glpk/glpk-4.65/src/misc/wclique.c": {
    "is_edge": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static int is_edge(struct csa *csa, int i, int j)\n{     /* if there is arc (i,j), the routine returns true; otherwise\n       * false; 0 <= i, j < n */\n      int k;\n      xassert(0 <= i && i < n);\n      xassert(0 <= j && j < n);\n      if (i == j) return 0;\n      if (i < j) k = i, i = j, j = k;\n      k = (i * (i - 1)) / 2 + j;\n      return a[k / CHAR_BIT] &\n         (unsigned char)(1 << ((CHAR_BIT - 1) - k % CHAR_BIT));\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sub": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void sub(struct csa *csa, int ct, int table[], int level,\n      int weight, int l_weight)\n{     int i, j, k, curr_weight, left_weight, *p1, *p2, *newtable;\n      newtable = xcalloc(n, sizeof(int));\n      if (ct <= 0)\n      {  /* 0 or 1 elements left; include these */\n         if (ct == 0)\n         {  set[level++] = table[0];\n            weight += l_weight;\n         }\n         if (weight > record)\n         {  record = weight;\n            rec_level = level;\n            for (i = 0; i < level; i++) rec[i] = set[i];\n         }\n         goto done;\n      }\n      for (i = ct; i >= 0; i--)\n      {  if ((level == 0) && (i < ct)) goto done;\n         k = table[i];\n         if ((level > 0) && (clique[k] <= (record - weight)))\n            goto done; /* prune */\n         set[level] = k;\n         curr_weight = weight + wt[k];\n         l_weight -= wt[k];\n         if (l_weight <= (record - curr_weight))\n            goto done; /* prune */\n         p1 = newtable;\n         p2 = table;\n         left_weight = 0;\n         while (p2 < table + i)\n         {  j = *p2++;\n            if (is_edge(csa, j, k))\n            {  *p1++ = j;\n               left_weight += wt[j];\n            }\n         }\n         if (left_weight <= (record - curr_weight)) continue;\n         sub(csa, p1 - newtable - 1, newtable, level + 1, curr_weight,\n            left_weight);\n      }\ndone: xfree(newtable);\n      return;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wclique": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "int wclique(int n_, const int w[], const unsigned char a_[], int ind[])\n{     struct csa csa_, *csa = &csa_;\n      int i, j, p, max_wt, max_nwt, wth, *used, *nwt, *pos;\n      double timer;\n      n = n_;\n      xassert(n > 0);\n      wt = &w[1];\n      a = a_;\n      record = 0;\n      rec_level = 0;\n      rec = &ind[1];\n      clique = xcalloc(n, sizeof(int));\n      set = xcalloc(n, sizeof(int));\n      used = xcalloc(n, sizeof(int));\n      nwt = xcalloc(n, sizeof(int));\n      pos = xcalloc(n, sizeof(int));\n      /* start timer */\n      timer = xtime();\n      /* order vertices */\n      for (i = 0; i < n; i++)\n      {  nwt[i] = 0;\n         for (j = 0; j < n; j++)\n            if (is_edge(csa, i, j)) nwt[i] += wt[j];\n      }\n      for (i = 0; i < n; i++)\n         used[i] = 0;\n      for (i = n-1; i >= 0; i--)\n      {  max_wt = -1;\n         max_nwt = -1;\n         for (j = 0; j < n; j++)\n         {  if ((!used[j]) && ((wt[j] > max_wt) || (wt[j] == max_wt\n               && nwt[j] > max_nwt)))\n            {  max_wt = wt[j];\n               max_nwt = nwt[j];\n               p = j;\n            }\n         }\n         pos[i] = p;\n         used[p] = 1;\n         for (j = 0; j < n; j++)\n            if ((!used[j]) && (j != p) && (is_edge(csa, p, j)))\n               nwt[j] -= wt[p];\n      }\n      /* main routine */\n      wth = 0;\n      for (i = 0; i < n; i++)\n      {  wth += wt[pos[i]];\n         sub(csa, i, pos, 0, 0, wth);\n         clique[pos[i]] = record;\n         if (xdifftime(xtime(), timer) >= 5.0 - 0.001)\n         {  /* print current record and reset timer */\n            xprintf(\"level = %d (%d); best = %d\\n\", i+1, n, record);\n            timer = xtime();\n         }\n      }\n      xfree(clique);\n      xfree(set);\n      xfree(used);\n      xfree(nwt);\n      xfree(pos);\n      /* return the solution found */\n      for (i = 1; i <= rec_level; i++) ind[i]++;\n      return rec_level;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/wclique.h": {},
  "glpk/glpk-4.65/src/misc/wclique1.c": {
    "fcmp": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static int CDECL fcmp(const void *xx, const void *yy)\n{     const struct vertex *x = xx, *y = yy;\n      if (x->cw > y->cw) return -1;\n      if (x->cw < y->cw) return +1;\n      return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "wclique1": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "int wclique1(int n, const double w[],\n      int (*func)(void *info, int i, int ind[]), void *info, int c[])\n{     struct vertex *v_list;\n      int deg, c_size, d_size, i, j, k, kk, l, *ind, *c_list, *d_list,\n         size = 0;\n      double c_wght, d_wght, *sw, best = 0.0;\n      char *d_flag, *skip;\n      /* perform sanity checks */\n      xassert(n >= 0);\n      for (i = 1; i <= n; i++)\n         xassert(w[i] >= 0.0);\n      /* if the graph is empty, nothing to do */\n      if (n == 0) goto done;\n      /* allocate working arrays */\n      ind = xcalloc(1+n, sizeof(int));\n      v_list = xcalloc(1+n, sizeof(struct vertex));\n      c_list = xcalloc(1+n, sizeof(int));\n      d_list = xcalloc(1+n, sizeof(int));\n      d_flag = xcalloc(1+n, sizeof(char));\n      skip = xcalloc(1+n, sizeof(char));\n      sw = xcalloc(1+n, sizeof(double));\n      /* build the vertex list */\n      for (i = 1; i <= n; i++)\n      {  v_list[i].i = i;\n         /* compute the cumulative weight of each vertex i, which is\n          * cw[i] = w[i] + sum{j : (i,j) in E} w[j] */\n         v_list[i].cw = w[i];\n         deg = func(info, i, ind);\n         xassert(0 <= deg && deg < n);\n         for (k = 1; k <= deg; k++)\n         {  j = ind[k];\n            xassert(1 <= j && j <= n && j != i);\n            v_list[i].cw += w[j];\n         }\n      }\n      /* sort the vertex list to access vertices in descending order of\n       * cumulative weights */\n      qsort(&v_list[1], n, sizeof(struct vertex), fcmp);\n      /* initially all vertices are unmarked */\n      memset(&skip[1], 0, sizeof(char) * n);\n      /* clear flags of all vertices */\n      memset(&d_flag[1], 0, sizeof(char) * n);\n      /* look through all vertices of the graph */\n      for (l = 1; l <= n; l++)\n      {  /* take vertex i */\n         i = v_list[l].i;\n         /* if this vertex was already included in one of previosuly\n          * constructed cliques, skip it */\n         if (skip[i]) continue;\n         /* use vertex i as the initial clique vertex */\n         c_size = 1;    /* size of current clique */\n         c_list[1] = i; /* list of vertices in current clique */\n         c_wght = w[i]; /* weight of current clique */\n         /* determine the candidate set D = { j : (i,j) in E } */\n         d_size = func(info, i, d_list);\n         xassert(0 <= d_size && d_size < n);\n         d_wght = 0.0;  /* weight of set D */\n         for (k = 1; k <= d_size; k++)\n         {  j = d_list[k];\n            xassert(1 <= j && j <= n && j != i);\n            xassert(!d_flag[j]);\n            d_flag[j] = 1;\n            d_wght += w[j];\n         }\n         /* check an upper bound to the final clique weight */\n         if (c_wght + d_wght < best + 1e-5 * (1.0 + fabs(best)))\n         {  /* skip constructing the current clique */\n            goto next;\n         }\n         /* compute the summary weight of each vertex i in D, which is\n          * sw[i] = w[i] + sum{j in D and (i,j) in E} w[j] */\n         for (k = 1; k <= d_size; k++)\n         {  i = d_list[k];\n            sw[i] = w[i];\n            /* consider vertices adjacent to vertex i */\n            deg = func(info, i, ind);\n            xassert(0 <= deg && deg < n);\n            for (kk = 1; kk <= deg; kk++)\n            {  j = ind[kk];\n               xassert(1 <= j && j <= n && j != i);\n               if (d_flag[j]) sw[i] += w[j];\n            }\n         }\n         /* grow the current clique by adding vertices from D */\n         while (d_size > 0)\n         {  /* check an upper bound to the final clique weight */\n            if (c_wght + d_wght < best + 1e-5 * (1.0 + fabs(best)))\n            {  /* skip constructing the current clique */\n               goto next;\n            }\n            /* choose vertex i in D having maximal summary weight */\n            i = d_list[1];\n            for (k = 2; k <= d_size; k++)\n            {  j = d_list[k];\n               if (sw[i] < sw[j]) i = j;\n            }\n            /* include vertex i in the current clique */\n            c_size++;\n            c_list[c_size] = i;\n            c_wght += w[i];\n            /* remove all vertices not adjacent to vertex i, including\n             * vertex i itself, from the candidate set D */\n            deg = func(info, i, ind);\n            xassert(0 <= deg && deg < n);\n            for (k = 1; k <= deg; k++)\n            {  j = ind[k];\n               xassert(1 <= j && j <= n && j != i);\n               /* vertex j is adjacent to vertex i */\n               if (d_flag[j])\n               {  xassert(d_flag[j] == 1);\n                  /* mark vertex j to keep it in D */\n                  d_flag[j] = 2;\n               }\n            }\n            kk = d_size, d_size = 0;\n            for (k = 1; k <= kk; k++)\n            {  j = d_list[k];\n               if (d_flag[j] == 1)\n               {  /* remove vertex j from D */\n                  d_flag[j] = 0;\n                  d_wght -= w[j];\n               }\n               else if (d_flag[j] == 2)\n               {  /* keep vertex j in D */\n                  d_list[++d_size] = j;\n                  d_flag[j] = 1;\n               }\n               else\n                  xassert(d_flag != d_flag);\n            }\n         }\n         /* the current clique has been completely constructed */\n         if (best < c_wght)\n         {  best = c_wght;\n            size = c_size;\n            xassert(1 <= size && size <= n);\n            memcpy(&c[1], &c_list[1], size * sizeof(int));\n         }\nnext:    /* mark the current clique vertices in order not to use them\n          * as initial vertices anymore */\n         for (k = 1; k <= c_size; k++)\n            skip[c_list[k]] = 1;\n         /* set D can be non-empty, so clean up vertex flags */\n         for (k = 1; k <= d_size; k++)\n            d_flag[d_list[k]] = 0;\n      }\n      /* free working arrays */\n      xfree(ind);\n      xfree(v_list);\n      xfree(c_list);\n      xfree(d_list);\n      xfree(d_flag);\n      xfree(skip);\n      xfree(sw);\ndone: /* return to the calling program */\n      return size;\n}",
      "lines": 157,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "func": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "int func(void *info, int i, int ind[])\n{     glp_arc *e;\n      int j, k, deg = 0;\n      xassert(info == NULL);\n      xassert(1 <= i && i <= G->nv);\n      /* look through incoming arcs */\n      for (e = G->v[i]->in; e != NULL; e = e->h_next)\n      {  j = e->tail->i; /* j->i */\n         if (j != i && !flag[j]) ind[++deg] = j, flag[j] = 1;\n      }\n      /* look through outgoing arcs */\n      for (e = G->v[i]->out; e != NULL; e = e->t_next)\n      {  j = e->head->i; /* i->j */\n         if (j != i && !flag[j]) ind[++deg] = j, flag[j] = 1;\n      }\n      /* clear the flag array */\n      xassert(deg < G->nv);\n      for (k = 1; k <= deg; k++) flag[ind[k]] = 0;\n      return deg;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "int main(int argc, char *argv[])\n{     RNG *rand;\n      int i, k, kk, size, *c, *ind, deg;\n      double *w, sum, t;\n      /* read graph in DIMACS format */\n      G = glp_create_graph(sizeof(v_data), 0);\n      xassert(argc == 2);\n      xassert(glp_read_ccdata(G, offsetof(v_data, w), argv[1]) == 0);\n      /* print the number of connected components */\n      xprintf(\"nc = %d\\n\", glp_weak_comp(G, -1));\n      /* assign random weights unformly distributed in [1,100] */\n      w = xcalloc(1+G->nv, sizeof(double));\n      rand = rng_create_rand();\n      for (i = 1; i <= G->nv; i++)\n#if 0\n         w[i] = weight(G->v[i]) = 1.0;\n#else\n         w[i] = weight(G->v[i]) = rng_unif_rand(rand, 100) + 1;\n#endif\n      /* write graph in DIMACS format */\n      xassert(glp_write_ccdata(G, offsetof(v_data, w), \"graph\") == 0);\n      /* find maximum weight clique */\n      c = xcalloc(1+G->nv, sizeof(int));\n      flag = xcalloc(1+G->nv, sizeof(char));\n      memset(&flag[1], 0, G->nv);\n      t = xtime();\n      size = wclique1(G->nv, w, func, NULL, c);\n      xprintf(\"Time used: %.1f s\\n\", xdifftime(xtime(), t));\n      /* check the clique found */\n      ind = xcalloc(1+G->nv, sizeof(int));\n      for (k = 1; k <= size; k++)\n      {  i = c[k];\n         deg = func(NULL, i, ind);\n         for (kk = 1; kk <= size; kk++)\n            flag[c[kk]] = 1;\n         flag[i] = 0;\n         for (kk = 1; kk <= deg; kk++)\n            flag[ind[kk]] = 0;\n         for (kk = 1; kk <= size; kk++)\n            xassert(flag[c[kk]] == 0);\n      }\n      /* compute the clique weight */\n      sum = 0.0;\n      for (i = 1; i <= size; i++)\n         sum += w[c[i]];\n      xprintf(\"size = %d; sum = %g\\n\", size, sum);\n      return 0;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/misc/wclique1.h": {},
  "glpk/glpk-4.65/src/mpl/mpl.h": {},
  "glpk/glpk-4.65/src/mpl/mpl1.c": {
    "enter_context": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void enter_context(MPL *mpl)\n{     char *image, *s;\n      if (mpl->token == T_EOF)\n         image = \"_|_\";\n      else if (mpl->token == T_STRING)\n         image = \"'...'\";\n      else\n         image = mpl->image;\n      xassert(0 <= mpl->c_ptr && mpl->c_ptr < CONTEXT_SIZE);\n      mpl->context[mpl->c_ptr++] = ' ';\n      if (mpl->c_ptr == CONTEXT_SIZE) mpl->c_ptr = 0;\n      for (s = image; *s != '\\0'; s++)\n      {  mpl->context[mpl->c_ptr++] = *s;\n         if (mpl->c_ptr == CONTEXT_SIZE) mpl->c_ptr = 0;\n      }\n      return;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_context": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void print_context(MPL *mpl)\n{     int c;\n      while (mpl->c_ptr > 0)\n      {  mpl->c_ptr--;\n         c = mpl->context[0];\n         memmove(mpl->context, mpl->context+1, CONTEXT_SIZE-1);\n         mpl->context[CONTEXT_SIZE-1] = (char)c;\n      }\n      xprintf(\"Context: %s%.*s\\n\", mpl->context[0] == ' ' ? \"\" : \"...\",\n         CONTEXT_SIZE, mpl->context);\n      return;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "get_char": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void get_char(MPL *mpl)\n{     int c;\n      if (mpl->c == EOF) goto done;\n      if (mpl->c == '\\n') mpl->line++;\n      c = read_char(mpl);\n      if (c == EOF)\n      {  if (mpl->c == '\\n')\n            mpl->line--;\n         else\n            warning(mpl, \"final NL missing before end of file\");\n      }\n      else if (c == '\\n')\n         ;\n      else if (isspace(c))\n         c = ' ';\n      else if (iscntrl(c))\n      {  enter_context(mpl);\n         error(mpl, \"control character 0x%02X not allowed\", c);\n      }\n      mpl->c = c;\ndone: return;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "append_char": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void append_char(MPL *mpl)\n{     xassert(0 <= mpl->imlen && mpl->imlen <= MAX_LENGTH);\n      if (mpl->imlen == MAX_LENGTH)\n      {  switch (mpl->token)\n         {  case T_NAME:\n               enter_context(mpl);\n               error(mpl, \"symbolic name %s... too long\", mpl->image);\n            case T_SYMBOL:\n               enter_context(mpl);\n               error(mpl, \"symbol %s... too long\", mpl->image);\n            case T_NUMBER:\n               enter_context(mpl);\n               error(mpl, \"numeric literal %s... too long\", mpl->image);\n            case T_STRING:\n               enter_context(mpl);\n               error(mpl, \"string literal too long\");\n            default:\n               xassert(mpl != mpl);\n         }\n      }\n      mpl->image[mpl->imlen++] = (char)mpl->c;\n      mpl->image[mpl->imlen] = '\\0';\n      get_char(mpl);\n      return;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "get_token": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "void get_token(MPL *mpl)\n{     /* save the current token */\n      mpl->b_token = mpl->token;\n      mpl->b_imlen = mpl->imlen;\n      strcpy(mpl->b_image, mpl->image);\n      mpl->b_value = mpl->value;\n      /* if the next token is already scanned, make it current */\n      if (mpl->f_scan)\n      {  mpl->f_scan = 0;\n         mpl->token = mpl->f_token;\n         mpl->imlen = mpl->f_imlen;\n         strcpy(mpl->image, mpl->f_image);\n         mpl->value = mpl->f_value;\n         goto done;\n      }\nloop: /* nothing has been scanned so far */\n      mpl->token = 0;\n      mpl->imlen = 0;\n      mpl->image[0] = '\\0';\n      mpl->value = 0.0;\n      /* skip any uninteresting characters */\n      while (mpl->c == ' ' || mpl->c == '\\n') get_char(mpl);\n      /* recognize and construct the token */\n      if (mpl->c == EOF)\n      {  /* end-of-file reached */\n         mpl->token = T_EOF;\n      }\n      else if (mpl->c == '#')\n      {  /* comment; skip anything until end-of-line */\n         while (mpl->c != '\\n' && mpl->c != EOF) get_char(mpl);\n         goto loop;\n      }\n      else if (!mpl->flag_d && (isalpha(mpl->c) || mpl->c == '_'))\n      {  /* symbolic name or reserved keyword */\n         mpl->token = T_NAME;\n         while (isalnum(mpl->c) || mpl->c == '_') append_char(mpl);\n         if (strcmp(mpl->image, \"and\") == 0)\n            mpl->token = T_AND;\n         else if (strcmp(mpl->image, \"by\") == 0)\n            mpl->token = T_BY;\n         else if (strcmp(mpl->image, \"cross\") == 0)\n            mpl->token = T_CROSS;\n         else if (strcmp(mpl->image, \"diff\") == 0)\n            mpl->token = T_DIFF;\n         else if (strcmp(mpl->image, \"div\") == 0)\n            mpl->token = T_DIV;\n         else if (strcmp(mpl->image, \"else\") == 0)\n            mpl->token = T_ELSE;\n         else if (strcmp(mpl->image, \"if\") == 0)\n            mpl->token = T_IF;\n         else if (strcmp(mpl->image, \"in\") == 0)\n            mpl->token = T_IN;\n#if 1 /* 21/VII-2006 */\n         else if (strcmp(mpl->image, \"Infinity\") == 0)\n            mpl->token = T_INFINITY;\n#endif\n         else if (strcmp(mpl->image, \"inter\") == 0)\n            mpl->token = T_INTER;\n         else if (strcmp(mpl->image, \"less\") == 0)\n            mpl->token = T_LESS;\n         else if (strcmp(mpl->image, \"mod\") == 0)\n            mpl->token = T_MOD;\n         else if (strcmp(mpl->image, \"not\") == 0)\n            mpl->token = T_NOT;\n         else if (strcmp(mpl->image, \"or\") == 0)\n            mpl->token = T_OR;\n         else if (strcmp(mpl->image, \"s\") == 0 && mpl->c == '.')\n         {  mpl->token = T_SPTP;\n            append_char(mpl);\n            if (mpl->c != 't')\nsptp:       {  enter_context(mpl);\n               error(mpl, \"keyword s.t. incomplete\");\n            }\n            append_char(mpl);\n            if (mpl->c != '.') goto sptp;\n            append_char(mpl);\n         }\n         else if (strcmp(mpl->image, \"symdiff\") == 0)\n            mpl->token = T_SYMDIFF;\n         else if (strcmp(mpl->image, \"then\") == 0)\n            mpl->token = T_THEN;\n         else if (strcmp(mpl->image, \"union\") == 0)\n            mpl->token = T_UNION;\n         else if (strcmp(mpl->image, \"within\") == 0)\n            mpl->token = T_WITHIN;\n      }\n      else if (!mpl->flag_d && isdigit(mpl->c))\n      {  /* numeric literal */\n         mpl->token = T_NUMBER;\n         /* scan integer part */\n         while (isdigit(mpl->c)) append_char(mpl);\n         /* scan optional fractional part */\n         if (mpl->c == '.')\n         {  append_char(mpl);\n            if (mpl->c == '.')\n            {  /* hmm, it is not the fractional part, it is dots that\n                  follow the integer part */\n               mpl->imlen--;\n               mpl->image[mpl->imlen] = '\\0';\n               mpl->f_dots = 1;\n               goto conv;\n            }\nfrac:       while (isdigit(mpl->c)) append_char(mpl);\n         }\n         /* scan optional decimal exponent */\n         if (mpl->c == 'e' || mpl->c == 'E')\n         {  append_char(mpl);\n            if (mpl->c == '+' || mpl->c == '-') append_char(mpl);\n            if (!isdigit(mpl->c))\n            {  enter_context(mpl);\n               error(mpl, \"numeric literal %s incomplete\", mpl->image);\n            }\n            while (isdigit(mpl->c)) append_char(mpl);\n         }\n         /* there must be no letter following the numeric literal */\n         if (isalpha(mpl->c) || mpl->c == '_')\n         {  enter_context(mpl);\n            error(mpl, \"symbol %s%c... should be enclosed in quotes\",\n               mpl->image, mpl->c);\n         }\nconv:    /* convert numeric literal to floating-point */\n         if (str2num(mpl->image, &mpl->value))\nerr:     {  enter_context(mpl);\n            error(mpl, \"cannot convert numeric literal %s to floating-p\"\n               \"oint number\", mpl->image);\n         }\n      }\n      else if (mpl->c == '\\'' || mpl->c == '\"')\n      {  /* character string */\n         int quote = mpl->c;\n         mpl->token = T_STRING;\n         get_char(mpl);\n         for (;;)\n         {  if (mpl->c == '\\n' || mpl->c == EOF)\n            {  enter_context(mpl);\n               error(mpl, \"unexpected end of line; string literal incom\"\n                  \"plete\");\n            }\n            if (mpl->c == quote)\n            {  get_char(mpl);\n               if (mpl->c != quote) break;\n            }\n            append_char(mpl);\n         }\n      }\n      else if (!mpl->flag_d && mpl->c == '+')\n         mpl->token = T_PLUS, append_char(mpl);\n      else if (!mpl->flag_d && mpl->c == '-')\n         mpl->token = T_MINUS, append_char(mpl);\n      else if (mpl->c == '*')\n      {  mpl->token = T_ASTERISK, append_char(mpl);\n         if (mpl->c == '*')\n            mpl->token = T_POWER, append_char(mpl);\n      }\n      else if (mpl->c == '/')\n      {  mpl->token = T_SLASH, append_char(mpl);\n         if (mpl->c == '*')\n         {  /* comment sequence */\n            get_char(mpl);\n            for (;;)\n            {  if (mpl->c == EOF)\n               {  /* do not call enter_context at this point */\n                  error(mpl, \"unexpected end of file; comment sequence \"\n                     \"incomplete\");\n               }\n               else if (mpl->c == '*')\n               {  get_char(mpl);\n                  if (mpl->c == '/') break;\n               }\n               else\n                  get_char(mpl);\n            }\n            get_char(mpl);\n            goto loop;\n         }\n      }\n      else if (mpl->c == '^')\n         mpl->token = T_POWER, append_char(mpl);\n      else if (mpl->c == '<')\n      {  mpl->token = T_LT, append_char(mpl);\n         if (mpl->c == '=')\n            mpl->token = T_LE, append_char(mpl);\n         else if (mpl->c == '>')\n            mpl->token = T_NE, append_char(mpl);\n#if 1 /* 11/II-2008 */\n         else if (mpl->c == '-')\n            mpl->token = T_INPUT, append_char(mpl);\n#endif\n      }\n      else if (mpl->c == '=')\n      {  mpl->token = T_EQ, append_char(mpl);\n         if (mpl->c == '=') append_char(mpl);\n      }\n      else if (mpl->c == '>')\n      {  mpl->token = T_GT, append_char(mpl);\n         if (mpl->c == '=')\n            mpl->token = T_GE, append_char(mpl);\n#if 1 /* 14/VII-2006 */\n         else if (mpl->c == '>')\n            mpl->token = T_APPEND, append_char(mpl);\n#endif\n      }\n      else if (mpl->c == '!')\n      {  mpl->token = T_NOT, append_char(mpl);\n         if (mpl->c == '=')\n            mpl->token = T_NE, append_char(mpl);\n      }\n      else if (mpl->c == '&')\n      {  mpl->token = T_CONCAT, append_char(mpl);\n         if (mpl->c == '&')\n            mpl->token = T_AND, append_char(mpl);\n      }\n      else if (mpl->c == '|')\n      {  mpl->token = T_BAR, append_char(mpl);\n         if (mpl->c == '|')\n            mpl->token = T_OR, append_char(mpl);\n      }\n      else if (!mpl->flag_d && mpl->c == '.')\n      {  mpl->token = T_POINT, append_char(mpl);\n         if (mpl->f_dots)\n         {  /* dots; the first dot was read on the previous call to the\n               scanner, so the current character is the second dot */\n            mpl->token = T_DOTS;\n            mpl->imlen = 2;\n            strcpy(mpl->image, \"..\");\n            mpl->f_dots = 0;\n         }\n         else if (mpl->c == '.')\n            mpl->token = T_DOTS, append_char(mpl);\n         else if (isdigit(mpl->c))\n         {  /* numeric literal that begins with the decimal point */\n            mpl->token = T_NUMBER, append_char(mpl);\n            goto frac;\n         }\n      }\n      else if (mpl->c == ',')\n         mpl->token = T_COMMA, append_char(mpl);\n      else if (mpl->c == ':')\n      {  mpl->token = T_COLON, append_char(mpl);\n         if (mpl->c == '=')\n            mpl->token = T_ASSIGN, append_char(mpl);\n      }\n      else if (mpl->c == ';')\n         mpl->token = T_SEMICOLON, append_char(mpl);\n      else if (mpl->c == '(')\n         mpl->token = T_LEFT, append_char(mpl);\n      else if (mpl->c == ')')\n         mpl->token = T_RIGHT, append_char(mpl);\n      else if (mpl->c == '[')\n         mpl->token = T_LBRACKET, append_char(mpl);\n      else if (mpl->c == ']')\n         mpl->token = T_RBRACKET, append_char(mpl);\n      else if (mpl->c == '{')\n         mpl->token = T_LBRACE, append_char(mpl);\n      else if (mpl->c == '}')\n         mpl->token = T_RBRACE, append_char(mpl);\n#if 1 /* 11/II-2008 */\n      else if (mpl->c == '~')\n         mpl->token = T_TILDE, append_char(mpl);\n#endif\n      else if (isalnum(mpl->c) || strchr(\"+-._\", mpl->c) != NULL)\n      {  /* symbol */\n         xassert(mpl->flag_d);\n         mpl->token = T_SYMBOL;\n         while (isalnum(mpl->c) || strchr(\"+-._\", mpl->c) != NULL)\n            append_char(mpl);\n         switch (str2num(mpl->image, &mpl->value))\n         {  case 0:\n               mpl->token = T_NUMBER;\n               break;\n            case 1:\n               goto err;\n            case 2:\n               break;\n            default:\n               xassert(mpl != mpl);\n         }\n      }\n      else\n      {  enter_context(mpl);\n         error(mpl, \"character %c not allowed\", mpl->c);\n      }\n      /* enter the current token into the context queue */\n      enter_context(mpl);\n      /* reset the flag, which may be set by indexing_expression() and\n         is used by expression_list() */\n      mpl->flag_x = 0;\ndone: return;\n}",
      "lines": 289,
      "depth": 33,
      "decorators": [
        "void"
      ]
    },
    "unget_token": {
      "start_point": [
        435,
        0
      ],
      "end_point": [
        449,
        1
      ],
      "content": "void unget_token(MPL *mpl)\n{     /* save the current token, which becomes the next one */\n      xassert(!mpl->f_scan);\n      mpl->f_scan = 1;\n      mpl->f_token = mpl->token;\n      mpl->f_imlen = mpl->imlen;\n      strcpy(mpl->f_image, mpl->image);\n      mpl->f_value = mpl->value;\n      /* restore the previous token, which becomes the current one */\n      mpl->token = mpl->b_token;\n      mpl->imlen = mpl->b_imlen;\n      strcpy(mpl->image, mpl->b_image);\n      mpl->value = mpl->b_value;\n      return;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "is_keyword": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        460,
        1
      ],
      "content": "int is_keyword(MPL *mpl, char *keyword)\n{     return\n         mpl->token == T_NAME && strcmp(mpl->image, keyword) == 0;\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "is_reserved": {
      "start_point": [
        468,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "int is_reserved(MPL *mpl)\n{     return\n         mpl->token == T_AND && mpl->image[0] == 'a' ||\n         mpl->token == T_BY ||\n         mpl->token == T_CROSS ||\n         mpl->token == T_DIFF ||\n         mpl->token == T_DIV ||\n         mpl->token == T_ELSE ||\n         mpl->token == T_IF ||\n         mpl->token == T_IN ||\n         mpl->token == T_INTER ||\n         mpl->token == T_LESS ||\n         mpl->token == T_MOD ||\n         mpl->token == T_NOT && mpl->image[0] == 'n' ||\n         mpl->token == T_OR && mpl->image[0] == 'o' ||\n         mpl->token == T_SYMDIFF ||\n         mpl->token == T_THEN ||\n         mpl->token == T_UNION ||\n         mpl->token == T_WITHIN;\n}",
      "lines": 20,
      "depth": 24,
      "decorators": [
        "int"
      ]
    },
    "make_code": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "CODE *make_code(MPL *mpl, int op, OPERANDS *arg, int type, int dim)\n{     CODE *code;\n      DOMAIN *domain;\n      DOMAIN_BLOCK *block;\n      ARG_LIST *e;\n      /* generate pseudo-code */\n      code = alloc(CODE);\n      code->op = op;\n      code->vflag = 0; /* is inherited from operand(s) */\n      /* copy operands and also make them referring to the pseudo-code\n         being generated, because the latter becomes the parent for all\n         its operands */\n      memset(&code->arg, '?', sizeof(OPERANDS));\n      switch (op)\n      {  case O_NUMBER:\n            code->arg.num = arg->num;\n            break;\n         case O_STRING:\n            code->arg.str = arg->str;\n            break;\n         case O_INDEX:\n            code->arg.index.slot = arg->index.slot;\n            code->arg.index.next = arg->index.next;\n            break;\n         case O_MEMNUM:\n         case O_MEMSYM:\n            for (e = arg->par.list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.par.par = arg->par.par;\n            code->arg.par.list = arg->par.list;\n            break;\n         case O_MEMSET:\n            for (e = arg->set.list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.set.set = arg->set.set;\n            code->arg.set.list = arg->set.list;\n            break;\n         case O_MEMVAR:\n            for (e = arg->var.list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.var.var = arg->var.var;\n            code->arg.var.list = arg->var.list;\n#if 1 /* 15/V-2010 */\n            code->arg.var.suff = arg->var.suff;\n#endif\n            break;\n#if 1 /* 15/V-2010 */\n         case O_MEMCON:\n            for (e = arg->con.list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.con.con = arg->con.con;\n            code->arg.con.list = arg->con.list;\n            code->arg.con.suff = arg->con.suff;\n            break;\n#endif\n         case O_TUPLE:\n         case O_MAKE:\n            for (e = arg->list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.list = arg->list;\n            break;\n         case O_SLICE:\n            xassert(arg->slice != NULL);\n            code->arg.slice = arg->slice;\n            break;\n         case O_IRAND224:\n         case O_UNIFORM01:\n         case O_NORMAL01:\n         case O_GMTIME:\n            code->vflag = 1;\n            break;\n         case O_CVTNUM:\n         case O_CVTSYM:\n         case O_CVTLOG:\n         case O_CVTTUP:\n         case O_CVTLFM:\n         case O_PLUS:\n         case O_MINUS:\n         case O_NOT:\n         case O_ABS:\n         case O_CEIL:\n         case O_FLOOR:\n         case O_EXP:\n         case O_LOG:\n         case O_LOG10:\n         case O_SQRT:\n         case O_SIN:\n         case O_COS:\n         case O_TAN:\n         case O_ATAN:\n         case O_ROUND:\n         case O_TRUNC:\n         case O_CARD:\n         case O_LENGTH:\n            /* unary operation */\n            xassert(arg->arg.x != NULL);\n            xassert(arg->arg.x->up == NULL);\n            arg->arg.x->up = code;\n            code->vflag |= arg->arg.x->vflag;\n            code->arg.arg.x = arg->arg.x;\n            break;\n         case O_ADD:\n         case O_SUB:\n         case O_LESS:\n         case O_MUL:\n         case O_DIV:\n         case O_IDIV:\n         case O_MOD:\n         case O_POWER:\n         case O_ATAN2:\n         case O_ROUND2:\n         case O_TRUNC2:\n         case O_UNIFORM:\n            if (op == O_UNIFORM) code->vflag = 1;\n         case O_NORMAL:\n            if (op == O_NORMAL) code->vflag = 1;\n         case O_CONCAT:\n         case O_LT:\n         case O_LE:\n         case O_EQ:\n         case O_GE:\n         case O_GT:\n         case O_NE:\n         case O_AND:\n         case O_OR:\n         case O_UNION:\n         case O_DIFF:\n         case O_SYMDIFF:\n         case O_INTER:\n         case O_CROSS:\n         case O_IN:\n         case O_NOTIN:\n         case O_WITHIN:\n         case O_NOTWITHIN:\n         case O_SUBSTR:\n         case O_STR2TIME:\n         case O_TIME2STR:\n            /* binary operation */\n            xassert(arg->arg.x != NULL);\n            xassert(arg->arg.x->up == NULL);\n            arg->arg.x->up = code;\n            code->vflag |= arg->arg.x->vflag;\n            xassert(arg->arg.y != NULL);\n            xassert(arg->arg.y->up == NULL);\n            arg->arg.y->up = code;\n            code->vflag |= arg->arg.y->vflag;\n            code->arg.arg.x = arg->arg.x;\n            code->arg.arg.y = arg->arg.y;\n            break;\n         case O_DOTS:\n         case O_FORK:\n         case O_SUBSTR3:\n            /* ternary operation */\n            xassert(arg->arg.x != NULL);\n            xassert(arg->arg.x->up == NULL);\n            arg->arg.x->up = code;\n            code->vflag |= arg->arg.x->vflag;\n            xassert(arg->arg.y != NULL);\n            xassert(arg->arg.y->up == NULL);\n            arg->arg.y->up = code;\n            code->vflag |= arg->arg.y->vflag;\n            if (arg->arg.z != NULL)\n            {  xassert(arg->arg.z->up == NULL);\n               arg->arg.z->up = code;\n               code->vflag |= arg->arg.z->vflag;\n            }\n            code->arg.arg.x = arg->arg.x;\n            code->arg.arg.y = arg->arg.y;\n            code->arg.arg.z = arg->arg.z;\n            break;\n         case O_MIN:\n         case O_MAX:\n            /* n-ary operation */\n            for (e = arg->list; e != NULL; e = e->next)\n            {  xassert(e->x != NULL);\n               xassert(e->x->up == NULL);\n               e->x->up = code;\n               code->vflag |= e->x->vflag;\n            }\n            code->arg.list = arg->list;\n            break;\n         case O_SUM:\n         case O_PROD:\n         case O_MINIMUM:\n         case O_MAXIMUM:\n         case O_FORALL:\n         case O_EXISTS:\n         case O_SETOF:\n         case O_BUILD:\n            /* iterated operation */\n            domain = arg->loop.domain;\n            xassert(domain != NULL);\n            if (domain->code != NULL)\n            {  xassert(domain->code->up == NULL);\n               domain->code->up = code;\n               code->vflag |= domain->code->vflag;\n            }\n            for (block = domain->list; block != NULL; block =\n               block->next)\n            {  xassert(block->code != NULL);\n               xassert(block->code->up == NULL);\n               block->code->up = code;\n               code->vflag |= block->code->vflag;\n            }\n            if (arg->loop.x != NULL)\n            {  xassert(arg->loop.x->up == NULL);\n               arg->loop.x->up = code;\n               code->vflag |= arg->loop.x->vflag;\n            }\n            code->arg.loop.domain = arg->loop.domain;\n            code->arg.loop.x = arg->loop.x;\n            break;\n         default:\n            xassert(op != op);\n      }\n      /* set other attributes of the pseudo-code */\n      code->type = type;\n      code->dim = dim;\n      code->up = NULL;\n      code->valid = 0;\n      memset(&code->value, '?', sizeof(VALUE));\n      return code;\n}",
      "lines": 243,
      "depth": 15,
      "decorators": [
        "CODE",
        "*make_code(MPL *mpl, int op, OPERANDS *arg, int type, int dim)",
        "*"
      ]
    },
    "make_unary": {
      "start_point": [
        744,
        0
      ],
      "end_point": [
        751,
        1
      ],
      "content": "CODE *make_unary(MPL *mpl, int op, CODE *x, int type, int dim)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(x != NULL);\n      arg.arg.x = x;\n      code = make_code(mpl, op, &arg, type, dim);\n      return code;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "CODE",
        "*make_unary(MPL *mpl, int op, CODE *x, int type, int dim)",
        "*"
      ]
    },
    "make_binary": {
      "start_point": [
        758,
        0
      ],
      "end_point": [
        768,
        1
      ],
      "content": "CODE *make_binary(MPL *mpl, int op, CODE *x, CODE *y, int type,\n      int dim)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(x != NULL);\n      xassert(y != NULL);\n      arg.arg.x = x;\n      arg.arg.y = y;\n      code = make_code(mpl, op, &arg, type, dim);\n      return code;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "CODE",
        "*make_binary(MPL *mpl, int op, CODE *x, CODE *y, int type,\n      int dim)",
        "*"
      ]
    },
    "make_ternary": {
      "start_point": [
        775,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "CODE *make_ternary(MPL *mpl, int op, CODE *x, CODE *y, CODE *z,\n      int type, int dim)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(x != NULL);\n      xassert(y != NULL);\n      /* third operand can be NULL */\n      arg.arg.x = x;\n      arg.arg.y = y;\n      arg.arg.z = z;\n      code = make_code(mpl, op, &arg, type, dim);\n      return code;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "CODE",
        "*make_ternary(MPL *mpl, int op, CODE *x, CODE *y, CODE *z,\n      int type, int dim)",
        "*"
      ]
    },
    "numeric_literal": {
      "start_point": [
        796,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "CODE *numeric_literal(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(mpl->token == T_NUMBER);\n      arg.num = mpl->value;\n      code = make_code(mpl, O_NUMBER, &arg, A_NUMERIC, 0);\n      get_token(mpl /* <numeric literal> */);\n      return code;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "CODE",
        "*numeric_literal(MPL *mpl)",
        "*"
      ]
    },
    "string_literal": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "CODE *string_literal(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(mpl->token == T_STRING);\n      arg.str = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(arg.str, mpl->image);\n      code = make_code(mpl, O_STRING, &arg, A_SYMBOLIC, 0);\n      get_token(mpl /* <string literal> */);\n      return code;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "CODE",
        "*string_literal(MPL *mpl)",
        "*"
      ]
    },
    "create_arg_list": {
      "start_point": [
        829,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "ARG_LIST *create_arg_list(MPL *mpl)\n{     ARG_LIST *list;\n      xassert(mpl == mpl);\n      list = NULL;\n      return list;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "ARG_LIST",
        "*create_arg_list(MPL *mpl)",
        "*"
      ]
    },
    "expand_arg_list": {
      "start_point": [
        841,
        0
      ],
      "end_point": [
        856,
        1
      ],
      "content": "ARG_LIST *expand_arg_list(MPL *mpl, ARG_LIST *list, CODE *x)\n{     ARG_LIST *tail, *temp;\n      xassert(x != NULL);\n      /* create new operands list entry */\n      tail = alloc(ARG_LIST);\n      tail->x = x;\n      tail->next = NULL;\n      /* and append it to the operands list */\n      if (list == NULL)\n         list = tail;\n      else\n      {  for (temp = list; temp->next != NULL; temp = temp->next);\n         temp->next = tail;\n      }\n      return list;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "ARG_LIST",
        "*expand_arg_list(MPL *mpl, ARG_LIST *list, CODE *x)",
        "*"
      ]
    },
    "arg_list_len": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        870,
        1
      ],
      "content": "int arg_list_len(MPL *mpl, ARG_LIST *list)\n{     ARG_LIST *temp;\n      int len;\n      xassert(mpl == mpl);\n      len = 0;\n      for (temp = list; temp != NULL; temp = temp->next) len++;\n      return len;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "subscript_list": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        906,
        1
      ],
      "content": "ARG_LIST *subscript_list(MPL *mpl)\n{     ARG_LIST *list;\n      CODE *x;\n      list = create_arg_list(mpl);\n      for (;;)\n      {  /* parse subscript expression */\n         x = expression_5(mpl);\n         /* convert it to symbolic type, if necessary */\n         if (x->type == A_NUMERIC)\n            x = make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\n         /* check that now the expression is of symbolic type */\n         if (x->type != A_SYMBOLIC)\n            error(mpl, \"subscript expression has invalid type\");\n         xassert(x->dim == 0);\n         /* and append it to the subscript list */\n         list = expand_arg_list(mpl, list, x);\n         /* check a token that follows the subscript expression */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_RBRACKET)\n            break;\n         else\n            error(mpl, \"syntax error in subscript list\");\n      }\n      return list;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "ARG_LIST",
        "*subscript_list(MPL *mpl)",
        "*"
      ]
    },
    "object_reference": {
      "start_point": [
        932,
        0
      ],
      "end_point": [
        1084,
        1
      ],
      "content": "CODE *object_reference(MPL *mpl)\n{     AVLNODE *node;\n      DOMAIN_SLOT *slot;\n      SET *set;\n      PARAMETER *par;\n      VARIABLE *var;\n      CONSTRAINT *con;\n      ARG_LIST *list;\n      OPERANDS arg;\n      CODE *code;\n      char *name;\n      int dim, suff;\n      /* find the object in the symbolic name table */\n      xassert(mpl->token == T_NAME);\n      node = avl_find_node(mpl->tree, mpl->image);\n      if (node == NULL)\n         error(mpl, \"%s not defined\", mpl->image);\n      /* check the object type and obtain its dimension */\n      switch (avl_get_node_type(node))\n      {  case A_INDEX:\n            /* dummy index */\n            slot = (DOMAIN_SLOT *)avl_get_node_link(node);\n            name = slot->name;\n            dim = 0;\n            break;\n         case A_SET:\n            /* model set */\n            set = (SET *)avl_get_node_link(node);\n            name = set->name;\n            dim = set->dim;\n            /* if a set object is referenced in its own declaration and\n               the dimen attribute is not specified yet, use dimen 1 by\n               default */\n            if (set->dimen == 0) set->dimen = 1;\n            break;\n         case A_PARAMETER:\n            /* model parameter */\n            par = (PARAMETER *)avl_get_node_link(node);\n            name = par->name;\n            dim = par->dim;\n            break;\n         case A_VARIABLE:\n            /* model variable */\n            var = (VARIABLE *)avl_get_node_link(node);\n            name = var->name;\n            dim = var->dim;\n            break;\n         case A_CONSTRAINT:\n            /* model constraint or objective */\n            con = (CONSTRAINT *)avl_get_node_link(node);\n            name = con->name;\n            dim = con->dim;\n            break;\n         default:\n            xassert(node != node);\n      }\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional subscript list */\n      if (mpl->token == T_LBRACKET)\n      {  /* subscript list is specified */\n         if (dim == 0)\n            error(mpl, \"%s cannot be subscripted\", name);\n         get_token(mpl /* [ */);\n         list = subscript_list(mpl);\n         if (dim != arg_list_len(mpl, list))\n            error(mpl, \"%s must have %d subscript%s rather than %d\",\n               name, dim, dim == 1 ? \"\" : \"s\", arg_list_len(mpl, list));\n         xassert(mpl->token == T_RBRACKET);\n         get_token(mpl /* ] */);\n      }\n      else\n      {  /* subscript list is not specified */\n         if (dim != 0)\n            error(mpl, \"%s must be subscripted\", name);\n         list = create_arg_list(mpl);\n      }\n      /* parse optional suffix */\n      if (!mpl->flag_s && avl_get_node_type(node) == A_VARIABLE)\n         suff = DOT_NONE;\n      else\n         suff = DOT_VAL;\n      if (mpl->token == T_POINT)\n      {  get_token(mpl /* . */);\n         if (mpl->token != T_NAME)\n            error(mpl, \"invalid use of period\");\n         if (!(avl_get_node_type(node) == A_VARIABLE ||\n               avl_get_node_type(node) == A_CONSTRAINT))\n            error(mpl, \"%s cannot have a suffix\", name);\n         if (strcmp(mpl->image, \"lb\") == 0)\n            suff = DOT_LB;\n         else if (strcmp(mpl->image, \"ub\") == 0)\n            suff = DOT_UB;\n         else if (strcmp(mpl->image, \"status\") == 0)\n            suff = DOT_STATUS;\n         else if (strcmp(mpl->image, \"val\") == 0)\n            suff = DOT_VAL;\n         else if (strcmp(mpl->image, \"dual\") == 0)\n            suff = DOT_DUAL;\n         else\n            error(mpl, \"suffix .%s invalid\", mpl->image);\n         get_token(mpl /* suffix */);\n      }\n      /* generate pseudo-code to take value of the object */\n      switch (avl_get_node_type(node))\n      {  case A_INDEX:\n            arg.index.slot = slot;\n            arg.index.next = slot->list;\n            code = make_code(mpl, O_INDEX, &arg, A_SYMBOLIC, 0);\n            slot->list = code;\n            break;\n         case A_SET:\n            arg.set.set = set;\n            arg.set.list = list;\n            code = make_code(mpl, O_MEMSET, &arg, A_ELEMSET,\n               set->dimen);\n            break;\n         case A_PARAMETER:\n            arg.par.par = par;\n            arg.par.list = list;\n            if (par->type == A_SYMBOLIC)\n               code = make_code(mpl, O_MEMSYM, &arg, A_SYMBOLIC, 0);\n            else\n               code = make_code(mpl, O_MEMNUM, &arg, A_NUMERIC, 0);\n            break;\n         case A_VARIABLE:\n            if (!mpl->flag_s && (suff == DOT_STATUS || suff == DOT_VAL\n               || suff == DOT_DUAL))\n               error(mpl, \"invalid reference to status, primal value, o\"\n                  \"r dual value of variable %s above solve statement\",\n                  var->name);\n            arg.var.var = var;\n            arg.var.list = list;\n            arg.var.suff = suff;\n            code = make_code(mpl, O_MEMVAR, &arg, suff == DOT_NONE ?\n               A_FORMULA : A_NUMERIC, 0);\n            break;\n         case A_CONSTRAINT:\n            if (!mpl->flag_s && (suff == DOT_STATUS || suff == DOT_VAL\n               || suff == DOT_DUAL))\n               error(mpl, \"invalid reference to status, primal value, o\"\n                  \"r dual value of %s %s above solve statement\",\n                  con->type == A_CONSTRAINT ? \"constraint\" : \"objective\"\n                  , con->name);\n            arg.con.con = con;\n            arg.con.list = list;\n            arg.con.suff = suff;\n            code = make_code(mpl, O_MEMCON, &arg, A_NUMERIC, 0);\n            break;\n         default:\n            xassert(node != node);\n      }\n      return code;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "CODE",
        "*object_reference(MPL *mpl)",
        "*"
      ]
    },
    "numeric_argument": {
      "start_point": [
        1095,
        0
      ],
      "end_point": [
        1106,
        1
      ],
      "content": "CODE *numeric_argument(MPL *mpl, char *func)\n{     CODE *x;\n      x = expression_5(mpl);\n      /* convert the argument to numeric type, if necessary */\n      if (x->type == A_SYMBOLIC)\n         x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n      /* check that now the argument is of numeric type */\n      if (x->type != A_NUMERIC)\n         error(mpl, \"argument for %s has invalid type\", func);\n      xassert(x->dim == 0);\n      return x;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "CODE",
        "*numeric_argument(MPL *mpl, char *func)",
        "*"
      ]
    },
    "symbolic_argument": {
      "start_point": [
        1109,
        0
      ],
      "end_point": [
        1120,
        1
      ],
      "content": "CODE *symbolic_argument(MPL *mpl, char *func)\n{     CODE *x;\n      x = expression_5(mpl);\n      /* convert the argument to symbolic type, if necessary */\n      if (x->type == A_NUMERIC)\n         x = make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\n      /* check that now the argument is of symbolic type */\n      if (x->type != A_SYMBOLIC)\n         error(mpl, \"argument for %s has invalid type\", func);\n      xassert(x->dim == 0);\n      return x;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "CODE",
        "*symbolic_argument(MPL *mpl, char *func)",
        "*"
      ]
    },
    "elemset_argument": {
      "start_point": [
        1124,
        0
      ],
      "end_point": [
        1131,
        1
      ],
      "content": "CODE *elemset_argument(MPL *mpl, char *func)\n{     CODE *x;\n      x = expression_9(mpl);\n      if (x->type != A_ELEMSET)\n         error(mpl, \"argument for %s has invalid type\", func);\n      xassert(x->dim > 0);\n      return x;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "CODE",
        "*elemset_argument(MPL *mpl, char *func)",
        "*"
      ]
    },
    "function_reference": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1406,
        1
      ],
      "content": "CODE *function_reference(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      int op;\n      char func[15+1];\n      /* determine operation code */\n      xassert(mpl->token == T_NAME);\n      if (strcmp(mpl->image, \"abs\") == 0)\n         op = O_ABS;\n      else if (strcmp(mpl->image, \"ceil\") == 0)\n         op = O_CEIL;\n      else if (strcmp(mpl->image, \"floor\") == 0)\n         op = O_FLOOR;\n      else if (strcmp(mpl->image, \"exp\") == 0)\n         op = O_EXP;\n      else if (strcmp(mpl->image, \"log\") == 0)\n         op = O_LOG;\n      else if (strcmp(mpl->image, \"log10\") == 0)\n         op = O_LOG10;\n      else if (strcmp(mpl->image, \"sqrt\") == 0)\n         op = O_SQRT;\n      else if (strcmp(mpl->image, \"sin\") == 0)\n         op = O_SIN;\n      else if (strcmp(mpl->image, \"cos\") == 0)\n         op = O_COS;\n      else if (strcmp(mpl->image, \"tan\") == 0)\n         op = O_TAN;\n      else if (strcmp(mpl->image, \"atan\") == 0)\n         op = O_ATAN;\n      else if (strcmp(mpl->image, \"min\") == 0)\n         op = O_MIN;\n      else if (strcmp(mpl->image, \"max\") == 0)\n         op = O_MAX;\n      else if (strcmp(mpl->image, \"round\") == 0)\n         op = O_ROUND;\n      else if (strcmp(mpl->image, \"trunc\") == 0)\n         op = O_TRUNC;\n      else if (strcmp(mpl->image, \"Irand224\") == 0)\n         op = O_IRAND224;\n      else if (strcmp(mpl->image, \"Uniform01\") == 0)\n         op = O_UNIFORM01;\n      else if (strcmp(mpl->image, \"Uniform\") == 0)\n         op = O_UNIFORM;\n      else if (strcmp(mpl->image, \"Normal01\") == 0)\n         op = O_NORMAL01;\n      else if (strcmp(mpl->image, \"Normal\") == 0)\n         op = O_NORMAL;\n      else if (strcmp(mpl->image, \"card\") == 0)\n         op = O_CARD;\n      else if (strcmp(mpl->image, \"length\") == 0)\n         op = O_LENGTH;\n      else if (strcmp(mpl->image, \"substr\") == 0)\n         op = O_SUBSTR;\n      else if (strcmp(mpl->image, \"str2time\") == 0)\n         op = O_STR2TIME;\n      else if (strcmp(mpl->image, \"time2str\") == 0)\n         op = O_TIME2STR;\n      else if (strcmp(mpl->image, \"gmtime\") == 0)\n         op = O_GMTIME;\n      else\n         error(mpl, \"function %s unknown\", mpl->image);\n      /* save symbolic name of the function */\n      strcpy(func, mpl->image);\n      xassert(strlen(func) < sizeof(func));\n      get_token(mpl /* <symbolic name> */);\n      /* check the left parenthesis that follows the function name */\n      xassert(mpl->token == T_LEFT);\n      get_token(mpl /* ( */);\n      /* parse argument list */\n      if (op == O_MIN || op == O_MAX)\n      {  /* min and max allow arbitrary number of arguments */\n         arg.list = create_arg_list(mpl);\n         /* parse argument list */\n         for (;;)\n         {  /* parse argument and append it to the operands list */\n            arg.list = expand_arg_list(mpl, arg.list,\n               numeric_argument(mpl, func));\n            /* check a token that follows the argument */\n            if (mpl->token == T_COMMA)\n               get_token(mpl /* , */);\n            else if (mpl->token == T_RIGHT)\n               break;\n            else\n               error(mpl, \"syntax error in argument list for %s\", func);\n         }\n      }\n      else if (op == O_IRAND224 || op == O_UNIFORM01 || op ==\n         O_NORMAL01 || op == O_GMTIME)\n      {  /* Irand224, Uniform01, Normal01, gmtime need no arguments */\n         if (mpl->token != T_RIGHT)\n            error(mpl, \"%s needs no arguments\", func);\n      }\n      else if (op == O_UNIFORM || op == O_NORMAL)\n      {  /* Uniform and Normal need two arguments */\n         /* parse the first argument */\n         arg.arg.x = numeric_argument(mpl, func);\n         /* check a token that follows the first argument */\n         if (mpl->token == T_COMMA)\n            ;\n         else if (mpl->token == T_RIGHT)\n            error(mpl, \"%s needs two arguments\", func);\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n         get_token(mpl /* , */);\n         /* parse the second argument */\n         arg.arg.y = numeric_argument(mpl, func);\n         /* check a token that follows the second argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs two argument\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      else if (op == O_ATAN || op == O_ROUND || op == O_TRUNC)\n      {  /* atan, round, and trunc need one or two arguments */\n         /* parse the first argument */\n         arg.arg.x = numeric_argument(mpl, func);\n         /* parse the second argument, if specified */\n         if (mpl->token == T_COMMA)\n         {  switch (op)\n            {  case O_ATAN:  op = O_ATAN2;  break;\n               case O_ROUND: op = O_ROUND2; break;\n               case O_TRUNC: op = O_TRUNC2; break;\n               default: xassert(op != op);\n            }\n            get_token(mpl /* , */);\n            arg.arg.y = numeric_argument(mpl, func);\n         }\n         /* check a token that follows the last argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs one or two arguments\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      else if (op == O_SUBSTR)\n      {  /* substr needs two or three arguments */\n         /* parse the first argument */\n         arg.arg.x = symbolic_argument(mpl, func);\n         /* check a token that follows the first argument */\n         if (mpl->token == T_COMMA)\n            ;\n         else if (mpl->token == T_RIGHT)\n            error(mpl, \"%s needs two or three arguments\", func);\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n         get_token(mpl /* , */);\n         /* parse the second argument */\n         arg.arg.y = numeric_argument(mpl, func);\n         /* parse the third argument, if specified */\n         if (mpl->token == T_COMMA)\n         {  op = O_SUBSTR3;\n            get_token(mpl /* , */);\n            arg.arg.z = numeric_argument(mpl, func);\n         }\n         /* check a token that follows the last argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs two or three arguments\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      else if (op == O_STR2TIME)\n      {  /* str2time needs two arguments, both symbolic */\n         /* parse the first argument */\n         arg.arg.x = symbolic_argument(mpl, func);\n         /* check a token that follows the first argument */\n         if (mpl->token == T_COMMA)\n            ;\n         else if (mpl->token == T_RIGHT)\n            error(mpl, \"%s needs two arguments\", func);\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n         get_token(mpl /* , */);\n         /* parse the second argument */\n         arg.arg.y = symbolic_argument(mpl, func);\n         /* check a token that follows the second argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs two argument\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      else if (op == O_TIME2STR)\n      {  /* time2str needs two arguments, numeric and symbolic */\n         /* parse the first argument */\n         arg.arg.x = numeric_argument(mpl, func);\n         /* check a token that follows the first argument */\n         if (mpl->token == T_COMMA)\n            ;\n         else if (mpl->token == T_RIGHT)\n            error(mpl, \"%s needs two arguments\", func);\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n         get_token(mpl /* , */);\n         /* parse the second argument */\n         arg.arg.y = symbolic_argument(mpl, func);\n         /* check a token that follows the second argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs two argument\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      else\n      {  /* other functions need one argument */\n         if (op == O_CARD)\n            arg.arg.x = elemset_argument(mpl, func);\n         else if (op == O_LENGTH)\n            arg.arg.x = symbolic_argument(mpl, func);\n         else\n            arg.arg.x = numeric_argument(mpl, func);\n         /* check a token that follows the argument */\n         if (mpl->token == T_COMMA)\n            error(mpl, \"%s needs one argument\", func);\n         else if (mpl->token == T_RIGHT)\n            ;\n         else\n            error(mpl, \"syntax error in argument for %s\", func);\n      }\n      /* make pseudo-code to call the built-in function */\n      if (op == O_SUBSTR || op == O_SUBSTR3 || op == O_TIME2STR)\n         code = make_code(mpl, op, &arg, A_SYMBOLIC, 0);\n      else\n         code = make_code(mpl, op, &arg, A_NUMERIC, 0);\n      /* the reference ends with the right parenthesis */\n      xassert(mpl->token == T_RIGHT);\n      get_token(mpl /* ) */);\n      return code;\n}",
      "lines": 235,
      "depth": 34,
      "decorators": [
        "CODE",
        "*function_reference(MPL *mpl)",
        "*"
      ]
    },
    "create_domain": {
      "start_point": [
        1414,
        0
      ],
      "end_point": [
        1420,
        1
      ],
      "content": "DOMAIN *create_domain(MPL *mpl)\n{     DOMAIN *domain;\n      domain = alloc(DOMAIN);\n      domain->list = NULL;\n      domain->code = NULL;\n      return domain;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "DOMAIN",
        "*create_domain(MPL *mpl)",
        "*"
      ]
    },
    "create_block": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1436,
        1
      ],
      "content": "DOMAIN_BLOCK *create_block(MPL *mpl)\n{     DOMAIN_BLOCK *block;\n      block = alloc(DOMAIN_BLOCK);\n      block->list = NULL;\n      block->code = NULL;\n      block->backup = NULL;\n      block->next = NULL;\n      return block;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "DOMAIN_BLOCK",
        "*create_block(MPL *mpl)",
        "*"
      ]
    },
    "append_block": {
      "start_point": [
        1444,
        0
      ],
      "end_point": [
        1458,
        1
      ],
      "content": "void append_block(MPL *mpl, DOMAIN *domain, DOMAIN_BLOCK *block)\n{     DOMAIN_BLOCK *temp;\n      xassert(mpl == mpl);\n      xassert(domain != NULL);\n      xassert(block != NULL);\n      xassert(block->next == NULL);\n      if (domain->list == NULL)\n         domain->list = block;\n      else\n      {  for (temp = domain->list; temp->next != NULL; temp =\n            temp->next);\n         temp->next = block;\n      }\n      return;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "append_slot": {
      "start_point": [
        1474,
        0
      ],
      "end_point": [
        1492,
        1
      ],
      "content": "DOMAIN_SLOT *append_slot(MPL *mpl, DOMAIN_BLOCK *block, char *name,\n      CODE *code)\n{     DOMAIN_SLOT *slot, *temp;\n      xassert(block != NULL);\n      slot = alloc(DOMAIN_SLOT);\n      slot->name = name;\n      slot->code = code;\n      slot->value = NULL;\n      slot->list = NULL;\n      slot->next = NULL;\n      if (block->list == NULL)\n         block->list = slot;\n      else\n      {  for (temp = block->list; temp->next != NULL; temp =\n            temp->next);\n         temp->next = slot;\n      }\n      return slot;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "DOMAIN_SLOT",
        "*append_slot(MPL *mpl, DOMAIN_BLOCK *block, char *name,\n      CODE *code)",
        "*"
      ]
    },
    "expression_list": {
      "start_point": [
        1522,
        0
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "CODE *expression_list(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      struct { char *name; CODE *code; } list[1+max_dim];\n      int flag_x, next_token, dim, j, slice = 0;\n      xassert(mpl->token == T_LEFT);\n      /* the flag, which allows recognizing undeclared symbolic names\n         as dummy indices, will be automatically reset by get_token(),\n         so save it before scanning the next token */\n      flag_x = mpl->flag_x;\n      get_token(mpl /* ( */);\n      /* parse <expression list> */\n      for (dim = 1; ; dim++)\n      {  if (dim > max_dim)\n            error(mpl, \"too many components within parentheses\");\n         /* current component of <expression list> can be either dummy\n            index or expression */\n         if (mpl->token == T_NAME)\n         {  /* symbolic name is recognized as dummy index only if:\n               the flag, which allows that, is set, and\n               the name is followed by comma or right parenthesis, and\n               the name is undeclared */\n            get_token(mpl /* <symbolic name> */);\n            next_token = mpl->token;\n            unget_token(mpl);\n            if (!(flag_x &&\n                  (next_token == T_COMMA || next_token == T_RIGHT) &&\n                  avl_find_node(mpl->tree, mpl->image) == NULL))\n            {  /* this is not dummy index */\n               goto expr;\n            }\n            /* all dummy indices within the same slice must have unique\n               symbolic names */\n            for (j = 1; j < dim; j++)\n            {  if (list[j].name != NULL && strcmp(list[j].name,\n                  mpl->image) == 0)\n                  error(mpl, \"duplicate dummy index %s not allowed\",\n                     mpl->image);\n            }\n            /* current component of <expression list> is dummy index */\n            list[dim].name\n               = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n            strcpy(list[dim].name, mpl->image);\n            list[dim].code = NULL;\n            get_token(mpl /* <symbolic name> */);\n            /* <expression list> is a slice, because at least one dummy\n               index has appeared */\n            slice = 1;\n            /* note that the context ( <dummy index> ) is not allowed,\n               i.e. in this case <primary expression> is considered as\n               a parenthesized expression */\n            if (dim == 1 && mpl->token == T_RIGHT)\n               error(mpl, \"%s not defined\", list[dim].name);\n         }\n         else\nexpr:    {  /* current component of <expression list> is expression */\n            code = expression_13(mpl);\n            /* if the current expression is followed by comma or it is\n               not the very first expression, entire <expression list>\n               is n-tuple or slice, in which case the current expression\n               should be converted to symbolic type, if necessary */\n            if (mpl->token == T_COMMA || dim > 1)\n            {  if (code->type == A_NUMERIC)\n                  code = make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\n               /* now the expression must be of symbolic type */\n               if (code->type != A_SYMBOLIC)\n                  error(mpl, \"component expression has invalid type\");\n               xassert(code->dim == 0);\n            }\n            list[dim].name = NULL;\n            list[dim].code = code;\n         }\n         /* check a token that follows the current component */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_RIGHT)\n            break;\n         else\n            error(mpl, \"right parenthesis missing where expected\");\n      }\n      /* generate pseudo-code for <primary expression> */\n      if (dim == 1 && !slice)\n      {  /* <primary expression> is a parenthesized expression */\n         code = list[1].code;\n      }\n      else if (!slice)\n      {  /* <primary expression> is a n-tuple */\n         arg.list = create_arg_list(mpl);\n         for (j = 1; j <= dim; j++)\n            arg.list = expand_arg_list(mpl, arg.list, list[j].code);\n         code = make_code(mpl, O_TUPLE, &arg, A_TUPLE, dim);\n      }\n      else\n      {  /* <primary expression> is a slice */\n         arg.slice = create_block(mpl);\n         for (j = 1; j <= dim; j++)\n            append_slot(mpl, arg.slice, list[j].name, list[j].code);\n         /* note that actually pseudo-codes with op = O_SLICE are never\n            evaluated */\n         code = make_code(mpl, O_SLICE, &arg, A_TUPLE, dim);\n      }\n      get_token(mpl /* ) */);\n      /* if <primary expression> is a slice, there must be the keyword\n         'in', which follows the right parenthesis */\n      if (slice && mpl->token != T_IN)\n         error(mpl, \"keyword in missing where expected\");\n      /* if the slice flag is set and there is the keyword 'in', which\n         follows <primary expression>, the latter must be a slice */\n      if (flag_x && mpl->token == T_IN && !slice)\n      {  if (dim == 1)\n            error(mpl, \"syntax error in indexing expression\");\n         else\n            error(mpl, \"0-ary slice not allowed\");\n      }\n      return code;\n}",
      "lines": 116,
      "depth": 17,
      "decorators": [
        "CODE",
        "*expression_list(MPL *mpl)",
        "*"
      ]
    },
    "literal_set": {
      "start_point": [
        1653,
        0
      ],
      "end_point": [
        1690,
        1
      ],
      "content": "CODE *literal_set(MPL *mpl, CODE *code)\n{     OPERANDS arg;\n      int j;\n      xassert(code != NULL);\n      arg.list = create_arg_list(mpl);\n      /* parse <member list> */\n      for (j = 1; ; j++)\n      {  /* all member expressions must be n-tuples; so, if the current\n            expression is not n-tuple, convert it to 1-tuple */\n         if (code->type == A_NUMERIC)\n            code = make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\n         if (code->type == A_SYMBOLIC)\n            code = make_unary(mpl, O_CVTTUP, code, A_TUPLE, 1);\n         /* now the expression must be n-tuple */\n         if (code->type != A_TUPLE)\n            error(mpl, \"member expression has invalid type\");\n         /* all member expressions must have identical dimension */\n         if (arg.list != NULL && arg.list->x->dim != code->dim)\n            error(mpl, \"member %d has %d component%s while member %d ha\"\n               \"s %d component%s\",\n               j-1, arg.list->x->dim, arg.list->x->dim == 1 ? \"\" : \"s\",\n               j, code->dim, code->dim == 1 ? \"\" : \"s\");\n         /* append the current expression to the member list */\n         arg.list = expand_arg_list(mpl, arg.list, code);\n         /* check a token that follows the current expression */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_RBRACE)\n            break;\n         else\n            error(mpl, \"syntax error in literal set\");\n         /* parse the next expression that follows the comma */\n         code = expression_5(mpl);\n      }\n      /* generate pseudo-code for <literal set> */\n      code = make_code(mpl, O_MAKE, &arg, A_ELEMSET, arg.list->x->dim);\n      return code;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "CODE",
        "*literal_set(MPL *mpl, CODE *code)",
        "*"
      ]
    },
    "indexing_expression": {
      "start_point": [
        1714,
        0
      ],
      "end_point": [
        1872,
        1
      ],
      "content": "DOMAIN *indexing_expression(MPL *mpl)\n{     DOMAIN *domain;\n      DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      CODE *code;\n      xassert(mpl->token == T_LBRACE);\n      get_token(mpl /* { */);\n      if (mpl->token == T_RBRACE)\n         error(mpl, \"empty indexing expression not allowed\");\n      /* create domain to be constructed */\n      domain = create_domain(mpl);\n      /* parse either <member list> or <indexing list> that follows the\n         left brace */\n      for (;;)\n      {  /* domain block for <indexing element> is not created yet */\n         block = NULL;\n         /* pseudo-code for <basic expression> is not generated yet */\n         code = NULL;\n         /* check a token, which <indexing element> begins with */\n         if (mpl->token == T_NAME)\n         {  /* it is a symbolic name */\n            int next_token;\n            char *name;\n            /* symbolic name is recognized as dummy index only if it is\n               followed by the keyword 'in' and not declared */\n            get_token(mpl /* <symbolic name> */);\n            next_token = mpl->token;\n            unget_token(mpl);\n            if (!(next_token == T_IN &&\n                  avl_find_node(mpl->tree, mpl->image) == NULL))\n            {  /* this is not dummy index; the symbolic name begins an\n                  expression, which is either <basic expression> or the\n                  very first <member expression> in <literal set> */\n               goto expr;\n            }\n            /* create domain block with one slot, which is assigned the\n               dummy index */\n            block = create_block(mpl);\n            name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n            strcpy(name, mpl->image);\n            append_slot(mpl, block, name, NULL);\n            get_token(mpl /* <symbolic name> */);\n            /* the keyword 'in' is already checked above */\n            xassert(mpl->token == T_IN);\n            get_token(mpl /* in */);\n            /* <basic expression> that follows the keyword 'in' will be\n               parsed below */\n         }\n         else if (mpl->token == T_LEFT)\n         {  /* it is the left parenthesis; parse expression that begins\n               with this parenthesis (the flag is set in order to allow\n               recognizing slices; see the routine expression_list) */\n            mpl->flag_x = 1;\n            code = expression_9(mpl);\n            if (code->op != O_SLICE)\n            {  /* this is either <basic expression> or the very first\n                  <member expression> in <literal set> */\n               goto expr;\n            }\n            /* this is a slice; besides the corresponding domain block\n               is already created by expression_list() */\n            block = code->arg.slice;\n            code = NULL; /* <basic expression> is not parsed yet */\n            /* the keyword 'in' following the slice is already checked\n               by expression_list() */\n            xassert(mpl->token == T_IN);\n            get_token(mpl /* in */);\n            /* <basic expression> that follows the keyword 'in' will be\n               parsed below */\n         }\nexpr:    /* parse expression that follows either the keyword 'in' (in\n            which case it can be <basic expression) or the left brace\n            (in which case it can be <basic expression> as well as the\n            very first <member expression> in <literal set>); note that\n            this expression can be already parsed above */\n         if (code == NULL) code = expression_9(mpl);\n         /* check the type of the expression just parsed */\n         if (code->type != A_ELEMSET)\n         {  /* it is not <basic expression> and therefore it can only\n               be the very first <member expression> in <literal set>;\n               however, then there must be no dummy index neither slice\n               between the left brace and this expression */\n            if (block != NULL)\n               error(mpl, \"domain expression has invalid type\");\n            /* parse the rest part of <literal set> and make this set\n               be <basic expression>, i.e. the construction {a, b, c}\n               is parsed as it were written as {A}, where A = {a, b, c}\n               is a temporary elemental set */\n            code = literal_set(mpl, code);\n         }\n         /* now pseudo-code for <basic set> has been built */\n         xassert(code != NULL);\n         xassert(code->type == A_ELEMSET);\n         xassert(code->dim > 0);\n         /* if domain block for the current <indexing element> is still\n            not created, create it for fake slice of the same dimension\n            as <basic set> */\n         if (block == NULL)\n         {  int j;\n            block = create_block(mpl);\n            for (j = 1; j <= code->dim; j++)\n               append_slot(mpl, block, NULL, NULL);\n         }\n         /* number of indexing positions in <indexing element> must be\n            the same as dimension of n-tuples in basic set */\n         {  int dim = 0;\n            for (slot = block->list; slot != NULL; slot = slot->next)\n               dim++;\n            if (dim != code->dim)\n               error(mpl,\"%d %s specified for set of dimension %d\",\n                  dim, dim == 1 ? \"index\" : \"indices\", code->dim);\n         }\n         /* store pseudo-code for <basic set> in the domain block */\n         xassert(block->code == NULL);\n         block->code = code;\n         /* and append the domain block to the domain */\n         append_block(mpl, domain, block);\n         /* the current <indexing element> has been completely parsed;\n            include all its dummy indices into the symbolic name table\n            to make them available for referencing from expressions;\n            implicit declarations of dummy indices remain valid while\n            the corresponding domain scope is valid */\n         for (slot = block->list; slot != NULL; slot = slot->next)\n         if (slot->name != NULL)\n         {  AVLNODE *node;\n            xassert(avl_find_node(mpl->tree, slot->name) == NULL);\n            node = avl_insert_node(mpl->tree, slot->name);\n            avl_set_node_type(node, A_INDEX);\n            avl_set_node_link(node, (void *)slot);\n         }\n         /* check a token that follows <indexing element> */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_COLON || mpl->token == T_RBRACE)\n            break;\n         else\n            error(mpl, \"syntax error in indexing expression\");\n      }\n      /* parse <logical expression> that follows the colon */\n      if (mpl->token == T_COLON)\n      {  get_token(mpl /* : */);\n         code = expression_13(mpl);\n         /* convert the expression to logical type, if necessary */\n         if (code->type == A_SYMBOLIC)\n            code = make_unary(mpl, O_CVTNUM, code, A_NUMERIC, 0);\n         if (code->type == A_NUMERIC)\n            code = make_unary(mpl, O_CVTLOG, code, A_LOGICAL, 0);\n         /* now the expression must be of logical type */\n         if (code->type != A_LOGICAL)\n            error(mpl, \"expression following colon has invalid type\");\n         xassert(code->dim == 0);\n         domain->code = code;\n         /* the right brace must follow the logical expression */\n         if (mpl->token != T_RBRACE)\n            error(mpl, \"syntax error in indexing expression\");\n      }\n      get_token(mpl /* } */);\n      return domain;\n}",
      "lines": 159,
      "depth": 16,
      "decorators": [
        "DOMAIN",
        "*indexing_expression(MPL *mpl)",
        "*"
      ]
    },
    "close_scope": {
      "start_point": [
        1881,
        0
      ],
      "end_point": [
        1898,
        1
      ],
      "content": "void close_scope(MPL *mpl, DOMAIN *domain)\n{     DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      AVLNODE *node;\n      xassert(domain != NULL);\n      /* remove all dummy indices from the symbolic names table */\n      for (block = domain->list; block != NULL; block = block->next)\n      {  for (slot = block->list; slot != NULL; slot = slot->next)\n         {  if (slot->name != NULL)\n            {  node = avl_find_node(mpl->tree, slot->name);\n               xassert(node != NULL);\n               xassert(avl_get_node_type(node) == A_INDEX);\n               avl_delete_node(mpl->tree, node);\n            }\n         }\n      }\n      return;\n}",
      "lines": 18,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "link_up": {
      "start_point": [
        1919,
        0
      ],
      "end_point": [
        1938,
        1
      ],
      "content": "static void link_up(CODE *code)\n{     /* if we have something like sum{(i+1,j,k-1) in E} x[i,j,k],\n         where i and k are dummy indices defined out of the iterated\n         expression, we should link up pseudo-code for computing i+1\n         and k-1 to pseudo-code for computing the iterated expression;\n         this is needed to invalidate current value of the iterated\n         expression once i or k have been changed */\n      DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      for (block = code->arg.loop.domain->list; block != NULL;\n         block = block->next)\n      {  for (slot = block->list; slot != NULL; slot = slot->next)\n         {  if (slot->code != NULL)\n            {  xassert(slot->code->up == NULL);\n               slot->code->up = code;\n            }\n         }\n      }\n      return;\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "iterated_expression": {
      "start_point": [
        1941,
        0
      ],
      "end_point": [
        2032,
        1
      ],
      "content": "CODE *iterated_expression(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      int op;\n      char opstr[8];\n      /* determine operation code */\n      xassert(mpl->token == T_NAME);\n      if (strcmp(mpl->image, \"sum\") == 0)\n         op = O_SUM;\n      else if (strcmp(mpl->image, \"prod\") == 0)\n         op = O_PROD;\n      else if (strcmp(mpl->image, \"min\") == 0)\n         op = O_MINIMUM;\n      else if (strcmp(mpl->image, \"max\") == 0)\n         op = O_MAXIMUM;\n      else if (strcmp(mpl->image, \"forall\") == 0)\n         op = O_FORALL;\n      else if (strcmp(mpl->image, \"exists\") == 0)\n         op = O_EXISTS;\n      else if (strcmp(mpl->image, \"setof\") == 0)\n         op = O_SETOF;\n      else\n         error(mpl, \"operator %s unknown\", mpl->image);\n      strcpy(opstr, mpl->image);\n      xassert(strlen(opstr) < sizeof(opstr));\n      get_token(mpl /* <symbolic name> */);\n      /* check the left brace that follows the operator name */\n      xassert(mpl->token == T_LBRACE);\n      /* parse indexing expression that controls iterating */\n      arg.loop.domain = indexing_expression(mpl);\n      /* parse \"integrand\" expression and generate pseudo-code */\n      switch (op)\n      {  case O_SUM:\n         case O_PROD:\n         case O_MINIMUM:\n         case O_MAXIMUM:\n            arg.loop.x = expression_3(mpl);\n            /* convert the integrand to numeric type, if necessary */\n            if (arg.loop.x->type == A_SYMBOLIC)\n               arg.loop.x = make_unary(mpl, O_CVTNUM, arg.loop.x,\n                  A_NUMERIC, 0);\n            /* now the integrand must be of numeric type or linear form\n               (the latter is only allowed for the sum operator) */\n            if (!(arg.loop.x->type == A_NUMERIC ||\n                  op == O_SUM && arg.loop.x->type == A_FORMULA))\nerr:           error(mpl, \"integrand following %s{...} has invalid type\"\n                  , opstr);\n            xassert(arg.loop.x->dim == 0);\n            /* generate pseudo-code */\n            code = make_code(mpl, op, &arg, arg.loop.x->type, 0);\n            break;\n         case O_FORALL:\n         case O_EXISTS:\n            arg.loop.x = expression_12(mpl);\n            /* convert the integrand to logical type, if necessary */\n            if (arg.loop.x->type == A_SYMBOLIC)\n               arg.loop.x = make_unary(mpl, O_CVTNUM, arg.loop.x,\n                  A_NUMERIC, 0);\n            if (arg.loop.x->type == A_NUMERIC)\n               arg.loop.x = make_unary(mpl, O_CVTLOG, arg.loop.x,\n                  A_LOGICAL, 0);\n            /* now the integrand must be of logical type */\n            if (arg.loop.x->type != A_LOGICAL) goto err;\n            xassert(arg.loop.x->dim == 0);\n            /* generate pseudo-code */\n            code = make_code(mpl, op, &arg, A_LOGICAL, 0);\n            break;\n         case O_SETOF:\n            arg.loop.x = expression_5(mpl);\n            /* convert the integrand to 1-tuple, if necessary */\n            if (arg.loop.x->type == A_NUMERIC)\n               arg.loop.x = make_unary(mpl, O_CVTSYM, arg.loop.x,\n                  A_SYMBOLIC, 0);\n            if (arg.loop.x->type == A_SYMBOLIC)\n               arg.loop.x = make_unary(mpl, O_CVTTUP, arg.loop.x,\n                  A_TUPLE, 1);\n            /* now the integrand must be n-tuple */\n            if (arg.loop.x->type != A_TUPLE) goto err;\n            xassert(arg.loop.x->dim > 0);\n            /* generate pseudo-code */\n            code = make_code(mpl, op, &arg, A_ELEMSET, arg.loop.x->dim);\n            break;\n         default:\n            xassert(op != op);\n      }\n      /* close the scope of the indexing expression */\n      close_scope(mpl, arg.loop.domain);\n#if 1 /* 07/IX-2008 */\n      link_up(code);\n#endif\n      return code;\n}",
      "lines": 92,
      "depth": 16,
      "decorators": [
        "CODE",
        "*iterated_expression(MPL *mpl)",
        "*"
      ]
    },
    "domain_arity": {
      "start_point": [
        2040,
        0
      ],
      "end_point": [
        2050,
        1
      ],
      "content": "int domain_arity(MPL *mpl, DOMAIN *domain)\n{     DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      int arity;\n      xassert(mpl == mpl);\n      arity = 0;\n      for (block = domain->list; block != NULL; block = block->next)\n         for (slot = block->list; slot != NULL; slot = slot->next)\n            if (slot->code == NULL) arity++;\n      return arity;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "set_expression": {
      "start_point": [
        2060,
        0
      ],
      "end_point": [
        2089,
        1
      ],
      "content": "CODE *set_expression(MPL *mpl)\n{     CODE *code;\n      OPERANDS arg;\n      xassert(mpl->token == T_LBRACE);\n      get_token(mpl /* { */);\n      /* check a token that follows the left brace */\n      if (mpl->token == T_RBRACE)\n      {  /* it is the right brace, so the resultant is an empty set of\n            dimension 1 */\n         arg.list = NULL;\n         /* generate pseudo-code to build the resultant set */\n         code = make_code(mpl, O_MAKE, &arg, A_ELEMSET, 1);\n         get_token(mpl /* } */);\n      }\n      else\n      {  /* the next token begins an indexing expression */\n         unget_token(mpl);\n         arg.loop.domain = indexing_expression(mpl);\n         arg.loop.x = NULL; /* integrand is not used */\n         /* close the scope of the indexing expression */\n         close_scope(mpl, arg.loop.domain);\n         /* generate pseudo-code to build the resultant set */\n         code = make_code(mpl, O_BUILD, &arg, A_ELEMSET,\n            domain_arity(mpl, arg.loop.domain));\n#if 1 /* 07/IX-2008 */\n         link_up(code);\n#endif\n      }\n      return code;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "CODE",
        "*set_expression(MPL *mpl)",
        "*"
      ]
    },
    "branched_expression": {
      "start_point": [
        2102,
        0
      ],
      "end_point": [
        2169,
        1
      ],
      "content": "CODE *branched_expression(MPL *mpl)\n{     CODE *code, *x, *y, *z;\n      xassert(mpl->token == T_IF);\n      get_token(mpl /* if */);\n      /* parse <logical expression> that follows 'if' */\n      x = expression_13(mpl);\n      /* convert the expression to logical type, if necessary */\n      if (x->type == A_SYMBOLIC)\n         x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n      if (x->type == A_NUMERIC)\n         x = make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\n      /* now the expression must be of logical type */\n      if (x->type != A_LOGICAL)\n         error(mpl, \"expression following if has invalid type\");\n      xassert(x->dim == 0);\n      /* the keyword 'then' must follow the logical expression */\n      if (mpl->token != T_THEN)\n         error(mpl, \"keyword then missing where expected\");\n      get_token(mpl /* then */);\n      /* parse <expression> that follows 'then' and check its type */\n      y = expression_9(mpl);\n      if (!(y->type == A_NUMERIC || y->type == A_SYMBOLIC ||\n            y->type == A_ELEMSET || y->type == A_FORMULA))\n         error(mpl, \"expression following then has invalid type\");\n      /* if the expression that follows the keyword 'then' is elemental\n         set, the keyword 'else' cannot be omitted; otherwise else-part\n         is optional */\n      if (mpl->token != T_ELSE)\n      {  if (y->type == A_ELEMSET)\n            error(mpl, \"keyword else missing where expected\");\n         z = NULL;\n         goto skip;\n      }\n      get_token(mpl /* else */);\n      /* parse <expression> that follow 'else' and check its type */\n      z = expression_9(mpl);\n      if (!(z->type == A_NUMERIC || z->type == A_SYMBOLIC ||\n            z->type == A_ELEMSET || z->type == A_FORMULA))\n         error(mpl, \"expression following else has invalid type\");\n      /* convert to identical types, if necessary */\n      if (y->type == A_FORMULA || z->type == A_FORMULA)\n      {  if (y->type == A_SYMBOLIC)\n            y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n         if (y->type == A_NUMERIC)\n            y = make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\n         if (z->type == A_SYMBOLIC)\n            z = make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\n         if (z->type == A_NUMERIC)\n            z = make_unary(mpl, O_CVTLFM, z, A_FORMULA, 0);\n      }\n      if (y->type == A_SYMBOLIC || z->type == A_SYMBOLIC)\n      {  if (y->type == A_NUMERIC)\n            y = make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\n         if (z->type == A_NUMERIC)\n            z = make_unary(mpl, O_CVTSYM, z, A_SYMBOLIC, 0);\n      }\n      /* now both expressions must have identical types */\n      if (y->type != z->type)\n         error(mpl, \"expressions following then and else have incompati\"\n            \"ble types\");\n      /* and identical dimensions */\n      if (y->dim != z->dim)\n         error(mpl, \"expressions following then and else have different\"\n            \" dimensions %d and %d, respectively\", y->dim, z->dim);\nskip: /* generate pseudo-code to perform branching */\n      code = make_ternary(mpl, O_FORK, x, y, z, y->type, y->dim);\n      return code;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "CODE",
        "*branched_expression(MPL *mpl)",
        "*"
      ]
    },
    "primary_expression": {
      "start_point": [
        2196,
        0
      ],
      "end_point": [
        2259,
        1
      ],
      "content": "CODE *primary_expression(MPL *mpl)\n{     CODE *code;\n      if (mpl->token == T_NUMBER)\n      {  /* parse numeric literal */\n         code = numeric_literal(mpl);\n      }\n#if 1 /* 21/VII-2006 */\n      else if (mpl->token == T_INFINITY)\n      {  /* parse \"infinity\" */\n         OPERANDS arg;\n         arg.num = DBL_MAX;\n         code = make_code(mpl, O_NUMBER, &arg, A_NUMERIC, 0);\n         get_token(mpl /* Infinity */);\n      }\n#endif\n      else if (mpl->token == T_STRING)\n      {  /* parse string literal */\n         code = string_literal(mpl);\n      }\n      else if (mpl->token == T_NAME)\n      {  int next_token;\n         get_token(mpl /* <symbolic name> */);\n         next_token = mpl->token;\n         unget_token(mpl);\n         /* check a token that follows <symbolic name> */\n         switch (next_token)\n         {  case T_LBRACKET:\n               /* parse reference to subscripted object */\n               code = object_reference(mpl);\n               break;\n            case T_LEFT:\n               /* parse reference to built-in function */\n               code = function_reference(mpl);\n               break;\n            case T_LBRACE:\n               /* parse iterated expression */\n               code = iterated_expression(mpl);\n               break;\n            default:\n               /* parse reference to unsubscripted object */\n               code = object_reference(mpl);\n               break;\n         }\n      }\n      else if (mpl->token == T_LEFT)\n      {  /* parse parenthesized expression */\n         code = expression_list(mpl);\n      }\n      else if (mpl->token == T_LBRACE)\n      {  /* parse set expression */\n         code = set_expression(mpl);\n      }\n      else if (mpl->token == T_IF)\n      {  /* parse conditional expression */\n         code = branched_expression(mpl);\n      }\n      else if (is_reserved(mpl))\n      {  /* other reserved keywords cannot be used here */\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      }\n      else\n         error(mpl, \"syntax error in expression\");\n      return code;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "CODE",
        "*primary_expression(MPL *mpl)",
        "*"
      ]
    },
    "error_preceding": {
      "start_point": [
        2267,
        0
      ],
      "end_point": [
        2270,
        1
      ],
      "content": "void error_preceding(MPL *mpl, char *opstr)\n{     error(mpl, \"operand preceding %s has invalid type\", opstr);\n      /* no return */\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "error_following": {
      "start_point": [
        2278,
        0
      ],
      "end_point": [
        2281,
        1
      ],
      "content": "void error_following(MPL *mpl, char *opstr)\n{     error(mpl, \"operand following %s has invalid type\", opstr);\n      /* no return */\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "error_dimension": {
      "start_point": [
        2289,
        0
      ],
      "end_point": [
        2293,
        1
      ],
      "content": "void error_dimension(MPL *mpl, char *opstr, int dim1, int dim2)\n{     error(mpl, \"operands preceding and following %s have different di\"\n         \"mensions %d and %d, respectively\", opstr, dim1, dim2);\n      /* no return */\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "expression_0": {
      "start_point": [
        2302,
        0
      ],
      "end_point": [
        2306,
        1
      ],
      "content": "CODE *expression_0(MPL *mpl)\n{     CODE *code;\n      code = primary_expression(mpl);\n      return code;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "CODE",
        "*expression_0(MPL *mpl)",
        "*"
      ]
    },
    "expression_1": {
      "start_point": [
        2318,
        0
      ],
      "end_point": [
        2341,
        1
      ],
      "content": "CODE *expression_1(MPL *mpl)\n{     CODE *x, *y;\n      char opstr[8];\n      x = expression_0(mpl);\n      if (mpl->token == T_POWER)\n      {  strcpy(opstr, mpl->image);\n         xassert(strlen(opstr) < sizeof(opstr));\n         if (x->type == A_SYMBOLIC)\n            x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n         if (x->type != A_NUMERIC)\n            error_preceding(mpl, opstr);\n         get_token(mpl /* ^ | ** */);\n         if (mpl->token == T_PLUS || mpl->token == T_MINUS)\n            y = expression_2(mpl);\n         else\n            y = expression_1(mpl);\n         if (y->type == A_SYMBOLIC)\n            y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n         if (y->type != A_NUMERIC)\n            error_following(mpl, opstr);\n         x = make_binary(mpl, O_POWER, x, y, A_NUMERIC, 0);\n      }\n      return x;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "CODE",
        "*expression_1(MPL *mpl)",
        "*"
      ]
    },
    "expression_2": {
      "start_point": [
        2352,
        0
      ],
      "end_point": [
        2375,
        1
      ],
      "content": "CODE *expression_2(MPL *mpl)\n{     CODE *x;\n      if (mpl->token == T_PLUS)\n      {  get_token(mpl /* + */);\n         x = expression_1(mpl);\n         if (x->type == A_SYMBOLIC)\n            x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n         if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n            error_following(mpl, \"+\");\n         x = make_unary(mpl, O_PLUS, x, x->type, 0);\n      }\n      else if (mpl->token == T_MINUS)\n      {  get_token(mpl /* - */);\n         x = expression_1(mpl);\n         if (x->type == A_SYMBOLIC)\n            x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n         if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n            error_following(mpl, \"-\");\n         x = make_unary(mpl, O_MINUS, x, x->type, 0);\n      }\n      else\n         x = expression_1(mpl);\n      return x;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "CODE",
        "*expression_2(MPL *mpl)",
        "*"
      ]
    },
    "expression_3": {
      "start_point": [
        2388,
        0
      ],
      "end_point": [
        2456,
        1
      ],
      "content": "CODE *expression_3(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_2(mpl);\n      for (;;)\n      {  if (mpl->token == T_ASTERISK)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n               error_preceding(mpl, \"*\");\n            get_token(mpl /* * */);\n            y = expression_2(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (!(y->type == A_NUMERIC || y->type == A_FORMULA))\n               error_following(mpl, \"*\");\n            if (x->type == A_FORMULA && y->type == A_FORMULA)\n               error(mpl, \"multiplication of linear forms not allowed\");\n            if (x->type == A_NUMERIC && y->type == A_NUMERIC)\n               x = make_binary(mpl, O_MUL, x, y, A_NUMERIC, 0);\n            else\n               x = make_binary(mpl, O_MUL, x, y, A_FORMULA, 0);\n         }\n         else if (mpl->token == T_SLASH)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n               error_preceding(mpl, \"/\");\n            get_token(mpl /* / */);\n            y = expression_2(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type != A_NUMERIC)\n               error_following(mpl, \"/\");\n            if (x->type == A_NUMERIC)\n               x = make_binary(mpl, O_DIV, x, y, A_NUMERIC, 0);\n            else\n               x = make_binary(mpl, O_DIV, x, y, A_FORMULA, 0);\n         }\n         else if (mpl->token == T_DIV)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type != A_NUMERIC)\n               error_preceding(mpl, \"div\");\n            get_token(mpl /* div */);\n            y = expression_2(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type != A_NUMERIC)\n               error_following(mpl, \"div\");\n            x = make_binary(mpl, O_IDIV, x, y, A_NUMERIC, 0);\n         }\n         else if (mpl->token == T_MOD)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type != A_NUMERIC)\n               error_preceding(mpl, \"mod\");\n            get_token(mpl /* mod */);\n            y = expression_2(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type != A_NUMERIC)\n               error_following(mpl, \"mod\");\n            x = make_binary(mpl, O_MOD, x, y, A_NUMERIC, 0);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "CODE",
        "*expression_3(MPL *mpl)",
        "*"
      ]
    },
    "expression_4": {
      "start_point": [
        2468,
        0
      ],
      "end_point": [
        2523,
        1
      ],
      "content": "CODE *expression_4(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_3(mpl);\n      for (;;)\n      {  if (mpl->token == T_PLUS)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n               error_preceding(mpl, \"+\");\n            get_token(mpl /* + */);\n            y = expression_3(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (!(y->type == A_NUMERIC || y->type == A_FORMULA))\n               error_following(mpl, \"+\");\n            if (x->type == A_NUMERIC && y->type == A_FORMULA)\n               x = make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\n            if (x->type == A_FORMULA && y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\n            x = make_binary(mpl, O_ADD, x, y, x->type, 0);\n         }\n         else if (mpl->token == T_MINUS)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (!(x->type == A_NUMERIC || x->type == A_FORMULA))\n               error_preceding(mpl, \"-\");\n            get_token(mpl /* - */);\n            y = expression_3(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (!(y->type == A_NUMERIC || y->type == A_FORMULA))\n               error_following(mpl, \"-\");\n            if (x->type == A_NUMERIC && y->type == A_FORMULA)\n               x = make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\n            if (x->type == A_FORMULA && y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\n            x = make_binary(mpl, O_SUB, x, y, x->type, 0);\n         }\n         else if (mpl->token == T_LESS)\n         {  if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type != A_NUMERIC)\n               error_preceding(mpl, \"less\");\n            get_token(mpl /* less */);\n            y = expression_3(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type != A_NUMERIC)\n               error_following(mpl, \"less\");\n            x = make_binary(mpl, O_LESS, x, y, A_NUMERIC, 0);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "CODE",
        "*expression_4(MPL *mpl)",
        "*"
      ]
    },
    "expression_5": {
      "start_point": [
        2533,
        0
      ],
      "end_point": [
        2554,
        1
      ],
      "content": "CODE *expression_5(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_4(mpl);\n      for (;;)\n      {  if (mpl->token == T_CONCAT)\n         {  if (x->type == A_NUMERIC)\n               x = make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\n            if (x->type != A_SYMBOLIC)\n               error_preceding(mpl, \"&\");\n            get_token(mpl /* & */);\n            y = expression_4(mpl);\n            if (y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\n            if (y->type != A_SYMBOLIC)\n               error_following(mpl, \"&\");\n            x = make_binary(mpl, O_CONCAT, x, y, A_SYMBOLIC, 0);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "CODE",
        "*expression_5(MPL *mpl)",
        "*"
      ]
    },
    "expression_6": {
      "start_point": [
        2566,
        0
      ],
      "end_point": [
        2593,
        1
      ],
      "content": "CODE *expression_6(MPL *mpl)\n{     CODE *x, *y, *z;\n      x = expression_5(mpl);\n      if (mpl->token == T_DOTS)\n      {  if (x->type == A_SYMBOLIC)\n            x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n         if (x->type != A_NUMERIC)\n            error_preceding(mpl, \"..\");\n         get_token(mpl /* .. */);\n         y = expression_5(mpl);\n         if (y->type == A_SYMBOLIC)\n            y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n         if (y->type != A_NUMERIC)\n            error_following(mpl, \"..\");\n         if (mpl->token == T_BY)\n         {  get_token(mpl /* by */);\n            z = expression_5(mpl);\n            if (z->type == A_SYMBOLIC)\n               z = make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\n            if (z->type != A_NUMERIC)\n               error_following(mpl, \"by\");\n         }\n         else\n            z = NULL;\n         x = make_ternary(mpl, O_DOTS, x, y, z, A_ELEMSET, 1);\n      }\n      return x;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "CODE",
        "*expression_6(MPL *mpl)",
        "*"
      ]
    },
    "expression_7": {
      "start_point": [
        2603,
        0
      ],
      "end_point": [
        2621,
        1
      ],
      "content": "CODE *expression_7(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_6(mpl);\n      for (;;)\n      {  if (mpl->token == T_CROSS)\n         {  if (x->type != A_ELEMSET)\n               error_preceding(mpl, \"cross\");\n            get_token(mpl /* cross */);\n            y = expression_6(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, \"cross\");\n            x = make_binary(mpl, O_CROSS, x, y, A_ELEMSET,\n               x->dim + y->dim);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "CODE",
        "*expression_7(MPL *mpl)",
        "*"
      ]
    },
    "expression_8": {
      "start_point": [
        2631,
        0
      ],
      "end_point": [
        2650,
        1
      ],
      "content": "CODE *expression_8(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_7(mpl);\n      for (;;)\n      {  if (mpl->token == T_INTER)\n         {  if (x->type != A_ELEMSET)\n               error_preceding(mpl, \"inter\");\n            get_token(mpl /* inter */);\n            y = expression_7(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, \"inter\");\n            if (x->dim != y->dim)\n               error_dimension(mpl, \"inter\", x->dim, y->dim);\n            x = make_binary(mpl, O_INTER, x, y, A_ELEMSET, x->dim);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "CODE",
        "*expression_8(MPL *mpl)",
        "*"
      ]
    },
    "expression_9": {
      "start_point": [
        2662,
        0
      ],
      "end_point": [
        2703,
        1
      ],
      "content": "CODE *expression_9(MPL *mpl)\n{     CODE *x, *y;\n      x = expression_8(mpl);\n      for (;;)\n      {  if (mpl->token == T_UNION)\n         {  if (x->type != A_ELEMSET)\n               error_preceding(mpl, \"union\");\n            get_token(mpl /* union */);\n            y = expression_8(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, \"union\");\n            if (x->dim != y->dim)\n               error_dimension(mpl, \"union\", x->dim, y->dim);\n            x = make_binary(mpl, O_UNION, x, y, A_ELEMSET, x->dim);\n         }\n         else if (mpl->token == T_DIFF)\n         {  if (x->type != A_ELEMSET)\n               error_preceding(mpl, \"diff\");\n            get_token(mpl /* diff */);\n            y = expression_8(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, \"diff\");\n            if (x->dim != y->dim)\n               error_dimension(mpl, \"diff\", x->dim, y->dim);\n            x = make_binary(mpl, O_DIFF, x, y, A_ELEMSET, x->dim);\n         }\n         else if (mpl->token == T_SYMDIFF)\n         {  if (x->type != A_ELEMSET)\n               error_preceding(mpl, \"symdiff\");\n            get_token(mpl /* symdiff */);\n            y = expression_8(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, \"symdiff\");\n            if (x->dim != y->dim)\n               error_dimension(mpl, \"symdiff\", x->dim, y->dim);\n            x = make_binary(mpl, O_SYMDIFF, x, y, A_ELEMSET, x->dim);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "CODE",
        "*expression_9(MPL *mpl)",
        "*"
      ]
    },
    "expression_10": {
      "start_point": [
        2715,
        0
      ],
      "end_point": [
        2825,
        1
      ],
      "content": "CODE *expression_10(MPL *mpl)\n{     CODE *x, *y;\n      int op = -1;\n      char opstr[16];\n      x = expression_9(mpl);\n      strcpy(opstr, \"\");\n      switch (mpl->token)\n      {  case T_LT:\n            op = O_LT; break;\n         case T_LE:\n            op = O_LE; break;\n         case T_EQ:\n            op = O_EQ; break;\n         case T_GE:\n            op = O_GE; break;\n         case T_GT:\n            op = O_GT; break;\n         case T_NE:\n            op = O_NE; break;\n         case T_IN:\n            op = O_IN; break;\n         case T_WITHIN:\n            op = O_WITHIN; break;\n         case T_NOT:\n            strcpy(opstr, mpl->image);\n            get_token(mpl /* not | ! */);\n            if (mpl->token == T_IN)\n               op = O_NOTIN;\n            else if (mpl->token == T_WITHIN)\n               op = O_NOTWITHIN;\n            else\n               error(mpl, \"invalid use of %s\", opstr);\n            strcat(opstr, \" \");\n            break;\n         default:\n            goto done;\n      }\n      strcat(opstr, mpl->image);\n      xassert(strlen(opstr) < sizeof(opstr));\n      switch (op)\n      {  case O_EQ:\n         case O_NE:\n#if 1 /* 02/VIII-2008 */\n         case O_LT:\n         case O_LE:\n         case O_GT:\n         case O_GE:\n#endif\n            if (!(x->type == A_NUMERIC || x->type == A_SYMBOLIC))\n               error_preceding(mpl, opstr);\n            get_token(mpl /* <rho> */);\n            y = expression_9(mpl);\n            if (!(y->type == A_NUMERIC || y->type == A_SYMBOLIC))\n               error_following(mpl, opstr);\n            if (x->type == A_NUMERIC && y->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\n            if (x->type == A_SYMBOLIC && y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\n            x = make_binary(mpl, op, x, y, A_LOGICAL, 0);\n            break;\n#if 0 /* 02/VIII-2008 */\n         case O_LT:\n         case O_LE:\n         case O_GT:\n         case O_GE:\n            if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type != A_NUMERIC)\n               error_preceding(mpl, opstr);\n            get_token(mpl /* <rho> */);\n            y = expression_9(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type != A_NUMERIC)\n               error_following(mpl, opstr);\n            x = make_binary(mpl, op, x, y, A_LOGICAL, 0);\n            break;\n#endif\n         case O_IN:\n         case O_NOTIN:\n            if (x->type == A_NUMERIC)\n               x = make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\n            if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTTUP, x, A_TUPLE, 1);\n            if (x->type != A_TUPLE)\n               error_preceding(mpl, opstr);\n            get_token(mpl /* <rho> */);\n            y = expression_9(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, opstr);\n            if (x->dim != y->dim)\n               error_dimension(mpl, opstr, x->dim, y->dim);\n            x = make_binary(mpl, op, x, y, A_LOGICAL, 0);\n            break;\n         case O_WITHIN:\n         case O_NOTWITHIN:\n            if (x->type != A_ELEMSET)\n               error_preceding(mpl, opstr);\n            get_token(mpl /* <rho> */);\n            y = expression_9(mpl);\n            if (y->type != A_ELEMSET)\n               error_following(mpl, opstr);\n            if (x->dim != y->dim)\n               error_dimension(mpl, opstr, x->dim, y->dim);\n            x = make_binary(mpl, op, x, y, A_LOGICAL, 0);\n            break;\n         default:\n            xassert(op != op);\n      }\ndone: return x;\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "CODE",
        "*expression_10(MPL *mpl)",
        "*"
      ]
    },
    "expression_11": {
      "start_point": [
        2836,
        0
      ],
      "end_point": [
        2855,
        1
      ],
      "content": "CODE *expression_11(MPL *mpl)\n{     CODE *x;\n      char opstr[8];\n      if (mpl->token == T_NOT)\n      {  strcpy(opstr, mpl->image);\n         xassert(strlen(opstr) < sizeof(opstr));\n         get_token(mpl /* not | ! */);\n         x = expression_10(mpl);\n         if (x->type == A_SYMBOLIC)\n            x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n         if (x->type == A_NUMERIC)\n            x = make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\n         if (x->type != A_LOGICAL)\n            error_following(mpl, opstr);\n         x = make_unary(mpl, O_NOT, x, A_LOGICAL, 0);\n      }\n      else\n         x = expression_10(mpl);\n      return x;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "CODE",
        "*expression_11(MPL *mpl)",
        "*"
      ]
    },
    "expression_12": {
      "start_point": [
        2866,
        0
      ],
      "end_point": [
        2894,
        1
      ],
      "content": "CODE *expression_12(MPL *mpl)\n{     CODE *x, *y;\n      char opstr[8];\n      x = expression_11(mpl);\n      for (;;)\n      {  if (mpl->token == T_AND)\n         {  strcpy(opstr, mpl->image);\n            xassert(strlen(opstr) < sizeof(opstr));\n            if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type == A_NUMERIC)\n               x = make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\n            if (x->type != A_LOGICAL)\n               error_preceding(mpl, opstr);\n            get_token(mpl /* and | && */);\n            y = expression_11(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\n            if (y->type != A_LOGICAL)\n               error_following(mpl, opstr);\n            x = make_binary(mpl, O_AND, x, y, A_LOGICAL, 0);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "CODE",
        "*expression_12(MPL *mpl)",
        "*"
      ]
    },
    "expression_13": {
      "start_point": [
        2905,
        0
      ],
      "end_point": [
        2933,
        1
      ],
      "content": "CODE *expression_13(MPL *mpl)\n{     CODE *x, *y;\n      char opstr[8];\n      x = expression_12(mpl);\n      for (;;)\n      {  if (mpl->token == T_OR)\n         {  strcpy(opstr, mpl->image);\n            xassert(strlen(opstr) < sizeof(opstr));\n            if (x->type == A_SYMBOLIC)\n               x = make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\n            if (x->type == A_NUMERIC)\n               x = make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\n            if (x->type != A_LOGICAL)\n               error_preceding(mpl, opstr);\n            get_token(mpl /* or | || */);\n            y = expression_12(mpl);\n            if (y->type == A_SYMBOLIC)\n               y = make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\n            if (y->type == A_NUMERIC)\n               y = make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\n            if (y->type != A_LOGICAL)\n               error_following(mpl, opstr);\n            x = make_binary(mpl, O_OR, x, y, A_LOGICAL, 0);\n         }\n         else\n            break;\n      }\n      return x;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "CODE",
        "*expression_13(MPL *mpl)",
        "*"
      ]
    },
    "set_statement": {
      "start_point": [
        2954,
        0
      ],
      "end_point": [
        3174,
        1
      ],
      "content": "SET *set_statement(MPL *mpl)\n{     SET *set;\n      int dimen_used = 0;\n      xassert(is_keyword(mpl, \"set\"));\n      get_token(mpl /* set */);\n      /* symbolic name must follow the keyword 'set' */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create model set */\n      set = alloc(SET);\n      set->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(set->name, mpl->image);\n      set->alias = NULL;\n      set->dim = 0;\n      set->domain = NULL;\n      set->dimen = 0;\n      set->within = NULL;\n      set->assign = NULL;\n      set->option = NULL;\n      set->gadget = NULL;\n      set->data = 0;\n      set->array = NULL;\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  set->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(set->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  set->domain = indexing_expression(mpl);\n         set->dim = domain_arity(mpl, set->domain);\n      }\n      /* include the set name in the symbolic names table */\n      {  AVLNODE *node;\n         node = avl_insert_node(mpl->tree, set->name);\n         avl_set_node_type(node, A_SET);\n         avl_set_node_link(node, (void *)set);\n      }\n      /* parse the list of optional attributes */\n      for (;;)\n      {  if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_SEMICOLON)\n            break;\n         if (is_keyword(mpl, \"dimen\"))\n         {  /* dimension of set members */\n            int dimen;\n            get_token(mpl /* dimen */);\n            if (!(mpl->token == T_NUMBER &&\n                  1.0 <= mpl->value && mpl->value <= 20.0 &&\n                  floor(mpl->value) == mpl->value))\n               error(mpl, \"dimension must be integer between 1 and 20\");\n            dimen = (int)(mpl->value + 0.5);\n            if (dimen_used)\n               error(mpl, \"at most one dimension attribute allowed\");\n            if (set->dimen > 0)\n               error(mpl, \"dimension %d conflicts with dimension %d alr\"\n                  \"eady determined\", dimen, set->dimen);\n            set->dimen = dimen;\n            dimen_used = 1;\n            get_token(mpl /* <numeric literal> */);\n         }\n         else if (mpl->token == T_WITHIN || mpl->token == T_IN)\n         {  /* restricting superset */\n            WITHIN *within, *temp;\n            if (mpl->token == T_IN && !mpl->as_within)\n            {  warning(mpl, \"keyword in understood as within\");\n               mpl->as_within = 1;\n            }\n            get_token(mpl /* within */);\n            /* create new restricting superset list entry and append it\n               to the within-list */\n            within = alloc(WITHIN);\n            within->code = NULL;\n            within->next = NULL;\n            if (set->within == NULL)\n               set->within = within;\n            else\n            {  for (temp = set->within; temp->next != NULL; temp =\n                  temp->next);\n               temp->next = within;\n            }\n            /* parse an expression that follows 'within' */\n            within->code = expression_9(mpl);\n            if (within->code->type != A_ELEMSET)\n               error(mpl, \"expression following within has invalid type\"\n                  );\n            xassert(within->code->dim > 0);\n            /* check/set dimension of set members */\n            if (set->dimen == 0) set->dimen = within->code->dim;\n            if (set->dimen != within->code->dim)\n               error(mpl, \"set expression following within must have di\"\n                  \"mension %d rather than %d\",\n                  set->dimen, within->code->dim);\n         }\n         else if (mpl->token == T_ASSIGN)\n         {  /* assignment expression */\n            if (!(set->assign == NULL && set->option == NULL &&\n                  set->gadget == NULL))\nerr:           error(mpl, \"at most one := or default/data allowed\");\n            get_token(mpl /* := */);\n            /* parse an expression that follows ':=' */\n            set->assign = expression_9(mpl);\n            if (set->assign->type != A_ELEMSET)\n               error(mpl, \"expression following := has invalid type\");\n            xassert(set->assign->dim > 0);\n            /* check/set dimension of set members */\n            if (set->dimen == 0) set->dimen = set->assign->dim;\n            if (set->dimen != set->assign->dim)\n               error(mpl, \"set expression following := must have dimens\"\n                  \"ion %d rather than %d\",\n                  set->dimen, set->assign->dim);\n         }\n         else if (is_keyword(mpl, \"default\"))\n         {  /* expression for default value */\n            if (!(set->assign == NULL && set->option == NULL)) goto err;\n            get_token(mpl /* := */);\n            /* parse an expression that follows 'default' */\n            set->option = expression_9(mpl);\n            if (set->option->type != A_ELEMSET)\n               error(mpl, \"expression following default has invalid typ\"\n                  \"e\");\n            xassert(set->option->dim > 0);\n            /* check/set dimension of set members */\n            if (set->dimen == 0) set->dimen = set->option->dim;\n            if (set->dimen != set->option->dim)\n               error(mpl, \"set expression following default must have d\"\n                  \"imension %d rather than %d\",\n                  set->dimen, set->option->dim);\n         }\n#if 1 /* 12/XII-2008 */\n         else if (is_keyword(mpl, \"data\"))\n         {  /* gadget to initialize the set by data from plain set */\n            GADGET *gadget;\n            AVLNODE *node;\n            int i, k, fff[20];\n            if (!(set->assign == NULL && set->gadget == NULL)) goto err;\n            get_token(mpl /* data */);\n            set->gadget = gadget = alloc(GADGET);\n            /* set name must follow the keyword 'data' */\n            if (mpl->token == T_NAME)\n               ;\n            else if (is_reserved(mpl))\n               error(mpl, \"invalid use of reserved keyword %s\",\n                  mpl->image);\n            else\n               error(mpl, \"set name missing where expected\");\n            /* find the set in the symbolic name table */\n            node = avl_find_node(mpl->tree, mpl->image);\n            if (node == NULL)\n               error(mpl, \"%s not defined\", mpl->image);\n            if (avl_get_node_type(node) != A_SET)\nerr1:          error(mpl, \"%s not a plain set\", mpl->image);\n            gadget->set = avl_get_node_link(node);\n            if (gadget->set->dim != 0) goto err1;\n            if (gadget->set == set)\n               error(mpl, \"set cannot be initialized by itself\");\n            /* check and set dimensions */\n            if (set->dim >= gadget->set->dimen)\nerr2:          error(mpl, \"dimension of %s too small\", mpl->image);\n            if (set->dimen == 0)\n               set->dimen = gadget->set->dimen - set->dim;\n            if (set->dim + set->dimen > gadget->set->dimen)\n               goto err2;\n            else if (set->dim + set->dimen < gadget->set->dimen)\n               error(mpl, \"dimension of %s too big\", mpl->image);\n            get_token(mpl /* set name */);\n            /* left parenthesis must follow the set name */\n            if (mpl->token == T_LEFT)\n               get_token(mpl /* ( */);\n            else\n               error(mpl, \"left parenthesis missing where expected\");\n            /* parse permutation of component numbers */\n            for (k = 0; k < gadget->set->dimen; k++) fff[k] = 0;\n            k = 0;\n            for (;;)\n            {  if (mpl->token != T_NUMBER)\n                  error(mpl, \"component number missing where expected\");\n               if (str2int(mpl->image, &i) != 0)\nerr3:             error(mpl, \"component number must be integer between \"\n                     \"1 and %d\", gadget->set->dimen);\n               if (!(1 <= i && i <= gadget->set->dimen)) goto err3;\n               if (fff[i-1] != 0)\n                  error(mpl, \"component %d multiply specified\", i);\n               gadget->ind[k++] = i, fff[i-1] = 1;\n               xassert(k <= gadget->set->dimen);\n               get_token(mpl /* number */);\n               if (mpl->token == T_COMMA)\n                  get_token(mpl /* , */);\n               else if (mpl->token == T_RIGHT)\n                  break;\n               else\n                  error(mpl, \"syntax error in data attribute\");\n            }\n            if (k < gadget->set->dimen)\n               error(mpl, \"there are must be %d components rather than \"\n                  \"%d\", gadget->set->dimen, k);\n            get_token(mpl /* ) */);\n         }\n#endif\n         else\n            error(mpl, \"syntax error in set statement\");\n      }\n      /* close the domain scope */\n      if (set->domain != NULL) close_scope(mpl, set->domain);\n      /* if dimension of set members is still unknown, set it to 1 */\n      if (set->dimen == 0) set->dimen = 1;\n      /* the set statement has been completely parsed */\n      xassert(mpl->token == T_SEMICOLON);\n      get_token(mpl /* ; */);\n      return set;\n}",
      "lines": 221,
      "depth": 18,
      "decorators": [
        "SET",
        "*set_statement(MPL *mpl)",
        "*"
      ]
    },
    "parameter_statement": {
      "start_point": [
        3199,
        0
      ],
      "end_point": [
        3434,
        1
      ],
      "content": "PARAMETER *parameter_statement(MPL *mpl)\n{     PARAMETER *par;\n      int integer_used = 0, binary_used = 0, symbolic_used = 0;\n      xassert(is_keyword(mpl, \"param\"));\n      get_token(mpl /* param */);\n      /* symbolic name must follow the keyword 'param' */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create model parameter */\n      par = alloc(PARAMETER);\n      par->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(par->name, mpl->image);\n      par->alias = NULL;\n      par->dim = 0;\n      par->domain = NULL;\n      par->type = A_NUMERIC;\n      par->cond = NULL;\n      par->in = NULL;\n      par->assign = NULL;\n      par->option = NULL;\n      par->data = 0;\n      par->defval = NULL;\n      par->array = NULL;\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  par->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(par->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  par->domain = indexing_expression(mpl);\n         par->dim = domain_arity(mpl, par->domain);\n      }\n      /* include the parameter name in the symbolic names table */\n      {  AVLNODE *node;\n         node = avl_insert_node(mpl->tree, par->name);\n         avl_set_node_type(node, A_PARAMETER);\n         avl_set_node_link(node, (void *)par);\n      }\n      /* parse the list of optional attributes */\n      for (;;)\n      {  if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_SEMICOLON)\n            break;\n         if (is_keyword(mpl, \"integer\"))\n         {  if (integer_used)\n               error(mpl, \"at most one integer allowed\");\n            if (par->type == A_SYMBOLIC)\n               error(mpl, \"symbolic parameter cannot be integer\");\n            if (par->type != A_BINARY) par->type = A_INTEGER;\n            integer_used = 1;\n            get_token(mpl /* integer */);\n         }\n         else if (is_keyword(mpl, \"binary\"))\nbin:     {  if (binary_used)\n               error(mpl, \"at most one binary allowed\");\n            if (par->type == A_SYMBOLIC)\n               error(mpl, \"symbolic parameter cannot be binary\");\n            par->type = A_BINARY;\n            binary_used = 1;\n            get_token(mpl /* binary */);\n         }\n         else if (is_keyword(mpl, \"logical\"))\n         {  if (!mpl->as_binary)\n            {  warning(mpl, \"keyword logical understood as binary\");\n               mpl->as_binary = 1;\n            }\n            goto bin;\n         }\n         else if (is_keyword(mpl, \"symbolic\"))\n         {  if (symbolic_used)\n               error(mpl, \"at most one symbolic allowed\");\n            if (par->type != A_NUMERIC)\n               error(mpl, \"integer or binary parameter cannot be symbol\"\n                  \"ic\");\n            /* the parameter may be referenced from expressions given\n               in the same parameter declaration, so its type must be\n               completed before parsing that expressions */\n            if (!(par->cond == NULL && par->in == NULL &&\n                  par->assign == NULL && par->option == NULL))\n               error(mpl, \"keyword symbolic must precede any other para\"\n                  \"meter attributes\");\n            par->type = A_SYMBOLIC;\n            symbolic_used = 1;\n            get_token(mpl /* symbolic */);\n         }\n         else if (mpl->token == T_LT || mpl->token == T_LE ||\n                  mpl->token == T_EQ || mpl->token == T_GE ||\n                  mpl->token == T_GT || mpl->token == T_NE)\n         {  /* restricting condition */\n            CONDITION *cond, *temp;\n            char opstr[8];\n            /* create new restricting condition list entry and append\n               it to the conditions list */\n            cond = alloc(CONDITION);\n            switch (mpl->token)\n            {  case T_LT:\n                  cond->rho = O_LT, strcpy(opstr, mpl->image); break;\n               case T_LE:\n                  cond->rho = O_LE, strcpy(opstr, mpl->image); break;\n               case T_EQ:\n                  cond->rho = O_EQ, strcpy(opstr, mpl->image); break;\n               case T_GE:\n                  cond->rho = O_GE, strcpy(opstr, mpl->image); break;\n               case T_GT:\n                  cond->rho = O_GT, strcpy(opstr, mpl->image); break;\n               case T_NE:\n                  cond->rho = O_NE, strcpy(opstr, mpl->image); break;\n               default:\n                  xassert(mpl->token != mpl->token);\n            }\n            xassert(strlen(opstr) < sizeof(opstr));\n            cond->code = NULL;\n            cond->next = NULL;\n            if (par->cond == NULL)\n               par->cond = cond;\n            else\n            {  for (temp = par->cond; temp->next != NULL; temp =\n                  temp->next);\n               temp->next = cond;\n            }\n#if 0 /* 13/VIII-2008 */\n            if (par->type == A_SYMBOLIC &&\n               !(cond->rho == O_EQ || cond->rho == O_NE))\n               error(mpl, \"inequality restriction not allowed\");\n#endif\n            get_token(mpl /* rho */);\n            /* parse an expression that follows relational operator */\n            cond->code = expression_5(mpl);\n            if (!(cond->code->type == A_NUMERIC ||\n                  cond->code->type == A_SYMBOLIC))\n               error(mpl, \"expression following %s has invalid type\",\n                  opstr);\n            xassert(cond->code->dim == 0);\n            /* convert to the parameter type, if necessary */\n            if (par->type != A_SYMBOLIC && cond->code->type ==\n               A_SYMBOLIC)\n               cond->code = make_unary(mpl, O_CVTNUM, cond->code,\n                  A_NUMERIC, 0);\n            if (par->type == A_SYMBOLIC && cond->code->type !=\n               A_SYMBOLIC)\n               cond->code = make_unary(mpl, O_CVTSYM, cond->code,\n                  A_SYMBOLIC, 0);\n         }\n         else if (mpl->token == T_IN || mpl->token == T_WITHIN)\n         {  /* restricting superset */\n            WITHIN *in, *temp;\n            if (mpl->token == T_WITHIN && !mpl->as_in)\n            {  warning(mpl, \"keyword within understood as in\");\n               mpl->as_in = 1;\n            }\n            get_token(mpl /* in */);\n            /* create new restricting superset list entry and append it\n               to the in-list */\n            in = alloc(WITHIN);\n            in->code = NULL;\n            in->next = NULL;\n            if (par->in == NULL)\n               par->in = in;\n            else\n            {  for (temp = par->in; temp->next != NULL; temp =\n                  temp->next);\n               temp->next = in;\n            }\n            /* parse an expression that follows 'in' */\n            in->code = expression_9(mpl);\n            if (in->code->type != A_ELEMSET)\n               error(mpl, \"expression following in has invalid type\");\n            xassert(in->code->dim > 0);\n            if (in->code->dim != 1)\n               error(mpl, \"set expression following in must have dimens\"\n                  \"ion 1 rather than %d\", in->code->dim);\n         }\n         else if (mpl->token == T_ASSIGN)\n         {  /* assignment expression */\n            if (!(par->assign == NULL && par->option == NULL))\nerr:           error(mpl, \"at most one := or default allowed\");\n            get_token(mpl /* := */);\n            /* parse an expression that follows ':=' */\n            par->assign = expression_5(mpl);\n            /* the expression must be of numeric/symbolic type */\n            if (!(par->assign->type == A_NUMERIC ||\n                  par->assign->type == A_SYMBOLIC))\n               error(mpl, \"expression following := has invalid type\");\n            xassert(par->assign->dim == 0);\n            /* convert to the parameter type, if necessary */\n            if (par->type != A_SYMBOLIC && par->assign->type ==\n               A_SYMBOLIC)\n               par->assign = make_unary(mpl, O_CVTNUM, par->assign,\n                  A_NUMERIC, 0);\n            if (par->type == A_SYMBOLIC && par->assign->type !=\n               A_SYMBOLIC)\n               par->assign = make_unary(mpl, O_CVTSYM, par->assign,\n                  A_SYMBOLIC, 0);\n         }\n         else if (is_keyword(mpl, \"default\"))\n         {  /* expression for default value */\n            if (!(par->assign == NULL && par->option == NULL)) goto err;\n            get_token(mpl /* default */);\n            /* parse an expression that follows 'default' */\n            par->option = expression_5(mpl);\n            if (!(par->option->type == A_NUMERIC ||\n                  par->option->type == A_SYMBOLIC))\n               error(mpl, \"expression following default has invalid typ\"\n                  \"e\");\n            xassert(par->option->dim == 0);\n            /* convert to the parameter type, if necessary */\n            if (par->type != A_SYMBOLIC && par->option->type ==\n               A_SYMBOLIC)\n               par->option = make_unary(mpl, O_CVTNUM, par->option,\n                  A_NUMERIC, 0);\n            if (par->type == A_SYMBOLIC && par->option->type !=\n               A_SYMBOLIC)\n               par->option = make_unary(mpl, O_CVTSYM, par->option,\n                  A_SYMBOLIC, 0);\n         }\n         else\n            error(mpl, \"syntax error in parameter statement\");\n      }\n      /* close the domain scope */\n      if (par->domain != NULL) close_scope(mpl, par->domain);\n      /* the parameter statement has been completely parsed */\n      xassert(mpl->token == T_SEMICOLON);\n      get_token(mpl /* ; */);\n      return par;\n}",
      "lines": 236,
      "depth": 22,
      "decorators": [
        "PARAMETER",
        "*parameter_statement(MPL *mpl)",
        "*"
      ]
    },
    "variable_statement": {
      "start_point": [
        3455,
        0
      ],
      "end_point": [
        3608,
        1
      ],
      "content": "VARIABLE *variable_statement(MPL *mpl)\n{     VARIABLE *var;\n      int integer_used = 0, binary_used = 0;\n      xassert(is_keyword(mpl, \"var\"));\n      if (mpl->flag_s)\n         error(mpl, \"variable statement must precede solve statement\");\n      get_token(mpl /* var */);\n      /* symbolic name must follow the keyword 'var' */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create model variable */\n      var = alloc(VARIABLE);\n      var->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(var->name, mpl->image);\n      var->alias = NULL;\n      var->dim = 0;\n      var->domain = NULL;\n      var->type = A_NUMERIC;\n      var->lbnd = NULL;\n      var->ubnd = NULL;\n      var->array = NULL;\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  var->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(var->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  var->domain = indexing_expression(mpl);\n         var->dim = domain_arity(mpl, var->domain);\n      }\n      /* include the variable name in the symbolic names table */\n      {  AVLNODE *node;\n         node = avl_insert_node(mpl->tree, var->name);\n         avl_set_node_type(node, A_VARIABLE);\n         avl_set_node_link(node, (void *)var);\n      }\n      /* parse the list of optional attributes */\n      for (;;)\n      {  if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_SEMICOLON)\n            break;\n         if (is_keyword(mpl, \"integer\"))\n         {  if (integer_used)\n               error(mpl, \"at most one integer allowed\");\n            if (var->type != A_BINARY) var->type = A_INTEGER;\n            integer_used = 1;\n            get_token(mpl /* integer */);\n         }\n         else if (is_keyword(mpl, \"binary\"))\nbin:     {  if (binary_used)\n               error(mpl, \"at most one binary allowed\");\n            var->type = A_BINARY;\n            binary_used = 1;\n            get_token(mpl /* binary */);\n         }\n         else if (is_keyword(mpl, \"logical\"))\n         {  if (!mpl->as_binary)\n            {  warning(mpl, \"keyword logical understood as binary\");\n               mpl->as_binary = 1;\n            }\n            goto bin;\n         }\n         else if (is_keyword(mpl, \"symbolic\"))\n            error(mpl, \"variable cannot be symbolic\");\n         else if (mpl->token == T_GE)\n         {  /* lower bound */\n            if (var->lbnd != NULL)\n            {  if (var->lbnd == var->ubnd)\n                  error(mpl, \"both fixed value and lower bound not allo\"\n                     \"wed\");\n               else\n                  error(mpl, \"at most one lower bound allowed\");\n            }\n            get_token(mpl /* >= */);\n            /* parse an expression that specifies the lower bound */\n            var->lbnd = expression_5(mpl);\n            if (var->lbnd->type == A_SYMBOLIC)\n               var->lbnd = make_unary(mpl, O_CVTNUM, var->lbnd,\n                  A_NUMERIC, 0);\n            if (var->lbnd->type != A_NUMERIC)\n               error(mpl, \"expression following >= has invalid type\");\n            xassert(var->lbnd->dim == 0);\n         }\n         else if (mpl->token == T_LE)\n         {  /* upper bound */\n            if (var->ubnd != NULL)\n            {  if (var->ubnd == var->lbnd)\n                  error(mpl, \"both fixed value and upper bound not allo\"\n                     \"wed\");\n               else\n                  error(mpl, \"at most one upper bound allowed\");\n            }\n            get_token(mpl /* <= */);\n            /* parse an expression that specifies the upper bound */\n            var->ubnd = expression_5(mpl);\n            if (var->ubnd->type == A_SYMBOLIC)\n               var->ubnd = make_unary(mpl, O_CVTNUM, var->ubnd,\n                  A_NUMERIC, 0);\n            if (var->ubnd->type != A_NUMERIC)\n               error(mpl, \"expression following <= has invalid type\");\n            xassert(var->ubnd->dim == 0);\n         }\n         else if (mpl->token == T_EQ)\n         {  /* fixed value */\n            char opstr[8];\n            if (!(var->lbnd == NULL && var->ubnd == NULL))\n            {  if (var->lbnd == var->ubnd)\n                  error(mpl, \"at most one fixed value allowed\");\n               else if (var->lbnd != NULL)\n                  error(mpl, \"both lower bound and fixed value not allo\"\n                     \"wed\");\n               else\n                  error(mpl, \"both upper bound and fixed value not allo\"\n                     \"wed\");\n            }\n            strcpy(opstr, mpl->image);\n            xassert(strlen(opstr) < sizeof(opstr));\n            get_token(mpl /* = | == */);\n            /* parse an expression that specifies the fixed value */\n            var->lbnd = expression_5(mpl);\n            if (var->lbnd->type == A_SYMBOLIC)\n               var->lbnd = make_unary(mpl, O_CVTNUM, var->lbnd,\n                  A_NUMERIC, 0);\n            if (var->lbnd->type != A_NUMERIC)\n               error(mpl, \"expression following %s has invalid type\",\n                  opstr);\n            xassert(var->lbnd->dim == 0);\n            /* indicate that the variable is fixed, not bounded */\n            var->ubnd = var->lbnd;\n         }\n         else if (mpl->token == T_LT || mpl->token == T_GT ||\n                  mpl->token == T_NE)\n            error(mpl, \"strict bound not allowed\");\n         else\n            error(mpl, \"syntax error in variable statement\");\n      }\n      /* close the domain scope */\n      if (var->domain != NULL) close_scope(mpl, var->domain);\n      /* the variable statement has been completely parsed */\n      xassert(mpl->token == T_SEMICOLON);\n      get_token(mpl /* ; */);\n      return var;\n}",
      "lines": 154,
      "depth": 22,
      "decorators": [
        "VARIABLE",
        "*variable_statement(MPL *mpl)",
        "*"
      ]
    },
    "constraint_statement": {
      "start_point": [
        3634,
        0
      ],
      "end_point": [
        3828,
        1
      ],
      "content": "CONSTRAINT *constraint_statement(MPL *mpl)\n{     CONSTRAINT *con;\n      CODE *first, *second, *third;\n      int rho;\n      char opstr[8];\n      if (mpl->flag_s)\n         error(mpl, \"constraint statement must precede solve statement\")\n            ;\n      if (is_keyword(mpl, \"subject\"))\n      {  get_token(mpl /* subject */);\n         if (!is_keyword(mpl, \"to\"))\n            error(mpl, \"keyword subject to incomplete\");\n         get_token(mpl /* to */);\n      }\n      else if (is_keyword(mpl, \"subj\"))\n      {  get_token(mpl /* subj */);\n         if (!is_keyword(mpl, \"to\"))\n            error(mpl, \"keyword subj to incomplete\");\n         get_token(mpl /* to */);\n      }\n      else if (mpl->token == T_SPTP)\n         get_token(mpl /* s.t. */);\n      /* the current token must be symbolic name of constraint */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create model constraint */\n      con = alloc(CONSTRAINT);\n      con->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(con->name, mpl->image);\n      con->alias = NULL;\n      con->dim = 0;\n      con->domain = NULL;\n      con->type = A_CONSTRAINT;\n      con->code = NULL;\n      con->lbnd = NULL;\n      con->ubnd = NULL;\n      con->array = NULL;\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  con->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(con->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  con->domain = indexing_expression(mpl);\n         con->dim = domain_arity(mpl, con->domain);\n      }\n      /* include the constraint name in the symbolic names table */\n      {  AVLNODE *node;\n         node = avl_insert_node(mpl->tree, con->name);\n         avl_set_node_type(node, A_CONSTRAINT);\n         avl_set_node_link(node, (void *)con);\n      }\n      /* the colon must precede the first expression */\n      if (mpl->token != T_COLON)\n         error(mpl, \"colon missing where expected\");\n      get_token(mpl /* : */);\n      /* parse the first expression */\n      first = expression_5(mpl);\n      if (first->type == A_SYMBOLIC)\n         first = make_unary(mpl, O_CVTNUM, first, A_NUMERIC, 0);\n      if (!(first->type == A_NUMERIC || first->type == A_FORMULA))\n         error(mpl, \"expression following colon has invalid type\");\n      xassert(first->dim == 0);\n      /* relational operator must follow the first expression */\n      if (mpl->token == T_COMMA) get_token(mpl /* , */);\n      switch (mpl->token)\n      {  case T_LE:\n         case T_GE:\n         case T_EQ:\n            break;\n         case T_LT:\n         case T_GT:\n         case T_NE:\n            error(mpl, \"strict inequality not allowed\");\n         case T_SEMICOLON:\n            error(mpl, \"constraint must be equality or inequality\");\n         default:\n            goto err;\n      }\n      rho = mpl->token;\n      strcpy(opstr, mpl->image);\n      xassert(strlen(opstr) < sizeof(opstr));\n      get_token(mpl /* rho */);\n      /* parse the second expression */\n      second = expression_5(mpl);\n      if (second->type == A_SYMBOLIC)\n         second = make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\n      if (!(second->type == A_NUMERIC || second->type == A_FORMULA))\n         error(mpl, \"expression following %s has invalid type\", opstr);\n      xassert(second->dim == 0);\n      /* check a token that follow the second expression */\n      if (mpl->token == T_COMMA)\n      {  get_token(mpl /* , */);\n         if (mpl->token == T_SEMICOLON) goto err;\n      }\n      if (mpl->token == T_LT || mpl->token == T_LE ||\n          mpl->token == T_EQ || mpl->token == T_GE ||\n          mpl->token == T_GT || mpl->token == T_NE)\n      {  /* it is another relational operator, therefore the constraint\n            is double inequality */\n         if (rho == T_EQ || mpl->token != rho)\n            error(mpl, \"double inequality must be ... <= ... <= ... or \"\n               \"... >= ... >= ...\");\n         /* the first expression cannot be linear form */\n         if (first->type == A_FORMULA)\n            error(mpl, \"leftmost expression in double inequality cannot\"\n               \" be linear form\");\n         get_token(mpl /* rho */);\n         /* parse the third expression */\n         third = expression_5(mpl);\n         if (third->type == A_SYMBOLIC)\n            third = make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\n         if (!(third->type == A_NUMERIC || third->type == A_FORMULA))\n            error(mpl, \"rightmost expression in double inequality const\"\n               \"raint has invalid type\");\n         xassert(third->dim == 0);\n         /* the third expression also cannot be linear form */\n         if (third->type == A_FORMULA)\n            error(mpl, \"rightmost expression in double inequality canno\"\n               \"t be linear form\");\n      }\n      else\n      {  /* the constraint is equality or single inequality */\n         third = NULL;\n      }\n      /* close the domain scope */\n      if (con->domain != NULL) close_scope(mpl, con->domain);\n      /* convert all expressions to linear form, if necessary */\n      if (first->type != A_FORMULA)\n         first = make_unary(mpl, O_CVTLFM, first, A_FORMULA, 0);\n      if (second->type != A_FORMULA)\n         second = make_unary(mpl, O_CVTLFM, second, A_FORMULA, 0);\n      if (third != NULL)\n         third = make_unary(mpl, O_CVTLFM, third, A_FORMULA, 0);\n      /* arrange expressions in the constraint */\n      if (third == NULL)\n      {  /* the constraint is equality or single inequality */\n         switch (rho)\n         {  case T_LE:\n               /* first <= second */\n               con->code = first;\n               con->lbnd = NULL;\n               con->ubnd = second;\n               break;\n            case T_GE:\n               /* first >= second */\n               con->code = first;\n               con->lbnd = second;\n               con->ubnd = NULL;\n               break;\n            case T_EQ:\n               /* first = second */\n               con->code = first;\n               con->lbnd = second;\n               con->ubnd = second;\n               break;\n            default:\n               xassert(rho != rho);\n         }\n      }\n      else\n      {  /* the constraint is double inequality */\n         switch (rho)\n         {  case T_LE:\n               /* first <= second <= third */\n               con->code = second;\n               con->lbnd = first;\n               con->ubnd = third;\n               break;\n            case T_GE:\n               /* first >= second >= third */\n               con->code = second;\n               con->lbnd = third;\n               con->ubnd = first;\n               break;\n            default:\n               xassert(rho != rho);\n         }\n      }\n      /* the constraint statement has been completely parsed */\n      if (mpl->token != T_SEMICOLON)\nerr:     error(mpl, \"syntax error in constraint statement\");\n      get_token(mpl /* ; */);\n      return con;\n}",
      "lines": 195,
      "depth": 13,
      "decorators": [
        "CONSTRAINT",
        "*constraint_statement(MPL *mpl)",
        "*"
      ]
    },
    "objective_statement": {
      "start_point": [
        3845,
        0
      ],
      "end_point": [
        3917,
        1
      ],
      "content": "CONSTRAINT *objective_statement(MPL *mpl)\n{     CONSTRAINT *obj;\n      int type;\n      if (is_keyword(mpl, \"minimize\"))\n         type = A_MINIMIZE;\n      else if (is_keyword(mpl, \"maximize\"))\n         type = A_MAXIMIZE;\n      else\n         xassert(mpl != mpl);\n      if (mpl->flag_s)\n         error(mpl, \"objective statement must precede solve statement\");\n      get_token(mpl /* minimize | maximize */);\n      /* symbolic name must follow the verb 'minimize' or 'maximize' */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create model objective */\n      obj = alloc(CONSTRAINT);\n      obj->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(obj->name, mpl->image);\n      obj->alias = NULL;\n      obj->dim = 0;\n      obj->domain = NULL;\n      obj->type = type;\n      obj->code = NULL;\n      obj->lbnd = NULL;\n      obj->ubnd = NULL;\n      obj->array = NULL;\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  obj->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(obj->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  obj->domain = indexing_expression(mpl);\n         obj->dim = domain_arity(mpl, obj->domain);\n      }\n      /* include the constraint name in the symbolic names table */\n      {  AVLNODE *node;\n         node = avl_insert_node(mpl->tree, obj->name);\n         avl_set_node_type(node, A_CONSTRAINT);\n         avl_set_node_link(node, (void *)obj);\n      }\n      /* the colon must precede the objective expression */\n      if (mpl->token != T_COLON)\n         error(mpl, \"colon missing where expected\");\n      get_token(mpl /* : */);\n      /* parse the objective expression */\n      obj->code = expression_5(mpl);\n      if (obj->code->type == A_SYMBOLIC)\n         obj->code = make_unary(mpl, O_CVTNUM, obj->code, A_NUMERIC, 0);\n      if (obj->code->type == A_NUMERIC)\n         obj->code = make_unary(mpl, O_CVTLFM, obj->code, A_FORMULA, 0);\n      if (obj->code->type != A_FORMULA)\n         error(mpl, \"expression following colon has invalid type\");\n      xassert(obj->code->dim == 0);\n      /* close the domain scope */\n      if (obj->domain != NULL) close_scope(mpl, obj->domain);\n      /* the objective statement has been completely parsed */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in objective statement\");\n      get_token(mpl /* ; */);\n      return obj;\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "CONSTRAINT",
        "*objective_statement(MPL *mpl)",
        "*"
      ]
    },
    "table_statement": {
      "start_point": [
        3954,
        0
      ],
      "end_point": [
        4229,
        1
      ],
      "content": "TABLE *table_statement(MPL *mpl)\n{     TABLE *tab;\n      TABARG *last_arg, *arg;\n      TABFLD *last_fld, *fld;\n      TABIN *last_in, *in;\n      TABOUT *last_out, *out;\n      AVLNODE *node;\n      int nflds;\n      char name[MAX_LENGTH+1];\n      xassert(is_keyword(mpl, \"table\"));\n      get_token(mpl /* solve */);\n      /* symbolic name must follow the keyword table */\n      if (mpl->token == T_NAME)\n         ;\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"symbolic name missing where expected\");\n      /* there must be no other object with the same name */\n      if (avl_find_node(mpl->tree, mpl->image) != NULL)\n         error(mpl, \"%s multiply declared\", mpl->image);\n      /* create data table */\n      tab = alloc(TABLE);\n      tab->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n      strcpy(tab->name, mpl->image);\n      get_token(mpl /* <symbolic name> */);\n      /* parse optional alias */\n      if (mpl->token == T_STRING)\n      {  tab->alias = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(tab->alias, mpl->image);\n         get_token(mpl /* <string literal> */);\n      }\n      else\n         tab->alias = NULL;\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  /* this is output table */\n         tab->type = A_OUTPUT;\n         tab->u.out.domain = indexing_expression(mpl);\n         if (!is_keyword(mpl, \"OUT\"))\n            error(mpl, \"keyword OUT missing where expected\");\n         get_token(mpl /* OUT */);\n      }\n      else\n      {  /* this is input table */\n         tab->type = A_INPUT;\n         if (!is_keyword(mpl, \"IN\"))\n            error(mpl, \"keyword IN missing where expected\");\n         get_token(mpl /* IN */);\n      }\n      /* parse argument list */\n      tab->arg = last_arg = NULL;\n      for (;;)\n      {  /* create argument list entry */\n         arg = alloc(TABARG);\n         /* parse argument expression */\n         if (mpl->token == T_COMMA || mpl->token == T_COLON ||\n             mpl->token == T_SEMICOLON)\n            error(mpl, \"argument expression missing where expected\");\n         arg->code = expression_5(mpl);\n         /* convert the result to symbolic type, if necessary */\n         if (arg->code->type == A_NUMERIC)\n            arg->code =\n               make_unary(mpl, O_CVTSYM, arg->code, A_SYMBOLIC, 0);\n         /* check that now the result is of symbolic type */\n         if (arg->code->type != A_SYMBOLIC)\n            error(mpl, \"argument expression has invalid type\");\n         /* add the entry to the end of the list */\n         arg->next = NULL;\n         if (last_arg == NULL)\n            tab->arg = arg;\n         else\n            last_arg->next = arg;\n         last_arg = arg;\n         /* argument expression has been parsed */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_COLON || mpl->token == T_SEMICOLON)\n            break;\n      }\n      xassert(tab->arg != NULL);\n      /* argument list must end with colon */\n      if (mpl->token == T_COLON)\n         get_token(mpl /* : */);\n      else\n         error(mpl, \"colon missing where expected\");\n      /* parse specific part of the table statement */\n      switch (tab->type)\n      {  case A_INPUT:  goto input_table;\n         case A_OUTPUT: goto output_table;\n         default:       xassert(tab != tab);\n      }\ninput_table:\n      /* parse optional set name */\n      if (mpl->token == T_NAME)\n      {  node = avl_find_node(mpl->tree, mpl->image);\n         if (node == NULL)\n            error(mpl, \"%s not defined\", mpl->image);\n         if (avl_get_node_type(node) != A_SET)\n            error(mpl, \"%s not a set\", mpl->image);\n         tab->u.in.set = (SET *)avl_get_node_link(node);\n         if (tab->u.in.set->assign != NULL)\n            error(mpl, \"%s needs no data\", mpl->image);\n         if (tab->u.in.set->dim != 0)\n            error(mpl, \"%s must be a simple set\", mpl->image);\n         get_token(mpl /* <symbolic name> */);\n         if (mpl->token == T_INPUT)\n            get_token(mpl /* <- */);\n         else\n            error(mpl, \"delimiter <- missing where expected\");\n      }\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         tab->u.in.set = NULL;\n      /* parse field list */\n      tab->u.in.fld = last_fld = NULL;\n      nflds = 0;\n      if (mpl->token == T_LBRACKET)\n         get_token(mpl /* [ */);\n      else\n         error(mpl, \"field list missing where expected\");\n      for (;;)\n      {  /* create field list entry */\n         fld = alloc(TABFLD);\n         /* parse field name */\n         if (mpl->token == T_NAME)\n            ;\n         else if (is_reserved(mpl))\n            error(mpl,\n               \"invalid use of reserved keyword %s\", mpl->image);\n         else\n            error(mpl, \"field name missing where expected\");\n         fld->name = dmp_get_atomv(mpl->pool, strlen(mpl->image)+1);\n         strcpy(fld->name, mpl->image);\n         get_token(mpl /* <symbolic name> */);\n         /* add the entry to the end of the list */\n         fld->next = NULL;\n         if (last_fld == NULL)\n            tab->u.in.fld = fld;\n         else\n            last_fld->next = fld;\n         last_fld = fld;\n         nflds++;\n         /* field name has been parsed */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_RBRACKET)\n            break;\n         else\n            error(mpl, \"syntax error in field list\");\n      }\n      /* check that the set dimen is equal to the number of fields */\n      if (tab->u.in.set != NULL && tab->u.in.set->dimen != nflds)\n         error(mpl, \"there must be %d field%s rather than %d\",\n            tab->u.in.set->dimen, tab->u.in.set->dimen == 1 ? \"\" : \"s\",\n            nflds);\n      get_token(mpl /* ] */);\n      /* parse optional input list */\n      tab->u.in.list = last_in = NULL;\n      while (mpl->token == T_COMMA)\n      {  get_token(mpl /* , */);\n         /* create input list entry */\n         in = alloc(TABIN);\n         /* parse parameter name */\n         if (mpl->token == T_NAME)\n            ;\n         else if (is_reserved(mpl))\n            error(mpl,\n               \"invalid use of reserved keyword %s\", mpl->image);\n         else\n            error(mpl, \"parameter name missing where expected\");\n         node = avl_find_node(mpl->tree, mpl->image);\n         if (node == NULL)\n            error(mpl, \"%s not defined\", mpl->image);\n         if (avl_get_node_type(node) != A_PARAMETER)\n            error(mpl, \"%s not a parameter\", mpl->image);\n         in->par = (PARAMETER *)avl_get_node_link(node);\n         if (in->par->dim != nflds)\n            error(mpl, \"%s must have %d subscript%s rather than %d\",\n               mpl->image, nflds, nflds == 1 ? \"\" : \"s\", in->par->dim);\n         if (in->par->assign != NULL)\n            error(mpl, \"%s needs no data\", mpl->image);\n         get_token(mpl /* <symbolic name> */);\n         /* parse optional field name */\n         if (mpl->token == T_TILDE)\n         {  get_token(mpl /* ~ */);\n            /* parse field name */\n            if (mpl->token == T_NAME)\n               ;\n            else if (is_reserved(mpl))\n               error(mpl,\n                  \"invalid use of reserved keyword %s\", mpl->image);\n            else\n               error(mpl, \"field name missing where expected\");\n            xassert(strlen(mpl->image) < sizeof(name));\n            strcpy(name, mpl->image);\n            get_token(mpl /* <symbolic name> */);\n         }\n         else\n         {  /* field name is the same as the parameter name */\n            xassert(strlen(in->par->name) < sizeof(name));\n            strcpy(name, in->par->name);\n         }\n         /* assign field name */\n         in->name = dmp_get_atomv(mpl->pool, strlen(name)+1);\n         strcpy(in->name, name);\n         /* add the entry to the end of the list */\n         in->next = NULL;\n         if (last_in == NULL)\n            tab->u.in.list = in;\n         else\n            last_in->next = in;\n         last_in = in;\n      }\n      goto end_of_table;\noutput_table:\n      /* parse output list */\n      tab->u.out.list = last_out = NULL;\n      for (;;)\n      {  /* create output list entry */\n         out = alloc(TABOUT);\n         /* parse expression */\n         if (mpl->token == T_COMMA || mpl->token == T_SEMICOLON)\n            error(mpl, \"expression missing where expected\");\n         if (mpl->token == T_NAME)\n         {  xassert(strlen(mpl->image) < sizeof(name));\n            strcpy(name, mpl->image);\n         }\n         else\n            name[0] = '\\0';\n         out->code = expression_5(mpl);\n         /* parse optional field name */\n         if (mpl->token == T_TILDE)\n         {  get_token(mpl /* ~ */);\n            /* parse field name */\n            if (mpl->token == T_NAME)\n               ;\n            else if (is_reserved(mpl))\n               error(mpl,\n                  \"invalid use of reserved keyword %s\", mpl->image);\n            else\n               error(mpl, \"field name missing where expected\");\n            xassert(strlen(mpl->image) < sizeof(name));\n            strcpy(name, mpl->image);\n            get_token(mpl /* <symbolic name> */);\n         }\n         /* assign field name */\n         if (name[0] == '\\0')\n            error(mpl, \"field name required\");\n         out->name = dmp_get_atomv(mpl->pool, strlen(name)+1);\n         strcpy(out->name, name);\n         /* add the entry to the end of the list */\n         out->next = NULL;\n         if (last_out == NULL)\n            tab->u.out.list = out;\n         else\n            last_out->next = out;\n         last_out = out;\n         /* output item has been parsed */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == T_SEMICOLON)\n            break;\n         else\n            error(mpl, \"syntax error in output list\");\n      }\n      /* close the domain scope */\n      close_scope(mpl,tab->u.out.domain);\nend_of_table:\n      /* the table statement must end with semicolon */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in table statement\");\n      get_token(mpl /* ; */);\n      return tab;\n}",
      "lines": 276,
      "depth": 15,
      "decorators": [
        "TABLE",
        "*table_statement(MPL *mpl)",
        "*"
      ]
    },
    "solve_statement": {
      "start_point": [
        4241,
        0
      ],
      "end_point": [
        4252,
        1
      ],
      "content": "void *solve_statement(MPL *mpl)\n{     xassert(is_keyword(mpl, \"solve\"));\n      if (mpl->flag_s)\n         error(mpl, \"at most one solve statement allowed\");\n      mpl->flag_s = 1;\n      get_token(mpl /* solve */);\n      /* semicolon must follow solve statement */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in solve statement\");\n      get_token(mpl /* ; */);\n      return NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "*solve_statement(MPL *mpl)",
        "*"
      ]
    },
    "check_statement": {
      "start_point": [
        4265,
        0
      ],
      "end_point": [
        4295,
        1
      ],
      "content": "CHECK *check_statement(MPL *mpl)\n{     CHECK *chk;\n      xassert(is_keyword(mpl, \"check\"));\n      /* create check descriptor */\n      chk = alloc(CHECK);\n      chk->domain = NULL;\n      chk->code = NULL;\n      get_token(mpl /* check */);\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  chk->domain = indexing_expression(mpl);\n#if 0\n         if (mpl->token != T_COLON)\n            error(mpl, \"colon missing where expected\");\n#endif\n      }\n      /* skip optional colon */\n      if (mpl->token == T_COLON) get_token(mpl /* : */);\n      /* parse logical expression */\n      chk->code = expression_13(mpl);\n      if (chk->code->type != A_LOGICAL)\n         error(mpl, \"expression has invalid type\");\n      xassert(chk->code->dim == 0);\n      /* close the domain scope */\n      if (chk->domain != NULL) close_scope(mpl, chk->domain);\n      /* the check statement has been completely parsed */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in check statement\");\n      get_token(mpl /* ; */);\n      return chk;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "CHECK",
        "*check_statement(MPL *mpl)",
        "*"
      ]
    },
    "display_statement": {
      "start_point": [
        4320,
        0
      ],
      "end_point": [
        4410,
        1
      ],
      "content": "DISPLAY *display_statement(MPL *mpl)\n{     DISPLAY *dpy;\n      DISPLAY1 *entry, *last_entry;\n      xassert(is_keyword(mpl, \"display\"));\n      /* create display descriptor */\n      dpy = alloc(DISPLAY);\n      dpy->domain = NULL;\n      dpy->list = last_entry = NULL;\n      get_token(mpl /* display */);\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n         dpy->domain = indexing_expression(mpl);\n      /* skip optional colon */\n      if (mpl->token == T_COLON) get_token(mpl /* : */);\n      /* parse display list */\n      for (;;)\n      {  /* create new display entry */\n         entry = alloc(DISPLAY1);\n         entry->type = 0;\n         entry->next = NULL;\n         /* and append it to the display list */\n         if (dpy->list == NULL)\n            dpy->list = entry;\n         else\n            last_entry->next = entry;\n         last_entry = entry;\n         /* parse display entry */\n         if (mpl->token == T_NAME)\n         {  AVLNODE *node;\n            int next_token;\n            get_token(mpl /* <symbolic name> */);\n            next_token = mpl->token;\n            unget_token(mpl);\n            if (!(next_token == T_COMMA || next_token == T_SEMICOLON))\n            {  /* symbolic name begins expression */\n               goto expr;\n            }\n            /* display entry is dummy index or model object */\n            node = avl_find_node(mpl->tree, mpl->image);\n            if (node == NULL)\n               error(mpl, \"%s not defined\", mpl->image);\n            entry->type = avl_get_node_type(node);\n            switch (avl_get_node_type(node))\n            {  case A_INDEX:\n                  entry->u.slot =\n                     (DOMAIN_SLOT *)avl_get_node_link(node);\n                  break;\n               case A_SET:\n                  entry->u.set = (SET *)avl_get_node_link(node);\n                  break;\n               case A_PARAMETER:\n                  entry->u.par = (PARAMETER *)avl_get_node_link(node);\n                  break;\n               case A_VARIABLE:\n                  entry->u.var = (VARIABLE *)avl_get_node_link(node);\n                  if (!mpl->flag_s)\n                     error(mpl, \"invalid reference to variable %s above\"\n                        \" solve statement\", entry->u.var->name);\n                  break;\n               case A_CONSTRAINT:\n                  entry->u.con = (CONSTRAINT *)avl_get_node_link(node);\n                  if (!mpl->flag_s)\n                     error(mpl, \"invalid reference to %s %s above solve\"\n                        \" statement\",\n                        entry->u.con->type == A_CONSTRAINT ?\n                        \"constraint\" : \"objective\", entry->u.con->name);\n                  break;\n               default:\n                  xassert(node != node);\n            }\n            get_token(mpl /* <symbolic name> */);\n         }\n         else\nexpr:    {  /* display entry is expression */\n            entry->type = A_EXPRESSION;\n            entry->u.code = expression_13(mpl);\n         }\n         /* check a token that follows the entry parsed */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else\n            break;\n      }\n      /* close the domain scope */\n      if (dpy->domain != NULL) close_scope(mpl, dpy->domain);\n      /* the display statement has been completely parsed */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in display statement\");\n      get_token(mpl /* ; */);\n      return dpy;\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "DISPLAY",
        "*display_statement(MPL *mpl)",
        "*"
      ]
    },
    "printf_statement": {
      "start_point": [
        4431,
        0
      ],
      "end_point": [
        4504,
        1
      ],
      "content": "PRINTF *printf_statement(MPL *mpl)\n{     PRINTF *prt;\n      PRINTF1 *entry, *last_entry;\n      xassert(is_keyword(mpl, \"printf\"));\n      /* create printf descriptor */\n      prt = alloc(PRINTF);\n      prt->domain = NULL;\n      prt->fmt = NULL;\n      prt->list = last_entry = NULL;\n      get_token(mpl /* printf */);\n      /* parse optional indexing expression */\n      if (mpl->token == T_LBRACE)\n      {  prt->domain = indexing_expression(mpl);\n#if 0\n         if (mpl->token != T_COLON)\n            error(mpl, \"colon missing where expected\");\n#endif\n      }\n      /* skip optional colon */\n      if (mpl->token == T_COLON) get_token(mpl /* : */);\n      /* parse expression for format string */\n      prt->fmt = expression_5(mpl);\n      /* convert it to symbolic type, if necessary */\n      if (prt->fmt->type == A_NUMERIC)\n         prt->fmt = make_unary(mpl, O_CVTSYM, prt->fmt, A_SYMBOLIC, 0);\n      /* check that now the expression is of symbolic type */\n      if (prt->fmt->type != A_SYMBOLIC)\n         error(mpl, \"format expression has invalid type\");\n      /* parse printf list */\n      while (mpl->token == T_COMMA)\n      {  get_token(mpl /* , */);\n         /* create new printf entry */\n         entry = alloc(PRINTF1);\n         entry->code = NULL;\n         entry->next = NULL;\n         /* and append it to the printf list */\n         if (prt->list == NULL)\n            prt->list = entry;\n         else\n            last_entry->next = entry;\n         last_entry = entry;\n         /* parse printf entry */\n         entry->code = expression_9(mpl);\n         if (!(entry->code->type == A_NUMERIC ||\n               entry->code->type == A_SYMBOLIC ||\n               entry->code->type == A_LOGICAL))\n            error(mpl, \"only numeric, symbolic, or logical expression a\"\n               \"llowed\");\n      }\n      /* close the domain scope */\n      if (prt->domain != NULL) close_scope(mpl, prt->domain);\n#if 1 /* 14/VII-2006 */\n      /* parse optional redirection */\n      prt->fname = NULL, prt->app = 0;\n      if (mpl->token == T_GT || mpl->token == T_APPEND)\n      {  prt->app = (mpl->token == T_APPEND);\n         get_token(mpl /* > or >> */);\n         /* parse expression for file name string */\n         prt->fname = expression_5(mpl);\n         /* convert it to symbolic type, if necessary */\n         if (prt->fname->type == A_NUMERIC)\n            prt->fname = make_unary(mpl, O_CVTSYM, prt->fname,\n               A_SYMBOLIC, 0);\n         /* check that now the expression is of symbolic type */\n         if (prt->fname->type != A_SYMBOLIC)\n            error(mpl, \"file name expression has invalid type\");\n      }\n#endif\n      /* the printf statement has been completely parsed */\n      if (mpl->token != T_SEMICOLON)\n         error(mpl, \"syntax error in printf statement\");\n      get_token(mpl /* ; */);\n      return prt;\n}",
      "lines": 74,
      "depth": 14,
      "decorators": [
        "PRINTF",
        "*printf_statement(MPL *mpl)",
        "*"
      ]
    },
    "for_statement": {
      "start_point": [
        4521,
        0
      ],
      "end_point": [
        4561,
        1
      ],
      "content": "FOR *for_statement(MPL *mpl)\n{     FOR *fur;\n      STATEMENT *stmt, *last_stmt;\n      xassert(is_keyword(mpl, \"for\"));\n      /* create for descriptor */\n      fur = alloc(FOR);\n      fur->domain = NULL;\n      fur->list = last_stmt = NULL;\n      get_token(mpl /* for */);\n      /* parse indexing expression */\n      if (mpl->token != T_LBRACE)\n         error(mpl, \"indexing expression missing where expected\");\n      fur->domain = indexing_expression(mpl);\n      /* skip optional colon */\n      if (mpl->token == T_COLON) get_token(mpl /* : */);\n      /* parse for statement body */\n      if (mpl->token != T_LBRACE)\n      {  /* parse simple statement */\n         fur->list = simple_statement(mpl, 1);\n      }\n      else\n      {  /* parse compound statement */\n         get_token(mpl /* { */);\n         while (mpl->token != T_RBRACE)\n         {  /* parse statement */\n            stmt = simple_statement(mpl, 1);\n            /* and append it to the end of the statement list */\n            if (last_stmt == NULL)\n               fur->list = stmt;\n            else\n               last_stmt->next = stmt;\n            last_stmt = stmt;\n         }\n         get_token(mpl /* } */);\n      }\n      /* close the domain scope */\n      xassert(fur->domain != NULL);\n      close_scope(mpl, fur->domain);\n      /* the for statement has been completely parsed */\n      return fur;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "FOR",
        "*for_statement(MPL *mpl)",
        "*"
      ]
    },
    "end_statement": {
      "start_point": [
        4570,
        0
      ],
      "end_point": [
        4587,
        1
      ],
      "content": "void end_statement(MPL *mpl)\n{     if (!mpl->flag_d && is_keyword(mpl, \"end\") ||\n           mpl->flag_d && is_literal(mpl, \"end\"))\n      {  get_token(mpl /* end */);\n         if (mpl->token == T_SEMICOLON)\n            get_token(mpl /* ; */);\n         else\n            warning(mpl, \"no semicolon following end statement; missing\"\n               \" semicolon inserted\");\n      }\n      else\n         warning(mpl, \"unexpected end of file; missing end statement in\"\n            \"serted\");\n      if (mpl->token != T_EOF)\n         warning(mpl, \"some text detected beyond end statement; text ig\"\n            \"nored\");\n      return;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "simple_statement": {
      "start_point": [
        4607,
        0
      ],
      "end_point": [
        4686,
        1
      ],
      "content": "STATEMENT *simple_statement(MPL *mpl, int spec)\n{     STATEMENT *stmt;\n      stmt = alloc(STATEMENT);\n      stmt->line = mpl->line;\n      stmt->next = NULL;\n      if (is_keyword(mpl, \"set\"))\n      {  if (spec)\n            error(mpl, \"set statement not allowed here\");\n         stmt->type = A_SET;\n         stmt->u.set = set_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"param\"))\n      {  if (spec)\n            error(mpl, \"parameter statement not allowed here\");\n         stmt->type = A_PARAMETER;\n         stmt->u.par = parameter_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"var\"))\n      {  if (spec)\n            error(mpl, \"variable statement not allowed here\");\n         stmt->type = A_VARIABLE;\n         stmt->u.var = variable_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"subject\") ||\n               is_keyword(mpl, \"subj\") ||\n               mpl->token == T_SPTP)\n      {  if (spec)\n            error(mpl, \"constraint statement not allowed here\");\n         stmt->type = A_CONSTRAINT;\n         stmt->u.con = constraint_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"minimize\") ||\n               is_keyword(mpl, \"maximize\"))\n      {  if (spec)\n            error(mpl, \"objective statement not allowed here\");\n         stmt->type = A_CONSTRAINT;\n         stmt->u.con = objective_statement(mpl);\n      }\n#if 1 /* 11/II-2008 */\n      else if (is_keyword(mpl, \"table\"))\n      {  if (spec)\n            error(mpl, \"table statement not allowed here\");\n         stmt->type = A_TABLE;\n         stmt->u.tab = table_statement(mpl);\n      }\n#endif\n      else if (is_keyword(mpl, \"solve\"))\n      {  if (spec)\n            error(mpl, \"solve statement not allowed here\");\n         stmt->type = A_SOLVE;\n         stmt->u.slv = solve_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"check\"))\n      {  stmt->type = A_CHECK;\n         stmt->u.chk = check_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"display\"))\n      {  stmt->type = A_DISPLAY;\n         stmt->u.dpy = display_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"printf\"))\n      {  stmt->type = A_PRINTF;\n         stmt->u.prt = printf_statement(mpl);\n      }\n      else if (is_keyword(mpl, \"for\"))\n      {  stmt->type = A_FOR;\n         stmt->u.fur = for_statement(mpl);\n      }\n      else if (mpl->token == T_NAME)\n      {  if (spec)\n            error(mpl, \"constraint statement not allowed here\");\n         stmt->type = A_CONSTRAINT;\n         stmt->u.con = constraint_statement(mpl);\n      }\n      else if (is_reserved(mpl))\n         error(mpl, \"invalid use of reserved keyword %s\", mpl->image);\n      else\n         error(mpl, \"syntax error in model section\");\n      return stmt;\n}",
      "lines": 80,
      "depth": 14,
      "decorators": [
        "STATEMENT",
        "*simple_statement(MPL *mpl, int spec)",
        "*"
      ]
    },
    "model_section": {
      "start_point": [
        4699,
        0
      ],
      "end_point": [
        4715,
        1
      ],
      "content": "void model_section(MPL *mpl)\n{     STATEMENT *stmt, *last_stmt;\n      xassert(mpl->model == NULL);\n      last_stmt = NULL;\n      while (!(mpl->token == T_EOF || is_keyword(mpl, \"data\") ||\n               is_keyword(mpl, \"end\")))\n      {  /* parse statement */\n         stmt = simple_statement(mpl, 0);\n         /* and append it to the end of the statement list */\n         if (last_stmt == NULL)\n            mpl->model = stmt;\n         else\n            last_stmt->next = stmt;\n         last_stmt = stmt;\n      }\n      return;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mpl2.c": {
    "create_slice": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "SLICE *create_slice(MPL *mpl)\n{     SLICE *slice;\n      xassert(mpl == mpl);\n      slice = NULL;\n      return slice;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "SLICE",
        "*create_slice(MPL *mpl)",
        "*"
      ]
    },
    "expand_slice": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "SLICE *expand_slice\n(     MPL *mpl,\n      SLICE *slice,           /* destroyed */\n      SYMBOL *sym             /* destroyed */\n)\n{     SLICE *tail, *temp;\n      /* create a new component */\n      tail = dmp_get_atom(mpl->tuples, sizeof(SLICE));\n      tail->sym = sym;\n      tail->next = NULL;\n      /* and append it to the component list */\n      if (slice == NULL)\n         slice = tail;\n      else\n      {  for (temp = slice; temp->next != NULL; temp = temp->next);\n         temp->next = tail;\n      }\n      return slice;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "SLICE",
        "*expand_slice\n(     MPL *mpl,\n      SLICE *slice,           /* destroyed */\n      SYMBOL *sym             /* destroyed */\n)",
        "*"
      ]
    },
    "slice_dimen": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int slice_dimen\n(     MPL *mpl,\n      SLICE *slice            /* not changed */\n)\n{     SLICE *temp;\n      int dim;\n      xassert(mpl == mpl);\n      dim = 0;\n      for (temp = slice; temp != NULL; temp = temp->next) dim++;\n      return dim;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "slice_arity": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int slice_arity\n(     MPL *mpl,\n      SLICE *slice            /* not changed */\n)\n{     SLICE *temp;\n      int arity;\n      xassert(mpl == mpl);\n      arity = 0;\n      for (temp = slice; temp != NULL; temp = temp->next)\n         if (temp->sym == NULL) arity++;\n      return arity;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "fake_slice": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "SLICE *fake_slice(MPL *mpl, int dim)\n{     SLICE *slice;\n      slice = create_slice(mpl);\n      while (dim-- > 0) slice = expand_slice(mpl, slice, NULL);\n      return slice;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "SLICE",
        "*fake_slice(MPL *mpl, int dim)",
        "*"
      ]
    },
    "delete_slice": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void delete_slice\n(     MPL *mpl,\n      SLICE *slice            /* destroyed */\n)\n{     SLICE *temp;\n      while (slice != NULL)\n      {  temp = slice;\n         slice = temp->next;\n         if (temp->sym != NULL) delete_symbol(mpl, temp->sym);\nxassert(sizeof(SLICE) == sizeof(TUPLE));\n         dmp_free_atom(mpl->tuples, temp, sizeof(TUPLE));\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "is_number": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int is_number(MPL *mpl)\n{     return\n         mpl->token == T_NUMBER;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "is_symbol": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "int is_symbol(MPL *mpl)\n{     return\n         mpl->token == T_NUMBER ||\n         mpl->token == T_SYMBOL ||\n         mpl->token == T_STRING;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "is_literal": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int is_literal(MPL *mpl, char *literal)\n{     return\n         is_symbol(mpl) && strcmp(mpl->image, literal) == 0;\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "read_number": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "double read_number(MPL *mpl)\n{     double num;\n      xassert(is_number(mpl));\n      num = mpl->value;\n      get_token(mpl /* <number> */);\n      return num;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "read_symbol": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "SYMBOL *read_symbol(MPL *mpl)\n{     SYMBOL *sym;\n      xassert(is_symbol(mpl));\n      if (is_number(mpl))\n         sym = create_symbol_num(mpl, mpl->value);\n      else\n         sym = create_symbol_str(mpl, create_string(mpl, mpl->image));\n      get_token(mpl /* <symbol> */);\n      return sym;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "SYMBOL",
        "*read_symbol(MPL *mpl)",
        "*"
      ]
    },
    "read_slice": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "SLICE *read_slice\n(     MPL *mpl,\n      char *name,             /* not changed */\n      int dim\n)\n{     SLICE *slice;\n      int close;\n      xassert(name != NULL);\n      switch (mpl->token)\n      {  case T_LBRACKET:\n            close = T_RBRACKET;\n            break;\n         case T_LEFT:\n            xassert(dim > 0);\n            close = T_RIGHT;\n            break;\n         default:\n            xassert(mpl != mpl);\n      }\n      if (dim == 0)\n         error(mpl, \"%s cannot be subscripted\", name);\n      get_token(mpl /* ( | [ */);\n      /* read slice components */\n      slice = create_slice(mpl);\n      for (;;)\n      {  /* the current token must be a symbol or asterisk */\n         if (is_symbol(mpl))\n            slice = expand_slice(mpl, slice, read_symbol(mpl));\n         else if (mpl->token == T_ASTERISK)\n         {  slice = expand_slice(mpl, slice, NULL);\n            get_token(mpl /* * */);\n         }\n         else\n            error(mpl, \"number, symbol, or asterisk missing where expec\"\n               \"ted\");\n         /* check a token that follows the symbol */\n         if (mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n         else if (mpl->token == close)\n            break;\n         else\n            error(mpl, \"syntax error in slice\");\n      }\n      /* number of slice components must be the same as the appropriate\n         dimension */\n      if (slice_dimen(mpl, slice) != dim)\n      {  switch (close)\n         {  case T_RBRACKET:\n               error(mpl, \"%s must have %d subscript%s, not %d\", name,\n                  dim, dim == 1 ? \"\" : \"s\", slice_dimen(mpl, slice));\n               break;\n            case T_RIGHT:\n               error(mpl, \"%s has dimension %d, not %d\", name, dim,\n                  slice_dimen(mpl, slice));\n               break;\n            default:\n               xassert(close != close);\n         }\n      }\n      get_token(mpl /* ) | ] */);\n      return slice;\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "SLICE",
        "*read_slice\n(     MPL *mpl,\n      char *name,             /* not changed */\n      int dim\n)",
        "*"
      ]
    },
    "select_set": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "SET *select_set\n(     MPL *mpl,\n      char *name              /* not changed */\n)\n{     SET *set;\n      AVLNODE *node;\n      xassert(name != NULL);\n      node = avl_find_node(mpl->tree, name);\n      if (node == NULL || avl_get_node_type(node) != A_SET)\n         error(mpl, \"%s not a set\", name);\n      set = (SET *)avl_get_node_link(node);\n      if (set->assign != NULL || set->gadget != NULL)\n         error(mpl, \"%s needs no data\", name);\n      set->data = 1;\n      return set;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "SET",
        "*select_set\n(     MPL *mpl,\n      char *name              /* not changed */\n)",
        "*"
      ]
    },
    "simple_format": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "void simple_format\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      MEMBER *memb,           /* modified */\n      SLICE *slice            /* not changed */\n)\n{     TUPLE *tuple;\n      SLICE *temp;\n      SYMBOL *sym, *with = NULL;\n      xassert(set != NULL);\n      xassert(memb != NULL);\n      xassert(slice != NULL);\n      xassert(set->dimen == slice_dimen(mpl, slice));\n      xassert(memb->value.set->dim == set->dimen);\n      if (slice_arity(mpl, slice) > 0) xassert(is_symbol(mpl));\n      /* read symbols and construct complete n-tuple */\n      tuple = create_tuple(mpl);\n      for (temp = slice; temp != NULL; temp = temp->next)\n      {  if (temp->sym == NULL)\n         {  /* substitution is needed; read symbol */\n            if (!is_symbol(mpl))\n            {  int lack = slice_arity(mpl, temp);\n               /* with cannot be null due to assertion above */\n               xassert(with != NULL);\n               if (lack == 1)\n                  error(mpl, \"one item missing in data group beginning \"\n                     \"with %s\", format_symbol(mpl, with));\n               else\n                  error(mpl, \"%d items missing in data group beginning \"\n                     \"with %s\", lack, format_symbol(mpl, with));\n            }\n            sym = read_symbol(mpl);\n            if (with == NULL) with = sym;\n         }\n         else\n         {  /* copy symbol from the slice */\n            sym = copy_symbol(mpl, temp->sym);\n         }\n         /* append the symbol to the n-tuple */\n         tuple = expand_tuple(mpl, tuple, sym);\n         /* skip optional comma *between* <symbols> */\n         if (temp->next != NULL && mpl->token == T_COMMA)\n            get_token(mpl /* , */);\n      }\n      /* add constructed n-tuple to elemental set */\n      check_then_add(mpl, memb->value.set, tuple);\n      return;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "matrix_format": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        486,
        1
      ],
      "content": "void matrix_format\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      MEMBER *memb,           /* modified */\n      SLICE *slice,           /* not changed */\n      int tr\n)\n{     SLICE *list, *col, *temp;\n      TUPLE *tuple;\n      SYMBOL *row;\n      xassert(set != NULL);\n      xassert(memb != NULL);\n      xassert(slice != NULL);\n      xassert(set->dimen == slice_dimen(mpl, slice));\n      xassert(memb->value.set->dim == set->dimen);\n      xassert(slice_arity(mpl, slice) == 2);\n      /* read the matrix heading that contains column symbols (there\n         may be no columns at all) */\n      list = create_slice(mpl);\n      while (mpl->token != T_ASSIGN)\n      {  /* read column symbol and append it to the column list */\n         if (!is_symbol(mpl))\n            error(mpl, \"number, symbol, or := missing where expected\");\n         list = expand_slice(mpl, list, read_symbol(mpl));\n      }\n      get_token(mpl /* := */);\n      /* read zero or more rows that contain matrix data */\n      while (is_symbol(mpl))\n      {  /* read row symbol (if the matrix has no columns, row symbols\n            are just ignored) */\n         row = read_symbol(mpl);\n         /* read the matrix row accordingly to the column list */\n         for (col = list; col != NULL; col = col->next)\n         {  int which = 0;\n            /* check indicator */\n            if (is_literal(mpl, \"+\"))\n               ;\n            else if (is_literal(mpl, \"-\"))\n            {  get_token(mpl /* - */);\n               continue;\n            }\n            else\n            {  int lack = slice_dimen(mpl, col);\n               if (lack == 1)\n                  error(mpl, \"one item missing in data group beginning \"\n                     \"with %s\", format_symbol(mpl, row));\n               else\n                  error(mpl, \"%d items missing in data group beginning \"\n                     \"with %s\", lack, format_symbol(mpl, row));\n            }\n            /* construct complete n-tuple */\n            tuple = create_tuple(mpl);\n            for (temp = slice; temp != NULL; temp = temp->next)\n            {  if (temp->sym == NULL)\n               {  /* substitution is needed */\n                  switch (++which)\n                  {  case 1:\n                        /* substitute in the first null position */\n                        tuple = expand_tuple(mpl, tuple,\n                           copy_symbol(mpl, tr ? col->sym : row));\n                        break;\n                     case 2:\n                        /* substitute in the second null position */\n                        tuple = expand_tuple(mpl, tuple,\n                           copy_symbol(mpl, tr ? row : col->sym));\n                        break;\n                     default:\n                        xassert(which != which);\n                  }\n               }\n               else\n               {  /* copy symbol from the slice */\n                  tuple = expand_tuple(mpl, tuple, copy_symbol(mpl,\n                     temp->sym));\n               }\n            }\n            xassert(which == 2);\n            /* add constructed n-tuple to elemental set */\n            check_then_add(mpl, memb->value.set, tuple);\n            get_token(mpl /* + */);\n         }\n         /* delete the row symbol */\n         delete_symbol(mpl, row);\n      }\n      /* delete the column list */\n      delete_slice(mpl, list);\n      return;\n}",
      "lines": 88,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "set_data": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        628,
        1
      ],
      "content": "void set_data(MPL *mpl)\n{     SET *set;\n      TUPLE *tuple;\n      MEMBER *memb;\n      SLICE *slice;\n      int tr = 0;\n      xassert(is_literal(mpl, \"set\"));\n      get_token(mpl /* set */);\n      /* symbolic name of set must follows the keyword 'set' */\n      if (!is_symbol(mpl))\n         error(mpl, \"set name missing where expected\");\n      /* select the set to saturate it with data */\n      set = select_set(mpl, mpl->image);\n      get_token(mpl /* <symbolic name> */);\n      /* read optional subscript list, which identifies member of the\n         set to be read */\n      tuple = create_tuple(mpl);\n      if (mpl->token == T_LBRACKET)\n      {  /* subscript list is specified */\n         if (set->dim == 0)\n            error(mpl, \"%s cannot be subscripted\", set->name);\n         get_token(mpl /* [ */);\n         /* read symbols and construct subscript list */\n         for (;;)\n         {  if (!is_symbol(mpl))\n               error(mpl, \"number or symbol missing where expected\");\n            tuple = expand_tuple(mpl, tuple, read_symbol(mpl));\n            if (mpl->token == T_COMMA)\n               get_token(mpl /* , */);\n            else if (mpl->token == T_RBRACKET)\n               break;\n            else\n               error(mpl, \"syntax error in subscript list\");\n         }\n         if (set->dim != tuple_dimen(mpl, tuple))\n            error(mpl, \"%s must have %d subscript%s rather than %d\",\n               set->name, set->dim, set->dim == 1 ? \"\" : \"s\",\n               tuple_dimen(mpl, tuple));\n         get_token(mpl /* ] */);\n      }\n      else\n      {  /* subscript list is not specified */\n         if (set->dim != 0)\n            error(mpl, \"%s must be subscripted\", set->name);\n      }\n      /* there must be no member with the same subscript list */\n      if (find_member(mpl, set->array, tuple) != NULL)\n         error(mpl, \"%s%s already defined\",\n            set->name, format_tuple(mpl, '[', tuple));\n      /* add new member to the set and assign it empty elemental set */\n      memb = add_member(mpl, set->array, tuple);\n      memb->value.set = create_elemset(mpl, set->dimen);\n      /* create an initial fake slice of all asterisks */\n      slice = fake_slice(mpl, set->dimen);\n      /* read zero or more data assignments */\n      for (;;)\n      {  /* skip optional comma */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n         /* process assignment element */\n         if (mpl->token == T_ASSIGN)\n         {  /* assignment ligature is non-significant element */\n            get_token(mpl /* := */);\n         }\n         else if (mpl->token == T_LEFT)\n         {  /* left parenthesis begins either new slice or \"transpose\"\n               indicator */\n            int is_tr;\n            get_token(mpl /* ( */);\n            is_tr = is_literal(mpl, \"tr\");\n            unget_token(mpl /* ( */);\n            if (is_tr) goto left;\n            /* delete the current slice and read new one */\n            delete_slice(mpl, slice);\n            slice = read_slice(mpl, set->name, set->dimen);\n            /* each new slice resets the \"transpose\" indicator */\n            tr = 0;\n            /* if the new slice is 0-ary, formally there is one 0-tuple\n               (in the simple format) that follows it */\n            if (slice_arity(mpl, slice) == 0)\n               simple_format(mpl, set, memb, slice);\n         }\n         else if (is_symbol(mpl))\n         {  /* number or symbol begins data in the simple format */\n            simple_format(mpl, set, memb, slice);\n         }\n         else if (mpl->token == T_COLON)\n         {  /* colon begins data in the matrix format */\n            if (slice_arity(mpl, slice) != 2)\nerr1:          error(mpl, \"slice currently used must specify 2 asterisk\"\n                  \"s, not %d\", slice_arity(mpl, slice));\n            get_token(mpl /* : */);\n            /* read elemental set data in the matrix format */\n            matrix_format(mpl, set, memb, slice, tr);\n         }\n         else if (mpl->token == T_LEFT)\nleft:    {  /* left parenthesis begins the \"transpose\" indicator, which\n               is followed by data in the matrix format */\n            get_token(mpl /* ( */);\n            if (!is_literal(mpl, \"tr\"))\nerr2:          error(mpl, \"transpose indicator (tr) incomplete\");\n            if (slice_arity(mpl, slice) != 2) goto err1;\n            get_token(mpl /* tr */);\n            if (mpl->token != T_RIGHT) goto err2;\n            get_token(mpl /* ) */);\n            /* in this case the colon is optional */\n            if (mpl->token == T_COLON) get_token(mpl /* : */);\n            /* set the \"transpose\" indicator */\n            tr = 1;\n            /* read elemental set data in the matrix format */\n            matrix_format(mpl, set, memb, slice, tr);\n         }\n         else if (mpl->token == T_SEMICOLON)\n         {  /* semicolon terminates the data block */\n            get_token(mpl /* ; */);\n            break;\n         }\n         else\n            error(mpl, \"syntax error in set data block\");\n      }\n      /* delete the current slice */\n      delete_slice(mpl, slice);\n      return;\n}",
      "lines": 123,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "select_parameter": {
      "start_point": [
        636,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "PARAMETER *select_parameter\n(     MPL *mpl,\n      char *name              /* not changed */\n)\n{     PARAMETER *par;\n      AVLNODE *node;\n      xassert(name != NULL);\n      node = avl_find_node(mpl->tree, name);\n      if (node == NULL || avl_get_node_type(node) != A_PARAMETER)\n         error(mpl, \"%s not a parameter\", name);\n      par = (PARAMETER *)avl_get_node_link(node);\n      if (par->assign != NULL)\n         error(mpl, \"%s needs no data\", name);\n      if (par->data)\n         error(mpl, \"%s already provided with data\", name);\n      par->data = 1;\n      return par;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "PARAMETER",
        "*select_parameter\n(     MPL *mpl,\n      char *name              /* not changed */\n)",
        "*"
      ]
    },
    "set_default": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "void set_default\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      SYMBOL *altval          /* destroyed */\n)\n{     xassert(par != NULL);\n      xassert(altval != NULL);\n      if (par->option != NULL)\n         error(mpl, \"default value for %s already specified in model se\"\n            \"ction\", par->name);\n      xassert(par->defval == NULL);\n      par->defval = altval;\n      return;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "read_value": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "MEMBER *read_value\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* destroyed */\n)\n{     MEMBER *memb;\n      xassert(par != NULL);\n      xassert(is_symbol(mpl));\n      /* there must be no member with the same n-tuple */\n      if (find_member(mpl, par->array, tuple) != NULL)\n         error(mpl, \"%s%s already defined\",\n            par->name, format_tuple(mpl, '[', tuple));\n      /* create new parameter member with given n-tuple */\n      memb = add_member(mpl, par->array, tuple);\n      /* read value and assigns it to the new parameter member */\n      switch (par->type)\n      {  case A_NUMERIC:\n         case A_INTEGER:\n         case A_BINARY:\n            if (!is_number(mpl))\n               error(mpl, \"%s requires numeric data\", par->name);\n            memb->value.num = read_number(mpl);\n            break;\n         case A_SYMBOLIC:\n            memb->value.sym = read_symbol(mpl);\n            break;\n         default:\n            xassert(par != par);\n      }\n      return memb;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "MEMBER",
        "*read_value\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* destroyed */\n)",
        "*"
      ]
    },
    "plain_format": {
      "start_point": [
        730,
        0
      ],
      "end_point": [
        773,
        1
      ],
      "content": "void plain_format\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      SLICE *slice            /* not changed */\n)\n{     TUPLE *tuple;\n      SLICE *temp;\n      SYMBOL *sym, *with = NULL;\n      xassert(par != NULL);\n      xassert(par->dim == slice_dimen(mpl, slice));\n      xassert(is_symbol(mpl));\n      /* read symbols and construct complete subscript list */\n      tuple = create_tuple(mpl);\n      for (temp = slice; temp != NULL; temp = temp->next)\n      {  if (temp->sym == NULL)\n         {  /* substitution is needed; read symbol */\n            if (!is_symbol(mpl))\n            {  int lack = slice_arity(mpl, temp) + 1;\n               xassert(with != NULL);\n               xassert(lack > 1);\n               error(mpl, \"%d items missing in data group beginning wit\"\n                  \"h %s\", lack, format_symbol(mpl, with));\n            }\n            sym = read_symbol(mpl);\n            if (with == NULL) with = sym;\n         }\n         else\n         {  /* copy symbol from the slice */\n            sym = copy_symbol(mpl, temp->sym);\n         }\n         /* append the symbol to the subscript list */\n         tuple = expand_tuple(mpl, tuple, sym);\n         /* skip optional comma */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n      }\n      /* read value and assign it to new parameter member */\n      if (!is_symbol(mpl))\n      {  xassert(with != NULL);\n         error(mpl, \"one item missing in data group beginning with %s\",\n            format_symbol(mpl, with));\n      }\n      read_value(mpl, par, tuple);\n      return;\n}",
      "lines": 44,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "tabular_format": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "void tabular_format\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      SLICE *slice,           /* not changed */\n      int tr\n)\n{     SLICE *list, *col, *temp;\n      TUPLE *tuple;\n      SYMBOL *row;\n      xassert(par != NULL);\n      xassert(par->dim == slice_dimen(mpl, slice));\n      xassert(slice_arity(mpl, slice) == 2);\n      /* read the table heading that contains column symbols (the table\n         may have no columns) */\n      list = create_slice(mpl);\n      while (mpl->token != T_ASSIGN)\n      {  /* read column symbol and append it to the column list */\n         if (!is_symbol(mpl))\n            error(mpl, \"number, symbol, or := missing where expected\");\n         list = expand_slice(mpl, list, read_symbol(mpl));\n      }\n      get_token(mpl /* := */);\n      /* read zero or more rows that contain tabular data */\n      while (is_symbol(mpl))\n      {  /* read row symbol (if the table has no columns, these symbols\n            are just ignored) */\n         row = read_symbol(mpl);\n         /* read values accordingly to the column list */\n         for (col = list; col != NULL; col = col->next)\n         {  int which = 0;\n            /* if the token is single point, no value is provided */\n            if (is_literal(mpl, \".\"))\n            {  get_token(mpl /* . */);\n               continue;\n            }\n            /* construct complete subscript list */\n            tuple = create_tuple(mpl);\n            for (temp = slice; temp != NULL; temp = temp->next)\n            {  if (temp->sym == NULL)\n               {  /* substitution is needed */\n                  switch (++which)\n                  {  case 1:\n                        /* substitute in the first null position */\n                        tuple = expand_tuple(mpl, tuple,\n                           copy_symbol(mpl, tr ? col->sym : row));\n                        break;\n                     case 2:\n                        /* substitute in the second null position */\n                        tuple = expand_tuple(mpl, tuple,\n                           copy_symbol(mpl, tr ? row : col->sym));\n                        break;\n                     default:\n                        xassert(which != which);\n                  }\n               }\n               else\n               {  /* copy symbol from the slice */\n                  tuple = expand_tuple(mpl, tuple, copy_symbol(mpl,\n                     temp->sym));\n               }\n            }\n            xassert(which == 2);\n            /* read value and assign it to new parameter member */\n            if (!is_symbol(mpl))\n            {  int lack = slice_dimen(mpl, col);\n               if (lack == 1)\n                  error(mpl, \"one item missing in data group beginning \"\n                     \"with %s\", format_symbol(mpl, row));\n               else\n                  error(mpl, \"%d items missing in data group beginning \"\n                     \"with %s\", lack, format_symbol(mpl, row));\n            }\n            read_value(mpl, par, tuple);\n         }\n         /* delete the row symbol */\n         delete_symbol(mpl, row);\n      }\n      /* delete the column list */\n      delete_slice(mpl, list);\n      return;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "void"
      ]
    },
    "tabbing_format": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "void tabbing_format\n(     MPL *mpl,\n      SYMBOL *altval          /* not changed */\n)\n{     SET *set = NULL;\n      PARAMETER *par;\n      SLICE *list, *col;\n      TUPLE *tuple;\n      int next_token, j, dim = 0;\n      char *last_name = NULL;\n      /* read the optional <prefix> */\n      if (is_symbol(mpl))\n      {  get_token(mpl /* <symbol> */);\n         next_token = mpl->token;\n         unget_token(mpl /* <symbol> */);\n         if (next_token == T_COLON)\n         {  /* select the set to saturate it with data */\n            set = select_set(mpl, mpl->image);\n            /* the set must be simple (i.e. not set of sets) */\n            if (set->dim != 0)\n               error(mpl, \"%s must be a simple set\", set->name);\n            /* and must not be defined yet */\n            if (set->array->head != NULL)\n               error(mpl, \"%s already defined\", set->name);\n            /* add new (the only) member to the set and assign it empty\n               elemental set */\n            add_member(mpl, set->array, NULL)->value.set =\n               create_elemset(mpl, set->dimen);\n            last_name = set->name, dim = set->dimen;\n            get_token(mpl /* <symbol> */);\n            xassert(mpl->token == T_COLON);\n            get_token(mpl /* : */);\n         }\n      }\n      /* read the table heading that contains parameter names */\n      list = create_slice(mpl);\n      while (mpl->token != T_ASSIGN)\n      {  /* there must be symbolic name of parameter */\n         if (!is_symbol(mpl))\n            error(mpl, \"parameter name or := missing where expected\");\n         /* select the parameter to saturate it with data */\n         par = select_parameter(mpl, mpl->image);\n         /* the parameter must be subscripted */\n         if (par->dim == 0)\n            error(mpl, \"%s not a subscripted parameter\", mpl->image);\n         /* the set (if specified) and all the parameters in the data\n            block must have identical dimension */\n         if (dim != 0 && par->dim != dim)\n         {  xassert(last_name != NULL);\n            error(mpl, \"%s has dimension %d while %s has dimension %d\",\n               last_name, dim, par->name, par->dim);\n         }\n         /* set default value for the parameter (if specified) */\n         if (altval != NULL)\n            set_default(mpl, par, copy_symbol(mpl, altval));\n         /* append the parameter to the column list */\n         list = expand_slice(mpl, list, (SYMBOL *)par);\n         last_name = par->name, dim = par->dim;\n         get_token(mpl /* <symbol> */);\n         /* skip optional comma */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n      }\n      if (slice_dimen(mpl, list) == 0)\n         error(mpl, \"at least one parameter name required\");\n      get_token(mpl /* := */);\n      /* skip optional comma */\n      if (mpl->token == T_COMMA) get_token(mpl /* , */);\n      /* read rows that contain tabbing data */\n      while (is_symbol(mpl))\n      {  /* read subscript list */\n         tuple = create_tuple(mpl);\n         for (j = 1; j <= dim; j++)\n         {  /* read j-th subscript */\n            if (!is_symbol(mpl))\n            {  int lack = slice_dimen(mpl, list) + dim - j + 1;\n               xassert(tuple != NULL);\n               xassert(lack > 1);\n               error(mpl, \"%d items missing in data group beginning wit\"\n                  \"h %s\", lack, format_symbol(mpl, tuple->sym));\n            }\n            /* read and append j-th subscript to the n-tuple */\n            tuple = expand_tuple(mpl, tuple, read_symbol(mpl));\n            /* skip optional comma *between* <symbols> */\n            if (j < dim && mpl->token == T_COMMA)\n               get_token(mpl /* , */);\n         }\n         /* if the set is specified, add to it new n-tuple, which is a\n            copy of the subscript list just read */\n         if (set != NULL)\n            check_then_add(mpl, set->array->head->value.set,\n               copy_tuple(mpl, tuple));\n         /* skip optional comma between <symbol> and <value> */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n         /* read values accordingly to the column list */\n         for (col = list; col != NULL; col = col->next)\n         {  /* if the token is single point, no value is provided */\n            if (is_literal(mpl, \".\"))\n            {  get_token(mpl /* . */);\n               continue;\n            }\n            /* read value and assign it to new parameter member */\n            if (!is_symbol(mpl))\n            {  int lack = slice_dimen(mpl, col);\n               xassert(tuple != NULL);\n               if (lack == 1)\n                  error(mpl, \"one item missing in data group beginning \"\n                     \"with %s\", format_symbol(mpl, tuple->sym));\n               else\n                  error(mpl, \"%d items missing in data group beginning \"\n                     \"with %s\", lack, format_symbol(mpl, tuple->sym));\n            }\n            read_value(mpl, (PARAMETER *)col->sym, copy_tuple(mpl,\n               tuple));\n            /* skip optional comma preceding the next value */\n            if (col->next != NULL && mpl->token == T_COMMA)\n               get_token(mpl /* , */);\n         }\n         /* delete the original subscript list */\n         delete_tuple(mpl, tuple);\n         /* skip optional comma (only if there is next data group) */\n         if (mpl->token == T_COMMA)\n         {  get_token(mpl /* , */);\n            if (!is_symbol(mpl)) unget_token(mpl /* , */);\n         }\n      }\n      /* delete the column list (it contains parameters, not symbols,\n         so nullify it before) */\n      for (col = list; col != NULL; col = col->next) col->sym = NULL;\n      delete_slice(mpl, list);\n      return;\n}",
      "lines": 131,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "parameter_data": {
      "start_point": [
        1058,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "void parameter_data(MPL *mpl)\n{     PARAMETER *par;\n      SYMBOL *altval = NULL;\n      SLICE *slice;\n      int tr = 0;\n      xassert(is_literal(mpl, \"param\"));\n      get_token(mpl /* param */);\n      /* read optional default value */\n      if (is_literal(mpl, \"default\"))\n      {  get_token(mpl /* default */);\n         if (!is_symbol(mpl))\n            error(mpl, \"default value missing where expected\");\n         altval = read_symbol(mpl);\n         /* if the default value follows the keyword 'param', the next\n            token must be only the colon */\n         if (mpl->token != T_COLON)\n            error(mpl, \"colon missing where expected\");\n      }\n      /* being used after the keyword 'param' or the optional default\n         value the colon begins data in the tabbing format */\n      if (mpl->token == T_COLON)\n      {  get_token(mpl /* : */);\n         /* skip optional comma */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n         /* read parameter data in the tabbing format */\n         tabbing_format(mpl, altval);\n         /* on reading data in the tabbing format the default value is\n            always copied, so delete the original symbol */\n         if (altval != NULL) delete_symbol(mpl, altval);\n         /* the next token must be only semicolon */\n         if (mpl->token != T_SEMICOLON)\n            error(mpl, \"symbol, number, or semicolon missing where expe\"\n               \"cted\");\n         get_token(mpl /* ; */);\n         goto done;\n      }\n      /* in other cases there must be symbolic name of parameter, which\n         follows the keyword 'param' */\n      if (!is_symbol(mpl))\n         error(mpl, \"parameter name missing where expected\");\n      /* select the parameter to saturate it with data */\n      par = select_parameter(mpl, mpl->image);\n      get_token(mpl /* <symbol> */);\n      /* read optional default value */\n      if (is_literal(mpl, \"default\"))\n      {  get_token(mpl /* default */);\n         if (!is_symbol(mpl))\n            error(mpl, \"default value missing where expected\");\n         altval = read_symbol(mpl);\n         /* set default value for the parameter */\n         set_default(mpl, par, altval);\n      }\n      /* create initial fake slice of all asterisks */\n      slice = fake_slice(mpl, par->dim);\n      /* read zero or more data assignments */\n      for (;;)\n      {  /* skip optional comma */\n         if (mpl->token == T_COMMA) get_token(mpl /* , */);\n         /* process current assignment */\n         if (mpl->token == T_ASSIGN)\n         {  /* assignment ligature is non-significant element */\n            get_token(mpl /* := */);\n         }\n         else if (mpl->token == T_LBRACKET)\n         {  /* left bracket begins new slice; delete the current slice\n               and read new one */\n            delete_slice(mpl, slice);\n            slice = read_slice(mpl, par->name, par->dim);\n            /* each new slice resets the \"transpose\" indicator */\n            tr = 0;\n         }\n         else if (is_symbol(mpl))\n         {  /* number or symbol begins data in the plain format */\n            plain_format(mpl, par, slice);\n         }\n         else if (mpl->token == T_COLON)\n         {  /* colon begins data in the tabular format */\n            if (par->dim == 0)\nerr1:          error(mpl, \"%s not a subscripted parameter\",\n                  par->name);\n            if (slice_arity(mpl, slice) != 2)\nerr2:          error(mpl, \"slice currently used must specify 2 asterisk\"\n                  \"s, not %d\", slice_arity(mpl, slice));\n            get_token(mpl /* : */);\n            /* read parameter data in the tabular format */\n            tabular_format(mpl, par, slice, tr);\n         }\n         else if (mpl->token == T_LEFT)\n         {  /* left parenthesis begins the \"transpose\" indicator, which\n               is followed by data in the tabular format */\n            get_token(mpl /* ( */);\n            if (!is_literal(mpl, \"tr\"))\nerr3:          error(mpl, \"transpose indicator (tr) incomplete\");\n            if (par->dim == 0) goto err1;\n            if (slice_arity(mpl, slice) != 2) goto err2;\n            get_token(mpl /* tr */);\n            if (mpl->token != T_RIGHT) goto err3;\n            get_token(mpl /* ) */);\n            /* in this case the colon is optional */\n            if (mpl->token == T_COLON) get_token(mpl /* : */);\n            /* set the \"transpose\" indicator */\n            tr = 1;\n            /* read parameter data in the tabular format */\n            tabular_format(mpl, par, slice, tr);\n         }\n         else if (mpl->token == T_SEMICOLON)\n         {  /* semicolon terminates the data block */\n            get_token(mpl /* ; */);\n            break;\n         }\n         else\n            error(mpl, \"syntax error in parameter data block\");\n      }\n      /* delete the current slice */\n      delete_slice(mpl, slice);\ndone: return;\n}",
      "lines": 117,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "data_section": {
      "start_point": [
        1189,
        0
      ],
      "end_point": [
        1199,
        1
      ],
      "content": "void data_section(MPL *mpl)\n{     while (!(mpl->token == T_EOF || is_literal(mpl, \"end\")))\n      {  if (is_literal(mpl, \"set\"))\n            set_data(mpl);\n         else if (is_literal(mpl, \"param\"))\n            parameter_data(mpl);\n         else\n            error(mpl, \"syntax error in data section\");\n      }\n      return;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mpl3.c": {
    "fp_add": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "double fp_add(MPL *mpl, double x, double y)\n{     if (x > 0.0 && y > 0.0 && x > + 0.999 * DBL_MAX - y ||\n          x < 0.0 && y < 0.0 && x < - 0.999 * DBL_MAX - y)\n         error(mpl, \"%.*g + %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      return x + y;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "fp_sub": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "double fp_sub(MPL *mpl, double x, double y)\n{     if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y ||\n          x < 0.0 && y > 0.0 && x < - 0.999 * DBL_MAX + y)\n         error(mpl, \"%.*g - %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      return x - y;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "fp_less": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "double fp_less(MPL *mpl, double x, double y)\n{     if (x < y) return 0.0;\n      if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y)\n         error(mpl, \"%.*g less %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      return x - y;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "fp_mul": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "double fp_mul(MPL *mpl, double x, double y)\n{     if (fabs(y) > 1.0 && fabs(x) > (0.999 * DBL_MAX) / fabs(y))\n         error(mpl, \"%.*g * %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      return x * y;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "fp_div": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "double fp_div(MPL *mpl, double x, double y)\n{     if (fabs(y) < DBL_MIN)\n         error(mpl, \"%.*g / %.*g; floating-point zero divide\",\n            DBL_DIG, x, DBL_DIG, y);\n      if (fabs(y) < 1.0 && fabs(x) > (0.999 * DBL_MAX) * fabs(y))\n         error(mpl, \"%.*g / %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      return x / y;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "fp_idiv": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "double fp_idiv(MPL *mpl, double x, double y)\n{     if (fabs(y) < DBL_MIN)\n         error(mpl, \"%.*g div %.*g; floating-point zero divide\",\n            DBL_DIG, x, DBL_DIG, y);\n      if (fabs(y) < 1.0 && fabs(x) > (0.999 * DBL_MAX) * fabs(y))\n         error(mpl, \"%.*g div %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      x /= y;\n      return x > 0.0 ? floor(x) : x < 0.0 ? ceil(x) : 0.0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "fp_mod": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "double fp_mod(MPL *mpl, double x, double y)\n{     double r;\n      xassert(mpl == mpl);\n      if (x == 0.0)\n         r = 0.0;\n      else if (y == 0.0)\n         r = x;\n      else\n      {  r = fmod(fabs(x), fabs(y));\n         if (r != 0.0)\n         {  if (x < 0.0) r = - r;\n            if (x > 0.0 && y < 0.0 || x < 0.0 && y > 0.0) r += y;\n         }\n      }\n      return r;\n}",
      "lines": 16,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "fp_power": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "double fp_power(MPL *mpl, double x, double y)\n{     double r;\n      if (x == 0.0 && y <= 0.0 || x < 0.0 && y != floor(y))\n         error(mpl, \"%.*g ** %.*g; result undefined\",\n            DBL_DIG, x, DBL_DIG, y);\n      if (x == 0.0) goto eval;\n      if (fabs(x) > 1.0 && y > +1.0 &&\n            +log(fabs(x)) > (0.999 * log(DBL_MAX)) / y ||\n          fabs(x) < 1.0 && y < -1.0 &&\n            +log(fabs(x)) < (0.999 * log(DBL_MAX)) / y)\n         error(mpl, \"%.*g ** %.*g; floating-point overflow\",\n            DBL_DIG, x, DBL_DIG, y);\n      if (fabs(x) > 1.0 && y < -1.0 &&\n            -log(fabs(x)) < (0.999 * log(DBL_MAX)) / y ||\n          fabs(x) < 1.0 && y > +1.0 &&\n            -log(fabs(x)) > (0.999 * log(DBL_MAX)) / y)\n         r = 0.0;\n      else\neval:    r = pow(x, y);\n      return r;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "fp_exp": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "double fp_exp(MPL *mpl, double x)\n{     if (x > 0.999 * log(DBL_MAX))\n         error(mpl, \"exp(%.*g); floating-point overflow\", DBL_DIG, x);\n      return exp(x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fp_log": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "double fp_log(MPL *mpl, double x)\n{     if (x <= 0.0)\n         error(mpl, \"log(%.*g); non-positive argument\", DBL_DIG, x);\n      return log(x);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fp_log10": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "double fp_log10(MPL *mpl, double x)\n{     if (x <= 0.0)\n         error(mpl, \"log10(%.*g); non-positive argument\", DBL_DIG, x);\n      return log10(x);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fp_sqrt": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "double fp_sqrt(MPL *mpl, double x)\n{     if (x < 0.0)\n         error(mpl, \"sqrt(%.*g); negative argument\", DBL_DIG, x);\n      return sqrt(x);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fp_sin": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "double fp_sin(MPL *mpl, double x)\n{     if (!(-1e6 <= x && x <= +1e6))\n         error(mpl, \"sin(%.*g); argument too large\", DBL_DIG, x);\n      return sin(x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fp_cos": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "double fp_cos(MPL *mpl, double x)\n{     if (!(-1e6 <= x && x <= +1e6))\n         error(mpl, \"cos(%.*g); argument too large\", DBL_DIG, x);\n      return cos(x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fp_tan": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "double fp_tan(MPL *mpl, double x)\n{     if (!(-1e6 <= x && x <= +1e6))\n         error(mpl, \"tan(%.*g); argument too large\", DBL_DIG, x);\n      return tan(x);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fp_atan": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "double fp_atan(MPL *mpl, double x)\n{     xassert(mpl == mpl);\n      return atan(x);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "fp_atan2": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "double fp_atan2(MPL *mpl, double y, double x)\n{     xassert(mpl == mpl);\n      return atan2(y, x);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "double"
      ]
    },
    "fp_round": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "double fp_round(MPL *mpl, double x, double n)\n{     double ten_to_n;\n      if (n != floor(n))\n         error(mpl, \"round(%.*g, %.*g); non-integer second argument\",\n            DBL_DIG, x, DBL_DIG, n);\n      if (n <= DBL_DIG + 2)\n      {  ten_to_n = pow(10.0, n);\n         if (fabs(x) < (0.999 * DBL_MAX) / ten_to_n)\n         {  x = floor(x * ten_to_n + 0.5);\n            if (x != 0.0) x /= ten_to_n;\n         }\n      }\n      return x;\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "fp_trunc": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "double fp_trunc(MPL *mpl, double x, double n)\n{     double ten_to_n;\n      if (n != floor(n))\n         error(mpl, \"trunc(%.*g, %.*g); non-integer second argument\",\n            DBL_DIG, x, DBL_DIG, n);\n      if (n <= DBL_DIG + 2)\n      {  ten_to_n = pow(10.0, n);\n         if (fabs(x) < (0.999 * DBL_MAX) / ten_to_n)\n         {  x = (x >= 0.0 ? floor(x * ten_to_n) : ceil(x * ten_to_n));\n            if (x != 0.0) x /= ten_to_n;\n         }\n      }\n      return x;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "double"
      ]
    },
    "fp_irand224": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "double fp_irand224(MPL *mpl)\n{     return\n         (double)rng_unif_rand(mpl->rand, two_to_the_24);\n}",
      "lines": 4,
      "depth": 8,
      "decorators": [
        "double"
      ]
    },
    "fp_uniform01": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "double fp_uniform01(MPL *mpl)\n{     return\n         (double)rng_next_rand(mpl->rand) / (double)two_to_the_31;\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "fp_uniform": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "double fp_uniform(MPL *mpl, double a, double b)\n{     double x;\n      if (a >= b)\n         error(mpl, \"Uniform(%.*g, %.*g); invalid range\",\n            DBL_DIG, a, DBL_DIG, b);\n      x = fp_uniform01(mpl);\n#if 0\n      x = a * (1.0 - x) + b * x;\n#else\n      x = fp_add(mpl, a * (1.0 - x), b * x);\n#endif\n      return x;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "double"
      ]
    },
    "fp_normal01": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "double fp_normal01(MPL *mpl)\n{     double x, y, r2;\n      do\n      {  /* choose x, y in uniform square (-1,-1) to (+1,+1) */\n         x = -1.0 + 2.0 * fp_uniform01(mpl);\n         y = -1.0 + 2.0 * fp_uniform01(mpl);\n         /* see if it is in the unit circle */\n         r2 = x * x + y * y;\n      } while (r2 > 1.0 || r2 == 0.0);\n      /* Box-Muller transform */\n      return y * sqrt(-2.0 * log (r2) / r2);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "fp_normal": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "double fp_normal(MPL *mpl, double mu, double sigma)\n{     double x;\n#if 0\n      x = mu + sigma * fp_normal01(mpl);\n#else\n      x = fp_add(mpl, mu, fp_mul(mpl, sigma, fp_normal01(mpl)));\n#endif\n      return x;\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "create_symbol_num": {
      "start_point": [
        565,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "SYMBOL *create_symbol_num(MPL *mpl, double num)\n{     SYMBOL *sym;\n      sym = dmp_get_atom(mpl->symbols, sizeof(SYMBOL));\n      sym->num = num;\n      sym->str = NULL;\n      return sym;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "SYMBOL",
        "*create_symbol_num(MPL *mpl, double num)",
        "*"
      ]
    },
    "create_symbol_str": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        589,
        1
      ],
      "content": "SYMBOL *create_symbol_str\n(     MPL *mpl,\n      STRING *str             /* destroyed */\n)\n{     SYMBOL *sym;\n      xassert(str != NULL);\n      sym = dmp_get_atom(mpl->symbols, sizeof(SYMBOL));\n      sym->num = 0.0;\n      sym->str = str;\n      return sym;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "SYMBOL",
        "*create_symbol_str\n(     MPL *mpl,\n      STRING *str             /* destroyed */\n)",
        "*"
      ]
    },
    "copy_symbol": {
      "start_point": [
        596,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "SYMBOL *copy_symbol\n(     MPL *mpl,\n      SYMBOL *sym             /* not changed */\n)\n{     SYMBOL *copy;\n      xassert(sym != NULL);\n      copy = dmp_get_atom(mpl->symbols, sizeof(SYMBOL));\n      if (sym->str == NULL)\n      {  copy->num = sym->num;\n         copy->str = NULL;\n      }\n      else\n      {  copy->num = 0.0;\n         copy->str = copy_string(mpl, sym->str);\n      }\n      return copy;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "SYMBOL",
        "*copy_symbol\n(     MPL *mpl,\n      SYMBOL *sym             /* not changed */\n)",
        "*"
      ]
    },
    "compare_symbols": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "int compare_symbols\n(     MPL *mpl,\n      SYMBOL *sym1,           /* not changed */\n      SYMBOL *sym2            /* not changed */\n)\n{     xassert(sym1 != NULL);\n      xassert(sym2 != NULL);\n      /* let all numeric quantities precede all symbolic quantities */\n      if (sym1->str == NULL && sym2->str == NULL)\n      {  if (sym1->num < sym2->num) return -1;\n         if (sym1->num > sym2->num) return +1;\n         return 0;\n      }\n      if (sym1->str == NULL) return -1;\n      if (sym2->str == NULL) return +1;\n      return compare_strings(mpl, sym1->str, sym2->str);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "delete_symbol": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "void delete_symbol\n(     MPL *mpl,\n      SYMBOL *sym             /* destroyed */\n)\n{     xassert(sym != NULL);\n      if (sym->str != NULL) delete_string(mpl, sym->str);\n      dmp_free_atom(mpl->symbols, sym, sizeof(SYMBOL));\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "format_symbol": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        708,
        1
      ],
      "content": "char *format_symbol\n(     MPL *mpl,\n      SYMBOL *sym             /* not changed */\n)\n{     char *buf = mpl->sym_buf;\n      xassert(sym != NULL);\n      if (sym->str == NULL)\n         sprintf(buf, \"%.*g\", DBL_DIG, sym->num);\n      else\n      {  char str[MAX_LENGTH+1];\n         int quoted, j, len;\n         fetch_string(mpl, sym->str, str);\n         if (!(isalpha((unsigned char)str[0]) || str[0] == '_'))\n            quoted = 1;\n         else\n         {  quoted = 0;\n            for (j = 1; str[j] != '\\0'; j++)\n            {  if (!(isalnum((unsigned char)str[j]) ||\n                     strchr(\"+-._\", (unsigned char)str[j]) != NULL))\n               {  quoted = 1;\n                  break;\n               }\n            }\n         }\n#        define safe_append(c) \\\n            (void)(len < 255 ? (buf[len++] = (char)(c)) : 0)\n         buf[0] = '\\0', len = 0;\n         if (quoted) safe_append('\\'');\n         for (j = 0; str[j] != '\\0'; j++)\n         {  if (quoted && str[j] == '\\'') safe_append('\\'');\n            safe_append(str[j]);\n         }\n         if (quoted) safe_append('\\'');\n#        undef safe_append\n         buf[len] = '\\0';\n         if (len == 255) strcpy(buf+252, \"...\");\n      }\n      xassert(strlen(buf) <= 255);\n      return buf;\n}",
      "lines": 40,
      "depth": 20,
      "decorators": [
        "char",
        "*format_symbol\n(     MPL *mpl,\n      SYMBOL *sym             /* not changed */\n)",
        "*"
      ]
    },
    "concat_symbols": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "SYMBOL *concat_symbols\n(     MPL *mpl,\n      SYMBOL *sym1,           /* destroyed */\n      SYMBOL *sym2            /* destroyed */\n)\n{     char str1[MAX_LENGTH+1], str2[MAX_LENGTH+1];\n      xassert(MAX_LENGTH >= DBL_DIG + DBL_DIG);\n      if (sym1->str == NULL)\n         sprintf(str1, \"%.*g\", DBL_DIG, sym1->num);\n      else\n         fetch_string(mpl, sym1->str, str1);\n      if (sym2->str == NULL)\n         sprintf(str2, \"%.*g\", DBL_DIG, sym2->num);\n      else\n         fetch_string(mpl, sym2->str, str2);\n      if (strlen(str1) + strlen(str2) > MAX_LENGTH)\n      {  char buf[255+1];\n         strcpy(buf, format_symbol(mpl, sym1));\n         xassert(strlen(buf) < sizeof(buf));\n         error(mpl, \"%s & %s; resultant symbol exceeds %d characters\",\n            buf, format_symbol(mpl, sym2), MAX_LENGTH);\n      }\n      delete_symbol(mpl, sym1);\n      delete_symbol(mpl, sym2);\n      return create_symbol_str(mpl, create_string(mpl, strcat(str1,\n         str2)));\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "SYMBOL",
        "*concat_symbols\n(     MPL *mpl,\n      SYMBOL *sym1,           /* destroyed */\n      SYMBOL *sym2            /* destroyed */\n)",
        "*"
      ]
    },
    "create_tuple": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        760,
        1
      ],
      "content": "TUPLE *create_tuple(MPL *mpl)\n{     TUPLE *tuple;\n      xassert(mpl == mpl);\n      tuple = NULL;\n      return tuple;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "TUPLE",
        "*create_tuple(MPL *mpl)",
        "*"
      ]
    },
    "expand_tuple": {
      "start_point": [
        768,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "TUPLE *expand_tuple\n(     MPL *mpl,\n      TUPLE *tuple,           /* destroyed */\n      SYMBOL *sym             /* destroyed */\n)\n{     TUPLE *tail, *temp;\n      xassert(sym != NULL);\n      /* create a new component */\n      tail = dmp_get_atom(mpl->tuples, sizeof(TUPLE));\n      tail->sym = sym;\n      tail->next = NULL;\n      /* and append it to the component list */\n      if (tuple == NULL)\n         tuple = tail;\n      else\n      {  for (temp = tuple; temp->next != NULL; temp = temp->next);\n         temp->next = tail;\n      }\n      return tuple;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "TUPLE",
        "*expand_tuple\n(     MPL *mpl,\n      TUPLE *tuple,           /* destroyed */\n      SYMBOL *sym             /* destroyed */\n)",
        "*"
      ]
    },
    "tuple_dimen": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        804,
        1
      ],
      "content": "int tuple_dimen\n(     MPL *mpl,\n      TUPLE *tuple            /* not changed */\n)\n{     TUPLE *temp;\n      int dim = 0;\n      xassert(mpl == mpl);\n      for (temp = tuple; temp != NULL; temp = temp->next) dim++;\n      return dim;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "copy_tuple": {
      "start_point": [
        811,
        0
      ],
      "end_point": [
        829,
        1
      ],
      "content": "TUPLE *copy_tuple\n(     MPL *mpl,\n      TUPLE *tuple            /* not changed */\n)\n{     TUPLE *head, *tail;\n      if (tuple == NULL)\n         head = NULL;\n      else\n      {  head = tail = dmp_get_atom(mpl->tuples, sizeof(TUPLE));\n         for (; tuple != NULL; tuple = tuple->next)\n         {  xassert(tuple->sym != NULL);\n            tail->sym = copy_symbol(mpl, tuple->sym);\n            if (tuple->next != NULL)\ntail = (tail->next = dmp_get_atom(mpl->tuples, sizeof(TUPLE)));\n         }\n         tail->next = NULL;\n      }\n      return head;\n}",
      "lines": 19,
      "depth": 16,
      "decorators": [
        "TUPLE",
        "*copy_tuple\n(     MPL *mpl,\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "compare_tuples": {
      "start_point": [
        845,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "int compare_tuples\n(     MPL *mpl,\n      TUPLE *tuple1,          /* not changed */\n      TUPLE *tuple2           /* not changed */\n)\n{     TUPLE *item1, *item2;\n      int ret;\n      xassert(mpl == mpl);\n      for (item1 = tuple1, item2 = tuple2; item1 != NULL;\n           item1 = item1->next, item2 = item2->next)\n      {  xassert(item2 != NULL);\n         xassert(item1->sym != NULL);\n         xassert(item2->sym != NULL);\n         ret = compare_symbols(mpl, item1->sym, item2->sym);\n         if (ret != 0) return ret;\n      }\n      xassert(item2 == NULL);\n      return 0;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "build_subtuple": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "TUPLE *build_subtuple\n(     MPL *mpl,\n      TUPLE *tuple,           /* not changed */\n      int dim\n)\n{     TUPLE *head, *temp;\n      int j;\n      head = create_tuple(mpl);\n      for (j = 1, temp = tuple; j <= dim; j++, temp = temp->next)\n      {  xassert(temp != NULL);\n         head = expand_tuple(mpl, head, copy_symbol(mpl, temp->sym));\n      }\n      return head;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "TUPLE",
        "*build_subtuple\n(     MPL *mpl,\n      TUPLE *tuple,           /* not changed */\n      int dim\n)",
        "*"
      ]
    },
    "delete_tuple": {
      "start_point": [
        891,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "void delete_tuple\n(     MPL *mpl,\n      TUPLE *tuple            /* destroyed */\n)\n{     TUPLE *temp;\n      while (tuple != NULL)\n      {  temp = tuple;\n         tuple = temp->next;\n         xassert(temp->sym != NULL);\n         delete_symbol(mpl, temp->sym);\n         dmp_free_atom(mpl->tuples, temp, sizeof(TUPLE));\n      }\n      return;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "format_tuple": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "char *format_tuple\n(     MPL *mpl,\n      int c,\n      TUPLE *tuple            /* not changed */\n)\n{     TUPLE *temp;\n      int dim, j, len;\n      char *buf = mpl->tup_buf, str[255+1], *save;\n#     define safe_append(c) \\\n         (void)(len < 255 ? (buf[len++] = (char)(c)) : 0)\n      buf[0] = '\\0', len = 0;\n      dim = tuple_dimen(mpl, tuple);\n      if (c == '[' && dim > 0) safe_append('[');\n      if (c == '(' && dim > 1) safe_append('(');\n      for (temp = tuple; temp != NULL; temp = temp->next)\n      {  if (temp != tuple) safe_append(',');\n         xassert(temp->sym != NULL);\n         save = mpl->sym_buf;\n         mpl->sym_buf = str;\n         format_symbol(mpl, temp->sym);\n         mpl->sym_buf = save;\n         xassert(strlen(str) < sizeof(str));\n         for (j = 0; str[j] != '\\0'; j++) safe_append(str[j]);\n      }\n      if (c == '[' && dim > 0) safe_append(']');\n      if (c == '(' && dim > 1) safe_append(')');\n#     undef safe_append\n      buf[len] = '\\0';\n      if (len == 255) strcpy(buf+252, \"...\");\n      xassert(strlen(buf) <= 255);\n      return buf;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "char",
        "*format_tuple\n(     MPL *mpl,\n      int c,\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "create_elemset": {
      "start_point": [
        958,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "ELEMSET *create_elemset(MPL *mpl, int dim)\n{     ELEMSET *set;\n      xassert(dim > 0);\n      set = create_array(mpl, A_NONE, dim);\n      return set;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "ELEMSET",
        "*create_elemset(MPL *mpl, int dim)",
        "*"
      ]
    },
    "find_tuple": {
      "start_point": [
        973,
        0
      ],
      "end_point": [
        982,
        1
      ],
      "content": "MEMBER *find_tuple\n(     MPL *mpl,\n      ELEMSET *set,           /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     xassert(set != NULL);\n      xassert(set->type == A_NONE);\n      xassert(set->dim == tuple_dimen(mpl, tuple));\n      return find_member(mpl, set, tuple);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "MEMBER",
        "*find_tuple\n(     MPL *mpl,\n      ELEMSET *set,           /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "add_tuple": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1007,
        1
      ],
      "content": "MEMBER *add_tuple\n(     MPL *mpl,\n      ELEMSET *set,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)\n{     MEMBER *memb;\n      xassert(set != NULL);\n      xassert(set->type == A_NONE);\n      xassert(set->dim == tuple_dimen(mpl, tuple));\n      memb = add_member(mpl, set, tuple);\n      memb->value.none = NULL;\n      return memb;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "MEMBER",
        "*add_tuple\n(     MPL *mpl,\n      ELEMSET *set,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)",
        "*"
      ]
    },
    "check_then_add": {
      "start_point": [
        1015,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "MEMBER *check_then_add\n(     MPL *mpl,\n      ELEMSET *set,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)\n{     if (find_tuple(mpl, set, tuple) != NULL)\n         error(mpl, \"duplicate tuple %s detected\", format_tuple(mpl,\n            '(', tuple));\n      return add_tuple(mpl, set, tuple);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "MEMBER",
        "*check_then_add\n(     MPL *mpl,\n      ELEMSET *set,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)",
        "*"
      ]
    },
    "copy_elemset": {
      "start_point": [
        1031,
        0
      ],
      "end_point": [
        1044,
        1
      ],
      "content": "ELEMSET *copy_elemset\n(     MPL *mpl,\n      ELEMSET *set            /* not changed */\n)\n{     ELEMSET *copy;\n      MEMBER *memb;\n      xassert(set != NULL);\n      xassert(set->type == A_NONE);\n      xassert(set->dim > 0);\n      copy = create_elemset(mpl, set->dim);\n      for (memb = set->head; memb != NULL; memb = memb->next)\n         add_tuple(mpl, copy, copy_tuple(mpl, memb->tuple));\n      return copy;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "ELEMSET",
        "*copy_elemset\n(     MPL *mpl,\n      ELEMSET *set            /* not changed */\n)",
        "*"
      ]
    },
    "delete_elemset": {
      "start_point": [
        1051,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "void delete_elemset\n(     MPL *mpl,\n      ELEMSET *set            /* destroyed */\n)\n{     xassert(set != NULL);\n      xassert(set->type == A_NONE);\n      delete_array(mpl, set);\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "arelset_size": {
      "start_point": [
        1073,
        0
      ],
      "end_point": [
        1099,
        1
      ],
      "content": "int arelset_size(MPL *mpl, double t0, double tf, double dt)\n{     double temp;\n      if (dt == 0.0)\n         error(mpl, \"%.*g .. %.*g by %.*g; zero stride not allowed\",\n            DBL_DIG, t0, DBL_DIG, tf, DBL_DIG, dt);\n      if (tf > 0.0 && t0 < 0.0 && tf > + 0.999 * DBL_MAX + t0)\n         temp = +DBL_MAX;\n      else if (tf < 0.0 && t0 > 0.0 && tf < - 0.999 * DBL_MAX + t0)\n         temp = -DBL_MAX;\n      else\n         temp = tf - t0;\n      if (fabs(dt) < 1.0 && fabs(temp) > (0.999 * DBL_MAX) * fabs(dt))\n      {  if (temp > 0.0 && dt > 0.0 || temp < 0.0 && dt < 0.0)\n            temp = +DBL_MAX;\n         else\n            temp = 0.0;\n      }\n      else\n      {  temp = floor(temp / dt) + 1.0;\n         if (temp < 0.0) temp = 0.0;\n      }\n      xassert(temp >= 0.0);\n      if (temp > (double)(INT_MAX - 1))\n         error(mpl, \"%.*g .. %.*g by %.*g; set too large\",\n            DBL_DIG, t0, DBL_DIG, tf, DBL_DIG, dt);\n      return (int)(temp + 0.5);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "arelset_member": {
      "start_point": [
        1117,
        0
      ],
      "end_point": [
        1120,
        1
      ],
      "content": "double arelset_member(MPL *mpl, double t0, double tf, double dt, int j)\n{     xassert(1 <= j && j <= arelset_size(mpl, t0, tf, dt));\n      return t0 + (double)(j - 1) * dt;\n}",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "create_arelset": {
      "start_point": [
        1132,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "ELEMSET *create_arelset(MPL *mpl, double t0, double tf, double dt)\n{     ELEMSET *set;\n      int j, n;\n      set = create_elemset(mpl, 1);\n      n = arelset_size(mpl, t0, tf, dt);\n      for (j = 1; j <= n; j++)\n      {  add_tuple\n         (  mpl,\n            set,\n            expand_tuple\n            (  mpl,\n               create_tuple(mpl),\n               create_symbol_num\n               (  mpl,\n                  arelset_member(mpl, t0, tf, dt, j)\n               )\n            )\n         );\n      }\n      return set;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "ELEMSET",
        "*create_arelset(MPL *mpl, double t0, double tf, double dt)",
        "*"
      ]
    },
    "set_union": {
      "start_point": [
        1163,
        0
      ],
      "end_point": [
        1182,
        1
      ],
      "content": "ELEMSET *set_union\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)\n{     MEMBER *memb;\n      xassert(X != NULL);\n      xassert(X->type == A_NONE);\n      xassert(X->dim > 0);\n      xassert(Y != NULL);\n      xassert(Y->type == A_NONE);\n      xassert(Y->dim > 0);\n      xassert(X->dim == Y->dim);\n      for (memb = Y->head; memb != NULL; memb = memb->next)\n      {  if (find_tuple(mpl, X, memb->tuple) == NULL)\n            add_tuple(mpl, X, copy_tuple(mpl, memb->tuple));\n      }\n      delete_elemset(mpl, Y);\n      return X;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ELEMSET",
        "*set_union\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)",
        "*"
      ]
    },
    "set_diff": {
      "start_point": [
        1193,
        0
      ],
      "end_point": [
        1215,
        1
      ],
      "content": "ELEMSET *set_diff\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)\n{     ELEMSET *Z;\n      MEMBER *memb;\n      xassert(X != NULL);\n      xassert(X->type == A_NONE);\n      xassert(X->dim > 0);\n      xassert(Y != NULL);\n      xassert(Y->type == A_NONE);\n      xassert(Y->dim > 0);\n      xassert(X->dim == Y->dim);\n      Z = create_elemset(mpl, X->dim);\n      for (memb = X->head; memb != NULL; memb = memb->next)\n      {  if (find_tuple(mpl, Y, memb->tuple) == NULL)\n            add_tuple(mpl, Z, copy_tuple(mpl, memb->tuple));\n      }\n      delete_elemset(mpl, X);\n      delete_elemset(mpl, Y);\n      return Z;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "ELEMSET",
        "*set_diff\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)",
        "*"
      ]
    },
    "set_symdiff": {
      "start_point": [
        1226,
        0
      ],
      "end_point": [
        1254,
        1
      ],
      "content": "ELEMSET *set_symdiff\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)\n{     ELEMSET *Z;\n      MEMBER *memb;\n      xassert(X != NULL);\n      xassert(X->type == A_NONE);\n      xassert(X->dim > 0);\n      xassert(Y != NULL);\n      xassert(Y->type == A_NONE);\n      xassert(Y->dim > 0);\n      xassert(X->dim == Y->dim);\n      /* Z := X \\ Y */\n      Z = create_elemset(mpl, X->dim);\n      for (memb = X->head; memb != NULL; memb = memb->next)\n      {  if (find_tuple(mpl, Y, memb->tuple) == NULL)\n            add_tuple(mpl, Z, copy_tuple(mpl, memb->tuple));\n      }\n      /* Z := Z U (Y \\ X) */\n      for (memb = Y->head; memb != NULL; memb = memb->next)\n      {  if (find_tuple(mpl, X, memb->tuple) == NULL)\n            add_tuple(mpl, Z, copy_tuple(mpl, memb->tuple));\n      }\n      delete_elemset(mpl, X);\n      delete_elemset(mpl, Y);\n      return Z;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "ELEMSET",
        "*set_symdiff\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)",
        "*"
      ]
    },
    "set_inter": {
      "start_point": [
        1265,
        0
      ],
      "end_point": [
        1287,
        1
      ],
      "content": "ELEMSET *set_inter\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)\n{     ELEMSET *Z;\n      MEMBER *memb;\n      xassert(X != NULL);\n      xassert(X->type == A_NONE);\n      xassert(X->dim > 0);\n      xassert(Y != NULL);\n      xassert(Y->type == A_NONE);\n      xassert(Y->dim > 0);\n      xassert(X->dim == Y->dim);\n      Z = create_elemset(mpl, X->dim);\n      for (memb = X->head; memb != NULL; memb = memb->next)\n      {  if (find_tuple(mpl, Y, memb->tuple) != NULL)\n            add_tuple(mpl, Z, copy_tuple(mpl, memb->tuple));\n      }\n      delete_elemset(mpl, X);\n      delete_elemset(mpl, Y);\n      return Z;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "ELEMSET",
        "*set_inter\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)",
        "*"
      ]
    },
    "set_cross": {
      "start_point": [
        1298,
        0
      ],
      "end_point": [
        1325,
        1
      ],
      "content": "ELEMSET *set_cross\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)\n{     ELEMSET *Z;\n      MEMBER *memx, *memy;\n      TUPLE *tuple, *temp;\n      xassert(X != NULL);\n      xassert(X->type == A_NONE);\n      xassert(X->dim > 0);\n      xassert(Y != NULL);\n      xassert(Y->type == A_NONE);\n      xassert(Y->dim > 0);\n      Z = create_elemset(mpl, X->dim + Y->dim);\n      for (memx = X->head; memx != NULL; memx = memx->next)\n      {  for (memy = Y->head; memy != NULL; memy = memy->next)\n         {  tuple = copy_tuple(mpl, memx->tuple);\n            for (temp = memy->tuple; temp != NULL; temp = temp->next)\n               tuple = expand_tuple(mpl, tuple, copy_symbol(mpl,\n                  temp->sym));\n            add_tuple(mpl, Z, tuple);\n         }\n      }\n      delete_elemset(mpl, X);\n      delete_elemset(mpl, Y);\n      return Z;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "ELEMSET",
        "*set_cross\n(     MPL *mpl,\n      ELEMSET *X,             /* destroyed */\n      ELEMSET *Y              /* destroyed */\n)",
        "*"
      ]
    },
    "constant_term": {
      "start_point": [
        1342,
        0
      ],
      "end_point": [
        1353,
        1
      ],
      "content": "FORMULA *constant_term(MPL *mpl, double coef)\n{     FORMULA *form;\n      if (coef == 0.0)\n         form = NULL;\n      else\n      {  form = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n         form->coef = coef;\n         form->var = NULL;\n         form->next = NULL;\n      }\n      return form;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "FORMULA",
        "*constant_term(MPL *mpl, double coef)",
        "*"
      ]
    },
    "single_variable": {
      "start_point": [
        1361,
        0
      ],
      "end_point": [
        1372,
        1
      ],
      "content": "FORMULA *single_variable\n(     MPL *mpl,\n      ELEMVAR *var            /* referenced */\n)\n{     FORMULA *form;\n      xassert(var != NULL);\n      form = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n      form->coef = 1.0;\n      form->var = var;\n      form->next = NULL;\n      return form;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "FORMULA",
        "*single_variable\n(     MPL *mpl,\n      ELEMVAR *var            /* referenced */\n)",
        "*"
      ]
    },
    "copy_formula": {
      "start_point": [
        1379,
        0
      ],
      "end_point": [
        1397,
        1
      ],
      "content": "FORMULA *copy_formula\n(     MPL *mpl,\n      FORMULA *form           /* not changed */\n)\n{     FORMULA *head, *tail;\n      if (form == NULL)\n         head = NULL;\n      else\n      {  head = tail = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n         for (; form != NULL; form = form->next)\n         {  tail->coef = form->coef;\n            tail->var = form->var;\n            if (form->next != NULL)\ntail = (tail->next = dmp_get_atom(mpl->formulae, sizeof(FORMULA)));\n         }\n         tail->next = NULL;\n      }\n      return head;\n}",
      "lines": 19,
      "depth": 16,
      "decorators": [
        "FORMULA",
        "*copy_formula\n(     MPL *mpl,\n      FORMULA *form           /* not changed */\n)",
        "*"
      ]
    },
    "delete_formula": {
      "start_point": [
        1404,
        0
      ],
      "end_point": [
        1415,
        1
      ],
      "content": "void delete_formula\n(     MPL *mpl,\n      FORMULA *form           /* destroyed */\n)\n{     FORMULA *temp;\n      while (form != NULL)\n      {  temp = form;\n         form = form->next;\n         dmp_free_atom(mpl->formulae, temp, sizeof(FORMULA));\n      }\n      return;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "linear_comb": {
      "start_point": [
        1427,
        0
      ],
      "end_point": [
        1472,
        1
      ],
      "content": "FORMULA *linear_comb\n(     MPL *mpl,\n      double a, FORMULA *fx,  /* destroyed */\n      double b, FORMULA *fy   /* destroyed */\n)\n{     FORMULA *form = NULL, *term, *temp;\n      double c0 = 0.0;\n      for (term = fx; term != NULL; term = term->next)\n      {  if (term->var == NULL)\n            c0 = fp_add(mpl, c0, fp_mul(mpl, a, term->coef));\n         else\n            term->var->temp =\n               fp_add(mpl, term->var->temp, fp_mul(mpl, a, term->coef));\n      }\n      for (term = fy; term != NULL; term = term->next)\n      {  if (term->var == NULL)\n            c0 = fp_add(mpl, c0, fp_mul(mpl, b, term->coef));\n         else\n            term->var->temp =\n               fp_add(mpl, term->var->temp, fp_mul(mpl, b, term->coef));\n      }\n      for (term = fx; term != NULL; term = term->next)\n      {  if (term->var != NULL && term->var->temp != 0.0)\n         {  temp = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n            temp->coef = term->var->temp, temp->var = term->var;\n            temp->next = form, form = temp;\n            term->var->temp = 0.0;\n         }\n      }\n      for (term = fy; term != NULL; term = term->next)\n      {  if (term->var != NULL && term->var->temp != 0.0)\n         {  temp = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n            temp->coef = term->var->temp, temp->var = term->var;\n            temp->next = form, form = temp;\n            term->var->temp = 0.0;\n         }\n      }\n      if (c0 != 0.0)\n      {  temp = dmp_get_atom(mpl->formulae, sizeof(FORMULA));\n         temp->coef = c0, temp->var = NULL;\n         temp->next = form, form = temp;\n      }\n      delete_formula(mpl, fx);\n      delete_formula(mpl, fy);\n      return form;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "FORMULA",
        "*linear_comb\n(     MPL *mpl,\n      double a, FORMULA *fx,  /* destroyed */\n      double b, FORMULA *fy   /* destroyed */\n)",
        "*"
      ]
    },
    "remove_constant": {
      "start_point": [
        1480,
        0
      ],
      "end_point": [
        1502,
        1
      ],
      "content": "FORMULA *remove_constant\n(     MPL *mpl,\n      FORMULA *form,          /* destroyed */\n      double *coef            /* modified */\n)\n{     FORMULA *head = NULL, *temp;\n      *coef = 0.0;\n      while (form != NULL)\n      {  temp = form;\n         form = form->next;\n         if (temp->var == NULL)\n         {  /* constant term */\n            *coef = fp_add(mpl, *coef, temp->coef);\n            dmp_free_atom(mpl->formulae, temp, sizeof(FORMULA));\n         }\n         else\n         {  /* linear term */\n            temp->next = head;\n            head = temp;\n         }\n      }\n      return head;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "FORMULA",
        "*remove_constant\n(     MPL *mpl,\n      FORMULA *form,          /* destroyed */\n      double *coef            /* modified */\n)",
        "*"
      ]
    },
    "reduce_terms": {
      "start_point": [
        1509,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "FORMULA *reduce_terms\n(     MPL *mpl,\n      FORMULA *form           /* destroyed */\n)\n{     FORMULA *term, *next_term;\n      double c0 = 0.0;\n      for (term = form; term != NULL; term = term->next)\n      {  if (term->var == NULL)\n            c0 = fp_add(mpl, c0, term->coef);\n         else\n            term->var->temp = fp_add(mpl, term->var->temp, term->coef);\n      }\n      next_term = form, form = NULL;\n      for (term = next_term; term != NULL; term = next_term)\n      {  next_term = term->next;\n         if (term->var == NULL && c0 != 0.0)\n         {  term->coef = c0, c0 = 0.0;\n            term->next = form, form = term;\n         }\n         else if (term->var != NULL && term->var->temp != 0.0)\n         {  term->coef = term->var->temp, term->var->temp = 0.0;\n            term->next = form, form = term;\n         }\n         else\n            dmp_free_atom(mpl->formulae, term, sizeof(FORMULA));\n      }\n      return form;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "FORMULA",
        "*reduce_terms\n(     MPL *mpl,\n      FORMULA *form           /* destroyed */\n)",
        "*"
      ]
    },
    "delete_value": {
      "start_point": [
        1555,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "void delete_value\n(     MPL *mpl,\n      int type,\n      VALUE *value            /* content destroyed */\n)\n{     xassert(value != NULL);\n      switch (type)\n      {  case A_NONE:\n            value->none = NULL;\n            break;\n         case A_NUMERIC:\n            value->num = 0.0;\n            break;\n         case A_SYMBOLIC:\n            delete_symbol(mpl, value->sym), value->sym = NULL;\n            break;\n         case A_LOGICAL:\n            value->bit = 0;\n            break;\n         case A_TUPLE:\n            delete_tuple(mpl, value->tuple), value->tuple = NULL;\n            break;\n         case A_ELEMSET:\n            delete_elemset(mpl, value->set), value->set = NULL;\n            break;\n         case A_ELEMVAR:\n            value->var = NULL;\n            break;\n         case A_FORMULA:\n            delete_formula(mpl, value->form), value->form = NULL;\n            break;\n         case A_ELEMCON:\n            value->con = NULL;\n            break;\n         default:\n            xassert(type != type);\n      }\n      return;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "create_array": {
      "start_point": [
        1618,
        0
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "ARRAY *create_array(MPL *mpl, int type, int dim)\n{     ARRAY *array;\n      xassert(type == A_NONE || type == A_NUMERIC ||\n             type == A_SYMBOLIC || type == A_ELEMSET ||\n             type == A_ELEMVAR || type == A_ELEMCON);\n      xassert(dim >= 0);\n      array = dmp_get_atom(mpl->arrays, sizeof(ARRAY));\n      array->type = type;\n      array->dim = dim;\n      array->size = 0;\n      array->head = NULL;\n      array->tail = NULL;\n      array->tree = NULL;\n      array->prev = NULL;\n      array->next = mpl->a_list;\n      /* include the array in the global array list */\n      if (array->next != NULL) array->next->prev = array;\n      mpl->a_list = array;\n      return array;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ARRAY",
        "*create_array(MPL *mpl, int type, int dim)",
        "*"
      ]
    },
    "compare_member_tuples": {
      "start_point": [
        1647,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static int compare_member_tuples(void *info, const void *key1,\n      const void *key2)\n{     /* this is an auxiliary routine used to compare keys, which are\n         n-tuples assigned to array members */\n      return compare_tuples((MPL *)info, (TUPLE *)key1, (TUPLE *)key2);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_member": {
      "start_point": [
        1654,
        0
      ],
      "end_point": [
        1684,
        1
      ],
      "content": "MEMBER *find_member\n(     MPL *mpl,\n      ARRAY *array,           /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      xassert(array != NULL);\n      /* the n-tuple must have the same dimension as the array */\n      xassert(tuple_dimen(mpl, tuple) == array->dim);\n      /* if the array is large enough, create the search tree and index\n         all existing members of the array */\n      if (array->size > 30 && array->tree == NULL)\n      {  array->tree = avl_create_tree(compare_member_tuples, mpl);\n         for (memb = array->head; memb != NULL; memb = memb->next)\navl_set_node_link(avl_insert_node(array->tree, memb->tuple),\n               (void *)memb);\n      }\n      /* find a member, which has the given tuple */\n      if (array->tree == NULL)\n      {  /* the search tree doesn't exist; use the linear search */\n         for (memb = array->head; memb != NULL; memb = memb->next)\n            if (compare_tuples(mpl, memb->tuple, tuple) == 0) break;\n      }\n      else\n      {  /* the search tree exists; use the binary search */\n         AVLNODE *node;\n         node = avl_find_node(array->tree, tuple);\nmemb = (MEMBER *)(node == NULL ? NULL : avl_get_node_link(node));\n      }\n      return memb;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "MEMBER",
        "*find_member\n(     MPL *mpl,\n      ARRAY *array,           /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "add_member": {
      "start_point": [
        1701,
        0
      ],
      "end_point": [
        1727,
        1
      ],
      "content": "MEMBER *add_member\n(     MPL *mpl,\n      ARRAY *array,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)\n{     MEMBER *memb;\n      xassert(array != NULL);\n      /* the n-tuple must have the same dimension as the array */\n      xassert(tuple_dimen(mpl, tuple) == array->dim);\n      /* create new member */\n      memb = dmp_get_atom(mpl->members, sizeof(MEMBER));\n      memb->tuple = tuple;\n      memb->next = NULL;\n      memset(&memb->value, '?', sizeof(VALUE));\n      /* and append it to the member list */\n      array->size++;\n      if (array->head == NULL)\n         array->head = memb;\n      else\n         array->tail->next = memb;\n      array->tail = memb;\n      /* if the search tree exists, index the new member */\n      if (array->tree != NULL)\navl_set_node_link(avl_insert_node(array->tree, memb->tuple),\n            (void *)memb);\n      return memb;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "MEMBER",
        "*add_member\n(     MPL *mpl,\n      ARRAY *array,           /* modified */\n      TUPLE *tuple            /* destroyed */\n)",
        "*"
      ]
    },
    "delete_array": {
      "start_point": [
        1738,
        0
      ],
      "end_point": [
        1765,
        1
      ],
      "content": "void delete_array\n(     MPL *mpl,\n      ARRAY *array            /* destroyed */\n)\n{     MEMBER *memb;\n      xassert(array != NULL);\n      /* delete all existing array members */\n      while (array->head != NULL)\n      {  memb = array->head;\n         array->head = memb->next;\n         delete_tuple(mpl, memb->tuple);\n         dmp_free_atom(mpl->members, memb, sizeof(MEMBER));\n      }\n      /* if the search tree exists, also delete it */\n      if (array->tree != NULL) avl_delete_tree(array->tree);\n      /* remove the array from the global array list */\n      if (array->prev == NULL)\n         mpl->a_list = array->next;\n      else\n         array->prev->next = array->next;\n      if (array->next == NULL)\n         ;\n      else\n         array->next->prev = array->prev;\n      /* delete the array descriptor */\n      dmp_free_atom(mpl->arrays, array, sizeof(ARRAY));\n      return;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "assign_dummy_index": {
      "start_point": [
        1778,
        0
      ],
      "end_point": [
        1814,
        1
      ],
      "content": "void assign_dummy_index\n(     MPL *mpl,\n      DOMAIN_SLOT *slot,      /* modified */\n      SYMBOL *value           /* not changed */\n)\n{     CODE *leaf, *code;\n      xassert(slot != NULL);\n      xassert(value != NULL);\n      /* delete the current value assigned to the dummy index */\n      if (slot->value != NULL)\n      {  /* if the current value and the new one are identical, actual\n            assignment is not needed */\n         if (compare_symbols(mpl, slot->value, value) == 0) goto done;\n         /* delete a symbol, which is the current value */\n         delete_symbol(mpl, slot->value), slot->value = NULL;\n      }\n      /* now walk through all the pseudo-codes with op = O_INDEX, which\n         refer to the dummy index to be changed (these pseudo-codes are\n         leaves in the forest of *all* expressions in the database) */\n      for (leaf = slot->list; leaf != NULL; leaf = leaf->arg.index.\n         next)\n      {  xassert(leaf->op == O_INDEX);\n         /* invalidate all resultant values, which depend on the dummy\n            index, walking from the current leaf toward the root of the\n            corresponding expression tree */\n         for (code = leaf; code != NULL; code = code->up)\n         {  if (code->valid)\n            {  /* invalidate and delete resultant value */\n               code->valid = 0;\n               delete_value(mpl, code->type, &code->value);\n            }\n         }\n      }\n      /* assign new value to the dummy index */\n      slot->value = copy_symbol(mpl, value);\ndone: return;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "update_dummy_indices": {
      "start_point": [
        1823,
        0
      ],
      "end_point": [
        1838,
        1
      ],
      "content": "void update_dummy_indices\n(     MPL *mpl,\n      DOMAIN_BLOCK *block     /* not changed */\n)\n{     DOMAIN_SLOT *slot;\n      TUPLE *temp;\n      if (block->backup != NULL)\n      {  for (slot = block->list, temp = block->backup; slot != NULL;\n            slot = slot->next, temp = temp->next)\n         {  xassert(temp != NULL);\n            xassert(temp->sym != NULL);\n            assign_dummy_index(mpl, slot, temp->sym);\n         }\n      }\n      return;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "enter_domain_block": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1911,
        1
      ],
      "content": "int enter_domain_block\n(     MPL *mpl,\n      DOMAIN_BLOCK *block,    /* not changed */\n      TUPLE *tuple,           /* not changed */\n      void *info, void (*func)(MPL *mpl, void *info)\n)\n{     TUPLE *backup;\n      int ret = 0;\n      /* check if the given n-tuple is a member of the basic set */\n      xassert(block->code != NULL);\n      if (!is_member(mpl, block->code, tuple))\n      {  ret = 1;\n         goto done;\n      }\n      /* save reference to \"backup\" n-tuple, which was used to assign\n         current values of the dummy indices (it is sufficient to save\n         reference, not value, because that n-tuple is defined in some\n         outer level of recursion and therefore cannot be changed on\n         this and deeper recursive calls) */\n      backup = block->backup;\n      /* set up new \"backup\" n-tuple, which defines new values of the\n         dummy indices */\n      block->backup = tuple;\n      /* assign new values to the dummy indices */\n      update_dummy_indices(mpl, block);\n      /* call the formal routine that does the rest part of the job */\n      func(mpl, info);\n      /* restore reference to the former \"backup\" n-tuple */\n      block->backup = backup;\n      /* restore former values of the dummy indices; note that if the\n         domain block just escaped has no other active instances which\n         may exist due to recursion (it is indicated by a null pointer\n         to the former n-tuple), former values of the dummy indices are\n         undefined; therefore in this case the routine keeps currently\n         assigned values of the dummy indices that involves keeping all\n         dependent temporary results and thereby, if this domain block\n         is not used recursively, allows improving efficiency */\n      update_dummy_indices(mpl, block);\ndone: return ret;\n}",
      "lines": 40,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "eval_domain_func": {
      "start_point": [
        1958,
        0
      ],
      "end_point": [
        2033,
        1
      ],
      "content": "static void eval_domain_func(MPL *mpl, void *_my_info)\n{     /* this routine recursively enters into the domain scope and then\n         calls the routine func */\n      struct eval_domain_info *my_info = _my_info;\n      if (my_info->block != NULL)\n      {  /* the current domain block to be entered exists */\n         DOMAIN_BLOCK *block;\n         DOMAIN_SLOT *slot;\n         TUPLE *tuple = NULL, *temp = NULL;\n         /* save pointer to the current domain block */\n         block = my_info->block;\n         /* and get ready to enter the next block (if it exists) */\n         my_info->block = block->next;\n         /* construct temporary n-tuple, whose components correspond to\n            dummy indices (slots) of the current domain; components of\n            the temporary n-tuple that correspond to free dummy indices\n            are assigned references (not values!) to symbols specified\n            in the corresponding components of the given n-tuple, while\n            other components that correspond to non-free dummy indices\n            are assigned symbolic values computed here */\n         for (slot = block->list; slot != NULL; slot = slot->next)\n         {  /* create component that corresponds to the current slot */\n            if (tuple == NULL)\n               tuple = temp = dmp_get_atom(mpl->tuples, sizeof(TUPLE));\n            else\ntemp = (temp->next = dmp_get_atom(mpl->tuples, sizeof(TUPLE)));\n            if (slot->code == NULL)\n            {  /* dummy index is free; take reference to symbol, which\n                  is specified in the corresponding component of given\n                  n-tuple */\n               xassert(my_info->tuple != NULL);\n               temp->sym = my_info->tuple->sym;\n               xassert(temp->sym != NULL);\n               my_info->tuple = my_info->tuple->next;\n            }\n            else\n            {  /* dummy index is non-free; compute symbolic value to be\n                  temporarily assigned to the dummy index */\n               temp->sym = eval_symbolic(mpl, slot->code);\n            }\n         }\n         temp->next = NULL;\n         /* enter the current domain block */\n         if (enter_domain_block(mpl, block, tuple, my_info,\n               eval_domain_func)) my_info->failure = 1;\n         /* delete temporary n-tuple as well as symbols that correspond\n            to non-free dummy indices (they were computed here) */\n         for (slot = block->list; slot != NULL; slot = slot->next)\n         {  xassert(tuple != NULL);\n            temp = tuple;\n            tuple = tuple->next;\n            if (slot->code != NULL)\n            {  /* dummy index is non-free; delete symbolic value */\n               delete_symbol(mpl, temp->sym);\n            }\n            /* delete component that corresponds to the current slot */\n            dmp_free_atom(mpl->tuples, temp, sizeof(TUPLE));\n         }\n      }\n      else\n      {  /* there are no more domain blocks, i.e. we have reached the\n            domain scope */\n         xassert(my_info->tuple == NULL);\n         /* check optional predicate specified for the domain */\n         if (my_info->domain->code != NULL && !eval_logical(mpl,\n            my_info->domain->code))\n         {  /* the predicate is false */\n            my_info->failure = 2;\n         }\n         else\n         {  /* the predicate is true; do the job */\n            my_info->func(mpl, my_info->info);\n         }\n      }\n      return;\n}",
      "lines": 76,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_within_domain": {
      "start_point": [
        2035,
        0
      ],
      "end_point": [
        2060,
        1
      ],
      "content": "int eval_within_domain\n(     MPL *mpl,\n      DOMAIN *domain,         /* not changed */\n      TUPLE *tuple,           /* not changed */\n      void *info, void (*func)(MPL *mpl, void *info)\n)\n{     /* this routine performs evaluation within domain scope */\n      struct eval_domain_info _my_info, *my_info = &_my_info;\n      if (domain == NULL)\n      {  xassert(tuple == NULL);\n         func(mpl, info);\n         my_info->failure = 0;\n      }\n      else\n      {  xassert(tuple != NULL);\n         my_info->domain = domain;\n         my_info->block = domain->list;\n         my_info->tuple = tuple;\n         my_info->info = info;\n         my_info->func = func;\n         my_info->failure = 0;\n         /* enter the very first domain block */\n         eval_domain_func(mpl, my_info);\n      }\n      return my_info->failure;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "loop_domain_func": {
      "start_point": [
        2094,
        0
      ],
      "end_point": [
        2212,
        1
      ],
      "content": "static void loop_domain_func(MPL *mpl, void *_my_info)\n{     /* this routine enumerates all n-tuples in the basic set of the\n         current domain block, enters recursively into the domain scope\n         for every n-tuple, and then calls the routine func */\n      struct loop_domain_info *my_info = _my_info;\n      if (my_info->block != NULL)\n      {  /* the current domain block to be entered exists */\n         DOMAIN_BLOCK *block;\n         DOMAIN_SLOT *slot;\n         TUPLE *bound;\n         /* save pointer to the current domain block */\n         block = my_info->block;\n         /* and get ready to enter the next block (if it exists) */\n         my_info->block = block->next;\n         /* compute symbolic values, at which non-free dummy indices of\n            the current domain block are bound; since that values don't\n            depend on free dummy indices of the current block, they can\n            be computed once out of the enumeration loop */\n         bound = create_tuple(mpl);\n         for (slot = block->list; slot != NULL; slot = slot->next)\n         {  if (slot->code != NULL)\n               bound = expand_tuple(mpl, bound, eval_symbolic(mpl,\n                  slot->code));\n         }\n         /* start enumeration */\n         xassert(block->code != NULL);\n         if (block->code->op == O_DOTS)\n         {  /* the basic set is \"arithmetic\", in which case it doesn't\n               need to be computed explicitly */\n            TUPLE *tuple;\n            int n, j;\n            double t0, tf, dt;\n            /* compute \"parameters\" of the basic set */\n            t0 = eval_numeric(mpl, block->code->arg.arg.x);\n            tf = eval_numeric(mpl, block->code->arg.arg.y);\n            if (block->code->arg.arg.z == NULL)\n               dt = 1.0;\n            else\n               dt = eval_numeric(mpl, block->code->arg.arg.z);\n            /* determine cardinality of the basic set */\n            n = arelset_size(mpl, t0, tf, dt);\n            /* create dummy 1-tuple for members of the basic set */\n            tuple = expand_tuple(mpl, create_tuple(mpl),\n               create_symbol_num(mpl, 0.0));\n            /* in case of \"arithmetic\" set there is exactly one dummy\n               index, which cannot be non-free */\n            xassert(bound == NULL);\n            /* walk through 1-tuples of the basic set */\n            for (j = 1; j <= n && my_info->looping; j++)\n            {  /* construct dummy 1-tuple for the current member */\n               tuple->sym->num = arelset_member(mpl, t0, tf, dt, j);\n               /* enter the current domain block */\n               enter_domain_block(mpl, block, tuple, my_info,\n                  loop_domain_func);\n            }\n            /* delete dummy 1-tuple */\n            delete_tuple(mpl, tuple);\n         }\n         else\n         {  /* the basic set is of general kind, in which case it needs\n               to be explicitly computed */\n            ELEMSET *set;\n            MEMBER *memb;\n            TUPLE *temp1, *temp2;\n            /* compute the basic set */\n            set = eval_elemset(mpl, block->code);\n            /* walk through all n-tuples of the basic set */\n            for (memb = set->head; memb != NULL && my_info->looping;\n               memb = memb->next)\n            {  /* all components of the current n-tuple that correspond\n                  to non-free dummy indices must be feasible; otherwise\n                  the n-tuple is not in the basic set */\n               temp1 = memb->tuple;\n               temp2 = bound;\n               for (slot = block->list; slot != NULL; slot = slot->next)\n               {  xassert(temp1 != NULL);\n                  if (slot->code != NULL)\n                  {  /* non-free dummy index */\n                     xassert(temp2 != NULL);\n                     if (compare_symbols(mpl, temp1->sym, temp2->sym)\n                        != 0)\n                     {  /* the n-tuple is not in the basic set */\n                        goto skip;\n                     }\n                     temp2 = temp2->next;\n                  }\n                  temp1 = temp1->next;\n               }\n               xassert(temp1 == NULL);\n               xassert(temp2 == NULL);\n               /* enter the current domain block */\n               enter_domain_block(mpl, block, memb->tuple, my_info,\n                  loop_domain_func);\nskip:          ;\n            }\n            /* delete the basic set */\n            delete_elemset(mpl, set);\n         }\n         /* delete symbolic values binding non-free dummy indices */\n         delete_tuple(mpl, bound);\n         /* restore pointer to the current domain block */\n         my_info->block = block;\n      }\n      else\n      {  /* there are no more domain blocks, i.e. we have reached the\n            domain scope */\n         /* check optional predicate specified for the domain */\n         if (my_info->domain->code != NULL && !eval_logical(mpl,\n            my_info->domain->code))\n         {  /* the predicate is false */\n            /* nop */;\n         }\n         else\n         {  /* the predicate is true; do the job */\n            my_info->looping = !my_info->func(mpl, my_info->info);\n         }\n      }\n      return;\n}",
      "lines": 119,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "loop_within_domain": {
      "start_point": [
        2214,
        0
      ],
      "end_point": [
        2233,
        1
      ],
      "content": "void loop_within_domain\n(     MPL *mpl,\n      DOMAIN *domain,         /* not changed */\n      void *info, int (*func)(MPL *mpl, void *info)\n)\n{     /* this routine performs iterations within domain scope */\n      struct loop_domain_info _my_info, *my_info = &_my_info;\n      if (domain == NULL)\n         func(mpl, info);\n      else\n      {  my_info->domain = domain;\n         my_info->block = domain->list;\n         my_info->looping = 1;\n         my_info->info = info;\n         my_info->func = func;\n         /* enter the very first domain block */\n         loop_domain_func(mpl, my_info);\n      }\n      return;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "out_of_domain": {
      "start_point": [
        2241,
        0
      ],
      "end_point": [
        2251,
        1
      ],
      "content": "void out_of_domain\n(     MPL *mpl,\n      char *name,             /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     xassert(name != NULL);\n      xassert(tuple != NULL);\n      error(mpl, \"%s%s out of domain\", name, format_tuple(mpl, '[',\n         tuple));\n      /* no return */\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "get_domain_tuple": {
      "start_point": [
        2264,
        0
      ],
      "end_point": [
        2284,
        1
      ],
      "content": "TUPLE *get_domain_tuple\n(     MPL *mpl,\n      DOMAIN *domain          /* not changed */\n)\n{     DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      TUPLE *tuple;\n      tuple = create_tuple(mpl);\n      if (domain != NULL)\n      {  for (block = domain->list; block != NULL; block = block->next)\n         {  for (slot = block->list; slot != NULL; slot = slot->next)\n            {  if (slot->code == NULL)\n               {  xassert(slot->value != NULL);\n                  tuple = expand_tuple(mpl, tuple, copy_symbol(mpl,\n                     slot->value));\n               }\n            }\n         }\n      }\n      return tuple;\n}",
      "lines": 21,
      "depth": 18,
      "decorators": [
        "TUPLE",
        "*get_domain_tuple\n(     MPL *mpl,\n      DOMAIN *domain          /* not changed */\n)",
        "*"
      ]
    },
    "clean_domain": {
      "start_point": [
        2292,
        0
      ],
      "end_point": [
        2313,
        1
      ],
      "content": "void clean_domain(MPL *mpl, DOMAIN *domain)\n{     DOMAIN_BLOCK *block;\n      DOMAIN_SLOT *slot;\n      /* if no domain is specified, do nothing */\n      if (domain == NULL) goto done;\n      /* clean all domain blocks */\n      for (block = domain->list; block != NULL; block = block->next)\n      {  /* clean all domain slots */\n         for (slot = block->list; slot != NULL; slot = slot->next)\n         {  /* clean pseudo-code for computing bound value */\n            clean_code(mpl, slot->code);\n            /* delete symbolic value assigned to dummy index */\n            if (slot->value != NULL)\n               delete_symbol(mpl, slot->value), slot->value = NULL;\n         }\n         /* clean pseudo-code for computing basic set */\n         clean_code(mpl, block->code);\n      }\n      /* clean pseudo-code for computing domain predicate */\n      clean_code(mpl, domain->code);\ndone: return;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "check_elem_set": {
      "start_point": [
        2327,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "void check_elem_set\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      TUPLE *tuple,           /* not changed */\n      ELEMSET *refer          /* not changed */\n)\n{     WITHIN *within;\n      MEMBER *memb;\n      int eqno;\n      /* elemental set must be within all specified supersets */\n      for (within = set->within, eqno = 1; within != NULL; within =\n         within->next, eqno++)\n      {  xassert(within->code != NULL);\n         for (memb = refer->head; memb != NULL; memb = memb->next)\n         {  if (!is_member(mpl, within->code, memb->tuple))\n            {  char buf[255+1];\n               strcpy(buf, format_tuple(mpl, '(', memb->tuple));\n               xassert(strlen(buf) < sizeof(buf));\n               error(mpl, \"%s%s contains %s which not within specified \"\n                  \"set; see (%d)\", set->name, format_tuple(mpl, '[',\n                     tuple), buf, eqno);\n            }\n         }\n      }\n      return;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "take_member_set": {
      "start_point": [
        2362,
        0
      ],
      "end_point": [
        2395,
        1
      ],
      "content": "ELEMSET *take_member_set      /* returns reference, not value */\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      ELEMSET *refer;\n      /* find member in the set array */\n      memb = find_member(mpl, set->array, tuple);\n      if (memb != NULL)\n      {  /* member exists, so just take the reference */\n         refer = memb->value.set;\n      }\n      else if (set->assign != NULL)\n      {  /* compute value using assignment expression */\n         refer = eval_elemset(mpl, set->assign);\nadd:     /* check that the elemental set satisfies to all restrictions,\n            assign it to new member, and add the member to the array */\n         check_elem_set(mpl, set, tuple, refer);\n         memb = add_member(mpl, set->array, copy_tuple(mpl, tuple));\n         memb->value.set = refer;\n      }\n      else if (set->option != NULL)\n      {  /* compute default elemental set */\n         refer = eval_elemset(mpl, set->option);\n         goto add;\n      }\n      else\n      {  /* no value (elemental set) is provided */\n         error(mpl, \"no value for %s%s\", set->name, format_tuple(mpl,\n            '[', tuple));\n      }\n      return refer;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "ELEMSET",
        "*take_member_set      /* returns reference, not value */\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "eval_set_func": {
      "start_point": [
        2419,
        0
      ],
      "end_point": [
        2432,
        1
      ],
      "content": "static void eval_set_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine to work within domain scope */\n      struct eval_set_info *info = _info;\n      if (info->memb != NULL)\n      {  /* checking call; check elemental set being assigned */\n         check_elem_set(mpl, info->set, info->memb->tuple,\n            info->memb->value.set);\n      }\n      else\n      {  /* normal call; evaluate member, which has given n-tuple */\n         info->refer = take_member_set(mpl, info->set, info->tuple);\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "saturate_set": {
      "start_point": [
        2435,
        0
      ],
      "end_point": [
        2492,
        1
      ],
      "content": "static void saturate_set(MPL *mpl, SET *set)\n{     GADGET *gadget = set->gadget;\n      ELEMSET *data;\n      MEMBER *elem, *memb;\n      TUPLE *tuple, *work[20];\n      int i;\n      xprintf(\"Generating %s...\\n\", set->name);\n      eval_whole_set(mpl, gadget->set);\n      /* gadget set must have exactly one member */\n      xassert(gadget->set->array != NULL);\n      xassert(gadget->set->array->head != NULL);\n      xassert(gadget->set->array->head == gadget->set->array->tail);\n      data = gadget->set->array->head->value.set;\n      xassert(data->type == A_NONE);\n      xassert(data->dim == gadget->set->dimen);\n      /* walk thru all elements of the plain set */\n      for (elem = data->head; elem != NULL; elem = elem->next)\n      {  /* create a copy of n-tuple */\n         tuple = copy_tuple(mpl, elem->tuple);\n         /* rearrange component of the n-tuple */\n         for (i = 0; i < gadget->set->dimen; i++)\n            work[i] = NULL;\n         for (i = 0; tuple != NULL; tuple = tuple->next)\n            work[gadget->ind[i++]-1] = tuple;\n         xassert(i == gadget->set->dimen);\n         for (i = 0; i < gadget->set->dimen; i++)\n         {  xassert(work[i] != NULL);\n            work[i]->next = work[i+1];\n         }\n         /* construct subscript list from first set->dim components */\n         if (set->dim == 0)\n            tuple = NULL;\n         else\n            tuple = work[0], work[set->dim-1]->next = NULL;\n         /* find corresponding member of the set to be initialized */\n         memb = find_member(mpl, set->array, tuple);\n         if (memb == NULL)\n         {  /* not found; add new member to the set and assign it empty\n               elemental set */\n            memb = add_member(mpl, set->array, tuple);\n            memb->value.set = create_elemset(mpl, set->dimen);\n         }\n         else\n         {  /* found; free subscript list */\n            delete_tuple(mpl, tuple);\n         }\n         /* construct new n-tuple from rest set->dimen components */\n         tuple = work[set->dim];\n         xassert(set->dim + set->dimen == gadget->set->dimen);\n         work[gadget->set->dimen-1]->next = NULL;\n         /* and add it to the elemental set assigned to the member\n            (no check for duplicates is needed) */\n         add_tuple(mpl, memb->value.set, tuple);\n      }\n      /* the set has been saturated with data */\n      set->data = 1;\n      return;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_member_set": {
      "start_point": [
        2495,
        0
      ],
      "end_point": [
        2542,
        1
      ],
      "content": "ELEMSET *eval_member_set      /* returns reference, not value */\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     /* this routine evaluates set member */\n      struct eval_set_info _info, *info = &_info;\n      xassert(set->dim == tuple_dimen(mpl, tuple));\n      info->set = set;\n      info->tuple = tuple;\n#if 1 /* 12/XII-2008 */\n      if (set->gadget != NULL && set->data == 0)\n      {  /* initialize the set with data from a plain set */\n         saturate_set(mpl, set);\n      }\n#endif\n      if (set->data == 1)\n      {  /* check data, which are provided in the data section, but not\n            checked yet */\n         /* save pointer to the last array member; note that during the\n            check new members may be added beyond the last member due to\n            references to the same parameter from default expression as\n            well as from expressions that define restricting supersets;\n            however, values assigned to the new members will be checked\n            by other routine, so we don't need to check them here */\n         MEMBER *tail = set->array->tail;\n         /* change the data status to prevent infinite recursive loop\n            due to references to the same set during the check */\n         set->data = 2;\n         /* check elemental sets assigned to array members in the data\n            section until the marked member has been reached */\n         for (info->memb = set->array->head; info->memb != NULL;\n            info->memb = info->memb->next)\n         {  if (eval_within_domain(mpl, set->domain, info->memb->tuple,\n               info, eval_set_func))\n               out_of_domain(mpl, set->name, info->memb->tuple);\n            if (info->memb == tail) break;\n         }\n         /* the check has been finished */\n      }\n      /* evaluate member, which has given n-tuple */\n      info->memb = NULL;\n      if (eval_within_domain(mpl, info->set->domain, info->tuple, info,\n         eval_set_func))\n      out_of_domain(mpl, set->name, info->tuple);\n      /* bring evaluated reference to the calling program */\n      return info->refer;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "ELEMSET",
        "*eval_member_set      /* returns reference, not value */\n(     MPL *mpl,\n      SET *set,               /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "whole_set_func": {
      "start_point": [
        2550,
        0
      ],
      "end_point": [
        2557,
        1
      ],
      "content": "static int whole_set_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      SET *set = (SET *)info;\n      TUPLE *tuple = get_domain_tuple(mpl, set->domain);\n      eval_member_set(mpl, set, tuple);\n      delete_tuple(mpl, tuple);\n      return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_whole_set": {
      "start_point": [
        2559,
        0
      ],
      "end_point": [
        2562,
        1
      ],
      "content": "void eval_whole_set(MPL *mpl, SET *set)\n{     loop_within_domain(mpl, set->domain, set, whole_set_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_set": {
      "start_point": [
        2570,
        0
      ],
      "end_point": [
        2589,
        1
      ],
      "content": "void clean_set(MPL *mpl, SET *set)\n{     WITHIN *within;\n      MEMBER *memb;\n      /* clean subscript domain */\n      clean_domain(mpl, set->domain);\n      /* clean pseudo-code for computing supersets */\n      for (within = set->within; within != NULL; within = within->next)\n         clean_code(mpl, within->code);\n      /* clean pseudo-code for computing assigned value */\n      clean_code(mpl, set->assign);\n      /* clean pseudo-code for computing default value */\n      clean_code(mpl, set->option);\n      /* reset data status flag */\n      set->data = 0;\n      /* delete content array */\n      for (memb = set->array->head; memb != NULL; memb = memb->next)\n         delete_value(mpl, set->array->type, &memb->value);\n      delete_array(mpl, set->array), set->array = NULL;\n      return;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "check_value_num": {
      "start_point": [
        2603,
        0
      ],
      "end_point": [
        2678,
        1
      ],
      "content": "void check_value_num\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple,           /* not changed */\n      double value\n)\n{     CONDITION *cond;\n      WITHIN *in;\n      int eqno;\n      /* the value must satisfy to the parameter type */\n      switch (par->type)\n      {  case A_NUMERIC:\n            break;\n         case A_INTEGER:\n            if (value != floor(value))\n               error(mpl, \"%s%s = %.*g not integer\", par->name,\n                  format_tuple(mpl, '[', tuple), DBL_DIG, value);\n            break;\n         case A_BINARY:\n            if (!(value == 0.0 || value == 1.0))\n               error(mpl, \"%s%s = %.*g not binary\", par->name,\n                  format_tuple(mpl, '[', tuple), DBL_DIG, value);\n            break;\n         default:\n            xassert(par != par);\n      }\n      /* the value must satisfy to all specified conditions */\n      for (cond = par->cond, eqno = 1; cond != NULL; cond = cond->next,\n         eqno++)\n      {  double bound;\n         char *rho;\n         xassert(cond->code != NULL);\n         bound = eval_numeric(mpl, cond->code);\n         switch (cond->rho)\n         {  case O_LT:\n               if (!(value < bound))\n               {  rho = \"<\";\nerr:              error(mpl, \"%s%s = %.*g not %s %.*g; see (%d)\",\n                     par->name, format_tuple(mpl, '[', tuple), DBL_DIG,\n                     value, rho, DBL_DIG, bound, eqno);\n               }\n               break;\n            case O_LE:\n               if (!(value <= bound)) { rho = \"<=\"; goto err; }\n               break;\n            case O_EQ:\n               if (!(value == bound)) { rho = \"=\"; goto err; }\n               break;\n            case O_GE:\n               if (!(value >= bound)) { rho = \">=\"; goto err; }\n               break;\n            case O_GT:\n               if (!(value > bound)) { rho = \">\"; goto err; }\n               break;\n            case O_NE:\n               if (!(value != bound)) { rho = \"<>\"; goto err; }\n               break;\n            default:\n               xassert(cond != cond);\n         }\n      }\n      /* the value must be in all specified supersets */\n      for (in = par->in, eqno = 1; in != NULL; in = in->next, eqno++)\n      {  TUPLE *dummy;\n         xassert(in->code != NULL);\n         xassert(in->code->dim == 1);\n         dummy = expand_tuple(mpl, create_tuple(mpl),\n            create_symbol_num(mpl, value));\n         if (!is_member(mpl, in->code, dummy))\n            error(mpl, \"%s%s = %.*g not in specified set; see (%d)\",\n               par->name, format_tuple(mpl, '[', tuple), DBL_DIG,\n               value, eqno);\n         delete_tuple(mpl, dummy);\n      }\n      return;\n}",
      "lines": 76,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "take_member_num": {
      "start_point": [
        2688,
        0
      ],
      "end_point": [
        2729,
        1
      ],
      "content": "double take_member_num\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      double value;\n      /* find member in the parameter array */\n      memb = find_member(mpl, par->array, tuple);\n      if (memb != NULL)\n      {  /* member exists, so just take its value */\n         value = memb->value.num;\n      }\n      else if (par->assign != NULL)\n      {  /* compute value using assignment expression */\n         value = eval_numeric(mpl, par->assign);\nadd:     /* check that the value satisfies to all restrictions, assign\n            it to new member, and add the member to the array */\n         check_value_num(mpl, par, tuple, value);\n         memb = add_member(mpl, par->array, copy_tuple(mpl, tuple));\n         memb->value.num = value;\n      }\n      else if (par->option != NULL)\n      {  /* compute default value */\n         value = eval_numeric(mpl, par->option);\n         goto add;\n      }\n      else if (par->defval != NULL)\n      {  /* take default value provided in the data section */\n         if (par->defval->str != NULL)\n            error(mpl, \"cannot convert %s to floating-point number\",\n               format_symbol(mpl, par->defval));\n         value = par->defval->num;\n         goto add;\n      }\n      else\n      {  /* no value is provided */\n         error(mpl, \"no value for %s%s\", par->name, format_tuple(mpl,\n            '[', tuple));\n      }\n      return value;\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "double"
      ]
    },
    "eval_num_func": {
      "start_point": [
        2753,
        0
      ],
      "end_point": [
        2766,
        1
      ],
      "content": "static void eval_num_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine to work within domain scope */\n      struct eval_num_info *info = _info;\n      if (info->memb != NULL)\n      {  /* checking call; check numeric value being assigned */\n         check_value_num(mpl, info->par, info->memb->tuple,\n            info->memb->value.num);\n      }\n      else\n      {  /* normal call; evaluate member, which has given n-tuple */\n         info->value = take_member_num(mpl, info->par, info->tuple);\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_member_num": {
      "start_point": [
        2768,
        0
      ],
      "end_point": [
        2811,
        1
      ],
      "content": "double eval_member_num\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     /* this routine evaluates numeric parameter member */\n      struct eval_num_info _info, *info = &_info;\n      xassert(par->type == A_NUMERIC || par->type == A_INTEGER ||\n             par->type == A_BINARY);\n      xassert(par->dim == tuple_dimen(mpl, tuple));\n      info->par = par;\n      info->tuple = tuple;\n      if (par->data == 1)\n      {  /* check data, which are provided in the data section, but not\n            checked yet */\n         /* save pointer to the last array member; note that during the\n            check new members may be added beyond the last member due to\n            references to the same parameter from default expression as\n            well as from expressions that define restricting conditions;\n            however, values assigned to the new members will be checked\n            by other routine, so we don't need to check them here */\n         MEMBER *tail = par->array->tail;\n         /* change the data status to prevent infinite recursive loop\n            due to references to the same parameter during the check */\n         par->data = 2;\n         /* check values assigned to array members in the data section\n            until the marked member has been reached */\n         for (info->memb = par->array->head; info->memb != NULL;\n            info->memb = info->memb->next)\n         {  if (eval_within_domain(mpl, par->domain, info->memb->tuple,\n               info, eval_num_func))\n               out_of_domain(mpl, par->name, info->memb->tuple);\n            if (info->memb == tail) break;\n         }\n         /* the check has been finished */\n      }\n      /* evaluate member, which has given n-tuple */\n      info->memb = NULL;\n      if (eval_within_domain(mpl, info->par->domain, info->tuple, info,\n         eval_num_func))\n         out_of_domain(mpl, par->name, info->tuple);\n      /* bring evaluated value to the calling program */\n      return info->value;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "check_value_sym": {
      "start_point": [
        2821,
        0
      ],
      "end_point": [
        2916,
        1
      ],
      "content": "void check_value_sym\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple,           /* not changed */\n      SYMBOL *value           /* not changed */\n)\n{     CONDITION *cond;\n      WITHIN *in;\n      int eqno;\n      /* the value must satisfy to all specified conditions */\n      for (cond = par->cond, eqno = 1; cond != NULL; cond = cond->next,\n         eqno++)\n      {  SYMBOL *bound;\n         char buf[255+1];\n         xassert(cond->code != NULL);\n         bound = eval_symbolic(mpl, cond->code);\n         switch (cond->rho)\n         {\n#if 1 /* 13/VIII-2008 */\n            case O_LT:\n               if (!(compare_symbols(mpl, value, bound) < 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not < %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n            case O_LE:\n               if (!(compare_symbols(mpl, value, bound) <= 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not <= %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n#endif\n            case O_EQ:\n               if (!(compare_symbols(mpl, value, bound) == 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not = %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n#if 1 /* 13/VIII-2008 */\n            case O_GE:\n               if (!(compare_symbols(mpl, value, bound) >= 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not >= %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n            case O_GT:\n               if (!(compare_symbols(mpl, value, bound) > 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not > %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n#endif\n            case O_NE:\n               if (!(compare_symbols(mpl, value, bound) != 0))\n               {  strcpy(buf, format_symbol(mpl, bound));\n                  xassert(strlen(buf) < sizeof(buf));\n                  error(mpl, \"%s%s = %s not <> %s\",\n                     par->name, format_tuple(mpl, '[', tuple),\n                     format_symbol(mpl, value), buf, eqno);\n               }\n               break;\n            default:\n               xassert(cond != cond);\n         }\n         delete_symbol(mpl, bound);\n      }\n      /* the value must be in all specified supersets */\n      for (in = par->in, eqno = 1; in != NULL; in = in->next, eqno++)\n      {  TUPLE *dummy;\n         xassert(in->code != NULL);\n         xassert(in->code->dim == 1);\n         dummy = expand_tuple(mpl, create_tuple(mpl), copy_symbol(mpl,\n            value));\n         if (!is_member(mpl, in->code, dummy))\n            error(mpl, \"%s%s = %s not in specified set; see (%d)\",\n               par->name, format_tuple(mpl, '[', tuple),\n               format_symbol(mpl, value), eqno);\n         delete_tuple(mpl, dummy);\n      }\n      return;\n}",
      "lines": 96,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "take_member_sym": {
      "start_point": [
        2926,
        0
      ],
      "end_point": [
        2964,
        1
      ],
      "content": "SYMBOL *take_member_sym       /* returns value, not reference */\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      SYMBOL *value;\n      /* find member in the parameter array */\n      memb = find_member(mpl, par->array, tuple);\n      if (memb != NULL)\n      {  /* member exists, so just take its value */\n         value = copy_symbol(mpl, memb->value.sym);\n      }\n      else if (par->assign != NULL)\n      {  /* compute value using assignment expression */\n         value = eval_symbolic(mpl, par->assign);\nadd:     /* check that the value satisfies to all restrictions, assign\n            it to new member, and add the member to the array */\n         check_value_sym(mpl, par, tuple, value);\n         memb = add_member(mpl, par->array, copy_tuple(mpl, tuple));\n         memb->value.sym = copy_symbol(mpl, value);\n      }\n      else if (par->option != NULL)\n      {  /* compute default value */\n         value = eval_symbolic(mpl, par->option);\n         goto add;\n      }\n      else if (par->defval != NULL)\n      {  /* take default value provided in the data section */\n         value = copy_symbol(mpl, par->defval);\n         goto add;\n      }\n      else\n      {  /* no value is provided */\n         error(mpl, \"no value for %s%s\", par->name, format_tuple(mpl,\n            '[', tuple));\n      }\n      return value;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "SYMBOL",
        "*take_member_sym       /* returns value, not reference */\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "eval_sym_func": {
      "start_point": [
        2988,
        0
      ],
      "end_point": [
        3001,
        1
      ],
      "content": "static void eval_sym_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine to work within domain scope */\n      struct eval_sym_info *info = _info;\n      if (info->memb != NULL)\n      {  /* checking call; check symbolic value being assigned */\n         check_value_sym(mpl, info->par, info->memb->tuple,\n            info->memb->value.sym);\n      }\n      else\n      {  /* normal call; evaluate member, which has given n-tuple */\n         info->value = take_member_sym(mpl, info->par, info->tuple);\n      }\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_member_sym": {
      "start_point": [
        3003,
        0
      ],
      "end_point": [
        3045,
        1
      ],
      "content": "SYMBOL *eval_member_sym       /* returns value, not reference */\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     /* this routine evaluates symbolic parameter member */\n      struct eval_sym_info _info, *info = &_info;\n      xassert(par->type == A_SYMBOLIC);\n      xassert(par->dim == tuple_dimen(mpl, tuple));\n      info->par = par;\n      info->tuple = tuple;\n      if (par->data == 1)\n      {  /* check data, which are provided in the data section, but not\n            checked yet */\n         /* save pointer to the last array member; note that during the\n            check new members may be added beyond the last member due to\n            references to the same parameter from default expression as\n            well as from expressions that define restricting conditions;\n            however, values assigned to the new members will be checked\n            by other routine, so we don't need to check them here */\n         MEMBER *tail = par->array->tail;\n         /* change the data status to prevent infinite recursive loop\n            due to references to the same parameter during the check */\n         par->data = 2;\n         /* check values assigned to array members in the data section\n            until the marked member has been reached */\n         for (info->memb = par->array->head; info->memb != NULL;\n            info->memb = info->memb->next)\n         {  if (eval_within_domain(mpl, par->domain, info->memb->tuple,\n               info, eval_sym_func))\n               out_of_domain(mpl, par->name, info->memb->tuple);\n            if (info->memb == tail) break;\n         }\n         /* the check has been finished */\n      }\n      /* evaluate member, which has given n-tuple */\n      info->memb = NULL;\n      if (eval_within_domain(mpl, info->par->domain, info->tuple, info,\n         eval_sym_func))\n         out_of_domain(mpl, par->name, info->tuple);\n      /* bring evaluated value to the calling program */\n      return info->value;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "SYMBOL",
        "*eval_member_sym       /* returns value, not reference */\n(     MPL *mpl,\n      PARAMETER *par,         /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "whole_par_func": {
      "start_point": [
        3053,
        0
      ],
      "end_point": [
        3071,
        1
      ],
      "content": "static int whole_par_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      PARAMETER *par = (PARAMETER *)info;\n      TUPLE *tuple = get_domain_tuple(mpl, par->domain);\n      switch (par->type)\n      {  case A_NUMERIC:\n         case A_INTEGER:\n         case A_BINARY:\n            eval_member_num(mpl, par, tuple);\n            break;\n         case A_SYMBOLIC:\n            delete_symbol(mpl, eval_member_sym(mpl, par, tuple));\n            break;\n         default:\n            xassert(par != par);\n      }\n      delete_tuple(mpl, tuple);\n      return 0;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_whole_par": {
      "start_point": [
        3073,
        0
      ],
      "end_point": [
        3076,
        1
      ],
      "content": "void eval_whole_par(MPL *mpl, PARAMETER *par)\n{     loop_within_domain(mpl, par->domain, par, whole_par_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_parameter": {
      "start_point": [
        3084,
        0
      ],
      "end_point": [
        3110,
        1
      ],
      "content": "void clean_parameter(MPL *mpl, PARAMETER *par)\n{     CONDITION *cond;\n      WITHIN *in;\n      MEMBER *memb;\n      /* clean subscript domain */\n      clean_domain(mpl, par->domain);\n      /* clean pseudo-code for computing restricting conditions */\n      for (cond = par->cond; cond != NULL; cond = cond->next)\n         clean_code(mpl, cond->code);\n      /* clean pseudo-code for computing restricting supersets */\n      for (in = par->in; in != NULL; in = in->next)\n         clean_code(mpl, in->code);\n      /* clean pseudo-code for computing assigned value */\n      clean_code(mpl, par->assign);\n      /* clean pseudo-code for computing default value */\n      clean_code(mpl, par->option);\n      /* reset data status flag */\n      par->data = 0;\n      /* delete default symbolic value */\n      if (par->defval != NULL)\n         delete_symbol(mpl, par->defval), par->defval = NULL;\n      /* delete content array */\n      for (memb = par->array->head; memb != NULL; memb = memb->next)\n         delete_value(mpl, par->array->type, &memb->value);\n      delete_array(mpl, par->array), par->array = NULL;\n      return;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "take_member_var": {
      "start_point": [
        3125,
        0
      ],
      "end_point": [
        3169,
        1
      ],
      "content": "ELEMVAR *take_member_var      /* returns reference */\n(     MPL *mpl,\n      VARIABLE *var,          /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      ELEMVAR *refer;\n      /* find member in the variable array */\n      memb = find_member(mpl, var->array, tuple);\n      if (memb != NULL)\n      {  /* member exists, so just take the reference */\n         refer = memb->value.var;\n      }\n      else\n      {  /* member is referenced for the first time and therefore does\n            not exist; create new elemental variable, assign it to new\n            member, and add the member to the variable array */\n         memb = add_member(mpl, var->array, copy_tuple(mpl, tuple));\n         refer = (memb->value.var =\n            dmp_get_atom(mpl->elemvars, sizeof(ELEMVAR)));\n         refer->j = 0;\n         refer->var = var;\n         refer->memb = memb;\n         /* compute lower bound */\n         if (var->lbnd == NULL)\n            refer->lbnd = 0.0;\n         else\n            refer->lbnd = eval_numeric(mpl, var->lbnd);\n         /* compute upper bound */\n         if (var->ubnd == NULL)\n            refer->ubnd = 0.0;\n         else if (var->ubnd == var->lbnd)\n            refer->ubnd = refer->lbnd;\n         else\n            refer->ubnd = eval_numeric(mpl, var->ubnd);\n         /* nullify working quantity */\n         refer->temp = 0.0;\n#if 1 /* 15/V-2010 */\n         /* solution has not been obtained by the solver yet */\n         refer->stat = 0;\n         refer->prim = refer->dual = 0.0;\n#endif\n      }\n      return refer;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "ELEMVAR",
        "*take_member_var      /* returns reference */\n(     MPL *mpl,\n      VARIABLE *var,          /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "eval_var_func": {
      "start_point": [
        3187,
        0
      ],
      "end_point": [
        3192,
        1
      ],
      "content": "static void eval_var_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine to work within domain scope */\n      struct eval_var_info *info = _info;\n      info->refer = take_member_var(mpl, info->var, info->tuple);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_member_var": {
      "start_point": [
        3194,
        0
      ],
      "end_point": [
        3210,
        1
      ],
      "content": "ELEMVAR *eval_member_var      /* returns reference */\n(     MPL *mpl,\n      VARIABLE *var,          /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     /* this routine evaluates variable member */\n      struct eval_var_info _info, *info = &_info;\n      xassert(var->dim == tuple_dimen(mpl, tuple));\n      info->var = var;\n      info->tuple = tuple;\n      /* evaluate member, which has given n-tuple */\n      if (eval_within_domain(mpl, info->var->domain, info->tuple, info,\n         eval_var_func))\n         out_of_domain(mpl, var->name, info->tuple);\n      /* bring evaluated reference to the calling program */\n      return info->refer;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "ELEMVAR",
        "*eval_member_var      /* returns reference */\n(     MPL *mpl,\n      VARIABLE *var,          /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "whole_var_func": {
      "start_point": [
        3218,
        0
      ],
      "end_point": [
        3225,
        1
      ],
      "content": "static int whole_var_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      VARIABLE *var = (VARIABLE *)info;\n      TUPLE *tuple = get_domain_tuple(mpl, var->domain);\n      eval_member_var(mpl, var, tuple);\n      delete_tuple(mpl, tuple);\n      return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_whole_var": {
      "start_point": [
        3227,
        0
      ],
      "end_point": [
        3230,
        1
      ],
      "content": "void eval_whole_var(MPL *mpl, VARIABLE *var)\n{     loop_within_domain(mpl, var->domain, var, whole_var_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_variable": {
      "start_point": [
        3238,
        0
      ],
      "end_point": [
        3251,
        1
      ],
      "content": "void clean_variable(MPL *mpl, VARIABLE *var)\n{     MEMBER *memb;\n      /* clean subscript domain */\n      clean_domain(mpl, var->domain);\n      /* clean code for computing lower bound */\n      clean_code(mpl, var->lbnd);\n      /* clean code for computing upper bound */\n      if (var->ubnd != var->lbnd) clean_code(mpl, var->ubnd);\n      /* delete content array */\n      for (memb = var->array->head; memb != NULL; memb = memb->next)\n         dmp_free_atom(mpl->elemvars, memb->value.var, sizeof(ELEMVAR));\n      delete_array(mpl, var->array), var->array = NULL;\n      return;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "take_member_con": {
      "start_point": [
        3266,
        0
      ],
      "end_point": [
        3356,
        1
      ],
      "content": "ELEMCON *take_member_con      /* returns reference */\n(     MPL *mpl,\n      CONSTRAINT *con,        /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     MEMBER *memb;\n      ELEMCON *refer;\n      /* find member in the constraint array */\n      memb = find_member(mpl, con->array, tuple);\n      if (memb != NULL)\n      {  /* member exists, so just take the reference */\n         refer = memb->value.con;\n      }\n      else\n      {  /* member is referenced for the first time and therefore does\n            not exist; create new elemental constraint, assign it to new\n            member, and add the member to the constraint array */\n         memb = add_member(mpl, con->array, copy_tuple(mpl, tuple));\n         refer = (memb->value.con =\n            dmp_get_atom(mpl->elemcons, sizeof(ELEMCON)));\n         refer->i = 0;\n         refer->con = con;\n         refer->memb = memb;\n         /* compute linear form */\n         xassert(con->code != NULL);\n         refer->form = eval_formula(mpl, con->code);\n         /* compute lower and upper bounds */\n         if (con->lbnd == NULL && con->ubnd == NULL)\n         {  /* objective has no bounds */\n            double temp;\n            xassert(con->type == A_MINIMIZE || con->type == A_MAXIMIZE);\n            /* carry the constant term to the right-hand side */\n            refer->form = remove_constant(mpl, refer->form, &temp);\n            refer->lbnd = refer->ubnd = - temp;\n         }\n         else if (con->lbnd != NULL && con->ubnd == NULL)\n         {  /* constraint a * x + b >= c * y + d is transformed to the\n               standard form a * x - c * y >= d - b */\n            double temp;\n            xassert(con->type == A_CONSTRAINT);\n            refer->form = linear_comb(mpl,\n               +1.0, refer->form,\n               -1.0, eval_formula(mpl, con->lbnd));\n            refer->form = remove_constant(mpl, refer->form, &temp);\n            refer->lbnd = - temp;\n            refer->ubnd = 0.0;\n         }\n         else if (con->lbnd == NULL && con->ubnd != NULL)\n         {  /* constraint a * x + b <= c * y + d is transformed to the\n               standard form a * x - c * y <= d - b */\n            double temp;\n            xassert(con->type == A_CONSTRAINT);\n            refer->form = linear_comb(mpl,\n               +1.0, refer->form,\n               -1.0, eval_formula(mpl, con->ubnd));\n            refer->form = remove_constant(mpl, refer->form, &temp);\n            refer->lbnd = 0.0;\n            refer->ubnd = - temp;\n         }\n         else if (con->lbnd == con->ubnd)\n         {  /* constraint a * x + b = c * y + d is transformed to the\n               standard form a * x - c * y = d - b */\n            double temp;\n            xassert(con->type == A_CONSTRAINT);\n            refer->form = linear_comb(mpl,\n               +1.0, refer->form,\n               -1.0, eval_formula(mpl, con->lbnd));\n            refer->form = remove_constant(mpl, refer->form, &temp);\n            refer->lbnd = refer->ubnd = - temp;\n         }\n         else\n         {  /* ranged constraint c <= a * x + b <= d is transformed to\n               the standard form c - b <= a * x <= d - b */\n            double temp, temp1, temp2;\n            xassert(con->type == A_CONSTRAINT);\n            refer->form = remove_constant(mpl, refer->form, &temp);\n            xassert(remove_constant(mpl, eval_formula(mpl, con->lbnd),\n               &temp1) == NULL);\n            xassert(remove_constant(mpl, eval_formula(mpl, con->ubnd),\n               &temp2) == NULL);\n            refer->lbnd = fp_sub(mpl, temp1, temp);\n            refer->ubnd = fp_sub(mpl, temp2, temp);\n         }\n#if 1 /* 15/V-2010 */\n         /* solution has not been obtained by the solver yet */\n         refer->stat = 0;\n         refer->prim = refer->dual = 0.0;\n#endif\n      }\n      return refer;\n}",
      "lines": 91,
      "depth": 19,
      "decorators": [
        "ELEMCON",
        "*take_member_con      /* returns reference */\n(     MPL *mpl,\n      CONSTRAINT *con,        /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "eval_con_func": {
      "start_point": [
        3374,
        0
      ],
      "end_point": [
        3379,
        1
      ],
      "content": "static void eval_con_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine to work within domain scope */\n      struct eval_con_info *info = _info;\n      info->refer = take_member_con(mpl, info->con, info->tuple);\n      return;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eval_member_con": {
      "start_point": [
        3381,
        0
      ],
      "end_point": [
        3397,
        1
      ],
      "content": "ELEMCON *eval_member_con      /* returns reference */\n(     MPL *mpl,\n      CONSTRAINT *con,        /* not changed */\n      TUPLE *tuple            /* not changed */\n)\n{     /* this routine evaluates constraint member */\n      struct eval_con_info _info, *info = &_info;\n      xassert(con->dim == tuple_dimen(mpl, tuple));\n      info->con = con;\n      info->tuple = tuple;\n      /* evaluate member, which has given n-tuple */\n      if (eval_within_domain(mpl, info->con->domain, info->tuple, info,\n         eval_con_func))\n         out_of_domain(mpl, con->name, info->tuple);\n      /* bring evaluated reference to the calling program */\n      return info->refer;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "ELEMCON",
        "*eval_member_con      /* returns reference */\n(     MPL *mpl,\n      CONSTRAINT *con,        /* not changed */\n      TUPLE *tuple            /* not changed */\n)",
        "*"
      ]
    },
    "whole_con_func": {
      "start_point": [
        3405,
        0
      ],
      "end_point": [
        3412,
        1
      ],
      "content": "static int whole_con_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      CONSTRAINT *con = (CONSTRAINT *)info;\n      TUPLE *tuple = get_domain_tuple(mpl, con->domain);\n      eval_member_con(mpl, con, tuple);\n      delete_tuple(mpl, tuple);\n      return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_whole_con": {
      "start_point": [
        3414,
        0
      ],
      "end_point": [
        3417,
        1
      ],
      "content": "void eval_whole_con(MPL *mpl, CONSTRAINT *con)\n{     loop_within_domain(mpl, con->domain, con, whole_con_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_constraint": {
      "start_point": [
        3425,
        0
      ],
      "end_point": [
        3442,
        1
      ],
      "content": "void clean_constraint(MPL *mpl, CONSTRAINT *con)\n{     MEMBER *memb;\n      /* clean subscript domain */\n      clean_domain(mpl, con->domain);\n      /* clean code for computing main linear form */\n      clean_code(mpl, con->code);\n      /* clean code for computing lower bound */\n      clean_code(mpl, con->lbnd);\n      /* clean code for computing upper bound */\n      if (con->ubnd != con->lbnd) clean_code(mpl, con->ubnd);\n      /* delete content array */\n      for (memb = con->array->head; memb != NULL; memb = memb->next)\n      {  delete_formula(mpl, memb->value.con->form);\n         dmp_free_atom(mpl->elemcons, memb->value.con, sizeof(ELEMCON));\n      }\n      delete_array(mpl, con->array), con->array = NULL;\n      return;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "iter_num_func": {
      "start_point": [
        3462,
        0
      ],
      "end_point": [
        3489,
        1
      ],
      "content": "static int iter_num_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine used to perform iterated operation\n         on numeric \"integrand\" within domain scope */\n      struct iter_num_info *info = _info;\n      double temp;\n      temp = eval_numeric(mpl, info->code->arg.loop.x);\n      switch (info->code->op)\n      {  case O_SUM:\n            /* summation over domain */\n            info->value = fp_add(mpl, info->value, temp);\n            break;\n         case O_PROD:\n            /* multiplication over domain */\n            info->value = fp_mul(mpl, info->value, temp);\n            break;\n         case O_MINIMUM:\n            /* minimum over domain */\n            if (info->value > temp) info->value = temp;\n            break;\n         case O_MAXIMUM:\n            /* maximum over domain */\n            if (info->value < temp) info->value = temp;\n            break;\n         default:\n            xassert(info != info);\n      }\n      return 0;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_numeric": {
      "start_point": [
        3491,
        0
      ],
      "end_point": [
        3907,
        1
      ],
      "content": "double eval_numeric(MPL *mpl, CODE *code)\n{     double value;\n      xassert(code != NULL);\n      xassert(code->type == A_NUMERIC);\n      xassert(code->dim == 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = code->value.num;\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_NUMBER:\n            /* take floating-point number */\n            value = code->arg.num;\n            break;\n         case O_MEMNUM:\n            /* take member of numeric parameter */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n               tuple = create_tuple(mpl);\n               for (e = code->arg.par.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n               value = eval_member_num(mpl, code->arg.par.par, tuple);\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_MEMVAR:\n            /* take computed value of elemental variable */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n#if 1 /* 15/V-2010 */\n               ELEMVAR *var;\n#endif\n               tuple = create_tuple(mpl);\n               for (e = code->arg.var.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n#if 0 /* 15/V-2010 */\n               value = eval_member_var(mpl, code->arg.var.var, tuple)\n                  ->value;\n#else\n               var = eval_member_var(mpl, code->arg.var.var, tuple);\n               switch (code->arg.var.suff)\n               {  case DOT_LB:\n                     if (var->var->lbnd == NULL)\n                        value = -DBL_MAX;\n                     else\n                        value = var->lbnd;\n                     break;\n                  case DOT_UB:\n                     if (var->var->ubnd == NULL)\n                        value = +DBL_MAX;\n                     else\n                        value = var->ubnd;\n                     break;\n                  case DOT_STATUS:\n                     value = var->stat;\n                     break;\n                  case DOT_VAL:\n                     value = var->prim;\n                     break;\n                  case DOT_DUAL:\n                     value = var->dual;\n                     break;\n                  default:\n                     xassert(code != code);\n               }\n#endif\n               delete_tuple(mpl, tuple);\n            }\n            break;\n#if 1 /* 15/V-2010 */\n         case O_MEMCON:\n            /* take computed value of elemental constraint */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n               ELEMCON *con;\n               tuple = create_tuple(mpl);\n               for (e = code->arg.con.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n               con = eval_member_con(mpl, code->arg.con.con, tuple);\n               switch (code->arg.con.suff)\n               {  case DOT_LB:\n                     if (con->con->lbnd == NULL)\n                        value = -DBL_MAX;\n                     else\n                        value = con->lbnd;\n                     break;\n                  case DOT_UB:\n                     if (con->con->ubnd == NULL)\n                        value = +DBL_MAX;\n                     else\n                        value = con->ubnd;\n                     break;\n                  case DOT_STATUS:\n                     value = con->stat;\n                     break;\n                  case DOT_VAL:\n                     value = con->prim;\n                     break;\n                  case DOT_DUAL:\n                     value = con->dual;\n                     break;\n                  default:\n                     xassert(code != code);\n               }\n               delete_tuple(mpl, tuple);\n            }\n            break;\n#endif\n         case O_IRAND224:\n            /* pseudo-random in [0, 2^24-1] */\n            value = fp_irand224(mpl);\n            break;\n         case O_UNIFORM01:\n            /* pseudo-random in [0, 1) */\n            value = fp_uniform01(mpl);\n            break;\n         case O_NORMAL01:\n            /* gaussian random, mu = 0, sigma = 1 */\n            value = fp_normal01(mpl);\n            break;\n         case O_GMTIME:\n            /* current calendar time */\n            value = fn_gmtime(mpl);\n            break;\n         case O_CVTNUM:\n            /* conversion to numeric */\n            {  SYMBOL *sym;\n               sym = eval_symbolic(mpl, code->arg.arg.x);\n#if 0 /* 23/XI-2008 */\n               if (sym->str != NULL)\n                  error(mpl, \"cannot convert %s to floating-point numbe\"\n                     \"r\", format_symbol(mpl, sym));\n               value = sym->num;\n#else\n               if (sym->str == NULL)\n                  value = sym->num;\n               else\n               {  if (str2num(sym->str, &value))\n                     error(mpl, \"cannot convert %s to floating-point nu\"\n                        \"mber\", format_symbol(mpl, sym));\n               }\n#endif\n               delete_symbol(mpl, sym);\n            }\n            break;\n         case O_PLUS:\n            /* unary plus */\n            value = + eval_numeric(mpl, code->arg.arg.x);\n            break;\n         case O_MINUS:\n            /* unary minus */\n            value = - eval_numeric(mpl, code->arg.arg.x);\n            break;\n         case O_ABS:\n            /* absolute value */\n            value = fabs(eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_CEIL:\n            /* round upward (\"ceiling of x\") */\n            value = ceil(eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_FLOOR:\n            /* round downward (\"floor of x\") */\n            value = floor(eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_EXP:\n            /* base-e exponential */\n            value = fp_exp(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_LOG:\n            /* natural logarithm */\n            value = fp_log(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_LOG10:\n            /* common (decimal) logarithm */\n            value = fp_log10(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_SQRT:\n            /* square root */\n            value = fp_sqrt(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_SIN:\n            /* trigonometric sine */\n            value = fp_sin(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_COS:\n            /* trigonometric cosine */\n            value = fp_cos(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_TAN:\n            /* trigonometric tangent */\n            value = fp_tan(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_ATAN:\n            /* trigonometric arctangent (one argument) */\n            value = fp_atan(mpl, eval_numeric(mpl, code->arg.arg.x));\n            break;\n         case O_ATAN2:\n            /* trigonometric arctangent (two arguments) */\n            value = fp_atan2(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_ROUND:\n            /* round to nearest integer */\n            value = fp_round(mpl,\n               eval_numeric(mpl, code->arg.arg.x), 0.0);\n            break;\n         case O_ROUND2:\n            /* round to n fractional digits */\n            value = fp_round(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_TRUNC:\n            /* truncate to nearest integer */\n            value = fp_trunc(mpl,\n               eval_numeric(mpl, code->arg.arg.x), 0.0);\n            break;\n         case O_TRUNC2:\n            /* truncate to n fractional digits */\n            value = fp_trunc(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_ADD:\n            /* addition */\n            value = fp_add(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_SUB:\n            /* subtraction */\n            value = fp_sub(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_LESS:\n            /* non-negative subtraction */\n            value = fp_less(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_MUL:\n            /* multiplication */\n            value = fp_mul(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_DIV:\n            /* division */\n            value = fp_div(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_IDIV:\n            /* quotient of exact division */\n            value = fp_idiv(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_MOD:\n            /* remainder of exact division */\n            value = fp_mod(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_POWER:\n            /* exponentiation (raise to power) */\n            value = fp_power(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_UNIFORM:\n            /* pseudo-random in [a, b) */\n            value = fp_uniform(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_NORMAL:\n            /* gaussian random, given mu and sigma */\n            value = fp_normal(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y));\n            break;\n         case O_CARD:\n            {  ELEMSET *set;\n               set = eval_elemset(mpl, code->arg.arg.x);\n               value = set->size;\n               delete_array(mpl, set);\n            }\n            break;\n         case O_LENGTH:\n            {  SYMBOL *sym;\n               char str[MAX_LENGTH+1];\n               sym = eval_symbolic(mpl, code->arg.arg.x);\n               if (sym->str == NULL)\n                  sprintf(str, \"%.*g\", DBL_DIG, sym->num);\n               else\n                  fetch_string(mpl, sym->str, str);\n               delete_symbol(mpl, sym);\n               value = strlen(str);\n            }\n            break;\n         case O_STR2TIME:\n            {  SYMBOL *sym;\n               char str[MAX_LENGTH+1], fmt[MAX_LENGTH+1];\n               sym = eval_symbolic(mpl, code->arg.arg.x);\n               if (sym->str == NULL)\n                  sprintf(str, \"%.*g\", DBL_DIG, sym->num);\n               else\n                  fetch_string(mpl, sym->str, str);\n               delete_symbol(mpl, sym);\n               sym = eval_symbolic(mpl, code->arg.arg.y);\n               if (sym->str == NULL)\n                  sprintf(fmt, \"%.*g\", DBL_DIG, sym->num);\n               else\n                  fetch_string(mpl, sym->str, fmt);\n               delete_symbol(mpl, sym);\n               value = fn_str2time(mpl, str, fmt);\n            }\n            break;\n         case O_FORK:\n            /* if-then-else */\n            if (eval_logical(mpl, code->arg.arg.x))\n               value = eval_numeric(mpl, code->arg.arg.y);\n            else if (code->arg.arg.z == NULL)\n               value = 0.0;\n            else\n               value = eval_numeric(mpl, code->arg.arg.z);\n            break;\n         case O_MIN:\n            /* minimal value (n-ary) */\n            {  ARG_LIST *e;\n               double temp;\n               value = +DBL_MAX;\n               for (e = code->arg.list; e != NULL; e = e->next)\n               {  temp = eval_numeric(mpl, e->x);\n                  if (value > temp) value = temp;\n               }\n            }\n            break;\n         case O_MAX:\n            /* maximal value (n-ary) */\n            {  ARG_LIST *e;\n               double temp;\n               value = -DBL_MAX;\n               for (e = code->arg.list; e != NULL; e = e->next)\n               {  temp = eval_numeric(mpl, e->x);\n                  if (value < temp) value = temp;\n               }\n            }\n            break;\n         case O_SUM:\n            /* summation over domain */\n            {  struct iter_num_info _info, *info = &_info;\n               info->code = code;\n               info->value = 0.0;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_num_func);\n               value = info->value;\n            }\n            break;\n         case O_PROD:\n            /* multiplication over domain */\n            {  struct iter_num_info _info, *info = &_info;\n               info->code = code;\n               info->value = 1.0;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_num_func);\n               value = info->value;\n            }\n            break;\n         case O_MINIMUM:\n            /* minimum over domain */\n            {  struct iter_num_info _info, *info = &_info;\n               info->code = code;\n               info->value = +DBL_MAX;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_num_func);\n               if (info->value == +DBL_MAX)\n                  error(mpl, \"min{} over empty set; result undefined\");\n               value = info->value;\n            }\n            break;\n         case O_MAXIMUM:\n            /* maximum over domain */\n            {  struct iter_num_info _info, *info = &_info;\n               info->code = code;\n               info->value = -DBL_MAX;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_num_func);\n               if (info->value == -DBL_MAX)\n                  error(mpl, \"max{} over empty set; result undefined\");\n               value = info->value;\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.num = value;\ndone: return value;\n}",
      "lines": 417,
      "depth": 17,
      "decorators": [
        "double"
      ]
    },
    "eval_symbolic": {
      "start_point": [
        3915,
        0
      ],
      "end_point": [
        4033,
        1
      ],
      "content": "SYMBOL *eval_symbolic(MPL *mpl, CODE *code)\n{     SYMBOL *value;\n      xassert(code != NULL);\n      xassert(code->type == A_SYMBOLIC);\n      xassert(code->dim == 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = copy_symbol(mpl, code->value.sym);\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_STRING:\n            /* take character string */\n            value = create_symbol_str(mpl, create_string(mpl,\n               code->arg.str));\n            break;\n         case O_INDEX:\n            /* take dummy index */\n            xassert(code->arg.index.slot->value != NULL);\n            value = copy_symbol(mpl, code->arg.index.slot->value);\n            break;\n         case O_MEMSYM:\n            /* take member of symbolic parameter */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n               tuple = create_tuple(mpl);\n               for (e = code->arg.par.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n               value = eval_member_sym(mpl, code->arg.par.par, tuple);\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_CVTSYM:\n            /* conversion to symbolic */\n            value = create_symbol_num(mpl, eval_numeric(mpl,\n               code->arg.arg.x));\n            break;\n         case O_CONCAT:\n            /* concatenation */\n            value = concat_symbols(mpl,\n               eval_symbolic(mpl, code->arg.arg.x),\n               eval_symbolic(mpl, code->arg.arg.y));\n            break;\n         case O_FORK:\n            /* if-then-else */\n            if (eval_logical(mpl, code->arg.arg.x))\n               value = eval_symbolic(mpl, code->arg.arg.y);\n            else if (code->arg.arg.z == NULL)\n               value = create_symbol_num(mpl, 0.0);\n            else\n               value = eval_symbolic(mpl, code->arg.arg.z);\n            break;\n         case O_SUBSTR:\n         case O_SUBSTR3:\n            {  double pos, len;\n               char str[MAX_LENGTH+1];\n               value = eval_symbolic(mpl, code->arg.arg.x);\n               if (value->str == NULL)\n                  sprintf(str, \"%.*g\", DBL_DIG, value->num);\n               else\n                  fetch_string(mpl, value->str, str);\n               delete_symbol(mpl, value);\n               if (code->op == O_SUBSTR)\n               {  pos = eval_numeric(mpl, code->arg.arg.y);\n                  if (pos != floor(pos))\n                     error(mpl, \"substr('...', %.*g); non-integer secon\"\n                        \"d argument\", DBL_DIG, pos);\n                  if (pos < 1 || pos > strlen(str) + 1)\n                     error(mpl, \"substr('...', %.*g); substring out of \"\n                        \"range\", DBL_DIG, pos);\n               }\n               else\n               {  pos = eval_numeric(mpl, code->arg.arg.y);\n                  len = eval_numeric(mpl, code->arg.arg.z);\n                  if (pos != floor(pos) || len != floor(len))\n                     error(mpl, \"substr('...', %.*g, %.*g); non-integer\"\n                        \" second and/or third argument\", DBL_DIG, pos,\n                        DBL_DIG, len);\n                  if (pos < 1 || len < 0 || pos + len > strlen(str) + 1)\n                     error(mpl, \"substr('...', %.*g, %.*g); substring o\"\n                        \"ut of range\", DBL_DIG, pos, DBL_DIG, len);\n                  str[(int)pos + (int)len - 1] = '\\0';\n               }\n               value = create_symbol_str(mpl, create_string(mpl, str +\n                  (int)pos - 1));\n            }\n            break;\n         case O_TIME2STR:\n            {  double num;\n               SYMBOL *sym;\n               char str[MAX_LENGTH+1], fmt[MAX_LENGTH+1];\n               num = eval_numeric(mpl, code->arg.arg.x);\n               sym = eval_symbolic(mpl, code->arg.arg.y);\n               if (sym->str == NULL)\n                  sprintf(fmt, \"%.*g\", DBL_DIG, sym->num);\n               else\n                  fetch_string(mpl, sym->str, fmt);\n               delete_symbol(mpl, sym);\n               fn_time2str(mpl, str, num, fmt);\n               value = create_symbol_str(mpl, create_string(mpl, str));\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.sym = copy_symbol(mpl, value);\ndone: return value;\n}",
      "lines": 119,
      "depth": 17,
      "decorators": [
        "SYMBOL",
        "*eval_symbolic(MPL *mpl, CODE *code)",
        "*"
      ]
    },
    "iter_log_func": {
      "start_point": [
        4049,
        0
      ],
      "end_point": [
        4069,
        1
      ],
      "content": "static int iter_log_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine used to perform iterated operation\n         on logical \"integrand\" within domain scope */\n      struct iter_log_info *info = _info;\n      int ret = 0;\n      switch (info->code->op)\n      {  case O_FORALL:\n            /* conjunction over domain */\n            info->value &= eval_logical(mpl, info->code->arg.loop.x);\n            if (!info->value) ret = 1;\n            break;\n         case O_EXISTS:\n            /* disjunction over domain */\n            info->value |= eval_logical(mpl, info->code->arg.loop.x);\n            if (info->value) ret = 1;\n            break;\n         default:\n            xassert(info != info);\n      }\n      return ret;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_logical": {
      "start_point": [
        4071,
        0
      ],
      "end_point": [
        4284,
        1
      ],
      "content": "int eval_logical(MPL *mpl, CODE *code)\n{     int value;\n      xassert(code->type == A_LOGICAL);\n      xassert(code->dim == 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = code->value.bit;\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_CVTLOG:\n            /* conversion to logical */\n            value = (eval_numeric(mpl, code->arg.arg.x) != 0.0);\n            break;\n         case O_NOT:\n            /* negation (logical \"not\") */\n            value = !eval_logical(mpl, code->arg.arg.x);\n            break;\n         case O_LT:\n            /* comparison on 'less than' */\n#if 0 /* 02/VIII-2008 */\n            value = (eval_numeric(mpl, code->arg.arg.x) <\n                     eval_numeric(mpl, code->arg.arg.y));\n#else\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) <\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) < 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n#endif\n            break;\n         case O_LE:\n            /* comparison on 'not greater than' */\n#if 0 /* 02/VIII-2008 */\n            value = (eval_numeric(mpl, code->arg.arg.x) <=\n                     eval_numeric(mpl, code->arg.arg.y));\n#else\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) <=\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) <= 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n#endif\n            break;\n         case O_EQ:\n            /* comparison on 'equal to' */\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) ==\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) == 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n            break;\n         case O_GE:\n            /* comparison on 'not less than' */\n#if 0 /* 02/VIII-2008 */\n            value = (eval_numeric(mpl, code->arg.arg.x) >=\n                     eval_numeric(mpl, code->arg.arg.y));\n#else\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) >=\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) >= 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n#endif\n            break;\n         case O_GT:\n            /* comparison on 'greater than' */\n#if 0 /* 02/VIII-2008 */\n            value = (eval_numeric(mpl, code->arg.arg.x) >\n                     eval_numeric(mpl, code->arg.arg.y));\n#else\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) >\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) > 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n#endif\n            break;\n         case O_NE:\n            /* comparison on 'not equal to' */\n            xassert(code->arg.arg.x != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n               value = (eval_numeric(mpl, code->arg.arg.x) !=\n                        eval_numeric(mpl, code->arg.arg.y));\n            else\n            {  SYMBOL *sym1 = eval_symbolic(mpl, code->arg.arg.x);\n               SYMBOL *sym2 = eval_symbolic(mpl, code->arg.arg.y);\n               value = (compare_symbols(mpl, sym1, sym2) != 0);\n               delete_symbol(mpl, sym1);\n               delete_symbol(mpl, sym2);\n            }\n            break;\n         case O_AND:\n            /* conjunction (logical \"and\") */\n            value = eval_logical(mpl, code->arg.arg.x) &&\n                    eval_logical(mpl, code->arg.arg.y);\n            break;\n         case O_OR:\n            /* disjunction (logical \"or\") */\n            value = eval_logical(mpl, code->arg.arg.x) ||\n                    eval_logical(mpl, code->arg.arg.y);\n            break;\n         case O_IN:\n            /* test on 'x in Y' */\n            {  TUPLE *tuple;\n               tuple = eval_tuple(mpl, code->arg.arg.x);\n               value = is_member(mpl, code->arg.arg.y, tuple);\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_NOTIN:\n            /* test on 'x not in Y' */\n            {  TUPLE *tuple;\n               tuple = eval_tuple(mpl, code->arg.arg.x);\n               value = !is_member(mpl, code->arg.arg.y, tuple);\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_WITHIN:\n            /* test on 'X within Y' */\n            {  ELEMSET *set;\n               MEMBER *memb;\n               set = eval_elemset(mpl, code->arg.arg.x);\n               value = 1;\n               for (memb = set->head; memb != NULL; memb = memb->next)\n               {  if (!is_member(mpl, code->arg.arg.y, memb->tuple))\n                  {  value = 0;\n                     break;\n                  }\n               }\n               delete_elemset(mpl, set);\n            }\n            break;\n         case O_NOTWITHIN:\n            /* test on 'X not within Y' */\n            {  ELEMSET *set;\n               MEMBER *memb;\n               set = eval_elemset(mpl, code->arg.arg.x);\n               value = 1;\n               for (memb = set->head; memb != NULL; memb = memb->next)\n               {  if (is_member(mpl, code->arg.arg.y, memb->tuple))\n                  {  value = 0;\n                     break;\n                  }\n               }\n               delete_elemset(mpl, set);\n            }\n            break;\n         case O_FORALL:\n            /* conjunction (A-quantification) */\n            {  struct iter_log_info _info, *info = &_info;\n               info->code = code;\n               info->value = 1;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_log_func);\n               value = info->value;\n            }\n            break;\n         case O_EXISTS:\n            /* disjunction (E-quantification) */\n            {  struct iter_log_info _info, *info = &_info;\n               info->code = code;\n               info->value = 0;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_log_func);\n               value = info->value;\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.bit = value;\ndone: return value;\n}",
      "lines": 214,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "eval_tuple": {
      "start_point": [
        4292,
        0
      ],
      "end_point": [
        4332,
        1
      ],
      "content": "TUPLE *eval_tuple(MPL *mpl, CODE *code)\n{     TUPLE *value;\n      xassert(code != NULL);\n      xassert(code->type == A_TUPLE);\n      xassert(code->dim > 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = copy_tuple(mpl, code->value.tuple);\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_TUPLE:\n            /* make n-tuple */\n            {  ARG_LIST *e;\n               value = create_tuple(mpl);\n               for (e = code->arg.list; e != NULL; e = e->next)\n                  value = expand_tuple(mpl, value, eval_symbolic(mpl,\n                     e->x));\n            }\n            break;\n         case O_CVTTUP:\n            /* convert to 1-tuple */\n            value = expand_tuple(mpl, create_tuple(mpl),\n               eval_symbolic(mpl, code->arg.arg.x));\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.tuple = copy_tuple(mpl, value);\ndone: return value;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "TUPLE",
        "*eval_tuple(MPL *mpl, CODE *code)",
        "*"
      ]
    },
    "iter_set_func": {
      "start_point": [
        4348,
        0
      ],
      "end_point": [
        4374,
        1
      ],
      "content": "static int iter_set_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine used to perform iterated operation\n         on n-tuple \"integrand\" within domain scope */\n      struct iter_set_info *info = _info;\n      TUPLE *tuple;\n      switch (info->code->op)\n      {  case O_SETOF:\n            /* compute next n-tuple and add it to the set; in this case\n               duplicate n-tuples are silently ignored */\n            tuple = eval_tuple(mpl, info->code->arg.loop.x);\n            if (find_tuple(mpl, info->value, tuple) == NULL)\n               add_tuple(mpl, info->value, tuple);\n            else\n               delete_tuple(mpl, tuple);\n            break;\n         case O_BUILD:\n            /* construct next n-tuple using current values assigned to\n               *free* dummy indices as its components and add it to the\n               set; in this case duplicate n-tuples cannot appear */\n            add_tuple(mpl, info->value, get_domain_tuple(mpl,\n               info->code->arg.loop.domain));\n            break;\n         default:\n            xassert(info != info);\n      }\n      return 0;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_elemset": {
      "start_point": [
        4376,
        0
      ],
      "end_point": [
        4488,
        1
      ],
      "content": "ELEMSET *eval_elemset(MPL *mpl, CODE *code)\n{     ELEMSET *value;\n      xassert(code != NULL);\n      xassert(code->type == A_ELEMSET);\n      xassert(code->dim > 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = copy_elemset(mpl, code->value.set);\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_MEMSET:\n            /* take member of set */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n               tuple = create_tuple(mpl);\n               for (e = code->arg.set.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n               value = copy_elemset(mpl,\n                  eval_member_set(mpl, code->arg.set.set, tuple));\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_MAKE:\n            /* make elemental set of n-tuples */\n            {  ARG_LIST *e;\n               value = create_elemset(mpl, code->dim);\n               for (e = code->arg.list; e != NULL; e = e->next)\n                  check_then_add(mpl, value, eval_tuple(mpl, e->x));\n            }\n            break;\n         case O_UNION:\n            /* union of two elemental sets */\n            value = set_union(mpl,\n               eval_elemset(mpl, code->arg.arg.x),\n               eval_elemset(mpl, code->arg.arg.y));\n            break;\n         case O_DIFF:\n            /* difference between two elemental sets */\n            value = set_diff(mpl,\n               eval_elemset(mpl, code->arg.arg.x),\n               eval_elemset(mpl, code->arg.arg.y));\n            break;\n         case O_SYMDIFF:\n            /* symmetric difference between two elemental sets */\n            value = set_symdiff(mpl,\n               eval_elemset(mpl, code->arg.arg.x),\n               eval_elemset(mpl, code->arg.arg.y));\n            break;\n         case O_INTER:\n            /* intersection of two elemental sets */\n            value = set_inter(mpl,\n               eval_elemset(mpl, code->arg.arg.x),\n               eval_elemset(mpl, code->arg.arg.y));\n            break;\n         case O_CROSS:\n            /* cross (Cartesian) product of two elemental sets */\n            value = set_cross(mpl,\n               eval_elemset(mpl, code->arg.arg.x),\n               eval_elemset(mpl, code->arg.arg.y));\n            break;\n         case O_DOTS:\n            /* build \"arithmetic\" elemental set */\n            value = create_arelset(mpl,\n               eval_numeric(mpl, code->arg.arg.x),\n               eval_numeric(mpl, code->arg.arg.y),\n               code->arg.arg.z == NULL ? 1.0 : eval_numeric(mpl,\n                  code->arg.arg.z));\n            break;\n         case O_FORK:\n            /* if-then-else */\n            if (eval_logical(mpl, code->arg.arg.x))\n               value = eval_elemset(mpl, code->arg.arg.y);\n            else\n               value = eval_elemset(mpl, code->arg.arg.z);\n            break;\n         case O_SETOF:\n            /* compute elemental set */\n            {  struct iter_set_info _info, *info = &_info;\n               info->code = code;\n               info->value = create_elemset(mpl, code->dim);\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_set_func);\n               value = info->value;\n            }\n            break;\n         case O_BUILD:\n            /* build elemental set identical to domain set */\n            {  struct iter_set_info _info, *info = &_info;\n               info->code = code;\n               info->value = create_elemset(mpl, code->dim);\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_set_func);\n               value = info->value;\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.set = copy_elemset(mpl, value);\ndone: return value;\n}",
      "lines": 113,
      "depth": 16,
      "decorators": [
        "ELEMSET",
        "*eval_elemset(MPL *mpl, CODE *code)",
        "*"
      ]
    },
    "null_func": {
      "start_point": [
        4499,
        0
      ],
      "end_point": [
        4504,
        1
      ],
      "content": "static void null_func(MPL *mpl, void *info)\n{     /* this is dummy routine used to enter the domain scope */\n      xassert(mpl == mpl);\n      xassert(info == NULL);\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_member": {
      "start_point": [
        4506,
        0
      ],
      "end_point": [
        4642,
        1
      ],
      "content": "int is_member(MPL *mpl, CODE *code, TUPLE *tuple)\n{     int value;\n      xassert(code != NULL);\n      xassert(code->type == A_ELEMSET);\n      xassert(code->dim > 0);\n      xassert(tuple != NULL);\n      switch (code->op)\n      {  case O_MEMSET:\n            /* check if given n-tuple is member of elemental set, which\n               is assigned to member of model set */\n            {  ARG_LIST *e;\n               TUPLE *temp;\n               ELEMSET *set;\n               /* evaluate reference to elemental set */\n               temp = create_tuple(mpl);\n               for (e = code->arg.set.list; e != NULL; e = e->next)\n                  temp = expand_tuple(mpl, temp, eval_symbolic(mpl,\n                     e->x));\n               set = eval_member_set(mpl, code->arg.set.set, temp);\n               delete_tuple(mpl, temp);\n               /* check if the n-tuple is contained in the set array */\n               temp = build_subtuple(mpl, tuple, set->dim);\n               value = (find_tuple(mpl, set, temp) != NULL);\n               delete_tuple(mpl, temp);\n            }\n            break;\n         case O_MAKE:\n            /* check if given n-tuple is member of literal set */\n            {  ARG_LIST *e;\n               TUPLE *temp, *that;\n               value = 0;\n               temp = build_subtuple(mpl, tuple, code->dim);\n               for (e = code->arg.list; e != NULL; e = e->next)\n               {  that = eval_tuple(mpl, e->x);\n                  value = (compare_tuples(mpl, temp, that) == 0);\n                  delete_tuple(mpl, that);\n                  if (value) break;\n               }\n               delete_tuple(mpl, temp);\n            }\n            break;\n         case O_UNION:\n            value = is_member(mpl, code->arg.arg.x, tuple) ||\n                    is_member(mpl, code->arg.arg.y, tuple);\n            break;\n         case O_DIFF:\n            value = is_member(mpl, code->arg.arg.x, tuple) &&\n                   !is_member(mpl, code->arg.arg.y, tuple);\n            break;\n         case O_SYMDIFF:\n            {  int in1 = is_member(mpl, code->arg.arg.x, tuple);\n               int in2 = is_member(mpl, code->arg.arg.y, tuple);\n               value = (in1 && !in2) || (!in1 && in2);\n            }\n            break;\n         case O_INTER:\n            value = is_member(mpl, code->arg.arg.x, tuple) &&\n                    is_member(mpl, code->arg.arg.y, tuple);\n            break;\n         case O_CROSS:\n            {  int j;\n               value = is_member(mpl, code->arg.arg.x, tuple);\n               if (value)\n               {  for (j = 1; j <= code->arg.arg.x->dim; j++)\n                  {  xassert(tuple != NULL);\n                     tuple = tuple->next;\n                  }\n                  value = is_member(mpl, code->arg.arg.y, tuple);\n               }\n            }\n            break;\n         case O_DOTS:\n            /* check if given 1-tuple is member of \"arithmetic\" set */\n            {  int j;\n               double x, t0, tf, dt;\n               xassert(code->dim == 1);\n               /* compute \"parameters\" of the \"arithmetic\" set */\n               t0 = eval_numeric(mpl, code->arg.arg.x);\n               tf = eval_numeric(mpl, code->arg.arg.y);\n               if (code->arg.arg.z == NULL)\n                  dt = 1.0;\n               else\n                  dt = eval_numeric(mpl, code->arg.arg.z);\n               /* make sure the parameters are correct */\n               arelset_size(mpl, t0, tf, dt);\n               /* if component of 1-tuple is symbolic, not numeric, the\n                  1-tuple cannot be member of \"arithmetic\" set */\n               xassert(tuple->sym != NULL);\n               if (tuple->sym->str != NULL)\n               {  value = 0;\n                  break;\n               }\n               /* determine numeric value of the component */\n               x = tuple->sym->num;\n               /* if the component value is out of the set range, the\n                  1-tuple is not in the set */\n               if (dt > 0.0 && !(t0 <= x && x <= tf) ||\n                   dt < 0.0 && !(tf <= x && x <= t0))\n               {  value = 0;\n                  break;\n               }\n               /* estimate ordinal number of the 1-tuple in the set */\n               j = (int)(((x - t0) / dt) + 0.5) + 1;\n               /* perform the main check */\n               value = (arelset_member(mpl, t0, tf, dt, j) == x);\n            }\n            break;\n         case O_FORK:\n            /* check if given n-tuple is member of conditional set */\n            if (eval_logical(mpl, code->arg.arg.x))\n               value = is_member(mpl, code->arg.arg.y, tuple);\n            else\n               value = is_member(mpl, code->arg.arg.z, tuple);\n            break;\n         case O_SETOF:\n            /* check if given n-tuple is member of computed set */\n            /* it is not clear how to efficiently perform the check not\n               computing the entire elemental set :+( */\n            error(mpl, \"implementation restriction; in/within setof{} n\"\n               \"ot allowed\");\n            break;\n         case O_BUILD:\n            /* check if given n-tuple is member of domain set */\n            {  TUPLE *temp;\n               temp = build_subtuple(mpl, tuple, code->dim);\n               /* try to enter the domain scope; if it is successful,\n                  the n-tuple is in the domain set */\n               value = (eval_within_domain(mpl, code->arg.loop.domain,\n                  temp, NULL, null_func) == 0);\n               delete_tuple(mpl, temp);\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      return value;\n}",
      "lines": 137,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "iter_form_func": {
      "start_point": [
        4660,
        0
      ],
      "end_point": [
        4699,
        1
      ],
      "content": "static int iter_form_func(MPL *mpl, void *_info)\n{     /* this is auxiliary routine used to perform iterated operation\n         on linear form \"integrand\" within domain scope */\n      struct iter_form_info *info = _info;\n      switch (info->code->op)\n      {  case O_SUM:\n            /* summation over domain */\n#if 0\n            info->value =\n               linear_comb(mpl,\n                  +1.0, info->value,\n                  +1.0, eval_formula(mpl, info->code->arg.loop.x));\n#else\n            /* the routine linear_comb needs to look through all terms\n               of both linear forms to reduce identical terms, so using\n               it here is not a good idea (for example, evaluation of\n               sum{i in 1..n} x[i] required quadratic time); the better\n               idea is to gather all terms of the integrand in one list\n               and reduce identical terms only once after all terms of\n               the resultant linear form have been evaluated */\n            {  FORMULA *form, *term;\n               form = eval_formula(mpl, info->code->arg.loop.x);\n               if (info->value == NULL)\n               {  xassert(info->tail == NULL);\n                  info->value = form;\n               }\n               else\n               {  xassert(info->tail != NULL);\n                  info->tail->next = form;\n               }\n               for (term = form; term != NULL; term = term->next)\n                  info->tail = term;\n            }\n#endif\n            break;\n         default:\n            xassert(info != info);\n      }\n      return 0;\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "eval_formula": {
      "start_point": [
        4701,
        0
      ],
      "end_point": [
        4819,
        1
      ],
      "content": "FORMULA *eval_formula(MPL *mpl, CODE *code)\n{     FORMULA *value;\n      xassert(code != NULL);\n      xassert(code->type == A_FORMULA);\n      xassert(code->dim == 0);\n      /* if the operation has a side effect, invalidate and delete the\n         resultant value */\n      if (code->vflag && code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* if resultant value is valid, no evaluation is needed */\n      if (code->valid)\n      {  value = copy_formula(mpl, code->value.form);\n         goto done;\n      }\n      /* evaluate pseudo-code recursively */\n      switch (code->op)\n      {  case O_MEMVAR:\n            /* take member of variable */\n            {  TUPLE *tuple;\n               ARG_LIST *e;\n               tuple = create_tuple(mpl);\n               for (e = code->arg.var.list; e != NULL; e = e->next)\n                  tuple = expand_tuple(mpl, tuple, eval_symbolic(mpl,\n                     e->x));\n#if 1 /* 15/V-2010 */\n               xassert(code->arg.var.suff == DOT_NONE);\n#endif\n               value = single_variable(mpl,\n                  eval_member_var(mpl, code->arg.var.var, tuple));\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case O_CVTLFM:\n            /* convert to linear form */\n            value = constant_term(mpl, eval_numeric(mpl,\n               code->arg.arg.x));\n            break;\n         case O_PLUS:\n            /* unary plus */\n            value = linear_comb(mpl,\n                0.0, constant_term(mpl, 0.0),\n               +1.0, eval_formula(mpl, code->arg.arg.x));\n            break;\n         case O_MINUS:\n            /* unary minus */\n            value = linear_comb(mpl,\n                0.0, constant_term(mpl, 0.0),\n               -1.0, eval_formula(mpl, code->arg.arg.x));\n            break;\n         case O_ADD:\n            /* addition */\n            value = linear_comb(mpl,\n               +1.0, eval_formula(mpl, code->arg.arg.x),\n               +1.0, eval_formula(mpl, code->arg.arg.y));\n            break;\n         case O_SUB:\n            /* subtraction */\n            value = linear_comb(mpl,\n               +1.0, eval_formula(mpl, code->arg.arg.x),\n               -1.0, eval_formula(mpl, code->arg.arg.y));\n            break;\n         case O_MUL:\n            /* multiplication */\n            xassert(code->arg.arg.x != NULL);\n            xassert(code->arg.arg.y != NULL);\n            if (code->arg.arg.x->type == A_NUMERIC)\n            {  xassert(code->arg.arg.y->type == A_FORMULA);\n               value = linear_comb(mpl,\n                  eval_numeric(mpl, code->arg.arg.x),\n                  eval_formula(mpl, code->arg.arg.y),\n                  0.0, constant_term(mpl, 0.0));\n            }\n            else\n            {  xassert(code->arg.arg.x->type == A_FORMULA);\n               xassert(code->arg.arg.y->type == A_NUMERIC);\n               value = linear_comb(mpl,\n                  eval_numeric(mpl, code->arg.arg.y),\n                  eval_formula(mpl, code->arg.arg.x),\n                  0.0, constant_term(mpl, 0.0));\n            }\n            break;\n         case O_DIV:\n            /* division */\n            value = linear_comb(mpl,\n               fp_div(mpl, 1.0, eval_numeric(mpl, code->arg.arg.y)),\n               eval_formula(mpl, code->arg.arg.x),\n               0.0, constant_term(mpl, 0.0));\n            break;\n         case O_FORK:\n            /* if-then-else */\n            if (eval_logical(mpl, code->arg.arg.x))\n               value = eval_formula(mpl, code->arg.arg.y);\n            else if (code->arg.arg.z == NULL)\n               value = constant_term(mpl, 0.0);\n            else\n               value = eval_formula(mpl, code->arg.arg.z);\n            break;\n         case O_SUM:\n            /* summation over domain */\n            {  struct iter_form_info _info, *info = &_info;\n               info->code = code;\n               info->value = constant_term(mpl, 0.0);\n               info->tail = NULL;\n               loop_within_domain(mpl, code->arg.loop.domain, info,\n                  iter_form_func);\n               value = reduce_terms(mpl, info->value);\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      /* save resultant value */\n      xassert(!code->valid);\n      code->valid = 1;\n      code->value.form = copy_formula(mpl, value);\ndone: return value;\n}",
      "lines": 119,
      "depth": 17,
      "decorators": [
        "FORMULA",
        "*eval_formula(MPL *mpl, CODE *code)",
        "*"
      ]
    },
    "clean_code": {
      "start_point": [
        4827,
        0
      ],
      "end_point": [
        4967,
        1
      ],
      "content": "void clean_code(MPL *mpl, CODE *code)\n{     ARG_LIST *e;\n      /* if no pseudo-code is specified, do nothing */\n      if (code == NULL) goto done;\n      /* if resultant value is valid (exists), delete it */\n      if (code->valid)\n      {  code->valid = 0;\n         delete_value(mpl, code->type, &code->value);\n      }\n      /* recursively clean pseudo-code for operands */\n      switch (code->op)\n      {  case O_NUMBER:\n         case O_STRING:\n         case O_INDEX:\n            break;\n         case O_MEMNUM:\n         case O_MEMSYM:\n            for (e = code->arg.par.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n         case O_MEMSET:\n            for (e = code->arg.set.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n         case O_MEMVAR:\n            for (e = code->arg.var.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n#if 1 /* 15/V-2010 */\n         case O_MEMCON:\n            for (e = code->arg.con.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n#endif\n         case O_TUPLE:\n         case O_MAKE:\n            for (e = code->arg.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n         case O_SLICE:\n            xassert(code != code);\n         case O_IRAND224:\n         case O_UNIFORM01:\n         case O_NORMAL01:\n         case O_GMTIME:\n            break;\n         case O_CVTNUM:\n         case O_CVTSYM:\n         case O_CVTLOG:\n         case O_CVTTUP:\n         case O_CVTLFM:\n         case O_PLUS:\n         case O_MINUS:\n         case O_NOT:\n         case O_ABS:\n         case O_CEIL:\n         case O_FLOOR:\n         case O_EXP:\n         case O_LOG:\n         case O_LOG10:\n         case O_SQRT:\n         case O_SIN:\n         case O_COS:\n         case O_TAN:\n         case O_ATAN:\n         case O_ROUND:\n         case O_TRUNC:\n         case O_CARD:\n         case O_LENGTH:\n            /* unary operation */\n            clean_code(mpl, code->arg.arg.x);\n            break;\n         case O_ADD:\n         case O_SUB:\n         case O_LESS:\n         case O_MUL:\n         case O_DIV:\n         case O_IDIV:\n         case O_MOD:\n         case O_POWER:\n         case O_ATAN2:\n         case O_ROUND2:\n         case O_TRUNC2:\n         case O_UNIFORM:\n         case O_NORMAL:\n         case O_CONCAT:\n         case O_LT:\n         case O_LE:\n         case O_EQ:\n         case O_GE:\n         case O_GT:\n         case O_NE:\n         case O_AND:\n         case O_OR:\n         case O_UNION:\n         case O_DIFF:\n         case O_SYMDIFF:\n         case O_INTER:\n         case O_CROSS:\n         case O_IN:\n         case O_NOTIN:\n         case O_WITHIN:\n         case O_NOTWITHIN:\n         case O_SUBSTR:\n         case O_STR2TIME:\n         case O_TIME2STR:\n            /* binary operation */\n            clean_code(mpl, code->arg.arg.x);\n            clean_code(mpl, code->arg.arg.y);\n            break;\n         case O_DOTS:\n         case O_FORK:\n         case O_SUBSTR3:\n            /* ternary operation */\n            clean_code(mpl, code->arg.arg.x);\n            clean_code(mpl, code->arg.arg.y);\n            clean_code(mpl, code->arg.arg.z);\n            break;\n         case O_MIN:\n         case O_MAX:\n            /* n-ary operation */\n            for (e = code->arg.list; e != NULL; e = e->next)\n               clean_code(mpl, e->x);\n            break;\n         case O_SUM:\n         case O_PROD:\n         case O_MINIMUM:\n         case O_MAXIMUM:\n         case O_FORALL:\n         case O_EXISTS:\n         case O_SETOF:\n         case O_BUILD:\n            /* iterated operation */\n            clean_domain(mpl, code->arg.loop.domain);\n            clean_code(mpl, code->arg.loop.x);\n            break;\n         default:\n            xassert(code->op != code->op);\n      }\ndone: return;\n}",
      "lines": 141,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpl_tab_num_args": {
      "start_point": [
        4974,
        0
      ],
      "end_point": [
        4977,
        1
      ],
      "content": "int mpl_tab_num_args(TABDCA *dca)\n{     /* returns the number of arguments */\n      return dca->na;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "mpl_tab_get_arg": {
      "start_point": [
        4979,
        0
      ],
      "end_point": [
        4983,
        1
      ],
      "content": "const char *mpl_tab_get_arg(TABDCA *dca, int k)\n{     /* returns pointer to k-th argument */\n      xassert(1 <= k && k <= dca->na);\n      return dca->arg[k];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*mpl_tab_get_arg(TABDCA *dca, int k)",
        "*"
      ]
    },
    "mpl_tab_num_flds": {
      "start_point": [
        4985,
        0
      ],
      "end_point": [
        4988,
        1
      ],
      "content": "int mpl_tab_num_flds(TABDCA *dca)\n{     /* returns the number of fields */\n      return dca->nf;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "mpl_tab_get_name": {
      "start_point": [
        4990,
        0
      ],
      "end_point": [
        4994,
        1
      ],
      "content": "const char *mpl_tab_get_name(TABDCA *dca, int k)\n{     /* returns pointer to name of k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      return dca->name[k];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*mpl_tab_get_name(TABDCA *dca, int k)",
        "*"
      ]
    },
    "mpl_tab_get_type": {
      "start_point": [
        4996,
        0
      ],
      "end_point": [
        5000,
        1
      ],
      "content": "int mpl_tab_get_type(TABDCA *dca, int k)\n{     /* returns type of k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      return dca->type[k];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpl_tab_get_num": {
      "start_point": [
        5002,
        0
      ],
      "end_point": [
        5007,
        1
      ],
      "content": "double mpl_tab_get_num(TABDCA *dca, int k)\n{     /* returns numeric value of k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      xassert(dca->type[k] == 'N');\n      return dca->num[k];\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "mpl_tab_get_str": {
      "start_point": [
        5009,
        0
      ],
      "end_point": [
        5015,
        1
      ],
      "content": "const char *mpl_tab_get_str(TABDCA *dca, int k)\n{     /* returns pointer to string value of k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      xassert(dca->type[k] == 'S');\n      xassert(dca->str[k] != NULL);\n      return dca->str[k];\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*mpl_tab_get_str(TABDCA *dca, int k)",
        "*"
      ]
    },
    "mpl_tab_set_num": {
      "start_point": [
        5017,
        0
      ],
      "end_point": [
        5024,
        1
      ],
      "content": "void mpl_tab_set_num(TABDCA *dca, int k, double num)\n{     /* assign numeric value to k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      xassert(dca->type[k] == '?');\n      dca->type[k] = 'N';\n      dca->num[k] = num;\n      return;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpl_tab_set_str": {
      "start_point": [
        5026,
        0
      ],
      "end_point": [
        5035,
        1
      ],
      "content": "void mpl_tab_set_str(TABDCA *dca, int k, const char *str)\n{     /* assign string value to k-th field */\n      xassert(1 <= k && k <= dca->nf);\n      xassert(dca->type[k] == '?');\n      xassert(strlen(str) <= MAX_LENGTH);\n      xassert(dca->str[k] != NULL);\n      dca->type[k] = 'S';\n      strcpy(dca->str[k], str);\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_func": {
      "start_point": [
        5037,
        0
      ],
      "end_point": [
        5077,
        1
      ],
      "content": "static int write_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      TABLE *tab = info;\n      TABDCA *dca = mpl->dca;\n      TABOUT *out;\n      SYMBOL *sym;\n      int k;\n      char buf[MAX_LENGTH+1];\n      /* evaluate field values */\n      k = 0;\n      for (out = tab->u.out.list; out != NULL; out = out->next)\n      {  k++;\n         switch (out->code->type)\n         {  case A_NUMERIC:\n               dca->type[k] = 'N';\n               dca->num[k] = eval_numeric(mpl, out->code);\n               dca->str[k][0] = '\\0';\n               break;\n            case A_SYMBOLIC:\n               sym = eval_symbolic(mpl, out->code);\n               if (sym->str == NULL)\n               {  dca->type[k] = 'N';\n                  dca->num[k] = sym->num;\n                  dca->str[k][0] = '\\0';\n               }\n               else\n               {  dca->type[k] = 'S';\n                  dca->num[k] = 0.0;\n                  fetch_string(mpl, sym->str, buf);\n                  strcpy(dca->str[k], buf);\n               }\n               delete_symbol(mpl, sym);\n               break;\n            default:\n               xassert(out != out);\n         }\n      }\n      /* write record to output table */\n      mpl_tab_drv_write(mpl);\n      return 0;\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_table": {
      "start_point": [
        5079,
        0
      ],
      "end_point": [
        5291,
        1
      ],
      "content": "void execute_table(MPL *mpl, TABLE *tab)\n{     /* execute table statement */\n      TABARG *arg;\n      TABFLD *fld;\n      TABIN *in;\n      TABOUT *out;\n      TABDCA *dca;\n      SET *set;\n      int k;\n      char buf[MAX_LENGTH+1];\n      /* allocate table driver communication area */\n      xassert(mpl->dca == NULL);\n      mpl->dca = dca = xmalloc(sizeof(TABDCA));\n      dca->id = 0;\n      dca->link = NULL;\n      dca->na = 0;\n      dca->arg = NULL;\n      dca->nf = 0;\n      dca->name = NULL;\n      dca->type = NULL;\n      dca->num = NULL;\n      dca->str = NULL;\n      /* allocate arguments */\n      xassert(dca->na == 0);\n      for (arg = tab->arg; arg != NULL; arg = arg->next)\n         dca->na++;\n      dca->arg = xcalloc(1+dca->na, sizeof(char *));\n#if 1 /* 28/IX-2008 */\n      for (k = 1; k <= dca->na; k++) dca->arg[k] = NULL;\n#endif\n      /* evaluate argument values */\n      k = 0;\n      for (arg = tab->arg; arg != NULL; arg = arg->next)\n      {  SYMBOL *sym;\n         k++;\n         xassert(arg->code->type == A_SYMBOLIC);\n         sym = eval_symbolic(mpl, arg->code);\n         if (sym->str == NULL)\n            sprintf(buf, \"%.*g\", DBL_DIG, sym->num);\n         else\n            fetch_string(mpl, sym->str, buf);\n         delete_symbol(mpl, sym);\n         dca->arg[k] = xmalloc(strlen(buf)+1);\n         strcpy(dca->arg[k], buf);\n      }\n      /* perform table input/output */\n      switch (tab->type)\n      {  case A_INPUT:  goto read_table;\n         case A_OUTPUT: goto write_table;\n         default:       xassert(tab != tab);\n      }\nread_table:\n      /* read data from input table */\n      /* add the only member to the control set and assign it empty\n         elemental set */\n      set = tab->u.in.set;\n      if (set != NULL)\n      {  if (set->data)\n            error(mpl, \"%s already provided with data\", set->name);\n         xassert(set->array->head == NULL);\n         add_member(mpl, set->array, NULL)->value.set =\n            create_elemset(mpl, set->dimen);\n         set->data = 1;\n      }\n      /* check parameters specified in the input list */\n      for (in = tab->u.in.list; in != NULL; in = in->next)\n      {  if (in->par->data)\n            error(mpl, \"%s already provided with data\", in->par->name);\n         in->par->data = 1;\n      }\n      /* allocate and initialize fields */\n      xassert(dca->nf == 0);\n      for (fld = tab->u.in.fld; fld != NULL; fld = fld->next)\n         dca->nf++;\n      for (in = tab->u.in.list; in != NULL; in = in->next)\n         dca->nf++;\n      dca->name = xcalloc(1+dca->nf, sizeof(char *));\n      dca->type = xcalloc(1+dca->nf, sizeof(int));\n      dca->num = xcalloc(1+dca->nf, sizeof(double));\n      dca->str = xcalloc(1+dca->nf, sizeof(char *));\n      k = 0;\n      for (fld = tab->u.in.fld; fld != NULL; fld = fld->next)\n      {  k++;\n         dca->name[k] = fld->name;\n         dca->type[k] = '?';\n         dca->num[k] = 0.0;\n         dca->str[k] = xmalloc(MAX_LENGTH+1);\n         dca->str[k][0] = '\\0';\n      }\n      for (in = tab->u.in.list; in != NULL; in = in->next)\n      {  k++;\n         dca->name[k] = in->name;\n         dca->type[k] = '?';\n         dca->num[k] = 0.0;\n         dca->str[k] = xmalloc(MAX_LENGTH+1);\n         dca->str[k][0] = '\\0';\n      }\n      /* open input table */\n      mpl_tab_drv_open(mpl, 'R');\n      /* read and process records */\n      for (;;)\n      {  TUPLE *tup;\n         /* reset field types */\n         for (k = 1; k <= dca->nf; k++)\n            dca->type[k] = '?';\n         /* read next record */\n         if (mpl_tab_drv_read(mpl)) break;\n         /* all fields must be set by the driver */\n         for (k = 1; k <= dca->nf; k++)\n         {  if (dca->type[k] == '?')\n               error(mpl, \"field %s missing in input table\",\n                  dca->name[k]);\n         }\n         /* construct n-tuple */\n         tup = create_tuple(mpl);\n         k = 0;\n         for (fld = tab->u.in.fld; fld != NULL; fld = fld->next)\n         {  k++;\n            xassert(k <= dca->nf);\n            switch (dca->type[k])\n            {  case 'N':\n                  tup = expand_tuple(mpl, tup, create_symbol_num(mpl,\n                     dca->num[k]));\n                  break;\n               case 'S':\n                  xassert(strlen(dca->str[k]) <= MAX_LENGTH);\n                  tup = expand_tuple(mpl, tup, create_symbol_str(mpl,\n                     create_string(mpl, dca->str[k])));\n                  break;\n               default:\n                  xassert(dca != dca);\n            }\n         }\n         /* add n-tuple just read to the control set */\n         if (tab->u.in.set != NULL)\n            check_then_add(mpl, tab->u.in.set->array->head->value.set,\n               copy_tuple(mpl, tup));\n         /* assign values to the parameters in the input list */\n         for (in = tab->u.in.list; in != NULL; in = in->next)\n         {  MEMBER *memb;\n            k++;\n            xassert(k <= dca->nf);\n            /* there must be no member with the same n-tuple */\n            if (find_member(mpl, in->par->array, tup) != NULL)\n               error(mpl, \"%s%s already defined\", in->par->name,\n               format_tuple(mpl, '[', tup));\n            /* create new parameter member with given n-tuple */\n            memb = add_member(mpl, in->par->array, copy_tuple(mpl, tup))\n               ;\n            /* assign value to the parameter member */\n            switch (in->par->type)\n            {  case A_NUMERIC:\n               case A_INTEGER:\n               case A_BINARY:\n                  if (dca->type[k] != 'N')\n                     error(mpl, \"%s requires numeric data\",\n                        in->par->name);\n                  memb->value.num = dca->num[k];\n                  break;\n               case A_SYMBOLIC:\n                  switch (dca->type[k])\n                  {  case 'N':\n                        memb->value.sym = create_symbol_num(mpl,\n                           dca->num[k]);\n                        break;\n                     case 'S':\n                        xassert(strlen(dca->str[k]) <= MAX_LENGTH);\n                        memb->value.sym = create_symbol_str(mpl,\n                           create_string(mpl,dca->str[k]));\n                        break;\n                     default:\n                        xassert(dca != dca);\n                  }\n                  break;\n               default:\n                  xassert(in != in);\n            }\n         }\n         /* n-tuple is no more needed */\n         delete_tuple(mpl, tup);\n      }\n      /* close input table */\n      mpl_tab_drv_close(mpl);\n      goto done;\nwrite_table:\n      /* write data to output table */\n      /* allocate and initialize fields */\n      xassert(dca->nf == 0);\n      for (out = tab->u.out.list; out != NULL; out = out->next)\n         dca->nf++;\n      dca->name = xcalloc(1+dca->nf, sizeof(char *));\n      dca->type = xcalloc(1+dca->nf, sizeof(int));\n      dca->num = xcalloc(1+dca->nf, sizeof(double));\n      dca->str = xcalloc(1+dca->nf, sizeof(char *));\n      k = 0;\n      for (out = tab->u.out.list; out != NULL; out = out->next)\n      {  k++;\n         dca->name[k] = out->name;\n         dca->type[k] = '?';\n         dca->num[k] = 0.0;\n         dca->str[k] = xmalloc(MAX_LENGTH+1);\n         dca->str[k][0] = '\\0';\n      }\n      /* open output table */\n      mpl_tab_drv_open(mpl, 'W');\n      /* evaluate fields and write records */\n      loop_within_domain(mpl, tab->u.out.domain, tab, write_func);\n      /* close output table */\n      mpl_tab_drv_close(mpl);\ndone: /* free table driver communication area */\n      free_dca(mpl);\n      return;\n}",
      "lines": 213,
      "depth": 21,
      "decorators": [
        "void"
      ]
    },
    "free_dca": {
      "start_point": [
        5293,
        0
      ],
      "end_point": [
        5319,
        1
      ],
      "content": "void free_dca(MPL *mpl)\n{     /* free table driver communucation area */\n      TABDCA *dca = mpl->dca;\n      int k;\n      if (dca != NULL)\n      {  if (dca->link != NULL)\n            mpl_tab_drv_close(mpl);\n         if (dca->arg != NULL)\n         {  for (k = 1; k <= dca->na; k++)\n#if 1 /* 28/IX-2008 */\n               if (dca->arg[k] != NULL)\n#endif\n               xfree(dca->arg[k]);\n            xfree(dca->arg);\n         }\n         if (dca->name != NULL) xfree(dca->name);\n         if (dca->type != NULL) xfree(dca->type);\n         if (dca->num != NULL) xfree(dca->num);\n         if (dca->str != NULL)\n         {  for (k = 1; k <= dca->nf; k++)\n               xfree(dca->str[k]);\n            xfree(dca->str);\n         }\n         xfree(dca), mpl->dca = NULL;\n      }\n      return;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "clean_table": {
      "start_point": [
        5321,
        0
      ],
      "end_point": [
        5342,
        1
      ],
      "content": "void clean_table(MPL *mpl, TABLE *tab)\n{     /* clean table statement */\n      TABARG *arg;\n      TABOUT *out;\n      /* clean string list */\n      for (arg = tab->arg; arg != NULL; arg = arg->next)\n         clean_code(mpl, arg->code);\n      switch (tab->type)\n      {  case A_INPUT:\n            break;\n         case A_OUTPUT:\n            /* clean subscript domain */\n            clean_domain(mpl, tab->u.out.domain);\n            /* clean output list */\n            for (out = tab->u.out.list; out != NULL; out = out->next)\n               clean_code(mpl, out->code);\n            break;\n         default:\n            xassert(tab != tab);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "check_func": {
      "start_point": [
        5354,
        0
      ],
      "end_point": [
        5361,
        1
      ],
      "content": "static int check_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      CHECK *chk = (CHECK *)info;\n      if (!eval_logical(mpl, chk->code))\n         error(mpl, \"check%s failed\", format_tuple(mpl, '[',\n            get_domain_tuple(mpl, chk->domain)));\n      return 0;\n}",
      "lines": 8,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_check": {
      "start_point": [
        5363,
        0
      ],
      "end_point": [
        5366,
        1
      ],
      "content": "void execute_check(MPL *mpl, CHECK *chk)\n{     loop_within_domain(mpl, chk->domain, chk, check_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_check": {
      "start_point": [
        5374,
        0
      ],
      "end_point": [
        5380,
        1
      ],
      "content": "void clean_check(MPL *mpl, CHECK *chk)\n{     /* clean subscript domain */\n      clean_domain(mpl, chk->domain);\n      /* clean pseudo-code for computing predicate */\n      clean_code(mpl, chk->code);\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "display_set": {
      "start_point": [
        5387,
        0
      ],
      "end_point": [
        5397,
        1
      ],
      "content": "static void display_set(MPL *mpl, SET *set, MEMBER *memb)\n{     /* display member of model set */\n      ELEMSET *s = memb->value.set;\n      MEMBER *m;\n      write_text(mpl, \"%s%s%s\\n\", set->name,\n         format_tuple(mpl, '[', memb->tuple),\n         s->head == NULL ? \" is empty\" : \":\");\n      for (m = s->head; m != NULL; m = m->next)\n         write_text(mpl, \"   %s\\n\", format_tuple(mpl, '(', m->tuple));\n      return;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_par": {
      "start_point": [
        5399,
        0
      ],
      "end_point": [
        5418,
        1
      ],
      "content": "static void display_par(MPL *mpl, PARAMETER *par, MEMBER *memb)\n{     /* display member of model parameter */\n      switch (par->type)\n      {  case A_NUMERIC:\n         case A_INTEGER:\n         case A_BINARY:\n            write_text(mpl, \"%s%s = %.*g\\n\", par->name,\n               format_tuple(mpl, '[', memb->tuple),\n               DBL_DIG, memb->value.num);\n            break;\n         case A_SYMBOLIC:\n            write_text(mpl, \"%s%s = %s\\n\", par->name,\n               format_tuple(mpl, '[', memb->tuple),\n               format_symbol(mpl, memb->value.sym));\n            break;\n         default:\n            xassert(par != par);\n      }\n      return;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_var": {
      "start_point": [
        5421,
        0
      ],
      "end_point": [
        5448,
        1
      ],
      "content": "static void display_var(MPL *mpl, VARIABLE *var, MEMBER *memb,\n      int suff)\n{     /* display member of model variable */\n      if (suff == DOT_NONE || suff == DOT_VAL)\n         write_text(mpl, \"%s%s.val = %.*g\\n\", var->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.var->prim);\n      else if (suff == DOT_LB)\n         write_text(mpl, \"%s%s.lb = %.*g\\n\", var->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.var->var->lbnd == NULL ? -DBL_MAX :\n            memb->value.var->lbnd);\n      else if (suff == DOT_UB)\n         write_text(mpl, \"%s%s.ub = %.*g\\n\", var->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.var->var->ubnd == NULL ? +DBL_MAX :\n            memb->value.var->ubnd);\n      else if (suff == DOT_STATUS)\n         write_text(mpl, \"%s%s.status = %d\\n\", var->name, format_tuple\n            (mpl, '[', memb->tuple), memb->value.var->stat);\n      else if (suff == DOT_DUAL)\n         write_text(mpl, \"%s%s.dual = %.*g\\n\", var->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.var->dual);\n      else\n         xassert(suff != suff);\n      return;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_con": {
      "start_point": [
        5452,
        0
      ],
      "end_point": [
        5479,
        1
      ],
      "content": "static void display_con(MPL *mpl, CONSTRAINT *con, MEMBER *memb,\n      int suff)\n{     /* display member of model constraint */\n      if (suff == DOT_NONE || suff == DOT_VAL)\n         write_text(mpl, \"%s%s.val = %.*g\\n\", con->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.con->prim);\n      else if (suff == DOT_LB)\n         write_text(mpl, \"%s%s.lb = %.*g\\n\", con->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.con->con->lbnd == NULL ? -DBL_MAX :\n            memb->value.con->lbnd);\n      else if (suff == DOT_UB)\n         write_text(mpl, \"%s%s.ub = %.*g\\n\", con->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.con->con->ubnd == NULL ? +DBL_MAX :\n            memb->value.con->ubnd);\n      else if (suff == DOT_STATUS)\n         write_text(mpl, \"%s%s.status = %d\\n\", con->name, format_tuple\n            (mpl, '[', memb->tuple), memb->value.con->stat);\n      else if (suff == DOT_DUAL)\n         write_text(mpl, \"%s%s.dual = %.*g\\n\", con->name,\n            format_tuple(mpl, '[', memb->tuple), DBL_DIG,\n            memb->value.con->dual);\n      else\n         xassert(suff != suff);\n      return;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_memb": {
      "start_point": [
        5482,
        0
      ],
      "end_point": [
        5527,
        1
      ],
      "content": "static void display_memb(MPL *mpl, CODE *code)\n{     /* display member specified by pseudo-code */\n      MEMBER memb;\n      ARG_LIST *e;\n      xassert(code->op == O_MEMNUM || code->op == O_MEMSYM\n         || code->op == O_MEMSET || code->op == O_MEMVAR\n         || code->op == O_MEMCON);\n      memb.tuple = create_tuple(mpl);\n      for (e = code->arg.par.list; e != NULL; e = e->next)\n         memb.tuple = expand_tuple(mpl, memb.tuple, eval_symbolic(mpl,\n            e->x));\n      switch (code->op)\n      {  case O_MEMNUM:\n            memb.value.num = eval_member_num(mpl, code->arg.par.par,\n               memb.tuple);\n            display_par(mpl, code->arg.par.par, &memb);\n            break;\n         case O_MEMSYM:\n            memb.value.sym = eval_member_sym(mpl, code->arg.par.par,\n               memb.tuple);\n            display_par(mpl, code->arg.par.par, &memb);\n            delete_symbol(mpl, memb.value.sym);\n            break;\n         case O_MEMSET:\n            memb.value.set = eval_member_set(mpl, code->arg.set.set,\n               memb.tuple);\n            display_set(mpl, code->arg.set.set, &memb);\n            break;\n         case O_MEMVAR:\n            memb.value.var = eval_member_var(mpl, code->arg.var.var,\n               memb.tuple);\n            display_var\n               (mpl, code->arg.var.var, &memb, code->arg.var.suff);\n            break;\n         case O_MEMCON:\n            memb.value.con = eval_member_con(mpl, code->arg.con.con,\n               memb.tuple);\n            display_con\n               (mpl, code->arg.con.con, &memb, code->arg.con.suff);\n            break;\n         default:\n            xassert(code != code);\n      }\n      delete_tuple(mpl, memb.tuple);\n      return;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_code": {
      "start_point": [
        5529,
        0
      ],
      "end_point": [
        5596,
        1
      ],
      "content": "static void display_code(MPL *mpl, CODE *code)\n{     /* display value of expression */\n      switch (code->type)\n      {  case A_NUMERIC:\n            /* numeric value */\n            {  double num;\n               num = eval_numeric(mpl, code);\n               write_text(mpl, \"%.*g\\n\", DBL_DIG, num);\n            }\n            break;\n         case A_SYMBOLIC:\n            /* symbolic value */\n            {  SYMBOL *sym;\n               sym = eval_symbolic(mpl, code);\n               write_text(mpl, \"%s\\n\", format_symbol(mpl, sym));\n               delete_symbol(mpl, sym);\n            }\n            break;\n         case A_LOGICAL:\n            /* logical value */\n            {  int bit;\n               bit = eval_logical(mpl, code);\n               write_text(mpl, \"%s\\n\", bit ? \"true\" : \"false\");\n            }\n            break;\n         case A_TUPLE:\n            /* n-tuple */\n            {  TUPLE *tuple;\n               tuple = eval_tuple(mpl, code);\n               write_text(mpl, \"%s\\n\", format_tuple(mpl, '(', tuple));\n               delete_tuple(mpl, tuple);\n            }\n            break;\n         case A_ELEMSET:\n            /* elemental set */\n            {  ELEMSET *set;\n               MEMBER *memb;\n               set = eval_elemset(mpl, code);\n               if (set->head == 0)\n                  write_text(mpl, \"set is empty\\n\");\n               for (memb = set->head; memb != NULL; memb = memb->next)\n                  write_text(mpl, \"   %s\\n\", format_tuple(mpl, '(',\n                     memb->tuple));\n               delete_elemset(mpl, set);\n            }\n            break;\n         case A_FORMULA:\n            /* linear form */\n            {  FORMULA *form, *term;\n               form = eval_formula(mpl, code);\n               if (form == NULL)\n                  write_text(mpl, \"linear form is empty\\n\");\n               for (term = form; term != NULL; term = term->next)\n               {  if (term->var == NULL)\n                     write_text(mpl, \"   %.*g\\n\", term->coef);\n                  else\n                     write_text(mpl, \"   %.*g %s%s\\n\", DBL_DIG,\n                        term->coef, term->var->var->name,\n                        format_tuple(mpl, '[', term->var->memb->tuple));\n               }\n               delete_formula(mpl, form);\n            }\n            break;\n         default:\n            xassert(code != code);\n      }\n      return;\n}",
      "lines": 68,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_func": {
      "start_point": [
        5598,
        0
      ],
      "end_point": [
        5700,
        1
      ],
      "content": "static int display_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      DISPLAY *dpy = (DISPLAY *)info;\n      DISPLAY1 *entry;\n      for (entry = dpy->list; entry != NULL; entry = entry->next)\n      {  if (entry->type == A_INDEX)\n         {  /* dummy index */\n            DOMAIN_SLOT *slot = entry->u.slot;\n            write_text(mpl, \"%s = %s\\n\", slot->name,\n            format_symbol(mpl, slot->value));\n         }\n         else if (entry->type == A_SET)\n         {  /* model set */\n            SET *set = entry->u.set;\n            MEMBER *memb;\n            if (set->assign != NULL)\n            {  /* the set has assignment expression; evaluate all its\n                  members over entire domain */\n               eval_whole_set(mpl, set);\n            }\n            else\n            {  /* the set has no assignment expression; refer to its\n                  any existing member ignoring resultant value to check\n                  the data provided the data section */\n#if 1 /* 12/XII-2008 */\n               if (set->gadget != NULL && set->data == 0)\n               {  /* initialize the set with data from a plain set */\n                  saturate_set(mpl, set);\n               }\n#endif\n               if (set->array->head != NULL)\n                  eval_member_set(mpl, set, set->array->head->tuple);\n            }\n            /* display all members of the set array */\n            if (set->array->head == NULL)\n               write_text(mpl, \"%s has empty content\\n\", set->name);\n            for (memb = set->array->head; memb != NULL; memb =\n               memb->next) display_set(mpl, set, memb);\n         }\n         else if (entry->type == A_PARAMETER)\n         {  /* model parameter */\n            PARAMETER *par = entry->u.par;\n            MEMBER *memb;\n            if (par->assign != NULL)\n            {  /* the parameter has an assignment expression; evaluate\n                  all its member over entire domain */\n               eval_whole_par(mpl, par);\n            }\n            else\n            {  /* the parameter has no assignment expression; refer to\n                  its any existing member ignoring resultant value to\n                  check the data provided in the data section */\n               if (par->array->head != NULL)\n               {  if (par->type != A_SYMBOLIC)\n                     eval_member_num(mpl, par, par->array->head->tuple);\n                  else\n                     delete_symbol(mpl, eval_member_sym(mpl, par,\n                        par->array->head->tuple));\n               }\n            }\n            /* display all members of the parameter array */\n            if (par->array->head == NULL)\n               write_text(mpl, \"%s has empty content\\n\", par->name);\n            for (memb = par->array->head; memb != NULL; memb =\n               memb->next) display_par(mpl, par, memb);\n         }\n         else if (entry->type == A_VARIABLE)\n         {  /* model variable */\n            VARIABLE *var = entry->u.var;\n            MEMBER *memb;\n            xassert(mpl->flag_p);\n            /* display all members of the variable array */\n            if (var->array->head == NULL)\n               write_text(mpl, \"%s has empty content\\n\", var->name);\n            for (memb = var->array->head; memb != NULL; memb =\n               memb->next) display_var(mpl, var, memb, DOT_NONE);\n         }\n         else if (entry->type == A_CONSTRAINT)\n         {  /* model constraint */\n            CONSTRAINT *con = entry->u.con;\n            MEMBER *memb;\n            xassert(mpl->flag_p);\n            /* display all members of the constraint array */\n            if (con->array->head == NULL)\n               write_text(mpl, \"%s has empty content\\n\", con->name);\n            for (memb = con->array->head; memb != NULL; memb =\n               memb->next) display_con(mpl, con, memb, DOT_NONE);\n         }\n         else if (entry->type == A_EXPRESSION)\n         {  /* expression */\n            CODE *code = entry->u.code;\n            if (code->op == O_MEMNUM || code->op == O_MEMSYM ||\n                code->op == O_MEMSET || code->op == O_MEMVAR ||\n                code->op == O_MEMCON)\n               display_memb(mpl, code);\n            else\n               display_code(mpl, code);\n         }\n         else\n            xassert(entry != entry);\n      }\n      return 0;\n}",
      "lines": 103,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_display": {
      "start_point": [
        5702,
        0
      ],
      "end_point": [
        5705,
        1
      ],
      "content": "void execute_display(MPL *mpl, DISPLAY *dpy)\n{     loop_within_domain(mpl, dpy->domain, dpy, display_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_display": {
      "start_point": [
        5713,
        0
      ],
      "end_point": [
        5732,
        1
      ],
      "content": "void clean_display(MPL *mpl, DISPLAY *dpy)\n{     DISPLAY1 *d;\n#if 0 /* 15/V-2010 */\n      ARG_LIST *e;\n#endif\n      /* clean subscript domain */\n      clean_domain(mpl, dpy->domain);\n      /* clean display list */\n      for (d = dpy->list; d != NULL; d = d->next)\n      {  /* clean pseudo-code for computing expression */\n         if (d->type == A_EXPRESSION)\n            clean_code(mpl, d->u.code);\n#if 0 /* 15/V-2010 */\n         /* clean pseudo-code for computing subscripts */\n         for (e = d->list; e != NULL; e = e->next)\n            clean_code(mpl, e->x);\n#endif\n      }\n      return;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "print_char": {
      "start_point": [
        5740,
        0
      ],
      "end_point": [
        5753,
        1
      ],
      "content": "static void print_char(MPL *mpl, int c)\n{     if (mpl->prt_fp == NULL)\n         write_char(mpl, c);\n      else\n#if 0 /* 04/VIII-2013 */\n         xfputc(c, mpl->prt_fp);\n#else\n      {  unsigned char buf[1];\n         buf[0] = (unsigned char)c;\n         glp_write(mpl->prt_fp, buf, 1);\n      }\n#endif\n      return;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_text": {
      "start_point": [
        5755,
        0
      ],
      "end_point": [
        5764,
        1
      ],
      "content": "static void print_text(MPL *mpl, char *fmt, ...)\n{     va_list arg;\n      char buf[OUTBUF_SIZE], *c;\n      va_start(arg, fmt);\n      vsprintf(buf, fmt, arg);\n      xassert(strlen(buf) < sizeof(buf));\n      va_end(arg);\n      for (c = buf; *c != '\\0'; c++) print_char(mpl, *c);\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "printf_func": {
      "start_point": [
        5767,
        0
      ],
      "end_point": [
        5894,
        1
      ],
      "content": "static int printf_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      PRINTF *prt = (PRINTF *)info;\n      PRINTF1 *entry;\n      SYMBOL *sym;\n      char fmt[MAX_LENGTH+1], *c, *from, save;\n      /* evaluate format control string */\n      sym = eval_symbolic(mpl, prt->fmt);\n      if (sym->str == NULL)\n         sprintf(fmt, \"%.*g\", DBL_DIG, sym->num);\n      else\n         fetch_string(mpl, sym->str, fmt);\n      delete_symbol(mpl, sym);\n      /* scan format control string and perform formatting output */\n      entry = prt->list;\n      for (c = fmt; *c != '\\0'; c++)\n      {  if (*c == '%')\n         {  /* scan format specifier */\n            from = c++;\n            if (*c == '%')\n            {  print_char(mpl, '%');\n               continue;\n            }\n            if (entry == NULL) break;\n            /* scan optional flags */\n            while (*c == '-' || *c == '+' || *c == ' ' || *c == '#' ||\n                   *c == '0') c++;\n            /* scan optional minimum field width */\n            while (isdigit((unsigned char)*c)) c++;\n            /* scan optional precision */\n            if (*c == '.')\n            {  c++;\n               while (isdigit((unsigned char)*c)) c++;\n            }\n            /* scan conversion specifier and perform formatting */\n            save = *(c+1), *(c+1) = '\\0';\n            if (*c == 'd' || *c == 'i' || *c == 'e' || *c == 'E' ||\n                *c == 'f' || *c == 'F' || *c == 'g' || *c == 'G')\n            {  /* the specifier requires numeric value */\n               double value;\n               xassert(entry != NULL);\n               switch (entry->code->type)\n               {  case A_NUMERIC:\n                     value = eval_numeric(mpl, entry->code);\n                     break;\n                  case A_SYMBOLIC:\n                     sym = eval_symbolic(mpl, entry->code);\n                     if (sym->str != NULL)\n                        error(mpl, \"cannot convert %s to floating-point\"\n                           \" number\", format_symbol(mpl, sym));\n                     value = sym->num;\n                     delete_symbol(mpl, sym);\n                     break;\n                  case A_LOGICAL:\n                     if (eval_logical(mpl, entry->code))\n                        value = 1.0;\n                     else\n                        value = 0.0;\n                     break;\n                  default:\n                     xassert(entry != entry);\n               }\n               if (*c == 'd' || *c == 'i')\n               {  double int_max = (double)INT_MAX;\n                  if (!(-int_max <= value && value <= +int_max))\n                     error(mpl, \"cannot convert %.*g to integer\",\n                        DBL_DIG, value);\n                  print_text(mpl, from, (int)floor(value + 0.5));\n               }\n               else\n                  print_text(mpl, from, value);\n            }\n            else if (*c == 's')\n            {  /* the specifier requires symbolic value */\n               char value[MAX_LENGTH+1];\n               switch (entry->code->type)\n               {  case A_NUMERIC:\n                     sprintf(value, \"%.*g\", DBL_DIG, eval_numeric(mpl,\n                        entry->code));\n                     break;\n                  case A_LOGICAL:\n                     if (eval_logical(mpl, entry->code))\n                        strcpy(value, \"T\");\n                     else\n                        strcpy(value, \"F\");\n                     break;\n                  case A_SYMBOLIC:\n                     sym = eval_symbolic(mpl, entry->code);\n                     if (sym->str == NULL)\n                        sprintf(value, \"%.*g\", DBL_DIG, sym->num);\n                     else\n                        fetch_string(mpl, sym->str, value);\n                     delete_symbol(mpl, sym);\n                     break;\n                  default:\n                     xassert(entry != entry);\n               }\n               print_text(mpl, from, value);\n            }\n            else\n               error(mpl, \"format specifier missing or invalid\");\n            *(c+1) = save;\n            entry = entry->next;\n         }\n         else if (*c == '\\\\')\n         {  /* write some control character */\n            c++;\n            if (*c == 't')\n               print_char(mpl, '\\t');\n            else if (*c == 'n')\n               print_char(mpl, '\\n');\n#if 1 /* 28/X-2010 */\n            else if (*c == '\\0')\n            {  /* format string ends with backslash */\n               error(mpl, \"invalid use of escape character \\\\ in format\"\n                  \" control string\");\n            }\n#endif\n            else\n               print_char(mpl, *c);\n         }\n         else\n         {  /* write character without formatting */\n            print_char(mpl, *c);\n         }\n      }\n      return 0;\n}",
      "lines": 128,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_printf": [
      {
        "start_point": [
          5897,
          0
        ],
        "end_point": [
          5900,
          1
        ],
        "content": "void execute_printf(MPL *mpl, PRINTF *prt)\n{     loop_within_domain(mpl, prt->domain, prt, printf_func);\n      return;\n}",
        "lines": 4,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          5902,
          0
        ],
        "end_point": [
          5947,
          1
        ],
        "content": "void execute_printf(MPL *mpl, PRINTF *prt)\n{     if (prt->fname == NULL)\n      {  /* switch to the standard output */\n         if (mpl->prt_fp != NULL)\n         {  glp_close(mpl->prt_fp), mpl->prt_fp = NULL;\n            xfree(mpl->prt_file), mpl->prt_file = NULL;\n         }\n      }\n      else\n      {  /* evaluate file name string */\n         SYMBOL *sym;\n         char fname[MAX_LENGTH+1];\n         sym = eval_symbolic(mpl, prt->fname);\n         if (sym->str == NULL)\n            sprintf(fname, \"%.*g\", DBL_DIG, sym->num);\n         else\n            fetch_string(mpl, sym->str, fname);\n         delete_symbol(mpl, sym);\n         /* close the current print file, if necessary */\n         if (mpl->prt_fp != NULL &&\n            (!prt->app || strcmp(mpl->prt_file, fname) != 0))\n         {  glp_close(mpl->prt_fp), mpl->prt_fp = NULL;\n            xfree(mpl->prt_file), mpl->prt_file = NULL;\n         }\n         /* open the specified print file, if necessary */\n         if (mpl->prt_fp == NULL)\n         {  mpl->prt_fp = glp_open(fname, prt->app ? \"a\" : \"w\");\n            if (mpl->prt_fp == NULL)\n               error(mpl, \"unable to open '%s' for writing - %s\",\n                  fname, get_err_msg());\n            mpl->prt_file = xmalloc(strlen(fname)+1);\n            strcpy(mpl->prt_file, fname);\n         }\n      }\n      loop_within_domain(mpl, prt->domain, prt, printf_func);\n      if (mpl->prt_fp != NULL)\n      {\n#if 0 /* FIXME */\n         xfflush(mpl->prt_fp);\n#endif\n         if (glp_ioerr(mpl->prt_fp))\n            error(mpl, \"writing error to '%s' - %s\", mpl->prt_file,\n               get_err_msg());\n      }\n      return;\n}",
        "lines": 46,
        "depth": 14,
        "decorators": [
          "void"
        ]
      }
    ],
    "clean_printf": {
      "start_point": [
        5956,
        0
      ],
      "end_point": [
        5972,
        1
      ],
      "content": "void clean_printf(MPL *mpl, PRINTF *prt)\n{     PRINTF1 *p;\n      /* clean subscript domain */\n      clean_domain(mpl, prt->domain);\n      /* clean pseudo-code for computing format string */\n      clean_code(mpl, prt->fmt);\n      /* clean printf list */\n      for (p = prt->list; p != NULL; p = p->next)\n      {  /* clean pseudo-code for computing value to be printed */\n         clean_code(mpl, p->code);\n      }\n#if 1 /* 14/VII-2006 */\n      /* clean pseudo-code for computing file name string */\n      clean_code(mpl, prt->fname);\n#endif\n      return;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "for_func": {
      "start_point": [
        5979,
        0
      ],
      "end_point": [
        5988,
        1
      ],
      "content": "static int for_func(MPL *mpl, void *info)\n{     /* this is auxiliary routine to work within domain scope */\n      FOR *fur = (FOR *)info;\n      STATEMENT *stmt, *save;\n      save = mpl->stmt;\n      for (stmt = fur->list; stmt != NULL; stmt = stmt->next)\n         execute_statement(mpl, stmt);\n      mpl->stmt = save;\n      return 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute_for": {
      "start_point": [
        5990,
        0
      ],
      "end_point": [
        5993,
        1
      ],
      "content": "void execute_for(MPL *mpl, FOR *fur)\n{     loop_within_domain(mpl, fur->domain, fur, for_func);\n      return;\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "clean_for": {
      "start_point": [
        6001,
        0
      ],
      "end_point": [
        6009,
        1
      ],
      "content": "void clean_for(MPL *mpl, FOR *fur)\n{     STATEMENT *stmt;\n      /* clean subscript domain */\n      clean_domain(mpl, fur->domain);\n      /* clean all sub-statements */\n      for (stmt = fur->list; stmt != NULL; stmt = stmt->next)\n         clean_statement(mpl, stmt);\n      return;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "execute_statement": {
      "start_point": [
        6016,
        0
      ],
      "end_point": [
        6061,
        1
      ],
      "content": "void execute_statement(MPL *mpl, STATEMENT *stmt)\n{     mpl->stmt = stmt;\n      switch (stmt->type)\n      {  case A_SET:\n         case A_PARAMETER:\n         case A_VARIABLE:\n            break;\n         case A_CONSTRAINT:\n            xprintf(\"Generating %s...\\n\", stmt->u.con->name);\n            eval_whole_con(mpl, stmt->u.con);\n            break;\n         case A_TABLE:\n            switch (stmt->u.tab->type)\n            {  case A_INPUT:\n                  xprintf(\"Reading %s...\\n\", stmt->u.tab->name);\n                  break;\n               case A_OUTPUT:\n                  xprintf(\"Writing %s...\\n\", stmt->u.tab->name);\n                  break;\n               default:\n                  xassert(stmt != stmt);\n            }\n            execute_table(mpl, stmt->u.tab);\n            break;\n         case A_SOLVE:\n            break;\n         case A_CHECK:\n            xprintf(\"Checking (line %d)...\\n\", stmt->line);\n            execute_check(mpl, stmt->u.chk);\n            break;\n         case A_DISPLAY:\n            write_text(mpl, \"Display statement at line %d\\n\",\n               stmt->line);\n            execute_display(mpl, stmt->u.dpy);\n            break;\n         case A_PRINTF:\n            execute_printf(mpl, stmt->u.prt);\n            break;\n         case A_FOR:\n            execute_for(mpl, stmt->u.fur);\n            break;\n         default:\n            xassert(stmt != stmt);\n      }\n      return;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "clean_statement": {
      "start_point": [
        6069,
        0
      ],
      "end_point": [
        6097,
        1
      ],
      "content": "void clean_statement(MPL *mpl, STATEMENT *stmt)\n{     switch(stmt->type)\n      {  case A_SET:\n            clean_set(mpl, stmt->u.set); break;\n         case A_PARAMETER:\n            clean_parameter(mpl, stmt->u.par); break;\n         case A_VARIABLE:\n            clean_variable(mpl, stmt->u.var); break;\n         case A_CONSTRAINT:\n            clean_constraint(mpl, stmt->u.con); break;\n#if 1 /* 11/II-2008 */\n         case A_TABLE:\n            clean_table(mpl, stmt->u.tab); break;\n#endif\n         case A_SOLVE:\n            break;\n         case A_CHECK:\n            clean_check(mpl, stmt->u.chk); break;\n         case A_DISPLAY:\n            clean_display(mpl, stmt->u.dpy); break;\n         case A_PRINTF:\n            clean_printf(mpl, stmt->u.prt); break;\n         case A_FOR:\n            clean_for(mpl, stmt->u.fur); break;\n         default:\n            xassert(stmt != stmt);\n      }\n      return;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mpl4.c": {
    "alloc_content": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void alloc_content(MPL *mpl)\n{     STATEMENT *stmt;\n      /* walk through all model statements */\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  switch (stmt->type)\n         {  case A_SET:\n               /* model set */\n               xassert(stmt->u.set->array == NULL);\n               stmt->u.set->array = create_array(mpl, A_ELEMSET,\n                  stmt->u.set->dim);\n               break;\n            case A_PARAMETER:\n               /* model parameter */\n               xassert(stmt->u.par->array == NULL);\n               switch (stmt->u.par->type)\n               {  case A_NUMERIC:\n                  case A_INTEGER:\n                  case A_BINARY:\n                     stmt->u.par->array = create_array(mpl, A_NUMERIC,\n                        stmt->u.par->dim);\n                     break;\n                  case A_SYMBOLIC:\n                     stmt->u.par->array = create_array(mpl, A_SYMBOLIC,\n                        stmt->u.par->dim);\n                     break;\n                  default:\n                     xassert(stmt != stmt);\n               }\n               break;\n            case A_VARIABLE:\n               /* model variable */\n               xassert(stmt->u.var->array == NULL);\n               stmt->u.var->array = create_array(mpl, A_ELEMVAR,\n                  stmt->u.var->dim);\n               break;\n            case A_CONSTRAINT:\n               /* model constraint/objective */\n               xassert(stmt->u.con->array == NULL);\n               stmt->u.con->array = create_array(mpl, A_ELEMCON,\n                  stmt->u.con->dim);\n               break;\n#if 1 /* 11/II-2008 */\n            case A_TABLE:\n#endif\n            case A_SOLVE:\n            case A_CHECK:\n            case A_DISPLAY:\n            case A_PRINTF:\n            case A_FOR:\n               /* functional statements have no content array */\n               break;\n            default:\n               xassert(stmt != stmt);\n         }\n      }\n      return;\n}",
      "lines": 57,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "generate_model": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void generate_model(MPL *mpl)\n{     STATEMENT *stmt;\n      xassert(!mpl->flag_p);\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  execute_statement(mpl, stmt);\n         if (mpl->stmt->type == A_SOLVE) break;\n      }\n      mpl->stmt = stmt;\n      return;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "build_problem": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void build_problem(MPL *mpl)\n{     STATEMENT *stmt;\n      MEMBER *memb;\n      VARIABLE *v;\n      CONSTRAINT *c;\n      FORMULA *t;\n      int i, j;\n      xassert(mpl->m == 0);\n      xassert(mpl->n == 0);\n      xassert(mpl->row == NULL);\n      xassert(mpl->col == NULL);\n      /* check that all elemental variables has zero column numbers */\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  if (stmt->type == A_VARIABLE)\n         {  v = stmt->u.var;\n            for (memb = v->array->head; memb != NULL; memb = memb->next)\n               xassert(memb->value.var->j == 0);\n         }\n      }\n      /* assign row numbers to elemental constraints and objectives */\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  if (stmt->type == A_CONSTRAINT)\n         {  c = stmt->u.con;\n            for (memb = c->array->head; memb != NULL; memb = memb->next)\n            {  xassert(memb->value.con->i == 0);\n               memb->value.con->i = ++mpl->m;\n               /* walk through linear form and mark elemental variables,\n                  which are referenced at least once */\n               for (t = memb->value.con->form; t != NULL; t = t->next)\n               {  xassert(t->var != NULL);\n                  t->var->memb->value.var->j = -1;\n               }\n            }\n         }\n      }\n      /* assign column numbers to marked elemental variables */\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  if (stmt->type == A_VARIABLE)\n         {  v = stmt->u.var;\n            for (memb = v->array->head; memb != NULL; memb = memb->next)\n               if (memb->value.var->j != 0) memb->value.var->j =\n                  ++mpl->n;\n         }\n      }\n      /* build list of rows */\n      mpl->row = xcalloc(1+mpl->m, sizeof(ELEMCON *));\n      for (i = 1; i <= mpl->m; i++) mpl->row[i] = NULL;\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  if (stmt->type == A_CONSTRAINT)\n         {  c = stmt->u.con;\n            for (memb = c->array->head; memb != NULL; memb = memb->next)\n            {  i = memb->value.con->i;\n               xassert(1 <= i && i <= mpl->m);\n               xassert(mpl->row[i] == NULL);\n               mpl->row[i] = memb->value.con;\n            }\n         }\n      }\n      for (i = 1; i <= mpl->m; i++) xassert(mpl->row[i] != NULL);\n      /* build list of columns */\n      mpl->col = xcalloc(1+mpl->n, sizeof(ELEMVAR *));\n      for (j = 1; j <= mpl->n; j++) mpl->col[j] = NULL;\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n      {  if (stmt->type == A_VARIABLE)\n         {  v = stmt->u.var;\n            for (memb = v->array->head; memb != NULL; memb = memb->next)\n            {  j = memb->value.var->j;\n               if (j == 0) continue;\n               xassert(1 <= j && j <= mpl->n);\n               xassert(mpl->col[j] == NULL);\n               mpl->col[j] = memb->value.var;\n            }\n         }\n      }\n      for (j = 1; j <= mpl->n; j++) xassert(mpl->col[j] != NULL);\n      return;\n}",
      "lines": 77,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "postsolve_model": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "void postsolve_model(MPL *mpl)\n{     STATEMENT *stmt;\n      xassert(!mpl->flag_p);\n      mpl->flag_p = 1;\n      for (stmt = mpl->stmt; stmt != NULL; stmt = stmt->next)\n         execute_statement(mpl, stmt);\n      mpl->stmt = NULL;\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "clean_model": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void clean_model(MPL *mpl)\n{     STATEMENT *stmt;\n      for (stmt = mpl->model; stmt != NULL; stmt = stmt->next)\n         clean_statement(mpl, stmt);\n      /* check that all atoms have been returned to their pools */\n      if (dmp_in_use(mpl->strings) != 0)\n         error(mpl, \"internal logic error: %d string segment(s) were lo\"\n            \"st\", dmp_in_use(mpl->strings));\n      if (dmp_in_use(mpl->symbols) != 0)\n         error(mpl, \"internal logic error: %d symbol(s) were lost\",\n            dmp_in_use(mpl->symbols));\n      if (dmp_in_use(mpl->tuples) != 0)\n         error(mpl, \"internal logic error: %d n-tuple component(s) were\"\n            \" lost\", dmp_in_use(mpl->tuples));\n      if (dmp_in_use(mpl->arrays) != 0)\n         error(mpl, \"internal logic error: %d array(s) were lost\",\n            dmp_in_use(mpl->arrays));\n      if (dmp_in_use(mpl->members) != 0)\n         error(mpl, \"internal logic error: %d array member(s) were lost\"\n            , dmp_in_use(mpl->members));\n      if (dmp_in_use(mpl->elemvars) != 0)\n         error(mpl, \"internal logic error: %d elemental variable(s) wer\"\n            \"e lost\", dmp_in_use(mpl->elemvars));\n      if (dmp_in_use(mpl->formulae) != 0)\n         error(mpl, \"internal logic error: %d linear term(s) were lost\",\n            dmp_in_use(mpl->formulae));\n      if (dmp_in_use(mpl->elemcons) != 0)\n         error(mpl, \"internal logic error: %d elemental constraint(s) w\"\n            \"ere lost\", dmp_in_use(mpl->elemcons));\n      return;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "open_input": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void open_input(MPL *mpl, char *file)\n{     mpl->line = 0;\n      mpl->c = '\\n';\n      mpl->token = 0;\n      mpl->imlen = 0;\n      mpl->image[0] = '\\0';\n      mpl->value = 0.0;\n      mpl->b_token = T_EOF;\n      mpl->b_imlen = 0;\n      mpl->b_image[0] = '\\0';\n      mpl->b_value = 0.0;\n      mpl->f_dots = 0;\n      mpl->f_scan = 0;\n      mpl->f_token = 0;\n      mpl->f_imlen = 0;\n      mpl->f_image[0] = '\\0';\n      mpl->f_value = 0.0;\n      memset(mpl->context, ' ', CONTEXT_SIZE);\n      mpl->c_ptr = 0;\n      xassert(mpl->in_fp == NULL);\n      mpl->in_fp = glp_open(file, \"r\");\n      if (mpl->in_fp == NULL)\n         error(mpl, \"unable to open %s - %s\", file, get_err_msg());\n      mpl->in_file = file;\n      /* scan the very first character */\n      get_char(mpl);\n      /* scan the very first token */\n      get_token(mpl);\n      return;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "read_char": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "int read_char(MPL *mpl)\n{     int c;\n      xassert(mpl->in_fp != NULL);\n      c = glp_getc(mpl->in_fp);\n      if (c < 0)\n      {  if (glp_ioerr(mpl->in_fp))\n            error(mpl, \"read error on %s - %s\", mpl->in_file,\n               get_err_msg());\n         c = EOF;\n      }\n      return c;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "close_input": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "void close_input(MPL *mpl)\n{     xassert(mpl->in_fp != NULL);\n      glp_close(mpl->in_fp);\n      mpl->in_fp = NULL;\n      mpl->in_file = NULL;\n      return;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "open_output": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void open_output(MPL *mpl, char *file)\n{     xassert(mpl->out_fp == NULL);\n      if (file == NULL)\n      {  file = \"<stdout>\";\n         mpl->out_fp = (void *)stdout;\n      }\n      else\n      {  mpl->out_fp = glp_open(file, \"w\");\n         if (mpl->out_fp == NULL)\n            error(mpl, \"unable to create %s - %s\", file, get_err_msg());\n      }\n      mpl->out_file = xmalloc(strlen(file)+1);\n      strcpy(mpl->out_file, file);\n      return;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "write_char": {
      "start_point": [
        361,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void write_char(MPL *mpl, int c)\n{     xassert(mpl->out_fp != NULL);\n      if (mpl->out_fp == (void *)stdout)\n         xprintf(\"%c\", c);\n      else\n         xfprintf(mpl->out_fp, \"%c\", c);\n      return;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_text": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "void write_text(MPL *mpl, char *fmt, ...)\n{     va_list arg;\n      char buf[OUTBUF_SIZE], *c;\n      va_start(arg, fmt);\n      vsprintf(buf, fmt, arg);\n      xassert(strlen(buf) < sizeof(buf));\n      va_end(arg);\n      for (c = buf; *c != '\\0'; c++) write_char(mpl, *c);\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "flush_output": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "void flush_output(MPL *mpl)\n{     xassert(mpl->out_fp != NULL);\n      if (mpl->out_fp != (void *)stdout)\n      {\n#if 0 /* FIXME */\n         xfflush(mpl->out_fp);\n#endif\n         if (glp_ioerr(mpl->out_fp))\n            error(mpl, \"write error on %s - %s\", mpl->out_file,\n               get_err_msg());\n      }\n      return;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "void error(MPL *mpl, char *fmt, ...)\n{     va_list arg;\n      char msg[4095+1];\n      va_start(arg, fmt);\n      vsprintf(msg, fmt, arg);\n      xassert(strlen(msg) < sizeof(msg));\n      va_end(arg);\n      switch (mpl->phase)\n      {  case 1:\n         case 2:\n            /* translation phase */\n            xprintf(\"%s:%d: %s\\n\",\n               mpl->in_file == NULL ? \"(unknown)\" : mpl->in_file,\n               mpl->line, msg);\n            print_context(mpl);\n            break;\n         case 3:\n            /* generation/postsolve phase */\n            xprintf(\"%s:%d: %s\\n\",\n               mpl->mod_file == NULL ? \"(unknown)\" : mpl->mod_file,\n               mpl->stmt == NULL ? 0 : mpl->stmt->line, msg);\n            break;\n         default:\n            xassert(mpl != mpl);\n      }\n      mpl->phase = 4;\n      longjmp(mpl->jump, 1);\n      /* no return */\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "warning": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "void warning(MPL *mpl, char *fmt, ...)\n{     va_list arg;\n      char msg[4095+1];\n      va_start(arg, fmt);\n      vsprintf(msg, fmt, arg);\n      xassert(strlen(msg) < sizeof(msg));\n      va_end(arg);\n      switch (mpl->phase)\n      {  case 1:\n         case 2:\n            /* translation phase */\n            xprintf(\"%s:%d: warning: %s\\n\",\n               mpl->in_file == NULL ? \"(unknown)\" : mpl->in_file,\n               mpl->line, msg);\n            break;\n         case 3:\n            /* generation/postsolve phase */\n            xprintf(\"%s:%d: warning: %s\\n\",\n               mpl->mod_file == NULL ? \"(unknown)\" : mpl->mod_file,\n               mpl->stmt == NULL ? 0 : mpl->stmt->line, msg);\n            break;\n         default:\n            xassert(mpl != mpl);\n      }\n      return;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpl_initialize": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "MPL *mpl_initialize(void)\n{     MPL *mpl;\n      mpl = xmalloc(sizeof(MPL));\n      /* scanning segment */\n      mpl->line = 0;\n      mpl->c = 0;\n      mpl->token = 0;\n      mpl->imlen = 0;\n      mpl->image = xcalloc(MAX_LENGTH+1, sizeof(char));\n      mpl->image[0] = '\\0';\n      mpl->value = 0.0;\n      mpl->b_token = 0;\n      mpl->b_imlen = 0;\n      mpl->b_image = xcalloc(MAX_LENGTH+1, sizeof(char));\n      mpl->b_image[0] = '\\0';\n      mpl->b_value = 0.0;\n      mpl->f_dots = 0;\n      mpl->f_scan = 0;\n      mpl->f_token = 0;\n      mpl->f_imlen = 0;\n      mpl->f_image = xcalloc(MAX_LENGTH+1, sizeof(char));\n      mpl->f_image[0] = '\\0';\n      mpl->f_value = 0.0;\n      mpl->context = xcalloc(CONTEXT_SIZE, sizeof(char));\n      memset(mpl->context, ' ', CONTEXT_SIZE);\n      mpl->c_ptr = 0;\n      mpl->flag_d = 0;\n      /* translating segment */\n      mpl->pool = dmp_create_poolx(0);\n      mpl->tree = avl_create_tree(avl_strcmp, NULL);\n      mpl->model = NULL;\n      mpl->flag_x = 0;\n      mpl->as_within = 0;\n      mpl->as_in = 0;\n      mpl->as_binary = 0;\n      mpl->flag_s = 0;\n      /* common segment */\n      mpl->strings = dmp_create_poolx(sizeof(STRING));\n      mpl->symbols = dmp_create_poolx(sizeof(SYMBOL));\n      mpl->tuples = dmp_create_poolx(sizeof(TUPLE));\n      mpl->arrays = dmp_create_poolx(sizeof(ARRAY));\n      mpl->members = dmp_create_poolx(sizeof(MEMBER));\n      mpl->elemvars = dmp_create_poolx(sizeof(ELEMVAR));\n      mpl->formulae = dmp_create_poolx(sizeof(FORMULA));\n      mpl->elemcons = dmp_create_poolx(sizeof(ELEMCON));\n      mpl->a_list = NULL;\n      mpl->sym_buf = xcalloc(255+1, sizeof(char));\n      mpl->sym_buf[0] = '\\0';\n      mpl->tup_buf = xcalloc(255+1, sizeof(char));\n      mpl->tup_buf[0] = '\\0';\n      /* generating/postsolving segment */\n      mpl->rand = rng_create_rand();\n      mpl->flag_p = 0;\n      mpl->stmt = NULL;\n#if 1 /* 11/II-2008 */\n      mpl->dca = NULL;\n#endif\n      mpl->m = 0;\n      mpl->n = 0;\n      mpl->row = NULL;\n      mpl->col = NULL;\n      /* input/output segment */\n      mpl->in_fp = NULL;\n      mpl->in_file = NULL;\n      mpl->out_fp = NULL;\n      mpl->out_file = NULL;\n      mpl->prt_fp = NULL;\n      mpl->prt_file = NULL;\n      /* solver interface segment */\n      if (setjmp(mpl->jump)) xassert(mpl != mpl);\n      mpl->phase = 0;\n      mpl->mod_file = NULL;\n      mpl->mpl_buf = xcalloc(255+1, sizeof(char));\n      mpl->mpl_buf[0] = '\\0';\n      return mpl;\n}",
      "lines": 76,
      "depth": 9,
      "decorators": [
        "MPL",
        "*mpl_initialize(void)",
        "*"
      ]
    },
    "mpl_read_model": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        653,
        1
      ],
      "content": "int mpl_read_model(MPL *mpl, char *file, int skip_data)\n{     if (mpl->phase != 0)\n         xfault(\"mpl_read_model: invalid call sequence\\n\");\n      if (file == NULL)\n         xfault(\"mpl_read_model: no input filename specified\\n\");\n      /* set up error handler */\n      if (setjmp(mpl->jump)) goto done;\n      /* translate model section */\n      mpl->phase = 1;\n      xprintf(\"Reading model section from %s...\\n\", file);\n      open_input(mpl, file);\n      model_section(mpl);\n      if (mpl->model == NULL)\n         error(mpl, \"empty model section not allowed\");\n      /* save name of the input text file containing model section for\n         error diagnostics during the generation phase */\n      mpl->mod_file = xcalloc(strlen(file)+1, sizeof(char));\n      strcpy(mpl->mod_file, mpl->in_file);\n      /* allocate content arrays for all model objects */\n      alloc_content(mpl);\n      /* optional data section may begin with the keyword 'data' */\n      if (is_keyword(mpl, \"data\"))\n      {  if (skip_data)\n         {  warning(mpl, \"data section ignored\");\n            goto skip;\n         }\n         mpl->flag_d = 1;\n         get_token(mpl /* data */);\n         if (mpl->token != T_SEMICOLON)\n            error(mpl, \"semicolon missing where expected\");\n         get_token(mpl /* ; */);\n         /* translate data section */\n         mpl->phase = 2;\n         xprintf(\"Reading data section from %s...\\n\", file);\n         data_section(mpl);\n      }\n      /* process end statement */\n      end_statement(mpl);\nskip: xprintf(\"%d line%s were read\\n\",\n         mpl->line, mpl->line == 1 ? \"\" : \"s\");\n      close_input(mpl);\ndone: /* return to the calling program */\n      return mpl->phase;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpl_generate": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "int mpl_generate(MPL *mpl, char *file)\n{     if (!(mpl->phase == 1 || mpl->phase == 2))\n         xfault(\"mpl_generate: invalid call sequence\\n\");\n      /* set up error handler */\n      if (setjmp(mpl->jump)) goto done;\n      /* generate model */\n      mpl->phase = 3;\n      open_output(mpl, file);\n      generate_model(mpl);\n      flush_output(mpl);\n      /* build problem instance */\n      build_problem(mpl);\n      /* generation phase has been finished */\n      xprintf(\"Model has been successfully generated\\n\");\ndone: /* return to the calling program */\n      return mpl->phase;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_prob_name": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "char *mpl_get_prob_name(MPL *mpl)\n{     char *name = mpl->mpl_buf;\n      char *file = mpl->mod_file;\n      int k;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_prob_name: invalid call sequence\\n\");\n      for (;;)\n      {  if (strchr(file, '/') != NULL)\n            file = strchr(file, '/') + 1;\n         else if (strchr(file, '\\\\') != NULL)\n            file = strchr(file, '\\\\') + 1;\n         else if (strchr(file, ':') != NULL)\n            file = strchr(file, ':') + 1;\n         else\n            break;\n      }\n      for (k = 0; ; k++)\n      {  if (k == 255) break;\n         if (!(isalnum((unsigned char)*file) || *file == '_')) break;\n         name[k] = *file++;\n      }\n      if (k == 0)\n         strcpy(name, \"Unknown\");\n      else\n         name[k] = '\\0';\n      xassert(strlen(name) <= 255);\n      return name;\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "char",
        "*mpl_get_prob_name(MPL *mpl)",
        "*"
      ]
    },
    "mpl_get_num_rows": {
      "start_point": [
        829,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "int mpl_get_num_rows(MPL *mpl)\n{     if (mpl->phase != 3)\n         xfault(\"mpl_get_num_rows: invalid call sequence\\n\");\n      return mpl->m;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_num_cols": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "int mpl_get_num_cols(MPL *mpl)\n{     if (mpl->phase != 3)\n         xfault(\"mpl_get_num_cols: invalid call sequence\\n\");\n      return mpl->n;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_row_name": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "char *mpl_get_row_name(MPL *mpl, int i)\n{     char *name = mpl->mpl_buf, *t;\n      int len;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_row_name: invalid call sequence\\n\");\n      if (!(1 <= i && i <= mpl->m))\n         xfault(\"mpl_get_row_name: i = %d; row number out of range\\n\",\n            i);\n      strcpy(name, mpl->row[i]->con->name);\n      len = strlen(name);\n      xassert(len <= 255);\n      t = format_tuple(mpl, '[', mpl->row[i]->memb->tuple);\n      while (*t)\n      {  if (len == 255) break;\n         name[len++] = *t++;\n      }\n      name[len] = '\\0';\n      if (len == 255) strcpy(name+252, \"...\");\n      xassert(strlen(name) <= 255);\n      return name;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "char",
        "*mpl_get_row_name(MPL *mpl, int i)",
        "*"
      ]
    },
    "mpl_get_row_kind": {
      "start_point": [
        906,
        0
      ],
      "end_point": [
        924,
        1
      ],
      "content": "int mpl_get_row_kind(MPL *mpl, int i)\n{     int kind;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_row_kind: invalid call sequence\\n\");\n      if (!(1 <= i && i <= mpl->m))\n         xfault(\"mpl_get_row_kind: i = %d; row number out of range\\n\",\n            i);\n      switch (mpl->row[i]->con->type)\n      {  case A_CONSTRAINT:\n            kind = MPL_ST; break;\n         case A_MINIMIZE:\n            kind = MPL_MIN; break;\n         case A_MAXIMIZE:\n            kind = MPL_MAX; break;\n         default:\n            xassert(mpl != mpl);\n      }\n      return kind;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_row_bnds": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int mpl_get_row_bnds(MPL *mpl, int i, double *_lb, double *_ub)\n{     ELEMCON *con;\n      int type;\n      double lb, ub;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_row_bnds: invalid call sequence\\n\");\n      if (!(1 <= i && i <= mpl->m))\n         xfault(\"mpl_get_row_bnds: i = %d; row number out of range\\n\",\n            i);\n      con = mpl->row[i];\n#if 0 /* 21/VII-2006 */\n      if (con->con->lbnd == NULL && con->con->ubnd == NULL)\n         type = MPL_FR, lb = ub = 0.0;\n      else if (con->con->ubnd == NULL)\n         type = MPL_LO, lb = con->lbnd, ub = 0.0;\n      else if (con->con->lbnd == NULL)\n         type = MPL_UP, lb = 0.0, ub = con->ubnd;\n      else if (con->con->lbnd != con->con->ubnd)\n         type = MPL_DB, lb = con->lbnd, ub = con->ubnd;\n      else\n         type = MPL_FX, lb = ub = con->lbnd;\n#else\n      lb = (con->con->lbnd == NULL ? -DBL_MAX : con->lbnd);\n      ub = (con->con->ubnd == NULL ? +DBL_MAX : con->ubnd);\n      if (lb == -DBL_MAX && ub == +DBL_MAX)\n         type = MPL_FR, lb = ub = 0.0;\n      else if (ub == +DBL_MAX)\n         type = MPL_LO, ub = 0.0;\n      else if (lb == -DBL_MAX)\n         type = MPL_UP, lb = 0.0;\n      else if (con->con->lbnd != con->con->ubnd)\n         type = MPL_DB;\n      else\n         type = MPL_FX;\n#endif\n      if (_lb != NULL) *_lb = lb;\n      if (_ub != NULL) *_ub = ub;\n      return type;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_mat_row": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1050,
        1
      ],
      "content": "int mpl_get_mat_row(MPL *mpl, int i, int ndx[], double val[])\n{     FORMULA *term;\n      int len = 0;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_mat_row: invalid call sequence\\n\");\n      if (!(1 <= i && i <= mpl->m))\n         xfault(\"mpl_get_mat_row: i = %d; row number out of range\\n\",\n            i);\n      for (term = mpl->row[i]->form; term != NULL; term = term->next)\n      {  xassert(term->var != NULL);\n         len++;\n         xassert(len <= mpl->n);\n         if (ndx != NULL) ndx[len] = term->var->j;\n         if (val != NULL) val[len] = term->coef;\n      }\n      return len;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_row_c0": {
      "start_point": [
        1068,
        0
      ],
      "end_point": [
        1082,
        1
      ],
      "content": "double mpl_get_row_c0(MPL *mpl, int i)\n{     ELEMCON *con;\n      double c0;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_row_c0: invalid call sequence\\n\");\n      if (!(1 <= i && i <= mpl->m))\n         xfault(\"mpl_get_row_c0: i = %d; row number out of range\\n\",\n            i);\n      con = mpl->row[i];\n      if (con->con->lbnd == NULL && con->con->ubnd == NULL)\n         c0 = - con->lbnd;\n      else\n         c0 = 0.0;\n      return c0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "mpl_get_col_name": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1117,
        1
      ],
      "content": "char *mpl_get_col_name(MPL *mpl, int j)\n{     char *name = mpl->mpl_buf, *t;\n      int len;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_col_name: invalid call sequence\\n\");\n      if (!(1 <= j && j <= mpl->n))\n         xfault(\"mpl_get_col_name: j = %d; column number out of range\\n\"\n            , j);\n      strcpy(name, mpl->col[j]->var->name);\n      len = strlen(name);\n      xassert(len <= 255);\n      t = format_tuple(mpl, '[', mpl->col[j]->memb->tuple);\n      while (*t)\n      {  if (len == 255) break;\n         name[len++] = *t++;\n      }\n      name[len] = '\\0';\n      if (len == 255) strcpy(name+252, \"...\");\n      xassert(strlen(name) <= 255);\n      return name;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "char",
        "*mpl_get_col_name(MPL *mpl, int j)",
        "*"
      ]
    },
    "mpl_get_col_kind": {
      "start_point": [
        1142,
        0
      ],
      "end_point": [
        1160,
        1
      ],
      "content": "int mpl_get_col_kind(MPL *mpl, int j)\n{     int kind;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_col_kind: invalid call sequence\\n\");\n      if (!(1 <= j && j <= mpl->n))\n         xfault(\"mpl_get_col_kind: j = %d; column number out of range\\n\"\n            , j);\n      switch (mpl->col[j]->var->type)\n      {  case A_NUMERIC:\n            kind = MPL_NUM; break;\n         case A_INTEGER:\n            kind = MPL_INT; break;\n         case A_BINARY:\n            kind = MPL_BIN; break;\n         default:\n            xassert(mpl != mpl);\n      }\n      return kind;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpl_get_col_bnds": {
      "start_point": [
        1201,
        0
      ],
      "end_point": [
        1239,
        1
      ],
      "content": "int mpl_get_col_bnds(MPL *mpl, int j, double *_lb, double *_ub)\n{     ELEMVAR *var;\n      int type;\n      double lb, ub;\n      if (mpl->phase != 3)\n         xfault(\"mpl_get_col_bnds: invalid call sequence\\n\");\n      if (!(1 <= j && j <= mpl->n))\n         xfault(\"mpl_get_col_bnds: j = %d; column number out of range\\n\"\n            , j);\n      var = mpl->col[j];\n#if 0 /* 21/VII-2006 */\n      if (var->var->lbnd == NULL && var->var->ubnd == NULL)\n         type = MPL_FR, lb = ub = 0.0;\n      else if (var->var->ubnd == NULL)\n         type = MPL_LO, lb = var->lbnd, ub = 0.0;\n      else if (var->var->lbnd == NULL)\n         type = MPL_UP, lb = 0.0, ub = var->ubnd;\n      else if (var->var->lbnd != var->var->ubnd)\n         type = MPL_DB, lb = var->lbnd, ub = var->ubnd;\n      else\n         type = MPL_FX, lb = ub = var->lbnd;\n#else\n      lb = (var->var->lbnd == NULL ? -DBL_MAX : var->lbnd);\n      ub = (var->var->ubnd == NULL ? +DBL_MAX : var->ubnd);\n      if (lb == -DBL_MAX && ub == +DBL_MAX)\n         type = MPL_FR, lb = ub = 0.0;\n      else if (ub == +DBL_MAX)\n         type = MPL_LO, ub = 0.0;\n      else if (lb == -DBL_MAX)\n         type = MPL_UP, lb = 0.0;\n      else if (var->var->lbnd != var->var->ubnd)\n         type = MPL_DB;\n      else\n         type = MPL_FX;\n#endif\n      if (_lb != NULL) *_lb = lb;\n      if (_ub != NULL) *_ub = ub;\n      return type;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpl_has_solve_stmt": {
      "start_point": [
        1254,
        0
      ],
      "end_point": [
        1258,
        1
      ],
      "content": "int mpl_has_solve_stmt(MPL *mpl)\n{     if (mpl->phase != 3)\n         xfault(\"mpl_has_solve_stmt: invalid call sequence\\n\");\n      return mpl->flag_s;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpl_put_row_soln": {
      "start_point": [
        1261,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "void mpl_put_row_soln(MPL *mpl, int i, int stat, double prim,\n      double dual)\n{     /* store row (constraint/objective) solution components */\n      xassert(mpl->phase == 3);\n      xassert(1 <= i && i <= mpl->m);\n      mpl->row[i]->stat = stat;\n      mpl->row[i]->prim = prim;\n      mpl->row[i]->dual = dual;\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpl_put_col_soln": {
      "start_point": [
        1274,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "void mpl_put_col_soln(MPL *mpl, int j, int stat, double prim,\n      double dual)\n{     /* store column (variable) solution components */\n      xassert(mpl->phase == 3);\n      xassert(1 <= j && j <= mpl->n);\n      mpl->col[j]->stat = stat;\n      mpl->col[j]->prim = prim;\n      mpl->col[j]->dual = dual;\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpl_put_col_value": {
      "start_point": [
        1301,
        0
      ],
      "end_point": [
        1309,
        1
      ],
      "content": "void mpl_put_col_value(MPL *mpl, int j, double val)\n{     if (mpl->phase != 3)\n         xfault(\"mpl_put_col_value: invalid call sequence\\n\");\n      if (!(1 <= j && j <= mpl->n))\n         xfault(\n         \"mpl_put_col_value: j = %d; column number out of range\\n\", j);\n      mpl->col[j]->prim = val;\n      return;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpl_postsolve": {
      "start_point": [
        1338,
        0
      ],
      "end_point": [
        1350,
        1
      ],
      "content": "int mpl_postsolve(MPL *mpl)\n{     if (!(mpl->phase == 3 && !mpl->flag_p))\n         xfault(\"mpl_postsolve: invalid call sequence\\n\");\n      /* set up error handler */\n      if (setjmp(mpl->jump)) goto done;\n      /* perform postsolving */\n      postsolve_model(mpl);\n      flush_output(mpl);\n      /* postsolving phase has been finished */\n      xprintf(\"Model has been successfully processed\\n\");\ndone: /* return to the calling program */\n      return mpl->phase;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpl_terminate": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1423,
        1
      ],
      "content": "void mpl_terminate(MPL *mpl)\n{     if (setjmp(mpl->jump)) xassert(mpl != mpl);\n      switch (mpl->phase)\n      {  case 0:\n         case 1:\n         case 2:\n         case 3:\n            /* there were no errors; clean the model content */\n            clean_model(mpl);\n            xassert(mpl->a_list == NULL);\n#if 1 /* 11/II-2008 */\n            xassert(mpl->dca == NULL);\n#endif\n            break;\n         case 4:\n            /* model processing has been finished due to error; delete\n               search trees, which may be created for some arrays */\n            {  ARRAY *a;\n               for (a = mpl->a_list; a != NULL; a = a->next)\n                  if (a->tree != NULL) avl_delete_tree(a->tree);\n            }\n#if 1 /* 11/II-2008 */\n            free_dca(mpl);\n#endif\n            break;\n         default:\n            xassert(mpl != mpl);\n      }\n      /* delete the translator database */\n      xfree(mpl->image);\n      xfree(mpl->b_image);\n      xfree(mpl->f_image);\n      xfree(mpl->context);\n      dmp_delete_pool(mpl->pool);\n      avl_delete_tree(mpl->tree);\n      dmp_delete_pool(mpl->strings);\n      dmp_delete_pool(mpl->symbols);\n      dmp_delete_pool(mpl->tuples);\n      dmp_delete_pool(mpl->arrays);\n      dmp_delete_pool(mpl->members);\n      dmp_delete_pool(mpl->elemvars);\n      dmp_delete_pool(mpl->formulae);\n      dmp_delete_pool(mpl->elemcons);\n      xfree(mpl->sym_buf);\n      xfree(mpl->tup_buf);\n      rng_delete_rand(mpl->rand);\n      if (mpl->row != NULL) xfree(mpl->row);\n      if (mpl->col != NULL) xfree(mpl->col);\n      if (mpl->in_fp != NULL) glp_close(mpl->in_fp);\n      if (mpl->out_fp != NULL && mpl->out_fp != (void *)stdout)\n         glp_close(mpl->out_fp);\n      if (mpl->out_file != NULL) xfree(mpl->out_file);\n      if (mpl->prt_fp != NULL) glp_close(mpl->prt_fp);\n      if (mpl->prt_file != NULL) xfree(mpl->prt_file);\n      if (mpl->mod_file != NULL) xfree(mpl->mod_file);\n      xfree(mpl->mpl_buf);\n      xfree(mpl);\n      return;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mpl5.c": {
    "fn_gmtime": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "double fn_gmtime(MPL *mpl)\n{     /* obtain the current calendar time (UTC) */\n      time_t timer;\n      struct tm *tm;\n      int j;\n      time(&timer);\n      if (timer == (time_t)(-1))\nerr:     error(mpl, \"gmtime(); unable to obtain current calendar time\");\n#if 0 /* 29/I-2017 */\n      tm = gmtime(&timer);\n#else\n      tm = xgmtime(&timer);\n#endif\n      if (tm == NULL) goto err;\n      j = jday(tm->tm_mday, tm->tm_mon + 1, 1900 + tm->tm_year);\n      if (j < 0) goto err;\n      return (((double)(j - jday(1, 1, 1970)) * 24.0 +\n         (double)tm->tm_hour) * 60.0 + (double)tm->tm_min) * 60.0 +\n         (double)tm->tm_sec;\n}",
      "lines": 20,
      "depth": 17,
      "decorators": [
        "double"
      ]
    },
    "error1": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static void error1(MPL *mpl, const char *str, const char *s,\n      const char *fmt, const char *f, const char *msg)\n{     xprintf(\"Input string passed to str2time:\\n\");\n      xprintf(\"%s\\n\", str);\n      xprintf(\"%*s\\n\", (s - str) + 1, \"^\");\n      xprintf(\"Format string passed to str2time:\\n\");\n      xprintf(\"%s\\n\", fmt);\n      xprintf(\"%*s\\n\", (f - fmt) + 1, \"^\");\n      error(mpl, \"%s\", msg);\n      /* no return */\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fn_str2time": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "double fn_str2time(MPL *mpl, const char *str, const char *fmt)\n{     /* convert character string to the calendar time */\n      int j, year, month, day, hh, mm, ss, zone;\n      const char *s, *f;\n      year = month = day = hh = mm = ss = -1, zone = INT_MAX;\n      s = str;\n      for (f = fmt; *f != '\\0'; f++)\n      {  if (*f == '%')\n         {  f++;\n            if (*f == 'b' || *f == 'h')\n            {  /* the abbreviated month name */\n               int k;\n               char *name;\n               if (month >= 0)\n                  error1(mpl, str, s, fmt, f, \"month multiply specified\"\n                     );\n               while (*s == ' ') s++;\n               for (month = 1; month <= 12; month++)\n               {  name = moon[month-1];\n                  for (k = 0; k <= 2; k++)\n                  {  if (toupper((unsigned char)s[k]) !=\n                         toupper((unsigned char)name[k])) goto next;\n                  }\n                  s += 3;\n                  for (k = 3; name[k] != '\\0'; k++)\n                  {  if (toupper((unsigned char)*s) !=\n                         toupper((unsigned char)name[k])) break;\n                     s++;\n                  }\n                  break;\nnext:             ;\n               }\n               if (month > 12)\n                  error1(mpl, str, s, fmt, f, \"abbreviated month name m\"\n                     \"issing or invalid\");\n            }\n            else if (*f == 'd')\n            {  /* the day of the month as a decimal number (01..31) */\n               if (day >= 0)\n                  error1(mpl, str, s, fmt, f, \"day multiply specified\");\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"day missing or invalid\");\n               day = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  day = 10 * day + ((*s++) - '0');\n               if (!(1 <= day && day <= 31))\n                  error1(mpl, str, s, fmt, f, \"day out of range\");\n            }\n            else if (*f == 'H')\n            {  /* the hour as a decimal number, using a 24-hour clock\n                  (00..23) */\n               if (hh >= 0)\n                  error1(mpl, str, s, fmt, f, \"hour multiply specified\")\n                     ;\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"hour missing or invalid\")\n                     ;\n               hh = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  hh = 10 * hh + ((*s++) - '0');\n               if (!(0 <= hh && hh <= 23))\n                  error1(mpl, str, s, fmt, f, \"hour out of range\");\n            }\n            else if (*f == 'm')\n            {  /* the month as a decimal number (01..12) */\n               if (month >= 0)\n                  error1(mpl, str, s, fmt, f, \"month multiply specified\"\n                     );\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"month missing or invalid\"\n                     );\n               month = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  month = 10 * month + ((*s++) - '0');\n               if (!(1 <= month && month <= 12))\n                  error1(mpl, str, s, fmt, f, \"month out of range\");\n            }\n            else if (*f == 'M')\n            {  /* the minute as a decimal number (00..59) */\n               if (mm >= 0)\n                  error1(mpl, str, s, fmt, f, \"minute multiply specifie\"\n                     \"d\");\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"minute missing or invali\"\n                     \"d\");\n               mm = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  mm = 10 * mm + ((*s++) - '0');\n               if (!(0 <= mm && mm <= 59))\n                  error1(mpl, str, s, fmt, f, \"minute out of range\");\n            }\n            else if (*f == 'S')\n            {  /* the second as a decimal number (00..60) */\n               if (ss >= 0)\n                  error1(mpl, str, s, fmt, f, \"second multiply specifie\"\n                     \"d\");\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"second missing or invali\"\n                     \"d\");\n               ss = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  ss = 10 * ss + ((*s++) - '0');\n               if (!(0 <= ss && ss <= 60))\n                  error1(mpl, str, s, fmt, f, \"second out of range\");\n            }\n            else if (*f == 'y')\n            {  /* the year without a century as a decimal number\n                  (00..99); the values 00 to 68 mean the years 2000 to\n                  2068 while the values 69 to 99 mean the years 1969 to\n                  1999 */\n               if (year >= 0)\n                  error1(mpl, str, s, fmt, f, \"year multiply specified\")\n                     ;\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"year missing or invalid\")\n                     ;\n               year = (*s++) - '0';\n               if ('0' <= *s && *s <= '9')\n                  year = 10 * year + ((*s++) - '0');\n               year += (year >= 69 ? 1900 : 2000);\n            }\n            else if (*f == 'Y')\n            {  /* the year as a decimal number, using the Gregorian\n                  calendar */\n               if (year >= 0)\n                  error1(mpl, str, s, fmt, f, \"year multiply specified\")\n                     ;\n               while (*s == ' ') s++;\n               if (!('0' <= *s && *s <= '9'))\n                  error1(mpl, str, s, fmt, f, \"year missing or invalid\")\n                     ;\n               year = 0;\n               for (j = 1; j <= 4; j++)\n               {  if (!('0' <= *s && *s <= '9')) break;\n                  year = 10 * year + ((*s++) - '0');\n               }\n               if (!(1 <= year && year <= 4000))\n                  error1(mpl, str, s, fmt, f, \"year out of range\");\n            }\n            else if (*f == 'z')\n            {  /* time zone offset in the form zhhmm */\n               int z, hh, mm;\n               if (zone != INT_MAX)\n                  error1(mpl, str, s, fmt, f, \"time zone offset multipl\"\n                     \"y specified\");\n               while (*s == ' ') s++;\n               if (*s == 'Z')\n               {  z = hh = mm = 0, s++;\n                  goto skip;\n               }\n               if (*s == '+')\n                  z = +1, s++;\n               else if (*s == '-')\n                  z = -1, s++;\n               else\n                  error1(mpl, str, s, fmt, f, \"time zone offset sign mi\"\n                     \"ssing\");\n               hh = 0;\n               for (j = 1; j <= 2; j++)\n               {  if (!('0' <= *s && *s <= '9'))\nerr1:                error1(mpl, str, s, fmt, f, \"time zone offset valu\"\n                        \"e incomplete or invalid\");\n                  hh = 10 * hh + ((*s++) - '0');\n               }\n               if (hh > 23)\nerr2:             error1(mpl, str, s, fmt, f, \"time zone offset value o\"\n                     \"ut of range\");\n               if (*s == ':')\n               {  s++;\n                  if (!('0' <= *s && *s <= '9')) goto err1;\n               }\n               mm = 0;\n               if (!('0' <= *s && *s <= '9')) goto skip;\n               for (j = 1; j <= 2; j++)\n               {  if (!('0' <= *s && *s <= '9')) goto err1;\n                  mm = 10 * mm + ((*s++) - '0');\n               }\n               if (mm > 59) goto err2;\nskip:          zone = z * (60 * hh + mm);\n            }\n            else if (*f == '%')\n            {  /* literal % character */\n               goto test;\n            }\n            else\n               error1(mpl, str, s, fmt, f, \"invalid conversion specifie\"\n                  \"r\");\n         }\n         else if (*f == ' ')\n            ;\n         else\ntest:    {  /* check a matching character in the input string */\n            if (*s != *f)\n               error1(mpl, str, s, fmt, f, \"character mismatch\");\n            s++;\n         }\n      }\n      if (year < 0) year = 1970;\n      if (month < 0) month = 1;\n      if (day < 0) day = 1;\n      if (hh < 0) hh = 0;\n      if (mm < 0) mm = 0;\n      if (ss < 0) ss = 0;\n      if (zone == INT_MAX) zone = 0;\n      j = jday(day, month, year);\n      xassert(j >= 0);\n      return (((double)(j - jday(1, 1, 1970)) * 24.0 + (double)hh) *\n         60.0 + (double)mm) * 60.0 + (double)ss - 60.0 * (double)zone;\n}",
      "lines": 215,
      "depth": 27,
      "decorators": [
        "double"
      ]
    },
    "error2": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void error2(MPL *mpl, const char *fmt, const char *f,\n      const char *msg)\n{     xprintf(\"Format string passed to time2str:\\n\");\n      xprintf(\"%s\\n\", fmt);\n      xprintf(\"%*s\\n\", (f - fmt) + 1, \"^\");\n      error(mpl, \"%s\", msg);\n      /* no return */\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "weekday": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static int weekday(int j)\n{     /* determine weekday number (1 = Mon, ..., 7 = Sun) */\n      return (j + jday(1, 1, 1970)) % 7 + 1;\n}",
      "lines": 4,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "firstday": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static int firstday(int year)\n{     /* determine the first day of the first week for a specified year\n         according to ISO 8601 */\n      int j;\n      /* if 1 January is Monday, Tuesday, Wednesday or Thursday, it is\n         in week 01; if 1 January is Friday, Saturday or Sunday, it is\n         in week 52 or 53 of the previous year */\n      j = jday(1, 1, year) - jday(1, 1, 1970);\n      switch (weekday(j))\n      {  case 1: /* 1 Jan is Mon */ j += 0; break;\n         case 2: /* 1 Jan is Tue */ j -= 1; break;\n         case 3: /* 1 Jan is Wed */ j -= 2; break;\n         case 4: /* 1 Jan is Thu */ j -= 3; break;\n         case 5: /* 1 Jan is Fri */ j += 3; break;\n         case 6: /* 1 Jan is Sat */ j += 2; break;\n         case 7: /* 1 Jan is Sun */ j += 1; break;\n         default: xassert(j != j);\n      }\n      /* the first day of the week must be Monday */\n      xassert(weekday(j) == 1);\n      return j;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fn_time2str": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "void fn_time2str(MPL *mpl, char *str, double t, const char *fmt)\n{     /* convert the calendar time to character string */\n      int j, year, month, day, hh, mm, ss, len;\n      double temp;\n      const char *f;\n      char buf[MAX_LENGTH+1];\n      if (!(-62135596800.0 <= t && t <= 64092211199.0))\n         error(mpl, \"time2str(%.*g,...); argument out of range\",\n            DBL_DIG, t);\n      t = floor(t + 0.5);\n      temp = fabs(t) / 86400.0;\n      j = (int)floor(temp);\n      if (t < 0.0)\n      {  if (temp == floor(temp))\n            j = - j;\n         else\n            j = - (j + 1);\n      }\n      xassert(jdate(j + jday(1, 1, 1970), &day, &month, &year) == 0);\n      ss = (int)(t - 86400.0 * (double)j);\n      xassert(0 <= ss && ss < 86400);\n      mm = ss / 60, ss %= 60;\n      hh = mm / 60, mm %= 60;\n      len = 0;\n      for (f = fmt; *f != '\\0'; f++)\n      {  if (*f == '%')\n         {  f++;\n            if (*f == 'a')\n            {  /* the abbreviated weekday name */\n               memcpy(buf, week[weekday(j)-1], 3), buf[3] = '\\0';\n            }\n            else if (*f == 'A')\n            {  /* the full weekday name */\n               strcpy(buf, week[weekday(j)-1]);\n            }\n            else if (*f == 'b' || *f == 'h')\n            {  /* the abbreviated month name */\n               memcpy(buf, moon[month-1], 3), buf[3] = '\\0';\n            }\n            else if (*f == 'B')\n            {  /* the full month name */\n               strcpy(buf, moon[month-1]);\n            }\n            else if (*f == 'C')\n            {  /* the century of the year */\n               sprintf(buf, \"%02d\", year / 100);\n            }\n            else if (*f == 'd')\n            {  /* the day of the month as a decimal number (01..31) */\n               sprintf(buf, \"%02d\", day);\n            }\n            else if (*f == 'D')\n            {  /* the date using the format %m/%d/%y */\n               sprintf(buf, \"%02d/%02d/%02d\", month, day, year % 100);\n            }\n            else if (*f == 'e')\n            {  /* the day of the month like with %d, but padded with\n                  blank (1..31) */\n               sprintf(buf, \"%2d\", day);\n            }\n            else if (*f == 'F')\n            {  /* the date using the format %Y-%m-%d */\n               sprintf(buf, \"%04d-%02d-%02d\", year, month, day);\n            }\n            else if (*f == 'g')\n            {  /* the year corresponding to the ISO week number, but\n                  without the century (range 00 through 99); this has\n                  the same format and value as %y, except that if the\n                  ISO week number (see %V) belongs to the previous or\n                  next year, that year is used instead */\n               int iso;\n               if (j < firstday(year))\n                  iso = year - 1;\n               else if (j < firstday(year + 1))\n                  iso = year;\n               else\n                  iso = year + 1;\n               sprintf(buf, \"%02d\", iso % 100);\n            }\n            else if (*f == 'G')\n            {  /* the year corresponding to the ISO week number; this\n                  has the same format and value as %Y, excepth that if\n                  the ISO week number (see %V) belongs to the previous\n                  or next year, that year is used instead */\n               int iso;\n               if (j < firstday(year))\n                  iso = year - 1;\n               else if (j < firstday(year + 1))\n                  iso = year;\n               else\n                  iso = year + 1;\n               sprintf(buf, \"%04d\", iso);\n            }\n            else if (*f == 'H')\n            {  /* the hour as a decimal number, using a 24-hour clock\n                  (00..23) */\n               sprintf(buf, \"%02d\", hh);\n            }\n            else if (*f == 'I')\n            {  /* the hour as a decimal number, using a 12-hour clock\n                  (01..12) */\n               sprintf(buf, \"%02d\",\n                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\n            }\n            else if (*f == 'j')\n            {  /* the day of the year as a decimal number (001..366) */\n               sprintf(buf, \"%03d\",\n                  jday(day, month, year) - jday(1, 1, year) + 1);\n            }\n            else if (*f == 'k')\n            {  /* the hour as a decimal number, using a 24-hour clock\n                  like %H, but padded with blank (0..23) */\n               sprintf(buf, \"%2d\", hh);\n            }\n            else if (*f == 'l')\n            {  /* the hour as a decimal number, using a 12-hour clock\n                  like %I, but padded with blank (1..12) */\n               sprintf(buf, \"%2d\",\n                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\n            }\n            else if (*f == 'm')\n            {  /* the month as a decimal number (01..12) */\n               sprintf(buf, \"%02d\", month);\n            }\n            else if (*f == 'M')\n            {  /* the minute as a decimal number (00..59) */\n               sprintf(buf, \"%02d\", mm);\n            }\n            else if (*f == 'p')\n            {  /* either AM or PM, according to the given time value;\n                  noon is treated as PM and midnight as AM */\n               strcpy(buf, hh <= 11 ? \"AM\" : \"PM\");\n            }\n            else if (*f == 'P')\n            {  /* either am or pm, according to the given time value;\n                  noon is treated as pm and midnight as am */\n               strcpy(buf, hh <= 11 ? \"am\" : \"pm\");\n            }\n            else if (*f == 'r')\n            {  /* the calendar time using the format %I:%M:%S %p */\n               sprintf(buf, \"%02d:%02d:%02d %s\",\n                  hh == 0 ? 12 : hh <= 12 ? hh : hh - 12,\n                  mm, ss, hh <= 11 ? \"AM\" : \"PM\");\n            }\n            else if (*f == 'R')\n            {  /* the hour and minute using the format %H:%M */\n               sprintf(buf, \"%02d:%02d\", hh, mm);\n            }\n            else if (*f == 'S')\n            {  /* the second as a decimal number (00..59) */\n               sprintf(buf, \"%02d\", ss);\n            }\n            else if (*f == 'T')\n            {  /* the time of day using the format %H:%M:%S */\n               sprintf(buf, \"%02d:%02d:%02d\", hh, mm, ss);\n            }\n            else if (*f == 'u')\n            {  /* the day of the week as a decimal number (1..7),\n                  Monday being 1 */\n               sprintf(buf, \"%d\", weekday(j));\n            }\n            else if (*f == 'U')\n            {  /* the week number of the current year as a decimal\n                  number (range 00 through 53), starting with the first\n                  Sunday as the first day of the first week; days\n                  preceding the first Sunday in the year are considered\n                  to be in week 00 */\n#if 1 /* 09/I-2009 */\n#undef sun\n/* causes compilation error in SunOS */\n#endif\n               int sun;\n               /* sun = the first Sunday of the year */\n               sun = jday(1, 1, year) - jday(1, 1, 1970);\n               sun += (7 - weekday(sun));\n               sprintf(buf, \"%02d\", (j + 7 - sun) / 7);\n            }\n            else if (*f == 'V')\n            {  /* the ISO week number as a decimal number (range 01\n                  through 53); ISO weeks start with Monday and end with\n                  Sunday; week 01 of a year is the first week which has\n                  the majority of its days in that year; week 01 of\n                  a year can contain days from the previous year; the\n                  week before week 01 of a year is the last week (52 or\n                  53) of the previous year even if it contains days\n                  from the new year */\n               int iso;\n               if (j < firstday(year))\n                  iso = j - firstday(year - 1);\n               else if (j < firstday(year + 1))\n                  iso = j - firstday(year);\n               else\n                  iso = j - firstday(year + 1);\n               sprintf(buf, \"%02d\", iso / 7 + 1);\n            }\n            else if (*f == 'w')\n            {  /* the day of the week as a decimal number (0..6),\n                  Sunday being 0 */\n               sprintf(buf, \"%d\", weekday(j) % 7);\n            }\n            else if (*f == 'W')\n            {  /* the week number of the current year as a decimal\n                  number (range 00 through 53), starting with the first\n                  Monday as the first day of the first week; days\n                  preceding the first Monday in the year are considered\n                  to be in week 00 */\n               int mon;\n               /* mon = the first Monday of the year */\n               mon = jday(1, 1, year) - jday(1, 1, 1970);\n               mon += (8 - weekday(mon)) % 7;\n               sprintf(buf, \"%02d\", (j + 7 - mon) / 7);\n            }\n            else if (*f == 'y')\n            {  /* the year without a century as a decimal number\n                  (00..99) */\n               sprintf(buf, \"%02d\", year % 100);\n            }\n            else if (*f == 'Y')\n            {  /* the year as a decimal number, using the Gregorian\n                  calendar */\n               sprintf(buf, \"%04d\", year);\n            }\n            else if (*f == '%')\n            {  /* a literal % character */\n               buf[0] = '%', buf[1] = '\\0';\n            }\n            else\n               error2(mpl, fmt, f, \"invalid conversion specifier\");\n         }\n         else\n            buf[0] = *f, buf[1] = '\\0';\n         if (len + strlen(buf) > MAX_LENGTH)\n            error(mpl, \"time2str; output string length exceeds %d chara\"\n               \"cters\", MAX_LENGTH);\n         memcpy(str+len, buf, strlen(buf));\n         len += strlen(buf);\n      }\n      str[len] = '\\0';\n      return;\n}",
      "lines": 240,
      "depth": 44,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mpl6.c": {
    "read_char": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void read_char(struct csv *csv)\n{     /* read character from csv data file */\n      int c;\n      xassert(csv->c != EOF);\n      if (csv->c == '\\n') csv->count++;\nloop: c = fgetc(csv->fp);\n      if (ferror(csv->fp))\n      {  xprintf(\"%s:%d: read error - %s\\n\", csv->fname, csv->count,\n#if 0 /* 29/I-2017 */\n            strerror(errno));\n#else\n            xstrerr(errno));\n#endif\n         longjmp(csv->jump, 0);\n      }\n      if (feof(csv->fp))\n      {  if (csv->c == '\\n')\n         {  csv->count--;\n            c = EOF;\n         }\n         else\n         {  xprintf(\"%s:%d: warning: missing final end-of-line\\n\",\n               csv->fname, csv->count);\n            c = '\\n';\n         }\n      }\n      else if (c == '\\r')\n         goto loop;\n      else if (c == '\\n')\n         ;\n      else if (iscntrl(c))\n      {  xprintf(\"%s:%d: invalid control character 0x%02X\\n\",\n            csv->fname, csv->count, c);\n         longjmp(csv->jump, 0);\n      }\n      csv->c = c;\n      return;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "read_field": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "static void read_field(struct csv *csv)\n{     /* read field from csv data file */\n      /* check for end of file */\n      if (csv->c == EOF)\n      {  csv->what = CSV_EOF;\n         strcpy(csv->field, \"EOF\");\n         goto done;\n      }\n      /* check for end of record */\n      if (csv->c == '\\n')\n      {  csv->what = CSV_EOR;\n         strcpy(csv->field, \"EOR\");\n         read_char(csv);\n         if (csv->c == ',')\nerr1:    {  xprintf(\"%s:%d: empty field not allowed\\n\", csv->fname,\n               csv->count);\n            longjmp(csv->jump, 0);\n         }\n         if (csv->c == '\\n')\n         {  xprintf(\"%s:%d: empty record not allowed\\n\", csv->fname,\n               csv->count);\n            longjmp(csv->jump, 0);\n         }\n#if 1 /* 01/VI-2010 */\n         /* skip comment records; may appear only before the very first\n            record containing field names */\n         if (csv->c == '#' && csv->count == 1)\n         {  while (csv->c == '#')\n            {  while (csv->c != '\\n')\n                  read_char(csv);\n               read_char(csv);\n               csv->nskip++;\n            }\n         }\n#endif\n         goto done;\n      }\n      /* skip comma before next field */\n      if (csv->c == ',')\n         read_char(csv);\n      /* read field */\n      if (csv->c == '\\'' || csv->c == '\"')\n      {  /* read a field enclosed in quotes */\n         int quote = csv->c, len = 0;\n         csv->what = CSV_STR;\n         /* skip opening quote */\n         read_char(csv);\n         /* read field characters within quotes */\n         for (;;)\n         {  /* check for closing quote and read it */\n            if (csv->c == quote)\n            {  read_char(csv);\n               if (csv->c == quote)\n                  ;\n               else if (csv->c == ',' || csv->c == '\\n')\n                  break;\n               else\n               {  xprintf(\"%s:%d: invalid field\\n\", csv->fname,\n                     csv->count);\n                  longjmp(csv->jump, 0);\n               }\n            }\n            /* check the current field length */\n            if (len == CSV_FDLEN_MAX)\nerr2:       {  xprintf(\"%s:%d: field too long\\n\", csv->fname,\n                  csv->count);\n               longjmp(csv->jump, 0);\n            }\n            /* add the current character to the field */\n            csv->field[len++] = (char)csv->c;\n            /* read the next character */\n            read_char(csv);\n         }\n         /* the field has been read */\n         if (len == 0) goto err1;\n         csv->field[len] = '\\0';\n      }\n      else\n      {  /* read a field not enclosed in quotes */\n         int len = 0;\n         double temp;\n         csv->what = CSV_NUM;\n         while (!(csv->c == ',' || csv->c == '\\n'))\n         {  /* quotes within the field are not allowed */\n            if (csv->c == '\\'' || csv->c == '\"')\n            {  xprintf(\"%s:%d: invalid use of single or double quote wi\"\n                  \"thin field\\n\", csv->fname, csv->count);\n               longjmp(csv->jump, 0);\n            }\n            /* check the current field length */\n            if (len == CSV_FDLEN_MAX) goto err2;\n            /* add the current character to the field */\n            csv->field[len++] = (char)csv->c;\n            /* read the next character */\n            read_char(csv);\n         }\n         /* the field has been read */\n         if (len == 0) goto err1;\n         csv->field[len] = '\\0';\n         /* check the field type */\n         if (str2num(csv->field, &temp)) csv->what = CSV_STR;\n      }\ndone: return;\n}",
      "lines": 104,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "csv_open_file": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static struct csv *csv_open_file(TABDCA *dca, int mode)\n{     /* open csv data file */\n      struct csv *csv;\n      /* create control structure */\n      csv = xmalloc(sizeof(struct csv));\n      csv->mode = mode;\n      csv->fname = NULL;\n      csv->fp = NULL;\n      if (setjmp(csv->jump)) goto fail;\n      csv->count = 0;\n      csv->c = '\\n';\n      csv->what = 0;\n      csv->field[0] = '\\0';\n      csv->nf = 0;\n      /* try to open the csv data file */\n      if (mpl_tab_num_args(dca) < 2)\n      {  xprintf(\"csv_driver: file name not specified\\n\");\n         longjmp(csv->jump, 0);\n      }\n      csv->fname = xmalloc(strlen(mpl_tab_get_arg(dca, 2))+1);\n      strcpy(csv->fname, mpl_tab_get_arg(dca, 2));\n      if (mode == 'R')\n      {  /* open the file for reading */\n         int k;\n         csv->fp = fopen(csv->fname, \"r\");\n         if (csv->fp == NULL)\n         {  xprintf(\"csv_driver: unable to open %s - %s\\n\",\n#if 0 /* 29/I-2017 */\n               csv->fname, strerror(errno));\n#else\n               csv->fname, xstrerr(errno));\n#endif\n            longjmp(csv->jump, 0);\n         }\n#if 1 /* 01/VI-2010 */\n         csv->nskip = 0;\n#endif\n         /* skip fake new-line */\n         read_field(csv);\n         xassert(csv->what == CSV_EOR);\n         /* read field names */\n         xassert(csv->nf == 0);\n         for (;;)\n         {  read_field(csv);\n            if (csv->what == CSV_EOR)\n               break;\n            if (csv->what != CSV_STR)\n            {  xprintf(\"%s:%d: invalid field name\\n\", csv->fname,\n                  csv->count);\n               longjmp(csv->jump, 0);\n            }\n            if (csv->nf == CSV_FIELD_MAX)\n            {  xprintf(\"%s:%d: too many fields\\n\", csv->fname,\n                  csv->count);\n               longjmp(csv->jump, 0);\n            }\n            csv->nf++;\n            /* find corresponding field in the table statement */\n            for (k = mpl_tab_num_flds(dca); k >= 1; k--)\n            {  if (strcmp(mpl_tab_get_name(dca, k), csv->field) == 0)\n                  break;\n            }\n            csv->ref[csv->nf] = k;\n         }\n         /* find dummy RECNO field in the table statement */\n         for (k = mpl_tab_num_flds(dca); k >= 1; k--)\n            if (strcmp(mpl_tab_get_name(dca, k), \"RECNO\") == 0) break;\n         csv->ref[0] = k;\n      }\n      else if (mode == 'W')\n      {  /* open the file for writing */\n         int k, nf;\n         csv->fp = fopen(csv->fname, \"w\");\n         if (csv->fp == NULL)\n         {  xprintf(\"csv_driver: unable to create %s - %s\\n\",\n#if 0 /* 29/I-2017 */\n               csv->fname, strerror(errno));\n#else\n               csv->fname, xstrerr(errno));\n#endif\n            longjmp(csv->jump, 0);\n         }\n         /* write field names */\n         nf = mpl_tab_num_flds(dca);\n         for (k = 1; k <= nf; k++)\n            fprintf(csv->fp, \"%s%c\", mpl_tab_get_name(dca, k),\n               k < nf ? ',' : '\\n');\n         csv->count++;\n      }\n      else\n         xassert(mode != mode);\n      /* the file has been open */\n      return csv;\nfail: /* the file cannot be open */\n      if (csv->fname != NULL) xfree(csv->fname);\n      if (csv->fp != NULL) fclose(csv->fp);\n      xfree(csv);\n      return NULL;\n}",
      "lines": 99,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "struct csv",
        "struct",
        "csv",
        "*csv_open_file(TABDCA *dca, int mode)",
        "*"
      ]
    },
    "csv_read_record": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "static int csv_read_record(TABDCA *dca, struct csv *csv)\n{     /* read next record from csv data file */\n      int k, ret = 0;\n      xassert(csv->mode == 'R');\n      if (setjmp(csv->jump))\n      {  ret = 1;\n         goto done;\n      }\n      /* read dummy RECNO field */\n      if (csv->ref[0] > 0)\n#if 0 /* 01/VI-2010 */\n         mpl_tab_set_num(dca, csv->ref[0], csv->count-1);\n#else\n         mpl_tab_set_num(dca, csv->ref[0], csv->count-csv->nskip-1);\n#endif\n      /* read fields */\n      for (k = 1; k <= csv->nf; k++)\n      {  read_field(csv);\n         if (csv->what == CSV_EOF)\n         {  /* end-of-file reached */\n            xassert(k == 1);\n            ret = -1;\n            goto done;\n         }\n         else if (csv->what == CSV_EOR)\n         {  /* end-of-record reached */\n            int lack = csv->nf - k + 1;\n            if (lack == 1)\n               xprintf(\"%s:%d: one field missing\\n\", csv->fname,\n                  csv->count);\n            else\n               xprintf(\"%s:%d: %d fields missing\\n\", csv->fname,\n                  csv->count, lack);\n            longjmp(csv->jump, 0);\n         }\n         else if (csv->what == CSV_NUM)\n         {  /* floating-point number */\n            if (csv->ref[k] > 0)\n            {  double num;\n               xassert(str2num(csv->field, &num) == 0);\n               mpl_tab_set_num(dca, csv->ref[k], num);\n            }\n         }\n         else if (csv->what == CSV_STR)\n         {  /* character string */\n            if (csv->ref[k] > 0)\n               mpl_tab_set_str(dca, csv->ref[k], csv->field);\n         }\n         else\n            xassert(csv != csv);\n      }\n      /* now there must be NL */\n      read_field(csv);\n      xassert(csv->what != CSV_EOF);\n      if (csv->what != CSV_EOR)\n      {  xprintf(\"%s:%d: too many fields\\n\", csv->fname, csv->count);\n         longjmp(csv->jump, 0);\n      }\ndone: return ret;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "csv_write_record": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "static int csv_write_record(TABDCA *dca, struct csv *csv)\n{     /* write next record to csv data file */\n      int k, nf, ret = 0;\n      const char *c;\n      xassert(csv->mode == 'W');\n      nf = mpl_tab_num_flds(dca);\n      for (k = 1; k <= nf; k++)\n      {  switch (mpl_tab_get_type(dca, k))\n         {  case 'N':\n               fprintf(csv->fp, \"%.*g\", DBL_DIG,\n                  mpl_tab_get_num(dca, k));\n               break;\n            case 'S':\n               fputc('\"', csv->fp);\n               for (c = mpl_tab_get_str(dca, k); *c != '\\0'; c++)\n               {  if (*c == '\"')\n                     fputc('\"', csv->fp), fputc('\"', csv->fp);\n                  else\n                     fputc(*c, csv->fp);\n               }\n               fputc('\"', csv->fp);\n               break;\n            default:\n               xassert(dca != dca);\n         }\n         fputc(k < nf ? ',' : '\\n', csv->fp);\n      }\n      csv->count++;\n      if (ferror(csv->fp))\n      {  xprintf(\"%s:%d: write error - %s\\n\", csv->fname, csv->count,\n#if 0 /* 29/I-2017 */\n            strerror(errno));\n#else\n            xstrerr(errno));\n#endif\n         ret = 1;\n      }\n      return ret;\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "csv_close_file": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "static int csv_close_file(TABDCA *dca, struct csv *csv)\n{     /* close csv data file */\n      int ret = 0;\n      xassert(dca == dca);\n      if (csv->mode == 'W')\n      {  fflush(csv->fp);\n         if (ferror(csv->fp))\n         {  xprintf(\"%s:%d: write error - %s\\n\", csv->fname,\n#if 0 /* 29/I-2017 */\n               csv->count, strerror(errno));\n#else\n               csv->count, xstrerr(errno));\n#endif\n            ret = 1;\n         }\n      }\n      xfree(csv->fname);\n      fclose(csv->fp);\n      xfree(csv);\n      return ret;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_byte": {
      "start_point": [
        475,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "static int read_byte(struct dbf *dbf)\n{     /* read byte from xBASE data file */\n      int b;\n      b = fgetc(dbf->fp);\n      if (ferror(dbf->fp))\n      {  xprintf(\"%s:0x%X: read error - %s\\n\", dbf->fname,\n#if 0 /* 29/I-2017 */\n            dbf->offset, strerror(errno));\n#else\n            dbf->offset, xstrerr(errno));\n#endif\n         longjmp(dbf->jump, 0);\n      }\n      if (feof(dbf->fp))\n      {  xprintf(\"%s:0x%X: unexpected end of file\\n\", dbf->fname,\n            dbf->offset);\n         longjmp(dbf->jump, 0);\n      }\n      xassert(0x00 <= b && b <= 0xFF);\n      dbf->offset++;\n      return b;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_header": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        579,
        1
      ],
      "content": "static void read_header(TABDCA *dca, struct dbf *dbf)\n{     /* read xBASE data file header */\n      int b, j, k, recl;\n      char name[10+1];\n      /* (ignored) */\n      for (j = 1; j <= 10; j++)\n         read_byte(dbf);\n      /* length of each record, in bytes */\n      recl = read_byte(dbf);\n      recl += read_byte(dbf) << 8;\n      /* (ignored) */\n      for (j = 1; j <= 20; j++)\n         read_byte(dbf);\n      /* field descriptor array */\n      xassert(dbf->nf == 0);\n      for (;;)\n      {  /* check for end of array */\n         b = read_byte(dbf);\n         if (b == 0x0D) break;\n         if (dbf->nf == DBF_FIELD_MAX)\n         {  xprintf(\"%s:0x%X: too many fields\\n\", dbf->fname,\n               dbf->offset);\n            longjmp(dbf->jump, 0);\n         }\n         dbf->nf++;\n         /* field name */\n         name[0] = (char)b;\n         for (j = 1; j < 10; j++)\n         {  b = read_byte(dbf);\n            name[j] = (char)b;\n         }\n         name[10] = '\\0';\n         b = read_byte(dbf);\n         if (b != 0x00)\n         {  xprintf(\"%s:0x%X: invalid field name\\n\", dbf->fname,\n               dbf->offset);\n            longjmp(dbf->jump, 0);\n         }\n         /* find corresponding field in the table statement */\n         for (k = mpl_tab_num_flds(dca); k >= 1; k--)\n            if (strcmp(mpl_tab_get_name(dca, k), name) == 0) break;\n         dbf->ref[dbf->nf] = k;\n         /* field type */\n         b = read_byte(dbf);\n         if (!(b == 'C' || b == 'N'))\n         {  xprintf(\"%s:0x%X: invalid field type\\n\", dbf->fname,\n               dbf->offset);\n            longjmp(dbf->jump, 0);\n         }\n         dbf->type[dbf->nf] = b;\n         /* (ignored) */\n         for (j = 1; j <= 4; j++)\n            read_byte(dbf);\n         /* field length */\n         b = read_byte(dbf);\n         if (b == 0)\n         {  xprintf(\"%s:0x%X: invalid field length\\n\", dbf->fname,\n               dbf->offset);\n            longjmp(dbf->jump, 0);\n         }\n         if (b > DBF_FDLEN_MAX)\n         {  xprintf(\"%s:0x%X: field too long\\n\", dbf->fname,\n               dbf->offset);\n            longjmp(dbf->jump, 0);\n         }\n         dbf->len[dbf->nf] = b;\n         recl -= b;\n         /* (ignored) */\n         for (j = 1; j <= 15; j++)\n            read_byte(dbf);\n      }\n      if (recl != 1)\n      {  xprintf(\"%s:0x%X: invalid file header\\n\", dbf->fname,\n            dbf->offset);\n         longjmp(dbf->jump, 0);\n      }\n      /* find dummy RECNO field in the table statement */\n      for (k = mpl_tab_num_flds(dca); k >= 1; k--)\n         if (strcmp(mpl_tab_get_name(dca, k), \"RECNO\") == 0) break;\n      dbf->ref[0] = k;\n      return;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_third_arg": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        647,
        1
      ],
      "content": "static void parse_third_arg(TABDCA *dca, struct dbf *dbf)\n{     /* parse xBASE file format (third argument) */\n      int j, k, temp;\n      const char *arg;\n      dbf->nf = mpl_tab_num_flds(dca);\n      arg = mpl_tab_get_arg(dca, 3), j = 0;\n      for (k = 1; k <= dbf->nf; k++)\n      {  /* parse specification of k-th field */\n         if (arg[j] == '\\0')\n         {  xprintf(\"xBASE driver: field %s: specification missing\\n\",\n               mpl_tab_get_name(dca, k));\n            longjmp(dbf->jump, 0);\n         }\n         /* parse field type */\n         if (arg[j] == 'C' || arg[j] == 'N')\n            dbf->type[k] = arg[j], j++;\n         else\n         {  xprintf(\"xBASE driver: field %s: invalid field type\\n\",\n               mpl_tab_get_name(dca, k));\n            longjmp(dbf->jump, 0);\n         }\n         /* check for left parenthesis */\n         if (arg[j] == '(')\n            j++;\n         else\nerr:     {  xprintf(\"xBASE driver: field %s: invalid field format\\n\",\n               mpl_tab_get_name(dca, k));\n            longjmp(dbf->jump, 0);\n         }\n         /* parse field length */\n         temp = 0;\n         while (isdigit(arg[j]))\n         {  if (temp > DBF_FDLEN_MAX) break;\n            temp = 10 * temp + (arg[j] - '0'), j++;\n         }\n         if (!(1 <= temp && temp <= DBF_FDLEN_MAX))\n         {  xprintf(\"xBASE driver: field %s: invalid field length\\n\",\n               mpl_tab_get_name(dca, k));\n            longjmp(dbf->jump, 0);\n         }\n         dbf->len[k] = temp;\n         /* parse optional field precision */\n         if (dbf->type[k] == 'N' && arg[j] == ',')\n         {  j++;\n            temp = 0;\n            while (isdigit(arg[j]))\n            {  if (temp > dbf->len[k]) break;\n               temp = 10 * temp + (arg[j] - '0'), j++;\n            }\n            if (temp > dbf->len[k])\n            {  xprintf(\"xBASE driver: field %s: invalid field precision\"\n                  \"\\n\", mpl_tab_get_name(dca, k));\n               longjmp(dbf->jump, 0);\n            }\n            dbf->prec[k] = temp;\n         }\n         else\n            dbf->prec[k] = 0;\n         /* check for right parenthesis */\n         if (arg[j] == ')')\n            j++;\n         else\n            goto err;\n      }\n      /* ignore other specifications */\n      return;\n}",
      "lines": 67,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_byte": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void write_byte(struct dbf *dbf, int b)\n{     /* write byte to xBASE data file */\n      fputc(b, dbf->fp);\n      dbf->offset++;\n      return;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_header": {
      "start_point": [
        656,
        0
      ],
      "end_point": [
        706,
        1
      ],
      "content": "static void write_header(TABDCA *dca, struct dbf *dbf)\n{     /* write xBASE data file header */\n      int j, k, temp;\n      const char *name;\n      /* version number */\n      write_byte(dbf, 0x03 /* file without DBT */);\n      /* date of last update (YYMMDD) */\n      write_byte(dbf, 70 /* 1970 */);\n      write_byte(dbf, 1 /* January */);\n      write_byte(dbf, 1 /* 1st */);\n      /* number of records (unknown so far) */\n      for (j = 1; j <= 4; j++)\n         write_byte(dbf, 0xFF);\n      /* length of the header, in bytes */\n      temp = 32 + dbf->nf * 32 + 1;\n      write_byte(dbf, temp);\n      write_byte(dbf, temp >> 8);\n      /* length of each record, in bytes */\n      temp = 1;\n      for (k = 1; k <= dbf->nf; k++)\n         temp += dbf->len[k];\n      write_byte(dbf, temp);\n      write_byte(dbf, temp >> 8);\n      /* (reserved) */\n      for (j = 1; j <= 20; j++)\n         write_byte(dbf, 0x00);\n      /* field descriptor array */\n      for (k = 1; k <= dbf->nf; k++)\n      {  /* field name (terminated by 0x00) */\n         name = mpl_tab_get_name(dca, k);\n         for (j = 0; j < 10 && name[j] != '\\0'; j++)\n            write_byte(dbf, name[j]);\n         for (j = j; j < 11; j++)\n            write_byte(dbf, 0x00);\n         /* field type */\n         write_byte(dbf, dbf->type[k]);\n         /* (reserved) */\n         for (j = 1; j <= 4; j++)\n            write_byte(dbf, 0x00);\n         /* field length */\n         write_byte(dbf, dbf->len[k]);\n         /* field precision */\n         write_byte(dbf, dbf->prec[k]);\n         /* (reserved) */\n         for (j = 1; j <= 14; j++)\n            write_byte(dbf, 0x00);\n      }\n      /* end of header */\n      write_byte(dbf, 0x0D);\n      return;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dbf_open_file": {
      "start_point": [
        708,
        0
      ],
      "end_point": [
        769,
        1
      ],
      "content": "static struct dbf *dbf_open_file(TABDCA *dca, int mode)\n{     /* open xBASE data file */\n      struct dbf *dbf;\n      /* create control structure */\n      dbf = xmalloc(sizeof(struct dbf));\n      dbf->mode = mode;\n      dbf->fname = NULL;\n      dbf->fp = NULL;\n      if (setjmp(dbf->jump)) goto fail;\n      dbf->offset = 0;\n      dbf->count = 0;\n      dbf->nf = 0;\n      /* try to open the xBASE data file */\n      if (mpl_tab_num_args(dca) < 2)\n      {  xprintf(\"xBASE driver: file name not specified\\n\");\n         longjmp(dbf->jump, 0);\n      }\n      dbf->fname = xmalloc(strlen(mpl_tab_get_arg(dca, 2))+1);\n      strcpy(dbf->fname, mpl_tab_get_arg(dca, 2));\n      if (mode == 'R')\n      {  /* open the file for reading */\n         dbf->fp = fopen(dbf->fname, \"rb\");\n         if (dbf->fp == NULL)\n         {  xprintf(\"xBASE driver: unable to open %s - %s\\n\",\n#if 0 /* 29/I-2017 */\n               dbf->fname, strerror(errno));\n#else\n               dbf->fname, xstrerr(errno));\n#endif\n            longjmp(dbf->jump, 0);\n         }\n         read_header(dca, dbf);\n      }\n      else if (mode == 'W')\n      {  /* open the file for writing */\n         if (mpl_tab_num_args(dca) < 3)\n         {  xprintf(\"xBASE driver: file format not specified\\n\");\n            longjmp(dbf->jump, 0);\n         }\n         parse_third_arg(dca, dbf);\n         dbf->fp = fopen(dbf->fname, \"wb\");\n         if (dbf->fp == NULL)\n         {  xprintf(\"xBASE driver: unable to create %s - %s\\n\",\n#if 0 /* 29/I-2017 */\n               dbf->fname, strerror(errno));\n#else\n               dbf->fname, xstrerr(errno));\n#endif\n            longjmp(dbf->jump, 0);\n         }\n         write_header(dca, dbf);\n      }\n      else\n         xassert(mode != mode);\n      /* the file has been open */\n      return dbf;\nfail: /* the file cannot be open */\n      if (dbf->fname != NULL) xfree(dbf->fname);\n      if (dbf->fp != NULL) fclose(dbf->fp);\n      xfree(dbf);\n      return NULL;\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "struct dbf",
        "struct",
        "dbf",
        "*dbf_open_file(TABDCA *dca, int mode)",
        "*"
      ]
    },
    "dbf_read_record": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static int dbf_read_record(TABDCA *dca, struct dbf *dbf)\n{     /* read next record from xBASE data file */\n      int b, j, k, ret = 0;\n      char buf[DBF_FDLEN_MAX+1];\n      xassert(dbf->mode == 'R');\n      if (setjmp(dbf->jump))\n      {  ret = 1;\n         goto done;\n      }\n      /* check record flag */\n      b = read_byte(dbf);\n      if (b == 0x1A)\n      {  /* end of data */\n         ret = -1;\n         goto done;\n      }\n      if (b != 0x20)\n      {  xprintf(\"%s:0x%X: invalid record flag\\n\", dbf->fname,\n            dbf->offset);\n         longjmp(dbf->jump, 0);\n      }\n      /* read dummy RECNO field */\n      if (dbf->ref[0] > 0)\n         mpl_tab_set_num(dca, dbf->ref[0], dbf->count+1);\n      /* read fields */\n      for (k = 1; k <= dbf->nf; k++)\n      {  /* read k-th field */\n         for (j = 0; j < dbf->len[k]; j++)\n            buf[j] = (char)read_byte(dbf);\n         buf[dbf->len[k]] = '\\0';\n         /* set field value */\n         if (dbf->type[k] == 'C')\n         {  /* character field */\n            if (dbf->ref[k] > 0)\n               mpl_tab_set_str(dca, dbf->ref[k], strtrim(buf));\n         }\n         else if (dbf->type[k] == 'N')\n         {  /* numeric field */\n            if (dbf->ref[k] > 0)\n            {  double num;\n               strspx(buf);\n               xassert(str2num(buf, &num) == 0);\n               mpl_tab_set_num(dca, dbf->ref[k], num);\n            }\n         }\n         else\n            xassert(dbf != dbf);\n      }\n      /* increase record count */\n      dbf->count++;\ndone: return ret;\n}",
      "lines": 52,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dbf_write_record": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        878,
        1
      ],
      "content": "static int dbf_write_record(TABDCA *dca, struct dbf *dbf)\n{     /* write next record to xBASE data file */\n      int j, k, ret = 0;\n      char buf[255+1];\n      xassert(dbf->mode == 'W');\n      if (setjmp(dbf->jump))\n      {  ret = 1;\n         goto done;\n      }\n      /* record flag */\n      write_byte(dbf, 0x20);\n      xassert(dbf->nf == mpl_tab_num_flds(dca));\n      for (k = 1; k <= dbf->nf; k++)\n      {  if (dbf->type[k] == 'C')\n         {  /* character field */\n            const char *str;\n            if (mpl_tab_get_type(dca, k) == 'N')\n            {  sprintf(buf, \"%.*g\", DBL_DIG, mpl_tab_get_num(dca, k));\n               str = buf;\n            }\n            else if (mpl_tab_get_type(dca, k) == 'S')\n               str = mpl_tab_get_str(dca, k);\n            else\n               xassert(dca != dca);\n            if ((int)strlen(str) > dbf->len[k])\n            {  xprintf(\"xBASE driver: field %s: cannot convert %.15s...\"\n                  \" to field format\\n\", mpl_tab_get_name(dca, k), str);\n               longjmp(dbf->jump, 0);\n            }\n            for (j = 0; j < dbf->len[k] && str[j] != '\\0'; j++)\n                write_byte(dbf, str[j]);\n            for (j = j; j < dbf->len[k]; j++)\n                write_byte(dbf, ' ');\n         }\n         else if (dbf->type[k] == 'N')\n         {  /* numeric field */\n            double num = mpl_tab_get_num(dca, k);\n            if (fabs(num) > 1e20)\nerr:        {  xprintf(\"xBASE driver: field %s: cannot convert %g to fi\"\n                  \"eld format\\n\", mpl_tab_get_name(dca, k), num);\n               longjmp(dbf->jump, 0);\n            }\n            sprintf(buf, \"%*.*f\", dbf->len[k], dbf->prec[k], num);\n            xassert(strlen(buf) < sizeof(buf));\n            if ((int)strlen(buf) != dbf->len[k]) goto err;\n            for (j = 0; j < dbf->len[k]; j++)\n               write_byte(dbf, buf[j]);\n         }\n         else\n            xassert(dbf != dbf);\n      }\n      /* increase record count */\n      dbf->count++;\ndone: return ret;\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dbf_close_file": {
      "start_point": [
        880,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "static int dbf_close_file(TABDCA *dca, struct dbf *dbf)\n{     /* close xBASE data file */\n      int ret = 0;\n      xassert(dca == dca);\n      if (dbf->mode == 'W')\n      {  if (setjmp(dbf->jump))\n         {  ret = 1;\n            goto skip;\n         }\n         /* end-of-file flag */\n         write_byte(dbf, 0x1A);\n         /* number of records */\n         dbf->offset = 4;\n         if (fseek(dbf->fp, dbf->offset, SEEK_SET))\n         {  xprintf(\"%s:0x%X: seek error - %s\\n\", dbf->fname,\n#if 0 /* 29/I-2017 */\n               dbf->offset, strerror(errno));\n#else\n               dbf->offset, xstrerr(errno));\n#endif\n            longjmp(dbf->jump, 0);\n         }\n         write_byte(dbf, dbf->count);\n         write_byte(dbf, dbf->count >> 8);\n         write_byte(dbf, dbf->count >> 16);\n         write_byte(dbf, dbf->count >> 24);\n         fflush(dbf->fp);\n         if (ferror(dbf->fp))\n         {  xprintf(\"%s:0x%X: write error - %s\\n\", dbf->fname,\n#if 0 /* 29/I-2017 */\n               dbf->offset, strerror(errno));\n#else\n               dbf->offset, xstrerr(errno));\n#endif\n            longjmp(dbf->jump, 0);\n         }\nskip:    ;\n      }\n      xfree(dbf->fname);\n      fclose(dbf->fp);\n      xfree(dbf);\n      return ret;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpl_tab_drv_open": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        959,
        1
      ],
      "content": "void mpl_tab_drv_open(MPL *mpl, int mode)\n{     TABDCA *dca = mpl->dca;\n      xassert(dca->id == 0);\n      xassert(dca->link == NULL);\n      xassert(dca->na >= 1);\n      if (strcmp(dca->arg[1], \"CSV\") == 0)\n      {  dca->id = TAB_CSV;\n         dca->link = csv_open_file(dca, mode);\n      }\n      else if (strcmp(dca->arg[1], \"xBASE\") == 0)\n      {  dca->id = TAB_XBASE;\n         dca->link = dbf_open_file(dca, mode);\n      }\n      else if (strcmp(dca->arg[1], \"ODBC\") == 0 ||\n               strcmp(dca->arg[1], \"iODBC\") == 0)\n      {  dca->id = TAB_ODBC;\n         dca->link = db_iodbc_open(dca, mode);\n      }\n      else if (strcmp(dca->arg[1], \"MySQL\") == 0)\n      {  dca->id = TAB_MYSQL;\n         dca->link = db_mysql_open(dca, mode);\n      }\n      else\n         xprintf(\"Invalid table driver '%s'\\n\", dca->arg[1]);\n      if (dca->link == NULL)\n         error(mpl, \"error on opening table %s\",\n            mpl->stmt->u.tab->name);\n      return;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpl_tab_drv_read": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "int mpl_tab_drv_read(MPL *mpl)\n{     TABDCA *dca = mpl->dca;\n      int ret;\n      switch (dca->id)\n      {  case TAB_CSV:\n            ret = csv_read_record(dca, dca->link);\n            break;\n         case TAB_XBASE:\n            ret = dbf_read_record(dca, dca->link);\n            break;\n         case TAB_ODBC:\n            ret = db_iodbc_read(dca, dca->link);\n            break;\n         case TAB_MYSQL:\n            ret = db_mysql_read(dca, dca->link);\n            break;\n         default:\n            xassert(dca != dca);\n      }\n      if (ret > 0)\n         error(mpl, \"error on reading data from table %s\",\n            mpl->stmt->u.tab->name);\n      return ret;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpl_tab_drv_write": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1009,
        1
      ],
      "content": "void mpl_tab_drv_write(MPL *mpl)\n{     TABDCA *dca = mpl->dca;\n      int ret;\n      switch (dca->id)\n      {  case TAB_CSV:\n            ret = csv_write_record(dca, dca->link);\n            break;\n         case TAB_XBASE:\n            ret = dbf_write_record(dca, dca->link);\n            break;\n         case TAB_ODBC:\n            ret = db_iodbc_write(dca, dca->link);\n            break;\n         case TAB_MYSQL:\n            ret = db_mysql_write(dca, dca->link);\n            break;\n         default:\n            xassert(dca != dca);\n      }\n      if (ret)\n         error(mpl, \"error on writing data to table %s\",\n            mpl->stmt->u.tab->name);\n      return;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpl_tab_drv_close": {
      "start_point": [
        1011,
        0
      ],
      "end_point": [
        1036,
        1
      ],
      "content": "void mpl_tab_drv_close(MPL *mpl)\n{     TABDCA *dca = mpl->dca;\n      int ret;\n      switch (dca->id)\n      {  case TAB_CSV:\n            ret = csv_close_file(dca, dca->link);\n            break;\n         case TAB_XBASE:\n            ret = dbf_close_file(dca, dca->link);\n            break;\n         case TAB_ODBC:\n            ret = db_iodbc_close(dca, dca->link);\n            break;\n         case TAB_MYSQL:\n            ret = db_mysql_close(dca, dca->link);\n            break;\n         default:\n            xassert(dca != dca);\n      }\n      dca->id = 0;\n      dca->link = NULL;\n      if (ret)\n         error(mpl, \"error on closing table %s\",\n            mpl->stmt->u.tab->name);\n      return;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mplsql.c": {
    "args_concat": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static char **args_concat(TABDCA *dca)\n{\n   const char  *arg;\n   int          i;\n   int          j;\n   int          j0;\n   int          j1;\n   size_t       len;\n   int          lentot;\n   int          narg;\n   int          nline = 0;\n   char       **sqllines = NULL;\n\n   narg = mpl_tab_num_args(dca);\n   /* The SQL statements start with argument 3. */\n   if (narg < 3)\n      return NULL;\n   /* Count the SQL statements */\n   for (j = 3; j <= narg; j++)\n   {\n      arg = mpl_tab_get_arg(dca, j);\n      len = strlen(arg);\n      if (arg[len-1] == ';' || j == narg)\n        nline ++;\n   }\n   /* Allocate string buffer. */\n   sqllines = (char **) xmalloc((nline+1) * sizeof(char **));\n   /* Join arguments */\n   sqllines[0] = NULL;\n   j0     = 3;\n   i      = 0;\n   lentot = 0;\n   for (j = 3; j <= narg; j++)\n   {\n      arg = mpl_tab_get_arg(dca, j);\n      len = strlen(arg);\n      /* add length of part */\n      lentot += len;\n      /* add length of space separating parts or 0x00 at end of SQL\n         statement */\n      lentot++;\n      if (arg[len-1] == ';' || j == narg)\n      {  /* Join arguments for a single SQL statement */\n         sqllines[i] = xmalloc(lentot);\n         sqllines[i+1] = NULL;\n         sqllines[i][0] = 0x00;\n         for (j1 = j0; j1 <= j; j1++)\n         {  if(j1>j0)\n               strcat(sqllines[i], \" \");\n            strcat(sqllines[i], mpl_tab_get_arg(dca, j1));\n         }\n         len = strlen(sqllines[i]);\n         if (sqllines[i][len-1] == ';')\n            sqllines[i][len-1] = 0x00;\n         j0 = j+1;\n         i++;\n         lentot = 0;\n      }\n   }\n   return sqllines;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "**args_concat(TABDCA *dca)",
        "*",
        "*args_concat(TABDCA *dca)",
        "*"
      ]
    },
    "free_buffer": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static void free_buffer(char **buf)\n{  int i;\n\n   for(i = 0; buf[i] != NULL; i++)\n      xfree(buf[i]);\n   xfree(buf);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "db_escaped_string_length": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static int db_escaped_string_length(const char* from)\n/* length of escaped string */\n{\n   int         count;\n   const char *pointer;\n\n    for (pointer = from, count = 0; *pointer != (char) '\\0'; pointer++,\n         count++)\n    {\n      switch (*pointer)\n      {\n         case '\\'':\n            count++;\n            break;\n      }\n    }\n\n    return count;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "db_escape_string": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static void db_escape_string (char *to, const char *from)\n/* escape string*/\n{\n   const char *source = from;\n   char *target = to;\n   size_t remaining;\n\n   remaining = strlen(from);\n\n   if (to == NULL)\n     to = (char *) (from + remaining);\n\n   while (remaining > 0)\n   {\n      switch (*source)\n      {\n         case '\\'':\n            *target = '\\'';\n            target++;\n            *target = '\\'';\n            break;\n\n         default:\n            *target = *source;\n            }\n      source++;\n      target++;\n      remaining--;\n      }\n\n   /* Write the terminating NUL character. */\n   *target = '\\0';\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "db_generate_select_stmt": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static char *db_generate_select_stmt(TABDCA *dca)\n/* generate select statement */\n{\n   char        *arg;\n   char const  *field;\n   char        *query;\n   int          j;\n   int          narg;\n   int          nf;\n   int          total;\n\n   total = 50;\n   nf = mpl_tab_num_flds(dca);\n   narg = mpl_tab_num_args(dca);\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      total += strlen(field);\n      total += 2;\n   }\n   arg = (char *) mpl_tab_get_arg(dca, narg);\n   total += strlen(arg);\n   query = xmalloc( total * sizeof(char));\n   strcpy (query, \"SELECT \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      strcat(query, field);\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" FROM \");\n   strcat(query, arg);\n   return query;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*db_generate_select_stmt(TABDCA *dca)",
        "*"
      ]
    },
    "db_generate_insert_stmt": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "static char *db_generate_insert_stmt(TABDCA *dca)\n/* generate insert statement */\n{\n   char        *arg;\n   char const  *field;\n   char        *query;\n   int          j;\n   int          narg;\n   int          nf;\n   int          total;\n\n   total = 50;\n   nf = mpl_tab_num_flds(dca);\n   narg = mpl_tab_num_args(dca);\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      total += strlen(field);\n      total += 5;\n   }\n   arg = (char *) mpl_tab_get_arg(dca, narg);\n   total += strlen(arg);\n   query = xmalloc( (total+1) * sizeof(char));\n   strcpy (query, \"INSERT INTO \");\n   strcat(query, arg);\n   strcat(query, \" ( \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      field = mpl_tab_get_name(dca, j);\n      strcat(query, field);\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" ) VALUES ( \");\n   for (j=1; j <= nf && j <= SQL_FIELD_MAX; j++)\n   {\n      strcat(query, \"?\");\n      if ( j < nf )\n         strcat(query, \", \");\n   }\n   strcat(query, \" )\");\n   return query;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*db_generate_insert_stmt(TABDCA *dca)",
        "*"
      ]
    },
    "db_iodbc_open": [
      {
        "start_point": [
          304,
          0
        ],
        "end_point": [
          309,
          1
        ],
        "content": "void *db_iodbc_open(TABDCA *dca, int mode)\n{     xassert(dca == dca);\n      xassert(mode == mode);\n      xprintf(\"iODBC table driver not supported\\n\");\n      return NULL;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "void",
          "*db_iodbc_open(TABDCA *dca, int mode)",
          "*"
        ]
      },
      {
        "start_point": [
          669,
          0
        ],
        "end_point": [
          682,
          1
        ],
        "content": "void *db_iodbc_open(TABDCA *dca, int mode)\n{  void  *ret;\n   char **sqllines;\n\n   sqllines = args_concat(dca);\n   if (sqllines == NULL)\n   {  xprintf(\"Missing arguments in table statement.\\n\"\n              \"Please, supply table driver, dsn, and query.\\n\");\n      return NULL;\n   }\n   ret = db_iodbc_open_int(dca, mode, (const char **) sqllines);\n   free_buffer(sqllines);\n   return ret;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "void",
          "*db_iodbc_open(TABDCA *dca, int mode)",
          "*"
        ]
      }
    ],
    "db_iodbc_read": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int db_iodbc_read(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "db_iodbc_write": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "int db_iodbc_write(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "db_iodbc_close": [
      {
        "start_point": [
          323,
          0
        ],
        "end_point": [
          327,
          1
        ],
        "content": "int db_iodbc_close(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1011,
          0
        ],
        "end_point": [
          1032,
          1
        ],
        "content": "int db_iodbc_close(TABDCA *dca, void *link)\n{\n   struct db_odbc *sql;\n\n   sql = (struct db_odbc *) link;\n   xassert(sql != NULL);\n   /* Commit */\n   if ( sql->mode == 'W' )\n      dl_SQLEndTran(SQL_HANDLE_ENV, sql->henv, SQL_COMMIT);\n   if ( sql->mode == 'R' )\n      dl_SQLCloseCursor(sql->hstmt);\n\n   dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n   dl_SQLDisconnect(sql->hdbc);\n   dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n   dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n   if ( sql->mode == 'W' )\n      xfree(sql->query);\n   xfree(sql);\n   dca->link = NULL;\n   return 0;\n}",
        "lines": 22,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "dl_SQLAllocHandle": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLAllocHandle (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             InputHandle,\n   SQLHANDLE            *OutputHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLAllocHandle(\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             InputHandle,\n         SQLHANDLE            *OutputHandle);\n\n      ep_SQLAllocHandle *fn;\n      fn = (ep_SQLAllocHandle *) xdlsym(h_odbc, \"SQLAllocHandle\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, InputHandle, OutputHandle);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLBindCol": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLBindCol (\n   SQLHSTMT              StatementHandle,\n   SQLUSMALLINT          ColumnNumber,\n   SQLSMALLINT           TargetType,\n   SQLPOINTER            TargetValue,\n   SQLLEN                BufferLength,\n   SQLLEN               *StrLen_or_Ind)\n{\n      typedef SQLRETURN SQL_API ep_SQLBindCol(\n         SQLHSTMT              StatementHandle,\n         SQLUSMALLINT          ColumnNumber,\n         SQLSMALLINT           TargetType,\n         SQLPOINTER            TargetValue,\n         SQLLEN                BufferLength,\n         SQLLEN               *StrLen_or_Ind);\n      ep_SQLBindCol *fn;\n      fn = (ep_SQLBindCol *) xdlsym(h_odbc, \"SQLBindCol\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnNumber, TargetType,\n         TargetValue, BufferLength, StrLen_or_Ind);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLCloseCursor": {
      "start_point": [
        402,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLCloseCursor (\n   SQLHSTMT              StatementHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLCloseCursor (\n         SQLHSTMT              StatementHandle);\n\n      ep_SQLCloseCursor *fn;\n      fn = (ep_SQLCloseCursor *) xdlsym(h_odbc, \"SQLCloseCursor\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLDisconnect": {
      "start_point": [
        415,
        0
      ],
      "end_point": [
        425,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLDisconnect (\n   SQLHDBC               ConnectionHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLDisconnect(\n         SQLHDBC               ConnectionHandle);\n\n      ep_SQLDisconnect *fn;\n      fn = (ep_SQLDisconnect *) xdlsym(h_odbc, \"SQLDisconnect\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLDriverConnect": {
      "start_point": [
        427,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLDriverConnect (\n   SQLHDBC               hdbc,\n   SQLHWND               hwnd,\n   SQLCHAR              *szConnStrIn,\n   SQLSMALLINT           cbConnStrIn,\n   SQLCHAR              *szConnStrOut,\n   SQLSMALLINT           cbConnStrOutMax,\n   SQLSMALLINT          *pcbConnStrOut,\n   SQLUSMALLINT          fDriverCompletion)\n{\n      typedef SQLRETURN SQL_API ep_SQLDriverConnect(\n         SQLHDBC               hdbc,\n         SQLHWND               hwnd,\n         SQLCHAR             * szConnStrIn,\n         SQLSMALLINT           cbConnStrIn,\n         SQLCHAR             * szConnStrOut,\n         SQLSMALLINT           cbConnStrOutMax,\n         SQLSMALLINT         * pcbConnStrOut,\n         SQLUSMALLINT          fDriverCompletion);\n\n      ep_SQLDriverConnect *fn;\n      fn = (ep_SQLDriverConnect *) xdlsym(h_odbc, \"SQLDriverConnect\");\n      xassert(fn != NULL);\n      return (*fn)(hdbc, hwnd, szConnStrIn, cbConnStrIn, szConnStrOut,\n         cbConnStrOutMax, pcbConnStrOut, fDriverCompletion);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLEndTran": {
      "start_point": [
        454,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLEndTran (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle,\n   SQLSMALLINT           CompletionType)\n{\n      typedef SQLRETURN SQL_API ep_SQLEndTran (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle,\n         SQLSMALLINT           CompletionType);\n\n      ep_SQLEndTran *fn;\n      fn = (ep_SQLEndTran *) xdlsym(h_odbc, \"SQLEndTran\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle, CompletionType);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLExecDirect": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLExecDirect (\n   SQLHSTMT              StatementHandle,\n   SQLCHAR             * StatementText,\n   SQLINTEGER            TextLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLExecDirect (\n         SQLHSTMT              StatementHandle,\n         SQLCHAR             * StatementText,\n         SQLINTEGER            TextLength);\n\n      ep_SQLExecDirect *fn;\n      fn = (ep_SQLExecDirect *) xdlsym(h_odbc, \"SQLExecDirect\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, StatementText, TextLength);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLFetch": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        496,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLFetch (\n   SQLHSTMT              StatementHandle)\n{\n      typedef SQLRETURN SQL_API ep_SQLFetch (\n         SQLHSTMT              StatementHandle);\n\n      ep_SQLFetch *fn;\n      fn = (ep_SQLFetch*) xdlsym(h_odbc, \"SQLFetch\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLFreeHandle": {
      "start_point": [
        498,
        0
      ],
      "end_point": [
        510,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLFreeHandle (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle)\n{\n      typedef SQLRETURN SQL_API ep_SQLFreeHandle (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle);\n\n      ep_SQLFreeHandle *fn;\n      fn = (ep_SQLFreeHandle *) xdlsym(h_odbc, \"SQLFreeHandle\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLDescribeCol": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLDescribeCol (\n   SQLHSTMT              StatementHandle,\n   SQLUSMALLINT          ColumnNumber,\n   SQLCHAR             * ColumnName,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT         * NameLength,\n   SQLSMALLINT         * DataType,\n   SQLULEN             * ColumnSize,\n   SQLSMALLINT         * DecimalDigits,\n   SQLSMALLINT         * Nullable)\n{\n      typedef SQLRETURN SQL_API ep_SQLDescribeCol (\n         SQLHSTMT              StatementHandle,\n         SQLUSMALLINT          ColumnNumber,\n         SQLCHAR              *ColumnName,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *NameLength,\n         SQLSMALLINT          *DataType,\n         SQLULEN              *ColumnSize,\n         SQLSMALLINT          *DecimalDigits,\n         SQLSMALLINT          *Nullable);\n\n      ep_SQLDescribeCol *fn;\n      fn = (ep_SQLDescribeCol *) xdlsym(h_odbc, \"SQLDescribeCol\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnNumber, ColumnName,\n         BufferLength, NameLength,\n         DataType, ColumnSize, DecimalDigits, Nullable);\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLGetDiagRec": {
      "start_point": [
        542,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLGetDiagRec (\n   SQLSMALLINT           HandleType,\n   SQLHANDLE             Handle,\n   SQLSMALLINT           RecNumber,\n   SQLCHAR              *Sqlstate,\n   SQLINTEGER           *NativeError,\n   SQLCHAR              *MessageText,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT          *TextLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLGetDiagRec (\n         SQLSMALLINT           HandleType,\n         SQLHANDLE             Handle,\n         SQLSMALLINT           RecNumber,\n         SQLCHAR              *Sqlstate,\n         SQLINTEGER           *NativeError,\n         SQLCHAR              *MessageText,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *TextLength);\n\n      ep_SQLGetDiagRec *fn;\n      fn = (ep_SQLGetDiagRec *) xdlsym(h_odbc, \"SQLGetDiagRec\");\n      xassert(fn != NULL);\n      return (*fn)(HandleType, Handle, RecNumber, Sqlstate,\n         NativeError, MessageText, BufferLength, TextLength);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLGetInfo": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        588,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLGetInfo (\n   SQLHDBC               ConnectionHandle,\n   SQLUSMALLINT          InfoType,\n   SQLPOINTER            InfoValue,\n   SQLSMALLINT           BufferLength,\n   SQLSMALLINT          *StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLGetInfo (\n         SQLHDBC               ConnectionHandle,\n         SQLUSMALLINT          InfoType,\n         SQLPOINTER            InfoValue,\n         SQLSMALLINT           BufferLength,\n         SQLSMALLINT          *StringLength);\n\n      ep_SQLGetInfo *fn;\n      fn = (ep_SQLGetInfo *) xdlsym(h_odbc, \"SQLGetInfo\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle, InfoType, InfoValue, BufferLength,\n         StringLength);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLNumResultCols": {
      "start_point": [
        590,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLNumResultCols (\n   SQLHSTMT              StatementHandle,\n   SQLSMALLINT          *ColumnCount)\n{\n      typedef SQLRETURN SQL_API ep_SQLNumResultCols (\n         SQLHSTMT              StatementHandle,\n         SQLSMALLINT          *ColumnCount);\n\n      ep_SQLNumResultCols *fn;\n      fn = (ep_SQLNumResultCols *) xdlsym(h_odbc, \"SQLNumResultCols\");\n      xassert(fn != NULL);\n      return (*fn)(StatementHandle, ColumnCount);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLSetConnectAttr": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLSetConnectAttr (\n   SQLHDBC               ConnectionHandle,\n   SQLINTEGER            Attribute,\n   SQLPOINTER            Value,\n   SQLINTEGER            StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLSetConnectAttr (\n         SQLHDBC               ConnectionHandle,\n         SQLINTEGER            Attribute,\n         SQLPOINTER            Value,\n         SQLINTEGER            StringLength);\n\n      ep_SQLSetConnectAttr *fn;\n     fn = (ep_SQLSetConnectAttr *) xdlsym(h_odbc, \"SQLSetConnectAttr\");\n      xassert(fn != NULL);\n      return (*fn)(ConnectionHandle, Attribute, Value, StringLength);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "dl_SQLSetEnvAttr": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "SQLRETURN SQL_API dl_SQLSetEnvAttr (\n   SQLHENV               EnvironmentHandle,\n   SQLINTEGER            Attribute,\n   SQLPOINTER            Value,\n   SQLINTEGER            StringLength)\n{\n      typedef SQLRETURN SQL_API ep_SQLSetEnvAttr (\n         SQLHENV               EnvironmentHandle,\n         SQLINTEGER            Attribute,\n         SQLPOINTER            Value,\n         SQLINTEGER            StringLength);\n\n      ep_SQLSetEnvAttr *fn;\n      fn = (ep_SQLSetEnvAttr *) xdlsym(h_odbc, \"SQLSetEnvAttr\");\n      xassert(fn != NULL);\n      return (*fn)(EnvironmentHandle, Attribute, Value, StringLength);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "SQLRETURN",
        "SQL_API",
        "SQL_API"
      ]
    },
    "db_iodbc_open_int": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static void *db_iodbc_open_int(TABDCA *dca, int mode, const char\n   **sqllines)\n{\n   struct db_odbc    *sql;\n   SQLRETURN          ret;\n   SQLCHAR FAR       *dsn;\n   SQLCHAR            info[256];\n   SQLSMALLINT        colnamelen;\n   SQLSMALLINT        nullable;\n   SQLSMALLINT        scale;\n   const char        *arg;\n   int                narg;\n   int                i, j;\n   int                total;\n\n   if (libodbc == NULL)\n   {\n      xprintf(\"No loader for shared ODBC library available\\n\");\n      return NULL;\n   }\n\n   if (h_odbc == NULL)\n   {\n      h_odbc = xdlopen(libodbc);\n      if (h_odbc == NULL)\n      {  xprintf(\"unable to open library %s\\n\", libodbc);\n         xprintf(\"%s\\n\", get_err_msg());\n         return NULL;\n      }\n   }\n\n   sql = (struct db_odbc *) xmalloc(sizeof(struct db_odbc));\n   if (sql == NULL)\n         return NULL;\n\n   sql->mode  = mode;\n   sql->hdbc  = NULL;\n   sql->henv  = NULL;\n   sql->hstmt = NULL;\n   sql->query = NULL;\n   narg = mpl_tab_num_args(dca);\n\n   dsn = (SQLCHAR FAR *) mpl_tab_get_arg(dca, 2);\n   /* allocate an environment handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE,\n      &(sql->henv));\n   /* set attribute to enable application to run as ODBC 3.0\n      application */\n   ret = dl_SQLSetEnvAttr(sql->henv, SQL_ATTR_ODBC_VERSION,\n      (void *) SQL_OV_ODBC3, 0);\n   /* allocate a connection handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_DBC, sql->henv, &(sql->hdbc));\n   /* connect */\n   ret = dl_SQLDriverConnect(sql->hdbc, NULL, dsn, SQL_NTS, NULL, 0,\n      NULL, SQL_DRIVER_COMPLETE);\n   if (SQL_SUCCEEDED(ret))\n   {  /* output information about data base connection */\n      xprintf(\"Connected to \");\n      dl_SQLGetInfo(sql->hdbc, SQL_DBMS_NAME, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s \", info);\n      dl_SQLGetInfo(sql->hdbc, SQL_DBMS_VER, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s - \", info);\n      dl_SQLGetInfo(sql->hdbc, SQL_DATABASE_NAME, (SQLPOINTER)info,\n         sizeof(info), NULL);\n      xprintf(\"%s\\n\", info);\n   }\n   else\n   {  /* describe error */\n      xprintf(\"Failed to connect\\n\");\n      extract_error(\"SQLDriverConnect\", sql->hdbc, SQL_HANDLE_DBC);\n      dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n      dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n      xfree(sql);\n      return NULL;\n   }\n   /* set AUTOCOMMIT on*/\n   ret = dl_SQLSetConnectAttr(sql->hdbc, SQL_ATTR_AUTOCOMMIT,\n      (SQLPOINTER)SQL_AUTOCOMMIT_ON, 0);\n   /* allocate a statement handle */\n   ret = dl_SQLAllocHandle(SQL_HANDLE_STMT, sql->hdbc, &(sql->hstmt));\n\n   /* initialization queries */\n   for(j = 0; sqllines[j+1] != NULL; j++)\n   {\n      sql->query = (SQLCHAR *) sqllines[j];\n      xprintf(\"%s\\n\", sql->query);\n      ret = dl_SQLExecDirect(sql->hstmt, sql->query, SQL_NTS);\n      switch (ret)\n      {\n         case SQL_SUCCESS:\n         case SQL_SUCCESS_WITH_INFO:\n         case SQL_NO_DATA_FOUND:\n            break;\n         default:\n            xprintf(\"db_iodbc_open: Query\\n\\\"%s\\\"\\nfailed.\\n\",\n               sql->query);\n            extract_error(\"SQLExecDirect\", sql->hstmt, SQL_HANDLE_STMT);\n            dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n            dl_SQLDisconnect(sql->hdbc);\n            dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n            dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n            xfree(sql);\n            return NULL;\n      }\n      /* commit statement */\n      dl_SQLEndTran(SQL_HANDLE_ENV, sql->henv, SQL_COMMIT);\n   }\n\n   if ( sql->mode == 'R' )\n   {  sql->nf = mpl_tab_num_flds(dca);\n      for(j = 0; sqllines[j] != NULL; j++)\n         arg = sqllines[j];\n      total = strlen(arg);\n      if (total > 7 && 0 == strncmp(arg, \"SELECT \", 7))\n      {\n         total = strlen(arg);\n         sql->query = xmalloc( (total+1) * sizeof(char));\n         strcpy (sql->query, arg);\n      }\n      else\n      {\n         sql->query = db_generate_select_stmt(dca);\n      }\n      xprintf(\"%s\\n\", sql->query);\n      if (dl_SQLExecDirect(sql->hstmt, sql->query, SQL_NTS) !=\n         SQL_SUCCESS)\n      {\n         xprintf(\"db_iodbc_open: Query\\n\\\"%s\\\"\\nfailed.\\n\", sql->query);\n         extract_error(\"SQLExecDirect\", sql->hstmt, SQL_HANDLE_STMT);\n         dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n         dl_SQLDisconnect(sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n         xfree(sql->query);\n            xfree(sql);\n         return NULL;\n      }\n      xfree(sql->query);\n      /* determine number of result columns */\n      ret = dl_SQLNumResultCols(sql->hstmt, &sql->nresultcols);\n      total = sql->nresultcols;\n      if (total > SQL_FIELD_MAX)\n      {  xprintf(\"db_iodbc_open: Too many fields (> %d) in query.\\n\"\n            \"\\\"%s\\\"\\n\", SQL_FIELD_MAX, sql->query);\n         dl_SQLFreeHandle(SQL_HANDLE_STMT, sql->hstmt);\n         dl_SQLDisconnect(sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_DBC, sql->hdbc);\n         dl_SQLFreeHandle(SQL_HANDLE_ENV, sql->henv);\n         xfree(sql->query);\n         return NULL;\n      }\n      for (i = 1; i <= total; i++)\n      {  /* return a set of attributes for a column */\n         ret = dl_SQLDescribeCol(sql->hstmt, (SQLSMALLINT) i,\n            sql->colname[i], SQL_FDLEN_MAX,\n            &colnamelen, &(sql->coltype[i]), &(sql->collen[i]), &scale,\n            &nullable);\n         sql->isnumeric[i] = is_numeric(sql->coltype[i]);\n         /* bind columns to program vars, converting all types to CHAR*/\n         if (sql->isnumeric[i])\n#if 0 /* 12/I-2014 */\n         {  dl_SQLBindCol(sql->hstmt, i, SQL_DOUBLE, sql->data[i],\n#else\n         {  dl_SQLBindCol(sql->hstmt, i, SQL_DOUBLE, &sql->datanum[i],\n#endif\n               SQL_FDLEN_MAX, &(sql->outlen[i]));\n         } else\n         {  dl_SQLBindCol(sql->hstmt, i, SQL_CHAR, sql->data[i],\n               SQL_FDLEN_MAX, &(sql->outlen[i]));\n         }\n         for (j = sql->nf; j >= 1; j--)\n         {  if (strcmp(mpl_tab_get_name(dca, j), sql->colname[i]) == 0)\n            break;\n         }\n         sql->ref[i] = j;\n      }\n   }\n   else if ( sql->mode == 'W' )\n   {  for(j = 0; sqllines[j] != NULL; j++)\n         arg = sqllines[j];\n      if (  NULL != strchr(arg, '?') )\n      {\n         total = strlen(arg);\n         sql->query = xmalloc( (total+1) * sizeof(char));\n         strcpy (sql->query, arg);\n         }\n      else\n      {\n         sql->query = db_generate_insert_stmt(dca);\n      }\n      xprintf(\"%s\\n\", sql->query);\n   }\n   return sql;\n}",
      "lines": 196,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void",
        "*db_iodbc_open_int(TABDCA *dca, int mode, const char\n   **sqllines)",
        "*"
      ]
    },
    "extract_error": {
      "start_point": [
        1034,
        0
      ],
      "end_point": [
        1057,
        1
      ],
      "content": "static void extract_error(\n   char *fn,\n   SQLHANDLE handle,\n   SQLSMALLINT type)\n{\n   SQLINTEGER   i = 0;\n   SQLINTEGER   native;\n   SQLCHAR   state[ 7 ];\n   SQLCHAR   text[256];\n   SQLSMALLINT  len;\n   SQLRETURN    ret;\n\n   xprintf(\"\\nThe driver reported the following diagnostics whilst \"\n      \"running %s\\n\", fn);\n\n   do\n   {\n      ret = dl_SQLGetDiagRec(type, handle, ++i, state, &native, text,\n         sizeof(text), &len );\n      if (SQL_SUCCEEDED(ret))\n         xprintf(\"%s:%ld:%ld:%s\\n\", state, i, native, text);\n   }\n   while( ret == SQL_SUCCESS );\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_numeric": {
      "start_point": [
        1059,
        0
      ],
      "end_point": [
        1077,
        1
      ],
      "content": "static int is_numeric(SQLSMALLINT coltype)\n{\n   int ret = 0;\n   switch (coltype)\n   {\n      case SQL_DECIMAL:\n      case SQL_NUMERIC:\n      case SQL_SMALLINT:\n      case SQL_INTEGER:\n      case SQL_REAL:\n      case SQL_FLOAT:\n      case SQL_DOUBLE:\n      case SQL_TINYINT:\n      case SQL_BIGINT:\n         ret = 1;\n         break;\n   }\n   return ret;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "db_mysql_open": [
      {
        "start_point": [
          1085,
          0
        ],
        "end_point": [
          1090,
          1
        ],
        "content": "void *db_mysql_open(TABDCA *dca, int mode)\n{     xassert(dca == dca);\n      xassert(mode == mode);\n      xprintf(\"MySQL table driver not supported\\n\");\n      return NULL;\n}",
        "lines": 6,
        "depth": 7,
        "decorators": [
          "void",
          "*db_mysql_open(TABDCA *dca, int mode)",
          "*"
        ]
      },
      {
        "start_point": [
          1290,
          0
        ],
        "end_point": [
          1303,
          1
        ],
        "content": "void *db_mysql_open(TABDCA *dca, int mode)\n{  void  *ret;\n   char **sqllines;\n\n   sqllines = args_concat(dca);\n   if (sqllines == NULL)\n   {  xprintf(\"Missing arguments in table statement.\\n\"\n              \"Please, supply table driver, dsn, and query.\\n\");\n      return NULL;\n   }\n   ret = db_mysql_open_int(dca, mode, (const char **) sqllines);\n   free_buffer(sqllines);\n   return ret;\n}",
        "lines": 14,
        "depth": 11,
        "decorators": [
          "void",
          "*db_mysql_open(TABDCA *dca, int mode)",
          "*"
        ]
      }
    ],
    "db_mysql_read": [
      {
        "start_point": [
          1092,
          0
        ],
        "end_point": [
          1096,
          1
        ],
        "content": "int db_mysql_read(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1510,
          0
        ],
        "end_point": [
          1560,
          1
        ],
        "content": "int db_mysql_read(TABDCA *dca, void *link)\n{  struct db_mysql *sql;\n   char            buf[255+1];\n   char            **row;\n   unsigned long   *lengths;\n   MYSQL_FIELD     *fields;\n   double          num;\n   int             len;\n   unsigned long   num_fields;\n   int             i;\n\n   sql = (struct db_mysql *) link;\n\n   xassert(sql != NULL);\n   xassert(sql->mode == 'R');\n   if (NULL == sql->res)\n   {\n      xprintf(\"db_mysql_read: no result set available\");\n      return 1;\n   }\n   if (NULL==(row = (char **)dl_mysql_fetch_row(sql->res))) {\n       return -1; /*EOF*/\n   }\n   lengths = dl_mysql_fetch_lengths(sql->res);\n   fields = dl_mysql_fetch_fields(sql->res);\n   num_fields = dl_mysql_num_fields(sql->res);\n   for (i=1; i <= num_fields; i++)\n   {\n      if (row[i-1] != NULL)\n      {  len = (size_t) lengths[i-1];\n         if (len > 255)\n            len = 255;\n         strncpy(buf, (const char *) row[i-1], len);\n         buf[len] = 0x00;\n         if (0 != (fields[i-1].flags & NUM_FLAG))\n         {  strspx(buf); /* remove spaces*/\n            if (str2num(buf, &num) != 0)\n            {  xprintf(\"'%s' cannot be converted to a number.\\n\", buf);\n               return 1;\n            }\n            if (sql->ref[i] > 0)\n               mpl_tab_set_num(dca, sql->ref[i], num);\n         }\n         else\n         {  if (sql->ref[i] > 0)\n               mpl_tab_set_str(dca, sql->ref[i], strtrim(buf));\n         }\n      }\n   }\n   return 0;\n}",
        "lines": 51,
        "depth": 15,
        "decorators": [
          "int"
        ]
      }
    ],
    "db_mysql_write": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1102,
        1
      ],
      "content": "int db_mysql_write(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "db_mysql_close": [
      {
        "start_point": [
          1104,
          0
        ],
        "end_point": [
          1108,
          1
        ],
        "content": "int db_mysql_close(TABDCA *dca, void *link)\n{     xassert(dca != dca);\n      xassert(link != link);\n      return 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          1642,
          0
        ],
        "end_point": [
          1654,
          1
        ],
        "content": "int db_mysql_close(TABDCA *dca, void *link)\n{\n   struct db_mysql *sql;\n\n   sql = (struct db_mysql *) link;\n   xassert(sql != NULL);\n   dl_mysql_close(sql->con);\n   if ( sql->mode == 'W' )\n      xfree(sql->query);\n   xfree(sql);\n   dca->link = NULL;\n   return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "dl_mysql_close": {
      "start_point": [
        1141,
        0
      ],
      "end_point": [
        1149,
        1
      ],
      "content": "void STDCALL dl_mysql_close(MYSQL *sock)\n{\n      typedef void STDCALL ep_mysql_close(MYSQL *sock);\n\n      ep_mysql_close *fn;\n      fn = (ep_mysql_close *) xdlsym(h_mysql, \"mysql_close\");\n      xassert(fn != NULL);\n      return (*fn)(sock);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_error": {
      "start_point": [
        1151,
        0
      ],
      "end_point": [
        1159,
        1
      ],
      "content": "const char * STDCALL dl_mysql_error(MYSQL *mysql)\n{\n      typedef const char * STDCALL ep_mysql_error(MYSQL *mysql);\n\n      ep_mysql_error *fn;\n      fn = (ep_mysql_error *) xdlsym(h_mysql, \"mysql_error\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "* STDCALL dl_mysql_error(MYSQL *mysql)",
        "*",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_fetch_lengths": {
      "start_point": [
        1172,
        0
      ],
      "end_point": [
        1182,
        1
      ],
      "content": "unsigned long * STDCALL dl_mysql_fetch_lengths(MYSQL_RES *result)\n{\n      typedef unsigned long * STDCALL\n         ep_mysql_fetch_lengths(MYSQL_RES *result);\n\n      ep_mysql_fetch_lengths *fn;\n      fn = (ep_mysql_fetch_lengths *) xdlsym(h_mysql,\n         \"mysql_fetch_lengths\");\n      xassert(fn != NULL);\n      return (*fn)(result);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long",
        "* STDCALL dl_mysql_fetch_lengths(MYSQL_RES *result)",
        "*",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_fetch_row": {
      "start_point": [
        1184,
        0
      ],
      "end_point": [
        1192,
        1
      ],
      "content": "MYSQL_ROW STDCALL dl_mysql_fetch_row(MYSQL_RES *result)\n{\n      typedef MYSQL_ROW STDCALL ep_mysql_fetch_row(MYSQL_RES *result);\n\n      ep_mysql_fetch_row *fn;\n      fn = (ep_mysql_fetch_row *) xdlsym(h_mysql, \"mysql_fetch_row\");\n      xassert(fn != NULL);\n      return (*fn)(result);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "MYSQL_ROW",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_field_count": {
      "start_point": [
        1194,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "unsigned int STDCALL dl_mysql_field_count(MYSQL *mysql)\n{\n      typedef unsigned int STDCALL ep_mysql_field_count(MYSQL *mysql);\n\n      ep_mysql_field_count *fn;\n     fn = (ep_mysql_field_count *) xdlsym(h_mysql, \"mysql_field_count\");\n      xassert(fn != NULL);\n      return (*fn)(mysql);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_num_fields": {
      "start_point": [
        1214,
        0
      ],
      "end_point": [
        1222,
        1
      ],
      "content": "unsigned int STDCALL dl_mysql_num_fields(MYSQL_RES *res)\n{\n      typedef unsigned int STDCALL ep_mysql_num_fields(MYSQL_RES *res);\n\n      ep_mysql_num_fields *fn;\n      fn = (ep_mysql_num_fields *) xdlsym(h_mysql, \"mysql_num_fields\");\n      xassert(fn != NULL);\n      return (*fn)(res);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "unsigned int",
        "unsigned",
        "int",
        "STDCALL",
        "STDCALL"
      ]
    },
    "dl_mysql_query": {
      "start_point": [
        1224,
        0
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "int STDCALL dl_mysql_query(MYSQL *mysql, const char *q)\n{\n      typedef int STDCALL ep_mysql_query(MYSQL *mysql, const char *q);\n\n      ep_mysql_query *fn;\n      fn = (ep_mysql_query *) xdlsym(h_mysql, \"mysql_query\");\n      xassert(fn != NULL);\n      return (*fn)(mysql, q);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "STDCALL",
        "STDCALL"
      ]
    }
  },
  "glpk/glpk-4.65/src/mpl/mplsql.h": {},
  "glpk/glpk-4.65/src/npp/npp.h": {},
  "glpk/glpk-4.65/src/npp/npp1.c": {
    "npp_create_wksp": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "NPP *npp_create_wksp(void)\n{     /* create LP/MIP preprocessor workspace */\n      NPP *npp;\n      npp = xmalloc(sizeof(NPP));\n      npp->orig_dir = 0;\n      npp->orig_m = npp->orig_n = npp->orig_nnz = 0;\n      npp->pool = dmp_create_pool();\n      npp->name = npp->obj = NULL;\n      npp->c0 = 0.0;\n      npp->nrows = npp->ncols = 0;\n      npp->r_head = npp->r_tail = NULL;\n      npp->c_head = npp->c_tail = NULL;\n      npp->stack = dmp_create_pool();\n      npp->top = NULL;\n#if 0 /* 16/XII-2009 */\n      memset(&npp->count, 0, sizeof(npp->count));\n#endif\n      npp->m = npp->n = npp->nnz = 0;\n      npp->row_ref = npp->col_ref = NULL;\n      npp->sol = npp->scaling = 0;\n      npp->p_stat = npp->d_stat = npp->t_stat = npp->i_stat = 0;\n      npp->r_stat = NULL;\n      /*npp->r_prim =*/ npp->r_pi = NULL;\n      npp->c_stat = NULL;\n      npp->c_value = /*npp->c_dual =*/ NULL;\n      return npp;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "NPP",
        "*npp_create_wksp(void)",
        "*"
      ]
    },
    "npp_insert_row": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void npp_insert_row(NPP *npp, NPPROW *row, int where)\n{     /* insert row to the row list */\n      if (where == 0)\n      {  /* insert row to the beginning of the row list */\n         row->prev = NULL;\n         row->next = npp->r_head;\n         if (row->next == NULL)\n            npp->r_tail = row;\n         else\n            row->next->prev = row;\n         npp->r_head = row;\n      }\n      else\n      {  /* insert row to the end of the row list */\n         row->prev = npp->r_tail;\n         row->next = NULL;\n         if (row->prev == NULL)\n            npp->r_head = row;\n         else\n            row->prev->next = row;\n         npp->r_tail = row;\n      }\n      return;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "npp_remove_row": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void npp_remove_row(NPP *npp, NPPROW *row)\n{     /* remove row from the row list */\n      if (row->prev == NULL)\n         npp->r_head = row->next;\n      else\n         row->prev->next = row->next;\n      if (row->next == NULL)\n         npp->r_tail = row->prev;\n      else\n         row->next->prev = row->prev;\n      return;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_activate_row": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void npp_activate_row(NPP *npp, NPPROW *row)\n{     /* make row active */\n      if (!row->temp)\n      {  row->temp = 1;\n         /* move the row to the beginning of the row list */\n         npp_remove_row(npp, row);\n         npp_insert_row(npp, row, 0);\n      }\n      return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_deactivate_row": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void npp_deactivate_row(NPP *npp, NPPROW *row)\n{     /* make row inactive */\n      if (row->temp)\n      {  row->temp = 0;\n         /* move the row to the end of the row list */\n         npp_remove_row(npp, row);\n         npp_insert_row(npp, row, 1);\n      }\n      return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_insert_col": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void npp_insert_col(NPP *npp, NPPCOL *col, int where)\n{     /* insert column to the column list */\n      if (where == 0)\n      {  /* insert column to the beginning of the column list */\n         col->prev = NULL;\n         col->next = npp->c_head;\n         if (col->next == NULL)\n            npp->c_tail = col;\n         else\n            col->next->prev = col;\n         npp->c_head = col;\n      }\n      else\n      {  /* insert column to the end of the column list */\n         col->prev = npp->c_tail;\n         col->next = NULL;\n         if (col->prev == NULL)\n            npp->c_head = col;\n         else\n            col->prev->next = col;\n         npp->c_tail = col;\n      }\n      return;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "npp_remove_col": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void npp_remove_col(NPP *npp, NPPCOL *col)\n{     /* remove column from the column list */\n      if (col->prev == NULL)\n         npp->c_head = col->next;\n      else\n         col->prev->next = col->next;\n      if (col->next == NULL)\n         npp->c_tail = col->prev;\n      else\n         col->next->prev = col->prev;\n      return;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_activate_col": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void npp_activate_col(NPP *npp, NPPCOL *col)\n{     /* make column active */\n      if (!col->temp)\n      {  col->temp = 1;\n         /* move the column to the beginning of the column list */\n         npp_remove_col(npp, col);\n         npp_insert_col(npp, col, 0);\n      }\n      return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_deactivate_col": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void npp_deactivate_col(NPP *npp, NPPCOL *col)\n{     /* make column inactive */\n      if (col->temp)\n      {  col->temp = 0;\n         /* move the column to the end of the column list */\n         npp_remove_col(npp, col);\n         npp_insert_col(npp, col, 1);\n      }\n      return;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_add_row": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "NPPROW *npp_add_row(NPP *npp)\n{     /* add new row to the current problem */\n      NPPROW *row;\n      row = dmp_get_atom(npp->pool, sizeof(NPPROW));\n      row->i = ++(npp->nrows);\n      row->name = NULL;\n      row->lb = -DBL_MAX, row->ub = +DBL_MAX;\n      row->ptr = NULL;\n      row->temp = 0;\n      npp_insert_row(npp, row, 1);\n      return row;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "NPPROW",
        "*npp_add_row(NPP *npp)",
        "*"
      ]
    },
    "npp_add_col": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "NPPCOL *npp_add_col(NPP *npp)\n{     /* add new column to the current problem */\n      NPPCOL *col;\n      col = dmp_get_atom(npp->pool, sizeof(NPPCOL));\n      col->j = ++(npp->ncols);\n      col->name = NULL;\n#if 0\n      col->kind = GLP_CV;\n#else\n      col->is_int = 0;\n#endif\n      col->lb = col->ub = col->coef = 0.0;\n      col->ptr = NULL;\n      col->temp = 0;\n      npp_insert_col(npp, col, 1);\n      return col;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "NPPCOL",
        "*npp_add_col(NPP *npp)",
        "*"
      ]
    },
    "npp_add_aij": {
      "start_point": [
        205,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "NPPAIJ *npp_add_aij(NPP *npp, NPPROW *row, NPPCOL *col, double val)\n{     /* add new element to the constraint matrix */\n      NPPAIJ *aij;\n      aij = dmp_get_atom(npp->pool, sizeof(NPPAIJ));\n      aij->row = row;\n      aij->col = col;\n      aij->val = val;\n      aij->r_prev = NULL;\n      aij->r_next = row->ptr;\n      aij->c_prev = NULL;\n      aij->c_next = col->ptr;\n      if (aij->r_next != NULL)\n         aij->r_next->r_prev = aij;\n      if (aij->c_next != NULL)\n         aij->c_next->c_prev = aij;\n      row->ptr = col->ptr = aij;\n      return aij;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "NPPAIJ",
        "*npp_add_aij(NPP *npp, NPPROW *row, NPPCOL *col, double val)",
        "*"
      ]
    },
    "npp_row_nnz": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "int npp_row_nnz(NPP *npp, NPPROW *row)\n{     /* count number of non-zero coefficients in row */\n      NPPAIJ *aij;\n      int nnz;\n      xassert(npp == npp);\n      nnz = 0;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         nnz++;\n      return nnz;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "npp_col_nnz": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "int npp_col_nnz(NPP *npp, NPPCOL *col)\n{     /* count number of non-zero coefficients in column */\n      NPPAIJ *aij;\n      int nnz;\n      xassert(npp == npp);\n      nnz = 0;\n      for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n         nnz++;\n      return nnz;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "npp_push_tse": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "void *npp_push_tse(NPP *npp, int (*func)(NPP *npp, void *info),\n      int size)\n{     /* push new entry to the transformation stack */\n      NPPTSE *tse;\n      tse = dmp_get_atom(npp->stack, sizeof(NPPTSE));\n      tse->func = func;\n      tse->info = dmp_get_atom(npp->stack, size);\n      tse->link = npp->top;\n      npp->top = tse;\n      return tse->info;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*npp_push_tse(NPP *npp, int (*func)(NPP *npp, void *info),\n      int size)",
        "*"
      ]
    },
    "npp_erase_row": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "void npp_erase_row(NPP *npp, NPPROW *row)\n{     /* erase row content to make it empty */\n      NPPAIJ *aij;\n      while (row->ptr != NULL)\n      {  aij = row->ptr;\n         row->ptr = aij->r_next;\n         if (aij->c_prev == NULL)\n            aij->col->ptr = aij->c_next;\n         else\n            aij->c_prev->c_next = aij->c_next;\n         if (aij->c_next == NULL)\n            ;\n         else\n            aij->c_next->c_prev = aij->c_prev;\n         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));\n      }\n      return;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "npp_del_row": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void npp_del_row(NPP *npp, NPPROW *row)\n{     /* remove row from the current problem */\n#if 0 /* 23/XII-2009 */\n      NPPAIJ *aij;\n#endif\n      if (row->name != NULL)\n         dmp_free_atom(npp->pool, row->name, strlen(row->name)+1);\n#if 0 /* 23/XII-2009 */\n      while (row->ptr != NULL)\n      {  aij = row->ptr;\n         row->ptr = aij->r_next;\n         if (aij->c_prev == NULL)\n            aij->col->ptr = aij->c_next;\n         else\n            aij->c_prev->c_next = aij->c_next;\n         if (aij->c_next == NULL)\n            ;\n         else\n            aij->c_next->c_prev = aij->c_prev;\n         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));\n      }\n#else\n      npp_erase_row(npp, row);\n#endif\n      npp_remove_row(npp, row);\n      dmp_free_atom(npp->pool, row, sizeof(NPPROW));\n      return;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "npp_del_col": {
      "start_point": [
        308,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void npp_del_col(NPP *npp, NPPCOL *col)\n{     /* remove column from the current problem */\n      NPPAIJ *aij;\n      if (col->name != NULL)\n         dmp_free_atom(npp->pool, col->name, strlen(col->name)+1);\n      while (col->ptr != NULL)\n      {  aij = col->ptr;\n         col->ptr = aij->c_next;\n         if (aij->r_prev == NULL)\n            aij->row->ptr = aij->r_next;\n         else\n            aij->r_prev->r_next = aij->r_next;\n         if (aij->r_next == NULL)\n            ;\n         else\n            aij->r_next->r_prev = aij->r_prev;\n         dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));\n      }\n      npp_remove_col(npp, col);\n      dmp_free_atom(npp->pool, col, sizeof(NPPCOL));\n      return;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "npp_del_aij": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "void npp_del_aij(NPP *npp, NPPAIJ *aij)\n{     /* remove element from the constraint matrix */\n      if (aij->r_prev == NULL)\n         aij->row->ptr = aij->r_next;\n      else\n         aij->r_prev->r_next = aij->r_next;\n      if (aij->r_next == NULL)\n         ;\n      else\n         aij->r_next->r_prev = aij->r_prev;\n      if (aij->c_prev == NULL)\n         aij->col->ptr = aij->c_next;\n      else\n         aij->c_prev->c_next = aij->c_next;\n      if (aij->c_next == NULL)\n         ;\n      else\n         aij->c_next->c_prev = aij->c_prev;\n      dmp_free_atom(npp->pool, aij, sizeof(NPPAIJ));\n      return;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "npp_load_prob": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "void npp_load_prob(NPP *npp, glp_prob *orig, int names, int sol,\n      int scaling)\n{     /* load original problem into the preprocessor workspace */\n      int m = orig->m;\n      int n = orig->n;\n      NPPROW **link;\n      int i, j;\n      double dir;\n      xassert(names == GLP_OFF || names == GLP_ON);\n      xassert(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP);\n      xassert(scaling == GLP_OFF || scaling == GLP_ON);\n      if (sol == GLP_MIP) xassert(!scaling);\n      npp->orig_dir = orig->dir;\n      if (npp->orig_dir == GLP_MIN)\n         dir = +1.0;\n      else if (npp->orig_dir == GLP_MAX)\n         dir = -1.0;\n      else\n         xassert(npp != npp);\n      npp->orig_m = m;\n      npp->orig_n = n;\n      npp->orig_nnz = orig->nnz;\n      if (names && orig->name != NULL)\n      {  npp->name = dmp_get_atom(npp->pool, strlen(orig->name)+1);\n         strcpy(npp->name, orig->name);\n      }\n      if (names && orig->obj != NULL)\n      {  npp->obj = dmp_get_atom(npp->pool, strlen(orig->obj)+1);\n         strcpy(npp->obj, orig->obj);\n      }\n      npp->c0 = dir * orig->c0;\n      /* load rows */\n      link = xcalloc(1+m, sizeof(NPPROW *));\n      for (i = 1; i <= m; i++)\n      {  GLPROW *rrr = orig->row[i];\n         NPPROW *row;\n         link[i] = row = npp_add_row(npp);\n         xassert(row->i == i);\n         if (names && rrr->name != NULL)\n         {  row->name = dmp_get_atom(npp->pool, strlen(rrr->name)+1);\n            strcpy(row->name, rrr->name);\n         }\n         if (!scaling)\n         {  if (rrr->type == GLP_FR)\n               row->lb = -DBL_MAX, row->ub = +DBL_MAX;\n            else if (rrr->type == GLP_LO)\n               row->lb = rrr->lb, row->ub = +DBL_MAX;\n            else if (rrr->type == GLP_UP)\n               row->lb = -DBL_MAX, row->ub = rrr->ub;\n            else if (rrr->type == GLP_DB)\n               row->lb = rrr->lb, row->ub = rrr->ub;\n            else if (rrr->type == GLP_FX)\n               row->lb = row->ub = rrr->lb;\n            else\n               xassert(rrr != rrr);\n         }\n         else\n         {  double rii = rrr->rii;\n            if (rrr->type == GLP_FR)\n               row->lb = -DBL_MAX, row->ub = +DBL_MAX;\n            else if (rrr->type == GLP_LO)\n               row->lb = rrr->lb * rii, row->ub = +DBL_MAX;\n            else if (rrr->type == GLP_UP)\n               row->lb = -DBL_MAX, row->ub = rrr->ub * rii;\n            else if (rrr->type == GLP_DB)\n               row->lb = rrr->lb * rii, row->ub = rrr->ub * rii;\n            else if (rrr->type == GLP_FX)\n               row->lb = row->ub = rrr->lb * rii;\n            else\n               xassert(rrr != rrr);\n         }\n      }\n      /* load columns and constraint coefficients */\n      for (j = 1; j <= n; j++)\n      {  GLPCOL *ccc = orig->col[j];\n         GLPAIJ *aaa;\n         NPPCOL *col;\n         col = npp_add_col(npp);\n         xassert(col->j == j);\n         if (names && ccc->name != NULL)\n         {  col->name = dmp_get_atom(npp->pool, strlen(ccc->name)+1);\n            strcpy(col->name, ccc->name);\n         }\n         if (sol == GLP_MIP)\n#if 0\n            col->kind = ccc->kind;\n#else\n            col->is_int = (char)(ccc->kind == GLP_IV);\n#endif\n         if (!scaling)\n         {  if (ccc->type == GLP_FR)\n               col->lb = -DBL_MAX, col->ub = +DBL_MAX;\n            else if (ccc->type == GLP_LO)\n               col->lb = ccc->lb, col->ub = +DBL_MAX;\n            else if (ccc->type == GLP_UP)\n               col->lb = -DBL_MAX, col->ub = ccc->ub;\n            else if (ccc->type == GLP_DB)\n               col->lb = ccc->lb, col->ub = ccc->ub;\n            else if (ccc->type == GLP_FX)\n               col->lb = col->ub = ccc->lb;\n            else\n               xassert(ccc != ccc);\n            col->coef = dir * ccc->coef;\n            for (aaa = ccc->ptr; aaa != NULL; aaa = aaa->c_next)\n               npp_add_aij(npp, link[aaa->row->i], col, aaa->val);\n         }\n         else\n         {  double sjj = ccc->sjj;\n            if (ccc->type == GLP_FR)\n               col->lb = -DBL_MAX, col->ub = +DBL_MAX;\n            else if (ccc->type == GLP_LO)\n               col->lb = ccc->lb / sjj, col->ub = +DBL_MAX;\n            else if (ccc->type == GLP_UP)\n               col->lb = -DBL_MAX, col->ub = ccc->ub / sjj;\n            else if (ccc->type == GLP_DB)\n               col->lb = ccc->lb / sjj, col->ub = ccc->ub / sjj;\n            else if (ccc->type == GLP_FX)\n               col->lb = col->ub = ccc->lb / sjj;\n            else\n               xassert(ccc != ccc);\n            col->coef = dir * ccc->coef * sjj;\n            for (aaa = ccc->ptr; aaa != NULL; aaa = aaa->c_next)\n               npp_add_aij(npp, link[aaa->row->i], col,\n                  aaa->row->rii * aaa->val * sjj);\n         }\n      }\n      xfree(link);\n      /* keep solution indicator and scaling option */\n      npp->sol = sol;\n      npp->scaling = scaling;\n      return;\n}",
      "lines": 132,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "npp_build_prob": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "void npp_build_prob(NPP *npp, glp_prob *prob)\n{     /* build resultant (preprocessed) problem */\n      NPPROW *row;\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int i, j, type, len, *ind;\n      double dir, *val;\n      glp_erase_prob(prob);\n      glp_set_prob_name(prob, npp->name);\n      glp_set_obj_name(prob, npp->obj);\n      glp_set_obj_dir(prob, npp->orig_dir);\n      if (npp->orig_dir == GLP_MIN)\n         dir = +1.0;\n      else if (npp->orig_dir == GLP_MAX)\n         dir = -1.0;\n      else\n         xassert(npp != npp);\n      glp_set_obj_coef(prob, 0, dir * npp->c0);\n      /* build rows */\n      for (row = npp->r_head; row != NULL; row = row->next)\n      {  row->temp = i = glp_add_rows(prob, 1);\n         glp_set_row_name(prob, i, row->name);\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n            type = GLP_FR;\n         else if (row->ub == +DBL_MAX)\n            type = GLP_LO;\n         else if (row->lb == -DBL_MAX)\n            type = GLP_UP;\n         else if (row->lb != row->ub)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_row_bnds(prob, i, type, row->lb, row->ub);\n      }\n      /* build columns and the constraint matrix */\n      ind = xcalloc(1+prob->m, sizeof(int));\n      val = xcalloc(1+prob->m, sizeof(double));\n      for (col = npp->c_head; col != NULL; col = col->next)\n      {  j = glp_add_cols(prob, 1);\n         glp_set_col_name(prob, j, col->name);\n#if 0\n         glp_set_col_kind(prob, j, col->kind);\n#else\n         glp_set_col_kind(prob, j, col->is_int ? GLP_IV : GLP_CV);\n#endif\n         if (col->lb == -DBL_MAX && col->ub == +DBL_MAX)\n            type = GLP_FR;\n         else if (col->ub == +DBL_MAX)\n            type = GLP_LO;\n         else if (col->lb == -DBL_MAX)\n            type = GLP_UP;\n         else if (col->lb != col->ub)\n            type = GLP_DB;\n         else\n            type = GLP_FX;\n         glp_set_col_bnds(prob, j, type, col->lb, col->ub);\n         glp_set_obj_coef(prob, j, dir * col->coef);\n         len = 0;\n         for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n         {  len++;\n            ind[len] = aij->row->temp;\n            val[len] = aij->val;\n         }\n         glp_set_mat_col(prob, j, len, ind, val);\n      }\n      xfree(ind);\n      xfree(val);\n      /* resultant problem has been built */\n      npp->m = prob->m;\n      npp->n = prob->n;\n      npp->nnz = prob->nnz;\n      npp->row_ref = xcalloc(1+npp->m, sizeof(int));\n      npp->col_ref = xcalloc(1+npp->n, sizeof(int));\n      for (row = npp->r_head, i = 0; row != NULL; row = row->next)\n         npp->row_ref[++i] = row->i;\n      for (col = npp->c_head, j = 0; col != NULL; col = col->next)\n         npp->col_ref[++j] = col->j;\n      /* transformed problem segment is no longer needed */\n      dmp_delete_pool(npp->pool), npp->pool = NULL;\n      npp->name = npp->obj = NULL;\n      npp->c0 = 0.0;\n      npp->r_head = npp->r_tail = NULL;\n      npp->c_head = npp->c_tail = NULL;\n      return;\n}",
      "lines": 85,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "npp_postprocess": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        698,
        1
      ],
      "content": "void npp_postprocess(NPP *npp, glp_prob *prob)\n{     /* postprocess solution from the resultant problem */\n      GLPROW *row;\n      GLPCOL *col;\n      NPPTSE *tse;\n      int i, j, k;\n      double dir;\n      xassert(npp->orig_dir == prob->dir);\n      if (npp->orig_dir == GLP_MIN)\n         dir = +1.0;\n      else if (npp->orig_dir == GLP_MAX)\n         dir = -1.0;\n      else\n         xassert(npp != npp);\n#if 0 /* 11/VII-2013; due to call from ios_main */\n      xassert(npp->m == prob->m);\n#else\n      if (npp->sol != GLP_MIP)\n         xassert(npp->m == prob->m);\n#endif\n      xassert(npp->n == prob->n);\n#if 0 /* 11/VII-2013; due to call from ios_main */\n      xassert(npp->nnz == prob->nnz);\n#else\n      if (npp->sol != GLP_MIP)\n         xassert(npp->nnz == prob->nnz);\n#endif\n      /* copy solution status */\n      if (npp->sol == GLP_SOL)\n      {  npp->p_stat = prob->pbs_stat;\n         npp->d_stat = prob->dbs_stat;\n      }\n      else if (npp->sol == GLP_IPT)\n         npp->t_stat = prob->ipt_stat;\n      else if (npp->sol == GLP_MIP)\n         npp->i_stat = prob->mip_stat;\n      else\n         xassert(npp != npp);\n      /* allocate solution arrays */\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat == NULL)\n            npp->r_stat = xcalloc(1+npp->nrows, sizeof(char));\n         for (i = 1; i <= npp->nrows; i++)\n            npp->r_stat[i] = 0;\n         if (npp->c_stat == NULL)\n            npp->c_stat = xcalloc(1+npp->ncols, sizeof(char));\n         for (j = 1; j <= npp->ncols; j++)\n            npp->c_stat[j] = 0;\n      }\n#if 0\n      if (npp->r_prim == NULL)\n         npp->r_prim = xcalloc(1+npp->nrows, sizeof(double));\n      for (i = 1; i <= npp->nrows; i++)\n         npp->r_prim[i] = DBL_MAX;\n#endif\n      if (npp->c_value == NULL)\n         npp->c_value = xcalloc(1+npp->ncols, sizeof(double));\n      for (j = 1; j <= npp->ncols; j++)\n         npp->c_value[j] = DBL_MAX;\n      if (npp->sol != GLP_MIP)\n      {  if (npp->r_pi == NULL)\n            npp->r_pi = xcalloc(1+npp->nrows, sizeof(double));\n         for (i = 1; i <= npp->nrows; i++)\n            npp->r_pi[i] = DBL_MAX;\n#if 0\n         if (npp->c_dual == NULL)\n            npp->c_dual = xcalloc(1+npp->ncols, sizeof(double));\n         for (j = 1; j <= npp->ncols; j++)\n            npp->c_dual[j] = DBL_MAX;\n#endif\n      }\n      /* copy solution components from the resultant problem */\n      if (npp->sol == GLP_SOL)\n      {  for (i = 1; i <= npp->m; i++)\n         {  row = prob->row[i];\n            k = npp->row_ref[i];\n            npp->r_stat[k] = (char)row->stat;\n            /*npp->r_prim[k] = row->prim;*/\n            npp->r_pi[k] = dir * row->dual;\n         }\n         for (j = 1; j <= npp->n; j++)\n         {  col = prob->col[j];\n            k = npp->col_ref[j];\n            npp->c_stat[k] = (char)col->stat;\n            npp->c_value[k] = col->prim;\n            /*npp->c_dual[k] = dir * col->dual;*/\n         }\n      }\n      else if (npp->sol == GLP_IPT)\n      {  for (i = 1; i <= npp->m; i++)\n         {  row = prob->row[i];\n            k = npp->row_ref[i];\n            /*npp->r_prim[k] = row->pval;*/\n            npp->r_pi[k] = dir * row->dval;\n         }\n         for (j = 1; j <= npp->n; j++)\n         {  col = prob->col[j];\n            k = npp->col_ref[j];\n            npp->c_value[k] = col->pval;\n            /*npp->c_dual[k] = dir * col->dval;*/\n         }\n      }\n      else if (npp->sol == GLP_MIP)\n      {\n#if 0\n         for (i = 1; i <= npp->m; i++)\n         {  row = prob->row[i];\n            k = npp->row_ref[i];\n            /*npp->r_prim[k] = row->mipx;*/\n         }\n#endif\n         for (j = 1; j <= npp->n; j++)\n         {  col = prob->col[j];\n            k = npp->col_ref[j];\n            npp->c_value[k] = col->mipx;\n         }\n      }\n      else\n         xassert(npp != npp);\n      /* perform postprocessing to construct solution to the original\n         problem */\n      for (tse = npp->top; tse != NULL; tse = tse->link)\n      {  xassert(tse->func != NULL);\n         xassert(tse->func(npp, tse->info) == 0);\n      }\n      return;\n}",
      "lines": 127,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "npp_unload_sol": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        904,
        1
      ],
      "content": "void npp_unload_sol(NPP *npp, glp_prob *orig)\n{     /* store solution to the original problem */\n      GLPROW *row;\n      GLPCOL *col;\n      int i, j;\n      double dir;\n      xassert(npp->orig_dir == orig->dir);\n      if (npp->orig_dir == GLP_MIN)\n         dir = +1.0;\n      else if (npp->orig_dir == GLP_MAX)\n         dir = -1.0;\n      else\n         xassert(npp != npp);\n      xassert(npp->orig_m == orig->m);\n      xassert(npp->orig_n == orig->n);\n      xassert(npp->orig_nnz == orig->nnz);\n      if (npp->sol == GLP_SOL)\n      {  /* store basic solution */\n         orig->valid = 0;\n         orig->pbs_stat = npp->p_stat;\n         orig->dbs_stat = npp->d_stat;\n         orig->obj_val = orig->c0;\n         orig->some = 0;\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            row->stat = npp->r_stat[i];\n            if (!npp->scaling)\n            {  /*row->prim = npp->r_prim[i];*/\n               row->dual = dir * npp->r_pi[i];\n            }\n            else\n            {  /*row->prim = npp->r_prim[i] / row->rii;*/\n               row->dual = dir * npp->r_pi[i] * row->rii;\n            }\n            if (row->stat == GLP_BS)\n               row->dual = 0.0;\n            else if (row->stat == GLP_NL)\n            {  xassert(row->type == GLP_LO || row->type == GLP_DB);\n               row->prim = row->lb;\n            }\n            else if (row->stat == GLP_NU)\n            {  xassert(row->type == GLP_UP || row->type == GLP_DB);\n               row->prim = row->ub;\n            }\n            else if (row->stat == GLP_NF)\n            {  xassert(row->type == GLP_FR);\n               row->prim = 0.0;\n            }\n            else if (row->stat == GLP_NS)\n            {  xassert(row->type == GLP_FX);\n               row->prim = row->lb;\n            }\n            else\n               xassert(row != row);\n         }\n         for (j = 1; j <= orig->n; j++)\n         {  col = orig->col[j];\n            col->stat = npp->c_stat[j];\n            if (!npp->scaling)\n            {  col->prim = npp->c_value[j];\n               /*col->dual = dir * npp->c_dual[j];*/\n            }\n            else\n            {  col->prim = npp->c_value[j] * col->sjj;\n               /*col->dual = dir * npp->c_dual[j] / col->sjj;*/\n            }\n            if (col->stat == GLP_BS)\n               col->dual = 0.0;\n#if 1\n            else if (col->stat == GLP_NL)\n            {  xassert(col->type == GLP_LO || col->type == GLP_DB);\n               col->prim = col->lb;\n            }\n            else if (col->stat == GLP_NU)\n            {  xassert(col->type == GLP_UP || col->type == GLP_DB);\n               col->prim = col->ub;\n            }\n            else if (col->stat == GLP_NF)\n            {  xassert(col->type == GLP_FR);\n               col->prim = 0.0;\n            }\n            else if (col->stat == GLP_NS)\n            {  xassert(col->type == GLP_FX);\n               col->prim = col->lb;\n            }\n            else\n               xassert(col != col);\n#endif\n            orig->obj_val += col->coef * col->prim;\n         }\n#if 1\n         /* compute primal values of inactive rows */\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            if (row->stat == GLP_BS)\n            {  GLPAIJ *aij;\n               double temp;\n               temp = 0.0;\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  temp += aij->val * aij->col->prim;\n               row->prim = temp;\n            }\n         }\n         /* compute reduced costs of active columns */\n         for (j = 1; j <= orig->n; j++)\n         {  col = orig->col[j];\n            if (col->stat != GLP_BS)\n            {  GLPAIJ *aij;\n               double temp;\n               temp = col->coef;\n               for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n                  temp -= aij->val * aij->row->dual;\n               col->dual = temp;\n            }\n         }\n#endif\n      }\n      else if (npp->sol == GLP_IPT)\n      {  /* store interior-point solution */\n         orig->ipt_stat = npp->t_stat;\n         orig->ipt_obj = orig->c0;\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            if (!npp->scaling)\n            {  /*row->pval = npp->r_prim[i];*/\n               row->dval = dir * npp->r_pi[i];\n            }\n            else\n            {  /*row->pval = npp->r_prim[i] / row->rii;*/\n               row->dval = dir * npp->r_pi[i] * row->rii;\n            }\n         }\n         for (j = 1; j <= orig->n; j++)\n         {  col = orig->col[j];\n            if (!npp->scaling)\n            {  col->pval = npp->c_value[j];\n               /*col->dval = dir * npp->c_dual[j];*/\n            }\n            else\n            {  col->pval = npp->c_value[j] * col->sjj;\n               /*col->dval = dir * npp->c_dual[j] / col->sjj;*/\n            }\n            orig->ipt_obj += col->coef * col->pval;\n         }\n#if 1\n         /* compute row primal values */\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            {  GLPAIJ *aij;\n               double temp;\n               temp = 0.0;\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  temp += aij->val * aij->col->pval;\n               row->pval = temp;\n            }\n         }\n         /* compute column dual values */\n         for (j = 1; j <= orig->n; j++)\n         {  col = orig->col[j];\n            {  GLPAIJ *aij;\n               double temp;\n               temp = col->coef;\n               for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n                  temp -= aij->val * aij->row->dval;\n               col->dval = temp;\n            }\n         }\n#endif\n      }\n      else if (npp->sol == GLP_MIP)\n      {  /* store MIP solution */\n         xassert(!npp->scaling);\n         orig->mip_stat = npp->i_stat;\n         orig->mip_obj = orig->c0;\n#if 0\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            /*row->mipx = npp->r_prim[i];*/\n         }\n#endif\n         for (j = 1; j <= orig->n; j++)\n         {  col = orig->col[j];\n            col->mipx = npp->c_value[j];\n            if (col->kind == GLP_IV)\n               xassert(col->mipx == floor(col->mipx));\n            orig->mip_obj += col->coef * col->mipx;\n         }\n#if 1\n         /* compute row primal values */\n         for (i = 1; i <= orig->m; i++)\n         {  row = orig->row[i];\n            {  GLPAIJ *aij;\n               double temp;\n               temp = 0.0;\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  temp += aij->val * aij->col->mipx;\n               row->mipx = temp;\n            }\n         }\n#endif\n      }\n      else\n         xassert(npp != npp);\n      return;\n}",
      "lines": 205,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "npp_delete_wksp": {
      "start_point": [
        906,
        0
      ],
      "end_point": [
        934,
        1
      ],
      "content": "void npp_delete_wksp(NPP *npp)\n{     /* delete LP/MIP preprocessor workspace */\n      if (npp->pool != NULL)\n         dmp_delete_pool(npp->pool);\n      if (npp->stack != NULL)\n         dmp_delete_pool(npp->stack);\n      if (npp->row_ref != NULL)\n         xfree(npp->row_ref);\n      if (npp->col_ref != NULL)\n         xfree(npp->col_ref);\n      if (npp->r_stat != NULL)\n         xfree(npp->r_stat);\n#if 0\n      if (npp->r_prim != NULL)\n         xfree(npp->r_prim);\n#endif\n      if (npp->r_pi != NULL)\n         xfree(npp->r_pi);\n      if (npp->c_stat != NULL)\n         xfree(npp->c_stat);\n      if (npp->c_value != NULL)\n         xfree(npp->c_value);\n#if 0\n      if (npp->c_dual != NULL)\n         xfree(npp->c_dual);\n#endif\n      xfree(npp);\n      return;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/npp/npp2.c": {
    "npp_free_row": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void npp_free_row(NPP *npp, NPPROW *p)\n{     /* process free (unbounded) row */\n      struct free_row *info;\n      /* the row must be free */\n      xassert(p->lb == -DBL_MAX && p->ub == +DBL_MAX);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_free_row, sizeof(struct free_row));\n      info->p = p->i;\n      /* remove the row from the problem */\n      npp_del_row(npp, p);\n      return;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rcv_free_row": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static int rcv_free_row(NPP *npp, void *_info)\n{     /* recover free (unbounded) row */\n      struct free_row *info = _info;\n      if (npp->sol == GLP_SOL)\n         npp->r_stat[info->p] = GLP_BS;\n      if (npp->sol != GLP_MIP)\n         npp->r_pi[info->p] = 0.0;\n      return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_geq_row": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void npp_geq_row(NPP *npp, NPPROW *p)\n{     /* process row of 'not less than' type */\n      struct ineq_row *info;\n      NPPCOL *s;\n      /* the row must have lower bound */\n      xassert(p->lb != -DBL_MAX);\n      xassert(p->lb < p->ub);\n      /* create column for surplus variable */\n      s = npp_add_col(npp);\n      s->lb = 0.0;\n      s->ub = (p->ub == +DBL_MAX ? +DBL_MAX : p->ub - p->lb);\n      /* and add it to the transformed problem */\n      npp_add_aij(npp, p, s, -1.0);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_geq_row, sizeof(struct ineq_row));\n      info->p = p->i;\n      info->s = s->j;\n      /* replace the row by equality constraint */\n      p->ub = p->lb;\n      return;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rcv_geq_row": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "static int rcv_geq_row(NPP *npp, void *_info)\n{     /* recover row of 'not less than' type */\n      struct ineq_row *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] == GLP_BS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n            {  npp_error();\n               return 1;\n            }\n            else if (npp->c_stat[info->s] == GLP_NL ||\n                     npp->c_stat[info->s] == GLP_NU)\n               npp->r_stat[info->p] = GLP_BS;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else if (npp->r_stat[info->p] == GLP_NS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n               npp->r_stat[info->p] = GLP_BS;\n            else if (npp->c_stat[info->s] == GLP_NL)\n               npp->r_stat[info->p] = GLP_NL;\n            else if (npp->c_stat[info->s] == GLP_NU)\n               npp->r_stat[info->p] = GLP_NU;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_leq_row": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "void npp_leq_row(NPP *npp, NPPROW *p)\n{     /* process row of 'not greater than' type */\n      struct ineq_row *info;\n      NPPCOL *s;\n      /* the row must have upper bound */\n      xassert(p->ub != +DBL_MAX);\n      xassert(p->lb < p->ub);\n      /* create column for slack variable */\n      s = npp_add_col(npp);\n      s->lb = 0.0;\n      s->ub = (p->lb == -DBL_MAX ? +DBL_MAX : p->ub - p->lb);\n      /* and add it to the transformed problem */\n      npp_add_aij(npp, p, s, +1.0);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_leq_row, sizeof(struct ineq_row));\n      info->p = p->i;\n      info->s = s->j;\n      /* replace the row by equality constraint */\n      p->lb = p->ub;\n      return;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rcv_leq_row": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static int rcv_leq_row(NPP *npp, void *_info)\n{     /* recover row of 'not greater than' type */\n      struct ineq_row *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] == GLP_BS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n            {  npp_error();\n               return 1;\n            }\n            else if (npp->c_stat[info->s] == GLP_NL ||\n                     npp->c_stat[info->s] == GLP_NU)\n               npp->r_stat[info->p] = GLP_BS;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else if (npp->r_stat[info->p] == GLP_NS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n               npp->r_stat[info->p] = GLP_BS;\n            else if (npp->c_stat[info->s] == GLP_NL)\n               npp->r_stat[info->p] = GLP_NU;\n            else if (npp->c_stat[info->s] == GLP_NU)\n               npp->r_stat[info->p] = GLP_NL;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_free_col": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "void npp_free_col(NPP *npp, NPPCOL *q)\n{     /* process free (unbounded) column */\n      struct free_col *info;\n      NPPCOL *s;\n      NPPAIJ *aij;\n      /* the column must be free */\n      xassert(q->lb == -DBL_MAX && q->ub == +DBL_MAX);\n      /* variable x[q] becomes s' */\n      q->lb = 0.0, q->ub = +DBL_MAX;\n      /* create variable s'' */\n      s = npp_add_col(npp);\n      s->is_int = q->is_int;\n      s->lb = 0.0, s->ub = +DBL_MAX;\n      /* duplicate objective coefficient */\n      s->coef = -q->coef;\n      /* duplicate column of the constraint matrix */\n      for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n         npp_add_aij(npp, aij->row, s, -aij->val);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_free_col, sizeof(struct free_col));\n      info->q = q->j;\n      info->s = s->j;\n      return;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rcv_free_col": {
      "start_point": [
        513,
        0
      ],
      "end_point": [
        547,
        1
      ],
      "content": "static int rcv_free_col(NPP *npp, void *_info)\n{     /* recover free (unbounded) column */\n      struct free_col *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->c_stat[info->q] == GLP_BS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n            {  npp_error();\n               return 1;\n            }\n            else if (npp->c_stat[info->s] == GLP_NL)\n               npp->c_stat[info->q] = GLP_BS;\n            else\n            {  npp_error();\n               return -1;\n            }\n         }\n         else if (npp->c_stat[info->q] == GLP_NL)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n               npp->c_stat[info->q] = GLP_BS;\n            else if (npp->c_stat[info->s] == GLP_NL)\n               npp->c_stat[info->q] = GLP_NF;\n            else\n            {  npp_error();\n               return -1;\n            }\n         }\n         else\n         {  npp_error();\n            return -1;\n         }\n      }\n      /* compute value of x[q] with formula (2) */\n      npp->c_value[info->q] -= npp->c_value[info->s];\n      return 0;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_lbnd_col": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "void npp_lbnd_col(NPP *npp, NPPCOL *q)\n{     /* process column with (non-zero) lower bound */\n      struct bnd_col *info;\n      NPPROW *i;\n      NPPAIJ *aij;\n      /* the column must have non-zero lower bound */\n      xassert(q->lb != 0.0);\n      xassert(q->lb != -DBL_MAX);\n      xassert(q->lb < q->ub);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_lbnd_col, sizeof(struct bnd_col));\n      info->q = q->j;\n      info->bnd = q->lb;\n      /* substitute x[q] into objective row */\n      npp->c0 += q->coef * q->lb;\n      /* substitute x[q] into constraint rows */\n      for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n      {  i = aij->row;\n         if (i->lb == i->ub)\n            i->ub = (i->lb -= aij->val * q->lb);\n         else\n         {  if (i->lb != -DBL_MAX)\n               i->lb -= aij->val * q->lb;\n            if (i->ub != +DBL_MAX)\n               i->ub -= aij->val * q->lb;\n         }\n      }\n      /* column x[q] becomes column s */\n      if (q->ub != +DBL_MAX)\n         q->ub -= q->lb;\n      q->lb = 0.0;\n      return;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rcv_lbnd_col": {
      "start_point": [
        680,
        0
      ],
      "end_point": [
        696,
        1
      ],
      "content": "static int rcv_lbnd_col(NPP *npp, void *_info)\n{     /* recover column with (non-zero) lower bound */\n      struct bnd_col *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->c_stat[info->q] == GLP_BS ||\n             npp->c_stat[info->q] == GLP_NL ||\n             npp->c_stat[info->q] == GLP_NU)\n            npp->c_stat[info->q] = npp->c_stat[info->q];\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      /* compute value of x[q] with formula (2) */\n      npp->c_value[info->q] = info->bnd + npp->c_value[info->q];\n      return 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_ubnd_col": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        849,
        1
      ],
      "content": "void npp_ubnd_col(NPP *npp, NPPCOL *q)\n{     /* process column with upper bound */\n      struct bnd_col *info;\n      NPPROW *i;\n      NPPAIJ *aij;\n      /* the column must have upper bound */\n      xassert(q->ub != +DBL_MAX);\n      xassert(q->lb < q->ub);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_ubnd_col, sizeof(struct bnd_col));\n      info->q = q->j;\n      info->bnd = q->ub;\n      /* substitute x[q] into objective row */\n      npp->c0 += q->coef * q->ub;\n      q->coef = -q->coef;\n      /* substitute x[q] into constraint rows */\n      for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n      {  i = aij->row;\n         if (i->lb == i->ub)\n            i->ub = (i->lb -= aij->val * q->ub);\n         else\n         {  if (i->lb != -DBL_MAX)\n               i->lb -= aij->val * q->ub;\n            if (i->ub != +DBL_MAX)\n               i->ub -= aij->val * q->ub;\n         }\n         aij->val = -aij->val;\n      }\n      /* column x[q] becomes column s */\n      if (q->lb != -DBL_MAX)\n         q->ub -= q->lb;\n      else\n         q->ub = +DBL_MAX;\n      q->lb = 0.0;\n      return;\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rcv_ubnd_col": {
      "start_point": [
        851,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "static int rcv_ubnd_col(NPP *npp, void *_info)\n{     /* recover column with upper bound */\n      struct bnd_col *info = _info;\n      if (npp->sol == GLP_BS)\n      {  if (npp->c_stat[info->q] == GLP_BS)\n            npp->c_stat[info->q] = GLP_BS;\n         else if (npp->c_stat[info->q] == GLP_NL)\n            npp->c_stat[info->q] = GLP_NU;\n         else if (npp->c_stat[info->q] == GLP_NU)\n            npp->c_stat[info->q] = GLP_NL;\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      /* compute value of x[q] with formula (2) */\n      npp->c_value[info->q] = info->bnd - npp->c_value[info->q];\n      return 0;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_dbnd_col": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "void npp_dbnd_col(NPP *npp, NPPCOL *q)\n{     /* process non-negative column with upper bound */\n      struct dbnd_col *info;\n      NPPROW *p;\n      NPPCOL *s;\n      /* the column must be non-negative with upper bound */\n      xassert(q->lb == 0.0);\n      xassert(q->ub > 0.0);\n      xassert(q->ub != +DBL_MAX);\n      /* create variable s */\n      s = npp_add_col(npp);\n      s->is_int = q->is_int;\n      s->lb = 0.0, s->ub = +DBL_MAX;\n      /* create equality constraint (2) */\n      p = npp_add_row(npp);\n      p->lb = p->ub = q->ub;\n      npp_add_aij(npp, p, q, +1.0);\n      npp_add_aij(npp, p, s, +1.0);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_dbnd_col, sizeof(struct dbnd_col));\n      info->q = q->j;\n      info->s = s->j;\n      /* remove upper bound of x[q] */\n      q->ub = +DBL_MAX;\n      return;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rcv_dbnd_col": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        1018,
        1
      ],
      "content": "static int rcv_dbnd_col(NPP *npp, void *_info)\n{     /* recover non-negative column with upper bound */\n      struct dbnd_col *info = _info;\n      if (npp->sol == GLP_BS)\n      {  if (npp->c_stat[info->q] == GLP_BS)\n         {  if (npp->c_stat[info->s] == GLP_BS)\n               npp->c_stat[info->q] = GLP_BS;\n            else if (npp->c_stat[info->s] == GLP_NL)\n               npp->c_stat[info->q] = GLP_NU;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else if (npp->c_stat[info->q] == GLP_NL)\n         {  if (npp->c_stat[info->s] == GLP_BS ||\n                npp->c_stat[info->s] == GLP_NL)\n               npp->c_stat[info->q] = GLP_NL;\n            else\n            {  npp_error();\n               return 1;\n            }\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_fixed_col": {
      "start_point": [
        1105,
        0
      ],
      "end_point": [
        1134,
        1
      ],
      "content": "void npp_fixed_col(NPP *npp, NPPCOL *q)\n{     /* process fixed column */\n      struct fixed_col *info;\n      NPPROW *i;\n      NPPAIJ *aij;\n      /* the column must be fixed */\n      xassert(q->lb == q->ub);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_fixed_col, sizeof(struct fixed_col));\n      info->q = q->j;\n      info->s = q->lb;\n      /* substitute x[q] = s[q] into objective row */\n      npp->c0 += q->coef * q->lb;\n      /* substitute x[q] = s[q] into constraint rows */\n      for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n      {  i = aij->row;\n         if (i->lb == i->ub)\n            i->ub = (i->lb -= aij->val * q->lb);\n         else\n         {  if (i->lb != -DBL_MAX)\n               i->lb -= aij->val * q->lb;\n            if (i->ub != +DBL_MAX)\n               i->ub -= aij->val * q->lb;\n         }\n      }\n      /* remove the column from the problem */\n      npp_del_col(npp, q);\n      return;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rcv_fixed_col": {
      "start_point": [
        1136,
        0
      ],
      "end_point": [
        1143,
        1
      ],
      "content": "static int rcv_fixed_col(NPP *npp, void *_info)\n{     /* recover fixed column */\n      struct fixed_col *info = _info;\n      if (npp->sol == GLP_SOL)\n         npp->c_stat[info->q] = GLP_NS;\n      npp->c_value[info->q] = info->s;\n      return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_make_equality": {
      "start_point": [
        1225,
        0
      ],
      "end_point": [
        1248,
        1
      ],
      "content": "int npp_make_equality(NPP *npp, NPPROW *p)\n{     /* process row with almost identical bounds */\n      struct make_equality *info;\n      double b, eps, nint;\n      /* the row must be double-sided inequality */\n      xassert(p->lb != -DBL_MAX);\n      xassert(p->ub != +DBL_MAX);\n      xassert(p->lb < p->ub);\n      /* check row bounds */\n      eps = 1e-9 + 1e-12 * fabs(p->lb);\n      if (p->ub - p->lb > eps) return 0;\n      /* row bounds are very close to each other */\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_make_equality, sizeof(struct make_equality));\n      info->p = p->i;\n      /* compute right-hand side */\n      b = 0.5 * (p->ub + p->lb);\n      nint = floor(b + 0.5);\n      if (fabs(b - nint) <= eps) b = nint;\n      /* replace row p by almost equivalent equality constraint */\n      p->lb = p->ub = b;\n      return 1;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rcv_make_equality": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1268,
        1
      ],
      "content": "int rcv_make_equality(NPP *npp, void *_info)\n{     /* recover row with almost identical bounds */\n      struct make_equality *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] == GLP_BS)\n            npp->r_stat[info->p] = GLP_BS;\n         else if (npp->r_stat[info->p] == GLP_NS)\n         {  if (npp->r_pi[info->p] >= 0.0)\n               npp->r_stat[info->p] = GLP_NL;\n            else\n               npp->r_stat[info->p] = GLP_NU;\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "npp_make_fixed": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1403,
        1
      ],
      "content": "int npp_make_fixed(NPP *npp, NPPCOL *q)\n{     /* process column with almost identical bounds */\n      struct make_fixed *info;\n      NPPAIJ *aij;\n      NPPLFE *lfe;\n      double s, eps, nint;\n      /* the column must be double-bounded */\n      xassert(q->lb != -DBL_MAX);\n      xassert(q->ub != +DBL_MAX);\n      xassert(q->lb < q->ub);\n      /* check column bounds */\n      eps = 1e-9 + 1e-12 * fabs(q->lb);\n      if (q->ub - q->lb > eps) return 0;\n      /* column bounds are very close to each other */\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_make_fixed, sizeof(struct make_fixed));\n      info->q = q->j;\n      info->c = q->coef;\n      info->ptr = NULL;\n      /* save column coefficients a[i,q] (needed for basic solution\n         only) */\n      if (npp->sol == GLP_SOL)\n      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n         {  lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n            lfe->ref = aij->row->i;\n            lfe->val = aij->val;\n            lfe->next = info->ptr;\n            info->ptr = lfe;\n         }\n      }\n      /* compute column fixed value */\n      s = 0.5 * (q->ub + q->lb);\n      nint = floor(s + 0.5);\n      if (fabs(s - nint) <= eps) s = nint;\n      /* make column q fixed */\n      q->lb = q->ub = s;\n      return 1;\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rcv_make_fixed": {
      "start_point": [
        1405,
        0
      ],
      "end_point": [
        1430,
        1
      ],
      "content": "static int rcv_make_fixed(NPP *npp, void *_info)\n{     /* recover column with almost identical bounds */\n      struct make_fixed *info = _info;\n      NPPLFE *lfe;\n      double lambda;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->c_stat[info->q] == GLP_BS)\n            npp->c_stat[info->q] = GLP_BS;\n         else if (npp->c_stat[info->q] == GLP_NS)\n         {  /* compute multiplier for column q with formula (6) */\n            lambda = info->c;\n            for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)\n               lambda -= lfe->val * npp->r_pi[lfe->ref];\n            /* assign status to non-basic column */\n            if (lambda >= 0.0)\n               npp->c_stat[info->q] = GLP_NL;\n            else\n               npp->c_stat[info->q] = GLP_NU;\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/npp/npp3.c": {
    "npp_empty_row": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int npp_empty_row(NPP *npp, NPPROW *p)\n{     /* process empty row */\n      double eps = 1e-3;\n      /* the row must be empty */\n      xassert(p->ptr == NULL);\n      /* check primal feasibility */\n      if (p->lb > +eps || p->ub < -eps)\n         return 1;\n      /* replace the row by equivalent free (unbounded) row */\n      p->lb = -DBL_MAX, p->ub = +DBL_MAX;\n      /* and process it */\n      npp_free_row(npp, p);\n      return 0;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "npp_empty_col": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "int npp_empty_col(NPP *npp, NPPCOL *q)\n{     /* process empty column */\n      struct empty_col *info;\n      double eps = 1e-3;\n      /* the column must be empty */\n      xassert(q->ptr == NULL);\n      /* check dual feasibility */\n      if (q->coef > +eps && q->lb == -DBL_MAX)\n         return 1;\n      if (q->coef < -eps && q->ub == +DBL_MAX)\n         return 1;\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_empty_col, sizeof(struct empty_col));\n      info->q = q->j;\n      /* fix the column */\n      if (q->lb == -DBL_MAX && q->ub == +DBL_MAX)\n      {  /* free column */\n         info->stat = GLP_NF;\n         q->lb = q->ub = 0.0;\n      }\n      else if (q->ub == +DBL_MAX)\nlo:   {  /* column with lower bound */\n         info->stat = GLP_NL;\n         q->ub = q->lb;\n      }\n      else if (q->lb == -DBL_MAX)\nup:   {  /* column with upper bound */\n         info->stat = GLP_NU;\n         q->lb = q->ub;\n      }\n      else if (q->lb != q->ub)\n      {  /* double-bounded column */\n         if (q->coef >= +DBL_EPSILON) goto lo;\n         if (q->coef <= -DBL_EPSILON) goto up;\n         if (fabs(q->lb) <= fabs(q->ub)) goto lo; else goto up;\n      }\n      else\n      {  /* fixed column */\n         info->stat = GLP_NS;\n      }\n      /* process fixed column */\n      npp_fixed_col(npp, q);\n      return 0;\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "rcv_empty_col": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "static int rcv_empty_col(NPP *npp, void *_info)\n{     /* recover empty column */\n      struct empty_col *info = _info;\n      if (npp->sol == GLP_SOL)\n         npp->c_stat[info->q] = info->stat;\n      return 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_implied_value": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "int npp_implied_value(NPP *npp, NPPCOL *q, double s)\n{     /* process implied column value */\n      double eps, nint;\n      xassert(npp == npp);\n      /* column must not be fixed */\n      xassert(q->lb < q->ub);\n      /* check integrality */\n      if (q->is_int)\n      {  nint = floor(s + 0.5);\n         if (fabs(s - nint) <= 1e-5)\n            s = nint;\n         else\n            return 2;\n      }\n      /* check current column lower bound */\n      if (q->lb != -DBL_MAX)\n      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->lb));\n         if (s < q->lb - eps) return 1;\n         /* if s[q] is close to l[q], fix column at its lower bound\n            rather than at the implied value */\n         if (s < q->lb + 1e-3 * eps)\n         {  q->ub = q->lb;\n            return 0;\n         }\n      }\n      /* check current column upper bound */\n      if (q->ub != +DBL_MAX)\n      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->ub));\n         if (s > q->ub + eps) return 1;\n         /* if s[q] is close to u[q], fix column at its upper bound\n            rather than at the implied value */\n         if (s > q->ub - 1e-3 * eps)\n         {  q->lb = q->ub;\n            return 0;\n         }\n      }\n      /* fix column at the implied value */\n      q->lb = q->ub = s;\n      return 0;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "npp_eq_singlet": {
      "start_point": [
        422,
        0
      ],
      "end_point": [
        463,
        1
      ],
      "content": "int npp_eq_singlet(NPP *npp, NPPROW *p)\n{     /* process row singleton (equality constraint) */\n      struct eq_singlet *info;\n      NPPCOL *q;\n      NPPAIJ *aij;\n      NPPLFE *lfe;\n      int ret;\n      double s;\n      /* the row must be singleton equality constraint */\n      xassert(p->lb == p->ub);\n      xassert(p->ptr != NULL && p->ptr->r_next == NULL);\n      /* compute and process implied column value */\n      aij = p->ptr;\n      q = aij->col;\n      s = p->lb / aij->val;\n      ret = npp_implied_value(npp, q, s);\n      xassert(0 <= ret && ret <= 2);\n      if (ret != 0) return ret;\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_eq_singlet, sizeof(struct eq_singlet));\n      info->p = p->i;\n      info->q = q->j;\n      info->apq = aij->val;\n      info->c = q->coef;\n      info->ptr = NULL;\n      /* save column coefficients a[i,q], i != p (not needed for MIP\n         solution) */\n      if (npp->sol != GLP_MIP)\n      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n         {  if (aij->row == p) continue; /* skip a[p,q] */\n            lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n            lfe->ref = aij->row->i;\n            lfe->val = aij->val;\n            lfe->next = info->ptr;\n            info->ptr = lfe;\n         }\n      }\n      /* remove the row from the problem */\n      npp_del_row(npp, p);\n      return 0;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rcv_eq_singlet": {
      "start_point": [
        465,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "static int rcv_eq_singlet(NPP *npp, void *_info)\n{     /* recover row singleton (equality constraint) */\n      struct eq_singlet *info = _info;\n      NPPLFE *lfe;\n      double temp;\n      if (npp->sol == GLP_SOL)\n      {  /* column q must be already recovered as GLP_NS */\n         if (npp->c_stat[info->q] != GLP_NS)\n         {  npp_error();\n            return 1;\n         }\n         npp->r_stat[info->p] = GLP_NS;\n         npp->c_stat[info->q] = GLP_BS;\n      }\n      if (npp->sol != GLP_MIP)\n      {  /* compute multiplier for row p with formula (3) */\n         temp = info->c;\n         for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)\n            temp -= lfe->val * npp->r_pi[lfe->ref];\n         npp->r_pi[info->p] = temp / info->apq;\n      }\n      return 0;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_implied_lower": {
      "start_point": [
        549,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "int npp_implied_lower(NPP *npp, NPPCOL *q, double l)\n{     /* process implied column lower bound */\n      int ret;\n      double eps, nint;\n      xassert(npp == npp);\n      /* column must not be fixed */\n      xassert(q->lb < q->ub);\n      /* implied lower bound must be finite */\n      xassert(l != -DBL_MAX);\n      /* if column is integral, round up l'[q] */\n      if (q->is_int)\n      {  nint = floor(l + 0.5);\n         if (fabs(l - nint) <= 1e-5)\n            l = nint;\n         else\n            l = ceil(l);\n      }\n      /* check current column lower bound */\n      if (q->lb != -DBL_MAX)\n      {  eps = (q->is_int ? 1e-3 : 1e-3 + 1e-6 * fabs(q->lb));\n         if (l < q->lb + eps)\n         {  ret = 0; /* redundant */\n            goto done;\n         }\n      }\n      /* check current column upper bound */\n      if (q->ub != +DBL_MAX)\n      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->ub));\n         if (l > q->ub + eps)\n         {  ret = 4; /* infeasible */\n            goto done;\n         }\n         /* if l'[q] is close to u[q], fix column at its upper bound */\n         if (l > q->ub - 1e-3 * eps)\n         {  q->lb = q->ub;\n            ret = 3; /* fixed */\n            goto done;\n         }\n      }\n      /* check if column lower bound changes significantly */\n      if (q->lb == -DBL_MAX)\n         ret = 2; /* significantly */\n      else if (q->is_int && l > q->lb + 0.5)\n         ret = 2; /* significantly */\n      else if (l > q->lb + 0.30 * (1.0 + fabs(q->lb)))\n         ret = 2; /* significantly */\n      else\n         ret = 1; /* not significantly */\n      /* set new column lower bound */\n      q->lb = l;\ndone: return ret;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_implied_upper": {
      "start_point": [
        662,
        0
      ],
      "end_point": [
        712,
        1
      ],
      "content": "int npp_implied_upper(NPP *npp, NPPCOL *q, double u)\n{     int ret;\n      double eps, nint;\n      xassert(npp == npp);\n      /* column must not be fixed */\n      xassert(q->lb < q->ub);\n      /* implied upper bound must be finite */\n      xassert(u != +DBL_MAX);\n      /* if column is integral, round down u'[q] */\n      if (q->is_int)\n      {  nint = floor(u + 0.5);\n         if (fabs(u - nint) <= 1e-5)\n            u = nint;\n         else\n            u = floor(u);\n      }\n      /* check current column upper bound */\n      if (q->ub != +DBL_MAX)\n      {  eps = (q->is_int ? 1e-3 : 1e-3 + 1e-6 * fabs(q->ub));\n         if (u > q->ub - eps)\n         {  ret = 0; /* redundant */\n            goto done;\n         }\n      }\n      /* check current column lower bound */\n      if (q->lb != -DBL_MAX)\n      {  eps = (q->is_int ? 1e-5 : 1e-5 + 1e-8 * fabs(q->lb));\n         if (u < q->lb - eps)\n         {  ret = 4; /* infeasible */\n            goto done;\n         }\n         /* if u'[q] is close to l[q], fix column at its lower bound */\n         if (u < q->lb + 1e-3 * eps)\n         {  q->ub = q->lb;\n            ret = 3; /* fixed */\n            goto done;\n         }\n      }\n      /* check if column upper bound changes significantly */\n      if (q->ub == +DBL_MAX)\n         ret = 2; /* significantly */\n      else if (q->is_int && u < q->ub - 0.5)\n         ret = 2; /* significantly */\n      else if (u < q->ub - 0.30 * (1.0 + fabs(q->ub)))\n         ret = 2; /* significantly */\n      else\n         ret = 1; /* not significantly */\n      /* set new column upper bound */\n      q->ub = u;\ndone: return ret;\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_ineq_singlet": {
      "start_point": [
        883,
        0
      ],
      "end_point": [
        962,
        1
      ],
      "content": "int npp_ineq_singlet(NPP *npp, NPPROW *p)\n{     /* process row singleton (inequality constraint) */\n      struct ineq_singlet *info;\n      NPPCOL *q;\n      NPPAIJ *apq, *aij;\n      NPPLFE *lfe;\n      int lb_changed, ub_changed;\n      double ll, uu;\n      /* the row must be singleton inequality constraint */\n      xassert(p->lb != -DBL_MAX || p->ub != +DBL_MAX);\n      xassert(p->lb < p->ub);\n      xassert(p->ptr != NULL && p->ptr->r_next == NULL);\n      /* compute implied column bounds */\n      apq = p->ptr;\n      q = apq->col;\n      xassert(q->lb < q->ub);\n      if (apq->val > 0.0)\n      {  ll = (p->lb == -DBL_MAX ? -DBL_MAX : p->lb / apq->val);\n         uu = (p->ub == +DBL_MAX ? +DBL_MAX : p->ub / apq->val);\n      }\n      else\n      {  ll = (p->ub == +DBL_MAX ? -DBL_MAX : p->ub / apq->val);\n         uu = (p->lb == -DBL_MAX ? +DBL_MAX : p->lb / apq->val);\n      }\n      /* process implied column lower bound */\n      if (ll == -DBL_MAX)\n         lb_changed = 0;\n      else\n      {  lb_changed = npp_implied_lower(npp, q, ll);\n         xassert(0 <= lb_changed && lb_changed <= 4);\n         if (lb_changed == 4) return 4; /* infeasible */\n      }\n      /* process implied column upper bound */\n      if (uu == +DBL_MAX)\n         ub_changed = 0;\n      else if (lb_changed == 3)\n      {  /* column was fixed on its upper bound due to l'[q] = u[q] */\n         /* note that L[p] < U[p], so l'[q] = u[q] < u'[q] */\n         ub_changed = 0;\n      }\n      else\n      {  ub_changed = npp_implied_upper(npp, q, uu);\n         xassert(0 <= ub_changed && ub_changed <= 4);\n         if (ub_changed == 4) return 4; /* infeasible */\n      }\n      /* if neither lower nor upper column bound was changed, the row\n         is originally redundant and can be replaced by free row */\n      if (!lb_changed && !ub_changed)\n      {  p->lb = -DBL_MAX, p->ub = +DBL_MAX;\n         npp_free_row(npp, p);\n         return 0;\n      }\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_ineq_singlet, sizeof(struct ineq_singlet));\n      info->p = p->i;\n      info->q = q->j;\n      info->apq = apq->val;\n      info->c = q->coef;\n      info->lb = p->lb;\n      info->ub = p->ub;\n      info->lb_changed = (char)lb_changed;\n      info->ub_changed = (char)ub_changed;\n      info->ptr = NULL;\n      /* save column coefficients a[i,q], i != p (not needed for MIP\n         solution) */\n      if (npp->sol != GLP_MIP)\n      {  for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n         {  if (aij == apq) continue; /* skip a[p,q] */\n            lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n            lfe->ref = aij->row->i;\n            lfe->val = aij->val;\n            lfe->next = info->ptr;\n            info->ptr = lfe;\n         }\n      }\n      /* remove the row from the problem */\n      npp_del_row(npp, p);\n      return lb_changed >= ub_changed ? lb_changed : ub_changed;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rcv_ineq_singlet": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "static int rcv_ineq_singlet(NPP *npp, void *_info)\n{     /* recover row singleton (inequality constraint) */\n      struct ineq_singlet *info = _info;\n      NPPLFE *lfe;\n      double lambda;\n      if (npp->sol == GLP_MIP) goto done;\n      /* compute lambda~[q] in solution to the transformed problem\n         with formula (8) */\n      lambda = info->c;\n      for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)\n         lambda -= lfe->val * npp->r_pi[lfe->ref];\n      if (npp->sol == GLP_SOL)\n      {  /* recover basic solution */\n         if (npp->c_stat[info->q] == GLP_BS)\n         {  /* column q is basic, so row p is inactive */\n            npp->r_stat[info->p] = GLP_BS;\n            npp->r_pi[info->p] = 0.0;\n         }\n         else if (npp->c_stat[info->q] == GLP_NL)\nnl:      {  /* column q is non-basic with lower bound active */\n            if (info->lb_changed)\n            {  /* it is implied bound, so actually row p is active\n                  while column q is basic */\n               npp->r_stat[info->p] =\n                  (char)(info->apq > 0.0 ? GLP_NL : GLP_NU);\n               npp->c_stat[info->q] = GLP_BS;\n               npp->r_pi[info->p] = lambda / info->apq;\n            }\n            else\n            {  /* it is original bound, so row p is inactive */\n               npp->r_stat[info->p] = GLP_BS;\n               npp->r_pi[info->p] = 0.0;\n            }\n         }\n         else if (npp->c_stat[info->q] == GLP_NU)\nnu:      {  /* column q is non-basic with upper bound active */\n            if (info->ub_changed)\n            {  /* it is implied bound, so actually row p is active\n                  while column q is basic */\n               npp->r_stat[info->p] =\n                  (char)(info->apq > 0.0 ? GLP_NU : GLP_NL);\n               npp->c_stat[info->q] = GLP_BS;\n               npp->r_pi[info->p] = lambda / info->apq;\n            }\n            else\n            {  /* it is original bound, so row p is inactive */\n               npp->r_stat[info->p] = GLP_BS;\n               npp->r_pi[info->p] = 0.0;\n            }\n         }\n         else if (npp->c_stat[info->q] == GLP_NS)\n         {  /* column q is non-basic and fixed; note, however, that in\n               in the original problem it is non-fixed */\n            if (lambda > +1e-7)\n            {  if (info->apq > 0.0 && info->lb != -DBL_MAX ||\n                   info->apq < 0.0 && info->ub != +DBL_MAX ||\n                  !info->lb_changed)\n               {  /* either corresponding bound of row p exists or\n                     column q remains non-basic with its original lower\n                     bound active */\n                  npp->c_stat[info->q] = GLP_NL;\n                  goto nl;\n               }\n            }\n            if (lambda < -1e-7)\n            {  if (info->apq > 0.0 && info->ub != +DBL_MAX ||\n                   info->apq < 0.0 && info->lb != -DBL_MAX ||\n                  !info->ub_changed)\n               {  /* either corresponding bound of row p exists or\n                     column q remains non-basic with its original upper\n                     bound active */\n                  npp->c_stat[info->q] = GLP_NU;\n                  goto nu;\n               }\n            }\n            /* either lambda~[q] is close to zero, or corresponding\n               bound of row p does not exist, because lambda~[q] has\n               wrong sign due to round-off errors; in the latter case\n               lambda~[q] is also assumed to be close to zero; so, we\n               can make row p active on its existing bound and column q\n               basic; pi[p] will have wrong sign, but it also will be\n               close to zero (rarus casus of dual degeneracy) */\n            if (info->lb != -DBL_MAX && info->ub == +DBL_MAX)\n            {  /* row lower bound exists, but upper bound doesn't */\n               npp->r_stat[info->p] = GLP_NL;\n            }\n            else if (info->lb == -DBL_MAX && info->ub != +DBL_MAX)\n            {  /* row upper bound exists, but lower bound doesn't */\n               npp->r_stat[info->p] = GLP_NU;\n            }\n            else if (info->lb != -DBL_MAX && info->ub != +DBL_MAX)\n            {  /* both row lower and upper bounds exist */\n               /* to choose proper active row bound we should not use\n                  lambda~[q], because its value being close to zero is\n                  unreliable; so we choose that bound which provides\n                  primal feasibility for original constraint (1) */\n               if (info->apq * npp->c_value[info->q] <=\n                   0.5 * (info->lb + info->ub))\n                  npp->r_stat[info->p] = GLP_NL;\n               else\n                  npp->r_stat[info->p] = GLP_NU;\n            }\n            else\n            {  npp_error();\n               return 1;\n            }\n            npp->c_stat[info->q] = GLP_BS;\n            npp->r_pi[info->p] = lambda / info->apq;\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      if (npp->sol == GLP_IPT)\n      {  /* recover interior-point solution */\n         if (lambda > +DBL_EPSILON && info->lb_changed ||\n             lambda < -DBL_EPSILON && info->ub_changed)\n         {  /* actually row p has corresponding active bound */\n            npp->r_pi[info->p] = lambda / info->apq;\n         }\n         else\n         {  /* either bounds of column q are both inactive or its\n               original bound is active */\n            npp->r_pi[info->p] = 0.0;\n         }\n      }\ndone: return 0;\n}",
      "lines": 129,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_implied_slack": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1289,
        1
      ],
      "content": "void npp_implied_slack(NPP *npp, NPPCOL *q)\n{     /* process column singleton (implied slack variable) */\n      struct implied_slack *info;\n      NPPROW *p;\n      NPPAIJ *aij;\n      NPPLFE *lfe;\n      /* the column must be non-integral non-fixed singleton */\n      xassert(!q->is_int);\n      xassert(q->lb < q->ub);\n      xassert(q->ptr != NULL && q->ptr->c_next == NULL);\n      /* corresponding row must be equality constraint */\n      aij = q->ptr;\n      p = aij->row;\n      xassert(p->lb == p->ub);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_implied_slack, sizeof(struct implied_slack));\n      info->p = p->i;\n      info->q = q->j;\n      info->apq = aij->val;\n      info->b = p->lb;\n      info->c = q->coef;\n      info->ptr = NULL;\n      /* save row coefficients a[p,j], j != q, and substitute x[q]\n         into the objective row */\n      for (aij = p->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->col == q) continue; /* skip a[p,q] */\n         lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n         lfe->ref = aij->col->j;\n         lfe->val = aij->val;\n         lfe->next = info->ptr;\n         info->ptr = lfe;\n         aij->col->coef -= info->c * (aij->val / info->apq);\n      }\n      npp->c0 += info->c * (info->b / info->apq);\n      /* compute new row bounds */\n      if (info->apq > 0.0)\n      {  p->lb = (q->ub == +DBL_MAX ?\n            -DBL_MAX : info->b - info->apq * q->ub);\n         p->ub = (q->lb == -DBL_MAX ?\n            +DBL_MAX : info->b - info->apq * q->lb);\n      }\n      else\n      {  p->lb = (q->lb == -DBL_MAX ?\n            -DBL_MAX : info->b - info->apq * q->lb);\n         p->ub = (q->ub == +DBL_MAX ?\n            +DBL_MAX : info->b - info->apq * q->ub);\n      }\n      /* remove the column from the problem */\n      npp_del_col(npp, q);\n      return;\n}",
      "lines": 52,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rcv_implied_slack": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1323,
        1
      ],
      "content": "static int rcv_implied_slack(NPP *npp, void *_info)\n{     /* recover column singleton (implied slack variable) */\n      struct implied_slack *info = _info;\n      NPPLFE *lfe;\n      double temp;\n      if (npp->sol == GLP_SOL)\n      {  /* assign statuses to row p and column q */\n         if (npp->r_stat[info->p] == GLP_BS ||\n             npp->r_stat[info->p] == GLP_NF)\n            npp->c_stat[info->q] = npp->r_stat[info->p];\n         else if (npp->r_stat[info->p] == GLP_NL)\n            npp->c_stat[info->q] =\n               (char)(info->apq > 0.0 ? GLP_NU : GLP_NL);\n         else if (npp->r_stat[info->p] == GLP_NU)\n            npp->c_stat[info->q] =\n               (char)(info->apq > 0.0 ? GLP_NL : GLP_NU);\n         else\n         {  npp_error();\n            return 1;\n         }\n         npp->r_stat[info->p] = GLP_NS;\n      }\n      if (npp->sol != GLP_MIP)\n      {  /* compute multiplier for row p */\n         npp->r_pi[info->p] += info->c / info->apq;\n      }\n      /* compute value of column q */\n      temp = info->b;\n      for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)\n         temp -= lfe->val * npp->c_value[lfe->ref];\n      npp->c_value[info->q] = temp / info->apq;\n      return 0;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_implied_free": {
      "start_point": [
        1488,
        0
      ],
      "end_point": [
        1613,
        1
      ],
      "content": "int npp_implied_free(NPP *npp, NPPCOL *q)\n{     /* process column singleton (implied free variable) */\n      struct implied_free *info;\n      NPPROW *p;\n      NPPAIJ *apq, *aij;\n      double alfa, beta, l, u, pi, eps;\n      /* the column must be non-fixed singleton */\n      xassert(q->lb < q->ub);\n      xassert(q->ptr != NULL && q->ptr->c_next == NULL);\n      /* corresponding row must be inequality constraint */\n      apq = q->ptr;\n      p = apq->row;\n      xassert(p->lb != -DBL_MAX || p->ub != +DBL_MAX);\n      xassert(p->lb < p->ub);\n      /* compute alfa */\n      alfa = p->lb;\n      if (alfa != -DBL_MAX)\n      {  for (aij = p->ptr; aij != NULL; aij = aij->r_next)\n         {  if (aij == apq) continue; /* skip a[p,q] */\n            if (aij->val > 0.0)\n            {  if (aij->col->ub == +DBL_MAX)\n               {  alfa = -DBL_MAX;\n                  break;\n               }\n               alfa -= aij->val * aij->col->ub;\n            }\n            else /* < 0.0 */\n            {  if (aij->col->lb == -DBL_MAX)\n               {  alfa = -DBL_MAX;\n                  break;\n               }\n               alfa -= aij->val * aij->col->lb;\n            }\n         }\n      }\n      /* compute beta */\n      beta = p->ub;\n      if (beta != +DBL_MAX)\n      {  for (aij = p->ptr; aij != NULL; aij = aij->r_next)\n         {  if (aij == apq) continue; /* skip a[p,q] */\n            if (aij->val > 0.0)\n            {  if (aij->col->lb == -DBL_MAX)\n               {  beta = +DBL_MAX;\n                  break;\n               }\n               beta -= aij->val * aij->col->lb;\n            }\n            else /* < 0.0 */\n            {  if (aij->col->ub == +DBL_MAX)\n               {  beta = +DBL_MAX;\n                  break;\n               }\n               beta -= aij->val * aij->col->ub;\n            }\n         }\n      }\n      /* compute implied column lower bound l'[q] */\n      if (apq->val > 0.0)\n         l = (alfa == -DBL_MAX ? -DBL_MAX : alfa / apq->val);\n      else /* < 0.0 */\n         l = (beta == +DBL_MAX ? -DBL_MAX : beta / apq->val);\n      /* compute implied column upper bound u'[q] */\n      if (apq->val > 0.0)\n         u = (beta == +DBL_MAX ? +DBL_MAX : beta / apq->val);\n      else\n         u = (alfa == -DBL_MAX ? +DBL_MAX : alfa / apq->val);\n      /* check if column lower bound l[q] can be active */\n      if (q->lb != -DBL_MAX)\n      {  eps = 1e-9 + 1e-12 * fabs(q->lb);\n         if (l < q->lb - eps) return 1; /* yes, it can */\n      }\n      /* check if column upper bound u[q] can be active */\n      if (q->ub != +DBL_MAX)\n      {  eps = 1e-9 + 1e-12 * fabs(q->ub);\n         if (u > q->ub + eps) return 1; /* yes, it can */\n      }\n      /* okay; make column q free (unbounded) */\n      q->lb = -DBL_MAX, q->ub = +DBL_MAX;\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_implied_free, sizeof(struct implied_free));\n      info->p = p->i;\n      info->stat = -1;\n      /* compute row multiplier pi[p] */\n      pi = q->coef / apq->val;\n      /* check dual feasibility for row p */\n      if (pi > +DBL_EPSILON)\n      {  /* lower bound L[p] must be active */\n         if (p->lb != -DBL_MAX)\nnl:      {  info->stat = GLP_NL;\n            p->ub = p->lb;\n         }\n         else\n         {  if (pi > +1e-5) return 2; /* dual infeasibility */\n            /* take a chance on U[p] */\n            xassert(p->ub != +DBL_MAX);\n            goto nu;\n         }\n      }\n      else if (pi < -DBL_EPSILON)\n      {  /* upper bound U[p] must be active */\n         if (p->ub != +DBL_MAX)\nnu:      {  info->stat = GLP_NU;\n            p->lb = p->ub;\n         }\n         else\n         {  if (pi < -1e-5) return 2; /* dual infeasibility */\n            /* take a chance on L[p] */\n            xassert(p->lb != -DBL_MAX);\n            goto nl;\n         }\n      }\n      else\n      {  /* any bound (either L[p] or U[p]) can be made active  */\n         if (p->ub == +DBL_MAX)\n         {  xassert(p->lb != -DBL_MAX);\n            goto nl;\n         }\n         if (p->lb == -DBL_MAX)\n         {  xassert(p->ub != +DBL_MAX);\n            goto nu;\n         }\n         if (fabs(p->lb) <= fabs(p->ub)) goto nl; else goto nu;\n      }\n      return 0;\n}",
      "lines": 126,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "rcv_implied_free": {
      "start_point": [
        1615,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static int rcv_implied_free(NPP *npp, void *_info)\n{     /* recover column singleton (implied free variable) */\n      struct implied_free *info = _info;\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] == GLP_BS)\n            npp->r_stat[info->p] = GLP_BS;\n         else if (npp->r_stat[info->p] == GLP_NS)\n         {  xassert(info->stat == GLP_NL || info->stat == GLP_NU);\n            npp->r_stat[info->p] = info->stat;\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      return 0;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_eq_doublet": {
      "start_point": [
        1762,
        0
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "NPPCOL *npp_eq_doublet(NPP *npp, NPPROW *p)\n{     /* process row doubleton (equality constraint) */\n      struct eq_doublet *info;\n      NPPROW *i;\n      NPPCOL *q, *r;\n      NPPAIJ *apq, *apr, *aiq, *air, *next;\n      NPPLFE *lfe;\n      double gamma;\n      /* the row must be doubleton equality constraint */\n      xassert(p->lb == p->ub);\n      xassert(p->ptr != NULL && p->ptr->r_next != NULL &&\n              p->ptr->r_next->r_next == NULL);\n      /* choose column to be eliminated */\n      {  NPPAIJ *a1, *a2;\n         a1 = p->ptr, a2 = a1->r_next;\n         if (fabs(a2->val) < 0.001 * fabs(a1->val))\n         {  /* only first column can be eliminated, because second one\n               has too small constraint coefficient */\n            apq = a1, apr = a2;\n         }\n         else if (fabs(a1->val) < 0.001 * fabs(a2->val))\n         {  /* only second column can be eliminated, because first one\n               has too small constraint coefficient */\n            apq = a2, apr = a1;\n         }\n         else\n         {  /* both columns are appropriate; choose that one which is\n               shorter to minimize fill-in */\n            if (npp_col_nnz(npp, a1->col) <= npp_col_nnz(npp, a2->col))\n            {  /* first column is shorter */\n               apq = a1, apr = a2;\n            }\n            else\n            {  /* second column is shorter */\n               apq = a2, apr = a1;\n            }\n         }\n      }\n      /* now columns q and r have been chosen */\n      q = apq->col, r = apr->col;\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_eq_doublet, sizeof(struct eq_doublet));\n      info->p = p->i;\n      info->apq = apq->val;\n      info->ptr = NULL;\n      /* transform each row i (i != p), where a[i,q] != 0, to eliminate\n         column q */\n      for (aiq = q->ptr; aiq != NULL; aiq = next)\n      {  next = aiq->c_next;\n         if (aiq == apq) continue; /* skip row p */\n         i = aiq->row; /* row i to be transformed */\n         /* save constraint coefficient a[i,q] */\n         if (npp->sol != GLP_MIP)\n         {  lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n            lfe->ref = i->i;\n            lfe->val = aiq->val;\n            lfe->next = info->ptr;\n            info->ptr = lfe;\n         }\n         /* find coefficient a[i,r] in row i */\n         for (air = i->ptr; air != NULL; air = air->r_next)\n            if (air->col == r) break;\n         /* if a[i,r] does not exist, create a[i,r] = 0 */\n         if (air == NULL)\n            air = npp_add_aij(npp, i, r, 0.0);\n         /* compute gamma[i] = a[i,q] / a[p,q] */\n         gamma = aiq->val / apq->val;\n         /* (row i) := (row i) - gamma[i] * (row p); see (3)-(6) */\n         /* new a[i,q] is exact zero due to elimnation; remove it from\n            row i */\n         npp_del_aij(npp, aiq);\n         /* compute new a[i,r] */\n         air->val -= gamma * apr->val;\n         /* if new a[i,r] is close to zero due to numeric cancelation,\n            remove it from row i */\n         if (fabs(air->val) <= 1e-10)\n            npp_del_aij(npp, air);\n         /* compute new lower and upper bounds of row i */\n         if (i->lb == i->ub)\n            i->lb = i->ub = (i->lb - gamma * p->lb);\n         else\n         {  if (i->lb != -DBL_MAX)\n               i->lb -= gamma * p->lb;\n            if (i->ub != +DBL_MAX)\n               i->ub -= gamma * p->lb;\n         }\n      }\n      return q;\n}",
      "lines": 90,
      "depth": 13,
      "decorators": [
        "NPPCOL",
        "*npp_eq_doublet(NPP *npp, NPPROW *p)",
        "*"
      ]
    },
    "rcv_eq_doublet": {
      "start_point": [
        1853,
        0
      ],
      "end_point": [
        1877,
        1
      ],
      "content": "static int rcv_eq_doublet(NPP *npp, void *_info)\n{     /* recover row doubleton (equality constraint) */\n      struct eq_doublet *info = _info;\n      NPPLFE *lfe;\n      double gamma, temp;\n      /* we assume that processing row p is followed by processing\n         column q as singleton of type \"implied slack variable\", in\n         which case row p must always be active equality constraint */\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] != GLP_NS)\n         {  npp_error();\n            return 1;\n         }\n      }\n      if (npp->sol != GLP_MIP)\n      {  /* compute value of multiplier for row p; see (14) */\n         temp = npp->r_pi[info->p];\n         for (lfe = info->ptr; lfe != NULL; lfe = lfe->next)\n         {  gamma = lfe->val / info->apq; /* a[i,q] / a[p,q] */\n            temp -= gamma * npp->r_pi[lfe->ref];\n         }\n         npp->r_pi[info->p] = temp;\n      }\n      return 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_forcing_row": {
      "start_point": [
        2090,
        0
      ],
      "end_point": [
        2174,
        1
      ],
      "content": "int npp_forcing_row(NPP *npp, NPPROW *p, int at)\n{     /* process forcing row */\n      struct forcing_row *info;\n      struct forcing_col *col = NULL;\n      NPPCOL *j;\n      NPPAIJ *apj, *aij;\n      NPPLFE *lfe;\n      double big;\n      xassert(at == 0 || at == 1);\n      /* determine maximal magnitude of the row coefficients */\n      big = 1.0;\n      for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         if (big < fabs(apj->val)) big = fabs(apj->val);\n      /* if there are too small coefficients in the row, transformation\n         should not be applied */\n      for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         if (fabs(apj->val) < 1e-7 * big) return 1;\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_forcing_row, sizeof(struct forcing_row));\n      info->p = p->i;\n      if (p->lb == p->ub)\n      {  /* equality constraint */\n         info->stat = GLP_NS;\n      }\n      else if (at == 0)\n      {  /* inequality constraint; case L[p] = U'[p] */\n         info->stat = GLP_NL;\n         xassert(p->lb != -DBL_MAX);\n      }\n      else /* at == 1 */\n      {  /* inequality constraint; case U[p] = L'[p] */\n         info->stat = GLP_NU;\n         xassert(p->ub != +DBL_MAX);\n      }\n      info->ptr = NULL;\n      /* scan the forcing row, fix columns at corresponding bounds, and\n         save column information (the latter is not needed for MIP) */\n      for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n      {  /* column j has non-zero coefficient in the forcing row */\n         j = apj->col;\n         /* it must be non-fixed */\n         xassert(j->lb < j->ub);\n         /* allocate stack entry to save column information */\n         if (npp->sol != GLP_MIP)\n         {  col = dmp_get_atom(npp->stack, sizeof(struct forcing_col));\n            col->j = j->j;\n            col->stat = -1; /* will be set below */\n            col->a = apj->val;\n            col->c = j->coef;\n            col->ptr = NULL;\n            col->next = info->ptr;\n            info->ptr = col;\n         }\n         /* fix column j */\n         if (at == 0 && apj->val < 0.0 || at != 0 && apj->val > 0.0)\n         {  /* at its lower bound */\n            if (npp->sol != GLP_MIP)\n               col->stat = GLP_NL;\n            xassert(j->lb != -DBL_MAX);\n            j->ub = j->lb;\n         }\n         else\n         {  /* at its upper bound */\n            if (npp->sol != GLP_MIP)\n               col->stat = GLP_NU;\n            xassert(j->ub != +DBL_MAX);\n            j->lb = j->ub;\n         }\n         /* save column coefficients a[i,j], i != p */\n         if (npp->sol != GLP_MIP)\n         {  for (aij = j->ptr; aij != NULL; aij = aij->c_next)\n            {  if (aij == apj) continue; /* skip a[p,j] */\n               lfe = dmp_get_atom(npp->stack, sizeof(NPPLFE));\n               lfe->ref = aij->row->i;\n               lfe->val = aij->val;\n               lfe->next = col->ptr;\n               col->ptr = lfe;\n            }\n         }\n      }\n      /* make the row free (unbounded) */\n      p->lb = -DBL_MAX, p->ub = +DBL_MAX;\n      return 0;\n}",
      "lines": 85,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "rcv_forcing_row": {
      "start_point": [
        2176,
        0
      ],
      "end_point": [
        2242,
        1
      ],
      "content": "static int rcv_forcing_row(NPP *npp, void *_info)\n{     /* recover forcing row */\n      struct forcing_row *info = _info;\n      struct forcing_col *col, *piv;\n      NPPLFE *lfe;\n      double d, big, temp;\n      if (npp->sol == GLP_MIP) goto done;\n      /* initially solution to the original problem is the same as\n         to the transformed problem, where row p is inactive constraint\n         with pi[p] = 0, and all columns are non-basic */\n      if (npp->sol == GLP_SOL)\n      {  if (npp->r_stat[info->p] != GLP_BS)\n         {  npp_error();\n            return 1;\n         }\n         for (col = info->ptr; col != NULL; col = col->next)\n         {  if (npp->c_stat[col->j] != GLP_NS)\n            {  npp_error();\n               return 1;\n            }\n            npp->c_stat[col->j] = col->stat; /* original status */\n         }\n      }\n      /* compute reduced costs d[j] for all columns with formula (10)\n         and store them in col.c instead objective coefficients */\n      for (col = info->ptr; col != NULL; col = col->next)\n      {  d = col->c;\n         for (lfe = col->ptr; lfe != NULL; lfe = lfe->next)\n            d -= lfe->val * npp->r_pi[lfe->ref];\n         col->c = d;\n      }\n      /* consider columns j, whose multipliers lambda[j] has wrong\n         sign in solution to the transformed problem (where lambda[j] =\n         d[j]), and choose column q, whose multipler lambda[q] reaches\n         zero last on changing row multiplier pi[p]; see (14) */\n      piv = NULL, big = 0.0;\n      for (col = info->ptr; col != NULL; col = col->next)\n      {  d = col->c; /* d[j] */\n         temp = fabs(d / col->a);\n         if (col->stat == GLP_NL)\n         {  /* column j has active lower bound */\n            if (d < 0.0 && big < temp)\n               piv = col, big = temp;\n         }\n         else if (col->stat == GLP_NU)\n         {  /* column j has active upper bound */\n            if (d > 0.0 && big < temp)\n               piv = col, big = temp;\n         }\n         else\n         {  npp_error();\n            return 1;\n         }\n      }\n      /* if column q does not exist, no correction is needed */\n      if (piv != NULL)\n      {  /* correct solution; row p becomes active constraint while\n            column q becomes basic */\n         if (npp->sol == GLP_SOL)\n         {  npp->r_stat[info->p] = info->stat;\n            npp->c_stat[piv->j] = GLP_BS;\n         }\n         /* assign new value to row multiplier pi[p] = d[p] / a[p,q] */\n         npp->r_pi[info->p] = piv->c / piv->a;\n      }\ndone: return 0;\n}",
      "lines": 67,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_analyze_row": {
      "start_point": [
        2337,
        0
      ],
      "end_point": [
        2418,
        1
      ],
      "content": "int npp_analyze_row(NPP *npp, NPPROW *p)\n{     /* perform general row analysis */\n      NPPAIJ *aij;\n      int ret = 0x00;\n      double l, u, eps;\n      xassert(npp == npp);\n      /* compute implied lower bound L'[p]; see (3) */\n      l = 0.0;\n      for (aij = p->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->val > 0.0)\n         {  if (aij->col->lb == -DBL_MAX)\n            {  l = -DBL_MAX;\n               break;\n            }\n            l += aij->val * aij->col->lb;\n         }\n         else /* aij->val < 0.0 */\n         {  if (aij->col->ub == +DBL_MAX)\n            {  l = -DBL_MAX;\n               break;\n            }\n            l += aij->val * aij->col->ub;\n         }\n      }\n      /* compute implied upper bound U'[p]; see (4) */\n      u = 0.0;\n      for (aij = p->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->val > 0.0)\n         {  if (aij->col->ub == +DBL_MAX)\n            {  u = +DBL_MAX;\n               break;\n            }\n            u += aij->val * aij->col->ub;\n         }\n         else /* aij->val < 0.0 */\n         {  if (aij->col->lb == -DBL_MAX)\n            {  u = +DBL_MAX;\n               break;\n            }\n            u += aij->val * aij->col->lb;\n         }\n      }\n      /* column bounds are assumed correct, so L'[p] <= U'[p] */\n      /* check if row lower bound is consistent */\n      if (p->lb != -DBL_MAX)\n      {  eps = 1e-3 + 1e-6 * fabs(p->lb);\n         if (p->lb - eps > u)\n         {  ret = 0x33;\n            goto done;\n         }\n      }\n      /* check if row upper bound is consistent */\n      if (p->ub != +DBL_MAX)\n      {  eps = 1e-3 + 1e-6 * fabs(p->ub);\n         if (p->ub + eps < l)\n         {  ret = 0x33;\n            goto done;\n         }\n      }\n      /* check if row lower bound can be active/forcing */\n      if (p->lb != -DBL_MAX)\n      {  eps = 1e-9 + 1e-12 * fabs(p->lb);\n         if (p->lb - eps > l)\n         {  if (p->lb + eps <= u)\n               ret |= 0x01;\n            else\n               ret |= 0x02;\n         }\n      }\n      /* check if row upper bound can be active/forcing */\n      if (p->ub != +DBL_MAX)\n      {  eps = 1e-9 + 1e-12 * fabs(p->ub);\n         if (p->ub + eps < u)\n         {  /* check if the upper bound is forcing */\n            if (p->ub - eps >= l)\n               ret |= 0x10;\n            else\n               ret |= 0x20;\n         }\n      }\ndone: return ret;\n}",
      "lines": 82,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "npp_inactive_bound": {
      "start_point": [
        2482,
        0
      ],
      "end_point": [
        2511,
        1
      ],
      "content": "void npp_inactive_bound(NPP *npp, NPPROW *p, int which)\n{     /* remove row lower/upper inactive bound */\n      struct inactive_bound *info;\n      if (npp->sol == GLP_SOL)\n      {  /* create transformation stack entry */\n         info = npp_push_tse(npp,\n            rcv_inactive_bound, sizeof(struct inactive_bound));\n         info->p = p->i;\n         if (p->ub == +DBL_MAX)\n            info->stat = GLP_NL;\n         else if (p->lb == -DBL_MAX)\n            info->stat = GLP_NU;\n         else if (p->lb != p->ub)\n            info->stat = (char)(which == 0 ? GLP_NU : GLP_NL);\n         else\n            info->stat = GLP_NS;\n      }\n      /* remove row inactive bound */\n      if (which == 0)\n      {  xassert(p->lb != -DBL_MAX);\n         p->lb = -DBL_MAX;\n      }\n      else if (which == 1)\n      {  xassert(p->ub != +DBL_MAX);\n         p->ub = +DBL_MAX;\n      }\n      else\n         xassert(which != which);\n      return;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "rcv_inactive_bound": {
      "start_point": [
        2513,
        0
      ],
      "end_point": [
        2525,
        1
      ],
      "content": "static int rcv_inactive_bound(NPP *npp, void *_info)\n{     /* recover row status */\n      struct inactive_bound *info = _info;\n      if (npp->sol != GLP_SOL)\n      {  npp_error();\n         return 1;\n      }\n      if (npp->r_stat[info->p] == GLP_BS)\n         npp->r_stat[info->p] = GLP_BS;\n      else\n         npp->r_stat[info->p] = info->stat;\n      return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_implied_bounds": {
      "start_point": [
        2747,
        0
      ],
      "end_point": [
        2858,
        1
      ],
      "content": "void npp_implied_bounds(NPP *npp, NPPROW *p)\n{     NPPAIJ *apj, *apk;\n      double big, eps, temp;\n      xassert(npp == npp);\n      /* initialize implied bounds for all variables and determine\n         maximal magnitude of row coefficients a[p,j] */\n      big = 1.0;\n      for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n      {  apj->col->ll.ll = -DBL_MAX, apj->col->uu.uu = +DBL_MAX;\n         if (big < fabs(apj->val)) big = fabs(apj->val);\n      }\n      eps = 1e-6 * big;\n      /* process row lower bound (assuming that it can be active) */\n      if (p->lb != -DBL_MAX)\n      {  apk = NULL;\n         for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         {  if (apj->val > 0.0 && apj->col->ub == +DBL_MAX ||\n                apj->val < 0.0 && apj->col->lb == -DBL_MAX)\n            {  if (apk == NULL)\n                  apk = apj;\n               else\n                  goto skip1;\n            }\n         }\n         /* if a[p,k] = NULL then |J'| = 0 else J' = { k } */\n         temp = p->lb;\n         for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         {  if (apj == apk)\n               /* skip a[p,k] */;\n            else if (apj->val > 0.0)\n               temp -= apj->val * apj->col->ub;\n            else /* apj->val < 0.0 */\n               temp -= apj->val * apj->col->lb;\n         }\n         /* compute column implied bounds */\n         if (apk == NULL)\n         {  /* temp = L[p] - U'[p] */\n            for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n            {  if (apj->val >= +eps)\n               {  /* l'[j] := u[j] + (L[p] - U'[p]) / a[p,j] */\n                  apj->col->ll.ll = apj->col->ub + temp / apj->val;\n               }\n               else if (apj->val <= -eps)\n               {  /* u'[j] := l[j] + (L[p] - U'[p]) / a[p,j] */\n                  apj->col->uu.uu = apj->col->lb + temp / apj->val;\n               }\n            }\n         }\n         else\n         {  /* temp = L[p,k] */\n            if (apk->val >= +eps)\n            {  /* l'[k] := L[p,k] / a[p,k] */\n               apk->col->ll.ll = temp / apk->val;\n            }\n            else if (apk->val <= -eps)\n            {  /* u'[k] := L[p,k] / a[p,k] */\n               apk->col->uu.uu = temp / apk->val;\n            }\n         }\nskip1:   ;\n      }\n      /* process row upper bound (assuming that it can be active) */\n      if (p->ub != +DBL_MAX)\n      {  apk = NULL;\n         for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         {  if (apj->val > 0.0 && apj->col->lb == -DBL_MAX ||\n                apj->val < 0.0 && apj->col->ub == +DBL_MAX)\n            {  if (apk == NULL)\n                  apk = apj;\n               else\n                  goto skip2;\n            }\n         }\n         /* if a[p,k] = NULL then |J''| = 0 else J'' = { k } */\n         temp = p->ub;\n         for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n         {  if (apj == apk)\n               /* skip a[p,k] */;\n            else if (apj->val > 0.0)\n               temp -= apj->val * apj->col->lb;\n            else /* apj->val < 0.0 */\n               temp -= apj->val * apj->col->ub;\n         }\n         /* compute column implied bounds */\n         if (apk == NULL)\n         {  /* temp = U[p] - L'[p] */\n            for (apj = p->ptr; apj != NULL; apj = apj->r_next)\n            {  if (apj->val >= +eps)\n               {  /* u'[j] := l[j] + (U[p] - L'[p]) / a[p,j] */\n                  apj->col->uu.uu = apj->col->lb + temp / apj->val;\n               }\n               else if (apj->val <= -eps)\n               {  /* l'[j] := u[j] + (U[p] - L'[p]) / a[p,j] */\n                  apj->col->ll.ll = apj->col->ub + temp / apj->val;\n               }\n            }\n         }\n         else\n         {  /* temp = U[p,k] */\n            if (apk->val >= +eps)\n            {  /* u'[k] := U[p,k] / a[p,k] */\n               apk->col->uu.uu = temp / apk->val;\n            }\n            else if (apk->val <= -eps)\n            {  /* l'[k] := U[p,k] / a[p,k] */\n               apk->col->ll.ll = temp / apk->val;\n            }\n         }\nskip2:   ;\n      }\n      return;\n}",
      "lines": 112,
      "depth": 17,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/npp/npp4.c": {
    "npp_binarize_prob": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "int npp_binarize_prob(NPP *npp)\n{     /* binarize MIP problem */\n      struct binarize *info;\n      NPPROW *row;\n      NPPCOL *col, *bin;\n      NPPAIJ *aij;\n      int u, n, k, temp, nfails, nvars, nbins, nrows;\n      /* new variables will be added to the end of the column list, so\n         we go from the end to beginning of the column list */\n      nfails = nvars = nbins = nrows = 0;\n      for (col = npp->c_tail; col != NULL; col = col->prev)\n      {  /* skip continuous variable */\n         if (!col->is_int) continue;\n         /* skip fixed variable */\n         if (col->lb == col->ub) continue;\n         /* skip binary variable */\n         if (col->lb == 0.0 && col->ub == 1.0) continue;\n         /* check if the transformation is applicable */\n         if (col->lb < -1e6 || col->ub > +1e6 ||\n             col->ub - col->lb > 4095.0)\n         {  /* unfortunately, not */\n            nfails++;\n            continue;\n         }\n         /* process integer non-binary variable x[q] */\n         nvars++;\n         /* make x[q] non-negative, if its lower bound is non-zero */\n         if (col->lb != 0.0)\n            npp_lbnd_col(npp, col);\n         /* now 0 <= x[q] <= u[q] */\n         xassert(col->lb == 0.0);\n         u = (int)col->ub;\n         xassert(col->ub == (double)u);\n         /* if x[q] is binary, further processing is not needed */\n         if (u == 1) continue;\n         /* determine smallest n such that u <= 2^n - 1 (thus, n is the\n            number of binary variables needed) */\n         n = 2, temp = 4;\n         while (u >= temp)\n            n++, temp += temp;\n         nbins += n;\n         /* create transformation stack entry */\n         info = npp_push_tse(npp,\n            rcv_binarize_prob, sizeof(struct binarize));\n         info->q = col->j;\n         info->j = 0; /* will be set below */\n         info->n = n;\n         /* if u < 2^n - 1, we need one additional row for (4) */\n         if (u < temp - 1)\n         {  row = npp_add_row(npp), nrows++;\n            row->lb = -DBL_MAX, row->ub = u;\n         }\n         else\n            row = NULL;\n         /* in the transformed problem variable x[q] becomes binary\n            variable x[0], so its objective and constraint coefficients\n            are not changed */\n         col->ub = 1.0;\n         /* include x[0] into constraint (4) */\n         if (row != NULL)\n            npp_add_aij(npp, row, col, 1.0);\n         /* add other binary variables x[1], ..., x[n-1] */\n         for (k = 1, temp = 2; k < n; k++, temp += temp)\n         {  /* add new binary variable x[k] */\n            bin = npp_add_col(npp);\n            bin->is_int = 1;\n            bin->lb = 0.0, bin->ub = 1.0;\n            bin->coef = (double)temp * col->coef;\n            /* store column reference number for x[1] */\n            if (info->j == 0)\n               info->j = bin->j;\n            else\n               xassert(info->j + (k-1) == bin->j);\n            /* duplicate constraint coefficients for x[k]; this also\n               automatically includes x[k] into constraint (4) */\n            for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n               npp_add_aij(npp, aij->row, bin, (double)temp * aij->val);\n         }\n      }\n      if (nvars > 0)\n         xprintf(\"%d integer variable(s) were replaced by %d binary one\"\n            \"s\\n\", nvars, nbins);\n      if (nrows > 0)\n         xprintf(\"%d row(s) were added due to binarization\\n\", nrows);\n      if (nfails > 0)\n         xprintf(\"Binarization failed for %d integer variable(s)\\n\",\n            nfails);\n      return nfails;\n}",
      "lines": 89,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "rcv_binarize_prob": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "static int rcv_binarize_prob(NPP *npp, void *_info)\n{     /* recovery binarized variable */\n      struct binarize *info = _info;\n      int k, temp;\n      double sum;\n      /* compute value of x[q]; see formula (3) */\n      sum = npp->c_value[info->q];\n      for (k = 1, temp = 2; k < info->n; k++, temp += temp)\n         sum += (double)temp * npp->c_value[info->j + (k-1)];\n      npp->c_value[info->q] = sum;\n      return 0;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "copy_form": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static struct elem *copy_form(NPP *npp, NPPROW *row, double s)\n{     /* copy linear form */\n      NPPAIJ *aij;\n      struct elem *ptr, *e;\n      ptr = NULL;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  e = dmp_get_atom(npp->pool, sizeof(struct elem));\n         e->aj = s * aij->val;\n         e->xj = aij->col;\n         e->next = ptr;\n         ptr = e;\n      }\n      return ptr;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct elem",
        "struct",
        "elem",
        "*copy_form(NPP *npp, NPPROW *row, double s)",
        "*"
      ]
    },
    "drop_form": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void drop_form(NPP *npp, struct elem *ptr)\n{     /* drop linear form */\n      struct elem *e;\n      while (ptr != NULL)\n      {  e = ptr;\n         ptr = e->next;\n         dmp_free_atom(npp->pool, e, sizeof(struct elem));\n      }\n      return;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "npp_is_packing": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "int npp_is_packing(NPP *npp, NPPROW *row)\n{     /* test if constraint is packing inequality */\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int b;\n      xassert(npp == npp);\n      if (!(row->lb == -DBL_MAX && row->ub != +DBL_MAX))\n         return 0;\n      b = 1;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  col = aij->col;\n         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n            return 0;\n         if (aij->val == +1.0)\n            ;\n         else if (aij->val == -1.0)\n            b--;\n         else\n            return 0;\n      }\n      if (row->ub != (double)b) return 0;\n      return 1;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "hidden_packing": {
      "start_point": [
        428,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "static int hidden_packing(NPP *npp, struct elem *ptr, double *_b)\n{     /* process inequality constraint: sum a[j] x[j] <= b;\n         0 - specified row is NOT hidden packing inequality;\n         1 - specified row is packing inequality;\n         2 - specified row is hidden packing inequality. */\n      struct elem *e, *ej, *ek;\n      int neg;\n      double b = *_b, eps;\n      xassert(npp == npp);\n      /* a[j] must be non-zero, x[j] must be binary, for all j in J */\n      for (e = ptr; e != NULL; e = e->next)\n      {  xassert(e->aj != 0.0);\n         xassert(e->xj->is_int);\n         xassert(e->xj->lb == 0.0 && e->xj->ub == 1.0);\n      }\n      /* check if the specified inequality constraint already has the\n         form of packing inequality */\n      neg = 0; /* neg is |Jn| */\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (e->aj == +1.0)\n            ;\n         else if (e->aj == -1.0)\n            neg++;\n         else\n            break;\n      }\n      if (e == NULL)\n      {  /* all coefficients a[j] are +1 or -1; check rhs b */\n         if (b == (double)(1 - neg))\n         {  /* it is packing inequality; no processing is needed */\n            return 1;\n         }\n      }\n      /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\n         positive; the result is a~[j] = |a[j]| and new rhs b */\n      for (e = ptr; e != NULL; e = e->next)\n         if (e->aj < 0) b -= e->aj;\n      /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\n      /* if a[j] > b, skip processing--this case must not appear */\n      for (e = ptr; e != NULL; e = e->next)\n         if (fabs(e->aj) > b) return 0;\n      /* now 0 < a[j] <= b for all j in J */\n      /* find two minimal coefficients a[j] and a[k], j != k */\n      ej = NULL;\n      for (e = ptr; e != NULL; e = e->next)\n         if (ej == NULL || fabs(ej->aj) > fabs(e->aj)) ej = e;\n      xassert(ej != NULL);\n      ek = NULL;\n      for (e = ptr; e != NULL; e = e->next)\n         if (e != ej)\n            if (ek == NULL || fabs(ek->aj) > fabs(e->aj)) ek = e;\n      xassert(ek != NULL);\n      /* the specified constraint is equivalent to packing inequality\n         iff a[j] + a[k] > b + eps */\n      eps = 1e-3 + 1e-6 * fabs(b);\n      if (fabs(ej->aj) + fabs(ek->aj) <= b + eps) return 0;\n      /* perform back substitution x~[j] = 1 - x[j] and construct the\n         final equivalent packing inequality in generalized format */\n      b = 1.0;\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (e->aj > 0.0)\n            e->aj = +1.0;\n         else /* e->aj < 0.0 */\n            e->aj = -1.0, b -= 1.0;\n      }\n      *_b = b;\n      return 2;\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_hidden_packing": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "int npp_hidden_packing(NPP *npp, NPPROW *row)\n{     /* identify hidden packing inequality */\n      NPPROW *copy;\n      NPPAIJ *aij;\n      struct elem *ptr, *e;\n      int kase, ret, count = 0;\n      double b;\n      /* the row must be inequality constraint */\n      xassert(row->lb < row->ub);\n      for (kase = 0; kase <= 1; kase++)\n      {  if (kase == 0)\n         {  /* process row upper bound */\n            if (row->ub == +DBL_MAX) continue;\n            ptr = copy_form(npp, row, +1.0);\n            b = + row->ub;\n         }\n         else\n         {  /* process row lower bound */\n            if (row->lb == -DBL_MAX) continue;\n            ptr = copy_form(npp, row, -1.0);\n            b = - row->lb;\n         }\n         /* now the inequality has the form \"sum a[j] x[j] <= b\" */\n         ret = hidden_packing(npp, ptr, &b);\n         xassert(0 <= ret && ret <= 2);\n         if (kase == 1 && ret == 1 || ret == 2)\n         {  /* the original inequality has been identified as hidden\n               packing inequality */\n            count++;\n#ifdef GLP_DEBUG\n            xprintf(\"Original constraint:\\n\");\n            for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n               xprintf(\" %+g x%d\", aij->val, aij->col->j);\n            if (row->lb != -DBL_MAX) xprintf(\", >= %g\", row->lb);\n            if (row->ub != +DBL_MAX) xprintf(\", <= %g\", row->ub);\n            xprintf(\"\\n\");\n            xprintf(\"Equivalent packing inequality:\\n\");\n            for (e = ptr; e != NULL; e = e->next)\n               xprintf(\" %sx%d\", e->aj > 0.0 ? \"+\" : \"-\", e->xj->j);\n            xprintf(\", <= %g\\n\", b);\n#endif\n            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)\n            {  /* the original row is single-sided inequality; no copy\n                  is needed */\n               copy = NULL;\n            }\n            else\n            {  /* the original row is double-sided inequality; we need\n                  to create its copy for other bound before replacing it\n                  with the equivalent inequality */\n               copy = npp_add_row(npp);\n               if (kase == 0)\n               {  /* the copy is for lower bound */\n                  copy->lb = row->lb, copy->ub = +DBL_MAX;\n               }\n               else\n               {  /* the copy is for upper bound */\n                  copy->lb = -DBL_MAX, copy->ub = row->ub;\n               }\n               /* copy original row coefficients */\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  npp_add_aij(npp, copy, aij->col, aij->val);\n            }\n            /* replace the original inequality by equivalent one */\n            npp_erase_row(npp, row);\n            row->lb = -DBL_MAX, row->ub = b;\n            for (e = ptr; e != NULL; e = e->next)\n               npp_add_aij(npp, row, e->xj, e->aj);\n            /* continue processing lower bound for the copy */\n            if (copy != NULL) row = copy;\n         }\n         drop_form(npp, ptr);\n      }\n      return count;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_implied_packing": {
      "start_point": [
        714,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "int npp_implied_packing(NPP *npp, NPPROW *row, int which,\n      NPPCOL *var[], char set[])\n{     struct elem *ptr, *e, *i, *k;\n      int len = 0;\n      double b, eps;\n      /* build inequality (3) */\n      if (which == 0)\n      {  ptr = copy_form(npp, row, -1.0);\n         xassert(row->lb != -DBL_MAX);\n         b = - row->lb;\n      }\n      else if (which == 1)\n      {  ptr = copy_form(npp, row, +1.0);\n         xassert(row->ub != +DBL_MAX);\n         b = + row->ub;\n      }\n      /* remove non-binary variables to build relaxed inequality (5);\n         compute its right-hand side b~ with formula (6) */\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (!(e->xj->is_int && e->xj->lb == 0.0 && e->xj->ub == 1.0))\n         {  /* x[j] is non-binary variable */\n            if (e->aj > 0.0)\n            {  if (e->xj->lb == -DBL_MAX) goto done;\n               b -= e->aj * e->xj->lb;\n            }\n            else /* e->aj < 0.0 */\n            {  if (e->xj->ub == +DBL_MAX) goto done;\n               b -= e->aj * e->xj->ub;\n            }\n            /* a[j] = 0 means that variable x[j] is removed */\n            e->aj = 0.0;\n         }\n      }\n      /* substitute x[j] = 1 - x~[j] to build knapsack inequality (8);\n         compute its right-hand side beta with formula (11) */\n      for (e = ptr; e != NULL; e = e->next)\n         if (e->aj < 0.0) b -= e->aj;\n      /* if beta is close to zero, the knapsack inequality is either\n         infeasible or forcing inequality; this must never happen, so\n         we skip further analysis */\n      if (b < 1e-3) goto done;\n      /* build set P as well as sets Jp and Jn, and determine x[k] as\n         explained above in comments to the routine */\n      eps = 1e-3 + 1e-6 * b;\n      i = k = NULL;\n      for (e = ptr; e != NULL; e = e->next)\n      {  /* note that alfa[j] = |a[j]| */\n         if (fabs(e->aj) > 0.5 * (b + eps))\n         {  /* alfa[j] > (b + eps) / 2; include x[j] in set P, i.e. in\n               set Jp or Jn */\n            var[++len] = e->xj;\n            set[len] = (char)(e->aj > 0.0 ? 0 : 1);\n            /* alfa[i] = min alfa[j] over all j included in set P */\n            if (i == NULL || fabs(i->aj) > fabs(e->aj)) i = e;\n         }\n         else if (fabs(e->aj) >= 1e-3)\n         {  /* alfa[k] = max alfa[j] over all j not included in set P;\n               we skip coefficient a[j] if it is close to zero to avoid\n               numerically unreliable results */\n            if (k == NULL || fabs(k->aj) < fabs(e->aj)) k = e;\n         }\n      }\n      /* if alfa[k] satisfies to condition (13) for all j in P, include\n         x[k] in P */\n      if (i != NULL && k != NULL && fabs(i->aj) + fabs(k->aj) > b + eps)\n      {  var[++len] = k->xj;\n         set[len] = (char)(k->aj > 0.0 ? 0 : 1);\n      }\n      /* trivial packing inequality being redundant must never appear,\n         so we just ignore it */\n      if (len < 2) len = 0;\ndone: drop_form(npp, ptr);\n      return len;\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_is_covering": {
      "start_point": [
        837,
        0
      ],
      "end_point": [
        859,
        1
      ],
      "content": "int npp_is_covering(NPP *npp, NPPROW *row)\n{     /* test if constraint is covering inequality */\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int b;\n      xassert(npp == npp);\n      if (!(row->lb != -DBL_MAX && row->ub == +DBL_MAX))\n         return 0;\n      b = 1;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  col = aij->col;\n         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n            return 0;\n         if (aij->val == +1.0)\n            ;\n         else if (aij->val == -1.0)\n            b--;\n         else\n            return 0;\n      }\n      if (row->lb != (double)b) return 0;\n      return 1;\n}",
      "lines": 23,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "hidden_covering": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "static int hidden_covering(NPP *npp, struct elem *ptr, double *_b)\n{     /* process inequality constraint: sum a[j] x[j] >= b;\n         0 - specified row is NOT hidden covering inequality;\n         1 - specified row is covering inequality;\n         2 - specified row is hidden covering inequality. */\n      struct elem *e;\n      int neg;\n      double b = *_b, eps;\n      xassert(npp == npp);\n      /* a[j] must be non-zero, x[j] must be binary, for all j in J */\n      for (e = ptr; e != NULL; e = e->next)\n      {  xassert(e->aj != 0.0);\n         xassert(e->xj->is_int);\n         xassert(e->xj->lb == 0.0 && e->xj->ub == 1.0);\n      }\n      /* check if the specified inequality constraint already has the\n         form of covering inequality */\n      neg = 0; /* neg is |Jn| */\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (e->aj == +1.0)\n            ;\n         else if (e->aj == -1.0)\n            neg++;\n         else\n            break;\n      }\n      if (e == NULL)\n      {  /* all coefficients a[j] are +1 or -1; check rhs b */\n         if (b == (double)(1 - neg))\n         {  /* it is covering inequality; no processing is needed */\n            return 1;\n         }\n      }\n      /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\n         positive; the result is a~[j] = |a[j]| and new rhs b */\n      for (e = ptr; e != NULL; e = e->next)\n         if (e->aj < 0) b -= e->aj;\n      /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\n      /* if b <= 0, skip processing--this case must not appear */\n      if (b < 1e-3) return 0;\n      /* now a[j] > 0 for all j in J, and b > 0 */\n      /* the specified constraint is equivalent to covering inequality\n         iff a[j] >= b for all j in J */\n      eps = 1e-9 + 1e-12 * fabs(b);\n      for (e = ptr; e != NULL; e = e->next)\n         if (fabs(e->aj) < b - eps) return 0;\n      /* perform back substitution x~[j] = 1 - x[j] and construct the\n         final equivalent covering inequality in generalized format */\n      b = 1.0;\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (e->aj > 0.0)\n            e->aj = +1.0;\n         else /* e->aj < 0.0 */\n            e->aj = -1.0, b -= 1.0;\n      }\n      *_b = b;\n      return 2;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_hidden_covering": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1064,
        1
      ],
      "content": "int npp_hidden_covering(NPP *npp, NPPROW *row)\n{     /* identify hidden covering inequality */\n      NPPROW *copy;\n      NPPAIJ *aij;\n      struct elem *ptr, *e;\n      int kase, ret, count = 0;\n      double b;\n      /* the row must be inequality constraint */\n      xassert(row->lb < row->ub);\n      for (kase = 0; kase <= 1; kase++)\n      {  if (kase == 0)\n         {  /* process row lower bound */\n            if (row->lb == -DBL_MAX) continue;\n            ptr = copy_form(npp, row, +1.0);\n            b = + row->lb;\n         }\n         else\n         {  /* process row upper bound */\n            if (row->ub == +DBL_MAX) continue;\n            ptr = copy_form(npp, row, -1.0);\n            b = - row->ub;\n         }\n         /* now the inequality has the form \"sum a[j] x[j] >= b\" */\n         ret = hidden_covering(npp, ptr, &b);\n         xassert(0 <= ret && ret <= 2);\n         if (kase == 1 && ret == 1 || ret == 2)\n         {  /* the original inequality has been identified as hidden\n               covering inequality */\n            count++;\n#ifdef GLP_DEBUG\n            xprintf(\"Original constraint:\\n\");\n            for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n               xprintf(\" %+g x%d\", aij->val, aij->col->j);\n            if (row->lb != -DBL_MAX) xprintf(\", >= %g\", row->lb);\n            if (row->ub != +DBL_MAX) xprintf(\", <= %g\", row->ub);\n            xprintf(\"\\n\");\n            xprintf(\"Equivalent covering inequality:\\n\");\n            for (e = ptr; e != NULL; e = e->next)\n               xprintf(\" %sx%d\", e->aj > 0.0 ? \"+\" : \"-\", e->xj->j);\n            xprintf(\", >= %g\\n\", b);\n#endif\n            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)\n            {  /* the original row is single-sided inequality; no copy\n                  is needed */\n               copy = NULL;\n            }\n            else\n            {  /* the original row is double-sided inequality; we need\n                  to create its copy for other bound before replacing it\n                  with the equivalent inequality */\n               copy = npp_add_row(npp);\n               if (kase == 0)\n               {  /* the copy is for upper bound */\n                  copy->lb = -DBL_MAX, copy->ub = row->ub;\n               }\n               else\n               {  /* the copy is for lower bound */\n                  copy->lb = row->lb, copy->ub = +DBL_MAX;\n               }\n               /* copy original row coefficients */\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  npp_add_aij(npp, copy, aij->col, aij->val);\n            }\n            /* replace the original inequality by equivalent one */\n            npp_erase_row(npp, row);\n            row->lb = b, row->ub = +DBL_MAX;\n            for (e = ptr; e != NULL; e = e->next)\n               npp_add_aij(npp, row, e->xj, e->aj);\n            /* continue processing upper bound for the copy */\n            if (copy != NULL) row = copy;\n         }\n         drop_form(npp, ptr);\n      }\n      return count;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_is_partitioning": {
      "start_point": [
        1109,
        0
      ],
      "end_point": [
        1130,
        1
      ],
      "content": "int npp_is_partitioning(NPP *npp, NPPROW *row)\n{     /* test if constraint is partitioning equality */\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int b;\n      xassert(npp == npp);\n      if (row->lb != row->ub) return 0;\n      b = 1;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  col = aij->col;\n         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n            return 0;\n         if (aij->val == +1.0)\n            ;\n         else if (aij->val == -1.0)\n            b--;\n         else\n            return 0;\n      }\n      if (row->lb != (double)b) return 0;\n      return 1;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "reduce_ineq_coef": {
      "start_point": [
        1274,
        0
      ],
      "end_point": [
        1339,
        1
      ],
      "content": "static int reduce_ineq_coef(NPP *npp, struct elem *ptr, double *_b)\n{     /* process inequality constraint: sum a[j] x[j] >= b */\n      /* returns: the number of coefficients reduced */\n      struct elem *e;\n      int count = 0;\n      double h, inf_t, new_a, b = *_b;\n      xassert(npp == npp);\n      /* compute h; see (15) */\n      h = 0.0;\n      for (e = ptr; e != NULL; e = e->next)\n      {  if (e->aj > 0.0)\n         {  if (e->xj->lb == -DBL_MAX) goto done;\n            h += e->aj * e->xj->lb;\n         }\n         else /* e->aj < 0.0 */\n         {  if (e->xj->ub == +DBL_MAX) goto done;\n            h += e->aj * e->xj->ub;\n         }\n      }\n      /* perform reduction of coefficients at binary variables */\n      for (e = ptr; e != NULL; e = e->next)\n      {  /* skip non-binary variable */\n         if (!(e->xj->is_int && e->xj->lb == 0.0 && e->xj->ub == 1.0))\n            continue;\n         if (e->aj > 0.0)\n         {  /* compute inf t[k]; see (14) */\n            inf_t = h;\n            if (b - e->aj < inf_t && inf_t < b)\n            {  /* compute reduced coefficient a'[k]; see (7) */\n               new_a = b - inf_t;\n               if (new_a >= +1e-3 &&\n                   e->aj - new_a >= 0.01 * (1.0 + e->aj))\n               {  /* accept a'[k] */\n#ifdef GLP_DEBUG\n                  xprintf(\"+\");\n#endif\n                  e->aj = new_a;\n                  count++;\n               }\n            }\n         }\n         else /* e->aj < 0.0 */\n         {  /* compute inf t[k]; see (14) */\n            inf_t = h - e->aj;\n            if (b < inf_t && inf_t < b - e->aj)\n            {  /* compute reduced coefficient a'[k]; see (11) */\n               new_a = e->aj + (inf_t - b);\n               if (new_a <= -1e-3 &&\n                   new_a - e->aj >= 0.01 * (1.0 - e->aj))\n               {  /* accept a'[k] */\n#ifdef GLP_DEBUG\n                  xprintf(\"-\");\n#endif\n                  e->aj = new_a;\n                  /* update h; see (17) */\n                  h += (inf_t - b);\n                  /* compute b'; see (9) */\n                  b = inf_t;\n                  count++;\n               }\n            }\n         }\n      }\n      *_b = b;\ndone: return count;\n}",
      "lines": 66,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_reduce_ineq_coef": {
      "start_point": [
        1341,
        0
      ],
      "end_point": [
        1411,
        1
      ],
      "content": "int npp_reduce_ineq_coef(NPP *npp, NPPROW *row)\n{     /* reduce inequality constraint coefficients */\n      NPPROW *copy;\n      NPPAIJ *aij;\n      struct elem *ptr, *e;\n      int kase, count[2];\n      double b;\n      /* the row must be inequality constraint */\n      xassert(row->lb < row->ub);\n      count[0] = count[1] = 0;\n      for (kase = 0; kase <= 1; kase++)\n      {  if (kase == 0)\n         {  /* process row lower bound */\n            if (row->lb == -DBL_MAX) continue;\n#ifdef GLP_DEBUG\n            xprintf(\"L\");\n#endif\n            ptr = copy_form(npp, row, +1.0);\n            b = + row->lb;\n         }\n         else\n         {  /* process row upper bound */\n            if (row->ub == +DBL_MAX) continue;\n#ifdef GLP_DEBUG\n            xprintf(\"U\");\n#endif\n            ptr = copy_form(npp, row, -1.0);\n            b = - row->ub;\n         }\n         /* now the inequality has the form \"sum a[j] x[j] >= b\" */\n         count[kase] = reduce_ineq_coef(npp, ptr, &b);\n         if (count[kase] > 0)\n         {  /* the original inequality has been replaced by equivalent\n               one with coefficients reduced */\n            if (row->lb == -DBL_MAX || row->ub == +DBL_MAX)\n            {  /* the original row is single-sided inequality; no copy\n                  is needed */\n               copy = NULL;\n            }\n            else\n            {  /* the original row is double-sided inequality; we need\n                  to create its copy for other bound before replacing it\n                  with the equivalent inequality */\n#ifdef GLP_DEBUG\n               xprintf(\"*\");\n#endif\n               copy = npp_add_row(npp);\n               if (kase == 0)\n               {  /* the copy is for upper bound */\n                  copy->lb = -DBL_MAX, copy->ub = row->ub;\n               }\n               else\n               {  /* the copy is for lower bound */\n                  copy->lb = row->lb, copy->ub = +DBL_MAX;\n               }\n               /* copy original row coefficients */\n               for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                  npp_add_aij(npp, copy, aij->col, aij->val);\n            }\n            /* replace the original inequality by equivalent one */\n            npp_erase_row(npp, row);\n            row->lb = b, row->ub = +DBL_MAX;\n            for (e = ptr; e != NULL; e = e->next)\n               npp_add_aij(npp, row, e->xj, e->aj);\n            /* continue processing upper bound for the copy */\n            if (copy != NULL) row = copy;\n         }\n         drop_form(npp, ptr);\n      }\n      return count[0] + count[1];\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/npp/npp5.c": {
    "npp_clean_prob": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "void npp_clean_prob(NPP *npp)\n{     /* perform initial LP/MIP processing */\n      NPPROW *row, *next_row;\n      NPPCOL *col, *next_col;\n      int ret;\n      xassert(npp == npp);\n      /* process rows which originally are free */\n      for (row = npp->r_head; row != NULL; row = next_row)\n      {  next_row = row->next;\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n         {  /* process free row */\n#ifdef GLP_DEBUG\n            xprintf(\"1\");\n#endif\n            npp_free_row(npp, row);\n            /* row was deleted */\n         }\n      }\n      /* process rows which originally are double-sided inequalities */\n      for (row = npp->r_head; row != NULL; row = next_row)\n      {  next_row = row->next;\n         if (row->lb != -DBL_MAX && row->ub != +DBL_MAX &&\n             row->lb < row->ub)\n         {  ret = npp_make_equality(npp, row);\n            if (ret == 0)\n               ;\n            else if (ret == 1)\n            {  /* row was replaced by equality constraint */\n#ifdef GLP_DEBUG\n               xprintf(\"2\");\n#endif\n            }\n            else\n               xassert(ret != ret);\n         }\n      }\n      /* process columns which are originally fixed */\n      for (col = npp->c_head; col != NULL; col = next_col)\n      {  next_col = col->next;\n         if (col->lb == col->ub)\n         {  /* process fixed column */\n#ifdef GLP_DEBUG\n            xprintf(\"3\");\n#endif\n            npp_fixed_col(npp, col);\n            /* column was deleted */\n         }\n      }\n      /* process columns which are originally double-bounded */\n      for (col = npp->c_head; col != NULL; col = next_col)\n      {  next_col = col->next;\n         if (col->lb != -DBL_MAX && col->ub != +DBL_MAX &&\n             col->lb < col->ub)\n         {  ret = npp_make_fixed(npp, col);\n            if (ret == 0)\n               ;\n            else if (ret == 1)\n            {  /* column was replaced by fixed column; process it */\n#ifdef GLP_DEBUG\n               xprintf(\"4\");\n#endif\n               npp_fixed_col(npp, col);\n               /* column was deleted */\n            }\n         }\n      }\n      return;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "npp_process_row": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int npp_process_row(NPP *npp, NPPROW *row, int hard)\n{     /* perform basic row processing */\n      NPPCOL *col;\n      NPPAIJ *aij, *next_aij, *aaa;\n      int ret;\n      /* row must not be free */\n      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));\n      /* start processing row */\n      if (row->ptr == NULL)\n      {  /* empty row */\n         ret = npp_empty_row(npp, row);\n         if (ret == 0)\n         {  /* row was deleted */\n#ifdef GLP_DEBUG\n            xprintf(\"A\");\n#endif\n            return 0;\n         }\n         else if (ret == 1)\n         {  /* primal infeasibility */\n            return GLP_ENOPFS;\n         }\n         else\n            xassert(ret != ret);\n      }\n      if (row->ptr->r_next == NULL)\n      {  /* row singleton */\n         col = row->ptr->col;\n         if (row->lb == row->ub)\n         {  /* equality constraint */\n            ret = npp_eq_singlet(npp, row);\n            if (ret == 0)\n            {  /* column was fixed, row was deleted */\n#ifdef GLP_DEBUG\n               xprintf(\"B\");\n#endif\n               /* activate rows affected by column */\n               for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n                  npp_activate_row(npp, aij->row);\n               /* process fixed column */\n               npp_fixed_col(npp, col);\n               /* column was deleted */\n               return 0;\n            }\n            else if (ret == 1 || ret == 2)\n            {  /* primal/integer infeasibility */\n               return GLP_ENOPFS;\n            }\n            else\n               xassert(ret != ret);\n         }\n         else\n         {  /* inequality constraint */\n            ret = npp_ineq_singlet(npp, row);\n            if (0 <= ret && ret <= 3)\n            {  /* row was deleted */\n#ifdef GLP_DEBUG\n               xprintf(\"C\");\n#endif\n               /* activate column, since its length was changed due to\n                  row deletion */\n               npp_activate_col(npp, col);\n               if (ret >= 2)\n               {  /* column bounds changed significantly or column was\n                     fixed */\n                  /* activate rows affected by column */\n                  for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n                     npp_activate_row(npp, aij->row);\n               }\n               if (ret == 3)\n               {  /* column was fixed; process it */\n#ifdef GLP_DEBUG\n                  xprintf(\"D\");\n#endif\n                  npp_fixed_col(npp, col);\n                  /* column was deleted */\n               }\n               return 0;\n            }\n            else if (ret == 4)\n            {  /* primal infeasibility */\n               return GLP_ENOPFS;\n            }\n            else\n               xassert(ret != ret);\n         }\n      }\n#if 0\n      /* sometimes this causes too large round-off errors; probably\n         pivot coefficient should be chosen more carefully */\n      if (row->ptr->r_next->r_next == NULL)\n      {  /* row doubleton */\n         if (row->lb == row->ub)\n         {  /* equality constraint */\n            if (!(row->ptr->col->is_int ||\n                  row->ptr->r_next->col->is_int))\n            {  /* both columns are continuous */\n               NPPCOL *q;\n               q = npp_eq_doublet(npp, row);\n               if (q != NULL)\n               {  /* column q was eliminated */\n#ifdef GLP_DEBUG\n                  xprintf(\"E\");\n#endif\n                  /* now column q is singleton of type \"implied slack\n                     variable\"; we process it here to make sure that on\n                     recovering basic solution the row is always active\n                     equality constraint (as required by the routine\n                     rcv_eq_doublet) */\n                  xassert(npp_process_col(npp, q) == 0);\n                  /* column q was deleted; note that row p also may be\n                     deleted */\n                  return 0;\n               }\n            }\n         }\n      }\n#endif\n      /* general row analysis */\n      ret = npp_analyze_row(npp, row);\n      xassert(0x00 <= ret && ret <= 0xFF);\n      if (ret == 0x33)\n      {  /* row bounds are inconsistent with column bounds */\n         return GLP_ENOPFS;\n      }\n      if ((ret & 0x0F) == 0x00)\n      {  /* row lower bound does not exist or redundant */\n         if (row->lb != -DBL_MAX)\n         {  /* remove redundant row lower bound */\n#ifdef GLP_DEBUG\n            xprintf(\"F\");\n#endif\n            npp_inactive_bound(npp, row, 0);\n         }\n      }\n      else if ((ret & 0x0F) == 0x01)\n      {  /* row lower bound can be active */\n         /* see below */\n      }\n      else if ((ret & 0x0F) == 0x02)\n      {  /* row lower bound is a forcing bound */\n#ifdef GLP_DEBUG\n         xprintf(\"G\");\n#endif\n         /* process forcing row */\n         if (npp_forcing_row(npp, row, 0) == 0)\nfixup:   {  /* columns were fixed, row was made free */\n            for (aij = row->ptr; aij != NULL; aij = next_aij)\n            {  /* process column fixed by forcing row */\n#ifdef GLP_DEBUG\n               xprintf(\"H\");\n#endif\n               col = aij->col;\n               next_aij = aij->r_next;\n               /* activate rows affected by column */\n               for (aaa = col->ptr; aaa != NULL; aaa = aaa->c_next)\n                  npp_activate_row(npp, aaa->row);\n               /* process fixed column */\n               npp_fixed_col(npp, col);\n               /* column was deleted */\n            }\n            /* process free row (which now is empty due to deletion of\n               all its columns) */\n            npp_free_row(npp, row);\n            /* row was deleted */\n            return 0;\n         }\n      }\n      else\n         xassert(ret != ret);\n      if ((ret & 0xF0) == 0x00)\n      {  /* row upper bound does not exist or redundant */\n         if (row->ub != +DBL_MAX)\n         {  /* remove redundant row upper bound */\n#ifdef GLP_DEBUG\n            xprintf(\"I\");\n#endif\n            npp_inactive_bound(npp, row, 1);\n         }\n      }\n      else if ((ret & 0xF0) == 0x10)\n      {  /* row upper bound can be active */\n         /* see below */\n      }\n      else if ((ret & 0xF0) == 0x20)\n      {  /* row upper bound is a forcing bound */\n#ifdef GLP_DEBUG\n         xprintf(\"J\");\n#endif\n         /* process forcing row */\n         if (npp_forcing_row(npp, row, 1) == 0) goto fixup;\n      }\n      else\n         xassert(ret != ret);\n      if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n      {  /* row became free due to redundant bounds removal */\n#ifdef GLP_DEBUG\n         xprintf(\"K\");\n#endif\n         /* activate its columns, since their length will change due\n            to row deletion */\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n            npp_activate_col(npp, aij->col);\n         /* process free row */\n         npp_free_row(npp, row);\n         /* row was deleted */\n         return 0;\n      }\n#if 1 /* 23/XII-2009 */\n      /* row lower and/or upper bounds can be active */\n      if (npp->sol == GLP_MIP && hard)\n      {  /* improve current column bounds (optional) */\n         if (npp_improve_bounds(npp, row, 1) < 0)\n            return GLP_ENOPFS;\n      }\n#endif\n      return 0;\n}",
      "lines": 218,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "npp_improve_bounds": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "int npp_improve_bounds(NPP *npp, NPPROW *row, int flag)\n{     /* improve current column bounds */\n      NPPCOL *col;\n      NPPAIJ *aij, *next_aij, *aaa;\n      int kase, ret, count = 0;\n      double lb, ub;\n      xassert(npp->sol == GLP_MIP);\n      /* row must not be free */\n      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));\n      /* determine implied column bounds */\n      npp_implied_bounds(npp, row);\n      /* and use these bounds to strengthen current column bounds */\n      for (aij = row->ptr; aij != NULL; aij = next_aij)\n      {  col = aij->col;\n         next_aij = aij->r_next;\n         for (kase = 0; kase <= 1; kase++)\n         {  /* save current column bounds */\n            lb = col->lb, ub = col->ub;\n            if (kase == 0)\n            {  /* process implied column lower bound */\n               if (col->ll.ll == -DBL_MAX) continue;\n               ret = npp_implied_lower(npp, col, col->ll.ll);\n            }\n            else\n            {  /* process implied column upper bound */\n               if (col->uu.uu == +DBL_MAX) continue;\n               ret = npp_implied_upper(npp, col, col->uu.uu);\n            }\n            if (ret == 0 || ret == 1)\n            {  /* current column bounds did not change or changed, but\n                  not significantly; restore current column bounds */\n               col->lb = lb, col->ub = ub;\n            }\n            else if (ret == 2 || ret == 3)\n            {  /* current column bounds changed significantly or column\n                  was fixed */\n#ifdef GLP_DEBUG\n               xprintf(\"L\");\n#endif\n               count++;\n               /* activate other rows affected by column, if required */\n               if (flag)\n               {  for (aaa = col->ptr; aaa != NULL; aaa = aaa->c_next)\n                  {  if (aaa->row != row)\n                        npp_activate_row(npp, aaa->row);\n                  }\n               }\n               if (ret == 3)\n               {  /* process fixed column */\n#ifdef GLP_DEBUG\n                  xprintf(\"M\");\n#endif\n                  npp_fixed_col(npp, col);\n                  /* column was deleted */\n                  break; /* for kase */\n               }\n            }\n            else if (ret == 4)\n            {  /* primal/integer infeasibility */\n               return -1;\n            }\n            else\n               xassert(ret != ret);\n         }\n      }\n      return count;\n}",
      "lines": 67,
      "depth": 19,
      "decorators": [
        "int"
      ]
    },
    "npp_process_col": {
      "start_point": [
        521,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "int npp_process_col(NPP *npp, NPPCOL *col)\n{     /* perform basic column processing */\n      NPPROW *row;\n      NPPAIJ *aij;\n      int ret;\n      /* column must not be fixed */\n      xassert(col->lb < col->ub);\n      /* start processing column */\n      if (col->ptr == NULL)\n      {  /* empty column */\n         ret = npp_empty_col(npp, col);\n         if (ret == 0)\n         {  /* column was fixed and deleted */\n#ifdef GLP_DEBUG\n            xprintf(\"N\");\n#endif\n            return 0;\n         }\n         else if (ret == 1)\n         {  /* dual infeasibility */\n            return GLP_ENODFS;\n         }\n         else\n            xassert(ret != ret);\n      }\n      if (col->ptr->c_next == NULL)\n      {  /* column singleton */\n         row = col->ptr->row;\n         if (row->lb == row->ub)\n         {  /* equality constraint */\n            if (!col->is_int)\nslack:      {  /* implied slack variable */\n#ifdef GLP_DEBUG\n               xprintf(\"O\");\n#endif\n               npp_implied_slack(npp, col);\n               /* column was deleted */\n               if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n               {  /* row became free due to implied slack variable */\n#ifdef GLP_DEBUG\n                  xprintf(\"P\");\n#endif\n                  /* activate columns affected by row */\n                  for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n                     npp_activate_col(npp, aij->col);\n                  /* process free row */\n                  npp_free_row(npp, row);\n                  /* row was deleted */\n               }\n               else\n               {  /* row became inequality constraint; activate it\n                     since its length changed due to column deletion */\n                  npp_activate_row(npp, row);\n               }\n               return 0;\n            }\n         }\n         else\n         {  /* inequality constraint */\n            if (!col->is_int)\n            {  ret = npp_implied_free(npp, col);\n               if (ret == 0)\n               {  /* implied free variable */\n#ifdef GLP_DEBUG\n                  xprintf(\"Q\");\n#endif\n                  /* column bounds were removed, row was replaced by\n                     equality constraint */\n                  goto slack;\n               }\n               else if (ret == 1)\n               {  /* column is not implied free variable, because its\n                     lower and/or upper bounds can be active */\n               }\n               else if (ret == 2)\n               {  /* dual infeasibility */\n                  return GLP_ENODFS;\n               }\n            }\n         }\n      }\n      /* column still exists */\n      return 0;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "npp_process_prob": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "int npp_process_prob(NPP *npp, int hard)\n{     /* perform basic LP/MIP processing */\n      NPPROW *row;\n      NPPCOL *col;\n      int processing, ret;\n      /* perform initial LP/MIP processing */\n      npp_clean_prob(npp);\n      /* activate all remaining rows and columns */\n      for (row = npp->r_head; row != NULL; row = row->next)\n         row->temp = 1;\n      for (col = npp->c_head; col != NULL; col = col->next)\n         col->temp = 1;\n      /* main processing loop */\n      processing = 1;\n      while (processing)\n      {  processing = 0;\n         /* process all active rows */\n         for (;;)\n         {  row = npp->r_head;\n            if (row == NULL || !row->temp) break;\n            npp_deactivate_row(npp, row);\n            ret = npp_process_row(npp, row, hard);\n            if (ret != 0) goto done;\n            processing = 1;\n         }\n         /* process all active columns */\n         for (;;)\n         {  col = npp->c_head;\n            if (col == NULL || !col->temp) break;\n            npp_deactivate_col(npp, col);\n            ret = npp_process_col(npp, col);\n            if (ret != 0) goto done;\n            processing = 1;\n         }\n      }\n#if 1 /* 23/XII-2009 */\n      if (npp->sol == GLP_MIP && !hard)\n      {  /* improve current column bounds (optional) */\n         for (row = npp->r_head; row != NULL; row = row->next)\n         {  if (npp_improve_bounds(npp, row, 0) < 0)\n            {  ret = GLP_ENOPFS;\n               goto done;\n            }\n         }\n      }\n#endif\n      /* all seems ok */\n      ret = 0;\ndone: xassert(ret == 0 || ret == GLP_ENOPFS || ret == GLP_ENODFS);\n#ifdef GLP_DEBUG\n      xprintf(\"\\n\");\n#endif\n      return ret;\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "npp_simplex": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "int npp_simplex(NPP *npp, const glp_smcp *parm)\n{     /* process LP prior to applying primal/dual simplex method */\n      int ret;\n      xassert(npp->sol == GLP_SOL);\n      xassert(parm == parm);\n      ret = npp_process_prob(npp, 0);\n      return ret;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "npp_integer": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "int npp_integer(NPP *npp, const glp_iocp *parm)\n{     /* process MIP prior to applying branch-and-bound method */\n      NPPROW *row, *prev_row;\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int count, ret;\n      xassert(npp->sol == GLP_MIP);\n      xassert(parm == parm);\n      /*==============================================================*/\n      /* perform basic MIP processing */\n      ret = npp_process_prob(npp, 1);\n      if (ret != 0) goto done;\n      /*==============================================================*/\n      /* binarize problem, if required */\n      if (parm->binarize)\n         npp_binarize_prob(npp);\n      /*==============================================================*/\n      /* identify hidden packing inequalities */\n      count = 0;\n      /* new rows will be added to the end of the row list, so we go\n         from the end to beginning of the row list */\n      for (row = npp->r_tail; row != NULL; row = prev_row)\n      {  prev_row = row->prev;\n         /* skip free row */\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX) continue;\n         /* skip equality constraint */\n         if (row->lb == row->ub) continue;\n         /* skip row having less than two variables */\n         if (row->ptr == NULL || row->ptr->r_next == NULL) continue;\n         /* skip row having non-binary variables */\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  col = aij->col;\n            if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n               break;\n         }\n         if (aij != NULL) continue;\n         count += npp_hidden_packing(npp, row);\n      }\n      if (count > 0)\n         xprintf(\"%d hidden packing inequaliti(es) were detected\\n\",\n            count);\n      /*==============================================================*/\n      /* identify hidden covering inequalities */\n      count = 0;\n      /* new rows will be added to the end of the row list, so we go\n         from the end to beginning of the row list */\n      for (row = npp->r_tail; row != NULL; row = prev_row)\n      {  prev_row = row->prev;\n         /* skip free row */\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX) continue;\n         /* skip equality constraint */\n         if (row->lb == row->ub) continue;\n         /* skip row having less than three variables */\n         if (row->ptr == NULL || row->ptr->r_next == NULL ||\n             row->ptr->r_next->r_next == NULL) continue;\n         /* skip row having non-binary variables */\n         for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         {  col = aij->col;\n            if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n               break;\n         }\n         if (aij != NULL) continue;\n         count += npp_hidden_covering(npp, row);\n      }\n      if (count > 0)\n         xprintf(\"%d hidden covering inequaliti(es) were detected\\n\",\n            count);\n      /*==============================================================*/\n      /* reduce inequality constraint coefficients */\n      count = 0;\n      /* new rows will be added to the end of the row list, so we go\n         from the end to beginning of the row list */\n      for (row = npp->r_tail; row != NULL; row = prev_row)\n      {  prev_row = row->prev;\n         /* skip equality constraint */\n         if (row->lb == row->ub) continue;\n         count += npp_reduce_ineq_coef(npp, row);\n      }\n      if (count > 0)\n         xprintf(\"%d constraint coefficient(s) were reduced\\n\", count);\n      /*==============================================================*/\n#ifdef GLP_DEBUG\n      routine(npp);\n#endif\n      /*==============================================================*/\n      /* all seems ok */\n      ret = 0;\ndone: return ret;\n}",
      "lines": 89,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/npp/npp6.c": {
    "npp_sat_free_row": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void npp_sat_free_row(NPP *npp, NPPROW *p)\n{     /* the row should be free */\n      xassert(p->lb == -DBL_MAX && p->ub == +DBL_MAX);\n      /* remove the row from the problem */\n      npp_del_row(npp, p);\n      return;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "npp_sat_fixed_col": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int npp_sat_fixed_col(NPP *npp, NPPCOL *q)\n{     struct sat_fixed_col *info;\n      NPPROW *i;\n      NPPAIJ *aij;\n      int temp;\n      /* the column should be fixed */\n      xassert(q->lb == q->ub);\n      /* create transformation stack entry */\n      info = npp_push_tse(npp,\n         rcv_sat_fixed_col, sizeof(struct sat_fixed_col));\n      info->q = q->j;\n      info->s = (int)q->lb;\n      xassert((double)info->s == q->lb);\n      /* substitute x[q] = s[q] into constraint rows */\n      if (info->s == 0)\n         goto skip;\n      for (aij = q->ptr; aij != NULL; aij = aij->c_next)\n      {  i = aij->row;\n         if (i->lb != -DBL_MAX)\n         {  i->lb -= aij->val * (double)info->s;\n            temp = (int)i->lb;\n            if ((double)temp != i->lb)\n               return 1; /* integer arithmetic error */\n         }\n         if (i->ub != +DBL_MAX)\n         {  i->ub -= aij->val * (double)info->s;\n            temp = (int)i->ub;\n            if ((double)temp != i->ub)\n               return 2; /* integer arithmetic error */\n         }\n      }\nskip: /* remove the column from the problem */\n      npp_del_col(npp, q);\n      return 0;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "rcv_sat_fixed_col": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static int rcv_sat_fixed_col(NPP *npp, void *info_)\n{     struct sat_fixed_col *info = info_;\n      npp->c_value[info->q] = (double)info->s;\n      return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "npp_sat_is_bin_comb": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "int npp_sat_is_bin_comb(NPP *npp, NPPROW *row)\n{     NPPCOL *col;\n      NPPAIJ *aij;\n      xassert(npp == npp);\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  if (!(aij->val == +1.0 || aij->val == -1.0))\n            return 0; /* non-unity coefficient */\n         col = aij->col;\n         if (!(col->is_int && col->lb == 0.0 && col->ub == 1.0))\n            return 0; /* non-binary column */\n      }\n      return 1; /* test was passed */\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_num_pos_coef": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int npp_sat_num_pos_coef(NPP *npp, NPPROW *row)\n{     NPPAIJ *aij;\n      int num = 0;\n      xassert(npp == npp);\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->val > 0.0)\n            num++;\n      }\n      return num;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_num_neg_coef": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int npp_sat_num_neg_coef(NPP *npp, NPPROW *row)\n{     NPPAIJ *aij;\n      int num = 0;\n      xassert(npp == npp);\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->val < 0.0)\n            num++;\n      }\n      return num;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_is_cover_ineq": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int npp_sat_is_cover_ineq(NPP *npp, NPPROW *row)\n{     xassert(npp == npp);\n      if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)\n      {  /* row is inequality of '>=' type */\n         if (npp_sat_is_bin_comb(npp, row))\n         {  /* row is a binary combination */\n            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))\n            {  /* row has the form (2) */\n               return 1;\n            }\n         }\n      }\n      else if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)\n      {  /* row is inequality of '<=' type */\n         if (npp_sat_is_bin_comb(npp, row))\n         {  /* row is a binary combination */\n            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)\n            {  /* row has the form (3) */\n               return 2;\n            }\n         }\n      }\n      /* row is not a covering inequality */\n      return 0;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_is_pack_ineq": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "int npp_sat_is_pack_ineq(NPP *npp, NPPROW *row)\n{     xassert(npp == npp);\n      if (row->lb == -DBL_MAX && row->ub != +DBL_MAX)\n      {  /* row is inequality of '<=' type */\n         if (npp_sat_is_bin_comb(npp, row))\n         {  /* row is a binary combination */\n            if (row->ub == 1.0 - npp_sat_num_neg_coef(npp, row))\n            {  /* row has the form (2) */\n               return 1;\n            }\n         }\n      }\n      else if (row->lb != -DBL_MAX && row->ub == +DBL_MAX)\n      {  /* row is inequality of '>=' type */\n         if (npp_sat_is_bin_comb(npp, row))\n         {  /* row is a binary combination */\n            if (row->lb == npp_sat_num_pos_coef(npp, row) - 1.0)\n            {  /* row has the form (3) */\n               return 2;\n            }\n         }\n      }\n      /* row is not a packing inequality */\n      return 0;\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_is_partn_eq": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "int npp_sat_is_partn_eq(NPP *npp, NPPROW *row)\n{     xassert(npp == npp);\n      if (row->lb == row->ub)\n      {  /* row is equality constraint */\n         if (npp_sat_is_bin_comb(npp, row))\n         {  /* row is a binary combination */\n            if (row->lb == 1.0 - npp_sat_num_neg_coef(npp, row))\n            {  /* row has the form (2) */\n               return 1;\n            }\n            if (row->ub == npp_sat_num_pos_coef(npp, row) - 1.0)\n            {  /* row has the form (3) */\n               return 2;\n            }\n         }\n      }\n      /* row is not a partitioning equality */\n      return 0;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_reverse_row": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "int npp_sat_reverse_row(NPP *npp, NPPROW *row)\n{     NPPAIJ *aij;\n      int temp, ret = 0;\n      double old_lb, old_ub;\n      xassert(npp == npp);\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  aij->val = -aij->val;\n         temp = (int)aij->val;\n         if ((double)temp != aij->val)\n            ret = 1;\n      }\n      old_lb = row->lb, old_ub = row->ub;\n      if (old_ub == +DBL_MAX)\n         row->lb = -DBL_MAX;\n      else\n      {  row->lb = -old_ub;\n         temp = (int)row->lb;\n         if ((double)temp != row->lb)\n            ret = 2;\n      }\n      if (old_lb == -DBL_MAX)\n         row->ub = +DBL_MAX;\n      else\n      {  row->ub = -old_lb;\n         temp = (int)row->ub;\n         if ((double)temp != row->ub)\n            ret = 3;\n      }\n      return ret;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_split_pack": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "NPPROW *npp_sat_split_pack(NPP *npp, NPPROW *row, int nlit)\n{     NPPROW *rrr;\n      NPPCOL *col;\n      NPPAIJ *aij;\n      int k;\n      /* original row should be packing inequality (1) */\n      xassert(npp_sat_is_pack_ineq(npp, row) == 1);\n      /* and nlit should be less than the number of literals (terms)\n         in the original row */\n      xassert(0 < nlit && nlit < npp_row_nnz(npp, row));\n      /* create new row corresponding to inequality (2) */\n      rrr = npp_add_row(npp);\n      rrr->lb = -DBL_MAX, rrr->ub = 1.0;\n      /* move first nlit literals (terms) from the original row to the\n         new row; the original row becomes inequality (3) */\n      for (k = 1; k <= nlit; k++)\n      {  aij = row->ptr;\n         xassert(aij != NULL);\n         /* add literal to the new row */\n         npp_add_aij(npp, rrr, aij->col, aij->val);\n         /* correct rhs */\n         if (aij->val < 0.0)\n            rrr->ub -= 1.0, row->ub += 1.0;\n         /* remove literal from the original row */\n         npp_del_aij(npp, aij);\n      }\n      /* create new binary variable y */\n      col = npp_add_col(npp);\n      col->is_int = 1, col->lb = 0.0, col->ub = 1.0;\n      /* include literal (1 - y) in the new row */\n      npp_add_aij(npp, rrr, col, -1.0);\n      rrr->ub -= 1.0;\n      /* include literal y in the original row */\n      npp_add_aij(npp, row, col, +1.0);\n      return rrr;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "NPPROW",
        "*npp_sat_split_pack(NPP *npp, NPPROW *row, int nlit)",
        "*"
      ]
    },
    "npp_sat_encode_pack": {
      "start_point": [
        493,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "void npp_sat_encode_pack(NPP *npp, NPPROW *row)\n{     NPPROW *rrr;\n      NPPAIJ *aij, *aik;\n      /* original row should be packing inequality (1) */\n      xassert(npp_sat_is_pack_ineq(npp, row) == 1);\n      /* create equivalent system of covering inequalities (3) */\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  /* due to symmetry only one of inequalities t[j] + t[k] <= 1\n            and t[k] <= t[j] <= 1 can be considered */\n         for (aik = aij->r_next; aik != NULL; aik = aik->r_next)\n         {  /* create edge packing inequality (2) */\n            rrr = npp_add_row(npp);\n            rrr->lb = -DBL_MAX, rrr->ub = 1.0;\n            npp_add_aij(npp, rrr, aij->col, aij->val);\n            if (aij->val < 0.0)\n               rrr->ub -= 1.0;\n            npp_add_aij(npp, rrr, aik->col, aik->val);\n            if (aik->val < 0.0)\n               rrr->ub -= 1.0;\n            /* and transform it to covering inequality (3) */\n            npp_sat_reverse_row(npp, rrr);\n            xassert(npp_sat_is_cover_ineq(npp, rrr) == 1);\n         }\n      }\n      /* remove the original row from the problem */\n      npp_del_row(npp, row);\n      return;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "npp_sat_encode_sum2": {
      "start_point": [
        540,
        0
      ],
      "end_point": [
        619,
        1
      ],
      "content": "void npp_sat_encode_sum2(NPP *npp, NPPLSE *set, NPPSED *sed)\n{     NPPROW *row;\n      int x, y, s, c;\n      /* the set should contain exactly two literals */\n      xassert(set != NULL);\n      xassert(set->next != NULL);\n      xassert(set->next->next == NULL);\n      sed->x = set->lit;\n      xassert(sed->x.neg == 0 || sed->x.neg == 1);\n      sed->y = set->next->lit;\n      xassert(sed->y.neg == 0 || sed->y.neg == 1);\n      sed->z.col = NULL, sed->z.neg = 0;\n      /* perform encoding s = (x + y) % 2 */\n      sed->s = npp_add_col(npp);\n      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;\n      for (x = 0; x <= 1; x++)\n      {  for (y = 0; y <= 1; y++)\n         {  for (s = 0; s <= 1; s++)\n            {  if ((x + y) % 2 != s)\n               {  /* generate CNF clause to disable infeasible\n                     combination */\n                  row = npp_add_row(npp);\n                  row->lb = 1.0, row->ub = +DBL_MAX;\n                  if (x == sed->x.neg)\n                     npp_add_aij(npp, row, sed->x.col, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->x.col, -1.0);\n                     row->lb -= 1.0;\n                  }\n                  if (y == sed->y.neg)\n                     npp_add_aij(npp, row, sed->y.col, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->y.col, -1.0);\n                     row->lb -= 1.0;\n                  }\n                  if (s == 0)\n                     npp_add_aij(npp, row, sed->s, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->s, -1.0);\n                     row->lb -= 1.0;\n                  }\n               }\n            }\n         }\n      }\n      /* perform encoding c = (x + y) / 2 */\n      sed->c = npp_add_col(npp);\n      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;\n      for (x = 0; x <= 1; x++)\n      {  for (y = 0; y <= 1; y++)\n         {  for (c = 0; c <= 1; c++)\n            {  if ((x + y) / 2 != c)\n               {  /* generate CNF clause to disable infeasible\n                     combination */\n                  row = npp_add_row(npp);\n                  row->lb = 1.0, row->ub = +DBL_MAX;\n                  if (x == sed->x.neg)\n                     npp_add_aij(npp, row, sed->x.col, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->x.col, -1.0);\n                     row->lb -= 1.0;\n                  }\n                  if (y == sed->y.neg)\n                     npp_add_aij(npp, row, sed->y.col, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->y.col, -1.0);\n                     row->lb -= 1.0;\n                  }\n                  if (c == 0)\n                     npp_add_aij(npp, row, sed->c, +1.0);\n                  else\n                  {  npp_add_aij(npp, row, sed->c, -1.0);\n                     row->lb -= 1.0;\n                  }\n               }\n            }\n         }\n      }\n      return;\n}",
      "lines": 80,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "npp_sat_encode_sum3": {
      "start_point": [
        639,
        0
      ],
      "end_point": [
        735,
        1
      ],
      "content": "void npp_sat_encode_sum3(NPP *npp, NPPLSE *set, NPPSED *sed)\n{     NPPROW *row;\n      int x, y, z, s, c;\n      /* the set should contain at least three literals */\n      xassert(set != NULL);\n      xassert(set->next != NULL);\n      xassert(set->next->next != NULL);\n      sed->x = set->lit;\n      xassert(sed->x.neg == 0 || sed->x.neg == 1);\n      sed->y = set->next->lit;\n      xassert(sed->y.neg == 0 || sed->y.neg == 1);\n      sed->z = set->next->next->lit;\n      xassert(sed->z.neg == 0 || sed->z.neg == 1);\n      /* perform encoding s = (x + y + z) % 2 */\n      sed->s = npp_add_col(npp);\n      sed->s->is_int = 1, sed->s->lb = 0.0, sed->s->ub = 1.0;\n      for (x = 0; x <= 1; x++)\n      {  for (y = 0; y <= 1; y++)\n         {  for (z = 0; z <= 1; z++)\n            {  for (s = 0; s <= 1; s++)\n               {  if ((x + y + z) % 2 != s)\n                  {  /* generate CNF clause to disable infeasible\n                        combination */\n                     row = npp_add_row(npp);\n                     row->lb = 1.0, row->ub = +DBL_MAX;\n                     if (x == sed->x.neg)\n                        npp_add_aij(npp, row, sed->x.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->x.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (y == sed->y.neg)\n                        npp_add_aij(npp, row, sed->y.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->y.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (z == sed->z.neg)\n                        npp_add_aij(npp, row, sed->z.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->z.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (s == 0)\n                        npp_add_aij(npp, row, sed->s, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->s, -1.0);\n                        row->lb -= 1.0;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      /* perform encoding c = (x + y + z) / 2 */\n      sed->c = npp_add_col(npp);\n      sed->c->is_int = 1, sed->c->lb = 0.0, sed->c->ub = 1.0;\n      for (x = 0; x <= 1; x++)\n      {  for (y = 0; y <= 1; y++)\n         {  for (z = 0; z <= 1; z++)\n            {  for (c = 0; c <= 1; c++)\n               {  if ((x + y + z) / 2 != c)\n                  {  /* generate CNF clause to disable infeasible\n                        combination */\n                     row = npp_add_row(npp);\n                     row->lb = 1.0, row->ub = +DBL_MAX;\n                     if (x == sed->x.neg)\n                        npp_add_aij(npp, row, sed->x.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->x.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (y == sed->y.neg)\n                        npp_add_aij(npp, row, sed->y.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->y.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (z == sed->z.neg)\n                        npp_add_aij(npp, row, sed->z.col, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->z.col, -1.0);\n                        row->lb -= 1.0;\n                     }\n                     if (c == 0)\n                        npp_add_aij(npp, row, sed->c, +1.0);\n                     else\n                     {  npp_add_aij(npp, row, sed->c, -1.0);\n                        row->lb -= 1.0;\n                     }\n                  }\n               }\n            }\n         }\n      }\n      return;\n}",
      "lines": 97,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "remove_lse": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static NPPLSE *remove_lse(NPP *npp, NPPLSE *set, NPPCOL *col)\n{     /* remove specified literal from specified literal set */\n      NPPLSE *lse, *prev = NULL;\n      for (lse = set; lse != NULL; prev = lse, lse = lse->next)\n         if (lse->lit.col == col) break;\n      xassert(lse != NULL);\n      if (prev == NULL)\n         set = lse->next;\n      else\n         prev->next = lse->next;\n      dmp_free_atom(npp->pool, lse, sizeof(NPPLSE));\n      return set;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "NPPLSE",
        "*remove_lse(NPP *npp, NPPLSE *set, NPPCOL *col)",
        "*"
      ]
    },
    "npp_sat_encode_sum_ax": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        916,
        1
      ],
      "content": "int npp_sat_encode_sum_ax(NPP *npp, NPPROW *row, NPPLIT y[])\n{     NPPAIJ *aij;\n      NPPLSE *set[1+NBIT_MAX], *lse;\n      NPPSED sed;\n      int k, n, temp;\n      double sum;\n      /* compute the sum (sum |a[j]|) */\n      sum = 0.0;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n         sum += fabs(aij->val);\n      /* determine n, the number of bits in the sum */\n      temp = (int)sum;\n      if ((double)temp != sum)\n         return -1; /* integer arithmetic error */\n      for (n = 0; temp > 0; n++, temp >>= 1);\n      xassert(0 <= n && n <= NBIT_MAX);\n      /* build initial sets J[k], 1 <= k <= n; see (5) */\n      /* set[k] is a pointer to the list of literals in J[k] */\n      for (k = 1; k <= n; k++)\n         set[k] = NULL;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  temp = (int)fabs(aij->val);\n         xassert((int)temp == fabs(aij->val));\n         for (k = 1; temp > 0; k++, temp >>= 1)\n         {  if (temp & 1)\n            {  xassert(k <= n);\n               lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));\n               lse->lit.col = aij->col;\n               lse->lit.neg = (aij->val > 0.0 ? 0 : 1);\n               lse->next = set[k];\n               set[k] = lse;\n            }\n         }\n      }\n      /* main transformation loop */\n      for (k = 1; k <= n; k++)\n      {  /* reduce J[k] and set y[k] */\n         for (;;)\n         {  if (set[k] == NULL)\n            {  /* J[k] is empty */\n               /* set y[k] to constant false */\n               y[k].col = NULL, y[k].neg = 0;\n               break;\n            }\n            if (set[k]->next == NULL)\n            {  /* J[k] contains one literal */\n               /* set y[k] to that literal */\n               y[k] = set[k]->lit;\n               dmp_free_atom(npp->pool, set[k], sizeof(NPPLSE));\n               break;\n            }\n            if (set[k]->next->next == NULL)\n            {  /* J[k] contains two literals */\n               /* apply transformation (7) */\n               npp_sat_encode_sum2(npp, set[k], &sed);\n            }\n            else\n            {  /* J[k] contains at least three literals */\n               /* apply transformation (8) */\n               npp_sat_encode_sum3(npp, set[k], &sed);\n               /* remove third literal from set[k] */\n               set[k] = remove_lse(npp, set[k], sed.z.col);\n            }\n            /* remove second literal from set[k] */\n            set[k] = remove_lse(npp, set[k], sed.y.col);\n            /* remove first literal from set[k] */\n            set[k] = remove_lse(npp, set[k], sed.x.col);\n            /* include new literal s to set[k] */\n            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));\n            lse->lit.col = sed.s, lse->lit.neg = 0;\n            lse->next = set[k];\n            set[k] = lse;\n            /* include new literal c to set[k+1] */\n            xassert(k < n); /* FIXME: can \"overflow\" happen? */\n            lse = dmp_get_atom(npp->pool, sizeof(NPPLSE));\n            lse->lit.col = sed.c, lse->lit.neg = 0;\n            lse->next = set[k+1];\n            set[k+1] = lse;\n         }\n      }\n      return n;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_normalize_clause": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        956,
        1
      ],
      "content": "int npp_sat_normalize_clause(NPP *npp, int size, NPPLIT lit[])\n{     int j, k, new_size;\n      xassert(npp == npp);\n      xassert(size >= 0);\n      new_size = 0;\n      for (k = 1; k <= size; k++)\n      {  for (j = 1; j <= new_size; j++)\n         {  if (lit[k].col == lit[j].col)\n            {  /* lit[k] refers to the same variable as lit[j], which\n                  is already included in the resulting clause */\n               if (lit[k].neg == lit[j].neg)\n               {  /* ignore lit[k] due to the idempotent law */\n                  goto skip;\n               }\n               else\n               {  /* lit[k] is NOT lit[j]; the clause is equivalent to\n                     the value true */\n                  return -1;\n               }\n            }\n         }\n         /* include lit[k] in the resulting clause */\n         lit[++new_size] = lit[k];\nskip:    ;\n      }\n      return new_size;\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_encode_clause": {
      "start_point": [
        978,
        0
      ],
      "end_point": [
        996,
        1
      ],
      "content": "NPPROW *npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[])\n{     NPPROW *row;\n      int k;\n      xassert(size >= 1);\n      row = npp_add_row(npp);\n      row->lb = 1.0, row->ub = +DBL_MAX;\n      for (k = 1; k <= size; k++)\n      {  xassert(lit[k].col != NULL);\n         if (lit[k].neg == 0)\n            npp_add_aij(npp, row, lit[k].col, +1.0);\n         else if (lit[k].neg == 1)\n         {  npp_add_aij(npp, row, lit[k].col, -1.0);\n            row->lb -= 1.0;\n         }\n         else\n            xassert(lit != lit);\n      }\n      return row;\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "NPPROW",
        "*npp_sat_encode_clause(NPP *npp, int size, NPPLIT lit[])",
        "*"
      ]
    },
    "npp_sat_encode_geq": {
      "start_point": [
        1057,
        0
      ],
      "end_point": [
        1123,
        1
      ],
      "content": "int npp_sat_encode_geq(NPP *npp, int n, NPPLIT y[], int rhs)\n{     NPPLIT lit[1+NBIT_MAX];\n      int j, k, size, temp, b[1+NBIT_MAX];\n      xassert(0 <= n && n <= NBIT_MAX);\n      /* if the constraint (1) is redundant, do nothing */\n      if (rhs < 0)\n         return 0;\n      /* determine binary digits of b according to (2) */\n      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)\n         b[k] = temp & 1;\n      if (temp != 0)\n      {  /* b >= 2**n; the constraint (1) is infeasible */\n         return 1;\n      }\n      /* main transformation loop */\n      for (k = 1; k <= n; k++)\n      {  /* build the clause (5) for current k */\n         size = 0; /* clause size = number of literals */\n         /* add literal y[k] >= b[k] */\n         if (b[k] == 0)\n         {  /* b[k] = 0 -> the literal is true */\n            goto skip;\n         }\n         else if (y[k].col == NULL)\n         {  /* y[k] = 0, b[k] = 1 -> the literal is false */\n            xassert(y[k].neg == 0);\n         }\n         else\n         {  /* add literal y[k] = 1 */\n            lit[++size] = y[k];\n         }\n         for (j = k+1; j <= n; j++)\n         {  /* add literal y[j] != b[j] */\n            if (y[j].col == NULL)\n            {  xassert(y[j].neg == 0);\n               if (b[j] == 0)\n               {  /* y[j] = 0, b[j] = 0 -> the literal is false */\n                  continue;\n               }\n               else\n               {  /* y[j] = 0, b[j] = 1 -> the literal is true */\n                  goto skip;\n               }\n            }\n            else\n            {  lit[++size] = y[j];\n               if (b[j] != 0)\n                  lit[size].neg = 1 - lit[size].neg;\n            }\n         }\n         /* normalize the clause */\n         size = npp_sat_normalize_clause(npp, size, lit);\n         if (size < 0)\n         {  /* the clause is equivalent to the value true */\n            goto skip;\n         }\n         if (size == 0)\n         {  /* the clause is equivalent to the value false; this means\n               that the constraint (1) is infeasible */\n            return 2;\n         }\n         /* translate the clause to corresponding cover inequality */\n         npp_sat_encode_clause(npp, size, lit);\nskip:    ;\n      }\n      return 0;\n}",
      "lines": 67,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_encode_leq": {
      "start_point": [
        1184,
        0
      ],
      "end_point": [
        1252,
        1
      ],
      "content": "int npp_sat_encode_leq(NPP *npp, int n, NPPLIT y[], int rhs)\n{     NPPLIT lit[1+NBIT_MAX];\n      int j, k, size, temp, b[1+NBIT_MAX];\n      xassert(0 <= n && n <= NBIT_MAX);\n      /* check if the constraint (1) is infeasible */\n      if (rhs < 0)\n         return 1;\n      /* determine binary digits of b according to (2) */\n      for (k = 1, temp = rhs; k <= n; k++, temp >>= 1)\n         b[k] = temp & 1;\n      if (temp != 0)\n      {  /* b >= 2**n; the constraint (1) is redundant */\n         return 0;\n      }\n      /* main transformation loop */\n      for (k = 1; k <= n; k++)\n      {  /* build the clause (5) for current k */\n         size = 0; /* clause size = number of literals */\n         /* add literal y[k] <= b[k] */\n         if (b[k] == 1)\n         {  /* b[k] = 1 -> the literal is true */\n            goto skip;\n         }\n         else if (y[k].col == NULL)\n         {  /* y[k] = 0, b[k] = 0 -> the literal is true */\n            xassert(y[k].neg == 0);\n            goto skip;\n         }\n         else\n         {  /* add literal y[k] = 0 */\n            lit[++size] = y[k];\n            lit[size].neg = 1 - lit[size].neg;\n         }\n         for (j = k+1; j <= n; j++)\n         {  /* add literal y[j] != b[j] */\n            if (y[j].col == NULL)\n            {  xassert(y[j].neg == 0);\n               if (b[j] == 0)\n               {  /* y[j] = 0, b[j] = 0 -> the literal is false */\n                  continue;\n               }\n               else\n               {  /* y[j] = 0, b[j] = 1 -> the literal is true */\n                  goto skip;\n               }\n            }\n            else\n            {  lit[++size] = y[j];\n               if (b[j] != 0)\n                  lit[size].neg = 1 - lit[size].neg;\n            }\n         }\n         /* normalize the clause */\n         size = npp_sat_normalize_clause(npp, size, lit);\n         if (size < 0)\n         {  /* the clause is equivalent to the value true */\n            goto skip;\n         }\n         if (size == 0)\n         {  /* the clause is equivalent to the value false; this means\n               that the constraint (1) is infeasible */\n            return 2;\n         }\n         /* translate the clause to corresponding cover inequality */\n         npp_sat_encode_clause(npp, size, lit);\nskip:    ;\n      }\n      return 0;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_encode_row": {
      "start_point": [
        1322,
        0
      ],
      "end_point": [
        1363,
        1
      ],
      "content": "int npp_sat_encode_row(NPP *npp, NPPROW *row)\n{     NPPAIJ *aij;\n      NPPLIT y[1+NBIT_MAX];\n      int n, rhs;\n      double lb, ub;\n      /* the row should not be free */\n      xassert(!(row->lb == -DBL_MAX && row->ub == +DBL_MAX));\n      /* compute new bounds L' and U' (3) */\n      lb = row->lb;\n      ub = row->ub;\n      for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n      {  if (aij->val < 0.0)\n         {  if (lb != -DBL_MAX)\n               lb -= aij->val;\n            if (ub != -DBL_MAX)\n               ub -= aij->val;\n         }\n      }\n      /* encode the equality (4) */\n      n = npp_sat_encode_sum_ax(npp, row, y);\n      if (n < 0)\n         return 2; /* integer arithmetic error */\n      /* encode the condition (5) */\n      if (lb != -DBL_MAX)\n      {  rhs = (int)lb;\n         if ((double)rhs != lb)\n            return 2; /* integer arithmetic error */\n         if (npp_sat_encode_geq(npp, n, y, rhs) != 0)\n            return 1; /* original constraint is infeasible */\n      }\n      /* encode the condition (6) */\n      if (ub != +DBL_MAX)\n      {  rhs = (int)ub;\n         if ((double)rhs != ub)\n            return 2; /* integer arithmetic error */\n         if (npp_sat_encode_leq(npp, n, y, rhs) != 0)\n            return 1; /* original constraint is infeasible */\n      }\n      /* remove the specified row from the problem */\n      npp_del_row(npp, row);\n      return 0;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "npp_sat_encode_prob": {
      "start_point": [
        1381,
        0
      ],
      "end_point": [
        1497,
        1
      ],
      "content": "int npp_sat_encode_prob(NPP *npp)\n{     NPPROW *row, *next_row, *prev_row;\n      NPPCOL *col, *next_col;\n      int cover = 0, pack = 0, partn = 0, ret;\n      /* process and remove free rows */\n      for (row = npp->r_head; row != NULL; row = next_row)\n      {  next_row = row->next;\n         if (row->lb == -DBL_MAX && row->ub == +DBL_MAX)\n            npp_sat_free_row(npp, row);\n      }\n      /* process and remove fixed columns */\n      for (col = npp->c_head; col != NULL; col = next_col)\n      {  next_col = col->next;\n         if (col->lb == col->ub)\n            xassert(npp_sat_fixed_col(npp, col) == 0);\n      }\n      /* only binary variables should remain */\n      for (col = npp->c_head; col != NULL; col = col->next)\n         xassert(col->is_int && col->lb == 0.0 && col->ub == 1.0);\n      /* new rows may be added to the end of the row list, so we walk\n         from the end to beginning of the list */\n      for (row = npp->r_tail; row != NULL; row = prev_row)\n      {  prev_row = row->prev;\n         /* process special cases */\n         ret = npp_sat_is_cover_ineq(npp, row);\n         if (ret != 0)\n         {  /* row is covering inequality */\n            cover++;\n            /* since it already encodes a clause, just transform it to\n               canonical form */\n            if (ret == 2)\n            {  xassert(npp_sat_reverse_row(npp, row) == 0);\n               ret = npp_sat_is_cover_ineq(npp, row);\n            }\n            xassert(ret == 1);\n            continue;\n         }\n         ret = npp_sat_is_partn_eq(npp, row);\n         if (ret != 0)\n         {  /* row is partitioning equality */\n            NPPROW *cov;\n            NPPAIJ *aij;\n            partn++;\n            /* transform it to canonical form */\n            if (ret == 2)\n            {  xassert(npp_sat_reverse_row(npp, row) == 0);\n               ret = npp_sat_is_partn_eq(npp, row);\n            }\n            xassert(ret == 1);\n            /* and split it into covering and packing inequalities,\n               both in canonical forms */\n            cov = npp_add_row(npp);\n            cov->lb = row->lb, cov->ub = +DBL_MAX;\n            for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n               npp_add_aij(npp, cov, aij->col, aij->val);\n            xassert(npp_sat_is_cover_ineq(npp, cov) == 1);\n            /* the cover inequality already encodes a clause and do\n               not need any further processing */\n            row->lb = -DBL_MAX;\n            xassert(npp_sat_is_pack_ineq(npp, row) == 1);\n            /* the packing inequality will be processed below */\n            pack--;\n         }\n         ret = npp_sat_is_pack_ineq(npp, row);\n         if (ret != 0)\n         {  /* row is packing inequality */\n            NPPROW *rrr;\n            int nlit, desired_nlit = 4;\n            pack++;\n            /* transform it to canonical form */\n            if (ret == 2)\n            {  xassert(npp_sat_reverse_row(npp, row) == 0);\n               ret = npp_sat_is_pack_ineq(npp, row);\n            }\n            xassert(ret == 1);\n            /* process the packing inequality */\n            for (;;)\n            {  /* determine the number of literals in the remaining\n                  inequality */\n               nlit = npp_row_nnz(npp, row);\n               if (nlit <= desired_nlit)\n                  break;\n               /* split the current inequality into one having not more\n                  than desired_nlit literals and remaining one */\n               rrr = npp_sat_split_pack(npp, row, desired_nlit-1);\n               /* translate the former inequality to CNF and remove it\n                  from the original problem */\n               npp_sat_encode_pack(npp, rrr);\n            }\n            /* translate the remaining inequality to CNF and remove it\n               from the original problem */\n            npp_sat_encode_pack(npp, row);\n            continue;\n         }\n         /* translate row of general type to CNF and remove it from the\n            original problem */\n         ret = npp_sat_encode_row(npp, row);\n         if (ret == 0)\n            ;\n         else if (ret == 1)\n            ret = GLP_ENOPFS;\n         else if (ret == 2)\n            ret = GLP_ERANGE;\n         else\n            xassert(ret != ret);\n         if (ret != 0)\n            goto done;\n      }\n      ret = 0;\n      if (cover != 0)\n         xprintf(\"%d covering inequalities\\n\", cover);\n      if (pack != 0)\n         xprintf(\"%d packing inequalities\\n\", pack);\n      if (partn != 0)\n         xprintf(\"%d partitioning equalities\\n\", partn);\ndone: return ret;\n}",
      "lines": 117,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/proxy/main.c": {
    "main": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int main(int argc, char **argv)\n/**********************************************************************/\n{\n    glp_prob *lp;\n    int ncols, status;\n    double *initsol, zstar, *xstar;\n\n    /* check arguments */\n    if ( (argc == 1) || (argc > 3) ) {\n        printf(\"ERROR: Usage: ts <instance> <(possibly) xml initsols>\\n\"\n              );\n        exit(1);\n    }\n\n    /* creating the problem */\n    lp = glp_create_prob();\n    glp_set_prob_name(lp, \"Proxy\");\n\n    /* reading the problem */\n    glp_term_out(GLP_OFF);\n#if 0 /* by mao */\n    status = glp_read_lp(lp, NULL, argv[1]);\n#else\n    status = glp_read_mps(lp, GLP_MPS_FILE, NULL, argv[1]);\n#endif\n    glp_term_out(GLP_ON);\n    if ( status ) {\n        printf(\"Problem %s does not exist!!!, status %d\\n\",\n               argv[1], status);\n        exit(1);\n    }\n\n    ncols = glp_get_num_cols(lp);\n\n    initsol = (double *) calloc(ncols+1, sizeof(double));\n\n    if (argc == 3) {\n        FILE *fp=fopen(argv[2],\"r\");\n        char  tmp[256]={0x0};\n        int counter = 1;\n        while(fp!=NULL && fgets(tmp, sizeof(tmp),fp)!=NULL)\n        {\n            char *valini = strstr(tmp, \"value\");\n            if (valini!=NULL){\n                int num;\n                double dnum;\n                valini +=7;\n                sscanf(valini, \"%d%*s\",&num);\n                dnum = (double)num;\n                initsol[counter] = dnum;\n                counter++;\n            }\n        }\n        fclose(fp);\n    }\n\n    xstar = (double *) calloc(ncols+1, sizeof(double));\n\n    if (argc == 3) {\n        status = proxy(lp, &zstar, xstar, initsol, 0.0, 0, 1);\n    }\n    else {\n        status = proxy(lp, &zstar, xstar, NULL, 0.0, 0, 1);\n    }\n\n    printf(\"Status = %d; ZSTAR = %f\\n\",status,zstar);\n    /*\n    int i;\n    for (i=1; i< ncols+1; i++) {\n        printf(\"XSTAR[%d] = %f\\n\",i, xstar[i]);\n    }\n     */\n\n    glp_delete_prob(lp);\n\n    return 0;\n}",
      "lines": 77,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/proxy/proxy.c": {
    "proxy": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        620,
        1
      ],
      "content": "int proxy(glp_prob *lp, double *zfinal, double *xfinal,\n          const double initsol[], double rel_impr, int tlim,\n          int verbose)\n\n{   struct csa csa_, *csa = &csa_;\n    glp_iocp parm;\n    glp_smcp parm_lp;\n    size_t tpeak;\n    int refine, tref_lim, err, cutoff_row, niter, status, i, tout;\n    double *xref, *xstar, zstar, tela, cutoff, zz;\n\n    memset(csa, 0, sizeof(struct csa));\n\n\n    /**********                         **********/\n    /********** RETRIEVING PROBLEM INFO **********/\n    /**********                         **********/\n\n    /* getting problem direction (min or max) */\n    csa->dir = glp_get_obj_dir(lp);\n\n    /* getting number of variables */\n    csa->ncols = glp_get_num_cols(lp);\n\n    /* getting kind, bounds and obj coefficient of each variable\n     information is stored in ckind, cub, clb, true_obj */\n    get_info(csa, lp);\n\n    /* checking if the objective function is always integral */\n    check_integrality(csa);\n\n    /* Proximity search cannot be used if there are no binary\n       variables */\n    if (csa->b_vars_exist == FALSE) {\n        if (verbose) {\n            xprintf(\"The problem has not binary variables. Proximity se\"\n                    \"arch cannot be used.\\n\");\n        }\n        tfree(csa->ckind);\n        tfree(csa->clb);\n        tfree(csa->cub);\n        tfree(csa->true_obj);\n        return -1;\n    }\n\n    /* checking if the problem needs refinement, i.e., not all\n       variables are binary. If so, the routine creates a copy of the\n       lp problem named lp_ref and initializes the solution xref to\n       zero. */\n    xref = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(xref, 0, sizeof(double)*(csa->ncols+1));\n#endif\n    refine = check_ref(csa, lp, xref);\n#ifdef PROXY_DEBUG\n    xprintf(\"REFINE = %d\\n\",refine);\n#endif\n\n    /* Initializing the solution */\n    xstar = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(xstar, 0, sizeof(double)*(csa->ncols+1));\n#endif\n\n    /**********                         **********/\n    /********** FINDING FIRST SOLUTION  **********/\n    /**********                         **********/\n\n    if (verbose) {\n        xprintf(\"Applying PROXY heuristic...\\n\");\n    }\n\n    /* get the initial time */\n    csa->GLOtstart = second();\n\n    /* setting the optimization parameters */\n    glp_init_iocp(&parm);\n    glp_init_smcp(&parm_lp);\n#if 0 /* by gioker */\n    /* Preprocessing should be disabled because the mip passed\n     to proxy is already preprocessed */\n    parm.presolve = GLP_ON;\n#endif\n#if 1 /* by mao */\n    /* best projection backtracking seems to be more efficient to find\n       any integer feasible solution */\n    parm.bt_tech = GLP_BT_BPH;\n#endif\n\n    /* Setting the default value of the minimum relative improvement\n       to 1% */\n    if ( rel_impr <= 0.0 ) {\n        rel_impr = 0.01;\n    }\n\n    /* Setting the default value of time limit to 10 minutes */\n    if (tlim <= 0) {\n        tlim = INT_MAX;\n    }\n    if (verbose) {\n        xprintf(\"Proxy's time limit set to %d seconds.\\n\",tlim/1000);\n        xprintf(\"Proxy's relative improvement \"\n                \"set to %2.2lf %c.\\n\",rel_impr*100,37);\n    }\n\n    parm_lp.tm_lim = tlim;\n\n    parm.mip_gap = 9999999.9; /* to stop the optimization at the first\n                                 feasible solution found */\n\n    /* finding the first solution */\n    if (verbose) {\n        xprintf(\"Searching for a feasible solution...\\n\");\n    }\n\n    /* verifying the existence of an input starting solution */\n    if (initsol != NULL) {\n        csa->startsol = initsol;\n        parm.cb_func = callback;\n        parm.cb_info = csa;\n        if (verbose) {\n            xprintf(\"Input solution found.\\n\");\n        }\n    }\n\n    tout = glp_term_out(GLP_OFF);\n    err = glp_simplex(lp,&parm_lp);\n    glp_term_out(tout);\n\n    status = glp_get_status(lp);\n\n    if (status != GLP_OPT) {\n        if (verbose) {\n            xprintf(\"Proxy heuristic terminated.\\n\");\n        }\n#ifdef  PROXY_DEBUG\n        /* For debug only */\n        xprintf(\"GLP_SIMPLEX status = %d\\n\",status);\n        xprintf(\"GLP_SIMPLEX error code = %d\\n\",err);\n#endif\n        tfree(xref);\n        tfree(xstar);\n        deallocate(csa, refine);\n        return -1;\n    }\n\n    tela = elapsed_time(csa);\n    if (tlim-tela*1000 <= 0) {\n        if (verbose) {\n            xprintf(\"Time limit exceeded. Proxy could not \"\n                    \"find optimal solution to LP relaxation.\\n\");\n            xprintf(\"Proxy heuristic aborted.\\n\");\n        }\n        tfree(xref);\n        tfree(xstar);\n        deallocate(csa, refine);\n        return -1;\n    }\n\n    parm.tm_lim = tlim - tela*1000;\n    tref_lim = (tlim - tela *1000) / 20;\n\n    tout = glp_term_out(GLP_OFF);\n    err = glp_intopt(lp, &parm);\n    glp_term_out(tout);\n\n    status = glp_mip_status(lp);\n\n    /***** If no solution was found *****/\n\n    if (status == GLP_NOFEAS || status == GLP_UNDEF) {\n        if (err == GLP_ETMLIM) {\n            if (verbose) {\n                xprintf(\"Time limit exceeded. Proxy could not \"\n                        \"find an initial integer feasible solution.\\n\");\n                xprintf(\"Proxy heuristic aborted.\\n\");\n            }\n        }\n        else {\n            if (verbose) {\n                xprintf(\"Proxy could not \"\n                        \"find an initial integer feasible solution.\\n\");\n                xprintf(\"Proxy heuristic aborted.\\n\");\n            }\n        }\n        tfree(xref);\n        tfree(xstar);\n        deallocate(csa, refine);\n        return -1;\n    }\n\n    /* getting the first solution and its value */\n    get_sol(csa, lp,xstar);\n    zstar = glp_mip_obj_val(lp);\n\n    if (verbose) {\n        xprintf(\">>>>> first solution = %e;\\n\", zstar);\n    }\n\n    /* If a feasible solution was found but the time limit is\n       exceeded */\n    if (err == GLP_ETMLIM) {\n        if (verbose) {\n          xprintf(\"Time limit exceeded. Proxy heuristic terminated.\\n\");\n        }\n        goto done;\n    }\n\n    tela = elapsed_time(csa);\n    tpeak = 0;\n    glp_mem_usage(NULL, NULL, NULL, &tpeak);\n    if (verbose) {\n        xprintf(\"Time used: %3.1lf secs.  Memory used: %2.1lf Mb\\n\",\n                tela,(double)tpeak/1048576);\n        xprintf(\"Starting proximity search...\\n\");\n    }\n\n    /**********                                 **********/\n    /********** PREPARING THE PROBLEM FOR PROXY **********/\n    /**********                                 **********/\n\n    /* adding a dummy cutoff constraint */\n    cutoff_row = add_cutoff(csa, lp);\n\n    /* proximity search needs minimization direction\n       even if the problem is a maximization one */\n    if (csa->dir == GLP_MAX) {\n        glp_set_obj_dir(lp, GLP_MIN);\n    }\n\n    /**********                           **********/\n    /********** STARTING PROXIMITY SEARCH **********/\n    /**********                           **********/\n\n\n    niter = 0;\n\n    while (TRUE) {\n        niter++;\n\n        /********** CHANGING THE OBJ FUNCTION **********/\n\n        redefine_obj(lp,xstar, csa->ncols, csa->ckind, csa->clb,\n                     csa->cub);\n\n        /********** UPDATING THE CUTOFF CONSTRAINT **********/\n\n        cutoff = update_cutoff(csa, lp,zstar, cutoff_row, rel_impr);\n\n#ifdef PROXY_DEBUG\n        xprintf(\"TRUE_OBJ[0] = %f\\n\",csa->true_obj[0]);\n        xprintf(\"ZSTAR  = %f\\n\",zstar);\n        xprintf(\"CUTOFF = %f\\n\",cutoff);\n#endif\n\n        /********** SEARCHING FOR A BETTER SOLUTION **********/\n\n        tela = elapsed_time(csa);\n        if (tlim-tela*1000 <= 0) {\n            if (verbose) {\n                xprintf(\"Time limit exceeded. Proxy heuristic \"\n                        \"terminated.\\n\");\n            }\n            goto done;\n        }\n#ifdef PROXY_DEBUG\n        xprintf(\"TELA = %3.1lf\\n\",tela*1000);\n        xprintf(\"TLIM = %3.1lf\\n\",tlim - tela*1000);\n#endif\n        parm_lp.tm_lim = tlim -tela*1000;\n\n        tout = glp_term_out(GLP_OFF);\n        err = glp_simplex(lp,&parm_lp);\n        glp_term_out(tout);\n\n        status = glp_get_status(lp);\n\n        if (status != GLP_OPT) {\n            if (status == GLP_NOFEAS) {\n                if (verbose) {\n                    xprintf(\"Bound exceeded = %f. \",cutoff);\n                }\n            }\n            if (verbose) {\n                xprintf(\"Proxy heuristic terminated.\\n\");\n            }\n#ifdef PROXY_DEBUG\n            xprintf(\"GLP_SIMPLEX status = %d\\n\",status);\n            xprintf(\"GLP_SIMPLEX error code = %d\\n\",err);\n#endif\n            goto done;\n        }\n\n        tela = elapsed_time(csa);\n        if (tlim-tela*1000 <= 0) {\n            if (verbose) {\n                xprintf(\"Time limit exceeded. Proxy heuristic \"\n                        \"terminated.\\n\");\n            }\n            goto done;\n        }\n        parm.tm_lim = tlim - tela*1000;\n        parm.cb_func = NULL;\n#if 0 /* by gioker */\n        /* Preprocessing should be disabled because the mip passed\n         to proxy is already preprocessed */\n        parm.presolve = GLP_ON;\n#endif\n        tout = glp_term_out(GLP_OFF);\n        err = glp_intopt(lp, &parm);\n        glp_term_out(tout);\n\n        /********** MANAGEMENT OF THE SOLUTION **********/\n\n        status = glp_mip_status(lp);\n\n        /***** No feasible solutions *****/\n\n        if (status == GLP_NOFEAS) {\n            if (verbose) {\n                xprintf(\"Bound exceeded = %f. Proxy heuristic \"\n                        \"terminated.\\n\",cutoff);\n            }\n            goto done;\n        }\n\n        /***** Undefined solution *****/\n\n        if (status == GLP_UNDEF) {\n            if (err == GLP_ETMLIM) {\n                if (verbose) {\n                    xprintf(\"Time limit exceeded. Proxy heuristic \"\n                            \"terminated.\\n\");\n                }\n            }\n            else {\n                if (verbose) {\n                    xprintf(\"Proxy terminated unexpectedly.\\n\");\n#ifdef PROXY_DEBUG\n                    xprintf(\"GLP_INTOPT error code = %d\\n\",err);\n#endif\n                }\n            }\n            goto done;\n        }\n\n        /***** Feasible solution *****/\n\n        if ((status == GLP_FEAS) || (status == GLP_OPT)) {\n\n            /* getting the solution and computing its value */\n            get_sol(csa, lp,xstar);\n            zz = objval(csa->ncols, xstar, csa->true_obj);\n\n            /* Comparing the incumbent solution with the current best\n               one */\n#ifdef PROXY_DEBUG\n            xprintf(\"ZZ = %f\\n\",zz);\n            xprintf(\"ZSTAR = %f\\n\",zstar);\n            xprintf(\"REFINE = %d\\n\",refine);\n#endif\n            if (((zz<zstar) && (csa->dir == GLP_MIN)) ||\n                ((zz>zstar) && (csa->dir == GLP_MAX))) {\n\n                /* refining (possibly) the solution */\n                if (refine) {\n\n                    /* copying the incumbent solution in the refinement\n                       one */\n                    array_copy(1, csa->ncols +1, xstar, xref);\n                    err = do_refine(csa, csa->lp_ref, csa->ncols,\n                          csa->ckind, xref, &tlim, tref_lim, verbose);\n                    if (!err) {\n                        double zref = objval(csa->ncols, xref,\n                                             csa->true_obj);\n                        if (((zref<zz) && (csa->dir == GLP_MIN)) ||\n                            ((zref>zz) && (csa->dir == GLP_MAX))) {\n                            zz = zref;\n                            /* copying the refinement solution in the\n                               incumbent one */\n                            array_copy(1, csa->ncols +1, xref, xstar);\n                        }\n                    }\n                }\n                zstar = zz;\n                tela = elapsed_time(csa);\n                if (verbose) {\n                    xprintf(\">>>>> it: %3d:   mip = %e;   elapsed time \"\n                            \"%3.1lf sec.s\\n\", niter,zstar,tela);\n                }\n            }\n        }\n    }\n\ndone:\n    tela = elapsed_time(csa);\n    glp_mem_usage(NULL, NULL, NULL, &tpeak);\n    if (verbose) {\n        xprintf(\"Time used: %3.1lf.  Memory used: %2.1lf Mb\\n\",\n                tela,(double)tpeak/1048576);\n    }\n\n\n    /* Exporting solution and obj val */\n    *zfinal = zstar;\n\n    for (i=1; i < (csa->ncols + 1); i++) {\n        xfinal[i]=xstar[i];\n    }\n\n    /* Freeing allocated memory */\n    tfree(xref);\n    tfree(xstar);\n    deallocate(csa, refine);\n\n    return 0;\n}",
      "lines": 417,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "callback": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        632,
        1
      ],
      "content": "static void callback(glp_tree *tree, void *info){\n/**********************************************************************/\n    struct csa *csa = info;\n    switch(glp_ios_reason(tree)) {\n        case GLP_IHEUR:\n            glp_ios_heur_sol(tree, csa->startsol);\n            break;\n        default: break;\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_info": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "static void get_info(struct csa *csa, glp_prob *lp)\n/**********************************************************************/\n{\n    int i;\n\n    /*  Storing helpful info of the problem  */\n\n    csa->ckind = talloc(csa->ncols+1, int);\n#if 0 /* by mao */\n    memset(csa->ckind, 0, sizeof(int)*(csa->ncols+1));\n#endif\n    csa->clb = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(csa->clb, 0, sizeof(double)*(csa->ncols+1));\n#endif\n    csa->cub = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(csa->cub, 0, sizeof(double)*(csa->ncols+1));\n#endif\n    csa->true_obj = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(csa->true_obj, 0, sizeof(double)*(csa->ncols+1));\n#endif\n        for( i = 1 ; i < (csa->ncols + 1); i++ ) {\n            csa->ckind[i] = glp_get_col_kind(lp, i);\n            csa->clb[i] = glp_get_col_lb(lp, i);\n            csa->cub[i] = glp_get_col_ub(lp, i);\n            csa->true_obj[i] = glp_get_obj_coef(lp, i);\n        }\n    csa->true_obj[0] = glp_get_obj_coef(lp, 0);\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_integer": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "static int is_integer(struct csa *csa)\n/**********************************************************************/\n{\n    int i;\n    csa->integer_obj = TRUE;\n    for ( i = 1; i < (csa->ncols + 1); i++ ) {\n        if (fabs(csa->true_obj[i]) > INT_MAX ) {\n            csa->integer_obj = FALSE;\n        }\n        if (fabs(csa->true_obj[i]) <= INT_MAX) {\n            double tmp, rem;\n            if (fabs(csa->true_obj[i]) - floor(fabs(csa->true_obj[i]))\n                < 0.5) {\n                tmp = floor(fabs(csa->true_obj[i]));\n            }\n            else {\n                tmp = ceil(fabs(csa->true_obj[i]));\n            }\n            rem = fabs(csa->true_obj[i]) - tmp;\n            rem = fabs(rem);\n            if (rem > EPS) {\n                csa->integer_obj = FALSE;\n            }\n\n        }\n    }\n    return csa->integer_obj;\n}",
      "lines": 28,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_integrality": {
      "start_point": [
        698,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "static void check_integrality(struct csa *csa)\n/**********************************************************************/\n{\n    /*\n     Checking if the problem has binary, integer or continuos variables.\n     integer_obj is TRUE if the problem has no continuous variables\n     and all the obj coefficients are integer (and < INT_MAX).\n     */\n\n    int i;\n    csa->integer_obj = is_integer(csa);\n    csa->b_vars_exist = FALSE;\n    csa->i_vars_exist = FALSE;\n    for ( i = 1; i < (csa->ncols + 1); i++ ) {\n        if ( csa->ckind[i] == GLP_IV ){\n            csa->i_vars_exist = TRUE;\n            continue;\n        }\n        if ( csa->ckind[i] == GLP_BV ){\n            csa->b_vars_exist =TRUE;\n            continue;\n        }\n        csa->integer_obj = FALSE;\n    }\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_ref": {
      "start_point": [
        725,
        0
      ],
      "end_point": [
        748,
        1
      ],
      "content": "static int check_ref(struct csa *csa, glp_prob *lp, double *xref)\n/**********************************************************************/\n{\n    /*\n     checking if the problem has continuos or integer variables. If so,\n     refinement is prepared.\n     */\n    int refine = FALSE;\n    int i;\n    for ( i = 1; i < (csa->ncols + 1); i++ ) {\n        if ( csa->ckind[i] != GLP_BV) {\n            refine = TRUE;\n            break;\n        }\n    }\n\n    /* possibly creating a mip clone for refinement only */\n    if ( refine ) {\n        csa->lp_ref = glp_create_prob();\n        glp_copy_prob(csa->lp_ref, lp, GLP_ON);\n    }\n\n    return refine;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "second": {
      "start_point": [
        751,
        0
      ],
      "end_point": [
        759,
        1
      ],
      "content": "static double second(void)\n/**********************************************************************/\n{\n#if 0 /* by mao */\n    return ((double)clock()/(double)CLOCKS_PER_SEC);\n#else\n    return xtime() / 1000.0;\n#endif\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "add_cutoff": {
      "start_point": [
        762,
        0
      ],
      "end_point": [
        809,
        1
      ],
      "content": "static int add_cutoff(struct csa *csa, glp_prob *lp)\n/**********************************************************************/\n{\n    /*\n     Adding a cutoff constraint to set an upper bound (in case of\n     minimaztion) on the obj value of the next solution, i.e., the next\n     value of the true obj function that we would like to find\n     */\n\n    /* store non-zero coefficients in the objective function */\n    int *obj_index = talloc(csa->ncols+1, int);\n#if 0 /* by mao */\n    memset(obj_index, 0, sizeof(int)*(csa->ncols+1));\n#endif\n    double *obj_value = talloc(csa->ncols+1, double);\n#if 0 /* by mao */\n    memset(obj_value, 0, sizeof(double)*(csa->ncols+1));\n#endif\n    int obj_nzcnt = 0;\n    int i, irow;\n    const char *rowname;\n    for ( i = 1; i < (csa->ncols + 1); i++ ) {\n        if ( fabs(csa->true_obj[i]) > EPS ) {\n            obj_nzcnt++;\n            obj_index[obj_nzcnt] = i;\n            obj_value[obj_nzcnt] = csa->true_obj[i];\n        }\n    }\n\n    irow = glp_add_rows(lp, 1);\n    rowname = \"Cutoff\";\n    glp_set_row_name(lp, irow, rowname);\n    if (csa->dir == GLP_MIN) {\n        /* minimization problem */\n        glp_set_row_bnds(lp, irow, GLP_UP, MAXVAL, MAXVAL);\n    }\n    else {\n        /* maximization problem */\n        glp_set_row_bnds(lp, irow, GLP_LO, MINVAL, MINVAL);\n    }\n\n    glp_set_mat_row(lp, irow, obj_nzcnt, obj_index, obj_value);\n\n    tfree(obj_index);\n    tfree(obj_value);\n\n    return irow;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_sol": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        821,
        1
      ],
      "content": "static void get_sol(struct csa *csa, glp_prob *lp, double *xstar)\n/**********************************************************************/\n{\n    /* Retrieving and storing the coefficients of the solution */\n\n    int i;\n    for (i = 1; i < (csa->ncols +1); i++) {\n        xstar[i] = glp_mip_col_val(lp, i);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "elapsed_time": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "static double elapsed_time(struct csa *csa)\n/**********************************************************************/\n{\n    double tela = second() - csa->GLOtstart;\n    if ( tela < 0 ) tela += TDAY;\n    return(tela);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "redefine_obj": {
      "start_point": [
        833,
        0
      ],
      "end_point": [
        877,
        1
      ],
      "content": "static void redefine_obj(glp_prob *lp, double *xtilde, int ncols,\n                         int *ckind, double *clb, double *cub)\n/**********************************************************************/\n\n/*\n Redefine the lp objective function obj as the distance-to-integrality\n (Hamming distance) from xtilde (the incumbent feasible solution), wrt\n to binary vars only\n */\n\n{\n    int j;\n    double *delta = talloc(ncols+1, double);\n#if 0 /* by mao */\n    memset(delta, 0, sizeof(double)*(ncols+1));\n#endif\n\n    for ( j = 1; j < (ncols +1); j++ ) {\n        delta[j] = 0.0;\n        /* skip continuous variables */\n        if ( ckind[j] == GLP_CV ) continue;\n\n        /* skip integer variables that have been fixed */\n        if ( cub[j]-clb[j] < 0.5 ) continue;\n\n        /* binary variable */\n        if ( ckind[j] == GLP_BV ) {\n            if ( xtilde[j] > 0.5 ) {\n                delta[j] = -1.0;\n            }\n            else {\n                delta[j] = 1.0;\n            }\n        }\n    }\n\n    /* changing the obj coeff. for all variables, including continuous\n       ones */\n    for ( j = 1; j < (ncols +1); j++ ) {\n        glp_set_obj_coef(lp, j, delta[j]);\n    }\n    glp_set_obj_coef(lp, 0, 0.0);\n\n    tfree(delta);\n}",
      "lines": 45,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "update_cutoff": {
      "start_point": [
        880,
        0
      ],
      "end_point": [
        901,
        1
      ],
      "content": "static double update_cutoff(struct csa *csa, glp_prob *lp,\n                            double zstar, int cutoff_row,\n                            double rel_impr)\n/**********************************************************************/\n{\n    /*\n     Updating the cutoff constraint with the value we would like to\n     find during the next optimization\n     */\n    double cutoff;\n    zstar -= csa->true_obj[0];\n    if (csa->dir == GLP_MIN) {\n        cutoff = zstar - compute_delta(csa, zstar, rel_impr);\n        glp_set_row_bnds(lp, cutoff_row, GLP_UP, cutoff, cutoff);\n    }\n    else {\n        cutoff = zstar + compute_delta(csa, zstar, rel_impr);\n        glp_set_row_bnds(lp, cutoff_row, GLP_LO, cutoff, cutoff);\n    }\n\n    return cutoff;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "compute_delta": {
      "start_point": [
        904,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "static double compute_delta(struct csa *csa, double z, double rel_impr)\n/**********************************************************************/\n{\n    /* Computing the offset for the next best solution */\n\n    double delta = rel_impr * fabs(z);\n    if ( csa->integer_obj ) delta = ceil(delta);\n\n    return(delta);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "objval": {
      "start_point": [
        916,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "static double objval(int ncols, double *x, double *true_obj)\n/**********************************************************************/\n{\n    /* Computing the true cost of x (using the original obj coeff.s) */\n\n    int j;\n    double z = 0.0;\n    for ( j = 1; j < (ncols +1); j++ ) {\n        z += x[j] * true_obj[j];\n    }\n    return z + true_obj[0];\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "array_copy": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        938,
        1
      ],
      "content": "static void array_copy(int begin, int end, double *source,\n                       double *destination)\n/**********************************************************************/\n{\n    int i;\n    for (i = begin; i < end; i++) {\n        destination[i] = source[i];\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "do_refine": {
      "start_point": [
        940,
        0
      ],
      "end_point": [
        1054,
        1
      ],
      "content": "static int do_refine(struct csa *csa, glp_prob *lp_ref, int ncols,\n                     int *ckind, double *xref, int *tlim, int tref_lim,\n                     int verbose)\n/**********************************************************************/\n{\n    /*\n     Refinement is applied when the variables of the problem are not\n     all binary. Binary variables are fixed to their value and\n     remaining ones are optimized. If there are only continuos\n     variables (in addition to those binary) the problem becomes just\n     an LP. Otherwise, it remains a MIP but of smaller size.\n     */\n\n    int j, tout;\n    double refineStart = second();\n    double val, tela, tlimit;\n\n    if ( glp_get_num_cols(lp_ref) != ncols ) {\n        if (verbose) {\n            xprintf(\"Error in Proxy refinement: \");\n            xprintf(\"wrong number of columns (%d vs %d).\\n\",\n                    ncols, glp_get_num_cols(lp_ref));\n        }\n        return 1;\n    }\n\n    val = -1.0;\n\n    /* fixing all binary variables to their current value in xref */\n    for ( j = 1; j < (ncols + 1); j++ ) {\n        if ( ckind[j] == GLP_BV ) {\n            val = 0.0;\n            if ( xref[j] > 0.5 ) val = 1.0;\n            glp_set_col_bnds(lp_ref, j, GLP_FX, val, val);\n        }\n    }\n\n    /* re-optimizing (refining) if some bound has been changed */\n    if ( val > -1.0 ) {\n        glp_iocp parm_ref;\n        glp_smcp parm_ref_lp;\n        int err, status;\n\n        glp_init_iocp(&parm_ref);\n        parm_ref.presolve = GLP_ON;\n        glp_init_smcp(&parm_ref_lp);\n        /*\n         If there are no general integer variable the problem becomes\n         an LP (after fixing the binary variables) and can be solved\n         quickly. Otherwise the problem is still a MIP problem and a\n         timelimit has to be set.\n         */\n        parm_ref.tm_lim = tref_lim;\n        if (parm_ref.tm_lim > *tlim) {\n            parm_ref.tm_lim = *tlim;\n        }\n        parm_ref_lp.tm_lim = parm_ref.tm_lim;\n#ifdef PROXY_DEBUG\n        xprintf(\"***** REFINING *****\\n\");\n#endif\n        tout = glp_term_out(GLP_OFF);\n        if (csa->i_vars_exist == TRUE) {\n            err = glp_intopt(lp_ref, &parm_ref);\n        }\n        else {\n            err = glp_simplex(lp_ref, &parm_ref_lp);\n        }\n        glp_term_out(tout);\n\n        if (csa->i_vars_exist == TRUE) {\n            status = glp_mip_status(lp_ref);\n        }\n        else {\n            status = glp_get_status(lp_ref);\n        }\n\n#if 1 /* 29/II-2016 by mao as reported by Chris */\n      switch (status)\n      {  case GLP_OPT:\n         case GLP_FEAS:\n            break;\n         default:\n            status = GLP_UNDEF;\n            break;\n      }\n#endif\n\n#ifdef PROXY_DEBUG\n        xprintf(\"STATUS REFINING = %d\\n\",status);\n#endif\n        if (status == GLP_UNDEF) {\n            if (err == GLP_ETMLIM) {\n#ifdef PROXY_DEBUG\n                    xprintf(\"Time limit exceeded on Proxy refining.\\n\");\n#endif\n                return 1;\n            }\n        }\n        for( j = 1 ; j < (ncols + 1); j++ ){\n            if (ckind[j] != GLP_BV) {\n                if (csa->i_vars_exist == TRUE) {\n                    xref[j] = glp_mip_col_val(lp_ref, j);\n                }\n                else{\n                    xref[j] = glp_get_col_prim(lp_ref, j);\n                }\n            }\n        }\n    }\n    tela = second() - refineStart;\n#ifdef PROXY_DEBUG\n    xprintf(\"REFINE TELA = %3.1lf\\n\",tela*1000);\n#endif\n    return 0;\n}",
      "lines": 115,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "deallocate": {
      "start_point": [
        1056,
        0
      ],
      "end_point": [
        1070,
        1
      ],
      "content": "static void deallocate(struct csa *csa, int refine)\n/**********************************************************************/\n{\n    /* Deallocating routine */\n\n    if (refine) {\n        glp_delete_prob(csa->lp_ref);\n    }\n\n    tfree(csa->ckind);\n    tfree(csa->clb);\n    tfree(csa->cub);\n    tfree(csa->true_obj);\n\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/proxy/proxy.h": {},
  "glpk/glpk-4.65/src/proxy/proxy1.c": {
    "ios_proxy_heur": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void ios_proxy_heur(glp_tree *T)\n{     glp_prob *prob;\n      int j, status;\n      double *xstar, zstar;\n      /* this heuristic is applied only once on the root level */\n      if (!(T->curr->level == 0 && T->curr->solved == 1))\n         goto done;\n      prob = glp_create_prob();\n      glp_copy_prob(prob, T->mip, 0);\n      xstar = xcalloc(1+prob->n, sizeof(double));\n      for (j = 1; j <= prob->n; j++)\n         xstar[j] = 0.0;\n      if (T->mip->mip_stat != GLP_FEAS)\n         status = proxy(prob, &zstar, xstar, NULL, 0.0,\n            T->parm->ps_tm_lim, 1);\n      else\n      {  double *xinit = xcalloc(1+prob->n, sizeof(double));\n         for (j = 1; j <= prob->n; j++)\n            xinit[j] = T->mip->col[j]->mipx;\n         status = proxy(prob, &zstar, xstar, xinit, 0.0,\n            T->parm->ps_tm_lim, 1);\n         xfree(xinit);\n      }\n      if (status == 0)\n#if 0 /* 17/III-2016 */\n         glp_ios_heur_sol(T, xstar);\n#else\n      {  /* sometimes the proxy heuristic reports a wrong solution, so\n          * make sure that the solution is really integer feasible */\n         int i, feas1, feas2, ae_ind, re_ind;\n         double ae_max, re_max;\n         glp_copy_prob(prob, T->mip, 0);\n         for (j = 1; j <= prob->n; j++)\n            prob->col[j]->mipx = xstar[j];\n         for (i = 1; i <= prob->m; i++)\n         {  GLPROW *row;\n            GLPAIJ *aij;\n            row = prob->row[i];\n            row->mipx = 0.0;\n            for (aij = row->ptr; aij != NULL; aij = aij->r_next)\n               row->mipx += aij->val * aij->col->mipx;\n         }\n         glp_check_kkt(prob, GLP_MIP, GLP_KKT_PE, &ae_max, &ae_ind,\n            &re_max, &re_ind);\n         feas1 = (re_max <= 1e-6);\n         glp_check_kkt(prob, GLP_MIP, GLP_KKT_PB, &ae_max, &ae_ind,\n            &re_max, &re_ind);\n         feas2 = (re_max <= 1e-6);\n         if (feas1 && feas2)\n            glp_ios_heur_sol(T, xstar);\n         else\n            xprintf(\"WARNING: PROXY HEURISTIC REPORTED WRONG SOLUTION; \"\n               \"SOLUTION REJECTED\\n\");\n      }\n#endif\n      xfree(xstar);\n      glp_delete_prob(prob);\ndone: return;\n}",
      "lines": 59,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/simplex.h": {},
  "glpk/glpk-4.65/src/simplex/spxat.c": {
    "spx_alloc_at": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "void spx_alloc_at(SPXLP *lp, SPXAT *at)\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      at->ptr = talloc(1+m+1, int);\n      at->ind = talloc(1+nnz, int);\n      at->val = talloc(1+nnz, double);\n      at->work = talloc(1+n, double);\n      return;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_build_at": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void spx_build_at(SPXLP *lp, SPXAT *at)\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int *AT_ptr = at->ptr;\n      int *AT_ind = at->ind;\n      double *AT_val = at->val;\n      int i, k, ptr, end, pos;\n      /* calculate AT_ptr[i] = number of non-zeros in i-th row */\n      memset(&AT_ptr[1], 0, m * sizeof(int));\n      for (k = 1; k <= n; k++)\n      {  ptr = A_ptr[k];\n         end = A_ptr[k+1];\n         for (; ptr < end; ptr++)\n            AT_ptr[A_ind[ptr]]++;\n      }\n      /* set AT_ptr[i] to position after last element in i-th row */\n      AT_ptr[1]++;\n      for (i = 2; i <= m; i++)\n         AT_ptr[i] += AT_ptr[i-1];\n      xassert(AT_ptr[m] == nnz+1);\n      AT_ptr[m+1] = nnz+1;\n      /* build row-wise representation and re-arrange AT_ptr[i] */\n      for (k = n; k >= 1; k--)\n      {  /* copy elements from k-th column to corresponding rows */\n         ptr = A_ptr[k];\n         end = A_ptr[k+1];\n         for (; ptr < end; ptr++)\n         {  pos = --AT_ptr[A_ind[ptr]];\n            AT_ind[pos] = k;\n            AT_val[pos] = A_val[ptr];\n         }\n      }\n      xassert(AT_ptr[1] == 1);\n      return;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_at_prod": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void spx_at_prod(SPXLP *lp, SPXAT *at, double y[/*1+n*/], double s,\n      const double x[/*1+m*/])\n{     int m = lp->m;\n      int *AT_ptr = at->ptr;\n      int *AT_ind = at->ind;\n      double *AT_val = at->val;\n      int i, ptr, end;\n      double t;\n      for (i = 1; i <= m; i++)\n      {  if (x[i] != 0.0)\n         {  /* y := y + s * (i-th row of A) * x[i] */\n            t = s * x[i];\n            ptr = AT_ptr[i];\n            end = AT_ptr[i+1];\n            for (; ptr < end; ptr++)\n               y[AT_ind[ptr]] += AT_val[ptr] * t;\n         }\n      }\n      return;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_nt_prod1": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void spx_nt_prod1(SPXLP *lp, SPXAT *at, double y[/*1+n-m*/], int ign,\n      double s, const double x[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      double *work = at->work;\n      int j, k;\n      for (k = 1; k <= n; k++)\n         work[k] = 0.0;\n      if (!ign)\n      {  for (j = 1; j <= n-m; j++)\n            work[head[m+j]] = y[j];\n      }\n      spx_at_prod(lp, at, work, s, x);\n      for (j = 1; j <= n-m; j++)\n         y[j] = work[head[m+j]];\n      return;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_trow1": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void spx_eval_trow1(SPXLP *lp, SPXAT *at, const double rho[/*1+m*/],\n      double trow[/*1+n-m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      int i, j, nnz_rho;\n      double cnt1, cnt2;\n      /* determine nnz(rho) */\n      nnz_rho = 0;\n      for (i = 1; i <= m; i++)\n      {  if (rho[i] != 0.0)\n            nnz_rho++;\n      }\n      /* estimate the number of operations for both ways */\n      cnt1 = (double)(n - m) * ((double)nnz / (double)n);\n      cnt2 = (double)nnz_rho * ((double)nnz / (double)m);\n      /* compute i-th row of simplex table */\n      if (cnt1 < cnt2)\n      {  /* as inner products */\n         int *A_ptr = lp->A_ptr;\n         int *A_ind = lp->A_ind;\n         double *A_val = lp->A_val;\n         int *head = lp->head;\n         int k, ptr, end;\n         double tij;\n         for (j = 1; j <= n-m; j++)\n         {  k = head[m+j]; /* x[k] = xN[j] */\n            /* compute t[i,j] = - N'[j] * pi */\n            tij = 0.0;\n            ptr = A_ptr[k];\n            end = A_ptr[k+1];\n            for (; ptr < end; ptr++)\n               tij -= A_val[ptr] * rho[A_ind[ptr]];\n            trow[j] = tij;\n         }\n      }\n      else\n      {  /* as linear combination */\n         spx_nt_prod1(lp, at, trow, 1, -1.0, rho);\n      }\n      return;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spx_free_at": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "void spx_free_at(SPXLP *lp, SPXAT *at)\n{     xassert(lp == lp);\n      tfree(at->ptr);\n      tfree(at->ind);\n      tfree(at->val);\n      tfree(at->work);\n      return;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxat.h": {},
  "glpk/glpk-4.65/src/simplex/spxchuzc.c": {
    "spx_chuzc_sel": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "int spx_chuzc_sel(SPXLP *lp, const double d[/*1+n-m*/], double tol,\n      double tol1, int list[/*1+n-m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k, num;\n      double ck, eps;\n      num = 0;\n      /* walk thru list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == u[k])\n         {  /* xN[j] is fixed variable; skip it */\n            continue;\n         }\n         /* determine absolute tolerance eps[j] */\n         ck = c[k];\n         eps = tol + tol1 * (ck >= 0.0 ? +ck : -ck);\n         /* check if xN[j] is eligible */\n         if (d[j] <= -eps)\n         {  /* xN[j] should be able to increase */\n            if (flag[j])\n            {  /* but its upper bound is active */\n               continue;\n            }\n         }\n         else if (d[j] >= +eps)\n         {  /* xN[j] should be able to decrease */\n            if (!flag[j] && l[k] != -DBL_MAX)\n            {  /* but its lower bound is active */\n               continue;\n            }\n         }\n         else /* -eps < d[j] < +eps */\n         {  /* xN[j] does not affect the objective function within the\n             * specified tolerance */\n            continue;\n         }\n         /* xN[j] is eligible non-basic variable */\n         num++;\n         if (list != NULL)\n            list[num] = j;\n      }\n      return num;\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "spx_chuzc_std": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int spx_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/], int num,\n      const int list[])\n{     int m = lp->m;\n      int n = lp->n;\n      int j, q, t;\n      double abs_dj, abs_dq;\n      xassert(0 < num && num <= n-m);\n      q = 0, abs_dq = -1.0;\n      for (t = 1; t <= num; t++)\n      {  j = list[t];\n         abs_dj = (d[j] >= 0.0 ? +d[j] : -d[j]);\n         if (abs_dq < abs_dj)\n            q = j, abs_dq = abs_dj;\n      }\n      xassert(q != 0);\n      return q;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "spx_alloc_se": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void spx_alloc_se(SPXLP *lp, SPXSE *se)\n{     int m = lp->m;\n      int n = lp->n;\n      se->valid = 0;\n      se->refsp = talloc(1+n, char);\n      se->gamma = talloc(1+n-m, double);\n      se->work = talloc(1+m, double);\n      return;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_reset_refsp": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "void spx_reset_refsp(SPXLP *lp, SPXSE *se)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *gamma = se->gamma;\n      int j, k;\n      se->valid = 1;\n      memset(&refsp[1], 0, n * sizeof(char));\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         refsp[k] = 1;\n         gamma[j] = 1.0;\n      }\n      return;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_gamma_j": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "double spx_eval_gamma_j(SPXLP *lp, SPXSE *se, int j)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *tcol = se->work;\n      int i, k;\n      double gamma_j;\n      xassert(se->valid);\n      xassert(1 <= j && j <= n-m);\n      k = head[m+j]; /* x[k] = xN[j] */\n      gamma_j = (refsp[k] ? 1.0 : 0.0);\n      spx_eval_tcol(lp, j, tcol);\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         if (refsp[k])\n            gamma_j += tcol[i] * tcol[i];\n      }\n      return gamma_j;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "spx_chuzc_pse": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int spx_chuzc_pse(SPXLP *lp, SPXSE *se, const double d[/*1+n-m*/],\n      int num, const int list[])\n{     int m = lp->m;\n      int n = lp->n;\n      double *gamma = se->gamma;\n      int j, q, t;\n      double best, temp;\n      xassert(se->valid);\n      xassert(0 < num && num <= n-m);\n      q = 0, best = -1.0;\n      for (t = 1; t <= num; t++)\n      {  j = list[t];\n         /* FIXME */\n         if (gamma[j] < DBL_EPSILON)\n            temp = 0.0;\n         else\n            temp = (d[j] * d[j]) / gamma[j];\n         if (best < temp)\n            q = j, best = temp;\n      }\n      xassert(q != 0);\n      return q;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "spx_update_gamma": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "double spx_update_gamma(SPXLP *lp, SPXSE *se, int p, int q,\n      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *gamma = se->gamma;\n      double *u = se->work;\n      int i, j, k, ptr, end;\n      double gamma_q, delta_q, e, r, s, t1, t2;\n      xassert(se->valid);\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n-m);\n      /* compute gamma[q] in current basis more accurately; also\n       * compute auxiliary vector u */\n      k = head[m+q]; /* x[k] = xN[q] */\n      gamma_q = delta_q = (refsp[k] ? 1.0 : 0.0);\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         if (refsp[k])\n         {  gamma_q += tcol[i] * tcol[i];\n            u[i] = tcol[i];\n         }\n         else\n            u[i] = 0.0;\n      }\n      bfd_btran(lp->bfd, u);\n      /* compute relative error in gamma[q] */\n      e = fabs(gamma_q - gamma[q]) / (1.0 + gamma_q);\n      /* compute new gamma[q] */\n      gamma[q] = gamma_q / (tcol[p] * tcol[p]);\n      /* compute new gamma[j] for all j != q */\n      for (j = 1; j <= n-m; j++)\n      {  if (j == q)\n            continue;\n         if (-1e-9 < trow[j] && trow[j] < +1e-9)\n         {  /* T[p,j] is close to zero; gamma[j] is not changed */\n            continue;\n         }\n         /* compute r[j] = T[p,j] / T[p,q] */\n         r = trow[j] / tcol[p];\n         /* compute inner product s[j] = N'[j] * u, where N[j] = A[k]\n          * is constraint matrix column corresponding to xN[j] */\n         s = 0.0;\n         k = head[m+j]; /* x[k] = xN[j] */\n         ptr = lp->A_ptr[k];\n         end = lp->A_ptr[k+1];\n         for (; ptr < end; ptr++)\n            s += lp->A_val[ptr] * u[lp->A_ind[ptr]];\n         /* compute new gamma[j] */\n         t1 = gamma[j] + r * (r * gamma_q + s + s);\n         t2 = (refsp[k] ? 1.0 : 0.0) + delta_q * r * r;\n         gamma[j] = (t1 >= t2 ? t1 : t2);\n      }\n      return e;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "spx_free_se": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "void spx_free_se(SPXLP *lp, SPXSE *se)\n{     xassert(lp == lp);\n      tfree(se->refsp);\n      tfree(se->gamma);\n      tfree(se->work);\n      return;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxchuzc.h": {},
  "glpk/glpk-4.65/src/simplex/spxchuzr.c": {
    "spx_chuzr_std": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int spx_chuzr_std(SPXLP *lp, int phase, const double beta[/*1+m*/],\n      int q, double s, const double tcol[/*1+m*/], int *p_flag,\n      double tol_piv, double tol, double tol1)\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, i_flag, k, p;\n      double alfa, biga, delta, lk, uk, teta, teta_min;\n      xassert(phase == 1 || phase == 2);\n      xassert(1 <= q && q <= n-m);\n      xassert(s == +1.0 || s == -1.0);\n      /* determine initial teta_min */\n      k = head[m+q]; /* x[k] = xN[q] */\n      if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)\n      {  /* xN[q] has no opposite bound */\n         p = 0, *p_flag = 0, teta_min = DBL_MAX, biga = 0.0;\n      }\n      else\n      {  /* xN[q] have both lower and upper bounds */\n         p = -1, *p_flag = 0, teta_min = fabs(l[k] - u[k]), biga = 1.0;\n      }\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         /* determine alfa such that delta xB[i] = alfa * teta */\n         alfa = s * tcol[i];\n         if (alfa <= -tol_piv)\n         {  /* xB[i] decreases */\n            /* determine actual lower bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* xB[i] has no actual lower bound */\n               continue;\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* actual lower bound of xB[i] is its upper bound */\n               lk = u[k];\n               xassert(lk != +DBL_MAX);\n               i_flag = 1;\n            }\n            else\n            {  /* actual lower bound of xB[i] is its original bound */\n               lk = l[k];\n               if (lk == -DBL_MAX)\n                  continue;\n               i_flag = 0;\n            }\n            /* determine teta on which xB[i] reaches its lower bound */\n            delta = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] <= lk + delta)\n               teta = 0.0;\n            else\n               teta = (lk - beta[i]) / alfa;\n         }\n         else if (alfa >= +tol_piv)\n         {  /* xB[i] increases */\n            /* determine actual upper bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* actual upper bound of xB[i] is its lower bound */\n               uk = l[k];\n               xassert(uk != -DBL_MAX);\n               i_flag = 0;\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* xB[i] has no actual upper bound */\n               continue;\n            }\n            else\n            {  /* actual upper bound of xB[i] is its original bound */\n               uk = u[k];\n               if (uk == +DBL_MAX)\n                  continue;\n               i_flag = 1;\n            }\n            /* determine teta on which xB[i] reaches its upper bound */\n            delta = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] >= uk - delta)\n               teta = 0.0;\n            else\n               teta = (uk - beta[i]) / alfa;\n         }\n         else\n         {  /* xB[i] does not depend on teta */\n            continue;\n         }\n         /* choose basic variable xB[p] for which teta is minimal */\n         xassert(teta >= 0.0);\n         alfa = (alfa >= 0.0 ? +alfa : -alfa);\n         if (teta_min > teta || (teta_min == teta && biga < alfa))\n            p = i, *p_flag = i_flag, teta_min = teta, biga = alfa;\n      }\n      /* if xB[p] is fixed variable, adjust its bound flag */\n      if (p > 0)\n      {  k = head[p];\n         if (l[k] == u[k])\n            *p_flag = 0;\n      }\n      return p;\n}",
      "lines": 101,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "spx_chuzr_harris": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int spx_chuzr_harris(SPXLP *lp, int phase, const double beta[/*1+m*/],\n      int q, double s, const double tcol[/*1+m*/], int *p_flag,\n      double tol_piv, double tol, double tol1)\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, i_flag, k, p;\n      double alfa, biga, delta, lk, uk, teta, teta_min;\n      xassert(phase == 1 || phase == 2);\n      xassert(1 <= q && q <= n-m);\n      xassert(s == +1.0 || s == -1.0);\n      /*--------------------------------------------------------------*/\n      /* first pass: determine teta_min for relaxed bounds            */\n      /*--------------------------------------------------------------*/\n      teta_min = DBL_MAX;\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         /* determine alfa such that delta xB[i] = alfa * teta */\n         alfa = s * tcol[i];\n         if (alfa <= -tol_piv)\n         {  /* xB[i] decreases */\n            /* determine actual lower bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* xB[i] has no actual lower bound */\n               continue;\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* actual lower bound of xB[i] is its upper bound */\n               lk = u[k];\n               xassert(lk != +DBL_MAX);\n            }\n            else\n            {  /* actual lower bound of xB[i] is its original bound */\n               lk = l[k];\n               if (lk == -DBL_MAX)\n                  continue;\n            }\n            /* determine teta on which xB[i] reaches its relaxed lower\n             * bound */\n            delta = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] < lk)\n               teta = - delta / alfa;\n            else\n               teta = ((lk - delta) - beta[i]) / alfa;\n         }\n         else if (alfa >= +tol_piv)\n         {  /* xB[i] increases */\n            /* determine actual upper bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* actual upper bound of xB[i] is its lower bound */\n               uk = l[k];\n               xassert(uk != -DBL_MAX);\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* xB[i] has no actual upper bound */\n               continue;\n            }\n            else\n            {  /* actual upper bound of xB[i] is its original bound */\n               uk = u[k];\n               if (uk == +DBL_MAX)\n                  continue;\n            }\n            /* determine teta on which xB[i] reaches its relaxed upper\n             * bound */\n            delta = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] > uk)\n               teta = + delta / alfa;\n            else\n               teta = ((uk + delta) - beta[i]) / alfa;\n         }\n         else\n         {  /* xB[i] does not depend on teta */\n            continue;\n         }\n         xassert(teta >= 0.0);\n         if (teta_min > teta)\n            teta_min = teta;\n      }\n      /*--------------------------------------------------------------*/\n      /* second pass: choose basic variable xB[p]                     */\n      /*--------------------------------------------------------------*/\n      k = head[m+q]; /* x[k] = xN[q] */\n      if (l[k] != -DBL_MAX && u[k] != +DBL_MAX)\n      {  /* xN[q] has both lower and upper bounds */\n         if (fabs(l[k] - u[k]) <= teta_min)\n         {  /* and reaches its opposite bound */\n            p = -1, *p_flag = 0;\n            goto done;\n         }\n      }\n      if (teta_min == DBL_MAX)\n      {  /* teta may increase unlimitedly */\n         p = 0, *p_flag = 0;\n         goto done;\n      }\n      /* nothing is chosen so far */\n      p = 0, *p_flag = 0, biga = 0.0;\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         /* determine alfa such that delta xB[i] = alfa * teta */\n         alfa = s * tcol[i];\n         if (alfa <= -tol_piv)\n         {  /* xB[i] decreases */\n            /* determine actual lower bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* xB[i] has no actual lower bound */\n               continue;\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* actual lower bound of xB[i] is its upper bound */\n               lk = u[k];\n               xassert(lk != +DBL_MAX);\n               i_flag = 1;\n            }\n            else\n            {  /* actual lower bound of xB[i] is its original bound */\n               lk = l[k];\n               if (lk == -DBL_MAX)\n                  continue;\n               i_flag = 0;\n            }\n            /* determine teta on which xB[i] reaches its lower bound */\n            teta = (lk - beta[i]) / alfa;\n         }\n         else if (alfa >= +tol_piv)\n         {  /* xB[i] increases */\n            /* determine actual upper bound of xB[i] */\n            if (phase == 1 && c[k] < 0.0)\n            {  /* actual upper bound of xB[i] is its lower bound */\n               uk = l[k];\n               xassert(uk != -DBL_MAX);\n               i_flag = 0;\n            }\n            else if (phase == 1 && c[k] > 0.0)\n            {  /* xB[i] has no actual upper bound */\n               continue;\n            }\n            else\n            {  /* actual upper bound of xB[i] is its original bound */\n               uk = u[k];\n               if (uk == +DBL_MAX)\n                  continue;\n               i_flag = 1;\n            }\n            /* determine teta on which xB[i] reaches its upper bound */\n            teta = (uk - beta[i]) / alfa;\n         }\n         else\n         {  /* xB[i] does not depend on teta */\n            continue;\n         }\n         /* choose basic variable for which teta is not greater than\n          * teta_min determined for relaxed bounds and which has best\n          * (largest in magnitude) pivot */\n         alfa = (alfa >= 0.0 ? +alfa : -alfa);\n         if (teta <= teta_min && biga < alfa)\n            p = i, *p_flag = i_flag, biga = alfa;\n      }\n      /* something must be chosen */\n      xassert(1 <= p && p <= m);\n      /* if xB[p] is fixed variable, adjust its bound flag */\n      k = head[p];\n      if (l[k] == u[k])\n         *p_flag = 0;\ndone: return p;\n}",
      "lines": 172,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "spx_ls_eval_bp": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "int spx_ls_eval_bp(SPXLP *lp, const double beta[/*1+m*/],\n      int q, double dq, const double tcol[/*1+m*/], double tol_piv,\n      SPXBP bp[/*1+2*m+1*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, k, nbp;\n      double s, alfa;\n      xassert(1 <= q && q <= n-m);\n      xassert(dq != 0.0);\n      s = (dq < 0.0 ? +1.0 : -1.0);\n      nbp = 0;\n      /* if chosen non-basic variable xN[q] is double-bounded, include\n       * it in the list, because it can cross its opposite bound */\n      k = head[m+q]; /* x[k] = xN[q] */\n      if (l[k] != -DBL_MAX && u[k] != +DBL_MAX)\n      {  nbp++;\n         bp[nbp].i = 0;\n         xassert(l[k] < u[k]); /* xN[q] cannot be fixed */\n         bp[nbp].teta = u[k] - l[k];\n         bp[nbp].dc = s;\n      }\n      /* build the list of all basic variables xB[i] that can cross\n       * their bound(s) for the ray parameter 0 <= teta < teta_max */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         xassert(l[k] <= u[k]);\n         /* determine alfa such that (delta xB[i]) = alfa * teta */\n         alfa = s * tcol[i];\n         if (alfa >= +tol_piv)\n         {  /* xB[i] increases on increasing teta */\n            if (l[k] == u[k])\n            {  /* xB[i] is fixed at lB[i] = uB[i] */\n               if (c[k] <= 0.0)\n               {  /* increasing xB[i] can cross its fixed value lB[i],\n                   * because currently xB[i] <= lB[i] */\n                  nbp++;\n                  bp[nbp].i = +i;\n                  bp[nbp].teta = (l[k] - beta[i]) / alfa;\n                  /* if xB[i] > lB[i] then cB[i] = +1 */\n                  bp[nbp].dc = +1.0 - c[k];\n               }\n            }\n            else\n            {  if (l[k] != -DBL_MAX && c[k] < 0.0)\n               {  /* increasing xB[i] can cross its lower bound lB[i],\n                   * because currently xB[i] < lB[i] */\n                  nbp++;\n                  bp[nbp].i = +i;\n                  bp[nbp].teta = (l[k] - beta[i]) / alfa;\n                  bp[nbp].dc = +1.0;\n               }\n               if (u[k] != +DBL_MAX && c[k] <= 0.0)\n               {  /* increasing xB[i] can cross its upper bound uB[i],\n                   * because currently xB[i] does not violate it */\n                  nbp++;\n                  bp[nbp].i = -i;\n                  bp[nbp].teta = (u[k] - beta[i]) / alfa;\n                  bp[nbp].dc = +1.0;\n               }\n            }\n         }\n         else if (alfa <= -tol_piv)\n         {  /* xB[i] decreases on increasing teta */\n            if (l[k] == u[k])\n            {  /* xB[i] is fixed at lB[i] = uB[i] */\n               if (c[k] >= 0.0)\n               {  /* decreasing xB[i] can cross its fixed value lB[i],\n                   * because currently xB[i] >= lB[i] */\n                  nbp++;\n                  bp[nbp].i = +i;\n                  bp[nbp].teta = (l[k] - beta[i]) / alfa;\n                  /* if xB[i] < lB[i] then cB[i] = -1 */\n                  bp[nbp].dc = -1.0 - c[k];\n               }\n            }\n            else\n            {  if (l[k] != -DBL_MAX && c[k] >= 0.0)\n               {  /* decreasing xB[i] can cross its lower bound lB[i],\n                   * because currently xB[i] does not violate it */\n                  nbp++;\n                  bp[nbp].i = +i;\n                  bp[nbp].teta = (l[k] - beta[i]) / alfa;\n                  bp[nbp].dc = -1.0;\n               }\n               if (u[k] != +DBL_MAX && c[k] > 0.0)\n               {  /* decreasing xB[i] can cross its upper bound uB[i],\n                   * because currently xB[i] > uB[i] */\n                  nbp++;\n                  bp[nbp].i = -i;\n                  bp[nbp].teta = (u[k] - beta[i]) / alfa;\n                  bp[nbp].dc = -1.0;\n               }\n            }\n         }\n         else\n         {  /* xB[i] does not depend on teta within a tolerance */\n            continue;\n         }\n         /* teta < 0 may happen only due to round-off errors when the\n          * current value of xB[i] is *close* to its (lower or upper)\n          * bound; in this case we replace teta by exact zero */\n         if (bp[nbp].teta < 0.0)\n            bp[nbp].teta = 0.0;\n      }\n      xassert(nbp <= 2*m+1);\n      return nbp;\n}",
      "lines": 111,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "fcmp": {
      "start_point": [
        538,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "static int CDECL fcmp(const void *v1, const void *v2)\n{     const SPXBP *p1 = v1, *p2 = v2;\n      if (p1->teta < p2->teta)\n         return -1;\n      else if (p1->teta > p2->teta)\n         return +1;\n      else\n         return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int",
        "CDECL",
        "CDECL"
      ]
    },
    "spx_ls_select_bp": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "int spx_ls_select_bp(SPXLP *lp, const double tcol[/*1+m*/],\n      int nbp, SPXBP bp[/*1+m+m+1*/], int num, double *slope, double\n      teta_lim)\n{     int m = lp->m;\n      int i, t, num1;\n      double teta, dz;\n      xassert(0 <= num && num <= nbp && nbp <= m+m+1);\n      /* select a new portion of break points */\n      num1 = num;\n      for (t = num+1; t <= nbp; t++)\n      {  if (bp[t].teta <= teta_lim)\n         {  /* move break point to the beginning of the new portion */\n            num1++;\n            i = bp[num1].i, teta = bp[num1].teta, dz = bp[num1].dc;\n            bp[num1].i = bp[t].i, bp[num1].teta = bp[t].teta,\n            bp[num1].dc = bp[t].dc;\n            bp[t].i = i, bp[t].teta = teta, bp[t].dc = dz;\n         }\n      }\n      /* sort new break points bp[num+1], ..., bp[num1] by ascending\n       * the ray parameter teta */\n      if (num1 - num > 1)\n         qsort(&bp[num+1], num1 - num, sizeof(SPXBP), fcmp);\n      /* calculate the penalty function change at the new break points\n       * selected */\n      for (t = num+1; t <= num1; t++)\n      {  /* calculate the penalty function change relative to its value\n          * at break point bp[t-1] */\n         dz = (*slope) * (bp[t].teta - (t == 1 ? 0.0 : bp[t-1].teta));\n         /* calculate the penalty function change relative to its value\n          * at teta = 0 */\n         bp[t].dz = (t == 1 ? 0.0 : bp[t-1].dz) + dz;\n         /* calculate a new slope of the penalty function to the right\n          * of the current break point bp[t] */\n         i = (bp[t].i >= 0 ? bp[t].i : -bp[t].i);\n         xassert(0 <= i && i <= m);\n         if (i == 0)\n            *slope += fabs(1.0 * bp[t].dc);\n         else\n            *slope += fabs(tcol[i] * bp[t].dc);\n      }\n      return num1;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxchuzr.h": {},
  "glpk/glpk-4.65/src/simplex/spxlp.c": {
    "jth_col": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static int jth_col(void *info, int j, int ind[], double val[])\n{     /* provide column B[j] */\n      SPXLP *lp = info;\n      int m = lp->m;\n      int *A_ptr = lp->A_ptr;\n      int *head = lp->head;\n      int k, ptr, len;\n      xassert(1 <= j && j <= m);\n      k = head[j]; /* x[k] = xB[j] */\n      ptr = A_ptr[k];\n      len = A_ptr[k+1] - ptr;\n      memcpy(&ind[1], &lp->A_ind[ptr], len * sizeof(int));\n      memcpy(&val[1], &lp->A_val[ptr], len * sizeof(double));\n      return len;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "spx_factorize": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int spx_factorize(SPXLP *lp)\n{     int ret;\n      ret = bfd_factorize(lp->bfd, lp->m, jth_col, lp);\n      lp->valid = (ret == 0);\n      return ret;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "spx_eval_beta": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void spx_eval_beta(SPXLP *lp, double beta[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      double *b = lp->b;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k, ptr, end;\n      double fj, *y;\n      /* compute y = b - N * xN */\n      /* y := b */\n      y = beta;\n      memcpy(&y[1], &b[1], m * sizeof(double));\n      /* y := y - N * f */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* f[j] := active bound of xN[j] */\n         fj = flag[j] ? u[k] : l[k];\n         if (fj == 0.0 || fj == -DBL_MAX)\n         {  /* either xN[j] has zero active bound or it is unbounded;\n             * in the latter case its value is assumed to be zero */\n            continue;\n         }\n         /* y := y - N[j] * f[j] */\n         ptr = A_ptr[k];\n         end = A_ptr[k+1];\n         for (; ptr < end; ptr++)\n            y[A_ind[ptr]] -= A_val[ptr] * fj;\n      }\n      /* compute beta = inv(B) * y */\n      xassert(lp->valid);\n      bfd_ftran(lp->bfd, beta);\n      return;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_obj": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "double spx_eval_obj(SPXLP *lp, const double beta[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int i, j, k;\n      double fj, z;\n      /* compute z = cB'* beta + cN'* f + c0 */\n      /* z := c0 */\n      z = c[0];\n      /* z := z + cB'* beta */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         z += c[k] * beta[i];\n      }\n      /* z := z + cN'* f */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* f[j] := active bound of xN[j] */\n         fj = flag[j] ? u[k] : l[k];\n         if (fj == 0.0 || fj == -DBL_MAX)\n         {  /* either xN[j] has zero active bound or it is unbounded;\n             * in the latter case its value is assumed to be zero */\n            continue;\n         }\n         z += c[k] * fj;\n      }\n      return z;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "spx_eval_pi": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void spx_eval_pi(SPXLP *lp, double pi[/*1+m*/])\n{     int m = lp->m;\n      double *c = lp->c;\n      int *head = lp->head;\n      int i;\n      double *cB;\n      /* construct cB */\n      cB = pi;\n      for (i = 1; i <= m; i++)\n         cB[i] = c[head[i]];\n      /* compute pi = inv(B) * cB */\n      bfd_btran(lp->bfd, pi);\n      return;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_dj": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "double spx_eval_dj(SPXLP *lp, const double pi[/*1+m*/], int j)\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int k, ptr, end;\n      double dj;\n      xassert(1 <= j && j <= n-m);\n      k = lp->head[m+j]; /* x[k] = xN[j] */\n      /* dj := c[k] */\n      dj = lp->c[k];\n      /* dj := dj - A'[k] * pi */\n      ptr = A_ptr[k];\n      end = A_ptr[k+1];\n      for (; ptr < end; ptr++)\n         dj -= A_val[ptr] * pi[A_ind[ptr]];\n      return dj;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "spx_eval_tcol": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void spx_eval_tcol(SPXLP *lp, int j, double tcol[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int *head = lp->head;\n      int i, k, ptr, end;\n      xassert(1 <= j && j <= n-m);\n      k = head[m+j]; /* x[k] = xN[j] */\n      /* compute tcol = - inv(B) * N[j] */\n      for (i = 1; i <= m; i++)\n         tcol[i] = 0.0;\n      ptr = A_ptr[k];\n      end = A_ptr[k+1];\n      for (; ptr < end; ptr++)\n         tcol[A_ind[ptr]] = -A_val[ptr];\n      bfd_ftran(lp->bfd, tcol);\n      return;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_rho": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "void spx_eval_rho(SPXLP *lp, int i, double rho[/*1+m*/])\n{     int m = lp->m;\n      int j;\n      xassert(1 <= i && i <= m);\n      /* compute rho = inv(B') * e[i] */\n      for (j = 1; j <= m; j++)\n         rho[j] = 0.0;\n      rho[i] = 1.0;\n      bfd_btran(lp->bfd, rho);\n      return;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_rho_s": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void spx_eval_rho_s(SPXLP *lp, int i, FVS *rho)\n{     /* sparse version of spx_eval_rho */\n      int m = lp->m;\n      xassert(1 <= i && i <= m);\n      /* compute rho = inv(B') * e[i] */\n      xassert(rho->n == m);\n      fvs_clear_vec(rho);\n      rho->nnz = 1;\n      rho->ind[1] = i;\n      rho->vec[i] = 1.0;\n      bfd_btran_s(lp->bfd, rho);\n      return;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spx_eval_tij": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "double spx_eval_tij(SPXLP *lp, const double rho[/*1+m*/], int j)\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int k, ptr, end;\n      double tij;\n      xassert(1 <= j && j <= n-m);\n      k = lp->head[m+j]; /* x[k] = xN[j] */\n      /* compute t[i,j] = - N'[j] * pi */\n      tij = 0.0;\n      ptr = A_ptr[k];\n      end = A_ptr[k+1];\n      for (; ptr < end; ptr++)\n         tij -= A_val[ptr] * rho[A_ind[ptr]];\n      return tij;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "spx_eval_trow": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "void spx_eval_trow(SPXLP *lp, const double rho[/*1+m*/], double\n      trow[/*1+n-m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int j;\n      for (j = 1; j <= n-m; j++)\n         trow[j] = spx_eval_tij(lp, rho, j);\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spx_update_beta": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "void spx_update_beta(SPXLP *lp, double beta[/*1+m*/], int p,\n      int p_flag, int q, const double tcol[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int i, k;\n      double delta_p, delta_q;\n      if (p < 0)\n      {  /* special case: xN[q] goes to its opposite bound */\n         xassert(1 <= q && q <= n-m);\n         /* xN[q] should be double-bounded variable */\n         k = head[m+q]; /* x[k] = xN[q] */\n         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);\n         /* determine delta xN[q] */\n         if (flag[q])\n         {  /* xN[q] goes from its upper bound to its lower bound */\n            delta_q = l[k] - u[k];\n         }\n         else\n         {  /* xN[q] goes from its lower bound to its upper bound */\n            delta_q = u[k] - l[k];\n         }\n      }\n      else\n      {  /* xB[p] leaves the basis, xN[q] enters the basis */\n         xassert(1 <= p && p <= m);\n         xassert(1 <= q && q <= n-m);\n         /* determine delta xB[p] */\n         k = head[p]; /* x[k] = xB[p] */\n         if (p_flag)\n         {  /* xB[p] goes to its upper bound */\n            xassert(l[k] != u[k] && u[k] != +DBL_MAX);\n            delta_p = u[k] - beta[p];\n         }\n         else if (l[k] == -DBL_MAX)\n         {  /* unbounded xB[p] becomes non-basic (unusual case) */\n            xassert(u[k] == +DBL_MAX);\n            delta_p = 0.0 - beta[p];\n         }\n         else\n         {  /* xB[p] goes to its lower bound or becomes fixed */\n            delta_p = l[k] - beta[p];\n         }\n         /* determine delta xN[q] */\n         delta_q = delta_p / tcol[p];\n         /* compute new beta[p], which is the value of xN[q] in the\n          * adjacent basis */\n         k = head[m+q]; /* x[k] = xN[q] */\n         if (flag[q])\n         {  /* xN[q] has its upper bound active */\n            xassert(l[k] != u[k] && u[k] != +DBL_MAX);\n            beta[p] = u[k] + delta_q;\n         }\n         else if (l[k] == -DBL_MAX)\n         {  /* xN[q] is non-basic unbounded variable */\n            xassert(u[k] == +DBL_MAX);\n            beta[p] = 0.0 + delta_q;\n         }\n         else\n         {  /* xN[q] has its lower bound active or is fixed (latter\n             * case is unusual) */\n            beta[p] = l[k] + delta_q;\n         }\n      }\n      /* compute new beta[i] for all i != p */\n      for (i = 1; i <= m; i++)\n      {  if (i != p)\n            beta[i] += tcol[i] * delta_q;\n      }\n      return;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spx_update_beta_s": {
      "start_point": [
        533,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "void spx_update_beta_s(SPXLP *lp, double beta[/*1+m*/], int p,\n      int p_flag, int q, const FVS *tcol)\n{     /* sparse version of spx_update_beta */\n      int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int nnz = tcol->nnz;\n      int *ind = tcol->ind;\n      double *vec = tcol->vec;\n      int i, k;\n      double delta_p, delta_q;\n      xassert(tcol->n == m);\n      if (p < 0)\n      {  /* special case: xN[q] goes to its opposite bound */\n#if 0 /* 11/VI-2017 */\n         /* FIXME: not tested yet */\n         xassert(0);\n#endif\n         xassert(1 <= q && q <= n-m);\n         /* xN[q] should be double-bounded variable */\n         k = head[m+q]; /* x[k] = xN[q] */\n         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);\n         /* determine delta xN[q] */\n         if (flag[q])\n         {  /* xN[q] goes from its upper bound to its lower bound */\n            delta_q = l[k] - u[k];\n         }\n         else\n         {  /* xN[q] goes from its lower bound to its upper bound */\n            delta_q = u[k] - l[k];\n         }\n      }\n      else\n      {  /* xB[p] leaves the basis, xN[q] enters the basis */\n         xassert(1 <= p && p <= m);\n         xassert(1 <= q && q <= n-m);\n         /* determine delta xB[p] */\n         k = head[p]; /* x[k] = xB[p] */\n         if (p_flag)\n         {  /* xB[p] goes to its upper bound */\n            xassert(l[k] != u[k] && u[k] != +DBL_MAX);\n            delta_p = u[k] - beta[p];\n         }\n         else if (l[k] == -DBL_MAX)\n         {  /* unbounded xB[p] becomes non-basic (unusual case) */\n            xassert(u[k] == +DBL_MAX);\n            delta_p = 0.0 - beta[p];\n         }\n         else\n         {  /* xB[p] goes to its lower bound or becomes fixed */\n            delta_p = l[k] - beta[p];\n         }\n         /* determine delta xN[q] */\n         delta_q = delta_p / vec[p];\n         /* compute new beta[p], which is the value of xN[q] in the\n          * adjacent basis */\n         k = head[m+q]; /* x[k] = xN[q] */\n         if (flag[q])\n         {  /* xN[q] has its upper bound active */\n            xassert(l[k] != u[k] && u[k] != +DBL_MAX);\n            beta[p] = u[k] + delta_q;\n         }\n         else if (l[k] == -DBL_MAX)\n         {  /* xN[q] is non-basic unbounded variable */\n            xassert(u[k] == +DBL_MAX);\n            beta[p] = 0.0 + delta_q;\n         }\n         else\n         {  /* xN[q] has its lower bound active or is fixed (latter\n             * case is unusual) */\n            beta[p] = l[k] + delta_q;\n         }\n      }\n      /* compute new beta[i] for all i != p */\n      for (k = 1; k <= nnz; k++)\n      {  i = ind[k];\n         if (i != p)\n            beta[i] += vec[i] * delta_q;\n      }\n      return;\n}",
      "lines": 84,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spx_update_d": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        697,
        1
      ],
      "content": "double spx_update_d(SPXLP *lp, double d[/*1+n-m*/], int p, int q,\n      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      int *head = lp->head;\n      int i, j, k;\n      double dq, e;\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n);\n      /* compute d[q] in current basis more accurately */\n      k = head[m+q]; /* x[k] = xN[q] */\n      dq = c[k];\n      for (i = 1; i <= m; i++)\n         dq += tcol[i] * c[head[i]];\n      /* compute relative error in d[q] */\n      e = fabs(dq - d[q]) / (1.0 + fabs(dq));\n      /* compute new d[q], which is the reduced cost of xB[p] in the\n       * adjacent basis */\n      d[q] = (dq /= tcol[p]);\n      /* compute new d[j] for all j != q */\n      for (j = 1; j <= n-m; j++)\n      {  if (j != q)\n            d[j] -= trow[j] * dq;\n      }\n      return e;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "spx_update_d_s": {
      "start_point": [
        700,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "double spx_update_d_s(SPXLP *lp, double d[/*1+n-m*/], int p, int q,\n      const FVS *trow, const FVS *tcol)\n{     /* sparse version of spx_update_d */\n      int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      int *head = lp->head;\n      int trow_nnz = trow->nnz;\n      int *trow_ind = trow->ind;\n      double *trow_vec = trow->vec;\n      int tcol_nnz = tcol->nnz;\n      int *tcol_ind = tcol->ind;\n      double *tcol_vec = tcol->vec;\n      int i, j, k;\n      double dq, e;\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n);\n      xassert(trow->n == n-m);\n      xassert(tcol->n == m);\n      /* compute d[q] in current basis more accurately */\n      k = head[m+q]; /* x[k] = xN[q] */\n      dq = c[k];\n      for (k = 1; k <= tcol_nnz; k++)\n      {  i = tcol_ind[k];\n         dq += tcol_vec[i] * c[head[i]];\n      }\n      /* compute relative error in d[q] */\n      e = fabs(dq - d[q]) / (1.0 + fabs(dq));\n      /* compute new d[q], which is the reduced cost of xB[p] in the\n       * adjacent basis */\n      d[q] = (dq /= tcol_vec[p]);\n      /* compute new d[j] for all j != q */\n      for (k = 1; k <= trow_nnz; k++)\n      {  j = trow_ind[k];\n         if (j != q)\n            d[j] -= trow_vec[j] * dq;\n      }\n      return e;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "double"
      ]
    },
    "spx_change_basis": {
      "start_point": [
        750,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "void spx_change_basis(SPXLP *lp, int p, int p_flag, int q)\n{     int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int k;\n      if (p < 0)\n      {  /* special case: xN[q] goes to its opposite bound */\n         xassert(1 <= q && q <= n-m);\n         /* xN[q] should be double-bounded variable */\n         k = head[m+q]; /* x[k] = xN[q] */\n         xassert(l[k] != -DBL_MAX && u[k] != +DBL_MAX && l[k] != u[k]);\n         /* change active bound flag */\n         flag[q] = 1 - flag[q];\n      }\n      else\n      {  /* xB[p] leaves the basis, xN[q] enters the basis */\n         xassert(1 <= p && p <= m);\n         xassert(p_flag == 0 || p_flag == 1);\n         xassert(1 <= q && q <= n-m);\n         k = head[p]; /* xB[p] = x[k] */\n         if (p_flag)\n         {  /* xB[p] goes to its upper bound */\n            xassert(l[k] != u[k] && u[k] != +DBL_MAX);\n         }\n         /* swap xB[p] and xN[q] in the basis */\n         head[p] = head[m+q], head[m+q] = k;\n         /* and set active bound flag for new xN[q] */\n         lp->flag[q] = p_flag;\n      }\n      return;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "spx_update_invb": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "int spx_update_invb(SPXLP *lp, int i, int k)\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int ptr, len, ret;\n      xassert(1 <= i && i <= m);\n      xassert(1 <= k && k <= n);\n      ptr = A_ptr[k];\n      len = A_ptr[k+1] - ptr;\n      ret = bfd_update(lp->bfd, i, len, &A_ind[ptr-1], &A_val[ptr-1]);\n      lp->valid = (ret == 0);\n      return ret;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxlp.h": {},
  "glpk/glpk-4.65/src/simplex/spxnt.c": {
    "spx_alloc_nt": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void spx_alloc_nt(SPXLP *lp, SPXNT *nt)\n{     int m = lp->m;\n      int nnz = lp->nnz;\n      nt->ptr = talloc(1+m, int);\n      nt->len = talloc(1+m, int);\n      nt->ind = talloc(1+nnz, int);\n      nt->val = talloc(1+nnz, double);\n      return;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "spx_init_nt": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void spx_init_nt(SPXLP *lp, SPXNT *nt)\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      int *NT_ptr = nt->ptr;\n      int *NT_len = nt->len;\n      int i, k, ptr, end;\n      /* calculate NT_len[i] = maximal number of non-zeros in i-th row\n       * of N = number of non-zeros in i-th row of A */\n      memset(&NT_len[1], 0, m * sizeof(int));\n      for (k = 1; k <= n; k++)\n      {  ptr = A_ptr[k];\n         end = A_ptr[k+1];\n         for (; ptr < end; ptr++)\n            NT_len[A_ind[ptr]]++;\n      }\n      /* initialize row pointers NT_ptr[i], i = 1,...,n-m */\n      NT_ptr[1] = 1;\n      for (i = 2; i <= m; i++)\n         NT_ptr[i] = NT_ptr[i-1] + NT_len[i-1];\n      xassert(NT_ptr[m] + NT_len[m] == nnz+1);\n      return;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spx_nt_add_col": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void spx_nt_add_col(SPXLP *lp, SPXNT *nt, int j, int k)\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      int *NT_ptr = nt->ptr;\n      int *NT_len = nt->len;\n      int *NT_ind = nt->ind;\n      double *NT_val = nt->val;\n      int i, ptr, end, pos;\n      xassert(1 <= j && j <= n-m);\n      xassert(1 <= k && k <= n);\n      ptr = A_ptr[k];\n      end = A_ptr[k+1];\n      for (; ptr < end; ptr++)\n      {  i = A_ind[ptr];\n         /* add element N[i,j] = A[i,k] to i-th row of matrix N */\n         pos = NT_ptr[i] + (NT_len[i]++);\n         if (i < m)\n            xassert(pos < NT_ptr[i+1]);\n         else\n            xassert(pos <= nnz);\n         NT_ind[pos] = j;\n         NT_val[pos] = A_val[ptr];\n      }\n      return;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_build_nt": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void spx_build_nt(SPXLP *lp, SPXNT *nt)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      int *NT_len = nt->len;\n      int j, k;\n      /* N := 0 */\n      memset(&NT_len[1], 0, m * sizeof(int));\n      /* add non-basic columns N[j] = A[k] */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         spx_nt_add_col(lp, nt, j, k);\n      }\n      return;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_nt_del_col": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void spx_nt_del_col(SPXLP *lp, SPXNT *nt, int j, int k)\n{     int m = lp->m;\n      int n = lp->n;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      int *NT_ptr = nt->ptr;\n      int *NT_len = nt->len;\n      int *NT_ind = nt->ind;\n      double *NT_val = nt->val;\n      int i, ptr, end, ptr1, end1;\n      xassert(1 <= j && j <= n-m);\n      xassert(1 <= k && k <= n);\n      ptr = A_ptr[k];\n      end = A_ptr[k+1];\n      for (; ptr < end; ptr++)\n      {  i = A_ind[ptr];\n         /* find element N[i,j] = A[i,k] in i-th row of matrix N */\n         ptr1 = NT_ptr[i];\n         end1 = ptr1 + NT_len[i];\n         for (; NT_ind[ptr1] != j; ptr1++)\n            /* nop */;\n         xassert(ptr1 < end1);\n         /* and remove it from i-th row element list */\n         NT_len[i]--;\n         NT_ind[ptr1] = NT_ind[end1-1];\n         NT_val[ptr1] = NT_val[end1-1];\n      }\n      return;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_update_nt": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void spx_update_nt(SPXLP *lp, SPXNT *nt, int p, int q)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n-m);\n      /* remove old column N[q] corresponding to variable xN[q] */\n      spx_nt_del_col(lp, nt, q, head[m+q]);\n      /* add new column N[q] corresponding to variable xB[p] */\n      spx_nt_add_col(lp, nt, q, head[p]);\n      return;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_nt_prod": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "void spx_nt_prod(SPXLP *lp, SPXNT *nt, double y[/*1+n-m*/], int ign,\n      double s, const double x[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *NT_ptr = nt->ptr;\n      int *NT_len = nt->len;\n      int *NT_ind = nt->ind;\n      double *NT_val = nt->val;\n      int i, j, ptr, end;\n      double t;\n      if (ign)\n      {  /* y := 0 */\n         for (j = 1; j <= n-m; j++)\n            y[j] = 0.0;\n      }\n      for (i = 1; i <= m; i++)\n      {  if (x[i] != 0.0)\n         {  /* y := y + s * (i-th row of N) * x[i] */\n            t = s * x[i];\n            ptr = NT_ptr[i];\n            end = ptr + NT_len[i];\n            for (; ptr < end; ptr++)\n               y[NT_ind[ptr]] += NT_val[ptr] * t;\n         }\n      }\n      return;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_nt_prod_s": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "void spx_nt_prod_s(SPXLP *lp, SPXNT *nt, FVS *y, int ign, double s,\n      const FVS *x, double eps)\n{     /* sparse version of spx_nt_prod */\n      int *NT_ptr = nt->ptr;\n      int *NT_len = nt->len;\n      int *NT_ind = nt->ind;\n      double *NT_val = nt->val;\n      int *x_ind = x->ind;\n      double *x_vec = x->vec;\n      int *y_ind = y->ind;\n      double *y_vec = y->vec;\n      int i, j, k, nnz, ptr, end;\n      double t;\n      xassert(x->n == lp->m);\n      xassert(y->n == lp->n-lp->m);\n      if (ign)\n      {  /* y := 0 */\n         fvs_clear_vec(y);\n      }\n      nnz = y->nnz;\n      for (k = x->nnz; k >= 1; k--)\n      {  i = x_ind[k];\n         /* y := y + s * (i-th row of N) * x[i] */\n         t = s * x_vec[i];\n         ptr = NT_ptr[i];\n         end = ptr + NT_len[i];\n         for (; ptr < end; ptr++)\n         {  j = NT_ind[ptr];\n            if (y_vec[j] == 0.0)\n               y_ind[++nnz] = j;\n            y_vec[j] += NT_val[ptr] * t;\n            /* don't forget about numeric cancellation */\n            if (y_vec[j] == 0.0)\n               y_vec[j] = DBL_MIN;\n         }\n      }\n      y->nnz = nnz;\n      fvs_adjust_vec(y, eps);\n      return;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_free_nt": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "void spx_free_nt(SPXLP *lp, SPXNT *nt)\n{     xassert(lp == lp);\n      tfree(nt->ptr);\n      tfree(nt->len);\n      tfree(nt->ind);\n      tfree(nt->val);\n      return;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxnt.h": {},
  "glpk/glpk-4.65/src/simplex/spxprim.c": {
    "set_penalty": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static int set_penalty(struct csa *csa, double tol, double tol1)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *beta = csa->beta;\n      int i, k, count = 0;\n      double t, eps;\n      /* reset objective coefficients */\n      for (k = 0; k <= n; k++)\n         c[k] = 0.0;\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         /* check lower bound */\n         if ((t = l[k]) != -DBL_MAX)\n         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);\n            if (beta[i] < t - eps)\n            {  /* lower bound is violated */\n               c[k] = -1.0, count++;\n            }\n         }\n         /* check upper bound */\n         if ((t = u[k]) != +DBL_MAX)\n         {  eps = tol + tol1 * (t >= 0.0 ? +t : -t);\n            if (beta[i] > t + eps)\n            {  /* upper bound is violated */\n               c[k] = +1.0, count++;\n            }\n         }\n      }\n      return count;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "check_feas": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static int check_feas(struct csa *csa, int phase, double tol, double\n      tol1)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *beta = csa->beta;\n      int i, k, orig, ret = 0;\n      double lk, uk, eps;\n      xassert(phase == 1 || phase == 2);\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         /* determine actual bounds of x[k] */\n         if (phase == 1 && c[k] < 0.0)\n         {  /* -inf < x[k] <= l[k] */\n            lk = -DBL_MAX, uk = l[k];\n            orig = 0; /* artificial bounds */\n         }\n         else if (phase == 1 && c[k] > 0.0)\n         {  /* u[k] <= x[k] < +inf */\n            lk = u[k], uk = +DBL_MAX;\n            orig = 0; /* artificial bounds */\n         }\n         else\n         {  /* l[k] <= x[k] <= u[k] */\n            lk = l[k], uk = u[k];\n            orig = 1; /* original bounds */\n         }\n         /* check actual lower bound */\n         if (lk != -DBL_MAX)\n         {  eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] < lk - eps)\n            {  /* actual lower bound is violated */\n               if (orig)\n               {  ret = 2;\n                  break;\n               }\n               ret = 1;\n            }\n         }\n         /* check actual upper bound */\n         if (uk != +DBL_MAX)\n         {  eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] > uk + eps)\n            {  /* actual upper bound is violated */\n               if (orig)\n               {  ret = 2;\n                  break;\n               }\n               ret = 1;\n            }\n         }\n      }\n      return ret;\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "adjust_penalty": [
      {
        "start_point": [
          370,
          0
        ],
        "end_point": [
          404,
          1
        ],
        "content": "static int adjust_penalty(struct csa *csa, double tol, double tol1)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *beta = csa->beta;\n      int i, k, count = 0;\n      double t, eps;\n      xassert(csa->phase == 1);\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         if (c[k] < 0.0)\n         {  /* x[k] violates its original lower bound l[k] */\n            xassert((t = l[k]) != -DBL_MAX);\n            eps = tol + tol1 * (t >= 0.0 ? +t : -t);\n            if (beta[i] >= t - eps)\n            {  /* however, violation is close to zero */\n               c[k] = 0.0, count++;\n            }\n         }\n         else if (c[k] > 0.0)\n         {  /* x[k] violates its original upper bound u[k] */\n            xassert((t = u[k]) != +DBL_MAX);\n            eps = tol + tol1 * (t >= 0.0 ? +t : -t);\n            if (beta[i] <= t + eps)\n            {  /* however, violation is close to zero */\n               c[k] = 0.0, count++;\n            }\n         }\n      }\n      return count;\n}",
        "lines": 35,
        "depth": 15,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      },
      {
        "start_point": [
          406,
          0
        ],
        "end_point": [
          445,
          1
        ],
        "content": "static int adjust_penalty(struct csa *csa, int num, const int\n      ind[/*1+num*/], double tol, double tol1)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *beta = csa->beta;\n      int i, k, t, cnt = 0;\n      double lk, uk, eps;\n      xassert(csa->phase == 1);\n      /* walk thru the specified list of basic variables */\n      for (t = 1; t <= num; t++)\n      {  i = ind[t];\n         xassert(1 <= i && i <= m);\n         k = head[i]; /* x[k] = xB[i] */\n         if (c[k] < 0.0)\n         {  /* x[k] violates its original lower bound */\n            lk = l[k];\n            xassert(lk != -DBL_MAX);\n            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] >= lk - eps)\n            {  /* however, violation is close to zero */\n               c[k] = 0.0, cnt++;\n            }\n         }\n         else if (c[k] > 0.0)\n         {  /* x[k] violates its original upper bound */\n            uk = u[k];\n            xassert(uk != +DBL_MAX);\n            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] <= uk + eps)\n            {  /* however, violation is close to zero */\n               c[k] = 0.0, cnt++;\n            }\n         }\n      }\n      return cnt;\n}",
        "lines": 40,
        "depth": 15,
        "decorators": [
          "static",
          "static",
          "int"
        ]
      }
    ],
    "err_in_vec": {
      "start_point": [
        459,
        0
      ],
      "end_point": [
        469,
        1
      ],
      "content": "static double err_in_vec(int n, const double x[], const double y[])\n{     int i;\n      double err, err_max;\n      err_max = 0.0;\n      for (i = 1; i <= n; i++)\n      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));\n         if (err_max < err)\n            err_max = err;\n      }\n      return err_max;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_beta": {
      "start_point": [
        481,
        0
      ],
      "end_point": [
        490,
        1
      ],
      "content": "static double err_in_beta(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double err, *beta;\n      beta = talloc(1+m, double);\n      spx_eval_beta(lp, beta);\n      err = err_in_vec(m, beta, csa->beta);\n      tfree(beta);\n      return err;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_d": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "static double err_in_d(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      int j;\n      double err, *pi, *d;\n      pi = talloc(1+m, double);\n      d = talloc(1+n-m, double);\n      spx_eval_pi(lp, pi);\n      for (j = 1; j <= n-m; j++)\n         d[j] = spx_eval_dj(lp, pi, j);\n      err = err_in_vec(n-m, d, csa->d);\n      tfree(pi);\n      tfree(d);\n      return err;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_gamma": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        543,
        1
      ],
      "content": "static double err_in_gamma(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      SPXSE *se = csa->se;\n      int j;\n      double err, *gamma;\n      xassert(se != NULL);\n      gamma = talloc(1+n-m, double);\n      for (j = 1; j <= n-m; j++)\n         gamma[j] = spx_eval_gamma_j(lp, se, j);\n      err = err_in_vec(n-m, gamma, se->gamma);\n      tfree(gamma);\n      return err;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "check_accuracy": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "static void check_accuracy(struct csa *csa)\n{     double e_beta, e_d, e_gamma;\n      e_beta = err_in_beta(csa);\n      e_d = err_in_d(csa);\n      if (csa->se == NULL)\n         e_gamma = 0.;\n      else\n         e_gamma = err_in_gamma(csa);\n      xprintf(\"e_beta = %10.3e; e_d = %10.3e; e_gamma = %10.3e\\n\",\n         e_beta, e_d, e_gamma);\n      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);\n      return;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "play_bounds": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        945,
        1
      ],
      "content": "static void play_bounds(struct csa *csa, int all)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *orig_l = csa->orig_l;\n      double *orig_u = csa->orig_u;\n      double *beta = csa->beta;\n#if 0 /* 11/VI-2017 */\n      const double *tcol = csa->tcol; /* was used to update beta */\n#else\n      const double *tcol = csa->tcol.vec;\n#endif\n      int i, k;\n      xassert(csa->phase == 1 || csa->phase == 2);\n      /* primal values beta = (beta[i]) should be valid */\n      xassert(csa->beta_st);\n      /* walk thru the list of basic variables xB = (xB[i]) */\n      for (i = 1; i <= m; i++)\n      {  if (all || tcol[i] != 0.0)\n         {  /* beta[i] has changed in the adjacent basis */\n            k = head[i]; /* x[k] = xB[i] */\n            if (csa->phase == 1 && c[k] < 0.0)\n            {  /* -inf < xB[i] <= lB[i] (artificial bounds) */\n               if (beta[i] < l[k] - 1e-9)\n                  continue;\n               /* restore actual bounds */\n               c[k] = 0.0;\n               csa->d_st = 0; /* since c[k] = cB[i] has changed */\n            }\n            if (csa->phase == 1 && c[k] > 0.0)\n            {  /* uB[i] <= xB[i] < +inf (artificial bounds) */\n               if (beta[i] > u[k] + 1e-9)\n                  continue;\n               /* restore actual bounds */\n               c[k] = 0.0;\n               csa->d_st = 0; /* since c[k] = cB[i] has changed */\n            }\n            /* lB[i] <= xB[i] <= uB[i] */\n            if (csa->phase == 1)\n               xassert(c[k] == 0.0);\n            if (l[k] != -DBL_MAX)\n            {  /* xB[i] has lower bound */\n               if (beta[i] < l[k])\n               {  /* strong feasibility means xB[i] >= lB[i] */\n#if 0 /* 11/VI-2017 */\n                  l[k] = beta[i];\n#else\n                  l[k] = beta[i] - 1e-9;\n#endif\n               }\n               else if (l[k] < orig_l[k])\n               {  /* remove/reduce perturbation of lB[i] */\n                  if (beta[i] >= orig_l[k])\n                     l[k] = orig_l[k];\n                  else\n                     l[k] = beta[i];\n               }\n            }\n            if (u[k] != +DBL_MAX)\n            {  /* xB[i] has upper bound */\n               if (beta[i] > u[k])\n               {  /* strong feasibility means xB[i] <= uB[i] */\n#if 0 /* 11/VI-2017 */\n                  u[k] = beta[i];\n#else\n                  u[k] = beta[i] + 1e-9;\n#endif\n               }\n               else if (u[k] > orig_u[k])\n               {  /* remove/reduce perturbation of uB[i] */\n                  if (beta[i] <= orig_u[k])\n                     u[k] = orig_u[k];\n                  else\n                     u[k] = beta[i];\n               }\n            }\n         }\n      }\n      return;\n}",
      "lines": 83,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "remove_perturb": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        978,
        1
      ],
      "content": "static void remove_perturb(struct csa *csa)\n{     /* remove perturbation */\n      SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *orig_l = csa->orig_l;\n      double *orig_u = csa->orig_u;\n      int j, k;\n      /* restore original bounds of variables */\n      memcpy(l, orig_l, (1+n) * sizeof(double));\n      memcpy(u, orig_u, (1+n) * sizeof(double));\n      /* adjust flags of fixed non-basic variables, because in the\n       * perturbed problem such variables might be changed to double-\n       * bounded type */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == u[k])\n            flag[j] = 0;\n      }\n      /* removing perturbation changes primal solution components */\n      csa->phase = csa->beta_st = 0;\n#if 1\n      if (csa->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Removing LP perturbation [%d]...\\n\",\n            csa->it_cnt);\n#endif\n      return;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sum_infeas": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "static double sum_infeas(SPXLP *lp, const double beta[/*1+m*/])\n{     int m = lp->m;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, k;\n      double sum = 0.0;\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         if (l[k] != -DBL_MAX && beta[i] < l[k])\n            sum += l[k] - beta[i];\n         if (u[k] != +DBL_MAX && beta[i] > u[k])\n            sum += beta[i] - u[k];\n      }\n      return sum;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "display": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1105,
        1
      ],
      "content": "static void display(struct csa *csa, int spec)\n{     int nnn, k;\n      double obj, sum, *save, *save1;\n#if 1 /* 15/VII-2017 */\n      double tm_cur;\n#endif\n      /* check if the display output should be skipped */\n      if (csa->msg_lev < GLP_MSG_ON) goto skip;\n#if 1 /* 15/VII-2017 */\n      tm_cur = xtime();\n#endif\n      if (csa->out_dly > 0 &&\n#if 0 /* 15/VII-2017 */\n         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)\n#else\n         1000.0 * xdifftime(tm_cur, csa->tm_beg) < csa->out_dly)\n#endif\n         goto skip;\n      if (csa->it_cnt == csa->it_dpy) goto skip;\n#if 0 /* 15/VII-2017 */\n      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;\n#else\n      if (!spec &&\n         1000.0 * xdifftime(tm_cur, csa->tm_dpy) < csa->out_frq)\n         goto skip;\n#endif\n      /* compute original objective value */\n      save = csa->lp->c;\n      csa->lp->c = csa->orig_c;\n      obj = csa->dir * spx_eval_obj(csa->lp, csa->beta);\n      csa->lp->c = save;\n#if SCALE_Z\n      obj *= csa->fz;\n#endif\n      /* compute sum of (scaled) primal infeasibilities */\n#if 1 /* 01/VII-2017 */\n      save = csa->lp->l;\n      save1 = csa->lp->u;\n      csa->lp->l = csa->orig_l;\n      csa->lp->u = csa->orig_u;\n#endif\n      sum = sum_infeas(csa->lp, csa->beta);\n#if 1 /* 01/VII-2017 */\n      csa->lp->l = save;\n      csa->lp->u = save1;\n#endif\n      /* compute number of infeasibilities/non-optimalities */\n      switch (csa->phase)\n      {  case 1:\n            nnn = 0;\n            for (k = 1; k <= csa->lp->n; k++)\n               if (csa->lp->c[k] != 0.0) nnn++;\n            break;\n         case 2:\n            xassert(csa->d_st);\n            nnn = spx_chuzc_sel(csa->lp, csa->d, csa->tol_dj,\n               csa->tol_dj1, NULL);\n            break;\n         default:\n            xassert(csa != csa);\n      }\n      /* display search progress */\n      xprintf(\"%c%6d: obj = %17.9e inf = %11.3e (%d)\",\n         csa->phase == 2 ? '*' : ' ', csa->it_cnt, obj, sum, nnn);\n      if (csa->inv_cnt)\n      {  /* number of basis factorizations performed */\n         xprintf(\" %d\", csa->inv_cnt);\n         csa->inv_cnt = 0;\n      }\n#if 1 /* 23/VI-2017 */\n      if (csa->phase == 1 && csa->r_test == GLP_RT_FLIP)\n      {  /*xprintf(\"   %d,%d\", csa->ns_cnt, csa->ls_cnt);*/\n         if (csa->ns_cnt + csa->ls_cnt)\n            xprintf(\" %d%%\",\n               (100 * csa->ls_cnt) / (csa->ns_cnt + csa->ls_cnt));\n         csa->ns_cnt = csa->ls_cnt = 0;\n      }\n#endif\n      xprintf(\"\\n\");\n      csa->it_dpy = csa->it_cnt;\n#if 1 /* 15/VII-2017 */\n      csa->tm_dpy = tm_cur;\n#endif\nskip: return;\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spx_primal": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1857,
        1
      ],
      "content": "int spx_primal(glp_prob *P, const glp_smcp *parm)\n{     /* driver to the primal simplex method */\n      struct csa csa_, *csa = &csa_;\n      SPXLP lp;\n      SPXAT at;\n      SPXNT nt;\n      SPXSE se;\n      int ret, *map, *daeh;\n#if SCALE_Z\n      int i, j, k;\n#endif\n      /* build working LP and its initial basis */\n      memset(csa, 0, sizeof(struct csa));\n      csa->lp = &lp;\n      spx_init_lp(csa->lp, P, parm->excl);\n      spx_alloc_lp(csa->lp);\n      map = talloc(1+P->m+P->n, int);\n      spx_build_lp(csa->lp, P, parm->excl, parm->shift, map);\n      spx_build_basis(csa->lp, P, map);\n      switch (P->dir)\n      {  case GLP_MIN:\n            csa->dir = +1;\n            break;\n         case GLP_MAX:\n            csa->dir = -1;\n            break;\n         default:\n            xassert(P != P);\n      }\n#if SCALE_Z\n      csa->fz = 0.0;\n      for (k = 1; k <= csa->lp->n; k++)\n      {  double t = fabs(csa->lp->c[k]);\n         if (csa->fz < t)\n            csa->fz = t;\n      }\n      if (csa->fz <= 1000.0)\n         csa->fz = 1.0;\n      else\n         csa->fz /= 1000.0;\n      /*xprintf(\"csa->fz = %g\\n\", csa->fz);*/\n      for (k = 0; k <= csa->lp->n; k++)\n         csa->lp->c[k] /= csa->fz;\n#endif\n      csa->orig_c = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_c, csa->lp->c, (1+csa->lp->n) * sizeof(double));\n#if 1 /*PERTURB*/\n      csa->orig_l = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_l, csa->lp->l, (1+csa->lp->n) * sizeof(double));\n      csa->orig_u = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_u, csa->lp->u, (1+csa->lp->n) * sizeof(double));\n#else\n      csa->orig_l = csa->orig_u = NULL;\n#endif\n      switch (parm->aorn)\n      {  case GLP_USE_AT:\n            /* build matrix A in row-wise format */\n            csa->at = &at;\n            csa->nt = NULL;\n            spx_alloc_at(csa->lp, csa->at);\n            spx_build_at(csa->lp, csa->at);\n            break;\n         case GLP_USE_NT:\n            /* build matrix N in row-wise format for initial basis */\n            csa->at = NULL;\n            csa->nt = &nt;\n            spx_alloc_nt(csa->lp, csa->nt);\n            spx_init_nt(csa->lp, csa->nt);\n            spx_build_nt(csa->lp, csa->nt);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n      /* allocate and initialize working components */\n      csa->phase = 0;\n      csa->beta = talloc(1+csa->lp->m, double);\n      csa->beta_st = 0;\n      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);\n      csa->d_st = 0;\n      switch (parm->pricing)\n      {  case GLP_PT_STD:\n            csa->se = NULL;\n            break;\n         case GLP_PT_PSE:\n            csa->se = &se;\n            spx_alloc_se(csa->lp, csa->se);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n      csa->list = talloc(1+csa->lp->n-csa->lp->m, int);\n#if 0 /* 11/VI-2017 */\n      csa->tcol = talloc(1+csa->lp->m, double);\n      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);\n#else\n      fvs_alloc_vec(&csa->tcol, csa->lp->m);\n      fvs_alloc_vec(&csa->trow, csa->lp->n-csa->lp->m);\n#endif\n#if 1 /* 23/VI-2017 */\n      csa->bp = NULL;\n#endif\n#if 0 /* 09/VII-2017 */\n      csa->work = talloc(1+csa->lp->m, double);\n#else\n      fvs_alloc_vec(&csa->work, csa->lp->m);\n#endif\n      /* initialize control parameters */\n      csa->msg_lev = parm->msg_lev;\n#if 0 /* 23/VI-2017 */\n      switch (parm->r_test)\n      {  case GLP_RT_STD:\n            csa->harris = 0;\n            break;\n         case GLP_RT_HAR:\n#if 1 /* 16/III-2016 */\n         case GLP_RT_FLIP:\n            /* FIXME */\n            /* currently for primal simplex GLP_RT_FLIP is equivalent\n             * to GLP_RT_HAR */\n#endif\n            csa->harris = 1;\n            break;\n         default:\n            xassert(parm != parm);\n      }\n#else\n      switch (parm->r_test)\n      {  case GLP_RT_STD:\n         case GLP_RT_HAR:\n            break;\n         case GLP_RT_FLIP:\n            csa->bp = talloc(1+2*csa->lp->m+1, SPXBP);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n      csa->r_test = parm->r_test;\n#endif\n      csa->tol_bnd = parm->tol_bnd;\n      csa->tol_bnd1 = .001 * parm->tol_bnd;\n      csa->tol_dj = parm->tol_dj;\n      csa->tol_dj1 = .001 * parm->tol_dj;\n      csa->tol_piv = parm->tol_piv;\n      csa->it_lim = parm->it_lim;\n      csa->tm_lim = parm->tm_lim;\n      csa->out_frq = parm->out_frq;\n      csa->out_dly = parm->out_dly;\n      /* initialize working parameters */\n      csa->tm_beg = xtime();\n      csa->it_beg = csa->it_cnt = P->it_cnt;\n      csa->it_dpy = -1;\n#if 1 /* 15/VII-2017 */\n      csa->tm_dpy = 0.0;\n#endif\n      csa->inv_cnt = 0;\n#if 1 /* 01/VII-2017 */\n      csa->degen = 0;\n#endif\n#if 1 /* 23/VI-2017 */\n      csa->ns_cnt = csa->ls_cnt = 0;\n#endif\n      /* try to solve working LP */\n      ret = primal_simplex(csa);\n      /* return basis factorization back to problem object */\n      P->valid = csa->lp->valid;\n      P->bfd = csa->lp->bfd;\n      /* set solution status */\n      P->pbs_stat = csa->p_stat;\n      P->dbs_stat = csa->d_stat;\n      /* if the solver failed, do not store basis header and basic\n       * solution components to problem object */\n      if (ret == GLP_EFAIL)\n         goto skip;\n      /* convert working LP basis to original LP basis and store it to\n       * problem object */\n      daeh = talloc(1+csa->lp->n, int);\n      spx_store_basis(csa->lp, P, map, daeh);\n      /* compute simplex multipliers for final basic solution found by\n       * the solver */\n#if 0 /* 09/VII-2017 */\n      spx_eval_pi(csa->lp, csa->work);\n#else\n      spx_eval_pi(csa->lp, csa->work.vec);\n#endif\n      /* convert working LP solution to original LP solution and store\n       * it into the problem object */\n#if SCALE_Z\n      for (i = 1; i <= csa->lp->m; i++)\n         csa->work.vec[i] *= csa->fz;\n      for (j = 1; j <= csa->lp->n-csa->lp->m; j++)\n         csa->d[j] *= csa->fz;\n#endif\n#if 0 /* 09/VII-2017 */\n      spx_store_sol(csa->lp, P, SHIFT, map, daeh, csa->beta, csa->work,\n         csa->d);\n#else\n      spx_store_sol(csa->lp, P, parm->shift, map, daeh, csa->beta,\n         csa->work.vec, csa->d);\n#endif\n      tfree(daeh);\n      /* save simplex iteration count */\n      P->it_cnt = csa->it_cnt;\n      /* report auxiliary/structural variable causing unboundedness */\n      P->some = 0;\n      if (csa->p_stat == GLP_FEAS && csa->d_stat == GLP_NOFEAS)\n      {  int k, kk;\n         /* xN[q] = x[k] causes unboundedness */\n         xassert(1 <= csa->q && csa->q <= csa->lp->n - csa->lp->m);\n         k = csa->lp->head[csa->lp->m + csa->q];\n         xassert(1 <= k && k <= csa->lp->n);\n         /* convert to number of original variable */\n         for (kk = 1; kk <= P->m + P->n; kk++)\n         {  if (abs(map[kk]) == k)\n            {  P->some = kk;\n               break;\n            }\n         }\n         xassert(P->some != 0);\n      }\nskip: /* deallocate working objects and arrays */\n      spx_free_lp(csa->lp);\n      tfree(map);\n      tfree(csa->orig_c);\n#if 1 /*PERTURB*/\n      tfree(csa->orig_l);\n      tfree(csa->orig_u);\n#endif\n      if (csa->at != NULL)\n         spx_free_at(csa->lp, csa->at);\n      if (csa->nt != NULL)\n         spx_free_nt(csa->lp, csa->nt);\n      tfree(csa->beta);\n      tfree(csa->d);\n      if (csa->se != NULL)\n         spx_free_se(csa->lp, csa->se);\n      tfree(csa->list);\n#if 0 /* 11/VI-2017 */\n      tfree(csa->tcol);\n      tfree(csa->trow);\n#else\n      fvs_free_vec(&csa->tcol);\n      fvs_free_vec(&csa->trow);\n#endif\n#if 1 /* 23/VI-2017 */\n      if (csa->bp != NULL)\n         tfree(csa->bp);\n#endif\n#if 0 /* 09/VII-2017 */\n      tfree(csa->work);\n#else\n      fvs_free_vec(&csa->work);\n#endif\n      /* return to calling program */\n      return ret;\n}",
      "lines": 255,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxprob.c": {
    "spx_init_lp": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void spx_init_lp(SPXLP *lp, glp_prob *P, int excl)\n{     int i, j, m, n, nnz;\n      m = P->m;\n      xassert(m > 0);\n      n = 0;\n      nnz = P->nnz;\n      xassert(P->valid);\n      /* scan rows of original LP */\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = P->row[i];\n         if (excl && row->stat == GLP_NS)\n         {  /* skip non-basic fixed auxiliary variable */\n            /* nop */\n         }\n         else\n         {  /* include auxiliary variable in working LP */\n            n++;\n            nnz++; /* unity column */\n         }\n      }\n      /* scan columns of original LP */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if (excl && col->stat == GLP_NS)\n         {  /* skip non-basic fixed structural variable */\n            GLPAIJ *aij;\n            for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n               nnz--;\n         }\n         else\n         {  /* include structural variable in working LP */\n            n++;\n         }\n      }\n      /* initialize working LP data block */\n      memset(lp, 0, sizeof(SPXLP));\n      lp->m = m;\n      xassert(n > 0);\n      lp->n = n;\n      lp->nnz = nnz;\n      return;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spx_alloc_lp": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void spx_alloc_lp(SPXLP *lp)\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      lp->A_ptr = talloc(1+n+1, int);\n      lp->A_ind = talloc(1+nnz, int);\n      lp->A_val = talloc(1+nnz, double);\n      lp->b = talloc(1+m, double);\n      lp->c = talloc(1+n, double);\n      lp->l = talloc(1+n, double);\n      lp->u = talloc(1+n, double);\n      lp->head = talloc(1+n, int);\n      lp->flag = talloc(1+n-m, char);\n      return;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spx_build_lp": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "void spx_build_lp(SPXLP *lp, glp_prob *P, int excl, int shift,\n      int map[/*1+P->m+P->n*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int nnz = lp->nnz;\n      int *A_ptr = lp->A_ptr;\n      int *A_ind = lp->A_ind;\n      double *A_val = lp->A_val;\n      double *b = lp->b;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int i, j, k, kk, ptr, end;\n      double dir, delta;\n      /* working LP is always minimization */\n      switch (P->dir)\n      {  case GLP_MIN:\n            dir = +1.0;\n            break;\n         case GLP_MAX:\n            dir = -1.0;\n            break;\n         default:\n            xassert(P != P);\n      }\n      /* initialize constant term of the objective */\n      c[0] = dir * P->c0;\n      k = 0; /* number of variable in working LP */\n      ptr = 1; /* current available position in A_ind/A_val */\n      /* process rows of original LP */\n      xassert(P->m == m);\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = P->row[i];\n         if (excl && row->stat == GLP_NS)\n         {  /* i-th auxiliary variable is non-basic and fixed */\n            /* substitute its scaled value in working LP */\n            xassert(row->type == GLP_FX);\n            map[i] = 0;\n            b[i] = - row->lb * row->rii;\n         }\n         else\n         {  /* include i-th auxiliary variable in working LP */\n            map[i] = ++k;\n            /* setup k-th column of working constraint matrix which is\n             * i-th column of unity matrix */\n            A_ptr[k] = ptr;\n            A_ind[ptr] = i;\n            A_val[ptr] = 1.0;\n            ptr++;\n            /* initialize right-hand side of i-th equality constraint\n             * and setup zero objective coefficient at variable x[k] */\n            b[i] = c[k] = 0.0;\n            /* setup scaled bounds of variable x[k] */\n            switch (row->type)\n            {  case GLP_FR:\n                  l[k] = -DBL_MAX, u[k] = +DBL_MAX;\n                  break;\n               case GLP_LO:\n                  l[k] = row->lb * row->rii, u[k] = +DBL_MAX;\n                  break;\n               case GLP_UP:\n                  l[k] = -DBL_MAX, u[k] = row->ub * row->rii;\n                  break;\n               case GLP_DB:\n                  l[k] = row->lb * row->rii, u[k] = row->ub * row->rii;\n                  xassert(l[k] != u[k]);\n                  break;\n               case GLP_FX:\n                  l[k] = u[k] = row->lb * row->rii;\n                  break;\n               default:\n                  xassert(row != row);\n            }\n         }\n      }\n      /* process columns of original LP */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         GLPAIJ *aij;\n         if (excl && col->stat == GLP_NS)\n         {  /* j-th structural variable is non-basic and fixed */\n            /* substitute its scaled value in working LP */\n            xassert(col->type == GLP_FX);\n            map[m+j] = 0;\n            if (col->lb != 0.0)\n            {  /* (note that sjj scale factor is cancelled) */\n               for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n                  b[aij->row->i] +=\n                     (aij->row->rii * aij->val) * col->lb;\n               c[0] += (dir * col->coef) * col->lb;\n            }\n         }\n         else\n         {  /* include j-th structural variable in working LP */\n            map[m+j] = ++k;\n            /* setup k-th column of working constraint matrix which is\n             * scaled j-th column of original constraint matrix (-A) */\n            A_ptr[k] = ptr;\n            for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n            {  A_ind[ptr] = aij->row->i;\n               A_val[ptr] = - aij->row->rii * aij->val * col->sjj;\n               ptr++;\n            }\n            /* setup scaled objective coefficient at variable x[k] */\n            c[k] = dir * col->coef * col->sjj;\n            /* setup scaled bounds of variable x[k] */\n            switch (col->type)\n            {  case GLP_FR:\n                  l[k] = -DBL_MAX, u[k] = +DBL_MAX;\n                  break;\n               case GLP_LO:\n                  l[k] = col->lb / col->sjj, u[k] = +DBL_MAX;\n                  break;\n               case GLP_UP:\n                  l[k] = -DBL_MAX, u[k] = col->ub / col->sjj;\n                  break;\n               case GLP_DB:\n                  l[k] = col->lb / col->sjj, u[k] = col->ub / col->sjj;\n                  xassert(l[k] != u[k]);\n                  break;\n               case GLP_FX:\n                  l[k] = u[k] = col->lb / col->sjj;\n                  break;\n               default:\n                  xassert(col != col);\n            }\n         }\n      }\n      xassert(k == n);\n      xassert(ptr == nnz+1);\n      A_ptr[n+1] = ptr;\n      /* shift bounds of all variables of working LP (optionally) */\n      if (shift)\n      {  for (kk = 1; kk <= m+P->n; kk++)\n         {  k = map[kk];\n            if (k == 0)\n            {  /* corresponding original variable was excluded */\n               continue;\n            }\n            /* shift bounds of variable x[k] */\n            if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)\n            {  /* x[k] is unbounded variable */\n               delta = 0.0;\n            }\n            else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)\n            {  /* shift lower bound to zero */\n               delta = l[k];\n               l[k] = 0.0;\n            }\n            else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)\n            {  /* shift upper bound to zero */\n               map[kk] = -k;\n               delta = u[k];\n               u[k] = 0.0;\n            }\n            else if (l[k] != u[k])\n            {  /* x[k] is double bounded variable */\n               if (fabs(l[k]) <= fabs(u[k]))\n               {  /* shift lower bound to zero */\n                  delta = l[k];\n                  l[k] = 0.0, u[k] -= delta;\n               }\n               else\n               {  /* shift upper bound to zero */\n                  map[kk] = -k;\n                  delta = u[k];\n                  l[k] -= delta, u[k] = 0.0;\n               }\n               xassert(l[k] != u[k]);\n            }\n            else\n            {  /* shift fixed value to zero */\n               delta = l[k];\n               l[k] = u[k] = 0.0;\n            }\n            /* substitute x[k] = x'[k] + delta into all constraints\n             * and the objective function of working LP */\n            if (delta != 0.0)\n            {  ptr = A_ptr[k];\n               end = A_ptr[k+1];\n               for (; ptr < end; ptr++)\n                  b[A_ind[ptr]] -= A_val[ptr] * delta;\n               c[0] += c[k] * delta;\n            }\n         }\n      }\n      return;\n}",
      "lines": 188,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "spx_build_basis": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "void spx_build_basis(SPXLP *lp, glp_prob *P, const int map[])\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int i, j, k, ii, jj;\n      /* original basis factorization should be valid that guarantees\n       * the basis is correct */\n      xassert(P->m == m);\n      xassert(P->valid);\n      /* initialize basis header for working LP */\n      memset(&head[1], 0, m * sizeof(int));\n      jj = 0;\n      /* scan rows of original LP */\n      xassert(P->m == m);\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = P->row[i];\n         /* determine ordinal number of x[k] in working LP */\n         if ((k = map[i]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* corresponding original variable was excluded */\n            continue;\n         }\n         xassert(1 <= k && k <= n);\n         if (row->stat == GLP_BS)\n         {  /* x[k] is basic variable xB[ii] */\n            ii = row->bind;\n            xassert(1 <= ii && ii <= m);\n            xassert(head[ii] == 0);\n            head[ii] = k;\n         }\n         else\n         {  /* x[k] is non-basic variable xN[jj] */\n            jj++;\n            head[m+jj] = k;\n            flag[jj] = (row->stat == GLP_NU);\n         }\n      }\n      /* scan columns of original LP */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         /* determine ordinal number of x[k] in working LP */\n         if ((k = map[m+j]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* corresponding original variable was excluded */\n            continue;\n         }\n         xassert(1 <= k && k <= n);\n         if (col->stat == GLP_BS)\n         {  /* x[k] is basic variable xB[ii] */\n            ii = col->bind;\n            xassert(1 <= ii && ii <= m);\n            xassert(head[ii] == 0);\n            head[ii] = k;\n         }\n         else\n         {  /* x[k] is non-basic variable xN[jj] */\n            jj++;\n            head[m+jj] = k;\n            flag[jj] = (col->stat == GLP_NU);\n         }\n      }\n      xassert(m+jj == n);\n      /* acquire basis factorization */\n      lp->valid = 1;\n      lp->bfd = P->bfd;\n      P->valid = 0;\n      P->bfd = NULL;\n      return;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "spx_store_basis": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        533,
        1
      ],
      "content": "void spx_store_basis(SPXLP *lp, glp_prob *P, const int map[],\n      int daeh[/*1+n*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int i, j, k, kk;\n      /* determine inverse of working basis header */\n      for (kk = 1; kk <= n; kk++)\n         daeh[head[kk]] = kk;\n      /* set row statuses */\n      xassert(P->m == m);\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = P->row[i];\n         if ((k = map[i]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* non-basic fixed auxiliary variable was excluded */\n            xassert(row->type == GLP_FX);\n            row->stat = GLP_NS;\n            row->bind = 0;\n         }\n         else\n         {  /* auxiliary variable corresponds to variable x[k] */\n            kk = daeh[k];\n            if (kk <= m)\n            {  /* x[k] = xB[kk] */\n               P->head[kk] = i;\n               row->stat = GLP_BS;\n               row->bind = kk;\n            }\n            else\n            {  /* x[k] = xN[kk-m] */\n               switch (row->type)\n               {  case GLP_FR:\n                     row->stat = GLP_NF;\n                     break;\n                  case GLP_LO:\n                     row->stat = GLP_NL;\n                     break;\n                  case GLP_UP:\n                     row->stat = GLP_NU;\n                     break;\n                  case GLP_DB:\n                     row->stat = (flag[kk-m] ? GLP_NU : GLP_NL);\n                     break;\n                  case GLP_FX:\n                     row->stat = GLP_NS;\n                     break;\n                  default:\n                     xassert(row != row);\n               }\n               row->bind = 0;\n            }\n         }\n      }\n      /* set column statuses */\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if ((k = map[m+j]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* non-basic fixed structural variable was excluded */\n            xassert(col->type == GLP_FX);\n            col->stat = GLP_NS;\n            col->bind = 0;\n         }\n         else\n         {  /* structural variable corresponds to variable x[k] */\n            kk = daeh[k];\n            if (kk <= m)\n            {  /* x[k] = xB[kk] */\n               P->head[kk] = m+j;\n               col->stat = GLP_BS;\n               col->bind = kk;\n            }\n            else\n            {  /* x[k] = xN[kk-m] */\n               switch (col->type)\n               {  case GLP_FR:\n                     col->stat = GLP_NF;\n                     break;\n                  case GLP_LO:\n                     col->stat = GLP_NL;\n                     break;\n                  case GLP_UP:\n                     col->stat = GLP_NU;\n                     break;\n                  case GLP_DB:\n                     col->stat = (flag[kk-m] ? GLP_NU : GLP_NL);\n                     break;\n                  case GLP_FX:\n                     col->stat = GLP_NS;\n                     break;\n                  default:\n                     xassert(col != col);\n               }\n               col->bind = 0;\n            }\n         }\n      }\n      return;\n}",
      "lines": 103,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "spx_store_sol": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "void spx_store_sol(SPXLP *lp, glp_prob *P, int shift,\n      const int map[], const int daeh[], const double beta[],\n      const double pi[], const double d[])\n{     int m = lp->m;\n      char *flag = lp->flag;\n      int i, j, k, kk;\n      double dir;\n      /* working LP is always minimization */\n      switch (P->dir)\n      {  case GLP_MIN:\n            dir = +1.0;\n            break;\n         case GLP_MAX:\n            dir = -1.0;\n            break;\n         default:\n            xassert(P != P);\n      }\n      /* compute row solution components */\n      xassert(P->m == m);\n      for (i = 1; i <= m; i++)\n      {  GLPROW *row = P->row[i];\n         if ((k = map[i]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* non-basic fixed auxiliary variable was excluded */\n            xassert(row->type == GLP_FX);\n            row->prim = row->lb;\n            /* compute reduced cost d[k] = c[k] - A'[k] * pi as if x[k]\n             * would be non-basic in working LP */\n            row->dual = - dir * pi[i] * row->rii;\n         }\n         else\n         {  /* auxiliary variable corresponds to variable x[k] */\n            kk = daeh[k];\n            if (kk <= m)\n            {  /* x[k] = xB[kk] */\n               row->prim = beta[kk] / row->rii;\n               if (shift)\n                  row->prim += (map[i] < 0 ? row->ub : row->lb);\n               row->dual = 0.0;\n            }\n            else\n            {  /* x[k] = xN[kk-m] */\n               row->prim = (flag[kk-m] ? row->ub : row->lb);\n               row->dual = (dir * d[kk-m]) * row->rii;\n            }\n         }\n      }\n      /* compute column solution components and objective value */\n      P->obj_val = P->c0;\n      for (j = 1; j <= P->n; j++)\n      {  GLPCOL *col = P->col[j];\n         if ((k = map[m+j]) < 0)\n            k = -k;\n         if (k == 0)\n         {  /* non-basic fixed structural variable was excluded */\n            GLPAIJ *aij;\n            double dk;\n            xassert(col->type == GLP_FX);\n            col->prim = col->lb;\n            /* compute reduced cost d[k] = c[k] - A'[k] * pi as if x[k]\n             * would be non-basic in working LP */\n            /* (note that sjj scale factor is cancelled) */\n            dk = dir * col->coef;\n            for (aij = col->ptr; aij != NULL; aij = aij->c_next)\n               dk += (aij->row->rii * aij->val) * pi[aij->row->i];\n            col->dual = dir * dk;\n         }\n         else\n         {  /* structural variable corresponds to variable x[k] */\n            kk = daeh[k];\n            if (kk <= m)\n            {  /* x[k] = xB[kk] */\n               col->prim = beta[kk] * col->sjj;\n               if (shift)\n                  col->prim += (map[m+j] < 0 ? col->ub : col->lb);\n               col->dual = 0.0;\n            }\n            else\n            {  /* x[k] = xN[kk-m] */\n               col->prim = (flag[kk-m] ? col->ub : col->lb);\n               col->dual = (dir * d[kk-m]) / col->sjj;\n            }\n         }\n         P->obj_val += col->coef * col->prim;\n      }\n      return;\n}",
      "lines": 89,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "spx_free_lp": {
      "start_point": [
        665,
        0
      ],
      "end_point": [
        676,
        1
      ],
      "content": "void spx_free_lp(SPXLP *lp)\n{     tfree(lp->A_ptr);\n      tfree(lp->A_ind);\n      tfree(lp->A_val);\n      tfree(lp->b);\n      tfree(lp->c);\n      tfree(lp->l);\n      tfree(lp->u);\n      tfree(lp->head);\n      tfree(lp->flag);\n      return;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spxprob.h": {},
  "glpk/glpk-4.65/src/simplex/spychuzc.c": {
    "spy_chuzc_std": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "int spy_chuzc_std(SPXLP *lp, const double d[/*1+n-m*/],\n#if 0 /* 14/III-2016 */\n      double s, const double trow[/*1+n-m*/], double tol_piv,\n#else\n      double r, const double trow[/*1+n-m*/], double tol_piv,\n#endif\n      double tol, double tol1)\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k, q;\n      double alfa, biga, delta, teta, teta_min;\n#if 0 /* 14/III-2016 */\n      xassert(s == +1.0 || s == -1.0);\n#else\n      double s;\n      xassert(r != 0.0);\n      s = (r > 0.0 ? +1.0 : -1.0);\n#endif\n      /* nothing is chosen so far */\n      q = 0, teta_min = DBL_MAX, biga = 0.0;\n      /* walk thru the list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* if xN[j] is fixed variable, skip it */\n         if (l[k] == u[k])\n            continue;\n         alfa = s * trow[j];\n         if (alfa >= +tol_piv && !flag[j])\n         {  /* xN[j] is either free or has its lower bound active, so\n             * lambdaN[j] = d[j] >= 0 decreases down to zero */\n            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);\n            /* determine theta on which lambdaN[j] reaches zero */\n            teta = (d[j] < +delta ? 0.0 : d[j] / alfa);\n         }\n         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))\n         {  /* xN[j] is either free or has its upper bound active, so\n             * lambdaN[j] = d[j] <= 0 increases up to zero */\n            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);\n            /* determine theta on which lambdaN[j] reaches zero */\n            teta = (d[j] > -delta ? 0.0 : d[j] / alfa);\n         }\n         else\n         {  /* lambdaN[j] cannot reach zero on increasing theta */\n            continue;\n         }\n         /* choose non-basic variable xN[q] by corresponding dual basic\n          * variable lambdaN[q] for which theta is minimal */\n         xassert(teta >= 0.0);\n         alfa = (alfa >= 0.0 ? +alfa : -alfa);\n         if (teta_min > teta || (teta_min == teta && biga < alfa))\n            q = j, teta_min = teta, biga = alfa;\n      }\n      return q;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "spy_chuzc_harris": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int spy_chuzc_harris(SPXLP *lp, const double d[/*1+n-m*/],\n#if 0 /* 14/III-2016 */\n      double s, const double trow[/*1+n-m*/], double tol_piv,\n#else\n      double r, const double trow[/*1+n-m*/], double tol_piv,\n#endif\n      double tol, double tol1)\n{     int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k, q;\n      double alfa, biga, delta, teta, teta_min;\n#if 0 /* 14/III-2016 */\n      xassert(s == +1.0 || s == -1.0);\n#else\n      double s;\n      xassert(r != 0.0);\n      s = (r > 0.0 ? +1.0 : -1.0);\n#endif\n      /*--------------------------------------------------------------*/\n      /* first pass: determine teta_min for relaxed bounds            */\n      /*--------------------------------------------------------------*/\n      teta_min = DBL_MAX;\n      /* walk thru the list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* if xN[j] is fixed variable, skip it */\n         if (l[k] == u[k])\n            continue;\n         alfa = s * trow[j];\n         if (alfa >= +tol_piv && !flag[j])\n         {  /* xN[j] is either free or has its lower bound active, so\n             * lambdaN[j] = d[j] >= 0 decreases down to zero */\n            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);\n            /* determine theta on which lambdaN[j] reaches -delta */\n            teta = ((d[j] < 0.0 ? 0.0 : d[j]) + delta) / alfa;\n         }\n         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))\n         {  /* xN[j] is either free or has its upper bound active, so\n             * lambdaN[j] = d[j] <= 0 increases up to zero */\n            delta = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);\n            /* determine theta on which lambdaN[j] reaches +delta */\n            teta = ((d[j] > 0.0 ? 0.0 : d[j]) - delta) / alfa;\n         }\n         else\n         {  /* lambdaN[j] cannot reach zero on increasing theta */\n            continue;\n         }\n         xassert(teta >= 0.0);\n         if (teta_min > teta)\n            teta_min = teta;\n      }\n      /*--------------------------------------------------------------*/\n      /* second pass: choose non-basic variable xN[q]                 */\n      /*--------------------------------------------------------------*/\n      if (teta_min == DBL_MAX)\n      {  /* theta may increase unlimitedly */\n         q = 0;\n         goto done;\n      }\n      /* nothing is chosen so far */\n      q = 0, biga = 0.0;\n      /* walk thru the list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* if xN[j] is fixed variable, skip it */\n         if (l[k] == u[k])\n            continue;\n         alfa = s * trow[j];\n         if (alfa >= +tol_piv && !flag[j])\n         {  /* xN[j] is either free or has its lower bound active, so\n             * lambdaN[j] = d[j] >= 0 decreases down to zero */\n            /* determine theta on which lambdaN[j] reaches zero */\n            teta = d[j] / alfa;\n         }\n         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))\n         {  /* xN[j] is either free or has its upper bound active, so\n             * lambdaN[j] = d[j] <= 0 increases up to zero */\n            /* determine theta on which lambdaN[j] reaches zero */\n            teta = d[j] / alfa;\n         }\n         else\n         {  /* lambdaN[j] cannot reach zero on increasing theta */\n            continue;\n         }\n         /* choose non-basic variable for which theta is not greater\n          * than theta_min determined for relaxed bounds and which has\n          * best (largest in magnitude) pivot */\n         alfa = (alfa >= 0.0 ? +alfa : -alfa);\n         if (teta <= teta_min && biga < alfa)\n            q = j, biga = alfa;\n      }\n      /* something must be chosen */\n      xassert(1 <= q && q <= n-m);\ndone: return q;\n}",
      "lines": 100,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "fcmp": [
      {
        "start_point": [
          277,
          0
        ],
        "end_point": [
          285,
          1
        ],
        "content": "static int CDECL fcmp(const void *v1, const void *v2)\n{     const SPYBP *p1 = v1, *p2 = v2;\n      if (p1->teta < p2->teta)\n         return -1;\n      else if (p1->teta > p2->teta)\n         return +1;\n      else\n         return 0;\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "int",
          "CDECL",
          "CDECL"
        ]
      },
      {
        "start_point": [
          499,
          0
        ],
        "end_point": [
          507,
          1
        ],
        "content": "static int CDECL fcmp(const void *v1, const void *v2)\n{     const SPYBP *p1 = v1, *p2 = v2;\n      if (p1->teta < p2->teta)\n         return -1;\n      else if (p1->teta > p2->teta)\n         return +1;\n      else\n         return 0;\n}",
        "lines": 9,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "int",
          "CDECL",
          "CDECL"
        ]
      }
    ],
    "spy_eval_bp": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "int spy_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],\n      double r, const double trow[/*1+n-m*/], double tol_piv,\n      SPYBP bp[/*1+n-m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, j_max, k, t, nnn, num;\n      double s, alfa, teta, teta_max, dz, v;\n      xassert(r != 0.0);\n      s = (r > 0.0 ? +1.0 : -1.0);\n      /* build the list of all dual basic variables lambdaN[j] that\n       * can reach zero on increasing the ray parameter teta >= 0 */\n      num = 0;\n      /* walk thru the list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* if xN[j] is fixed variable, skip it */\n         if (l[k] == u[k])\n            continue;\n         alfa = s * trow[j];\n         if (alfa >= +tol_piv && !flag[j])\n         {  /* xN[j] is either free or has its lower bound active, so\n             * lambdaN[j] = d[j] >= 0 decreases down to zero */\n            /* determine teta[j] on which lambdaN[j] reaches zero */\n            teta = (d[j] < 0.0 ? 0.0 : d[j] / alfa);\n         }\n         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))\n         {  /* xN[j] is either free or has its upper bound active, so\n             * lambdaN[j] = d[j] <= 0 increases up to zero */\n            /* determine teta[j] on which lambdaN[j] reaches zero */\n            teta = (d[j] > 0.0 ? 0.0 : d[j] / alfa);\n         }\n         else\n         {  /* lambdaN[j] cannot reach zero on increasing teta */\n            continue;\n         }\n         /* add lambdaN[j] to the list */\n         num++;\n         bp[num].j = j;\n         bp[num].teta = teta;\n      }\n      if (num == 0)\n      {  /* dual unboundedness */\n         goto done;\n      }\n      /* determine \"blocking\" dual basic variable lambdaN[j_max] that\n       * prevents increasing teta more than teta_max */\n      j_max = 0, teta_max = DBL_MAX;\n      for (t = 1; t <= num; t++)\n      {  j = bp[t].j;\n         k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)\n         {  /* lambdaN[j] cannot intersect zero */\n            if (j_max == 0\n               || teta_max > bp[t].teta\n               || (teta_max == bp[t].teta\n                  && fabs(trow[j_max]) < fabs(trow[j])))\n               j_max = j, teta_max = bp[t].teta;\n         }\n      }\n      /* keep in the list only dual basic variables lambdaN[j] that\n       * correspond to primal double-bounded variables xN[j] and whose\n       * teta[j] is not greater than teta_max */\n      nnn = 0;\n      for (t = 1; t <= num; t++)\n      {  j = bp[t].j;\n         k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] != -DBL_MAX && u[k] != +DBL_MAX\n            && bp[t].teta <= teta_max)\n         {  nnn++;\n            bp[nnn].j = j;\n            bp[nnn].teta = bp[t].teta;\n         }\n      }\n      num = nnn;\n      /* sort break-points by ascending teta[j] */\n      qsort(&bp[1], num, sizeof(SPYBP), fcmp);\n      /* add lambdaN[j_max] to the end of the list */\n      if (j_max != 0)\n      {  xassert(num < n-m);\n         num++;\n         bp[num].j = j_max;\n         bp[num].teta = teta_max;\n      }\n      /* compute increments of the dual objective at all break-points\n       * (relative to its value at teta = 0) */\n      dz = 0.0;      /* dual objective increment */\n      v = fabs(r);   /* dual objective slope d zeta / d teta */\n      for (t = 1; t <= num; t++)\n      {  /* compute increment at current break-point */\n         dz += v * (bp[t].teta - (t == 1 ? 0.0 : bp[t-1].teta));\n         if (dz < 0.001)\n         {  /* break-point with non-positive increment reached */\n            num = t - 1;\n            break;\n         }\n         bp[t].dz = dz;\n         /* compute next slope on the right to current break-point */\n         if (t < num)\n         {  j = bp[t].j;\n            k = head[m+j]; /* x[k] = xN[j] */\n            xassert(-DBL_MAX < l[k] && l[k] < u[k] && u[k] < +DBL_MAX);\n            v -= fabs(trow[j]) * (u[k] - l[k]);\n         }\n      }\ndone: return num;\n}",
      "lines": 110,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "spy_ls_eval_bp": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        474,
        1
      ],
      "content": "int spy_ls_eval_bp(SPXLP *lp, const double d[/*1+n-m*/],\n      double r, const double trow[/*1+n-m*/], double tol_piv,\n      SPYBP bp[/*1+n-m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k, t, nnn, nbp;\n      double s, alfa, teta, teta_max;\n      xassert(r != 0.0);\n      s = (r > 0.0 ? +1.0 : -1.0);\n      /* build the list of all dual basic variables lambdaN[j] that\n       * can reach zero on increasing the ray parameter teta >= 0 */\n      nnn = 0, teta_max = DBL_MAX;\n      /* walk thru the list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         /* if xN[j] is fixed variable, skip it */\n         if (l[k] == u[k])\n            continue;\n         alfa = s * trow[j];\n         if (alfa >= +tol_piv && !flag[j])\n         {  /* xN[j] is either free or has its lower bound active, so\n             * lambdaN[j] = d[j] >= 0 decreases down to zero */\n            /* determine teta[j] on which lambdaN[j] reaches zero */\n            teta = (d[j] < 0.0 ? 0.0 : d[j] / alfa);\n            /* if xN[j] has no upper bound, lambdaN[j] cannot become\n             * negative and thereby blocks further increasing teta */\n            if (u[k] == +DBL_MAX && teta_max > teta)\n               teta_max = teta;\n         }\n         else if (alfa <= -tol_piv && (l[k] == -DBL_MAX || flag[j]))\n         {  /* xN[j] is either free or has its upper bound active, so\n             * lambdaN[j] = d[j] <= 0 increases up to zero */\n            /* determine teta[j] on which lambdaN[j] reaches zero */\n            teta = (d[j] > 0.0 ? 0.0 : d[j] / alfa);\n            /* if xN[j] has no lower bound, lambdaN[j] cannot become\n             * positive and thereby blocks further increasing teta */\n            if (l[k] == -DBL_MAX && teta_max > teta)\n               teta_max = teta;\n         }\n         else\n         {  /* lambdaN[j] cannot reach zero on increasing teta */\n            continue;\n         }\n         /* add lambdaN[j] to the list */\n         nnn++;\n         bp[nnn].j = j;\n         bp[nnn].teta = teta;\n      }\n      /* remove from the list all dual basic variables lambdaN[j], for\n       * which teta[j] > teta_max */\n      nbp = 0;\n      for (t = 1; t <= nnn; t++)\n      {  if (bp[t].teta <= teta_max + 1e-6)\n         {  nbp++;\n            bp[nbp].j = bp[t].j;\n            bp[nbp].teta = bp[t].teta;\n         }\n      }\n      return nbp;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "spy_ls_select_bp": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "int spy_ls_select_bp(SPXLP *lp, const double trow[/*1+n-m*/],\n      int nbp, SPYBP bp[/*1+n-m*/], int num, double *slope, double\n      teta_lim)\n{     int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int j, k, t, num1;\n      double teta, dz;\n      xassert(0 <= num && num <= nbp && nbp <= n-m);\n      /* select a new portion of break-points */\n      num1 = num;\n      for (t = num+1; t <= nbp; t++)\n      {  if (bp[t].teta <= teta_lim)\n         {  /* move break-point to the beginning of the new portion */\n            num1++;\n            j = bp[num1].j, teta = bp[num1].teta;\n            bp[num1].j = bp[t].j, bp[num1].teta = bp[t].teta;\n            bp[t].j = j, bp[t].teta = teta;\n         }\n      }\n      /* sort new break-points bp[num+1], ..., bp[num1] by ascending\n       * the ray parameter teta */\n      if (num1 - num > 1)\n         qsort(&bp[num+1], num1 - num, sizeof(SPYBP), fcmp);\n      /* calculate the dual objective change at the new break-points */\n      for (t = num+1; t <= num1; t++)\n      {  /* calculate the dual objective change relative to its value\n          * at break-point bp[t-1] */\n         if (*slope == -DBL_MAX)\n            dz = -DBL_MAX;\n         else\n            dz = (*slope) *\n               (bp[t].teta - (t == 1 ? 0.0 : bp[t-1].teta));\n         /* calculate the dual objective change relative to its value\n          * at teta = 0 */\n         if (dz == -DBL_MAX)\n            bp[t].dz = -DBL_MAX;\n         else\n            bp[t].dz = (t == 1 ? 0.0 : bp[t-1].dz) + dz;\n         /* calculate a new slope of the dual objective to the right of\n          * the current break-point bp[t] */\n         if (*slope != -DBL_MAX)\n         {  j = bp[t].j;\n            k = head[m+j]; /* x[k] = xN[j] */\n            if (l[k] == -DBL_MAX || u[k] == +DBL_MAX)\n               *slope = -DBL_MAX; /* blocking break-point reached */\n            else\n            {  xassert(l[k] < u[k]);\n               *slope -= fabs(trow[j]) * (u[k] - l[k]);\n            }\n         }\n      }\n      return num1;\n}",
      "lines": 56,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spychuzc.h": {},
  "glpk/glpk-4.65/src/simplex/spychuzr.c": {
    "spy_chuzr_sel": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "int spy_chuzr_sel(SPXLP *lp, const double beta[/*1+m*/], double tol,\n      double tol1, int list[/*1+m*/])\n{     int m = lp->m;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, k, num;\n      double lk, uk, eps;\n      num = 0;\n      /* walk thru list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         lk = l[k], uk = u[k];\n         /* check if xB[i] is eligible */\n         if (beta[i] < lk)\n         {  /* determine absolute tolerance eps1[i] */\n            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] < lk - eps)\n            {  /* lower bound is violated */\n               num++;\n               if (list != NULL)\n                  list[num] = i;\n            }\n         }\n         else if (beta[i] > uk)\n         {  /* determine absolute tolerance eps2[i] */\n            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] > uk + eps)\n            {  /* upper bound is violated */\n               num++;\n               if (list != NULL)\n                  list[num] = i;\n            }\n         }\n      }\n      return num;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "spy_chuzr_std": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int spy_chuzr_std(SPXLP *lp, const double beta[/*1+m*/], int num,\n      const int list[])\n{     int m = lp->m;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int i, k, p, t;\n      double abs_ri, abs_rp;\n      xassert(0 < num && num <= m);\n      p = 0, abs_rp = -1.0;\n      for (t = 1; t <= num; t++)\n      {  i = list[t];\n         k = head[i]; /* x[k] = xB[i] */\n         if (beta[i] < l[k])\n            abs_ri = l[k] - beta[i];\n         else if (beta[i] > u[k])\n            abs_ri = beta[i] - u[k];\n         else\n            xassert(t != t);\n         if (abs_rp < abs_ri)\n            p = i, abs_rp = abs_ri;\n      }\n      xassert(p != 0);\n      return p;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "spy_alloc_se": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void spy_alloc_se(SPXLP *lp, SPYSE *se)\n{     int m = lp->m;\n      int n = lp->n;\n#if 1 /* 30/III-2016 */\n      int i;\n#endif\n      se->valid = 0;\n      se->refsp = talloc(1+n, char);\n      se->gamma = talloc(1+m, double);\n      se->work = talloc(1+m, double);\n#if 1 /* 30/III-2016 */\n      se->u.n = m;\n      se->u.nnz = 0;\n      se->u.ind = talloc(1+m, int);\n      se->u.vec = talloc(1+m, double);\n      for (i = 1; i <= m; i++)\n         se->u.vec[i] = 0.0;\n#endif\n      return;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "spy_reset_refsp": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "void spy_reset_refsp(SPXLP *lp, SPYSE *se)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *gamma = se->gamma;\n      int i, k;\n      se->valid = 1;\n      memset(&refsp[1], 0, n * sizeof(char));\n      for (i = 1; i <= m; i++)\n      {  k = head[i]; /* x[k] = xB[i] */\n         refsp[k] = 1;\n         gamma[i] = 1.0;\n      }\n      return;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "spy_eval_gamma_i": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "double spy_eval_gamma_i(SPXLP *lp, SPYSE *se, int i)\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *rho = se->work;\n      int j, k;\n      double gamma_i, t_ij;\n      xassert(se->valid);\n      xassert(1 <= i && i <= m);\n      k = head[i]; /* x[k] = xB[i] */\n      gamma_i = (refsp[k] ? 1.0 : 0.0);\n      spx_eval_rho(lp, i, rho);\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (refsp[k])\n         {  t_ij = spx_eval_tij(lp, rho, j);\n            gamma_i += t_ij * t_ij;\n         }\n      }\n      return gamma_i;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "double"
      ]
    },
    "spy_chuzr_pse": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int spy_chuzr_pse(SPXLP *lp, SPYSE *se, const double beta[/*1+m*/],\n      int num, const int list[])\n{     int m = lp->m;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      double *gamma = se->gamma;\n      int i, k, p, t;\n      double best, ri, temp;\n      xassert(0 < num && num <= m);\n      p = 0, best = -1.0;\n      for (t = 1; t <= num; t++)\n      {  i = list[t];\n         k = head[i]; /* x[k] = xB[i] */\n         if (beta[i] < l[k])\n            ri = l[k] - beta[i];\n         else if (beta[i] > u[k])\n            ri = u[k] - beta[i];\n         else\n            xassert(t != t);\n         /* FIXME */\n         if (gamma[i] < DBL_EPSILON)\n            temp = 0.0;\n         else\n            temp = (ri * ri) / gamma[i];\n         if (best < temp)\n            p = i, best = temp;\n      }\n      xassert(p != 0);\n      return p;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "spy_update_gamma": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        400,
        1
      ],
      "content": "double spy_update_gamma(SPXLP *lp, SPYSE *se, int p, int q,\n      const double trow[/*1+n-m*/], const double tcol[/*1+m*/])\n{     int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *gamma = se->gamma;\n      double *u = se->work;\n      int i, j, k, ptr, end;\n      double gamma_p, delta_p, e, r, t1, t2;\n      xassert(se->valid);\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n-m);\n      /* compute gamma[p] in current basis more accurately; also\n       * compute auxiliary vector u */\n      k = head[p]; /* x[k] = xB[p] */\n      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);\n      for (i = 1; i <= m; i++)\n         u[i] = 0.0;\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (refsp[k] && trow[j] != 0.0)\n         {  gamma_p += trow[j] * trow[j];\n            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint\n             * matrix column corresponding to xN[j] */\n            ptr = lp->A_ptr[k];\n            end = lp->A_ptr[k+1];\n            for (; ptr < end; ptr++)\n               u[lp->A_ind[ptr]] += trow[j] * lp->A_val[ptr];\n         }\n      }\n      bfd_ftran(lp->bfd, u);\n      /* compute relative error in gamma[p] */\n      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);\n      /* compute new gamma[p] */\n      gamma[p] = gamma_p / (tcol[p] * tcol[p]);\n      /* compute new gamma[i] for all i != p */\n      for (i = 1; i <= m; i++)\n      {  if (i == p)\n            continue;\n         /* compute r[i] = T[i,q] / T[p,q] */\n         r = tcol[i] / tcol[p];\n         /* compute new gamma[i] */\n         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);\n         k = head[i]; /* x[k] = xB[i] */\n         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;\n         gamma[i] = (t1 >= t2 ? t1 : t2);\n      }\n      return e;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "spy_update_gamma_s": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        461,
        1
      ],
      "content": "double spy_update_gamma_s(SPXLP *lp, SPYSE *se, int p, int q,\n      const FVS *trow, const FVS *tcol)\n{     /* sparse version of spy_update_gamma */\n      int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *refsp = se->refsp;\n      double *gamma = se->gamma;\n      double *u = se->work;\n      int trow_nnz = trow->nnz;\n      int *trow_ind = trow->ind;\n      double *trow_vec = trow->vec;\n      int tcol_nnz = tcol->nnz;\n      int *tcol_ind = tcol->ind;\n      double *tcol_vec = tcol->vec;\n      int i, j, k, t, ptr, end;\n      double gamma_p, delta_p, e, r, t1, t2;\n      xassert(se->valid);\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n-m);\n      /* compute gamma[p] in current basis more accurately; also\n       * compute auxiliary vector u */\n      k = head[p]; /* x[k] = xB[p] */\n      gamma_p = delta_p = (refsp[k] ? 1.0 : 0.0);\n      for (i = 1; i <= m; i++)\n         u[i] = 0.0;\n      for (t = 1; t <= trow_nnz; t++)\n      {  j = trow_ind[t];\n         k = head[m+j]; /* x[k] = xN[j] */\n         if (refsp[k])\n         {  gamma_p += trow_vec[j] * trow_vec[j];\n            /* u := u + T[p,j] * N[j], where N[j] = A[k] is constraint\n             * matrix column corresponding to xN[j] */\n            ptr = lp->A_ptr[k];\n            end = lp->A_ptr[k+1];\n            for (; ptr < end; ptr++)\n               u[lp->A_ind[ptr]] += trow_vec[j] * lp->A_val[ptr];\n         }\n      }\n      bfd_ftran(lp->bfd, u);\n      /* compute relative error in gamma[p] */\n      e = fabs(gamma_p - gamma[p]) / (1.0 + gamma_p);\n      /* compute new gamma[p] */\n      gamma[p] = gamma_p / (tcol_vec[p] * tcol_vec[p]);\n      /* compute new gamma[i] for all i != p */\n      for (t = 1; t <= tcol_nnz; t++)\n      {  i = tcol_ind[t];\n         if (i == p)\n            continue;\n         /* compute r[i] = T[i,q] / T[p,q] */\n         r = tcol_vec[i] / tcol_vec[p];\n         /* compute new gamma[i] */\n         t1 = gamma[i] + r * (r * gamma_p + u[i] + u[i]);\n         k = head[i]; /* x[k] = xB[i] */\n         t2 = (refsp[k] ? 1.0 : 0.0) + delta_p * r * r;\n         gamma[i] = (t1 >= t2 ? t1 : t2);\n      }\n      return e;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "double"
      ]
    },
    "spy_free_se": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        480,
        1
      ],
      "content": "void spy_free_se(SPXLP *lp, SPYSE *se)\n{     xassert(lp == lp);\n      tfree(se->refsp);\n      tfree(se->gamma);\n      tfree(se->work);\n#if 1 /* 30/III-2016 */\n      tfree(se->u.ind);\n      tfree(se->u.vec);\n#endif\n      return;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/simplex/spychuzr.h": {},
  "glpk/glpk-4.65/src/simplex/spydual.c": {
    "check_flags": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static void check_flags(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      int j, k;\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)\n            xassert(!flag[j]);\n         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)\n            xassert(!flag[j]);\n         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)\n            xassert(flag[j]);\n         else if (l[k] == u[k])\n            xassert(!flag[j]);\n      }\n      return;\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_art_bounds": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static void set_art_bounds(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *b = lp->b;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *d = csa->d;\n      int i, j, k;\n#if 1 /* 31/III-2016: FIXME */\n      /* set artificial right-hand sides */\n      for (i = 1; i <= m; i++)\n         b[i] = 0.0;\n      /* set artificial bounds depending on types of variables */\n      for (k = 1; k <= n; k++)\n      {  if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] == +DBL_MAX)\n         {  /* force free variables to enter the basis */\n            l[k] = -1e3, u[k] = +1e3;\n         }\n      else if (csa->orig_l[k] != -DBL_MAX && csa->orig_u[k] == +DBL_MAX)\n            l[k] = 0.0, u[k] = +1.0;\n      else if (csa->orig_l[k] == -DBL_MAX && csa->orig_u[k] != +DBL_MAX)\n            l[k] = -1.0, u[k] = 0.0;\n         else\n            l[k] = u[k] = 0.0;\n      }\n#endif\n      /* set active artificial bounds for non-basic variables */\n      xassert(csa->d_st == 1);\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         flag[j] = (l[k] != u[k] && d[j] < 0.0);\n      }\n      /* invalidate values of basic variables, since active bounds of\n       * non-basic variables have been changed */\n      csa->beta_st = 0;\n      return;\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_orig_bounds": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "static void set_orig_bounds(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *b = lp->b;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *d = csa->d;\n      int j, k;\n      /* restore original right-hand sides */\n      memcpy(b, csa->orig_b, (1+m) * sizeof(double));\n      /* restore original bounds of all variables */\n      memcpy(l, csa->orig_l, (1+n) * sizeof(double));\n      memcpy(u, csa->orig_u, (1+n) * sizeof(double));\n      /* set active original bounds for non-basic variables */\n      xassert(csa->d_st == 1);\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)\n            flag[j] = 0;\n         else if (l[k] != -DBL_MAX && u[k] == +DBL_MAX)\n            flag[j] = 0;\n         else if (l[k] == -DBL_MAX && u[k] != +DBL_MAX)\n            flag[j] = 1;\n         else if (l[k] != u[k])\n            flag[j] = (d[j] < 0.0);\n         else\n            flag[j] = 0;\n      }\n      /* invalidate values of basic variables, since active bounds of\n       * non-basic variables have been changed */\n      csa->beta_st = 0;\n      return;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_feas": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "static int check_feas(struct csa *csa, double tol, double tol1,\n      int recov)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *d = csa->d;\n      int j, k, ret = 0;\n      double eps;\n      /* reduced costs should be just computed */\n      xassert(csa->d_st == 1);\n      /* walk thru list of non-basic variables */\n      for (j = 1; j <= n-m; j++)\n      {  k = head[m+j]; /* x[k] = xN[j] */\n         if (l[k] == u[k])\n         {  /* xN[j] is fixed variable; skip it */\n            continue;\n         }\n         /* determine absolute tolerance eps[j] */\n         eps = tol + tol1 * (c[k] >= 0.0 ? +c[k] : -c[k]);\n         /* check dual feasibility of xN[j] */\n         if (d[j] > +eps)\n         {  /* xN[j] should have its lower bound active */\n            if (l[k] == -DBL_MAX || flag[j])\n            {  /* but it either has no lower bound or its lower bound\n                * is inactive */\n               if (l[k] == -DBL_MAX)\n               {  /* cannot recover, since xN[j] has no lower bound */\n                  ret = j;\n                  break;\n               }\n               /* recovering is possible */\n               if (recov)\n                  flag[j] = 0;\n               ret = -1;\n            }\n         }\n         else if (d[j] < -eps)\n         {  /* xN[j] should have its upper bound active */\n            if (!flag[j])\n            {  /* but it either has no upper bound or its upper bound\n                * is inactive */\n               if (u[k] == +DBL_MAX)\n               {  /* cannot recover, since xN[j] has no upper bound */\n                  ret = j;\n                  break;\n               }\n               /* recovering is possible */\n               if (recov)\n                  flag[j] = 1;\n               ret = -1;\n            }\n         }\n      }\n      if (recov && ret)\n      {  /* invalidate values of basic variables, since active bounds\n          * of non-basic variables have been changed */\n         csa->beta_st = 0;\n      }\n      return ret;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "err_in_vec": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        452,
        1
      ],
      "content": "static double err_in_vec(int n, const double x[], const double y[])\n{     int i;\n      double err, err_max;\n      err_max = 0.0;\n      for (i = 1; i <= n; i++)\n      {  err = fabs(x[i] - y[i]) / (1.0 + fabs(x[i]));\n         if (err_max < err)\n            err_max = err;\n      }\n      return err_max;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_beta": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        473,
        1
      ],
      "content": "static double err_in_beta(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      double err, *beta;\n      beta = talloc(1+m, double);\n      spx_eval_beta(lp, beta);\n      err = err_in_vec(m, beta, csa->beta);\n      tfree(beta);\n      return err;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_r": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "static double err_in_r(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int i, k;\n      double err, *r;\n      r = talloc(1+m, double);\n      for (i = 1; i <= m; i++)\n      {  k = lp->head[i];\n         if (csa->beta[i] < lp->l[k])\n            r[i] = lp->l[k] - csa->beta[i];\n         else if (csa->beta[i] > lp->u[k])\n            r[i] = lp->u[k] - csa->beta[i];\n         else\n            r[i] = 0.0;\n\nif (fabs(r[i] - csa->r.vec[i]) > 1e-6)\nprintf(\"i = %d; r = %g; csa->r = %g\\n\", i, r[i], csa->r.vec[i]);\n\n\n      }\n      err = err_in_vec(m, r, csa->r.vec);\n      tfree(r);\n      return err;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_d": {
      "start_point": [
        512,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "static double err_in_d(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      int j;\n      double err, *pi, *d;\n      pi = talloc(1+m, double);\n      d = talloc(1+n-m, double);\n      spx_eval_pi(lp, pi);\n      for (j = 1; j <= n-m; j++)\n         d[j] = spx_eval_dj(lp, pi, j);\n      err = err_in_vec(n-m, d, csa->d);\n      tfree(pi);\n      tfree(d);\n      return err;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "err_in_gamma": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        553,
        1
      ],
      "content": "static double err_in_gamma(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      SPYSE *se = csa->se;\n      int i;\n      double err, *gamma;\n      xassert(se != NULL);\ngamma = talloc(1+m, double);\n      for (i = 1; i <= m; i++)\n         gamma[i] = spy_eval_gamma_i(lp, se, i);\n      err = err_in_vec(m, gamma, se->gamma);\n      tfree(gamma);\n      return err;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "check_accuracy": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "static void check_accuracy(struct csa *csa)\n{     double e_beta, e_r, e_d, e_gamma;\n      e_beta = err_in_beta(csa);\n      e_r = err_in_r(csa);\n      e_d = err_in_d(csa);\n      if (csa->se == NULL)\n         e_gamma = 0.;\n      else\n         e_gamma = err_in_gamma(csa);\n      xprintf(\"e_beta = %10.3e; e_r = %10.3e; e_d = %10.3e; e_gamma = %\"\n         \"10.3e\\n\", e_beta, e_r, e_d, e_gamma);\n      xassert(e_beta <= 1e-5 && e_d <= 1e-5 && e_gamma <= 1e-3);\n      return;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spy_eval_r": {
      "start_point": [
        581,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static\nvoid spy_eval_r(SPXLP *lp, const double beta[/*1+m*/], double tol,\n      double tol1, FVS *r)\n{     /* this routine computes the vector of primal infeasibilities:\n       *\n       *        ( lB[i] - beta[i] > 0, if beta[i] < lb[i]\n       * r[i] = { 0,                   if lb[i] <= beta[i] <= ub[i]\n       *        ( ub[i] - beta[i] < 0, if beta[i] > ub[i]\n       *\n       * (this routine replaces spy_chuzr_sel) */\n      int m = lp->m;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int *ind = r->ind;\n      double *vec = r->vec;\n      int i, k, nnz = 0;\n      double lk, uk, eps;\n      xassert(r->n == m);\n      /* walk thru the list of basic variables */\n      for (i = 1; i <= m; i++)\n      {  vec[i] = 0.0;\n         k = head[i]; /* x[k] = xB[i] */\n         lk = l[k], uk = u[k];\n         /* check primal feasibility */\n         if (beta[i] < lk)\n         {  /* determine absolute tolerance eps1[i] */\n            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] < lk - eps)\n            {  /* lower bound is violated */\n               ind[++nnz] = i;\n               vec[i] = lk - beta[i];\n            }\n         }\n         else if (beta[i] > uk)\n         {  /* determine absolute tolerance eps2[i] */\n            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] > uk + eps)\n            {  /* upper bound is violated */\n               ind[++nnz] = i;\n               vec[i] = uk - beta[i];\n            }\n         }\n      }\n      r->nnz = nnz;\n      return;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "choose_pivot": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        884,
        1
      ],
      "content": "static int choose_pivot(struct csa *csa)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      SPXAT *at = csa->at;\n      SPXNT *nt = csa->nt;\n      double *beta = csa->beta;\n      double *d = csa->d;\n      SPYSE *se = csa->se;\n#if 0 /* 30/III-2016 */\n      int *list = csa->list;\n#else\n      int *list = csa->r.ind;\n#endif\n      double *rho = csa->work;\n      double *trow = csa->work1;\n      SPYBP *bp = csa->bp;\n      double tol_piv = csa->tol_piv;\n      int try, nnn, j, k, p, q, t, t_best, nbp, ret;\n      double big, temp, r, best_ratio, dz_best;\n      xassert(csa->beta_st);\n      xassert(csa->d_st);\nmore: /* initial number of eligible basic variables */\n#if 0 /* 30/III-2016 */\n      nnn = csa->num;\n#else\n      nnn = csa->r.nnz;\n#endif\n      /* nothing has been chosen so far */\n      csa->p = 0;\n      best_ratio = 0.0;\n      try = ret = 0;\ntry:  /* choose basic variable xB[p] */\n      xassert(nnn > 0);\n      try++;\n      if (se == NULL)\n      {  /* dual Dantzig's rule */\n         p = spy_chuzr_std(lp, beta, nnn, list);\n      }\n      else\n      {  /* dual projected steepest edge */\n         p = spy_chuzr_pse(lp, se, beta, nnn, list);\n      }\n      xassert(1 <= p && p <= m);\n      /* compute p-th row of inv(B) */\n      spx_eval_rho(lp, p, rho);\n      /* compute p-th row of the simplex table */\n      if (at != NULL)\n         spx_eval_trow1(lp, at, rho, trow);\n      else\n         spx_nt_prod(lp, nt, trow, 1, -1.0, rho);\n#if 1 /* 23/III-2016 */\n      /* big := max(1, |trow[1]|, ..., |trow[n-m]|) */\n      big = 1.0;\n      for (j = 1; j <= n-m; j++)\n      {  temp = trow[j];\n         if (temp < 0.0)\n            temp = - temp;\n         if (big < temp)\n            big = temp;\n      }\n#else\n      /* this still puzzles me */\n      big = 1.0;\n#endif\n      /* choose non-basic variable xN[q] */\n      k = head[p]; /* x[k] = xB[p] */\n      xassert(beta[p] < l[k] || beta[p] > u[k]);\n      r = beta[p] < l[k] ? l[k] - beta[p] : u[k] - beta[p];\n      if (csa->r_test == GLP_RT_FLIP && try <= 2)\n      {  /* long-step ratio test */\n#if 0 /* 23/III-2016 */\n         /* determine dual objective break-points */\n         nbp = spy_eval_bp(lp, d, r, trow, tol_piv, bp);\n         if (nbp <= 1)\n            goto skip;\n         /* choose appropriate break-point */\n         t_best = 0, dz_best = -DBL_MAX;\n         for (t = 1; t <= nbp; t++)\n         {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)\n            {  if (dz_best < bp[t].dz)\n                  t_best = t, dz_best = bp[t].dz;\n            }\n         }\n         if (t_best == 0)\n            goto skip;\n#else\n         int t, num, num1;\n         double slope, teta_lim;\n         /* determine dual objective break-points */\n         nbp = spy_ls_eval_bp(lp, d, r, trow, tol_piv, bp);\n         if (nbp < 2)\n            goto skip;\n         /* set initial slope */\n         slope = fabs(r);\n         /* estimate initial teta_lim */\n         teta_lim = DBL_MAX;\n         for (t = 1; t <= nbp; t++)\n         {  if (teta_lim > bp[t].teta)\n               teta_lim = bp[t].teta;\n         }\n         xassert(teta_lim >= 0.0);\n         if (teta_lim < 1e-6)\n            teta_lim = 1e-6;\n         /* nothing has been chosen so far */\n         t_best = 0, dz_best = 0.0, num = 0;\n         /* choose appropriate break-point */\n         while (num < nbp)\n         {  /* select and process a new portion of break-points */\n            num1 = spy_ls_select_bp(lp, trow, nbp, bp, num, &slope,\n               teta_lim);\n            for (t = num+1; t <= num1; t++)\n            {  if (fabs(trow[bp[t].j]) / big >= MIN_RATIO)\n               {  if (dz_best < bp[t].dz)\n                     t_best = t, dz_best = bp[t].dz;\n               }\n            }\n            if (slope < 0.0)\n            {  /* the dual objective starts decreasing */\n               break;\n            }\n            /* the dual objective continues increasing */\n            num = num1;\n            teta_lim += teta_lim;\n         }\n         if (dz_best == 0.0)\n            goto skip;\n         xassert(1 <= t_best && t_best <= num1);\n#endif\n         /* the choice has been made */\n         csa->p = p;\n#if 0 /* 29/III-2016 */\n         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));\n#else\n         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));\n         fvs_gather_vec(&csa->trow, DBL_EPSILON);\n#endif\n         csa->q = bp[t_best].j;\n         best_ratio = fabs(trow[bp[t_best].j]) / big;\n#if 0\n         xprintf(\"num = %d; t_best = %d; dz = %g\\n\", num, t_best,\n            bp[t_best].dz);\n#endif\n         ret = 1;\n         goto done;\nskip:    ;\n      }\n      if (csa->r_test == GLP_RT_STD)\n      {  /* textbook dual ratio test */\n         q = spy_chuzc_std(lp, d, r, trow, tol_piv,\n            .30 * csa->tol_dj, .30 * csa->tol_dj1);\n      }\n      else\n      {  /* Harris' two-pass dual ratio test */\n         q = spy_chuzc_harris(lp, d, r, trow, tol_piv,\n            .35 * csa->tol_dj, .35 * csa->tol_dj1);\n      }\n      if (q == 0)\n      {  /* dual unboundedness */\n         csa->p = p;\n#if 0 /* 29/III-2016 */\n         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));\n#else\n         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));\n         fvs_gather_vec(&csa->trow, DBL_EPSILON);\n#endif\n         csa->q = q;\n         best_ratio = 1.0;\n         goto done;\n      }\n      /* either keep previous choice or accept new choice depending on\n       * which one is better */\n      if (best_ratio < fabs(trow[q]) / big)\n      {  csa->p = p;\n#if 0 /* 29/III-2016 */\n         memcpy(&csa->trow[1], &trow[1], (n-m) * sizeof(double));\n#else\n         memcpy(&csa->trow.vec[1], &trow[1], (n-m) * sizeof(double));\n         fvs_gather_vec(&csa->trow, DBL_EPSILON);\n#endif\n         csa->q = q;\n         best_ratio = fabs(trow[q]) / big;\n      }\n      /* check if the current choice is acceptable */\n      if (best_ratio >= MIN_RATIO || nnn == 1 || try == 5)\n         goto done;\n      /* try to choose other xB[p] and xN[q] */\n      /* find xB[p] in the list */\n      for (t = 1; t <= nnn; t++)\n         if (list[t] == p) break;\n      xassert(t <= nnn);\n      /* move xB[p] to the end of the list */\n      list[t] = list[nnn], list[nnn] = p;\n      /* and exclude it from consideration */\n      nnn--;\n      /* repeat the choice */\n      goto try;\ndone: /* the choice has been made */\n#if 1 /* FIXME: currently just to avoid badly conditioned basis */\n      if (best_ratio < .001 * MIN_RATIO)\n      {  /* looks like this helps */\n         if (bfd_get_count(lp->bfd) > 0)\n            return -1;\n         /* didn't help; last chance to improve the choice */\n         if (tol_piv == csa->tol_piv)\n         {  tol_piv *= 1000.;\n            goto more;\n         }\n      }\n#endif\n#if 1 /* FIXME */\n      if (ret)\n      {  /* invalidate basic solution components */\n#if 0 /* 28/III-2016 */\n         csa->beta_st = csa->d_st = 0;\n#else\n         /* dual solution remains valid */\n         csa->beta_st = 0;\n#endif\n         /* set double-bounded non-basic variables to opposite bounds\n          * for all break-points preceding the chosen one */\n         for (t = 1; t < t_best; t++)\n         {  k = head[m + bp[t].j];\n            xassert(-DBL_MAX < l[k] && l[k] < u[k] && u[k] < +DBL_MAX);\n            lp->flag[bp[t].j] = !(lp->flag[bp[t].j]);\n         }\n      }\n#endif\n      return ret;\n}",
      "lines": 233,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "play_coef": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static void play_coef(struct csa *csa, int all)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      double *c = lp->c;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *orig_c = csa->orig_c;\n      double *d = csa->d;\n      const double *trow = csa->trow.vec;\n      /* this vector was used to update d = (d[j]) */\n      int j, k;\n      static const double eps = 1e-9;\n      /* reduced costs d = (d[j]) should be valid */\n      xassert(csa->d_st);\n      /* walk thru the list of non-basic variables xN = (xN[j]) */\n      for (j = 1; j <= n-m; j++)\n      {  if (all || trow[j] != 0.0)\n         {  /* d[j] has changed in the adjacent basis */\n            k = head[m+j]; /* x[k] = xN[j] */\n            if (l[k] == u[k])\n            {  /* xN[j] is fixed variable */\n               /* d[j] may have any sign */\n            }\n            else if (l[k] == -DBL_MAX && u[k] == +DBL_MAX)\n            {  /* xN[j] is free (unbounded) variable */\n               /* strong feasibility means d[j] = 0 */\n               c[k] -= d[j], d[j] = 0.0;\n               /* in this case dual degeneracy is not critical, since\n                * if xN[j] enters the basis, it never leaves it */\n            }\n            else if (!flag[j])\n            {  /* xN[j] has its lower bound active */\n               xassert(l[k] != -DBL_MAX);\n               /* first, we remove current perturbation to provide\n                * c[k] = orig_c[k] */\n               d[j] -= c[k] - orig_c[k], c[k] = orig_c[k];\n               /* strong feasibility means d[j] >= 0, but we provide\n                * d[j] >= +eps to prevent dual degeneracy */\n               if (d[j] < +eps)\n                  c[k] -= d[j] - eps, d[j] = +eps;\n            }\n            else\n            {  /* xN[j] has its upper bound active */\n               xassert(u[k] != +DBL_MAX);\n               /* similarly, we remove current perturbation to provide\n                * c[k] = orig_c[k] */\n               d[j] -= c[k] - orig_c[k], c[k] = orig_c[k];\n               /* strong feasibility means d[j] <= 0, but we provide\n                * d[j] <= -eps to prevent dual degeneracy */\n               if (d[j] > -eps)\n                  c[k] -= d[j] + eps, d[j] = -eps;\n            }\n         }\n      }\n      return;\n}",
      "lines": 59,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "remove_perturb": {
      "start_point": [
        966,
        0
      ],
      "end_point": [
        981,
        1
      ],
      "content": "static void remove_perturb(struct csa *csa)\n{     /* remove perturbation */\n      SPXLP *lp = csa->lp;\n      int n = lp->n;\n      double *c = lp->c;\n      double *orig_c = csa->orig_c;\n      memcpy(c, orig_c, (1+n) * sizeof(double));\n      /* removing perturbation changes dual solution components */\n      csa->phase = csa->d_st = 0;\n#if 1\n      if (csa->msg_lev >= GLP_MSG_ALL)\n         xprintf(\"Removing LP perturbation [%d]...\\n\",\n            csa->it_cnt);\n#endif\n      return;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display": {
      "start_point": [
        1003,
        0
      ],
      "end_point": [
        1126,
        1
      ],
      "content": "static void display(struct csa *csa, int spec)\n{     SPXLP *lp = csa->lp;\n      int m = lp->m;\n      int n = lp->n;\n      int *head = lp->head;\n      char *flag = lp->flag;\n      double *l = csa->orig_l; /* original lower bounds */\n      double *u = csa->orig_u; /* original upper bounds */\n      double *beta = csa->beta;\n      double *d = csa->d;\n      int j, k, nnn;\n      double sum;\n#if 1 /* 15/VII-2017 */\n      double tm_cur;\n#endif\n      /* check if the display output should be skipped */\n      if (csa->msg_lev < GLP_MSG_ON) goto skip;\n#if 1 /* 15/VII-2017 */\n      tm_cur = xtime();\n#endif\n      if (csa->out_dly > 0 &&\n#if 0 /* 15/VII-2017 */\n         1000.0 * xdifftime(xtime(), csa->tm_beg) < csa->out_dly)\n#else\n         1000.0 * xdifftime(tm_cur, csa->tm_beg) < csa->out_dly)\n#endif\n         goto skip;\n      if (csa->it_cnt == csa->it_dpy) goto skip;\n#if 0 /* 15/VII-2017 */\n      if (!spec && csa->it_cnt % csa->out_frq != 0) goto skip;\n#else\n      if (!spec &&\n         1000.0 * xdifftime(tm_cur, csa->tm_dpy) < csa->out_frq)\n         goto skip;\n#endif\n      /* display search progress depending on search phase */\n      switch (csa->phase)\n      {  case 1:\n            /* compute sum and number of (scaled) dual infeasibilities\n             * for original bounds */\n            sum = 0.0, nnn = 0;\n            for (j = 1; j <= n-m; j++)\n            {  k = head[m+j]; /* x[k] = xN[j] */\n               if (d[j] > 0.0)\n               {  /* xN[j] should have lower bound */\n                  if (l[k] == -DBL_MAX)\n                  {  sum += d[j];\n                     if (d[j] > +1e-7)\n                        nnn++;\n                  }\n               }\n               else if (d[j] < 0.0)\n               {  /* xN[j] should have upper bound */\n                  if (u[k] == +DBL_MAX)\n                  {  sum -= d[j];\n                     if (d[j] < -1e-7)\n                        nnn++;\n                  }\n               }\n            }\n            /* on phase I variables have artificial bounds which are\n             * meaningless for original LP, so corresponding objective\n             * function value is also meaningless */\n#if 0 /* 27/III-2016 */\n            xprintf(\" %6d: %23s inf = %11.3e (%d)\",\n               csa->it_cnt, \"\", sum, nnn);\n#else\n            xprintf(\" %6d: sum = %17.9e inf = %11.3e (%d)\",\n               csa->it_cnt, lp->c[0] - spx_eval_obj(lp, beta),\n               sum, nnn);\n#endif\n            break;\n         case 2:\n            /* compute sum of (scaled) dual infeasibilities */\n            sum = 0.0, nnn = 0;\n            for (j = 1; j <= n-m; j++)\n            {  k = head[m+j]; /* x[k] = xN[j] */\n               if (d[j] > 0.0)\n               {  /* xN[j] should have its lower bound active */\n                  if (l[k] == -DBL_MAX || flag[j])\n                     sum += d[j];\n               }\n               else if (d[j] < 0.0)\n               {  /* xN[j] should have its upper bound active */\n                  if (l[k] != u[k] && !flag[j])\n                     sum -= d[j];\n               }\n            }\n            /* compute number of primal infeasibilities */\n            nnn = spy_chuzr_sel(lp, beta, csa->tol_bnd, csa->tol_bnd1,\n               NULL);\n            xprintf(\"#%6d: obj = %17.9e inf = %11.3e (%d)\",\n#if SCALE_Z\n               csa->it_cnt,\n               (double)csa->dir * csa->fz * spx_eval_obj(lp, beta),\n#else\n               csa->it_cnt, (double)csa->dir * spx_eval_obj(lp, beta),\n#endif\n               sum, nnn);\n            break;\n         default:\n            xassert(csa != csa);\n      }\n      if (csa->inv_cnt)\n      {  /* number of basis factorizations performed */\n         xprintf(\" %d\", csa->inv_cnt);\n         csa->inv_cnt = 0;\n      }\n#if 1 /* 23/III-2016 */\n      if (csa->r_test == GLP_RT_FLIP)\n      {  /*xprintf(\"   %d,%d\", csa->ns_cnt, csa->ls_cnt);*/\n         if (csa->ns_cnt + csa->ls_cnt)\n            xprintf(\" %d%%\",\n               (100 * csa->ls_cnt) / (csa->ns_cnt + csa->ls_cnt));\n         csa->ns_cnt = csa->ls_cnt = 0;\n      }\n#endif\n      xprintf(\"\\n\");\n      csa->it_dpy = csa->it_cnt;\n#if 1 /* 15/VII-2017 */\n      csa->tm_dpy = tm_cur;\n#endif\nskip: return;\n}",
      "lines": 124,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spy_update_r": {
      "start_point": [
        1129,
        0
      ],
      "end_point": [
        1191,
        1
      ],
      "content": "static\nvoid spy_update_r(SPXLP *lp, int p, int q, const double beta[/*1+m*/],\n      const FVS *tcol, double tol, double tol1, FVS *r)\n{     /* update vector r of primal infeasibilities */\n      /* it is assumed that xB[p] leaves the basis, xN[q] enters the\n       * basis, and beta corresponds to the adjacent basis (i.e. this\n       * routine should be called after spx_update_beta) */\n      int m = lp->m;\n      int n = lp->n;\n      double *l = lp->l;\n      double *u = lp->u;\n      int *head = lp->head;\n      int *tcol_ind = tcol->ind;\n      int *ind = r->ind;\n      double *vec = r->vec;\n      int i, k, t, nnz;\n      double lk, uk, ri, eps;\n      xassert(1 <= p && p <= m);\n      xassert(1 <= q && q <= n-m);\n      nnz = r->nnz;\n      for (t = tcol->nnz; t >= 1; t--)\n      {  i = tcol_ind[t];\n         /* xB[i] changes in the adjacent basis to beta[i], so only\n          * r[i] should be updated */\n         if (i == p)\n            k = head[m+q]; /* x[k] = new xB[p] = old xN[q] */\n         else\n            k = head[i];   /* x[k] = new xB[i] = old xB[i] */\n         lk = l[k], uk = u[k];\n         /* determine new value of r[i]; see spy_eval_r */\n         ri = 0.0;\n         if (beta[i] < lk)\n         {  /* determine absolute tolerance eps1[i] */\n            eps = tol + tol1 * (lk >= 0.0 ? +lk : -lk);\n            if (beta[i] < lk - eps)\n            {  /* lower bound is violated */\n               ri = lk - beta[i];\n            }\n         }\n         else if (beta[i] > uk)\n         {  /* determine absolute tolerance eps2[i] */\n            eps = tol + tol1 * (uk >= 0.0 ? +uk : -uk);\n            if (beta[i] > uk + eps)\n            {  /* upper bound is violated */\n               ri = uk - beta[i];\n            }\n         }\n         if (ri == 0.0)\n         {  if (vec[i] != 0.0)\n               vec[i] = DBL_MIN; /* will be removed */\n         }\n         else\n         {  if (vec[i] == 0.0)\n               ind[++nnz] = i;\n            vec[i] = ri;\n         }\n\n      }\n      r->nnz = nnz;\n      /* remove zero elements */\n      fvs_adjust_vec(r, DBL_MIN + DBL_MIN);\n      return;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "spy_dual": {
      "start_point": [
        1833,
        0
      ],
      "end_point": [
        2098,
        1
      ],
      "content": "int spy_dual(glp_prob *P, const glp_smcp *parm)\n{     /* driver to the dual simplex method */\n      struct csa csa_, *csa = &csa_;\n      SPXLP lp;\n      SPXAT at;\n      SPXNT nt;\n      SPYSE se;\n      int ret, *map, *daeh;\n#if SCALE_Z\n      int i, j, k;\n#endif\n      /* build working LP and its initial basis */\n      memset(csa, 0, sizeof(struct csa));\n      csa->lp = &lp;\n      spx_init_lp(csa->lp, P, parm->excl);\n      spx_alloc_lp(csa->lp);\n      map = talloc(1+P->m+P->n, int);\n      spx_build_lp(csa->lp, P, parm->excl, parm->shift, map);\n      spx_build_basis(csa->lp, P, map);\n      switch (P->dir)\n      {  case GLP_MIN:\n            csa->dir = +1;\n            break;\n         case GLP_MAX:\n            csa->dir = -1;\n            break;\n         default:\n            xassert(P != P);\n      }\n#if SCALE_Z\n      csa->fz = 0.0;\n      for (k = 1; k <= csa->lp->n; k++)\n      {  double t = fabs(csa->lp->c[k]);\n         if (csa->fz < t)\n            csa->fz = t;\n      }\n      if (csa->fz <= 1000.0)\n         csa->fz = 1.0;\n      else\n         csa->fz /= 1000.0;\n      /*xprintf(\"csa->fz = %g\\n\", csa->fz);*/\n      for (k = 0; k <= csa->lp->n; k++)\n         csa->lp->c[k] /= csa->fz;\n#endif\n      csa->orig_b = talloc(1+csa->lp->m, double);\n      memcpy(csa->orig_b, csa->lp->b, (1+csa->lp->m) * sizeof(double));\n      csa->orig_c = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_c, csa->lp->c, (1+csa->lp->n) * sizeof(double));\n      csa->orig_l = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_l, csa->lp->l, (1+csa->lp->n) * sizeof(double));\n      csa->orig_u = talloc(1+csa->lp->n, double);\n      memcpy(csa->orig_u, csa->lp->u, (1+csa->lp->n) * sizeof(double));\n      switch (parm->aorn)\n      {  case GLP_USE_AT:\n            /* build matrix A in row-wise format */\n            csa->at = &at;\n            csa->nt = NULL;\n            spx_alloc_at(csa->lp, csa->at);\n            spx_build_at(csa->lp, csa->at);\n            break;\n         case GLP_USE_NT:\n            /* build matrix N in row-wise format for initial basis */\n            csa->at = NULL;\n            csa->nt = &nt;\n            spx_alloc_nt(csa->lp, csa->nt);\n            spx_init_nt(csa->lp, csa->nt);\n            spx_build_nt(csa->lp, csa->nt);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n      /* allocate and initialize working components */\n      csa->phase = 0;\n      csa->beta = talloc(1+csa->lp->m, double);\n      csa->beta_st = 0;\n      csa->d = talloc(1+csa->lp->n-csa->lp->m, double);\n      csa->d_st = 0;\n      switch (parm->pricing)\n      {  case GLP_PT_STD:\n            csa->se = NULL;\n            break;\n         case GLP_PT_PSE:\n            csa->se = &se;\n            spy_alloc_se(csa->lp, csa->se);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n#if 0 /* 30/III-2016 */\n      csa->list = talloc(1+csa->lp->m, int);\n      csa->trow = talloc(1+csa->lp->n-csa->lp->m, double);\n      csa->tcol = talloc(1+csa->lp->m, double);\n#else\n      fvs_alloc_vec(&csa->r, csa->lp->m);\n      fvs_alloc_vec(&csa->trow, csa->lp->n-csa->lp->m);\n      fvs_alloc_vec(&csa->tcol, csa->lp->m);\n#endif\n#if 1 /* 16/III-2016 */\n      csa->bp = NULL;\n#endif\n      csa->work = talloc(1+csa->lp->m, double);\n      csa->work1 = talloc(1+csa->lp->n-csa->lp->m, double);\n#if 0 /* 11/VI-2017 */\n#if 1 /* 31/III-2016 */\n      fvs_alloc_vec(&csa->wrow, csa->lp->n-csa->lp->m);\n      fvs_alloc_vec(&csa->wcol, csa->lp->m);\n#endif\n#endif\n      /* initialize control parameters */\n      csa->msg_lev = parm->msg_lev;\n      csa->dualp = (parm->meth == GLP_DUALP);\n#if 0 /* 16/III-2016 */\n      switch (parm->r_test)\n      {  case GLP_RT_STD:\n            csa->harris = 0;\n            break;\n         case GLP_RT_HAR:\n            csa->harris = 1;\n            break;\n         default:\n            xassert(parm != parm);\n      }\n#else\n      switch (parm->r_test)\n      {  case GLP_RT_STD:\n         case GLP_RT_HAR:\n            break;\n         case GLP_RT_FLIP:\n            csa->bp = talloc(1+csa->lp->n-csa->lp->m, SPYBP);\n            break;\n         default:\n            xassert(parm != parm);\n      }\n      csa->r_test = parm->r_test;\n#endif\n      csa->tol_bnd = parm->tol_bnd;\n      csa->tol_bnd1 = .001 * parm->tol_bnd;\n      csa->tol_dj = parm->tol_dj;\n      csa->tol_dj1 = .001 * parm->tol_dj;\n#if 0\n      csa->tol_dj1 = 1e-9 * parm->tol_dj;\n#endif\n      csa->tol_piv = parm->tol_piv;\n      switch (P->dir)\n      {  case GLP_MIN:\n            csa->obj_lim = + parm->obj_ul;\n            break;\n         case GLP_MAX:\n            csa->obj_lim = - parm->obj_ll;\n            break;\n         default:\n            xassert(parm != parm);\n      }\n#if SCALE_Z\n      if (csa->obj_lim != DBL_MAX)\n         csa->obj_lim /= csa->fz;\n#endif\n      csa->it_lim = parm->it_lim;\n      csa->tm_lim = parm->tm_lim;\n      csa->out_frq = parm->out_frq;\n      csa->out_dly = parm->out_dly;\n      /* initialize working parameters */\n      csa->tm_beg = xtime();\n      csa->it_beg = csa->it_cnt = P->it_cnt;\n      csa->it_dpy = -1;\n#if 1 /* 15/VII-2017 */\n      csa->tm_dpy = 0.0;\n#endif\n      csa->inv_cnt = 0;\n#if 1 /* 11/VII-2017 */\n      csa->degen = 0;\n#endif\n#if 1 /* 23/III-2016 */\n      csa->ns_cnt = csa->ls_cnt = 0;\n#endif\n      /* try to solve working LP */\n      ret = dual_simplex(csa);\n      /* return basis factorization back to problem object */\n      P->valid = csa->lp->valid;\n      P->bfd = csa->lp->bfd;\n      /* set solution status */\n      P->pbs_stat = csa->p_stat;\n      P->dbs_stat = csa->d_stat;\n      /* if the solver failed, do not store basis header and basic\n       * solution components to problem object */\n      if (ret == GLP_EFAIL)\n         goto skip;\n      /* convert working LP basis to original LP basis and store it to\n       * problem object */\n      daeh = talloc(1+csa->lp->n, int);\n      spx_store_basis(csa->lp, P, map, daeh);\n      /* compute simplex multipliers for final basic solution found by\n       * the solver */\n      spx_eval_pi(csa->lp, csa->work);\n      /* convert working LP solution to original LP solution and store\n       * it to problem object */\n#if SCALE_Z\n      for (i = 1; i <= csa->lp->m; i++)\n         csa->work[i] *= csa->fz;\n      for (j = 1; j <= csa->lp->n-csa->lp->m; j++)\n         csa->d[j] *= csa->fz;\n#endif\n      spx_store_sol(csa->lp, P, parm->shift, map, daeh, csa->beta,\n         csa->work, csa->d);\n      tfree(daeh);\n      /* save simplex iteration count */\n      P->it_cnt = csa->it_cnt;\n      /* report auxiliary/structural variable causing unboundedness */\n      P->some = 0;\n      if (csa->p_stat == GLP_NOFEAS && csa->d_stat == GLP_FEAS)\n      {  int k, kk;\n         /* xB[p] = x[k] causes dual unboundedness */\n         xassert(1 <= csa->p && csa->p <= csa->lp->m);\n         k = csa->lp->head[csa->p];\n         xassert(1 <= k && k <= csa->lp->n);\n         /* convert to number of original variable */\n         for (kk = 1; kk <= P->m + P->n; kk++)\n         {  if (abs(map[kk]) == k)\n            {  P->some = kk;\n               break;\n            }\n         }\n         xassert(P->some != 0);\n      }\nskip: /* deallocate working objects and arrays */\n      spx_free_lp(csa->lp);\n      tfree(map);\n      tfree(csa->orig_b);\n      tfree(csa->orig_c);\n      tfree(csa->orig_l);\n      tfree(csa->orig_u);\n      if (csa->at != NULL)\n         spx_free_at(csa->lp, csa->at);\n      if (csa->nt != NULL)\n         spx_free_nt(csa->lp, csa->nt);\n      tfree(csa->beta);\n      tfree(csa->d);\n      if (csa->se != NULL)\n         spy_free_se(csa->lp, csa->se);\n#if 0 /* 30/III-2016 */\n      tfree(csa->list);\n      tfree(csa->trow);\n#else\n      fvs_free_vec(&csa->r);\n      fvs_free_vec(&csa->trow);\n#endif\n#if 1 /* 16/III-2016 */\n      if (csa->bp != NULL)\n         tfree(csa->bp);\n#endif\n#if 0 /* 29/III-2016 */\n      tfree(csa->tcol);\n#else\n      fvs_free_vec(&csa->tcol);\n#endif\n      tfree(csa->work);\n      tfree(csa->work1);\n#if 0 /* 11/VI-2017 */\n#if 1 /* 31/III-2016 */\n      fvs_free_vec(&csa->wrow);\n      fvs_free_vec(&csa->wcol);\n#endif\n#endif\n      /* return to calling program */\n      return ret >= 0 ? ret : GLP_EFAIL;\n}",
      "lines": 266,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/adler32.c": {},
  "glpk/glpk-4.65/src/zlib/compress.c": {},
  "glpk/glpk-4.65/src/zlib/crc32.c": {
    "make_crc_table": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "local void make_crc_table()\n{\n    unsigned long c;\n    int n, k;\n    unsigned long poly;                 /* polynomial exclusive-or pattern */\n    /* terms of polynomial defining this crc (except x^32): */\n    static volatile int first = 1;      /* flag to limit concurrent making */\n    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n    /* See if another task is already doing this (not thread-safe, but better\n       than nothing -- significantly reduces duration of vulnerability in\n       case the advice about DYNAMIC_CRC_TABLE is ignored) */\n    if (first) {\n        first = 0;\n\n        /* make exclusive-or pattern from polynomial (0xedb88320UL) */\n        poly = 0UL;\n        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)\n            poly |= 1UL << (31 - p[n]);\n\n        /* generate a crc for every 8-bit value */\n        for (n = 0; n < 256; n++) {\n            c = (unsigned long)n;\n            for (k = 0; k < 8; k++)\n                c = c & 1 ? poly ^ (c >> 1) : c >> 1;\n            crc_table[0][n] = c;\n        }\n\n#ifdef BYFOUR\n        /* generate crc for each value followed by one, two, and three zeros,\n           and then the byte reversal of those as well as the first table */\n        for (n = 0; n < 256; n++) {\n            c = crc_table[0][n];\n            crc_table[4][n] = REV(c);\n            for (k = 1; k < 4; k++) {\n                c = crc_table[0][c & 0xff] ^ (c >> 8);\n                crc_table[k][n] = c;\n                crc_table[k + 4][n] = REV(c);\n            }\n        }\n#endif /* BYFOUR */\n\n        crc_table_empty = 0;\n    }\n    else {      /* not first */\n        /* wait for the other guy to finish (not efficient, but rare) */\n        while (crc_table_empty)\n            ;\n    }\n\n#ifdef MAKECRCH\n    /* write out CRC tables to crc32.h */\n    {\n        FILE *out;\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n        fprintf(out, \"/* crc32.h -- tables for rapid CRC calculation\\n\");\n        fprintf(out, \" * Generated automatically by crc32.c\\n */\\n\\n\");\n        fprintf(out, \"local const unsigned long FAR \");\n        fprintf(out, \"crc_table[TBLS][256] =\\n{\\n  {\\n\");\n        write_table(out, crc_table[0]);\n#  ifdef BYFOUR\n        fprintf(out, \"#ifdef BYFOUR\\n\");\n        for (k = 1; k < 8; k++) {\n            fprintf(out, \"  },\\n  {\\n\");\n            write_table(out, crc_table[k]);\n        }\n        fprintf(out, \"#endif\\n\");\n#  endif /* BYFOUR */\n        fprintf(out, \"  }\\n};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "local",
        "void",
        "void"
      ]
    },
    "get_crc_table": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "const unsigned long FAR * ZEXPORT get_crc_table()\n{\n#ifdef DYNAMIC_CRC_TABLE\n    if (crc_table_empty)\n        make_crc_table();\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const unsigned long FAR *)crc_table;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "unsigned long FAR",
        "unsigned",
        "long",
        "FAR",
        "* ZEXPORT get_crc_table()",
        "*",
        "ZEXPORT",
        "ZEXPORT"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/crc32.h": {},
  "glpk/glpk-4.65/src/zlib/deflate.c": {},
  "glpk/glpk-4.65/src/zlib/deflate.h": {},
  "glpk/glpk-4.65/src/zlib/gzclose.c": {},
  "glpk/glpk-4.65/src/zlib/gzguts.h": {},
  "glpk/glpk-4.65/src/zlib/gzlib.c": {
    "gz_intmax": {
      "start_point": [
        524,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "unsigned ZLIB_INTERNAL gz_intmax()\n{\n    unsigned p, q;\n\n    p = 1;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "unsigned ZLIB_INTERNAL",
        "unsigned",
        "ZLIB_INTERNAL"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/gzread.c": {},
  "glpk/glpk-4.65/src/zlib/gzwrite.c": {
    "ZEXPORTVA": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)\n{\n    int size, len;\n    gz_statep state;\n    z_streamp strm;\n    va_list va;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return 0;\n\n    /* do the printf() into the input buffer, put length in len */\n    size = (int)(state->size);\n    state->in[size - 1] = 0;\n    va_start(va, format);\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(state->in, format, va);\n    va_end(va);\n    for (len = 0; len < size; len++)\n        if (state->in[len] == 0) break;\n#  else\n    len = vsprintf((char *)state->in, format, va);\n    va_end(va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(state->in, size, format, va);\n    va_end(va);\n    len = strlen(state->in);\n#  else\n    len = vsnprintf((char *)(state->in), size, format, va);\n    va_end(va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, defer compression until needed */\n    strm->avail_in = (unsigned)len;\n    strm->next_in = state->in;\n    state->pos += len;\n    return len;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/inffast.c": {},
  "glpk/glpk-4.65/src/zlib/inffast.h": {},
  "glpk/glpk-4.65/src/zlib/inffixed.h": {},
  "glpk/glpk-4.65/src/zlib/inflate.c": {
    "makefixed": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "void makefixed()\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.lencode[low].op, state.lencode[low].bits,\n               state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/inflate.h": {},
  "glpk/glpk-4.65/src/zlib/inftrees.c": {},
  "glpk/glpk-4.65/src/zlib/inftrees.h": {},
  "glpk/glpk-4.65/src/zlib/trees.c": {
    "tr_static_init": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "local void tr_static_init()\n{\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n#endif\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length-1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
      "lines": 81,
      "depth": 13,
      "decorators": [
        "local",
        "void",
        "void"
      ]
    },
    "gen_trees_header": {
      "start_point": [
        332,
        0
      ],
      "end_point": [
        379,
        1
      ],
      "content": "void gen_trees_header()\n{\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n            \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n        fprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n        fprintf(header, \"%2u%s\", _dist_code[i],\n                SEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header,\n        \"const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n        fprintf(header, \"%2u%s\", _length_code[i],\n                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n        fprintf(header, \"%1u%s\", base_length[i],\n                SEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"%5u%s\", base_dist[i],\n                SEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/trees.h": {},
  "glpk/glpk-4.65/src/zlib/uncompr.c": {},
  "glpk/glpk-4.65/src/zlib/zconf.h": {},
  "glpk/glpk-4.65/src/zlib/zio.c": {
    "initialize": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "static void initialize(void)\n{     int fd;\n      assert(!initialized);\n      file[0] = stdin;\n      file[1] = stdout;\n      file[2] = stderr;\n      for (fd = 3; fd < FOPEN_MAX; fd++)\n         file[fd] = NULL;\n      initialized = 1;\n      return;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int open(const char *path, int oflag, ...)\n{     FILE *fp;\n      int fd;\n      if (!initialized) initialize();\n      /* see file gzlib.c, function gz_open */\n      if (oflag == O_RDONLY)\n         fp = fopen(path, \"rb\");\n      else if (oflag == (O_WRONLY | O_CREAT | O_TRUNC))\n         fp = fopen(path, \"wb\");\n      else if (oflag == (O_WRONLY | O_CREAT | O_APPEND))\n         fp = fopen(path, \"ab\");\n      else\n         assert(oflag != oflag);\n      if (fp == NULL)\n         return -1;\n      for (fd = 0; fd < FOPEN_MAX; fd++)\n         if (file[fd] == NULL) break;\n      assert(fd < FOPEN_MAX);\n      file[fd] = fp;\n      return fd;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "read": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "long read(int fd, void *buf, unsigned long nbyte)\n{     unsigned long count;\n      if (!initialized) initialize();\n      assert(0 <= fd && fd < FOPEN_MAX);\n      assert(file[fd] != NULL);\n      count = fread(buf, 1, nbyte, file[fd]);\n      if (ferror(file[fd]))\n         return -1;\n      return count;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "long",
        "long"
      ]
    },
    "write": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "long write(int fd, const void *buf, unsigned long nbyte)\n{     unsigned long count;\n      if (!initialized) initialize();\n      assert(0 <= fd && fd < FOPEN_MAX);\n      assert(file[fd] != NULL);\n      count = fwrite(buf, 1, nbyte, file[fd]);\n      if (count != nbyte)\n         return -1;\n      if (fflush(file[fd]) != 0)\n         return -1;\n      return count;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "long",
        "long"
      ]
    },
    "lseek": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "long lseek(int fd, long offset, int whence)\n{     if (!initialized) initialize();\n      assert(0 <= fd && fd < FOPEN_MAX);\n      assert(file[fd] != NULL);\n      if (fseek(file[fd], offset, whence) != 0)\n         return -1;\n      return ftell(file[fd]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "long",
        "long"
      ]
    },
    "close": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int close(int fd)\n{     if (!initialized) initialize();\n      assert(0 <= fd && fd < FOPEN_MAX);\n      assert(file[fd] != NULL);\n      fclose(file[fd]);\n      file[fd] = NULL;\n      return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "glpk/glpk-4.65/src/zlib/zio.h": {},
  "glpk/glpk-4.65/src/zlib/zlib.h": {},
  "glpk/glpk-4.65/src/zlib/zutil.c": {
    "zlibVersion": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "const char * ZEXPORT zlibVersion()\n{\n    return ZLIB_VERSION;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "const",
        "const",
        "char",
        "* ZEXPORT zlibVersion()",
        "*",
        "ZEXPORT",
        "ZEXPORT"
      ]
    },
    "zlibCompileFlags": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "uLong ZEXPORT zlibCompileFlags()\n{\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef DEBUG\n    flags += 1 << 8;\n#endif\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#ifdef STDC\n#  ifdef NO_vsnprintf\n        flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#else\n        flags += 1L << 24;\n#  ifdef NO_snprintf\n        flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n        flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n        flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
      "lines": 82,
      "depth": 11,
      "decorators": [
        "uLong",
        "ZEXPORT",
        "ZEXPORT"
      ]
    },
    "ZLIB_INTERNAL": [
      {
        "start_point": [
          215,
          0
        ],
        "end_point": [
          237,
          1
        ],
        "content": "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)\n{\n    voidpf buf = opaque; /* just to make some compilers happy */\n    ulg bsize = (ulg)items*size;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
        "lines": 23,
        "depth": 14,
        "decorators": [
          "voidpf"
        ]
      },
      {
        "start_point": [
          239,
          0
        ],
        "end_point": [
          259,
          1
        ],
        "content": "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    int n;\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    ptr = opaque; /* just to make some compilers happy */\n    Assert(0, \"zcfree: ptr not found\");\n}",
        "lines": 21,
        "depth": 11,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          274,
          0
        ],
        "end_point": [
          278,
          1
        ],
        "content": "voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    return _halloc((long)items, size);\n}",
        "lines": 5,
        "depth": 9,
        "decorators": [
          "voidpf"
        ]
      },
      {
        "start_point": [
          280,
          0
        ],
        "end_point": [
          284,
          1
        ],
        "content": "void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)\n{\n    if (opaque) opaque = 0; /* to make compiler happy */\n    _hfree(ptr);\n}",
        "lines": 5,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "glpk/glpk-4.65/src/zlib/zutil.h": {}
}