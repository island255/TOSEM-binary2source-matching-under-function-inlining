{
  "gss/gss-1.0.3/build-aux/snippet/arg-nonnull.h": {},
  "gss/gss-1.0.3/build-aux/snippet/c++defs.h": {},
  "gss/gss-1.0.3/build-aux/snippet/warn-on-use.h": {},
  "gss/gss-1.0.3/gl/dummy.c": {},
  "gss/gss-1.0.3/lib/asn1.c": {
    "_gss_asn1_length_der": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\n_gss_asn1_length_der (size_t len, unsigned char *ans, size_t * ans_len)\n{\n  size_t k;\n  unsigned char temp[sizeof (len)];\n\n  if (len < 128)\n    {\n      if (ans != NULL)\n\tans[0] = (unsigned char) len;\n      *ans_len = 1;\n    }\n  else\n    {\n      k = 0;\n\n      while (len)\n\t{\n\t  temp[k++] = len & 0xFF;\n\t  len = len >> 8;\n\t}\n\n      *ans_len = k + 1;\n\n      if (ans != NULL)\n\t{\n\t  ans[0] = ((unsigned char) k & 0x7F) + 128;\n\t  while (k--)\n\t    ans[*ans_len - 1 - k] = temp[k];\n\t}\n    }\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_gss_asn1_get_length_der": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static size_t\n_gss_asn1_get_length_der (const char *der, size_t der_len, size_t * len)\n{\n  size_t ans;\n  size_t k, punt;\n\n  *len = 0;\n  if (der_len <= 0)\n    return 0;\n\n  if (!(der[0] & 128))\n    {\n      /* short form */\n      *len = 1;\n      return (unsigned char) der[0];\n    }\n  else\n    {\n      /* Long form */\n      k = (unsigned char) der[0] & 0x7F;\n      punt = 1;\n      if (k)\n\t{\t\t\t/* definite length method */\n\t  ans = 0;\n\t  while (punt <= k && punt < der_len)\n\t    {\n\t      size_t last = ans;\n\n\t      ans = ans * 256 + (unsigned char) der[punt++];\n\t      if (ans < last)\n\t\t/* we wrapped around, no bignum support... */\n\t\treturn -2;\n\t    }\n\t}\n      else\n\t{\t\t\t/* indefinite length method */\n\t  ans = -1;\n\t}\n\n      *len = punt;\n      return ans;\n    }\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "_gss_encapsulate_token_prefix": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "OM_uint32\n_gss_encapsulate_token_prefix (const char *prefix, size_t prefixlen,\n\t\t\t       const char *in, size_t inlen,\n\t\t\t       const char *oid, OM_uint32 oidlen,\n\t\t\t       void **out, size_t * outlen)\n{\n  size_t oidlenlen;\n  size_t asn1len, asn1lenlen;\n  unsigned char *p;\n\n  if (prefix == NULL)\n    prefixlen = 0;\n\n  _gss_asn1_length_der (oidlen, NULL, &oidlenlen);\n  asn1len = 1 + oidlenlen + oidlen + prefixlen + inlen;\n  _gss_asn1_length_der (asn1len, NULL, &asn1lenlen);\n\n  *outlen = 1 + asn1lenlen + asn1len;\n  p = *out = malloc (*outlen);\n  if (!p)\n    return -1;\n\n  *p++ = '\\x60';\n  _gss_asn1_length_der (asn1len, p, &asn1lenlen);\n  p += asn1lenlen;\n  *p++ = '\\x06';\n  _gss_asn1_length_der (oidlen, p, &oidlenlen);\n  p += oidlenlen;\n  memcpy (p, oid, oidlen);\n  p += oidlen;\n  if (prefixlen > 0)\n    {\n      memcpy (p, prefix, prefixlen);\n      p += prefixlen;\n    }\n  memcpy (p, in, inlen);\n\n  return 0;\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_encapsulate_token": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "extern OM_uint32\ngss_encapsulate_token (gss_const_buffer_t input_token,\n\t\t       gss_const_OID token_oid,\n\t\t       gss_buffer_t output_token)\n{\n  int rc;\n\n  if (!input_token)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!token_oid)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!output_token)\n    return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n  rc = _gss_encapsulate_token_prefix (NULL, 0,\n\t\t\t\t      input_token->value,\n\t\t\t\t      input_token->length,\n\t\t\t\t      token_oid->elements,\n\t\t\t\t      token_oid->length,\n\t\t\t\t      &output_token->value,\n\t\t\t\t      &output_token->length);\n  if (rc != 0)\n    return GSS_S_FAILURE;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "extern",
        "extern",
        "OM_uint32"
      ]
    },
    "_gss_decapsulate_token": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "int\n_gss_decapsulate_token (const char *in, size_t inlen,\n\t\t\tchar **oid, size_t * oidlen,\n\t\t\tchar **out, size_t * outlen)\n{\n  size_t i;\n  size_t asn1lenlen;\n\n  if (inlen-- == 0)\n    return -1;\n  if (*in++ != '\\x60')\n    return -1;\n\n  i = inlen;\n  asn1lenlen = _gss_asn1_get_length_der (in, inlen, &i);\n  if (inlen < i)\n    return -1;\n\n  inlen -= i;\n  in += i;\n\n  if (inlen != asn1lenlen)\n    return -1;\n\n  if (inlen-- == 0)\n    return -1;\n  if (*in++ != '\\x06')\n    return -1;\n\n  i = inlen;\n  asn1lenlen = _gss_asn1_get_length_der (in, inlen, &i);\n  if (inlen < i)\n    return -1;\n\n  inlen -= i;\n  in += i;\n\n  if (inlen < asn1lenlen)\n    return -1;\n\n  *oidlen = asn1lenlen;\n  *oid = (char *) in;\n\n  inlen -= asn1lenlen;\n  in += asn1lenlen;\n\n  if (outlen)\n    *outlen = inlen;\n  if (out)\n    *out = (char *) in;\n\n  return 0;\n}",
      "lines": 53,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "gss_decapsulate_token": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "OM_uint32\ngss_decapsulate_token (gss_const_buffer_t input_token,\n\t\t       gss_const_OID token_oid,\n\t\t       gss_buffer_t output_token)\n{\n  gss_OID_desc tmpoid;\n  char *oid = NULL, *out = NULL;\n  size_t oidlen = 0, outlen = 0;\n\n  if (!input_token)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!token_oid)\n    return GSS_S_CALL_INACCESSIBLE_READ;\n  if (!output_token)\n    return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n  if (_gss_decapsulate_token ((char *) input_token->value,\n\t\t\t      input_token->length,\n\t\t\t      &oid, &oidlen, &out, &outlen) != 0)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  tmpoid.length = oidlen;\n  tmpoid.elements = oid;\n\n  if (!gss_oid_equal (token_oid, &tmpoid))\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  output_token->length = outlen;\n  output_token->value = malloc (outlen);\n  if (!output_token->value)\n    return GSS_S_FAILURE;\n\n  memcpy (output_token->value, out, outlen);\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/context.c": {
    "gss_init_sec_context": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "OM_uint32\ngss_init_sec_context (OM_uint32 * minor_status,\n\t\t      const gss_cred_id_t initiator_cred_handle,\n\t\t      gss_ctx_id_t * context_handle,\n\t\t      const gss_name_t target_name,\n\t\t      const gss_OID mech_type,\n\t\t      OM_uint32 req_flags,\n\t\t      OM_uint32 time_req,\n\t\t      const gss_channel_bindings_t input_chan_bindings,\n\t\t      const gss_buffer_t input_token,\n\t\t      gss_OID * actual_mech_type,\n\t\t      gss_buffer_t output_token,\n\t\t      OM_uint32 * ret_flags, OM_uint32 * time_rec)\n{\n  OM_uint32 maj_stat;\n  _gss_mech_api_t mech;\n  int freecontext = 0;\n\n  if (output_token)\n    {\n      output_token->length = 0;\n      output_token->value = NULL;\n    }\n\n  if (ret_flags)\n    *ret_flags = 0;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT | GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  if (output_token == GSS_C_NO_BUFFER)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_FAILURE | GSS_S_CALL_BAD_STRUCTURE;\n    }\n\n  if (*context_handle == GSS_C_NO_CONTEXT)\n    mech = _gss_find_mech (mech_type);\n  else\n    mech = _gss_find_mech ((*context_handle)->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  if (actual_mech_type)\n    *actual_mech_type = mech->mech;\n\n  if (*context_handle == GSS_C_NO_CONTEXT)\n    {\n      *context_handle = calloc (sizeof (**context_handle), 1);\n      if (!*context_handle)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n      (*context_handle)->mech = mech->mech;\n      freecontext = 1;\n    }\n\n  maj_stat = mech->init_sec_context (minor_status,\n\t\t\t\t     initiator_cred_handle,\n\t\t\t\t     context_handle,\n\t\t\t\t     target_name,\n\t\t\t\t     mech_type,\n\t\t\t\t     req_flags,\n\t\t\t\t     time_req,\n\t\t\t\t     input_chan_bindings,\n\t\t\t\t     input_token,\n\t\t\t\t     actual_mech_type,\n\t\t\t\t     output_token, ret_flags, time_rec);\n\n  if (GSS_ERROR (maj_stat) && freecontext)\n    {\n      free (*context_handle);\n      *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n  return maj_stat;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_accept_sec_context": {
      "start_point": [
        683,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "OM_uint32\ngss_accept_sec_context (OM_uint32 * minor_status,\n\t\t\tgss_ctx_id_t * context_handle,\n\t\t\tconst gss_cred_id_t acceptor_cred_handle,\n\t\t\tconst gss_buffer_t input_token_buffer,\n\t\t\tconst gss_channel_bindings_t input_chan_bindings,\n\t\t\tgss_name_t * src_name,\n\t\t\tgss_OID * mech_type,\n\t\t\tgss_buffer_t output_token,\n\t\t\tOM_uint32 * ret_flags,\n\t\t\tOM_uint32 * time_rec,\n\t\t\tgss_cred_id_t * delegated_cred_handle)\n{\n  _gss_mech_api_t mech;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT | GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  if (*context_handle == GSS_C_NO_CONTEXT)\n    {\n      char *oid;\n      size_t oidlen;\n      gss_OID_desc oidbuf;\n      int rc;\n\n      rc = _gss_decapsulate_token (input_token_buffer->value,\n\t\t\t\t   input_token_buffer->length,\n\t\t\t\t   &oid, &oidlen, NULL, NULL);\n      if (rc != 0)\n\t{\n\t  if (minor_status)\n\t    *minor_status = 0;\n\t  return GSS_S_DEFECTIVE_TOKEN;\n\t}\n\n      oidbuf.elements = oid;\n      oidbuf.length = oidlen;\n\n      mech = _gss_find_mech_no_default (&oidbuf);\n    }\n  else\n    mech = _gss_find_mech_no_default ((*context_handle)->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  if (mech_type)\n    *mech_type = mech->mech;\n\n  return mech->accept_sec_context (minor_status,\n\t\t\t\t   context_handle,\n\t\t\t\t   acceptor_cred_handle,\n\t\t\t\t   input_token_buffer,\n\t\t\t\t   input_chan_bindings,\n\t\t\t\t   src_name,\n\t\t\t\t   mech_type,\n\t\t\t\t   output_token,\n\t\t\t\t   ret_flags,\n\t\t\t\t   time_rec, delegated_cred_handle);\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_delete_sec_context": {
      "start_point": [
        798,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "OM_uint32\ngss_delete_sec_context (OM_uint32 * minor_status,\n\t\t\tgss_ctx_id_t * context_handle,\n\t\t\tgss_buffer_t output_token)\n{\n  _gss_mech_api_t mech;\n  OM_uint32 ret;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT | GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  if (*context_handle == GSS_C_NO_CONTEXT)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT | GSS_S_CALL_BAD_STRUCTURE;\n    }\n\n  if (output_token != GSS_C_NO_BUFFER)\n    {\n      output_token->length = 0;\n      output_token->value = NULL;\n    }\n\n  mech = _gss_find_mech ((*context_handle)->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  ret = mech->delete_sec_context (NULL, context_handle, output_token);\n\n  free (*context_handle);\n  *context_handle = GSS_C_NO_CONTEXT;\n\n  return ret;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_process_context_token": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        881,
        1
      ],
      "content": "OM_uint32\ngss_process_context_token (OM_uint32 * minor_status,\n\t\t\t   const gss_ctx_id_t context_handle,\n\t\t\t   const gss_buffer_t token_buffer)\n{\n  return GSS_S_FAILURE;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_context_time": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        927,
        1
      ],
      "content": "OM_uint32\ngss_context_time (OM_uint32 * minor_status,\n\t\t  const gss_ctx_id_t context_handle, OM_uint32 * time_rec)\n{\n  _gss_mech_api_t mech;\n\n  if (context_handle == GSS_C_NO_CONTEXT)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT | GSS_S_CALL_BAD_STRUCTURE;\n    }\n\n  mech = _gss_find_mech (context_handle->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->context_time (minor_status, context_handle, time_rec);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_inquire_context": {
      "start_point": [
        1033,
        0
      ],
      "end_point": [
        1043,
        1
      ],
      "content": "OM_uint32\ngss_inquire_context (OM_uint32 * minor_status,\n\t\t     const gss_ctx_id_t context_handle,\n\t\t     gss_name_t * src_name,\n\t\t     gss_name_t * targ_name,\n\t\t     OM_uint32 * lifetime_rec,\n\t\t     gss_OID * mech_type,\n\t\t     OM_uint32 * ctx_flags, int *locally_initiated, int *open)\n{\n  return GSS_S_FAILURE;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_wrap_size_limit": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1105,
        1
      ],
      "content": "OM_uint32\ngss_wrap_size_limit (OM_uint32 * minor_status,\n\t\t     const gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     OM_uint32 req_output_size, OM_uint32 * max_input_size)\n{\n  return GSS_S_FAILURE;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_export_sec_context": {
      "start_point": [
        1168,
        0
      ],
      "end_point": [
        1174,
        1
      ],
      "content": "OM_uint32\ngss_export_sec_context (OM_uint32 * minor_status,\n\t\t\tgss_ctx_id_t * context_handle,\n\t\t\tgss_buffer_t interprocess_token)\n{\n  return GSS_S_UNAVAILABLE;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_import_sec_context": {
      "start_point": [
        1204,
        0
      ],
      "end_point": [
        1210,
        1
      ],
      "content": "OM_uint32\ngss_import_sec_context (OM_uint32 * minor_status,\n\t\t\tconst gss_buffer_t interprocess_token,\n\t\t\tgss_ctx_id_t * context_handle)\n{\n  return GSS_S_UNAVAILABLE;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/cred.c": {
    "gss_acquire_cred": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "OM_uint32\ngss_acquire_cred (OM_uint32 * minor_status,\n\t\t  const gss_name_t desired_name,\n\t\t  OM_uint32 time_req,\n\t\t  const gss_OID_set desired_mechs,\n\t\t  gss_cred_usage_t cred_usage,\n\t\t  gss_cred_id_t * output_cred_handle,\n\t\t  gss_OID_set * actual_mechs, OM_uint32 * time_rec)\n{\n  _gss_mech_api_t mech = NULL;\n  OM_uint32 maj_stat;\n\n  if (!output_cred_handle)\n    return GSS_S_NO_CRED | GSS_S_CALL_INACCESSIBLE_WRITE;\n\n  if (desired_mechs != GSS_C_NO_OID_SET)\n    {\n      size_t i;\n\n      /* Is the desired_mechs an \"OR\" or \"AND\" list?  I.e., if the OID\n         set contain several OIDs, MUST the credential work with all\n         of them?  Or just any of them?  The specification isn't\n         entirely clear on this, to me.  This implement an OR list,\n         chosing the first mechanism in the OID set we support.  We\n         need more information in meta.c to implement AND lists. */\n\n      for (i = 0; mech == NULL && i < desired_mechs->count; i++)\n\tmech = _gss_find_mech ((&desired_mechs->elements)[i]);\n    }\n  else\n    mech = _gss_find_mech (GSS_C_NO_OID);\n\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  *output_cred_handle = calloc (sizeof (**output_cred_handle), 1);\n  if (!*output_cred_handle)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  (*output_cred_handle)->mech = mech->mech;\n\n  maj_stat = mech->acquire_cred (minor_status,\n\t\t\t\t desired_name,\n\t\t\t\t time_req,\n\t\t\t\t desired_mechs,\n\t\t\t\t cred_usage,\n\t\t\t\t output_cred_handle, actual_mechs, time_rec);\n  if (GSS_ERROR (maj_stat))\n    {\n      free (*output_cred_handle);\n      *output_cred_handle = GSS_C_NO_CREDENTIAL;\n      return maj_stat;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 63,
      "depth": 14,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_add_cred": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "OM_uint32\ngss_add_cred (OM_uint32 * minor_status,\n\t      const gss_cred_id_t input_cred_handle,\n\t      const gss_name_t desired_name,\n\t      const gss_OID desired_mech,\n\t      gss_cred_usage_t cred_usage,\n\t      OM_uint32 initiator_time_req,\n\t      OM_uint32 acceptor_time_req,\n\t      gss_cred_id_t * output_cred_handle,\n\t      gss_OID_set * actual_mechs,\n\t      OM_uint32 * initiator_time_rec, OM_uint32 * acceptor_time_rec)\n{\n  return GSS_S_UNAVAILABLE;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_inquire_cred": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "OM_uint32\ngss_inquire_cred (OM_uint32 * minor_status,\n\t\t  const gss_cred_id_t cred_handle,\n\t\t  gss_name_t * name,\n\t\t  OM_uint32 * lifetime,\n\t\t  gss_cred_usage_t * cred_usage, gss_OID_set * mechanisms)\n{\n  gss_cred_id_t credh = cred_handle;\n  _gss_mech_api_t mech;\n  OM_uint32 maj_stat;\n\n  if (cred_handle == GSS_C_NO_CREDENTIAL)\n    {\n      maj_stat = gss_acquire_cred (minor_status, GSS_C_NO_NAME,\n\t\t\t\t   GSS_C_INDEFINITE, GSS_C_NO_OID_SET,\n\t\t\t\t   GSS_C_INITIATE, &credh, NULL, NULL);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  mech = _gss_find_mech (credh->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  maj_stat = mech->inquire_cred (minor_status, credh, name, lifetime,\n\t\t\t\t cred_usage, mechanisms);\n\n  if (cred_handle == GSS_C_NO_CREDENTIAL)\n    gss_release_cred (NULL, &credh);\n\n  return maj_stat;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_inquire_cred_by_mech": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "OM_uint32\ngss_inquire_cred_by_mech (OM_uint32 * minor_status,\n\t\t\t  const gss_cred_id_t cred_handle,\n\t\t\t  const gss_OID mech_type,\n\t\t\t  gss_name_t * name,\n\t\t\t  OM_uint32 * initiator_lifetime,\n\t\t\t  OM_uint32 * acceptor_lifetime,\n\t\t\t  gss_cred_usage_t * cred_usage)\n{\n  _gss_mech_api_t mech;\n  gss_cred_id_t credh = cred_handle;\n  OM_uint32 maj_stat;\n\n  if (mech_type == GSS_C_NO_OID)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  mech = _gss_find_mech (mech_type);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  if (cred_handle == GSS_C_NO_CREDENTIAL)\n    {\n      maj_stat = gss_acquire_cred (minor_status,\n\t\t\t\t   GSS_C_NO_NAME, GSS_C_INDEFINITE,\n\t\t\t\t   /* FIXME: We should create an OID\n\t\t\t\t      set with mech_type and pass it\n\t\t\t\t      as desired_mechs.  Maybe even\n\t\t\t\t      check actual_mechs too. */\n\t\t\t\t   GSS_C_NO_OID_SET,\n\t\t\t\t   GSS_C_INITIATE, &credh, NULL, NULL);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  maj_stat = mech->inquire_cred_by_mech (minor_status, credh, mech_type, name,\n\t\t\t\t\t initiator_lifetime,\n\t\t\t\t\t acceptor_lifetime, cred_usage);\n\n  if (cred_handle == GSS_C_NO_CREDENTIAL)\n    gss_release_cred (NULL, &credh);\n\n  return maj_stat;\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_release_cred": {
      "start_point": [
        528,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "OM_uint32\ngss_release_cred (OM_uint32 * minor_status, gss_cred_id_t * cred_handle)\n{\n  _gss_mech_api_t mech;\n  OM_uint32 maj_stat;\n\n  if (!cred_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CRED | GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  if (*cred_handle == GSS_C_NO_CREDENTIAL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_COMPLETE;\n    }\n\n  mech = _gss_find_mech ((*cred_handle)->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_DEFECTIVE_CREDENTIAL;\n    }\n\n  maj_stat = mech->release_cred (minor_status, cred_handle);\n  free (*cred_handle);\n  *cred_handle = GSS_C_NO_CREDENTIAL;\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/error.c": {
    "gss_display_status": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "OM_uint32\ngss_display_status (OM_uint32 * minor_status,\n\t\t    OM_uint32 status_value,\n\t\t    int status_type,\n\t\t    const gss_OID mech_type,\n\t\t    OM_uint32 * message_context, gss_buffer_t status_string)\n{\n  size_t i;\n\n  bindtextdomain (PACKAGE PO_SUFFIX, LOCALEDIR);\n\n  if (minor_status)\n    *minor_status = 0;\n\n  if (message_context)\n    status_value &= ~*message_context;\n\n  switch (status_type)\n    {\n    case GSS_C_GSS_CODE:\n      if (message_context)\n\t{\n\t  *message_context |=\n\t    GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET;\n\t  if ((status_value & ~*message_context) == 0)\n\t    *message_context = 0;\n\t}\n\n      switch (GSS_ROUTINE_ERROR (status_value))\n\t{\n\tcase 0:\n\t  break;\n\n\tcase GSS_S_BAD_MECH:\n\tcase GSS_S_BAD_NAME:\n\tcase GSS_S_BAD_NAMETYPE:\n\tcase GSS_S_BAD_BINDINGS:\n\tcase GSS_S_BAD_STATUS:\n\tcase GSS_S_BAD_SIG:\n\tcase GSS_S_NO_CRED:\n\tcase GSS_S_NO_CONTEXT:\n\tcase GSS_S_DEFECTIVE_TOKEN:\n\tcase GSS_S_DEFECTIVE_CREDENTIAL:\n\tcase GSS_S_CREDENTIALS_EXPIRED:\n\tcase GSS_S_CONTEXT_EXPIRED:\n\tcase GSS_S_FAILURE:\n\tcase GSS_S_BAD_QOP:\n\tcase GSS_S_UNAUTHORIZED:\n\tcase GSS_S_UNAVAILABLE:\n\tcase GSS_S_DUPLICATE_ELEMENT:\n\tcase GSS_S_NAME_NOT_MN:\n\t  status_string->value =\n\t    strdup (_(gss_routine_errors\n\t\t      [(GSS_ROUTINE_ERROR (status_value) >>\n\t\t\tGSS_C_ROUTINE_ERROR_OFFSET) - 1].text));\n\t  if (!status_string->value)\n\t    {\n\t      if (minor_status)\n\t\t*minor_status = ENOMEM;\n\t      return GSS_S_FAILURE;\n\t    }\n\t  status_string->length = strlen (status_string->value);\n\t  return GSS_S_COMPLETE;\n\t  break;\n\n\tdefault:\n\t  return GSS_S_BAD_STATUS;\n\t  break;\n\t}\n\n      if (message_context)\n\t{\n\t  *message_context |=\n\t    GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET;\n\t  if ((status_value & ~*message_context) == 0)\n\t    *message_context = 0;\n\t}\n\n      switch (GSS_CALLING_ERROR (status_value))\n\t{\n\tcase 0:\n\t  break;\n\n\tcase GSS_S_CALL_INACCESSIBLE_READ:\n\tcase GSS_S_CALL_INACCESSIBLE_WRITE:\n\tcase GSS_S_CALL_BAD_STRUCTURE:\n\t  status_string->value =\n\t    strdup (_(gss_calling_errors\n\t\t      [(GSS_CALLING_ERROR (status_value) >>\n\t\t\tGSS_C_CALLING_ERROR_OFFSET) - 1].text));\n\t  if (!status_string->value)\n\t    {\n\t      if (minor_status)\n\t\t*minor_status = ENOMEM;\n\t      return GSS_S_FAILURE;\n\t    }\n\t  status_string->length = strlen (status_string->value);\n\t  return GSS_S_COMPLETE;\n\t  break;\n\n\tdefault:\n\t  return GSS_S_BAD_STATUS;\n\t  break;\n\t}\n\n      for (i = 0; i < sizeof (gss_supplementary_errors) /\n\t   sizeof (gss_supplementary_errors[0]); i++)\n\tif (gss_supplementary_errors[i].err &\n\t    GSS_SUPPLEMENTARY_INFO (status_value))\n\t  {\n\t    status_string->value =\n\t      strdup (_(gss_supplementary_errors[i].text));\n\t    if (!status_string->value)\n\t      {\n\t\tif (minor_status)\n\t\t  *minor_status = ENOMEM;\n\t\treturn GSS_S_FAILURE;\n\t      }\n\t    status_string->length = strlen (status_string->value);\n\t    *message_context |= gss_supplementary_errors[i].err;\n\t    if ((status_value & ~*message_context) == 0)\n\t      *message_context = 0;\n\t    return GSS_S_COMPLETE;\n\t  }\n\n      if (GSS_SUPPLEMENTARY_INFO (status_value))\n\treturn GSS_S_BAD_STATUS;\n\n      if (message_context)\n\t*message_context = 0;\n      status_string->value = strdup (_(\"No error\"));\n      if (!status_string->value)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n      status_string->length = strlen (status_string->value);\n      break;\n\n    case GSS_C_MECH_CODE:\n      {\n\t_gss_mech_api_t mech;\n\n\tmech = _gss_find_mech (mech_type);\n\treturn mech->display_status (minor_status, status_value, status_type,\n\t\t\t\t     mech_type, message_context,\n\t\t\t\t     status_string);\n      }\n      break;\n\n    default:\n      return GSS_S_BAD_STATUS;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 157,
      "depth": 22,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/ext.c": {
    "gss_userok": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\ngss_userok (const gss_name_t name, const char *username)\n{\n  /* FIXME: Call gss_export_name, then remove OID. */\n  return name->length == strlen (username) &&\n    memcmp (name->value, username, name->length) == 0;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/lib/internal.h": {},
  "gss/gss-1.0.3/lib/meta.c": {
    "_gss_find_mech_no_default": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "_gss_mech_api_t\n_gss_find_mech_no_default (const gss_OID oid)\n{\n  size_t i;\n\n  for (i = 0; _gss_mech_apis[i].mech; i++)\n    if (gss_oid_equal (oid, _gss_mech_apis[i].mech))\n      return &_gss_mech_apis[i];\n\n  return NULL;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "_gss_mech_api_t"
      ]
    },
    "_gss_find_mech": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "_gss_mech_api_t\n_gss_find_mech (const gss_OID oid)\n{\n  _gss_mech_api_t p = _gss_find_mech_no_default (oid);\n\n  if (!p && _gss_mech_apis[0].mech)\n    /* FIXME.  When we support more than one mechanism, make it possible\n       to configure the default mechanism. */\n    return &_gss_mech_apis[0];\n\n  return p;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "_gss_mech_api_t"
      ]
    },
    "_gss_find_mech_by_saslname": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "_gss_mech_api_t\n_gss_find_mech_by_saslname (const gss_buffer_t sasl_mech_name)\n{\n  size_t i;\n\n  if (sasl_mech_name == NULL\n      || sasl_mech_name->value == NULL || sasl_mech_name->length == 0)\n    return NULL;\n\n  for (i = 0; _gss_mech_apis[i].mech; i++)\n    if (strlen (_gss_mech_apis[i].sasl_name) == sasl_mech_name->length &&\n\tmemcmp (_gss_mech_apis[i].sasl_name, sasl_mech_name->value,\n\t\tsasl_mech_name->length) == 0)\n      return &_gss_mech_apis[i];\n\n  return NULL;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "_gss_mech_api_t"
      ]
    },
    "_gss_indicate_mechs1": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "OM_uint32\n_gss_indicate_mechs1 (OM_uint32 * minor_status, gss_OID_set * mech_set)\n{\n  OM_uint32 maj_stat;\n  int i;\n\n  for (i = 0; _gss_mech_apis[i].mech; i++)\n    {\n      maj_stat = gss_add_oid_set_member (minor_status,\n\t\t\t\t\t _gss_mech_apis[i].mech, mech_set);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/meta.h": {},
  "gss/gss-1.0.3/lib/misc.c": {
    "gss_create_empty_oid_set": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "OM_uint32\ngss_create_empty_oid_set (OM_uint32 * minor_status, gss_OID_set * oid_set)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  *oid_set = malloc (sizeof (**oid_set));\n  if (!*oid_set)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  (*oid_set)->count = 0;\n  (*oid_set)->elements = NULL;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "_gss_copy_oid": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static OM_uint32\n_gss_copy_oid (OM_uint32 * minor_status,\n\t       const gss_OID src_oid, gss_OID dest_oid)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  if (!src_oid)\n    return GSS_S_FAILURE | GSS_S_CALL_INACCESSIBLE_READ;\n\n  if (src_oid->length == 0 || src_oid->elements == NULL)\n    return GSS_S_FAILURE | GSS_S_CALL_BAD_STRUCTURE;\n\n  dest_oid->length = src_oid->length;\n  dest_oid->elements = malloc (src_oid->length);\n  if (!dest_oid->elements)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  memcpy (dest_oid->elements, src_oid->elements, src_oid->length);\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_add_oid_set_member": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "OM_uint32\ngss_add_oid_set_member (OM_uint32 * minor_status,\n\t\t\tconst gss_OID member_oid, gss_OID_set * oid_set)\n{\n  OM_uint32 major_stat;\n  int present;\n\n  if (!member_oid || member_oid->length == 0 || member_oid->elements == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_FAILURE;\n    }\n\n  major_stat = gss_test_oid_set_member (minor_status, member_oid,\n\t\t\t\t\t*oid_set, &present);\n  if (GSS_ERROR (major_stat))\n    return major_stat;\n\n  if (present)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_COMPLETE;\n    }\n\n  if ((*oid_set)->count + 1 == 0)\t/* integer overflow */\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_FAILURE;\n    }\n\n  (*oid_set)->count++;\n  {\n    gss_OID tmp;\n\n    tmp = realloc ((*oid_set)->elements, (*oid_set)->count *\n\t\t   sizeof (*(*oid_set)->elements));\n    if (!tmp)\n      {\n\tif (minor_status)\n\t  *minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n      }\n\n    (*oid_set)->elements = tmp;\n  }\n\n  major_stat = _gss_copy_oid (minor_status, member_oid,\n\t\t\t      (*oid_set)->elements + ((*oid_set)->count - 1));\n  if (GSS_ERROR (major_stat))\n    return major_stat;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_test_oid_set_member": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "OM_uint32\ngss_test_oid_set_member (OM_uint32 * minor_status,\n\t\t\t const gss_OID member,\n\t\t\t const gss_OID_set set, int *present)\n{\n  gss_OID cur;\n  size_t i;\n\n  if (minor_status)\n    *minor_status = 0;\n\n  *present = 0;\n\n  if (member == GSS_C_NO_OID)\n    return GSS_S_COMPLETE;\n\n  for (i = 0, cur = set->elements; i < set->count; i++, cur++)\n    {\n      if (cur->length == member->length &&\n\t  memcmp (cur->elements, member->elements, member->length) == 0)\n\t{\n\t  *present = 1;\n\t  return GSS_S_COMPLETE;\n\t}\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_release_oid_set": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "OM_uint32\ngss_release_oid_set (OM_uint32 * minor_status, gss_OID_set * set)\n{\n  gss_OID cur;\n  size_t i;\n\n  if (minor_status)\n    *minor_status = 0;\n\n  if (!set || *set == GSS_C_NO_OID_SET)\n    return GSS_S_COMPLETE;\n\n  for (i = 0, cur = (*set)->elements; i < (*set)->count; i++, cur++)\n    free (cur->elements);\n  free ((*set)->elements);\n  free (*set);\n  *set = GSS_C_NO_OID_SET;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_indicate_mechs": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "OM_uint32\ngss_indicate_mechs (OM_uint32 * minor_status, gss_OID_set * mech_set)\n{\n  OM_uint32 maj_stat;\n\n  maj_stat = gss_create_empty_oid_set (minor_status, mech_set);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  maj_stat = _gss_indicate_mechs1 (minor_status, mech_set);\n  if (GSS_ERROR (maj_stat))\n    {\n      gss_release_oid_set (NULL, mech_set);\n      return maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_release_buffer": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "OM_uint32\ngss_release_buffer (OM_uint32 * minor_status, gss_buffer_t buffer)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  if (buffer != GSS_C_NO_BUFFER)\n    {\n      free (buffer->value);\n      buffer->value = NULL;\n      buffer->length = 0;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/msg.c": {
    "gss_get_mic": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "OM_uint32\ngss_get_mic (OM_uint32 * minor_status,\n\t     const gss_ctx_id_t context_handle,\n\t     gss_qop_t qop_req,\n\t     const gss_buffer_t message_buffer, gss_buffer_t message_token)\n{\n  _gss_mech_api_t mech;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT;\n    }\n\n  mech = _gss_find_mech (context_handle->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->get_mic (minor_status, context_handle, qop_req,\n\t\t\tmessage_buffer, message_token);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_verify_mic": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "OM_uint32\ngss_verify_mic (OM_uint32 * minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t message_buffer,\n\t\tconst gss_buffer_t token_buffer, gss_qop_t * qop_state)\n{\n  _gss_mech_api_t mech;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT;\n    }\n\n  mech = _gss_find_mech (context_handle->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->verify_mic (minor_status, context_handle,\n\t\t\t   message_buffer, token_buffer, qop_state);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_wrap": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "OM_uint32\ngss_wrap (OM_uint32 * minor_status,\n\t  const gss_ctx_id_t context_handle,\n\t  int conf_req_flag,\n\t  gss_qop_t qop_req,\n\t  const gss_buffer_t input_message_buffer,\n\t  int *conf_state, gss_buffer_t output_message_buffer)\n{\n  _gss_mech_api_t mech;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT;\n    }\n\n  mech = _gss_find_mech (context_handle->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->wrap (minor_status, context_handle, conf_req_flag, qop_req,\n\t\t     input_message_buffer, conf_state, output_message_buffer);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_unwrap": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "OM_uint32\ngss_unwrap (OM_uint32 * minor_status,\n\t    const gss_ctx_id_t context_handle,\n\t    const gss_buffer_t input_message_buffer,\n\t    gss_buffer_t output_message_buffer,\n\t    int *conf_state, gss_qop_t * qop_state)\n{\n  _gss_mech_api_t mech;\n\n  if (!context_handle)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_NO_CONTEXT;\n    }\n\n  mech = _gss_find_mech (context_handle->mech);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->unwrap (minor_status, context_handle, input_message_buffer,\n\t\t       output_message_buffer, conf_state, qop_state);\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/name.c": {
    "gss_import_name": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "OM_uint32\ngss_import_name (OM_uint32 * minor_status,\n\t\t const gss_buffer_t input_name_buffer,\n\t\t const gss_OID input_name_type, gss_name_t * output_name)\n{\n  if (!output_name)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_NAME | GSS_S_CALL_INACCESSIBLE_WRITE;\n    }\n\n  *output_name = malloc (sizeof (**output_name));\n  if (!*output_name)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  (*output_name)->length = input_name_buffer->length;\n  (*output_name)->value = malloc (input_name_buffer->length);\n  if (!(*output_name)->value)\n    {\n      free (*output_name);\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  memcpy ((*output_name)->value,\n\t  input_name_buffer->value, input_name_buffer->length);\n\n  (*output_name)->type = input_name_type;\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_display_name": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "OM_uint32\ngss_display_name (OM_uint32 * minor_status,\n\t\t  const gss_name_t input_name,\n\t\t  gss_buffer_t output_name_buffer, gss_OID * output_name_type)\n{\n  if (!input_name)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_NAME;\n    }\n\n  output_name_buffer->length = input_name->length;\n  output_name_buffer->value = malloc (input_name->length + 1);\n  if (!output_name_buffer->value)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  if (input_name->value)\n    memcpy (output_name_buffer->value, input_name->value, input_name->length);\n\n  if (output_name_type)\n    *output_name_type = input_name->type;\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_compare_name": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "OM_uint32\ngss_compare_name (OM_uint32 * minor_status,\n\t\t  const gss_name_t name1,\n\t\t  const gss_name_t name2, int *name_equal)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  if (!name1 || !name2)\n    return GSS_S_BAD_NAME | GSS_S_CALL_INACCESSIBLE_READ;\n\n  if (!gss_oid_equal (name1->type, name2->type))\n    return GSS_S_BAD_NAMETYPE;\n\n  if (name_equal)\n    *name_equal = (name1->length == name2->length) &&\n      memcmp (name1->value, name2->value, name1->length) == 0;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_release_name": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "OM_uint32\ngss_release_name (OM_uint32 * minor_status, gss_name_t * name)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  if (!name)\n    return GSS_S_BAD_NAME | GSS_S_CALL_INACCESSIBLE_READ;\n\n  if (*name != GSS_C_NO_NAME)\n    {\n      if ((*name)->value)\n\tfree ((*name)->value);\n\n      free (*name);\n      *name = GSS_C_NO_NAME;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_inquire_names_for_mech": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "OM_uint32\ngss_inquire_names_for_mech (OM_uint32 * minor_status,\n\t\t\t    const gss_OID mechanism, gss_OID_set * name_types)\n{\n  OM_uint32 maj_stat;\n  _gss_mech_api_t mech;\n  int i;\n\n  mech = _gss_find_mech (mechanism);\n\n  maj_stat = gss_create_empty_oid_set (minor_status, name_types);\n  if (maj_stat != GSS_S_COMPLETE)\n    return maj_stat;\n\n  for (i = 0; mech->name_types[i]; i++)\n    {\n      maj_stat = gss_add_oid_set_member (minor_status, mech->name_types[i],\n\t\t\t\t\t name_types);\n      if (maj_stat != GSS_S_COMPLETE)\n\t{\n\t  gss_release_oid_set (minor_status, name_types);\n\t  return maj_stat;\n\t}\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "_gss_inquire_mechs_for_name3": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static OM_uint32\n_gss_inquire_mechs_for_name3 (OM_uint32 * minor_status,\n\t\t\t      gss_OID mech,\n\t\t\t      gss_OID name_type, gss_OID_set * mech_types)\n{\n  gss_OID_set oids;\n  int supported;\n  OM_uint32 maj_stat;\n\n  maj_stat = gss_inquire_names_for_mech (minor_status, mech, &oids);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  maj_stat = gss_test_oid_set_member (minor_status, name_type,\n\t\t\t\t      oids, &supported);\n  gss_release_oid_set (minor_status, &oids);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  if (supported)\n    {\n      maj_stat = gss_add_oid_set_member (minor_status, mech, mech_types);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "_gss_inquire_mechs_for_name2": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static OM_uint32\n_gss_inquire_mechs_for_name2 (OM_uint32 * minor_status,\n\t\t\t      gss_OID name_type,\n\t\t\t      gss_OID_set * out_mech_types,\n\t\t\t      gss_OID_set supported_mech_types)\n{\n  OM_uint32 maj_stat;\n  size_t i;\n\n  for (i = 0; i < supported_mech_types->count; i++)\n    {\n      maj_stat = _gss_inquire_mechs_for_name3\n\t(minor_status, &(supported_mech_types->elements)[i],\n\t name_type, out_mech_types);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "_gss_inquire_mechs_for_name1": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "static OM_uint32\n_gss_inquire_mechs_for_name1 (OM_uint32 * minor_status,\n\t\t\t      gss_OID name_type, gss_OID_set * out_mech_types)\n{\n  OM_uint32 maj_stat;\n  gss_OID_set supported_mech_types;\n\n  maj_stat = gss_indicate_mechs (minor_status, &supported_mech_types);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  maj_stat = _gss_inquire_mechs_for_name2 (minor_status, name_type,\n\t\t\t\t\t   out_mech_types,\n\t\t\t\t\t   supported_mech_types);\n  gss_release_oid_set (minor_status, &supported_mech_types);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_inquire_mechs_for_name": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "OM_uint32\ngss_inquire_mechs_for_name (OM_uint32 * minor_status,\n\t\t\t    const gss_name_t input_name,\n\t\t\t    gss_OID_set * mech_types)\n{\n  OM_uint32 maj_stat;\n\n  if (input_name == GSS_C_NO_NAME)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_NAME | GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  maj_stat = gss_create_empty_oid_set (minor_status, mech_types);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  maj_stat = _gss_inquire_mechs_for_name1 (minor_status,\n\t\t\t\t\t   input_name->type, mech_types);\n  if (GSS_ERROR (maj_stat))\n    {\n      gss_release_oid_set (minor_status, mech_types);\n      return maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_export_name": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        499,
        1
      ],
      "content": "OM_uint32\ngss_export_name (OM_uint32 * minor_status,\n\t\t const gss_name_t input_name, gss_buffer_t exported_name)\n{\n  OM_uint32 maj_stat;\n  gss_OID_set mechs;\n  _gss_mech_api_t mech;\n\n  maj_stat = gss_inquire_mechs_for_name (minor_status, input_name, &mechs);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  if (mechs->count == 0)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_NAMETYPE;\n    }\n\n  /* We just select a random mechanism that support this name-type.\n     I'm not sure how we can be more predicatable, given the\n     definition of this function. */\n\n  mech = _gss_find_mech (mechs->elements);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->export_name (minor_status, input_name, exported_name);\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_canonicalize_name": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "OM_uint32\ngss_canonicalize_name (OM_uint32 * minor_status,\n\t\t       const gss_name_t input_name,\n\t\t       const gss_OID mech_type, gss_name_t * output_name)\n{\n  _gss_mech_api_t mech;\n\n  mech = _gss_find_mech (mech_type);\n  if (mech == NULL)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  return mech->canonicalize_name (minor_status, input_name,\n\t\t\t\t  mech_type, output_name);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_duplicate_name": {
      "start_point": [
        563,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "OM_uint32\ngss_duplicate_name (OM_uint32 * minor_status,\n\t\t    const gss_name_t src_name, gss_name_t * dest_name)\n{\n  if (src_name == GSS_C_NO_NAME)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_NAME;\n    }\n\n  if (!dest_name)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_FAILURE | GSS_S_CALL_INACCESSIBLE_WRITE;\n    }\n\n  *dest_name = malloc (sizeof (**dest_name));\n  if (!*dest_name)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  (*dest_name)->type = src_name->type;\n  (*dest_name)->length = src_name->length;\n  (*dest_name)->value = malloc (src_name->length + 1);\n  if (!(*dest_name)->value)\n    {\n      free (*dest_name);\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  memcpy ((*dest_name)->value, src_name->value, src_name->length);\n  (*dest_name)->value[src_name->length] = '\\0';\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/obsolete.c": {
    "gss_sign": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "OM_uint32\ngss_sign (OM_uint32 * minor_status,\n\t  gss_ctx_id_t context_handle,\n\t  int qop_req,\n\t  gss_buffer_t message_buffer, gss_buffer_t message_token)\n{\n  return gss_get_mic (minor_status, context_handle,\n\t\t      (gss_qop_t) qop_req, message_buffer, message_token);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_verify": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "OM_uint32\ngss_verify (OM_uint32 * minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_buffer_t message_buffer,\n\t    gss_buffer_t token_buffer, int *qop_state)\n{\n  return gss_verify_mic (minor_status, context_handle, message_buffer,\n\t\t\t token_buffer, (gss_qop_t *) qop_state);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_seal": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "OM_uint32\ngss_seal (OM_uint32 * minor_status,\n\t  gss_ctx_id_t context_handle,\n\t  int conf_req_flag,\n\t  int qop_req,\n\t  gss_buffer_t input_message_buffer,\n\t  int *conf_state, gss_buffer_t output_message_buffer)\n{\n  return gss_wrap (minor_status, context_handle, conf_req_flag,\n\t\t   (gss_qop_t) qop_req,\n\t\t   input_message_buffer, conf_state, output_message_buffer);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_unseal": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "OM_uint32\ngss_unseal (OM_uint32 * minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_buffer_t input_message_buffer,\n\t    gss_buffer_t output_message_buffer,\n\t    int *conf_state, int *qop_state)\n{\n  return gss_unwrap (minor_status, context_handle, input_message_buffer,\n\t\t     output_message_buffer, conf_state,\n\t\t     (gss_qop_t *) qop_state);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/oid.c": {
    "gss_oid_equal": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\ngss_oid_equal (gss_const_OID first_oid, gss_const_OID second_oid)\n{\n  return first_oid && second_oid &&\n    first_oid->length == second_oid->length &&\n    memcmp (first_oid->elements, second_oid->elements,\n\t    second_oid->length) == 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/lib/saslname.c": {
    "dup_data": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static OM_uint32\ndup_data (OM_uint32 * minor_status,\n\t  gss_buffer_t out, const char *str, int translate)\n{\n  if (!out)\n    return GSS_S_COMPLETE;\n\n  if (translate)\n    out->value = strdup (_(str));\n  else\n    out->value = strdup (str);\n  if (!out->value)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n  out->length = strlen (str);\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_inquire_saslname_for_mech": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "OM_uint32\ngss_inquire_saslname_for_mech (OM_uint32 * minor_status,\n\t\t\t       const gss_OID desired_mech,\n\t\t\t       gss_buffer_t sasl_mech_name,\n\t\t\t       gss_buffer_t mech_name,\n\t\t\t       gss_buffer_t mech_description)\n{\n  _gss_mech_api_t m;\n\n  if (!desired_mech)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  m = _gss_find_mech_no_default (desired_mech);\n  if (!m)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  bindtextdomain (PACKAGE PO_SUFFIX, LOCALEDIR);\n\n  if (dup_data (minor_status, sasl_mech_name,\n\t\tm->sasl_name, 0) != GSS_S_COMPLETE)\n    return GSS_S_FAILURE;\n  if (dup_data (minor_status, mech_name, m->mech_name, 0) != GSS_S_COMPLETE)\n    {\n      if (sasl_mech_name)\n\tfree (sasl_mech_name->value);\n      return GSS_S_FAILURE;\n    }\n  if (dup_data (minor_status, mech_description,\n\t\tm->mech_description, 1) != GSS_S_COMPLETE)\n    {\n      if (sasl_mech_name)\n\tfree (sasl_mech_name->value);\n      if (mech_name)\n\tfree (mech_name->value);\n      return GSS_S_FAILURE;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 47,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_inquire_mech_for_saslname": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "OM_uint32\ngss_inquire_mech_for_saslname (OM_uint32 * minor_status,\n\t\t\t       const gss_buffer_t sasl_mech_name,\n\t\t\t       gss_OID * mech_type)\n{\n  _gss_mech_api_t m;\n\n  if (!sasl_mech_name)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_CALL_INACCESSIBLE_READ;\n    }\n\n  m = _gss_find_mech_by_saslname (sasl_mech_name);\n  if (!m)\n    {\n      if (minor_status)\n\t*minor_status = 0;\n      return GSS_S_BAD_MECH;\n    }\n\n  if (mech_type)\n    *mech_type = m->mech;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/version.c": {
    "gss_check_version": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "const char *\ngss_check_version (const char *req_version)\n{\n  if (!req_version || strverscmp (req_version, PACKAGE_VERSION) <= 0)\n    return PACKAGE_VERSION;\n\n  return NULL;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngss_check_version (const char *req_version)",
        "*"
      ]
    }
  },
  "gss/gss-1.0.3/lib/gl/dummy.c": {},
  "gss/gss-1.0.3/lib/gl/gettext.h": {},
  "gss/gss-1.0.3/lib/gl/stddef.in.h": {},
  "gss/gss-1.0.3/lib/gl/string.in.h": {},
  "gss/gss-1.0.3/lib/gl/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others  (padding)\n     Transition   (10) 0  (01) d  (00) x  (11) -   */\n  static const unsigned int next_state[] =\n  {\n      /* state    x    d    0    - */\n      /* S_N */  S_N, S_I, S_Z, S_N,\n      /* S_I */  S_N, S_I, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z, S_Z\n  };\n\n  static const int result_type[] =\n  {\n      /* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-\n                 0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */\n\n      /* S_N */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  CMP,  1,  LEN, LEN, CMP,\n                  1,  LEN, LEN, CMP, CMP, CMP, CMP, CMP,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP,  1,   1,  CMP, -1,  CMP, CMP, CMP,\n                 -1,  CMP, CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N | ((c1 == '0') + (ISDIGIT (c1) != 0));\n\n  while ((diff = c1 - c2) == 0 && c1 != '\\0')\n    {\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state |= (c1 == '0') + (ISDIGIT (c1) != 0);\n    }\n\n  state = result_type[state << 2 | ((c2 == '0') + (ISDIGIT (c2) != 0))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (ISDIGIT (*p1++))\n        if (!ISDIGIT (*p2++))\n          return 1;\n\n      return ISDIGIT (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/lib/headers/gss.h": {},
  "gss/gss-1.0.3/lib/headers/gss/api.h": {},
  "gss/gss-1.0.3/lib/headers/gss/ext.h": {},
  "gss/gss-1.0.3/lib/headers/gss/krb5-ext.h": {},
  "gss/gss-1.0.3/lib/headers/gss/krb5.h": {},
  "gss/gss-1.0.3/lib/krb5/checksum.c": {
    "pack_uint32": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\npack_uint32 (OM_uint32 i, char *buf)\n{\n  buf[0] = i & 0xFF;\n  buf[1] = (i >> 8) & 0xFF;\n  buf[2] = (i >> 16) & 0xFF;\n  buf[3] = (i >> 24) & 0xFF;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_cb": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static int\nhash_cb (OM_uint32 * minor_status,\n\t gss_ctx_id_t * context_handle,\n\t const gss_channel_bindings_t input_chan_bindings, char **out)\n{\n  gss_ctx_id_t ctx = *context_handle;\n  _gss_krb5_ctx_t k5 = ctx->krb5;\n  char *buf, *p;\n  size_t len;\n  int res;\n\n  if (input_chan_bindings->initiator_address.length > UINT32_MAX ||\n      input_chan_bindings->acceptor_address.length > UINT32_MAX ||\n      input_chan_bindings->application_data.length > UINT32_MAX)\n    return GSS_S_BAD_BINDINGS;\n\n  len = sizeof (OM_uint32) * 5\n    + input_chan_bindings->initiator_address.length\n    + input_chan_bindings->acceptor_address.length\n    + input_chan_bindings->application_data.length;\n  p = buf = malloc (len);\n  if (!buf)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  pack_uint32 (input_chan_bindings->initiator_addrtype, p);\n  p += sizeof (OM_uint32);\n  pack_uint32 (input_chan_bindings->initiator_address.length, p);\n  p += sizeof (OM_uint32);\n  if (input_chan_bindings->initiator_address.length > 0)\n    {\n      memcpy (p, input_chan_bindings->initiator_address.value,\n\t      input_chan_bindings->initiator_address.length);\n      p += input_chan_bindings->initiator_address.length;\n    }\n  pack_uint32 (input_chan_bindings->acceptor_addrtype, p);\n  p += sizeof (OM_uint32);\n  pack_uint32 (input_chan_bindings->acceptor_address.length, p);\n  p += sizeof (OM_uint32);\n  if (input_chan_bindings->acceptor_address.length > 0)\n    {\n      memcpy (p, input_chan_bindings->acceptor_address.value,\n\t      input_chan_bindings->acceptor_address.length);\n      p += input_chan_bindings->acceptor_address.length;\n    }\n  pack_uint32 (input_chan_bindings->application_data.length, p);\n  p += sizeof (OM_uint32);\n  if (input_chan_bindings->application_data.length > 0)\n    memcpy (p, input_chan_bindings->application_data.value,\n\t    input_chan_bindings->application_data.length);\n\n  res = shishi_md5 (k5->sh, buf, len, out);\n  free (buf);\n  if (res != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_gss_krb5_checksum_pack": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "OM_uint32\n_gss_krb5_checksum_pack (OM_uint32 * minor_status,\n\t\t\t const gss_cred_id_t initiator_cred_handle,\n\t\t\t gss_ctx_id_t * context_handle,\n\t\t\t const gss_channel_bindings_t input_chan_bindings,\n\t\t\t OM_uint32 req_flags, char **data, size_t * datalen)\n{\n  char *p;\n\n  *datalen = 24;\n  p = *data = malloc (*datalen);\n  if (!p)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  /*\n   * RFC 1964 / gssapi-cfx:\n   *\n   * The checksum value field's format is as follows:\n   *\n   * Byte    Name    Description\n   * 0..3    Lgth    Number of bytes in Bnd field;\n   *                 Currently contains hex 10 00 00 00\n   *                 (16, represented in little-endian form)\n   */\n\n  memcpy (&p[0], \"\\x10\\x00\\x00\\x00\", 4);\t/* length of Bnd */\n\n  /*\n   * 4..19   Bnd     MD5 hash of channel bindings, taken over all non-null\n   *                 components of bindings, in order of declaration.\n   *                 Integer fields within channel bindings are represented\n   *                 in little-endian order for the purposes of the MD5\n   *                 calculation.\n   *\n   *   In computing the contents of the \"Bnd\" field, the following detailed\n   *   points apply:\n   *\n   *   (1) Each integer field shall be formatted into four bytes, using\n   *   little-endian byte ordering, for purposes of MD5 hash\n   *   computation.\n   *\n   *   (2) All input length fields within gss_buffer_desc elements of a\n   *   gss_channel_bindings_struct, even those which are zero-valued,\n   *   shall be included in the hash calculation; the value elements of\n   *   gss_buffer_desc elements shall be dereferenced, and the\n   *   resulting data shall be included within the hash computation,\n   *   only for the case of gss_buffer_desc elements having non-zero\n   *   length specifiers.\n   *\n   *   (3) If the caller passes the value GSS_C_NO_BINDINGS instead of\n   *   a valid channel bindings structure, the Bnd field shall be set\n   *   to 16 zero-valued bytes.\n   *\n   */\n\n  if (input_chan_bindings != GSS_C_NO_CHANNEL_BINDINGS)\n    {\n      char *md5hash;\n      int res;\n\n      res = hash_cb (minor_status, context_handle,\n\t\t     input_chan_bindings, &md5hash);\n      if (res != GSS_S_COMPLETE)\n\t{\n\t  free (p);\n\t  return res;\n\t}\n\n      memcpy (&p[4], md5hash, 16);\n      free (md5hash);\n    }\n  else\n    memset (&p[4], 0, 16);\n\n  /*\n   * 20..23  Flags   Bit vector of context-establishment flags,\n   *                 with values consistent with RFC-1509, p. 41:\n   *                         GSS_C_DELEG_FLAG:       1\n   *                         GSS_C_MUTUAL_FLAG:      2\n   *                         GSS_C_REPLAY_FLAG:      4\n   *                         GSS_C_SEQUENCE_FLAG:    8\n   *                         GSS_C_CONF_FLAG:        16\n   *                         GSS_C_INTEG_FLAG:       32\n   *                 The resulting bit vector is encoded into bytes 20..23\n   *                 in little-endian form.\n   */\n\n  req_flags &=\t\t\t/* GSS_C_DELEG_FLAG | */\n    GSS_C_MUTUAL_FLAG |\n    GSS_C_REPLAY_FLAG | GSS_C_SEQUENCE_FLAG |\n    GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG;\n\n  p[20] = req_flags & 0xFF;\n  p[21] = (req_flags >> 8) & 0xFF;\n  p[22] = (req_flags >> 16) & 0xFF;\n  p[23] = (req_flags >> 24) & 0xFF;\n\n  /*\n   *    24..25       DlgOpt  The delegation option identifier (=1) in\n   *                 little-endian order [optional].  This field\n   *                 and the next two fields are present if and\n   *                 only if GSS_C_DELEG_FLAG is set as described\n   *                 in section 4.1.1.1.\n   *    26..27       Dlgth   The length of the Deleg field in little-\n   *                 endian order [optional].\n   *    28..(n-1)    Deleg   A KRB_CRED message (n = Dlgth + 28)\n   *                 [optional].\n   *    n..last      Exts    Extensions [optional].\n   *\n   */\n\n  if (req_flags & GSS_C_DELEG_FLAG)\n    {\n      /* XXX We don't support credential delegation yet.  We should\n         not fail here, as GSS_C_DELEG_FLAG is masked out above, and\n         in context.c. */\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 124,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    },
    "_gss_krb5_checksum_parse": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "OM_uint32\n_gss_krb5_checksum_parse (OM_uint32 * minor_status,\n\t\t\t  gss_ctx_id_t * context_handle,\n\t\t\t  const gss_channel_bindings_t input_chan_bindings)\n{\n  gss_ctx_id_t ctx = *context_handle;\n  _gss_krb5_ctx_t k5 = ctx->krb5;\n  char *out = NULL;\n  size_t len = 0;\n  int rc;\n  char *md5hash;\n\n  if (shishi_ap_authenticator_cksumtype (k5->ap) != 0x8003)\n    {\n      if (minor_status)\n\t*minor_status = GSS_KRB5_S_G_VALIDATE_FAILED;\n      return GSS_S_FAILURE;\n    }\n\n  rc = shishi_ap_authenticator_cksumdata (k5->ap, out, &len);\n  if (rc != SHISHI_TOO_SMALL_BUFFER)\n    return GSS_S_FAILURE;\n\n  out = malloc (len);\n  if (!out)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  rc = shishi_ap_authenticator_cksumdata (k5->ap, out, &len);\n  if (rc != SHISHI_OK)\n    {\n      free (out);\n      return GSS_S_FAILURE;\n    }\n\n  if (memcmp (out, \"\\x10\\x00\\x00\\x00\", 4) != 0)\n    {\n      free (out);\n      return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n  if (input_chan_bindings != GSS_C_NO_CHANNEL_BINDINGS)\n    {\n      rc = hash_cb (minor_status, context_handle,\n\t\t    input_chan_bindings, &md5hash);\n      if (rc != GSS_S_COMPLETE)\n\t{\n\t  free (out);\n\t  return GSS_S_DEFECTIVE_TOKEN;\n\t}\n\n      rc = memcmp (&out[4], md5hash, 16);\n\n      free (md5hash);\n    }\n  else\n    {\n      char zeros[16];\n      memset (&zeros[0], 0, sizeof zeros);\n      rc = memcmp (&out[4], zeros, 16);\n    }\n\n  free (out);\n\n  if (rc != 0)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 72,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/checksum.h": {},
  "gss/gss-1.0.3/lib/krb5/context.c": {
    "init_request": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static OM_uint32\ninit_request (OM_uint32 * minor_status,\n\t      const gss_cred_id_t initiator_cred_handle,\n\t      gss_ctx_id_t * context_handle,\n\t      const gss_name_t target_name,\n\t      const gss_OID mech_type,\n\t      OM_uint32 req_flags,\n\t      OM_uint32 time_req,\n\t      const gss_channel_bindings_t input_chan_bindings,\n\t      const gss_buffer_t input_token,\n\t      gss_OID * actual_mech_type,\n\t      gss_buffer_t output_token,\n\t      OM_uint32 * ret_flags, OM_uint32 * time_rec)\n{\n  gss_ctx_id_t ctx = *context_handle;\n  _gss_krb5_ctx_t k5 = ctx->krb5;\n  char *cksum, *der;\n  size_t cksumlen, derlen;\n  int rc;\n  OM_uint32 maj_stat;\n  Shishi_tkts_hint hint;\n\n  /* Get service ticket. */\n  maj_stat = gss_krb5_canonicalize_name (minor_status, target_name,\n\t\t\t\t\t GSS_C_NO_OID, &k5->peerptr);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  memset (&hint, 0, sizeof (hint));\n  hint.server = k5->peerptr->value;\n  hint.endtime = time_req;\n\n  k5->tkt = shishi_tkts_get (shishi_tkts_default (k5->sh), &hint);\n  if (!k5->tkt)\n    {\n      if (minor_status)\n\t*minor_status = GSS_KRB5_S_KG_CCACHE_NOMATCH;\n      return GSS_S_NO_CRED;\n    }\n\n  /* Create Authenticator checksum field. */\n  maj_stat = _gss_krb5_checksum_pack (minor_status, initiator_cred_handle,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_chan_bindings, req_flags,\n\t\t\t\t      &cksum, &cksumlen);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  /* Create AP-REQ in output_token. */\n  rc = shishi_ap_tktoptionsraw (k5->sh, &k5->ap, k5->tkt,\n\t\t\t\tSHISHI_APOPTIONS_MUTUAL_REQUIRED,\n\t\t\t\t0x8003, cksum, cksumlen);\n  free (cksum);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = shishi_authenticator_seqnumber_get (k5->sh,\n\t\t\t\t\t   shishi_ap_authenticator (k5->ap),\n\t\t\t\t\t   &k5->initseqnr);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = shishi_ap_req_der (k5->ap, &der, &derlen);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = _gss_encapsulate_token_prefix (TOK_AP_REQ, TOK_LEN,\n\t\t\t\t      der, derlen,\n\t\t\t\t      GSS_KRB5->elements,\n\t\t\t\t      GSS_KRB5->length,\n\t\t\t\t      &output_token->value,\n\t\t\t\t      &output_token->length);\n  free (der);\n  if (rc != 0)\n    return GSS_S_FAILURE;\n\n  if (req_flags & GSS_C_MUTUAL_FLAG)\n    return GSS_S_CONTINUE_NEEDED;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 81,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "init_reply": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static OM_uint32\ninit_reply (OM_uint32 * minor_status,\n\t    const gss_cred_id_t initiator_cred_handle,\n\t    gss_ctx_id_t * context_handle,\n\t    const gss_name_t target_name,\n\t    const gss_OID mech_type,\n\t    OM_uint32 req_flags,\n\t    OM_uint32 time_req,\n\t    const gss_channel_bindings_t input_chan_bindings,\n\t    const gss_buffer_t input_token,\n\t    gss_OID * actual_mech_type,\n\t    gss_buffer_t output_token,\n\t    OM_uint32 * ret_flags, OM_uint32 * time_rec)\n{\n  gss_ctx_id_t ctx = *context_handle;\n  _gss_krb5_ctx_t k5 = ctx->krb5;\n  OM_uint32 tmp_min_stat;\n  gss_buffer_desc data;\n  int rc;\n\n  if (gss_decapsulate_token (input_token, GSS_KRB5, &data) != GSS_S_COMPLETE)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  if (data.length < TOK_LEN)\n    {\n      gss_release_buffer (&tmp_min_stat, &data);\n      return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n  if (memcmp (data.value, TOK_AP_REP, TOK_LEN) != 0)\n    {\n      gss_release_buffer (&tmp_min_stat, &data);\n      return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n  rc = shishi_ap_rep_der_set (k5->ap, (char *) data.value + TOK_LEN,\n\t\t\t      data.length - TOK_LEN);\n  gss_release_buffer (&tmp_min_stat, &data);\n  if (rc != SHISHI_OK)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  rc = shishi_ap_rep_verify (k5->ap);\n  if (rc != SHISHI_OK)\n    return GSS_S_DEFECTIVE_TOKEN;\n\n  rc = shishi_encapreppart_seqnumber_get (k5->sh,\n\t\t\t\t\t  shishi_ap_encapreppart (k5->ap),\n\t\t\t\t\t  &k5->acceptseqnr);\n  if (rc != SHISHI_OK)\n    {\n      /* A strict 1964 implementation would return\n         GSS_S_DEFECTIVE_TOKEN here.  gssapi-cfx permit absent\n         sequence number, though. */\n      k5->acceptseqnr = 0;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_krb5_init_sec_context": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "OM_uint32\ngss_krb5_init_sec_context (OM_uint32 * minor_status,\n\t\t\t   const gss_cred_id_t initiator_cred_handle,\n\t\t\t   gss_ctx_id_t * context_handle,\n\t\t\t   const gss_name_t target_name,\n\t\t\t   const gss_OID mech_type,\n\t\t\t   OM_uint32 req_flags,\n\t\t\t   OM_uint32 time_req,\n\t\t\t   const gss_channel_bindings_t input_chan_bindings,\n\t\t\t   const gss_buffer_t input_token,\n\t\t\t   gss_OID * actual_mech_type,\n\t\t\t   gss_buffer_t output_token,\n\t\t\t   OM_uint32 * ret_flags, OM_uint32 * time_rec)\n{\n  gss_ctx_id_t ctx = *context_handle;\n  _gss_krb5_ctx_t k5 = ctx->krb5;\n  OM_uint32 maj_stat;\n  int rc;\n\n  if (minor_status)\n    *minor_status = 0;\n\n  if (initiator_cred_handle)\n    {\n      /* We only support the default initiator.  See k5internal.h for\n         adding a Shishi_tkt to the credential structure.  I'm not sure\n         what the use would be -- user-to-user authentication perhaps?\n         Later: if you have tickets for foo@BAR and bar@FOO, it may be\n         useful to call gss_acquire_cred first to chose which one to\n         initiate the context with.  Not many applications need this. */\n      return GSS_S_NO_CRED;\n    }\n\n  if (target_name == NULL)\n    {\n      return GSS_S_BAD_NAME;\n    }\n\n  if (k5 == NULL)\n    {\n      k5 = ctx->krb5 = calloc (sizeof (*k5), 1);\n      if (!k5)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n\n      rc = shishi_init (&k5->sh);\n      if (rc != SHISHI_OK)\n\treturn GSS_S_FAILURE;\n    }\n\n  if (!k5->reqdone)\n    {\n      maj_stat = init_request (minor_status,\n\t\t\t       initiator_cred_handle,\n\t\t\t       context_handle,\n\t\t\t       target_name,\n\t\t\t       mech_type,\n\t\t\t       req_flags,\n\t\t\t       time_req,\n\t\t\t       input_chan_bindings,\n\t\t\t       input_token,\n\t\t\t       actual_mech_type,\n\t\t\t       output_token, ret_flags, time_rec);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n\n      k5->flags = req_flags & (\t/* GSS_C_DELEG_FLAG | */\n\t\t\t\tGSS_C_MUTUAL_FLAG |\n\t\t\t\tGSS_C_REPLAY_FLAG | GSS_C_SEQUENCE_FLAG |\n\t\t\t\tGSS_C_CONF_FLAG | GSS_C_INTEG_FLAG);\n      /* PROT_READY is not mentioned in 1964/gssapi-cfx but we support\n         it anyway. */\n      k5->flags |= GSS_C_PROT_READY_FLAG;\n\n      if (ret_flags)\n\t*ret_flags = k5->flags;\n\n      k5->key = shishi_ap_key (k5->ap);\n      k5->reqdone = 1;\n    }\n  else if (k5->reqdone && k5->flags & GSS_C_MUTUAL_FLAG && !k5->repdone)\n    {\n      maj_stat = init_reply (minor_status,\n\t\t\t     initiator_cred_handle,\n\t\t\t     context_handle,\n\t\t\t     target_name,\n\t\t\t     mech_type,\n\t\t\t     req_flags,\n\t\t\t     time_req,\n\t\t\t     input_chan_bindings,\n\t\t\t     input_token,\n\t\t\t     actual_mech_type,\n\t\t\t     output_token, ret_flags, time_rec);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n\n      if (ret_flags)\n\t*ret_flags = k5->flags;\n\n      k5->repdone = 1;\n    }\n  else\n    maj_stat = GSS_S_FAILURE;\n\n  if (time_rec)\n    *time_rec = gss_krb5_tktlifetime (k5->tkt);\n\n  return maj_stat;\n}",
      "lines": 112,
      "depth": 13,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_accept_sec_context": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "OM_uint32\ngss_krb5_accept_sec_context (OM_uint32 * minor_status,\n\t\t\t     gss_ctx_id_t * context_handle,\n\t\t\t     const gss_cred_id_t acceptor_cred_handle,\n\t\t\t     const gss_buffer_t input_token_buffer,\n\t\t\t     const gss_channel_bindings_t input_chan_bindings,\n\t\t\t     gss_name_t * src_name,\n\t\t\t     gss_OID * mech_type,\n\t\t\t     gss_buffer_t output_token,\n\t\t\t     OM_uint32 * ret_flags,\n\t\t\t     OM_uint32 * time_rec,\n\t\t\t     gss_cred_id_t * delegated_cred_handle)\n{\n  gss_buffer_desc in;\n  gss_ctx_id_t cx;\n  _gss_krb5_ctx_t cxk5;\n  _gss_krb5_cred_t crk5;\n  OM_uint32 tmp_min_stat;\n  int rc;\n\n  if (minor_status)\n    *minor_status = 0;\n\n  if (ret_flags)\n    *ret_flags = 0;\n\n  if (!acceptor_cred_handle)\n    /* XXX support GSS_C_NO_CREDENTIAL: acquire_cred() default server */\n    return GSS_S_NO_CRED;\n\n  if (*context_handle)\n    return GSS_S_FAILURE;\n\n  crk5 = acceptor_cred_handle->krb5;\n\n  cx = calloc (sizeof (*cx), 1);\n  if (!cx)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  cxk5 = calloc (sizeof (*cxk5), 1);\n  if (!cxk5)\n    {\n      free (cx);\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  cx->mech = GSS_KRB5;\n  cx->krb5 = cxk5;\n  /* XXX cx->peer?? */\n  *context_handle = cx;\n\n  cxk5->sh = crk5->sh;\n  cxk5->key = crk5->key;\n  cxk5->acceptor = 1;\n\n  rc = shishi_ap (cxk5->sh, &cxk5->ap);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = gss_decapsulate_token (input_token_buffer, GSS_KRB5, &in);\n  if (rc != GSS_S_COMPLETE)\n    return GSS_S_BAD_MIC;\n\n  if (in.length < TOK_LEN)\n    {\n      gss_release_buffer (&tmp_min_stat, &in);\n      return GSS_S_BAD_MIC;\n    }\n\n  if (memcmp (in.value, TOK_AP_REQ, TOK_LEN) != 0)\n    {\n      gss_release_buffer (&tmp_min_stat, &in);\n      return GSS_S_BAD_MIC;\n    }\n\n  rc = shishi_ap_req_der_set (cxk5->ap, (char *) in.value + TOK_LEN,\n\t\t\t      in.length - TOK_LEN);\n  gss_release_buffer (&tmp_min_stat, &in);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = shishi_ap_req_process (cxk5->ap, crk5->key);\n  if (rc != SHISHI_OK)\n    {\n      if (minor_status)\n\t*minor_status = GSS_KRB5_S_G_VALIDATE_FAILED;\n      return GSS_S_FAILURE;\n    }\n\n  rc = shishi_authenticator_seqnumber_get (cxk5->sh,\n\t\t\t\t\t   shishi_ap_authenticator (cxk5->ap),\n\t\t\t\t\t   &cxk5->initseqnr);\n  if (rc != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  rc = _gss_krb5_checksum_parse (minor_status,\n\t\t\t\t context_handle, input_chan_bindings);\n  if (rc != GSS_S_COMPLETE)\n    return GSS_S_FAILURE;\n\n  cxk5->tkt = shishi_ap_tkt (cxk5->ap);\n  cxk5->key = shishi_ap_key (cxk5->ap);\n\n  if (shishi_apreq_mutual_required_p (crk5->sh, shishi_ap_req (cxk5->ap)))\n    {\n      Shishi_asn1 aprep;\n      char *der;\n      size_t len;\n\n      rc = shishi_ap_rep_asn1 (cxk5->ap, &aprep);\n      if (rc != SHISHI_OK)\n\t{\n\t  printf (\"Error creating AP-REP: %s\\n\", shishi_strerror (rc));\n\t  return GSS_S_FAILURE;\n\t}\n\n      rc = shishi_encapreppart_seqnumber_get (cxk5->sh,\n\t\t\t\t\t      shishi_ap_encapreppart\n\t\t\t\t\t      (cxk5->ap), &cxk5->acceptseqnr);\n      if (rc != SHISHI_OK)\n\t{\n\t  /* A strict 1964 implementation would return\n\t     GSS_S_DEFECTIVE_TOKEN here.  gssapi-cfx permit absent\n\t     sequence number, though. */\n\t  cxk5->acceptseqnr = 0;\n\t}\n\n      rc = shishi_asn1_to_der (crk5->sh, aprep, &der, &len);\n      if (rc != SHISHI_OK)\n\t{\n\t  printf (\"Error der encoding aprep: %s\\n\", shishi_strerror (rc));\n\t  return GSS_S_FAILURE;\n\t}\n\n      rc = _gss_encapsulate_token_prefix (TOK_AP_REP, TOK_LEN,\n\t\t\t\t\t  der, len,\n\t\t\t\t\t  GSS_KRB5->elements,\n\t\t\t\t\t  GSS_KRB5->length,\n\t\t\t\t\t  &output_token->value,\n\t\t\t\t\t  &output_token->length);\n      if (rc != 0)\n\treturn GSS_S_FAILURE;\n\n      if (ret_flags)\n\t*ret_flags = GSS_C_MUTUAL_FLAG;\n    }\n  else\n    {\n      output_token->value = NULL;\n      output_token->length = 0;\n    }\n\n  if (src_name)\n    {\n      gss_name_t p;\n\n      p = malloc (sizeof (*p));\n      if (!p)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n\n      rc = shishi_encticketpart_client (cxk5->sh,\n\t\t\t\t\tshishi_tkt_encticketpart (cxk5->tkt),\n\t\t\t\t\t&p->value, &p->length);\n      if (rc != SHISHI_OK)\n\treturn GSS_S_FAILURE;\n\n      p->type = GSS_KRB5_NT_PRINCIPAL_NAME;\n\n      *src_name = p;\n    }\n\n  /* PROT_READY is not mentioned in 1964/gssapi-cfx but we support\n     it anyway. */\n  if (ret_flags)\n    *ret_flags |= GSS_C_PROT_READY_FLAG;\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 190,
      "depth": 12,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_delete_sec_context": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "OM_uint32\ngss_krb5_delete_sec_context (OM_uint32 * minor_status,\n\t\t\t     gss_ctx_id_t * context_handle,\n\t\t\t     gss_buffer_t output_token)\n{\n  _gss_krb5_ctx_t k5 = (*context_handle)->krb5;\n\n  if (k5->peerptr != GSS_C_NO_NAME)\n    gss_release_name (NULL, &k5->peerptr);\n\n  if (k5->ap)\n    shishi_ap_done (k5->ap);\n\n  if (!k5->acceptor)\n    shishi_done (k5->sh);\n  free (k5);\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_context_time": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "OM_uint32\ngss_krb5_context_time (OM_uint32 * minor_status,\n\t\t       const gss_ctx_id_t context_handle,\n\t\t       OM_uint32 * time_rec)\n{\n  _gss_krb5_ctx_t k5 = context_handle->krb5;\n\n  if (time_rec)\n    {\n      *time_rec = gss_krb5_tktlifetime (k5->tkt);\n\n      if (*time_rec == 0)\n\t{\n\t  if (minor_status)\n\t    *minor_status = 0;\n\t  return GSS_S_CONTEXT_EXPIRED;\n\t}\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/cred.c": {
    "acquire_cred1": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static OM_uint32\nacquire_cred1 (OM_uint32 * minor_status,\n\t       const gss_name_t desired_name,\n\t       OM_uint32 time_req,\n\t       const gss_OID_set desired_mechs,\n\t       gss_cred_usage_t cred_usage,\n\t       gss_cred_id_t * output_cred_handle,\n\t       gss_OID_set * actual_mechs, OM_uint32 * time_rec)\n{\n  gss_name_t name = desired_name;\n  _gss_krb5_cred_t k5 = (*output_cred_handle)->krb5;\n  OM_uint32 maj_stat;\n\n  if (desired_name == GSS_C_NO_NAME)\n    {\n      gss_buffer_desc buf = { 4, (char *) \"host\" };\n\n      maj_stat = gss_import_name (minor_status, &buf,\n\t\t\t\t  GSS_C_NT_HOSTBASED_SERVICE, &name);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  maj_stat = gss_krb5_canonicalize_name (minor_status, name,\n\t\t\t\t\t GSS_KRB5, &k5->peerptr);\n  if (GSS_ERROR (maj_stat))\n    return maj_stat;\n\n  if (k5->peerptr == GSS_C_NO_NAME)\n    {\n      maj_stat = gss_release_name (minor_status, &name);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n      return GSS_S_BAD_NAME;\n    }\n\n  if (shishi_init_server (&k5->sh) != SHISHI_OK)\n    return GSS_S_FAILURE;\n\n  {\n    char *p;\n\n    p = malloc (k5->peerptr->length + 1);\n    if (!p)\n      {\n\tif (minor_status)\n\t  *minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n      }\n    memcpy (p, k5->peerptr->value, k5->peerptr->length);\n    p[k5->peerptr->length] = 0;\n\n    k5->key = shishi_hostkeys_for_serverrealm (k5->sh, p, NULL);\n\n    free (p);\n  }\n\n  if (!k5->key)\n    {\n      if (minor_status)\n\t*minor_status = GSS_KRB5_S_KG_KEYTAB_NOMATCH;\n      return GSS_S_NO_CRED;\n    }\n\n  if (time_rec)\n    *time_rec = GSS_C_INDEFINITE;\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 69,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_krb5_acquire_cred": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "OM_uint32\ngss_krb5_acquire_cred (OM_uint32 * minor_status,\n\t\t       const gss_name_t desired_name,\n\t\t       OM_uint32 time_req,\n\t\t       const gss_OID_set desired_mechs,\n\t\t       gss_cred_usage_t cred_usage,\n\t\t       gss_cred_id_t * output_cred_handle,\n\t\t       gss_OID_set * actual_mechs, OM_uint32 * time_rec)\n{\n  OM_uint32 maj_stat;\n  gss_cred_id_t p = *output_cred_handle;\n\n  p->krb5 = calloc (sizeof (*p->krb5), 1);\n  if (!p->krb5)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  if (actual_mechs)\n    {\n      maj_stat = gss_create_empty_oid_set (minor_status, actual_mechs);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  free (p->krb5);\n\t  return maj_stat;\n\t}\n      maj_stat = gss_add_oid_set_member (minor_status, GSS_KRB5,\n\t\t\t\t\t actual_mechs);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  free (p->krb5);\n\t  return maj_stat;\n\t}\n    }\n\n  maj_stat = acquire_cred1 (minor_status, desired_name, time_req,\n\t\t\t    desired_mechs, cred_usage,\n\t\t\t    &p, actual_mechs, time_rec);\n  if (GSS_ERROR (maj_stat))\n    {\n      if (actual_mechs)\n\tgss_release_oid_set (NULL, actual_mechs);\n      free (p->krb5);\n\n      return maj_stat;\n    }\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 53,
      "depth": 11,
      "decorators": [
        "OM_uint32"
      ]
    },
    "inquire_cred": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static OM_uint32\ninquire_cred (OM_uint32 * minor_status,\n\t      const gss_cred_id_t cred_handle,\n\t      gss_name_t * name,\n\t      OM_uint32 * lifetime,\n\t      gss_cred_usage_t * cred_usage, gss_OID_set * mechanisms)\n{\n  OM_uint32 maj_stat;\n\n  if (cred_handle == GSS_C_NO_CREDENTIAL)\n    return GSS_S_NO_CRED;\n\n  if (mechanisms)\n    {\n      maj_stat = gss_create_empty_oid_set (minor_status, mechanisms);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n      maj_stat = gss_add_oid_set_member (minor_status, GSS_KRB5, mechanisms);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  if (name)\n    {\n      maj_stat = gss_duplicate_name (minor_status, cred_handle->krb5->peerptr,\n\t\t\t\t     name);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n\n  if (cred_usage)\n    *cred_usage = GSS_C_BOTH;\n\n  if (lifetime)\n    *lifetime = GSS_C_INDEFINITE;\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "OM_uint32"
      ]
    },
    "gss_krb5_inquire_cred": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "OM_uint32\ngss_krb5_inquire_cred (OM_uint32 * minor_status,\n\t\t       const gss_cred_id_t cred_handle,\n\t\t       gss_name_t * name,\n\t\t       OM_uint32 * lifetime,\n\t\t       gss_cred_usage_t * cred_usage,\n\t\t       gss_OID_set * mechanisms)\n{\n  return inquire_cred (minor_status, cred_handle, name, lifetime,\n\t\t       cred_usage, mechanisms);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_inquire_cred_by_mech": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "OM_uint32\ngss_krb5_inquire_cred_by_mech (OM_uint32 * minor_status,\n\t\t\t       const gss_cred_id_t cred_handle,\n\t\t\t       const gss_OID mech_type,\n\t\t\t       gss_name_t * name,\n\t\t\t       OM_uint32 * initiator_lifetime,\n\t\t\t       OM_uint32 * acceptor_lifetime,\n\t\t\t       gss_cred_usage_t * cred_usage)\n{\n  OM_uint32 maj_stat;\n\n  maj_stat = inquire_cred (minor_status, cred_handle, name,\n\t\t\t   initiator_lifetime, cred_usage, NULL);\n\n  if (acceptor_lifetime)\n    *acceptor_lifetime = *initiator_lifetime;\n\n  return maj_stat;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_release_cred": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "OM_uint32\ngss_krb5_release_cred (OM_uint32 * minor_status, gss_cred_id_t * cred_handle)\n{\n  _gss_krb5_cred_t k5 = (*cred_handle)->krb5;\n\n  if (k5->peerptr != GSS_C_NO_NAME)\n    gss_release_name (NULL, &k5->peerptr);\n\n  shishi_key_done (k5->key);\n  shishi_done (k5->sh);\n  free (k5);\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/error.c": {
    "gss_krb5_display_status": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "OM_uint32\ngss_krb5_display_status (OM_uint32 * minor_status,\n\t\t\t OM_uint32 status_value,\n\t\t\t int status_type,\n\t\t\t const gss_OID mech_type,\n\t\t\t OM_uint32 * message_context,\n\t\t\t gss_buffer_t status_string)\n{\n  if (minor_status)\n    *minor_status = 0;\n\n  switch (status_value)\n    {\n    case 0:\n      status_string->value = strdup (_(\"No krb5 error\"));\n      if (!status_string->value)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n      status_string->length = strlen (status_string->value);\n      break;\n\n      /* 4.1.1. Non-Kerberos-specific codes */\n    case GSS_KRB5_S_G_BAD_SERVICE_NAME:\n    case GSS_KRB5_S_G_BAD_STRING_UID:\n    case GSS_KRB5_S_G_NOUSER:\n    case GSS_KRB5_S_G_VALIDATE_FAILED:\n    case GSS_KRB5_S_G_BUFFER_ALLOC:\n    case GSS_KRB5_S_G_BAD_MSG_CTX:\n    case GSS_KRB5_S_G_WRONG_SIZE:\n    case GSS_KRB5_S_G_BAD_USAGE:\n    case GSS_KRB5_S_G_UNKNOWN_QOP:\n      /* 4.1.2. Kerberos-specific-codes */\n    case GSS_KRB5_S_KG_CCACHE_NOMATCH:\n    case GSS_KRB5_S_KG_KEYTAB_NOMATCH:\n    case GSS_KRB5_S_KG_TGT_MISSING:\n    case GSS_KRB5_S_KG_NO_SUBKEY:\n    case GSS_KRB5_S_KG_CONTEXT_ESTABLISHED:\n    case GSS_KRB5_S_KG_BAD_SIGN_TYPE:\n    case GSS_KRB5_S_KG_BAD_LENGTH:\n    case GSS_KRB5_S_KG_CTX_INCOMPLETE:\n      status_string->value =\n\tstrdup (_(gss_krb5_errors[status_value - 1].text));\n      if (!status_string->value)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n      status_string->length = strlen (status_string->value);\n      break;\n\n    default:\n      status_string->value = strdup (_(\"Unknown krb5 error\"));\n      if (!status_string->value)\n\t{\n\t  if (minor_status)\n\t    *minor_status = ENOMEM;\n\t  return GSS_S_FAILURE;\n\t}\n      status_string->length = strlen (status_string->value);\n      break;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 68,
      "depth": 15,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/k5internal.h": {},
  "gss/gss-1.0.3/lib/krb5/msg.c": {
    "gss_krb5_get_mic": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "OM_uint32\ngss_krb5_get_mic (OM_uint32 * minor_status,\n\t\t  const gss_ctx_id_t context_handle,\n\t\t  gss_qop_t qop_req,\n\t\t  const gss_buffer_t message_buffer,\n\t\t  gss_buffer_t message_token)\n{\n  return GSS_S_UNAVAILABLE;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_verify_mic": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "OM_uint32\ngss_krb5_verify_mic (OM_uint32 * minor_status,\n\t\t     const gss_ctx_id_t context_handle,\n\t\t     const gss_buffer_t message_buffer,\n\t\t     const gss_buffer_t token_buffer, gss_qop_t * qop_state)\n{\n  return GSS_S_UNAVAILABLE;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_wrap": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "OM_uint32\ngss_krb5_wrap (OM_uint32 * minor_status,\n\t       const gss_ctx_id_t context_handle,\n\t       int conf_req_flag,\n\t       gss_qop_t qop_req,\n\t       const gss_buffer_t input_message_buffer,\n\t       int *conf_state, gss_buffer_t output_message_buffer)\n{\n  _gss_krb5_ctx_t k5 = context_handle->krb5;\n  size_t padlength;\n  gss_buffer_desc data;\n  char *p;\n  size_t tmplen;\n  int rc;\n\n  switch (shishi_key_type (k5->key))\n    {\n      /* XXX implement other checksums */\n\n    case SHISHI_DES_CBC_MD5:\n      {\n\tchar header[8];\n\tchar seqno[8];\n\tchar *eseqno;\n\tchar *cksum;\n\tchar confounder[8];\n\n\t/* Typical data:\n\t   ;; 02 01 00 00 ff ff ff ff  0c 22 1f 79 59 3d 00 cb\n\t   ;; d5 78 2f fb 50 d2 b8 59  fb b4 e0 9b d0 a2 fa dc\n\t   ;; 01 00 20 00 04 04 04 04\n\t   Translates into:\n\t   ;;   HEADER                 ENCRYPTED SEQ.NUMBER\n\t   ;;   DES-MAC-MD5 CKSUM      CONFOUNDER\n\t   ;;   PADDED DATA\n\t */\n\tpadlength = 8 - input_message_buffer->length % 8;\n\tdata.length = 4 * 8 + input_message_buffer->length + padlength;\n\tp = malloc (data.length);\n\tif (!p)\n\t  {\n\t    if (minor_status)\n\t      *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t  }\n\n\t/* XXX encrypt data iff confidential option chosen */\n\n\t/* Setup header and confounder */\n\tmemcpy (header, TOK_WRAP, 2);\t/* TOK_ID: Wrap 0201 */\n\tmemcpy (header + 2, \"\\x00\\x00\", 2);\t/* SGN_ALG: DES-MAC-MD5 */\n\tmemcpy (header + 4, \"\\xFF\\xFF\", 2);\t/* SEAL_ALG: none */\n\tmemcpy (header + 6, \"\\xFF\\xFF\", 2);\t/* filler */\n\trc = shishi_randomize (k5->sh, 0, confounder, 8);\n\tif (rc != SHISHI_OK)\n\t  return GSS_S_FAILURE;\n\n\t/* Compute checksum over header, confounder, input string, and pad */\n\tmemcpy (p, header, 8);\n\tmemcpy (p + 8, confounder, 8);\n\tmemcpy (p + 16, input_message_buffer->value,\n\t\tinput_message_buffer->length);\n\tmemset (p + 16 + input_message_buffer->length,\n\t\t(int) padlength, padlength);\n\n\trc = shishi_checksum (k5->sh,\n\t\t\t      k5->key,\n\t\t\t      0, SHISHI_RSA_MD5_DES_GSS,\n\t\t\t      p,\n\t\t\t      16 + input_message_buffer->length + padlength,\n\t\t\t      &cksum, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 8)\n\t  return GSS_S_FAILURE;\n\n\t/* seq_nr */\n\tif (k5->acceptor)\n\t  {\n\t    seqno[0] = k5->acceptseqnr & 0xFF;\n\t    seqno[1] = k5->acceptseqnr >> 8 & 0xFF;\n\t    seqno[2] = k5->acceptseqnr >> 16 & 0xFF;\n\t    seqno[3] = k5->acceptseqnr >> 24 & 0xFF;\n\t    memset (seqno + 4, 0xFF, 4);\n\t  }\n\telse\n\t  {\n\t    seqno[0] = k5->initseqnr & 0xFF;\n\t    seqno[1] = k5->initseqnr >> 8 & 0xFF;\n\t    seqno[2] = k5->initseqnr >> 16 & 0xFF;\n\t    seqno[3] = k5->initseqnr >> 24 & 0xFF;\n\t    memset (seqno + 4, 0, 4);\n\t  }\n\n\trc = shishi_encrypt_iv_etype (k5->sh, k5->key, 0,\n\t\t\t\t      SHISHI_DES_CBC_NONE, cksum, 8,\n\t\t\t\t      seqno, 8, &eseqno, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 8)\n\t  return GSS_S_FAILURE;\n\n\t/* put things in place */\n\tmemcpy (p, header, 8);\n\tmemcpy (p + 8, eseqno, 8);\n\tfree (eseqno);\n\tmemcpy (p + 16, cksum, 8);\n\tfree (cksum);\n\tmemcpy (p + 24, confounder, 8);\n\tmemcpy (p + 32, input_message_buffer->value,\n\t\tinput_message_buffer->length);\n\tmemset (p + 32 + input_message_buffer->length,\n\t\t(int) padlength, padlength);\n\n\tdata.value = p;\n\n\trc = gss_encapsulate_token (&data, GSS_KRB5, output_message_buffer);\n\tif (rc != GSS_S_COMPLETE)\n\t  return GSS_S_FAILURE;\n\tif (k5->acceptor)\n\t  k5->acceptseqnr++;\n\telse\n\t  k5->initseqnr++;\n      }\n      break;\n\n    case SHISHI_DES3_CBC_HMAC_SHA1_KD:\n      {\n\tchar *tmp;\n\n\tpadlength = 8 - input_message_buffer->length % 8;\n\tdata.length = 8 + 8 + 20 + 8 + input_message_buffer->length\n\t  + padlength;\n\tp = malloc (data.length);\n\tif (!p)\n\t  {\n\t    if (minor_status)\n\t      *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t  }\n\n\t/* XXX encrypt data iff confidential option chosen */\n\n\t/* Compute checksum over header, confounder, input string, and pad */\n\n\tmemcpy (p, TOK_WRAP, 2);\t/* TOK_ID: Wrap */\n\tmemcpy (p + 2, \"\\x04\\x00\", 2);\t/* SGN_ALG: 3DES */\n\tmemcpy (p + 4, \"\\xFF\\xFF\", 2);\t/* SEAL_ALG: none */\n\tmemcpy (p + 6, \"\\xFF\\xFF\", 2);\t/* filler */\n\trc = shishi_randomize (k5->sh, 0, p + 8, 8);\n\tif (rc != SHISHI_OK)\n\t  return GSS_S_FAILURE;\n\tmemcpy (p + 16, input_message_buffer->value,\n\t\tinput_message_buffer->length);\n\tmemset (p + 16 + input_message_buffer->length,\n\t\t(int) padlength, padlength);\n\n\trc = shishi_checksum (k5->sh,\n\t\t\t      k5->key,\n\t\t\t      SHISHI_KEYUSAGE_GSS_R2,\n\t\t\t      SHISHI_HMAC_SHA1_DES3_KD, p,\n\t\t\t      16 + input_message_buffer->length + padlength,\n\t\t\t      &tmp, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 20)\n\t  return GSS_S_FAILURE;\n\n\tmemcpy (p + 16, tmp, tmplen);\n\tmemcpy (p + 36, p + 8, 8);\n\n\t/* seq_nr */\n\tif (k5->acceptor)\n\t  {\n\t    (p + 8)[0] = k5->acceptseqnr & 0xFF;\n\t    (p + 8)[1] = k5->acceptseqnr >> 8 & 0xFF;\n\t    (p + 8)[2] = k5->acceptseqnr >> 16 & 0xFF;\n\t    (p + 8)[3] = k5->acceptseqnr >> 24 & 0xFF;\n\t    memset (p + 8 + 4, 0xFF, 4);\n\t  }\n\telse\n\t  {\n\t    (p + 8)[0] = k5->initseqnr & 0xFF;\n\t    (p + 8)[1] = k5->initseqnr >> 8 & 0xFF;\n\t    (p + 8)[2] = k5->initseqnr >> 16 & 0xFF;\n\t    (p + 8)[3] = k5->initseqnr >> 24 & 0xFF;\n\t    memset (p + 8 + 4, 0, 4);\n\t  }\n\n\trc = shishi_encrypt_iv_etype (k5->sh, k5->key, 0, SHISHI_DES3_CBC_NONE, p + 16, 8,\t/* cksum */\n\t\t\t\t      p + 8, 8, &tmp, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 8)\n\t  return GSS_S_FAILURE;\n\n\tmemcpy (p + 8, tmp, tmplen);\n\tfree (tmp);\n\tmemcpy (p + 8 + 8 + 20 + 8, input_message_buffer->value,\n\t\tinput_message_buffer->length);\n\tmemset (p + 8 + 8 + 20 + 8 + input_message_buffer->length,\n\t\t(int) padlength, padlength);\n\n\tdata.value = p;\n\n\trc = gss_encapsulate_token (&data, GSS_KRB5, output_message_buffer);\n\tif (rc != GSS_S_COMPLETE)\n\t  return GSS_S_FAILURE;\n\tif (k5->acceptor)\n\t  k5->acceptseqnr++;\n\telse\n\t  k5->initseqnr++;\n\tbreak;\n      }\n\n    default:\n      return GSS_S_FAILURE;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 213,
      "depth": 15,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_unwrap": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        492,
        1
      ],
      "content": "OM_uint32\ngss_krb5_unwrap (OM_uint32 * minor_status,\n\t\t const gss_ctx_id_t context_handle,\n\t\t const gss_buffer_t input_message_buffer,\n\t\t gss_buffer_t output_message_buffer,\n\t\t int *conf_state, gss_qop_t * qop_state)\n{\n  _gss_krb5_ctx_t k5 = context_handle->krb5;\n  gss_buffer_desc tok;\n  char *data;\n  OM_uint32 sgn_alg, seal_alg;\n  size_t tmplen;\n  int rc;\n\n  rc = gss_decapsulate_token (input_message_buffer, GSS_KRB5, &tok);\n  if (rc != GSS_S_COMPLETE)\n    return GSS_S_BAD_MIC;\n\n  if (tok.length < 8)\n    return GSS_S_BAD_MIC;\n\n  if (memcmp (tok.value, TOK_WRAP, TOK_LEN) != 0)\n    return GSS_S_BAD_MIC;\n\n  data = tok.value;\n\n  sgn_alg = data[2] & 0xFF;\n  sgn_alg |= data[3] << 8 & 0xFF00;\n\n  seal_alg = data[4] & 0xFF;\n  seal_alg |= data[5] << 8 & 0xFF00;\n\n  if (conf_state != NULL)\n    *conf_state = seal_alg == 0xFFFF;\n\n  if (memcmp (data + 6, \"\\xFF\\xFF\", 2) != 0)\n    return GSS_S_BAD_MIC;\n\n  switch (sgn_alg)\n    {\n      /* XXX implement other checksums */\n\n    case 0:\t\t\t/* DES-MD5 */\n      {\n\tsize_t padlen;\n\tchar *pt;\n\tchar header[8];\n\tchar encseqno[8];\n\tchar seqno[8];\n\tchar cksum[8];\n\tchar confounder[8];\n\tchar *tmp;\n\tuint32_t seqnr;\n\tsize_t outlen, i;\n\n\t/* Typical data:\n\t   ;; 02 01 00 00 ff ff ff ff  0c 22 1f 79 59 3d 00 cb\n\t   ;; d5 78 2f fb 50 d2 b8 59  fb b4 e0 9b d0 a2 fa dc\n\t   ;; 01 00 20 00 04 04 04 04\n\t   Translates into:\n\t   ;;   HEADER                 ENCRYPTED SEQ.NUMBER\n\t   ;;   DES-MAC-MD5 CKSUM      CONFOUNDER\n\t   ;;   PADDED DATA\n\t */\n\n\tif (tok.length < 5 * 8)\n\t  return GSS_S_BAD_MIC;\n\n\tmemcpy (header, data, 8);\n\tmemcpy (encseqno, data + 8, 8);\n\tmemcpy (cksum, data + 16, 8);\n\tmemcpy (confounder, data + 24, 8);\n\tpt = data + 32;\n\n\t/* XXX decrypt data iff confidential option chosen */\n\n\trc = shishi_decrypt_iv_etype (k5->sh,\n\t\t\t\t      k5->key,\n\t\t\t\t      0, SHISHI_DES_CBC_NONE,\n\t\t\t\t      cksum, 8, encseqno, 8, &tmp, &outlen);\n\tif (rc != SHISHI_OK)\n\t  return GSS_S_FAILURE;\n\tif (outlen != 8)\n\t  return GSS_S_BAD_MIC;\n\tmemcpy (seqno, tmp, 8);\n\tfree (tmp);\n\n\tif (memcmp (seqno + 4, k5->acceptor ? \"\\x00\\x00\\x00\\x00\" :\n\t\t    \"\\xFF\\xFF\\xFF\\xFF\", 4) != 0)\n\t  return GSS_S_BAD_MIC;\n\n\tseqnr = C2I (seqno);\n\tif (seqnr != (k5->acceptor ? k5->initseqnr : k5->acceptseqnr))\n\t  return GSS_S_BAD_MIC;\n\n\tif (k5->acceptor)\n\t  k5->initseqnr++;\n\telse\n\t  k5->acceptseqnr++;\n\n\t/* Check pad */\n\tpadlen = data[tok.length - 1];\n\tif (padlen > 8)\n\t  return GSS_S_BAD_MIC;\n\tfor (i = 1; i <= padlen; i++)\n\t  if (data[tok.length - i] != (int) padlen)\n\t    return GSS_S_BAD_MIC;\n\n\t/* Write header and confounder next to data */\n\tmemcpy (data + 16, header, 8);\n\tmemcpy (data + 24, confounder, 8);\n\n\t/* Checksum header + confounder + data + pad */\n\trc = shishi_checksum (k5->sh,\n\t\t\t      k5->key,\n\t\t\t      0, SHISHI_RSA_MD5_DES_GSS,\n\t\t\t      data + 16, tok.length - 16, &tmp, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 8)\n\t  return GSS_S_FAILURE;\n\n\tmemcpy (data + 8, tmp, tmplen);\n\n\t/* Compare checksum */\n\tif (tmplen != 8 || memcmp (cksum, data + 8, 8) != 0)\n\t  return GSS_S_BAD_MIC;\n\n\t/* Copy output data */\n\toutput_message_buffer->length = tok.length - 8 - 8 - 8 - 8 - padlen;\n\toutput_message_buffer->value = malloc (output_message_buffer->length);\n\tif (!output_message_buffer->value)\n\t  {\n\t    if (minor_status)\n\t      *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t  }\n\n\tmemcpy (output_message_buffer->value, pt,\n\t\ttok.length - 4 * 8 - padlen);\n      }\n      break;\n\n    case 4:\t\t\t/* 3DES */\n      {\n\tsize_t padlen;\n\tchar *p;\n\tchar *t;\n\tchar cksum[20];\n\tsize_t outlen, i;\n\tuint32_t seqnr;\n\n\tif (tok.length < 8 + 8 + 20 + 8 + 8)\n\t  return GSS_S_BAD_MIC;\n\n\tmemcpy (cksum, data + 8 + 8, 20);\n\n\t/* XXX decrypt data iff confidential option chosen */\n\n\tp = data + 8;\n\trc = shishi_decrypt_iv_etype (k5->sh,\n\t\t\t\t      k5->key,\n\t\t\t\t      0, SHISHI_DES3_CBC_NONE,\n\t\t\t\t      cksum, 8, p, 8, &t, &outlen);\n\tif (rc != SHISHI_OK || outlen != 8)\n\t  return GSS_S_FAILURE;\n\n\tmemcpy (p, t, 8);\n\tfree (t);\n\n\tif (memcmp (p + 4, k5->acceptor ? \"\\x00\\x00\\x00\\x00\" :\n\t\t    \"\\xFF\\xFF\\xFF\\xFF\", 4) != 0)\n\t  return GSS_S_BAD_MIC;\n\tseqnr = C2I (p);\n\tif (seqnr != (k5->acceptor ? k5->initseqnr : k5->acceptseqnr))\n\t  return GSS_S_BAD_MIC;\n\n\tif (k5->acceptor)\n\t  k5->initseqnr++;\n\telse\n\t  k5->acceptseqnr++;\n\n\t/* Check pad */\n\tpadlen = data[tok.length - 1];\n\tif (padlen > 8)\n\t  return GSS_S_BAD_MIC;\n\tfor (i = 1; i <= padlen; i++)\n\t  if (data[tok.length - i] != (int) padlen)\n\t    return GSS_S_BAD_MIC;\n\n\t/* Write header next to confounder */\n\tmemcpy (data + 8 + 20, data, 8);\n\n\t/* Checksum header + confounder + data + pad */\n\trc = shishi_checksum (k5->sh,\n\t\t\t      k5->key,\n\t\t\t      SHISHI_KEYUSAGE_GSS_R2,\n\t\t\t      SHISHI_HMAC_SHA1_DES3_KD, data + 20 + 8,\n\t\t\t      tok.length - 20 - 8, &t, &tmplen);\n\tif (rc != SHISHI_OK || tmplen != 20)\n\t  return GSS_S_FAILURE;\n\n\tmemcpy (data + 8 + 8, t, tmplen);\n\tfree (t);\n\n\t/* Compare checksum */\n\tif (tmplen != 20 || memcmp (cksum, data + 8 + 8, 20) != 0)\n\t  return GSS_S_BAD_MIC;\n\n\t/* Copy output data */\n\toutput_message_buffer->length = tok.length - 8 - 20 - 8 - 8 - padlen;\n\toutput_message_buffer->value = malloc (output_message_buffer->length);\n\tif (!output_message_buffer->value)\n\t  {\n\t    if (minor_status)\n\t      *minor_status = ENOMEM;\n\t    return GSS_S_FAILURE;\n\t  }\n\tmemcpy (output_message_buffer->value, data + 20 + 8 + 8 + 8,\n\t\ttok.length - 20 - 8 - 8 - 8 - padlen);\n      }\n      break;\n\n    default:\n      return GSS_S_FAILURE;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 227,
      "depth": 16,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/name.c": {
    "gss_krb5_canonicalize_name": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "OM_uint32\ngss_krb5_canonicalize_name (OM_uint32 * minor_status,\n\t\t\t    const gss_name_t input_name,\n\t\t\t    const gss_OID mech_type, gss_name_t * output_name)\n{\n  OM_uint32 maj_stat;\n\n  if (minor_status)\n    *minor_status = 0;\n\n  /* We consider (a zero terminated) GSS_KRB5_NT_PRINCIPAL_NAME the\n     canonical mechanism name type.  Convert everything into it.  */\n\n  if (gss_oid_equal (input_name->type, GSS_C_NT_EXPORT_NAME))\n    {\n      if (input_name->length > 15)\n\t{\n\t  *output_name = malloc (sizeof (**output_name));\n\t  if (!*output_name)\n\t    {\n\t      if (minor_status)\n\t\t*minor_status = ENOMEM;\n\t      return GSS_S_FAILURE;\n\t    }\n\t  (*output_name)->type = GSS_KRB5_NT_PRINCIPAL_NAME;\n\t  (*output_name)->length = input_name->length - 15;\n\t  (*output_name)->value = malloc ((*output_name)->length + 1);\n\t  if (!(*output_name)->value)\n\t    {\n\t      free (*output_name);\n\t      if (minor_status)\n\t\t*minor_status = ENOMEM;\n\t      return GSS_S_FAILURE;\n\t    }\n\t  memcpy ((*output_name)->value, input_name->value + 15,\n\t\t  (*output_name)->length);\n\t  (*output_name)->value[(*output_name)->length] = '\\0';\n\t}\n      else\n\t{\n\t  return GSS_S_BAD_NAME;\n\t}\n    }\n  else if (gss_oid_equal (input_name->type, GSS_C_NT_HOSTBASED_SERVICE))\n    {\n      char *p;\n\n      /* We don't support service-names without hostname part because\n         we can't compute a canonicalized name of the local host.\n         Calling gethostname does not give a canonicalized name. */\n      if (!memchr (input_name->value, '@', input_name->length))\n\t{\n\t  *minor_status = GSS_KRB5_S_G_BAD_SERVICE_NAME;\n\t  return GSS_S_COMPLETE;\n\t}\n\n      /* We don't do DNS name canoncalization since that is\n         insecure. */\n\n      maj_stat = gss_duplicate_name (minor_status, input_name, output_name);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n\n      (*output_name)->type = GSS_KRB5_NT_PRINCIPAL_NAME;\n\n      p = memchr ((*output_name)->value, '@', (*output_name)->length);\n      if (p)\n\t*p = '/';\n    }\n  else if (gss_oid_equal (input_name->type, GSS_KRB5_NT_PRINCIPAL_NAME))\n    {\n      maj_stat = gss_duplicate_name (minor_status, input_name, output_name);\n      if (GSS_ERROR (maj_stat))\n\treturn maj_stat;\n    }\n  else\n    {\n      *output_name = GSS_C_NO_NAME;\n      return GSS_S_BAD_NAMETYPE;\n    }\n\n  return GSS_S_COMPLETE;\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "OM_uint32"
      ]
    },
    "gss_krb5_export_name": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "OM_uint32\ngss_krb5_export_name (OM_uint32 * minor_status,\n\t\t      const gss_name_t input_name, gss_buffer_t exported_name)\n{\n  size_t msglen = input_name->length & 0xFFFFFFFF;\n  size_t len = TOK_LEN +\n    MECH_OID_LEN_LEN + MECH_OID_ASN1_LEN_LEN + GSS_KRB5->length +\n    NAME_LEN_LEN + msglen;\n  char *p;\n\n  exported_name->length = len;\n  p = exported_name->value = malloc (len);\n  if (!p)\n    {\n      if (minor_status)\n\t*minor_status = ENOMEM;\n      return GSS_S_FAILURE;\n    }\n\n  sprintf (p, \"\\x04\\x01\\x01\\x0B\\x06\\x09%s\", (char *) GSS_KRB5->elements);\n  p[2] = '\\0';\n  p += 15;\n  *p++ = (msglen >> 24) & 0xFF;\n  *p++ = (msglen >> 16) & 0xFF;\n  *p++ = (msglen >> 8) & 0xFF;\n  *p++ = msglen & 0xFF;\n  memcpy (p, input_name->value, msglen);\n\n  if (minor_status)\n    *minor_status = 0;\n  return GSS_S_COMPLETE;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/lib/krb5/oid.c": {},
  "gss/gss-1.0.3/lib/krb5/protos.h": {},
  "gss/gss-1.0.3/lib/krb5/utils.c": {
    "gss_krb5_tktlifetime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "OM_uint32\ngss_krb5_tktlifetime (Shishi_tkt * tkt)\n{\n  time_t now, end;\n\n  if (!tkt)\n    return GSS_C_INDEFINITE;\n\n  if (!shishi_tkt_valid_now_p (tkt))\n    return 0;\n\n  now = time (NULL);\n  end = shishi_tkt_endctime (tkt);\n\n  return end - now;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "OM_uint32"
      ]
    }
  },
  "gss/gss-1.0.3/src/gss.c": {
    "usage": {
      "start_point": [
        63,
        5
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void usage (int status)\n{\n  if (status != EXIT_SUCCESS)\n    fprintf (stderr, _(\"Try `%s --help' for more information.\\n\"),\n\t     program_name);\n  else\n    {\n      printf (_(\"\\\nUsage: %s OPTIONS...\\n\\\n\"), program_name);\n      fputs (_(\"\\\nCommand line interface to GSS, used to explain error codes.\\n\\\n\\n\\\n\"), stdout);\n      fputs (_(\"\\\nMandatory arguments to long options are mandatory for short options too.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -h, --help        Print help and exit.\\n\\\n  -V, --version     Print version and exit.\\n\\\n  -l, --list-mechanisms\\n\\\n                    List information about supported mechanisms\\n\\\n                    in a human readable format.\\n\\\n  -m, --major=LONG  Describe a `major status' error code value.\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -a, --accept-sec-context[=MECH]\\n\\\n                    Accept a security context as server.\\n\\\n                    If MECH is not specified, no credentials\\n\\\n                    will be acquired.  Use \\\"*\\\" to use library\\n\\\n                    default mechanism.\\n\\\n  -i, --init-sec-context=MECH\\n\\\n                    Initialize a security context as client.\\n\\\n                    MECH is the SASL name of mechanism, use -l\\n\\\n                    to list supported mechanisms.\\n\\\n  -n, --server-name=SERVICE@HOSTNAME\\n\\\n                    For -i and -a, set the name of the remote host.\\n\\\n                    For example, \\\"imap@mail.example.com\\\".\\n\\\n\"), stdout);\n      fputs (_(\"\\\n  -q, --quiet       Silent operation (default=off).\\n\\\n\"), stdout);\n      emit_bug_reporting_address ();\n    }\n  exit (status);\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "describe_major": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static int\ndescribe_major (unsigned int quiet, long major)\n{\n  gss_buffer_desc status_string;\n  OM_uint32 message_context = 0;\n  OM_uint32 maj = 0, min;\n  size_t i;\n  int rc = 0;\n\n  if (!quiet)\n    {\n      printf (_(\"GSS-API major status code %ld (0x%lx).\\n\\n\"), major, major);\n\n      printf (_(\"   MSB                               \"\n\t\t\"                                  LSB\\n\"\n\t\t\"   +-----------------+---------------\"\n\t\t\"--+---------------------------------+\\n\"\n\t\t\"   |  Calling Error  |  Routine Error\"\n\t\t\"  |       Supplementary Info        |\\n   | \"));\n      for (i = 0; i < 8; i++)\n\tprintf (\"%ld \", (major >> (31 - i)) & 1);\n      printf (\"| \");\n      for (i = 0; i < 8; i++)\n\tprintf (\"%ld \", (major >> (23 - i)) & 1);\n      printf (\"| \");\n      for (i = 0; i < 16; i++)\n\tprintf (\"%ld \", (major >> (15 - i)) & 1);\n      printf (_(\"|\\n\"\n\t\t\"   +-----------------+---------------\"\n\t\t\"--+---------------------------------+\\n\"\n\t\t\"Bit 31            24  23            1\"\n\t\t\"6  15                             0\\n\\n\"));\n    }\n\n  if (GSS_ROUTINE_ERROR (major))\n    {\n      if (!quiet)\n\tprintf (_(\"Masked routine error %ld (0x%lx) shifted \"\n\t\t  \"into %ld (0x%lx):\\n\"),\n\t\tGSS_ROUTINE_ERROR (major),\n\t\tGSS_ROUTINE_ERROR (major),\n\t\tGSS_ROUTINE_ERROR (major) >>\n\t\tGSS_C_ROUTINE_ERROR_OFFSET,\n\t\tGSS_ROUTINE_ERROR (major) >> GSS_C_ROUTINE_ERROR_OFFSET);\n\n      message_context = 0;\n      do\n\t{\n\t  maj = gss_display_status (&min, GSS_ROUTINE_ERROR (major),\n\t\t\t\t    GSS_C_GSS_CODE, GSS_C_NO_OID,\n\t\t\t\t    &message_context, &status_string);\n\t  if (GSS_ERROR (maj))\n\t    {\n\t      error (0, 0, _(\"displaying status code failed (%d)\"), maj);\n\t      rc = 1;\n\t      break;\n\t    }\n\n\t  printf (\"%.*s\\n\", (int) status_string.length,\n\t\t  (char *) status_string.value);\n\n\t  gss_release_buffer (&min, &status_string);\n\t}\n      while (message_context);\n\n      if (!quiet)\n\tprintf (\"\\n\");\n    }\n\n  if (GSS_CALLING_ERROR (major))\n    {\n      if (!quiet)\n\tprintf\n\t  (_(\"Masked calling error %ld (0x%lx) shifted into %ld (0x%lx):\\n\"),\n\t   GSS_CALLING_ERROR (major),\n\t   GSS_CALLING_ERROR (major),\n\t   GSS_CALLING_ERROR (major) >> GSS_C_CALLING_ERROR_OFFSET,\n\t   GSS_CALLING_ERROR (major) >> GSS_C_CALLING_ERROR_OFFSET);\n\n      message_context = 0;\n      do\n\t{\n\t  maj = gss_display_status (&min, GSS_CALLING_ERROR (major),\n\t\t\t\t    GSS_C_GSS_CODE, GSS_C_NO_OID,\n\t\t\t\t    &message_context, &status_string);\n\t  if (GSS_ERROR (maj))\n\t    {\n\t      error (0, 0, _(\"displaying status code failed (%d)\"), maj);\n\t      rc = 1;\n\t      break;\n\t    }\n\n\t  printf (\"%.*s\\n\", (int) status_string.length,\n\t\t  (char *) status_string.value);\n\n\t  gss_release_buffer (&min, &status_string);\n\t}\n      while (message_context);\n\n      if (!quiet)\n\tprintf (\"\\n\");\n    }\n\n  if (GSS_SUPPLEMENTARY_INFO (major))\n    {\n      if (!quiet)\n\tprintf (_(\"Masked supplementary info %ld (0x%lx) shifted \"\n\t\t  \"into %ld (0x%lx):\\n\"),\n\t\tGSS_SUPPLEMENTARY_INFO (major),\n\t\tGSS_SUPPLEMENTARY_INFO (major),\n\t\tGSS_SUPPLEMENTARY_INFO (major) >>\n\t\tGSS_C_SUPPLEMENTARY_OFFSET,\n\t\tGSS_SUPPLEMENTARY_INFO (major) >> GSS_C_SUPPLEMENTARY_OFFSET);\n\n      message_context = 0;\n      do\n\t{\n\t  maj = gss_display_status (&min,\n\t\t\t\t    GSS_SUPPLEMENTARY_INFO (major),\n\t\t\t\t    GSS_C_GSS_CODE, GSS_C_NO_OID,\n\t\t\t\t    &message_context, &status_string);\n\t  if (GSS_ERROR (maj))\n\t    {\n\t      error (0, 0, _(\"displaying status code failed (%d)\"), maj);\n\t      rc = 1;\n\t      break;\n\t    }\n\n\t  printf (\"%.*s\\n\", (int) status_string.length,\n\t\t  (char *) status_string.value);\n\n\t  gss_release_buffer (&min, &status_string);\n\t}\n      while (message_context);\n\n      if (!quiet)\n\tprintf (\"\\n\");\n    }\n\n  if (major == GSS_S_COMPLETE)\n    printf (_(\"No error\\n\"));\n\n  return rc;\n}",
      "lines": 144,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "list_mechanisms": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static int\nlist_mechanisms (unsigned quiet)\n{\n  OM_uint32 maj, min;\n  gss_OID_set mech_set;\n  size_t i;\n  gss_buffer_desc sasl_mech_name;\n  gss_buffer_desc mech_name;\n  gss_buffer_desc mech_description;\n\n  maj = gss_indicate_mechs (&min, &mech_set);\n  if (GSS_ERROR (maj))\n    {\n      error (0, 0, _(\"indicating mechanisms failed (%d)\"), maj);\n      return 1;\n    }\n\n  printf (\"Found %lu supported mechanisms.\\n\",\n\t  (unsigned long) mech_set->count);\n\n  for (i = 0; i < mech_set->count; i++)\n    {\n      printf (\"\\nMechanism %lu:\\n\", (unsigned long) i);\n\n      maj = gss_inquire_saslname_for_mech (&min, mech_set->elements++,\n\t\t\t\t\t   &sasl_mech_name, &mech_name,\n\t\t\t\t\t   &mech_description);\n      if (GSS_ERROR (maj))\n\t{\n\t  error (0, 0, _(\"inquiring information about mechanism failed (%d)\"),\n\t\t maj);\n\t  continue;\n\t}\n\n      printf (\"\\tMechanism name: %.*s\\n\",\n\t      (int) mech_name.length, (char *) mech_name.value);\n      printf (\"\\tMechanism description: %.*s\\n\",\n\t      (int) mech_description.length, (char *) mech_description.value);\n      printf (\"\\tSASL Mechanism name: %.*s\\n\",\n\t      (int) sasl_mech_name.length, (char *) sasl_mech_name.value);\n    }\n\n  return 0;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gettrimline": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "static ssize_t\ngettrimline (char **line, size_t * n, FILE * fh)\n{\n  ssize_t s = getline (line, n, fh);\n\n  if (s >= 2)\n    {\n      if ((*line)[strlen (*line) - 1] == '\\n')\n\t(*line)[strlen (*line) - 1] = '\\0';\n      if ((*line)[strlen (*line) - 1] == '\\r')\n\t(*line)[strlen (*line) - 1] = '\\0';\n    }\n\n  return s;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "init_sec_context": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "static int\ninit_sec_context (unsigned quiet, const char *mech, const char *server)\n{\n  OM_uint32 maj, min;\n  gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n  gss_name_t servername = GSS_C_NO_NAME;\n  gss_buffer_desc inbuf_desc;\n  gss_buffer_t inbuf = GSS_C_NO_BUFFER;\n  gss_buffer_desc bufdesc;\n  gss_buffer_desc sasl_mech_name;\n  gss_OID mech_type;\n  size_t outlen;\n  char *out;\n  ssize_t s;\n  char *line = NULL;\n  size_t n = 0;\n  bool ok;\n  OM_uint32 ret_flags;\n\n  sasl_mech_name.length = strlen (mech);\n  sasl_mech_name.value = (void *) mech;\n\n  maj = gss_inquire_mech_for_saslname (&min, &sasl_mech_name, &mech_type);\n  if (GSS_ERROR (maj))\n    error (EXIT_FAILURE, 0,\n\t   _(\"inquiring mechanism for SASL name (%d/%d)\"), maj, min);\n\n  if (server)\n    {\n      gss_buffer_desc namebuf;\n\n      namebuf.length = strlen (server);\n      namebuf.value = (void *) server;\n\n      maj = gss_import_name (&min, &namebuf, GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t     &servername);\n      if (GSS_ERROR (maj))\n\terror (EXIT_FAILURE, 0,\n\t       _(\"could not import server name \\\"%s\\\" (%d/%d)\"),\n\t       server, maj, min);\n    }\n\n  do\n    {\n      maj = gss_init_sec_context (&min,\n\t\t\t\t  GSS_C_NO_CREDENTIAL,\n\t\t\t\t  &ctx,\n\t\t\t\t  servername,\n\t\t\t\t  mech_type,\n\t\t\t\t  GSS_C_MUTUAL_FLAG |\n\t\t\t\t  GSS_C_REPLAY_FLAG |\n\t\t\t\t  GSS_C_SEQUENCE_FLAG,\n\t\t\t\t  0,\n\t\t\t\t  GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t  inbuf, NULL, &bufdesc, &ret_flags, NULL);\n      if (GSS_ERROR (maj))\n\terror (EXIT_FAILURE, 0,\n\t       _(\"initializing security context failed (%d/%d)\"), maj, min);\n\n      outlen = base64_encode_alloc (bufdesc.value, bufdesc.length, &out);\n      if (out == NULL && outlen == 0 && bufdesc.length != 0)\n\terror (EXIT_FAILURE, 0, _(\"base64 input too long\"));\n      if (out == NULL)\n\terror (EXIT_FAILURE, errno, _(\"malloc\"));\n\n      if (!quiet)\n\t{\n\t  if (maj == GSS_S_COMPLETE && bufdesc.length == 0)\n\t    printf (\"Context has been initialized.\\n\");\n\t  else if (maj == GSS_S_COMPLETE)\n\t    printf (\"Context has been initialized.  Final context token:\\n\");\n\t  else if (maj == GSS_S_CONTINUE_NEEDED &&\n\t\t   (ret_flags & GSS_C_PROT_READY_FLAG))\n\t    printf (\"Context token (protection is available):\\n\");\n\t  else if (maj == GSS_S_CONTINUE_NEEDED)\n\t    printf (\"Context token:\\n\");\n\t}\n      if (bufdesc.length != 0)\n\tprintf (\"%s\\n\", out);\n\n      free (out);\n\n      if (maj == GSS_S_COMPLETE)\n\tbreak;\n\n      if (!quiet)\n\tprintf (\"Input context token:\\n\");\n\n      s = gettrimline (&line, &n, stdin);\n      if (s == -1 && !feof (stdin))\n\terror (EXIT_FAILURE, errno, _(\"getline\"));\n      if (s == -1)\n\terror (EXIT_FAILURE, 0, _(\"end of file\"));\n\n      ok = base64_decode_alloc (line, strlen (line), &out, &outlen);\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"base64 fail\"));\n      if (out == NULL)\n\terror (EXIT_FAILURE, errno, _(\"malloc\"));\n\n      inbuf_desc.value = out;\n      inbuf_desc.length = outlen;\n      inbuf = &inbuf_desc;\n    }\n  while (maj == GSS_S_CONTINUE_NEEDED);\n\n  return 0;\n}",
      "lines": 108,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "accept_sec_context": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        587,
        1
      ],
      "content": "static int\naccept_sec_context (unsigned quiet, const char *mech, const char *server)\n{\n  OM_uint32 maj, min;\n  gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n  gss_cred_id_t cred = GSS_C_NO_CREDENTIAL;\n  gss_name_t client = GSS_C_NO_NAME;\n  gss_buffer_desc bufdesc, bufdesc2;\n  gss_OID mech_type = GSS_C_NO_OID;\n  char *out;\n  size_t outlen;\n  ssize_t s;\n  char *line = NULL;\n  size_t n = 0;\n  bool ok;\n  OM_uint32 ret_flags;\n\n  /*\n    We support these variants:\n\n    1) No call to gss_acquire_cred at all.  This happens if mech=NULL\n    and server=NULL.\n\n    2) Call to gss_acquire_cred with desired_mechs=GSS_C_NULL_OID_SET\n    and desired_name=GSS_C_NO_NAME.  This happens if mech=\"*\" (the\n    string) and server=NULL.\n\n    3) Call to gss_acquire_cred with desired_mechs=GSS_C_NULL_OID_SET\n    and desired_name=server.  This happens if mech=NULL or mech=\"*\"\n    (the string) and server!=NULL.\n\n    4) Call to gss_acquire_cred with desired_mechs=mech and\n    desired_name=GSS_C_NO_NAME.  This happens if mech is a valid\n    SASL-name and server=NULL.\n\n    5) Call to gss_acquire_cred with desired_mechs=mech and\n    desired_name=server.  This happens if mech is a valid SASL-name\n    and server!=NULL.\n   */\n\n  if (mech || server)\n    {\n      gss_name_t servername = GSS_C_NO_NAME;\n      gss_OID_set mech_types = GSS_C_NULL_OID_SET;\n\n      if (mech && strcmp (mech, \"*\") != 0)\n\t{\n\t  gss_buffer_desc sasl_mech_name;\n\n\t  sasl_mech_name.length = strlen (mech);\n\t  sasl_mech_name.value = (void *) mech;\n\n\t  printf (\"Inquiring mechanism OID for SASL name \\\"%s\\\"...\\n\", mech);\n\t  maj = gss_inquire_mech_for_saslname (&min, &sasl_mech_name,\n\t\t\t\t\t       &mech_type);\n\t  if (GSS_ERROR (maj))\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"inquiring mechanism for SASL name (%d/%d)\"), maj, min);\n\t}\n\n      if (server)\n\t{\n\t  gss_buffer_desc namebuf;\n\n\t  namebuf.length = strlen (server);\n\t  namebuf.value = (void *) server;\n\n\t  printf (\"Importing name \\\"%s\\\"...\\n\", server);\n\t  maj = gss_import_name (&min, &namebuf, GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\t &servername);\n\t  if (GSS_ERROR (maj))\n\t    error (EXIT_FAILURE, 0,\n\t\t   _(\"could not import server name \\\"%s\\\" (%d/%d)\"),\n\t\t   server, maj, min);\n\t}\n\n      if (mech_type != GSS_C_NO_OID)\n\t{\n\t  maj = gss_create_empty_oid_set (&min, &mech_types);\n\t  if (GSS_ERROR (maj))\n\t    error (EXIT_FAILURE, 0, \"gss_create_empty_oid_set (%d/%d)\",\n\t\t   maj, min);\n\n\t  maj = gss_add_oid_set_member (&min, mech_type, &mech_types);\n\t  if (GSS_ERROR (maj))\n\t    error (EXIT_FAILURE, 0, \"gss_add_oid_set_member (%d/%d)\",\n\t\t   maj, min);\n\t}\n\n      printf (\"Acquiring credentials...\\n\");\n      maj = gss_acquire_cred (&min, servername, 0, mech_types, GSS_C_ACCEPT,\n\t\t\t      &cred, NULL, NULL);\n      if (GSS_ERROR (maj))\n\terror (EXIT_FAILURE, 0,\n\t       _(\"could not acquire server credentials (%d/%d)\"), maj, min);\n\n      if (mech_type != GSS_C_NO_OID)\n\t{\n\t  maj = gss_release_oid_set (&min, &mech_types);\n\t  if (GSS_ERROR (maj))\n\t    error (EXIT_FAILURE, 0, \"gss_release_oid_set (%d/%d)\", maj, min);\n\t}\n    }\n\n  do\n    {\n      if (!quiet)\n\tprintf (\"Input context token:\\n\");\n\n      s = gettrimline (&line, &n, stdin);\n      if (s == -1 && !feof (stdin))\n\terror (EXIT_FAILURE, errno, _(\"getline\"));\n      if (s == -1)\n\terror (EXIT_FAILURE, 0, _(\"end of file\"));\n\n      ok = base64_decode_alloc (line, strlen (line), &out, &outlen);\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"base64 fail\"));\n      if (out == NULL)\n\terror (EXIT_FAILURE, errno, _(\"malloc\"));\n\n      bufdesc.value = out;\n      bufdesc.length = outlen;\n\n      maj = gss_accept_sec_context (&min,\n\t\t\t\t    &ctx,\n\t\t\t\t    cred,\n\t\t\t\t    &bufdesc,\n\t\t\t\t    GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t    &client,\n\t\t\t\t    &mech_type,\n\t\t\t\t    &bufdesc2, &ret_flags, NULL, NULL);\n      if (GSS_ERROR (maj))\n\terror (EXIT_FAILURE, 0,\n\t       _(\"accepting security context failed (%d/%d)\"), maj, min);\n\n      outlen = base64_encode_alloc (bufdesc2.value, bufdesc2.length, &out);\n      if (out == NULL && outlen == 0 && bufdesc2.length != 0)\n\terror (EXIT_FAILURE, 0, _(\"base64 input too long\"));\n      if (out == NULL)\n\terror (EXIT_FAILURE, errno, _(\"malloc\"));\n\n      if (!quiet)\n\t{\n\t  if (maj == GSS_S_COMPLETE && bufdesc2.length == 0)\n\t    printf (\"Context has been accepted.\\n\");\n\t  else if (maj == GSS_S_COMPLETE)\n\t    printf (\"Context has been accepted.  Final context token:\\n\");\n\t  else if (maj == GSS_S_CONTINUE_NEEDED &&\n\t\t   (ret_flags & GSS_C_PROT_READY_FLAG))\n\t    printf (\"Context token (protection is available):\\n\");\n\t  else if (maj == GSS_S_CONTINUE_NEEDED)\n\t    printf (\"Context token:\\n\");\n\t}\n      if (bufdesc2.length != 0)\n\tprintf (\"%s\\n\", out);\n\n      free (out);\n    }\n  while (maj == GSS_S_CONTINUE_NEEDED);\n\n  return 0;\n}",
      "lines": 163,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        589,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  struct gengetopt_args_info args;\n  int rc = 0;\n\n  setlocale (LC_ALL, \"\");\n  set_program_name (argv[0]);\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  if (cmdline_parser (argc, argv, &args) != 0)\n    return 1;\n\n  if (args.version_given)\n    {\n      version_etc (stdout, \"gss\", PACKAGE_NAME, VERSION,\n\t\t   \"Simon Josefsson\", (char *) NULL);\n      return EXIT_SUCCESS;\n    }\n\n  if (args.help_given)\n    usage (EXIT_SUCCESS);\n  else if (args.major_given)\n    rc = describe_major (args.quiet_given, args.major_arg);\n  else if (args.list_mechanisms_given)\n    rc = list_mechanisms (args.quiet_given);\n  else if (args.init_sec_context_given)\n    rc = init_sec_context (args.quiet_given, args.init_sec_context_arg,\n\t\t\t   args.server_name_arg);\n  else if (args.accept_sec_context_given)\n    rc = accept_sec_context (args.quiet_given, args.accept_sec_context_arg,\n\t\t\t     args.server_name_arg);\n  else\n    usage (EXIT_SUCCESS);\n\n  return rc;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/src/gss_cmd.c": {
    "clear_given": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static\nvoid clear_given (struct gengetopt_args_info *args_info)\n{\n  args_info->help_given = 0 ;\n  args_info->version_given = 0 ;\n  args_info->major_given = 0 ;\n  args_info->list_mechanisms_given = 0 ;\n  args_info->accept_sec_context_given = 0 ;\n  args_info->init_sec_context_given = 0 ;\n  args_info->server_name_given = 0 ;\n  args_info->quiet_given = 0 ;\n}",
      "lines": 12,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clear_args": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static\nvoid clear_args (struct gengetopt_args_info *args_info)\n{\n  FIX_UNUSED (args_info);\n  args_info->major_orig = NULL;\n  args_info->accept_sec_context_arg = NULL;\n  args_info->accept_sec_context_orig = NULL;\n  args_info->init_sec_context_arg = NULL;\n  args_info->init_sec_context_orig = NULL;\n  args_info->server_name_arg = NULL;\n  args_info->server_name_orig = NULL;\n  args_info->quiet_flag = 0;\n  \n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_args_info": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static\nvoid init_args_info(struct gengetopt_args_info *args_info)\n{\n\n\n  args_info->help_help = gengetopt_args_info_help[0] ;\n  args_info->version_help = gengetopt_args_info_help[1] ;\n  args_info->major_help = gengetopt_args_info_help[2] ;\n  args_info->list_mechanisms_help = gengetopt_args_info_help[3] ;\n  args_info->accept_sec_context_help = gengetopt_args_info_help[4] ;\n  args_info->init_sec_context_help = gengetopt_args_info_help[5] ;\n  args_info->server_name_help = gengetopt_args_info_help[6] ;\n  args_info->quiet_help = gengetopt_args_info_help[7] ;\n  \n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_version": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ncmdline_parser_print_version (void)\n{\n  printf (\"%s %s\\n\",\n     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),\n     CMDLINE_PARSER_VERSION);\n\n  if (strlen(gengetopt_args_info_versiontext) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_versiontext);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "print_help_common": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void print_help_common(void) {\n  cmdline_parser_print_version ();\n\n  if (strlen(gengetopt_args_info_purpose) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_purpose);\n\n  if (strlen(gengetopt_args_info_usage) > 0)\n    printf(\"\\n%s\\n\", gengetopt_args_info_usage);\n\n  printf(\"\\n\");\n\n  if (strlen(gengetopt_args_info_description) > 0)\n    printf(\"%s\\n\\n\", gengetopt_args_info_description);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_print_help": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\ncmdline_parser_print_help (void)\n{\n  int i = 0;\n  print_help_common();\n  while (gengetopt_args_info_help[i])\n    printf(\"%s\\n\", gengetopt_args_info_help[i++]);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_init": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\ncmdline_parser_init (struct gengetopt_args_info *args_info)\n{\n  clear_given (args_info);\n  clear_args (args_info);\n  init_args_info (args_info);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_init": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ncmdline_parser_params_init(struct cmdline_parser_params *params)\n{\n  if (params)\n    { \n      params->override = 0;\n      params->initialize = 1;\n      params->check_required = 1;\n      params->check_ambiguity = 0;\n      params->print_errors = 1;\n    }\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "cmdline_parser_params_create": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "struct cmdline_parser_params *\ncmdline_parser_params_create(void)\n{\n  struct cmdline_parser_params *params = \n    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));\n  cmdline_parser_params_init(params);  \n  return params;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "struct cmdline_parser_params",
        "struct",
        "cmdline_parser_params",
        "*\ncmdline_parser_params_create(void)",
        "*"
      ]
    },
    "free_string_field": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\nfree_string_field (char **s)\n{\n  if (*s)\n    {\n      free (*s);\n      *s = 0;\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_release": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\ncmdline_parser_release (struct gengetopt_args_info *args_info)\n{\n\n  free_string_field (&(args_info->major_orig));\n  free_string_field (&(args_info->accept_sec_context_arg));\n  free_string_field (&(args_info->accept_sec_context_orig));\n  free_string_field (&(args_info->init_sec_context_arg));\n  free_string_field (&(args_info->init_sec_context_orig));\n  free_string_field (&(args_info->server_name_arg));\n  free_string_field (&(args_info->server_name_orig));\n  \n  \n\n  clear_given (args_info);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "write_into_file": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static void\nwrite_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])\n{\n  FIX_UNUSED (values);\n  if (arg) {\n    fprintf(outfile, \"%s=\\\"%s\\\"\\n\", opt, arg);\n  } else {\n    fprintf(outfile, \"%s\\n\", opt);\n  }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmdline_parser_dump": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "int\ncmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)\n{\n  int i = 0;\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot dump options to stream\\n\", CMDLINE_PARSER_PACKAGE);\n      return EXIT_FAILURE;\n    }\n\n  if (args_info->help_given)\n    write_into_file(outfile, \"help\", 0, 0 );\n  if (args_info->version_given)\n    write_into_file(outfile, \"version\", 0, 0 );\n  if (args_info->major_given)\n    write_into_file(outfile, \"major\", args_info->major_orig, 0);\n  if (args_info->list_mechanisms_given)\n    write_into_file(outfile, \"list-mechanisms\", 0, 0 );\n  if (args_info->accept_sec_context_given)\n    write_into_file(outfile, \"accept-sec-context\", args_info->accept_sec_context_orig, 0);\n  if (args_info->init_sec_context_given)\n    write_into_file(outfile, \"init-sec-context\", args_info->init_sec_context_orig, 0);\n  if (args_info->server_name_given)\n    write_into_file(outfile, \"server-name\", args_info->server_name_orig, 0);\n  if (args_info->quiet_given)\n    write_into_file(outfile, \"quiet\", 0, 0 );\n  \n\n  i = EXIT_SUCCESS;\n  return i;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_file_save": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "int\ncmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)\n{\n  FILE *outfile;\n  int i = 0;\n\n  outfile = fopen(filename, \"w\");\n\n  if (!outfile)\n    {\n      fprintf (stderr, \"%s: cannot open file for writing: %s\\n\", CMDLINE_PARSER_PACKAGE, filename);\n      return EXIT_FAILURE;\n    }\n\n  i = cmdline_parser_dump(outfile, args_info);\n  fclose (outfile);\n\n  return i;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_free": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\ncmdline_parser_free (struct gengetopt_args_info *args_info)\n{\n  cmdline_parser_release (args_info);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gengetopt_strdup": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "char *\ngengetopt_strdup (const char *s)\n{\n  char *result = 0;\n  if (!s)\n    return result;\n\n  result = (char*)malloc(strlen(s) + 1);\n  if (result == (char*)0)\n    return (char*)0;\n  strcpy(result, s);\n  return result;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "char",
        "*\ngengetopt_strdup (const char *s)",
        "*"
      ]
    },
    "cmdline_parser": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "int\ncmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)\n{\n  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_ext": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "int\ncmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,\n                   struct cmdline_parser_params *params)\n{\n  int result;\n  result = cmdline_parser_internal (argc, argv, args_info, params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser2": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "int\ncmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)\n{\n  int result;\n  struct cmdline_parser_params params;\n  \n  params.override = override;\n  params.initialize = initialize;\n  params.check_required = check_required;\n  params.check_ambiguity = 0;\n  params.print_errors = 1;\n\n  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);\n\n  if (result == EXIT_FAILURE)\n    {\n      cmdline_parser_free (args_info);\n      exit (EXIT_FAILURE);\n    }\n  \n  return result;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "cmdline_parser_required": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "int\ncmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)\n{\n  FIX_UNUSED (args_info);\n  FIX_UNUSED (prog_name);\n  return EXIT_SUCCESS;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "update_arg": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        457,
        1
      ],
      "content": "static\nint update_arg(void *field, char **orig_field,\n               unsigned int *field_given, unsigned int *prev_given, \n               char *value, const char *possible_values[],\n               const char *default_value,\n               cmdline_parser_arg_type arg_type,\n               int check_ambiguity, int override,\n               int no_free, int multiple_option,\n               const char *long_opt, char short_opt,\n               const char *additional_error)\n{\n  char *stop_char = 0;\n  const char *val = value;\n  int found;\n  char **string_field;\n  FIX_UNUSED (field);\n\n  stop_char = 0;\n  found = 0;\n\n  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))\n    {\n      if (short_opt != '-')\n        fprintf (stderr, \"%s: `--%s' (`-%c') option given more than once%s\\n\", \n               package_name, long_opt, short_opt,\n               (additional_error ? additional_error : \"\"));\n      else\n        fprintf (stderr, \"%s: `--%s' option given more than once%s\\n\", \n               package_name, long_opt,\n               (additional_error ? additional_error : \"\"));\n      return 1; /* failure */\n    }\n\n  FIX_UNUSED (default_value);\n    \n  if (field_given && *field_given && ! override)\n    return 0;\n  if (prev_given)\n    (*prev_given)++;\n  if (field_given)\n    (*field_given)++;\n  if (possible_values)\n    val = possible_values[found];\n\n  switch(arg_type) {\n  case ARG_FLAG:\n    *((int *)field) = !*((int *)field);\n    break;\n  case ARG_LONG:\n    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);\n    break;\n  case ARG_STRING:\n    if (val) {\n      string_field = (char **)field;\n      if (!no_free && *string_field)\n        free (*string_field); /* free previous string */\n      *string_field = gengetopt_strdup (val);\n    }\n    break;\n  default:\n    break;\n  };\n\n  /* check numeric conversion */\n  switch(arg_type) {\n  case ARG_LONG:\n    if (val && !(stop_char && *stop_char == '\\0')) {\n      fprintf(stderr, \"%s: invalid numeric value: %s\\n\", package_name, val);\n      return 1; /* failure */\n    }\n    break;\n  default:\n    ;\n  };\n\n  /* store the original value */\n  switch(arg_type) {\n  case ARG_NO:\n  case ARG_FLAG:\n    break;\n  default:\n    if (value && orig_field) {\n      if (no_free) {\n        *orig_field = value;\n      } else {\n        if (*orig_field)\n          free (*orig_field); /* free previous string */\n        *orig_field = gengetopt_strdup (value);\n      }\n    }\n  };\n\n  return 0; /* OK */\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmdline_parser_internal": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "int\ncmdline_parser_internal (\n  int argc, char **argv, struct gengetopt_args_info *args_info,\n                        struct cmdline_parser_params *params, const char *additional_error)\n{\n  int c;\t/* Character of the parsed option.  */\n\n  int error_occurred = 0;\n  struct gengetopt_args_info local_args_info;\n  \n  int override;\n  int initialize;\n  int check_required;\n  int check_ambiguity;\n  \n  package_name = argv[0];\n  \n  override = params->override;\n  initialize = params->initialize;\n  check_required = params->check_required;\n  check_ambiguity = params->check_ambiguity;\n\n  if (initialize)\n    cmdline_parser_init (args_info);\n\n  cmdline_parser_init (&local_args_info);\n\n  optarg = 0;\n  optind = 0;\n  opterr = params->print_errors;\n  optopt = '?';\n\n  while (1)\n    {\n      int option_index = 0;\n\n      static struct option long_options[] = {\n        { \"help\",\t0, NULL, 'h' },\n        { \"version\",\t0, NULL, 'V' },\n        { \"major\",\t1, NULL, 'm' },\n        { \"list-mechanisms\",\t0, NULL, 'l' },\n        { \"accept-sec-context\",\t2, NULL, 'a' },\n        { \"init-sec-context\",\t1, NULL, 'i' },\n        { \"server-name\",\t1, NULL, 'n' },\n        { \"quiet\",\t0, NULL, 'q' },\n        { 0,  0, 0, 0 }\n      };\n\n      c = getopt_long (argc, argv, \"hVm:la::i:n:q\", long_options, &option_index);\n\n      if (c == -1) break;\t/* Exit from `while (1)' loop.  */\n\n      switch (c)\n        {\n        case 'h':\t/* Print help and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->help_given),\n              &(local_args_info.help_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"help\", 'h',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'V':\t/* Print version and exit.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->version_given),\n              &(local_args_info.version_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"version\", 'V',\n              additional_error))\n            goto failure;\n          cmdline_parser_free (&local_args_info);\n          return 0;\n        \n          break;\n        case 'm':\t/* See gss.c for doc string.  */\n        \n        \n          if (update_arg( (void *)&(args_info->major_arg), \n               &(args_info->major_orig), &(args_info->major_given),\n              &(local_args_info.major_given), optarg, 0, 0, ARG_LONG,\n              check_ambiguity, override, 0, 0,\n              \"major\", 'm',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'l':\t/* See gss.c for doc string.  */\n        \n        \n          if (update_arg( 0 , \n               0 , &(args_info->list_mechanisms_given),\n              &(local_args_info.list_mechanisms_given), optarg, 0, 0, ARG_NO,\n              check_ambiguity, override, 0, 0,\n              \"list-mechanisms\", 'l',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'a':\t/* See gss.c for doc string.  */\n        \n        \n          if (update_arg( (void *)&(args_info->accept_sec_context_arg), \n               &(args_info->accept_sec_context_orig), &(args_info->accept_sec_context_given),\n              &(local_args_info.accept_sec_context_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"accept-sec-context\", 'a',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'i':\t/* See gss.c for doc string.  */\n        \n        \n          if (update_arg( (void *)&(args_info->init_sec_context_arg), \n               &(args_info->init_sec_context_orig), &(args_info->init_sec_context_given),\n              &(local_args_info.init_sec_context_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"init-sec-context\", 'i',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'n':\t/* See gss.c for doc string.  */\n        \n        \n          if (update_arg( (void *)&(args_info->server_name_arg), \n               &(args_info->server_name_orig), &(args_info->server_name_given),\n              &(local_args_info.server_name_given), optarg, 0, 0, ARG_STRING,\n              check_ambiguity, override, 0, 0,\n              \"server-name\", 'n',\n              additional_error))\n            goto failure;\n        \n          break;\n        case 'q':\t/* Silent operation.  */\n        \n        \n          if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),\n              &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,\n              check_ambiguity, override, 1, 0, \"quiet\", 'q',\n              additional_error))\n            goto failure;\n        \n          break;\n\n        case 0:\t/* Long option with no short option */\n        case '?':\t/* Invalid option.  */\n          /* `getopt_long' already printed an error message.  */\n          goto failure;\n\n        default:\t/* bug: option not considered.  */\n          fprintf (stderr, \"%s: option unknown: %c%s\\n\", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : \"\"));\n          abort ();\n        } /* switch */\n    } /* while */\n\n\n\n\n  cmdline_parser_release (&local_args_info);\n\n  if ( error_occurred )\n    return (EXIT_FAILURE);\n\n  return 0;\n\nfailure:\n  \n  cmdline_parser_release (&local_args_info);\n  return (EXIT_FAILURE);\n}",
      "lines": 179,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/src/gss_cmd.h": {},
  "gss/gss-1.0.3/src/gl/base64.c": {
    "to_uchar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "base64_encode_fast": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nbase64_encode_fast (const char *restrict in, size_t inlen, char *restrict out)\n{\n  while (inlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      *out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n      *out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n      *out++ = b64c[to_uchar (in[2]) & 0x3f];\n\n      inlen -= 3;\n      in += 3;\n    }\n}",
      "lines": 14,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nbase64_encode (const char *restrict in, size_t inlen,\n               char *restrict out, size_t outlen)\n{\n  /* Note this outlen constraint can be enforced at compile time.\n     I.E. that the output buffer is exactly large enough to hold\n     the encoded inlen bytes.  The inlen constraints (of corresponding\n     to outlen, and being a multiple of 3) can change at runtime\n     at the end of input.  However the common case when reading\n     large inputs is to have both constraints satisfied, so we depend\n     on both in base_encode_fast().  */\n  if (outlen % 4 == 0 && inlen == outlen / 4 * 3)\n    {\n      base64_encode_fast (in, inlen, out);\n      return;\n    }\n\n  while (inlen && outlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      if (!--outlen)\n        break;\n      *out++ = b64c[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64c[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_alloc": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "size_t\nbase64_encode_alloc (const char *in, size_t inlen, char **out)\n{\n  size_t outlen = 1 + BASE64_LENGTH (inlen);\n\n  /* Check for overflow in outlen computation.\n   *\n   * If there is no overflow, outlen >= inlen.\n   *\n   * If the operation (inlen + 2) overflows then it yields at most +1, so\n   * outlen is 0.\n   *\n   * If the multiplication overflows, we lose at least half of the\n   * correct value, so the result is < ((inlen + 2) / 3) * 2, which is\n   * less than (inlen + 2) * 0.66667, which is less than inlen as soon as\n   * (inlen > 4).\n   */\n  if (inlen > outlen)\n    {\n      *out = NULL;\n      return 0;\n    }\n\n  *out = malloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "isbase64": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "bool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_ctx_init": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_4": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n          /* This is the common case: no newline.  */\n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n    /* Copy non-newline bytes into BUF.  */\n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)",
        "*"
      ]
    },
    "decode_4": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static bool\ndecode_4 (char const *restrict in, size_t inlen,\n          char *restrict *outp, size_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}",
      "lines": 66,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "base64_decode_ctx": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "bool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, size_t inlen,\n                   char *restrict out, size_t *outlen)\n{\n  size_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      size_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n              /* Save a copy of outleft, in case we need to re-parse this\n                 block of four bytes.  */\n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n      /* Handle the common case of 72-byte wrapped lines.\n         This also handles any other multiple-of-4-byte wrapping.  */\n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n      /* Restore OUT and OUTLEFT.  */\n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;  /* Might have nl in this case. */\n\n        /* If the input is empty or consists solely of newlines (0 non-newlines),\n           then we're done.  Likewise if there are fewer than 4 bytes when not\n           flushing context and not treating newlines as garbage.  */\n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_alloc_ctx": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "bool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, size_t inlen, char **out,\n                         size_t *outlen)\n{\n  /* This may allocate a few bytes too many, depending on input,\n     but it's not worth the extra CPU time to compute the exact size.\n     The exact size is 3 * (inlen + (ctx ? ctx->i : 0)) / 4, minus 1 if the\n     input ends with \"=\" and minus another 1 if the input ends with \"==\".\n     Dividing before multiplying avoids the possibility of overflow.  */\n  size_t needlen = 3 * (inlen / 4) + 3;\n\n  *out = malloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/base64.h": {},
  "gss/gss-1.0.3/src/gl/errno.in.h": {},
  "gss/gss-1.0.3/src/gl/error.c": {
    "is_open": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if _LIBC || STRERROR_R_CHAR_P\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        201,
        42
      ],
      "end_point": [
        283,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / sizeof (wchar_t) / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 83,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || (old_file_name != NULL\n                  && file_name != NULL\n                  && strcmp (old_file_name, file_name) == 0)))\n\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/error.h": {},
  "gss/gss-1.0.3/src/gl/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n                struct option_list *newp = malloc (sizeof (*newp));\n                newp->p = p;\n                newp->next = ambig_list;\n                ambig_list = newp;\n              }\n          }\n\n      if (ambig_list != NULL && !exact)\n        {\n          if (print_errors)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n\n      while (ambig_list != NULL)\n        {\n          struct option_list *pn = ambig_list->next;\n          free (ambig_list);\n          ambig_list = pn;\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 781,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1172,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/getopt.in.h": {},
  "gss/gss-1.0.3/src/gl/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/getopt_int.h": {},
  "gss/gss-1.0.3/src/gl/gettext.h": {},
  "gss/gss-1.0.3/src/gl/intprops.h": {},
  "gss/gss-1.0.3/src/gl/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/msvc-inval.h": {},
  "gss/gss-1.0.3/src/gl/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/msvc-nothrow.h": {},
  "gss/gss-1.0.3/src/gl/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/progname.h": {},
  "gss/gss-1.0.3/src/gl/stdarg.in.h": {},
  "gss/gss-1.0.3/src/gl/stdbool.in.h": {},
  "gss/gss-1.0.3/src/gl/stddef.in.h": {},
  "gss/gss-1.0.3/src/gl/stdio.in.h": {},
  "gss/gss-1.0.3/src/gl/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/strerror-override.h": {},
  "gss/gss-1.0.3/src/gl/strerror.c": {},
  "gss/gss-1.0.3/src/gl/string.in.h": {},
  "gss/gss-1.0.3/src/gl/sys_types.in.h": {},
  "gss/gss-1.0.3/src/gl/unistd.c": {},
  "gss/gss-1.0.3/src/gl/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/verify.h": {},
  "gss/gss-1.0.3/src/gl/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "gss/gss-1.0.3/src/gl/version-etc.h": {},
  "gss/gss-1.0.3/tests/basic.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  gss_uint32 maj_stat, min_stat, msgctx;\n  gss_buffer_desc bufdesc, bufdesc2;\n  gss_name_t service;\n  gss_OID_set oids;\n  int n;\n\n  do\n    if (strcmp (argv[argc - 1], \"-v\") == 0 ||\n\tstrcmp (argv[argc - 1], \"--verbose\") == 0)\n      debug = 1;\n    else if (strcmp (argv[argc - 1], \"-b\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--break-on-error\") == 0)\n      break_on_error = 1;\n    else if (strcmp (argv[argc - 1], \"-h\") == 0 ||\n\t     strcmp (argv[argc - 1], \"-?\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--help\") == 0)\n      {\n\tprintf (\"Usage: %s [-vbh?] [--verbose] [--break-on-error] [--help]\\n\",\n\t\targv[0]);\n\treturn 1;\n      }\n  while (argc-- > 1);\n\n  /* OID set tests */\n  oids = GSS_C_NO_OID_SET;\n  maj_stat = gss_create_empty_oid_set (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_create_empty_oid_set() OK\\n\");\n  else\n    fail (\"gss_create_empty_oid_set() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Test empty set */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_USER_NAME,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    OID present in empty set => %d\\n\", n);\n\n  if (!n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Add an OID */\n  maj_stat = gss_add_oid_set_member (&min_stat, GSS_C_NT_USER_NAME, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_add_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_add_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Test set for added OID */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_USER_NAME,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    OID present in set with the OID added to it => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Test set for another OID */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_ANONYMOUS,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    Another OID present in set without the OID => %d\\n\", n);\n\n  if (!n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Add another OID */\n  maj_stat = gss_add_oid_set_member (&min_stat, GSS_C_NT_ANONYMOUS, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_add_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_add_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Test set for added OID */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_ANONYMOUS,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    Another OID present in set with it added => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Test set for first OID */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_USER_NAME,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    First OID present in set => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_release_oid_set (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_oid_set() OK\\n\");\n  else\n    fail (\"gss_release_oid_set() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Check mechs */\n  oids = GSS_C_NO_OID_SET;\n  maj_stat = gss_indicate_mechs (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_indicate_mechs() OK\\n\");\n  else\n    fail (\"gss_indicate_mechs() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n#ifdef USE_KERBEROS5\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_KRB5, oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    kerberos5 supported => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n#endif\n\n  maj_stat = gss_release_oid_set (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_oid_set() OK\\n\");\n  else\n    fail (\"gss_release_oid_set() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n#ifdef USE_KERBEROS5\n  maj_stat = gss_inquire_names_for_mech (&min_stat, GSS_KRB5, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_names_for_mech() OK\\n\");\n  else\n    fail (\"gss_inquire_names_for_mech() failed (%d,%d)\\n\", maj_stat,\n\t  min_stat);\n\n  /* Check if KRB5 supports PRINCIPAL_NAME name type */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_KRB5_NT_PRINCIPAL_NAME,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    kerberos5 supports PRINCIPAL_NAME name type => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Check if KRB5 supports HOSTBASED NAME name type */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    kerberos5 supports HOSTBASED_SERVICE name type => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Check if KRB5 supports ANONYMOUS name type */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_ANONYMOUS,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    kerberos5 supports ANONYMOUS name type => %d\\n\", n);\n\n  if (!n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_release_oid_set (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_oid_set() OK\\n\");\n  else\n    fail (\"gss_release_oid_set() failed (%d,%d)\\n\", maj_stat, min_stat);\n#endif\n\n  /* Check name */\n  service = NULL;\n  bufdesc.value = (char *) \"imap@server.example.org@FOO\";\n  bufdesc.length = strlen (bufdesc.value);\n\n  maj_stat = gss_import_name (&min_stat, &bufdesc, GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t      &service);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_import_name() OK\\n\");\n  else\n    fail (\"gss_import_name() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_display_name (&min_stat, service, &bufdesc2, NULL);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_display_name() OK\\n\");\n  else\n    fail (\"gss_display_name() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    display_name() => %d: %.*s\\n\", (int) bufdesc2.length,\n\t    (int) bufdesc2.length, (char *) bufdesc2.value);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n#ifdef USE_KERBEROS5\n  /* NB: \"service\" resused from previous test */\n  maj_stat = gss_inquire_mechs_for_name (&min_stat, service, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_mechs_for_name() OK\\n\");\n  else\n    fail (\"gss_inquire_mechs_for_name() failed (%d,%d)\\n\", maj_stat,\n\t  min_stat);\n\n  /* Check GSS_C_NT_HOSTBASED_SERVICE name type is supported by KRB5 */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_KRB5, oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    HOSTBASED_SERVICE supported by kerberos5 => %d\\n\", n);\n\n  if (n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Dummy OID check */\n  maj_stat = gss_test_oid_set_member (&min_stat, GSS_C_NT_ANONYMOUS,\n\t\t\t\t      oids, &n);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    Dummy oid supported by kerberos5 => %d\\n\", n);\n\n  if (!n)\n    success (\"gss_test_oid_set_member() OK\\n\");\n  else\n    fail (\"gss_test_oid_set_member() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_release_oid_set (&min_stat, &oids);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_oid_set() OK\\n\");\n  else\n    fail (\"gss_release_oid_set() failed (%d,%d)\\n\", maj_stat, min_stat);\n#endif\n\n  /* Release service allocated earlier. */\n  maj_stat = gss_release_name (&min_stat, &service);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_name() OK\\n\");\n  else\n    fail (\"gss_release_name() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Check display_status */\n  msgctx = 0;\n  maj_stat = gss_display_status (&min_stat, GSS_S_COMPLETE, GSS_C_GSS_CODE,\n\t\t\t\t GSS_C_NO_OID, &msgctx, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_display_status() OK\\n\");\n  else\n    fail (\"gss_display_status() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"    Display status for GSS_S_COMPLETE => %*s\\n\",\n\t    (int) bufdesc.length, (char *) bufdesc.value);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  /* Encapsulate. */\n  bufdesc.value = (char *) \"context token\";\n  bufdesc.length = strlen (bufdesc.value);\n  maj_stat = gss_encapsulate_token (&bufdesc, GSS_C_NT_USER_NAME, &bufdesc2);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_encapsulate_token() OK\\n\");\n  else\n    fail (\"gss_encapsulate_token() failed (%d)\\n\", maj_stat);\n\n  maj_stat = gss_decapsulate_token (&bufdesc2, GSS_C_NT_ANONYMOUS, &bufdesc);\n  if (maj_stat == GSS_S_DEFECTIVE_TOKEN)\n    success (\"gss_decapsulate_token(bad oid) OK\\n\");\n  else\n    fail (\"gss_decapsulate_token() failed (%d)\\n\", maj_stat);\n\n  n = ((char *)bufdesc2.value)[3];\n  ((char *)bufdesc2.value)[3] = 42;\n  maj_stat = gss_decapsulate_token (&bufdesc2, GSS_C_NT_USER_NAME, &bufdesc);\n  ((char *)bufdesc2.value)[3] = n;\n  if (maj_stat == GSS_S_DEFECTIVE_TOKEN)\n    success (\"gss_decapsulate_token(bad length) OK\\n\");\n  else\n    fail (\"gss_decapsulate_token() failed (%d)\\n\", maj_stat);\n\n  maj_stat = gss_decapsulate_token (&bufdesc2, GSS_C_NT_USER_NAME, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_decapsulate_token() OK\\n\");\n  else\n    fail (\"gss_decapsulate_token() failed (%d)\\n\", maj_stat);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc2);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  if (debug)\n    printf (\"Basic self tests done with %d errors\\n\", error_count);\n\n  return error_count ? 1 : 0;\n}",
      "lines": 375,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/tests/krb5context.c": {
    "display_status_1": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\ndisplay_status_1 (const char *m, OM_uint32 code, int type)\n{\n  OM_uint32 maj_stat, min_stat;\n  gss_buffer_desc msg;\n  OM_uint32 msg_ctx;\n\n  msg_ctx = 0;\n  do\n    {\n      maj_stat = gss_display_status (&min_stat, code,\n\t\t\t\t     type, GSS_C_NO_OID, &msg_ctx, &msg);\n      if (GSS_ERROR (maj_stat))\n\tprintf (\"GSS-API display_status failed on code %d type %d\\n\",\n\t\tcode, type);\n      else\n\t{\n\t  printf (\"GSS-API error %s (%s): %.*s\\n\",\n\t\t  m, type == GSS_C_GSS_CODE ? \"major\" : \"minor\",\n\t\t  (int) msg.length, (char *) msg.value);\n\n\t  gss_release_buffer (&min_stat, &msg);\n\t}\n    }\n  while (!GSS_ERROR (maj_stat) && msg_ctx);\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_status": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ndisplay_status (const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat)\n{\n  display_status_1 (msg, maj_stat, GSS_C_GSS_CODE);\n  display_status_1 (msg, min_stat, GSS_C_MECH_CODE);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  gss_uint32 maj_stat, min_stat, ret_flags, time_rec;\n  gss_buffer_desc bufdesc, bufdesc2;\n  gss_name_t servername = GSS_C_NO_NAME, name;\n  gss_ctx_id_t cctx = GSS_C_NO_CONTEXT;\n  gss_ctx_id_t sctx = GSS_C_NO_CONTEXT;\n  gss_cred_id_t server_creds;\n  Shishi *handle;\n  size_t i;\n  struct gss_channel_bindings_struct cb;\n\n  memset (&cb, 0, sizeof (cb));\n  cb.application_data.length = 3;\n  cb.application_data.value = (char *) \"hej\";\n\n  do\n    if (strcmp (argv[argc - 1], \"-v\") == 0 ||\n\tstrcmp (argv[argc - 1], \"--verbose\") == 0)\n      debug = 1;\n    else if (strcmp (argv[argc - 1], \"-b\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--break-on-error\") == 0)\n      break_on_error = 1;\n    else if (strcmp (argv[argc - 1], \"-h\") == 0 ||\n\t     strcmp (argv[argc - 1], \"-?\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--help\") == 0)\n      {\n\tprintf (\"Usage: %s [-vbh?] [--verbose] [--break-on-error] [--help]\\n\",\n\t\targv[0]);\n\treturn 1;\n      }\n  while (argc-- > 1);\n\n  handle = shishi ();\n\n  /* Name of service. */\n\n  bufdesc.value = (char *) \"host@latte.josefsson.org\";\n  bufdesc.length = strlen (bufdesc.value);\n\n  maj_stat = gss_import_name (&min_stat, &bufdesc,\n\t\t\t      GSS_C_NT_HOSTBASED_SERVICE, &servername);\n  if (GSS_ERROR (maj_stat))\n    fail (\"gss_import_name (host/server)\\n\");\n\n  /* Get credential, for server. */\n\n  maj_stat = gss_acquire_cred (&min_stat, servername, 0,\n\t\t\t       GSS_C_NULL_OID_SET, GSS_C_ACCEPT,\n\t\t\t       &server_creds, NULL, NULL);\n  if (GSS_ERROR (maj_stat))\n    {\n      fail (\"gss_acquire_cred\");\n      display_status (\"acquire credentials\", maj_stat, min_stat);\n    }\n\n  for (i = 0; i < 3; i++)\n    {\n      /* Start client. */\n\n      switch (i)\n\t{\n\tcase 0:\n\t  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t\t   &cctx,\n\t\t\t\t\t   servername,\n\t\t\t\t\t   GSS_KRB5,\n\t\t\t\t\t   GSS_C_MUTUAL_FLAG |\n\t\t\t\t\t   GSS_C_REPLAY_FLAG |\n\t\t\t\t\t   GSS_C_SEQUENCE_FLAG,\n\t\t\t\t\t   0,\n\t\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t   GSS_C_NO_BUFFER, NULL,\n\t\t\t\t\t   &bufdesc2, NULL, NULL);\n\t  if (maj_stat != GSS_S_CONTINUE_NEEDED)\n\t    fail (\"loop 0 init failure\\n\");\n\t  break;\n\n\tcase 1:\n\t  /* Default OID, channel bindings. */\n\t  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t\t   &cctx,\n\t\t\t\t\t   servername,\n\t\t\t\t\t   GSS_C_NO_OID,\n\t\t\t\t\t   GSS_C_MUTUAL_FLAG |\n\t\t\t\t\t   GSS_C_REPLAY_FLAG |\n\t\t\t\t\t   GSS_C_SEQUENCE_FLAG,\n\t\t\t\t\t   0,\n\t\t\t\t\t   &cb,\n\t\t\t\t\t   GSS_C_NO_BUFFER, NULL,\n\t\t\t\t\t   &bufdesc2, NULL, NULL);\n\t  if (maj_stat != GSS_S_CONTINUE_NEEDED)\n\t    fail (\"loop 0 init failure\\n\");\n\t  break;\n\n\tcase 2:\n\t  /* No mutual authentication. */\n\t  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t\t   &cctx,\n\t\t\t\t\t   servername,\n\t\t\t\t\t   GSS_KRB5,\n\t\t\t\t\t   GSS_C_REPLAY_FLAG |\n\t\t\t\t\t   GSS_C_CONF_FLAG |\n\t\t\t\t\t   GSS_C_SEQUENCE_FLAG,\n\t\t\t\t\t   0,\n\t\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t   GSS_C_NO_BUFFER, NULL,\n\t\t\t\t\t   &bufdesc2, &ret_flags, NULL);\n\t  if (ret_flags != (GSS_C_REPLAY_FLAG |\n\t\t\t    GSS_C_CONF_FLAG |\n\t\t\t    GSS_C_SEQUENCE_FLAG | GSS_C_PROT_READY_FLAG))\n\t    fail (\"loop 2 ret_flags failure (%d)\\n\", ret_flags);\n\t  if (maj_stat != GSS_S_COMPLETE)\n\t    fail (\"loop 1 init failure\\n\");\n\t  break;\n\n\tdefault:\n\t  fail (\"default?!\\n\");\n\t  break;\n\t}\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  fail (\"gss_accept_sec_context failure\\n\");\n\t  display_status (\"accept_sec_context\", maj_stat, min_stat);\n\t}\n\n      if (debug)\n\t{\n\t  char *p = bufdesc2.value;\n\t  Shishi_asn1 apreq = shishi_der2asn1_apreq (handle,\n\t\t\t\t\t\t     p + 17,\n\t\t\t\t\t\t     bufdesc2.length - 17);\n\t  printf (\"\\nClient AP-REQ:\\n\\n\");\n\t  shishi_apreq_print (handle, stdout, apreq);\n\t}\n\n      /* Start server. */\n\n      switch (i)\n\t{\n\tcase 0:\n\t  maj_stat = gss_accept_sec_context (&min_stat,\n\t\t\t\t\t     &sctx,\n\t\t\t\t\t     server_creds,\n\t\t\t\t\t     &bufdesc2,\n\t\t\t\t\t     GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t     &name,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &bufdesc,\n\t\t\t\t\t     &ret_flags, &time_rec, NULL);\n\t  if (ret_flags != (GSS_C_MUTUAL_FLAG |\n\t\t\t    /* XXX GSS_C_REPLAY_FLAG |\n\t\t\t       GSS_C_SEQUENCE_FLAG | */\n\t\t\t    GSS_C_PROT_READY_FLAG))\n\t    fail (\"loop 0 accept flag failure (%d)\\n\", ret_flags);\n\t  break;\n\n\tcase 1:\n\t  maj_stat = gss_accept_sec_context (&min_stat,\n\t\t\t\t\t     &sctx,\n\t\t\t\t\t     server_creds,\n\t\t\t\t\t     &bufdesc2,\n\t\t\t\t\t     &cb,\n\t\t\t\t\t     &name,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &bufdesc,\n\t\t\t\t\t     &ret_flags, &time_rec, NULL);\n\t  break;\n\n\tcase 2:\n\t  maj_stat = gss_accept_sec_context (&min_stat,\n\t\t\t\t\t     &sctx,\n\t\t\t\t\t     server_creds,\n\t\t\t\t\t     &bufdesc2,\n\t\t\t\t\t     GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t     &name,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &bufdesc,\n\t\t\t\t\t     &ret_flags, &time_rec, NULL);\n\t  break;\n\tdefault:\n\t  fail (\"default?!\\n\");\n\t  break;\n\t}\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  fail (\"gss_accept_sec_context failure\\n\");\n\t  display_status (\"accept_sec_context\", maj_stat, min_stat);\n\t}\n\n      if (debug)\n\t{\n\t  char *p = bufdesc2.value;\n\t  Shishi_asn1 aprep =\n\t    shishi_der2asn1_aprep (handle, p + 15, bufdesc.length - 15);\n\t  printf (\"\\nServer AP-REP:\\n\\n\");\n\t  shishi_aprep_print (handle, stdout, aprep);\n\t}\n\n      switch (i)\n\t{\n\tcase 0:\n\t  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t\t   &cctx,\n\t\t\t\t\t   servername,\n\t\t\t\t\t   GSS_KRB5,\n\t\t\t\t\t   GSS_C_MUTUAL_FLAG |\n\t\t\t\t\t   GSS_C_REPLAY_FLAG |\n\t\t\t\t\t   GSS_C_SEQUENCE_FLAG,\n\t\t\t\t\t   0,\n\t\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t   &bufdesc, NULL,\n\t\t\t\t\t   &bufdesc2, NULL, NULL);\n\t  break;\n\n\tcase 1:\n\t  /* Check ret_flags. */\n\t  maj_stat = gss_init_sec_context (&min_stat,\n\t\t\t\t\t   GSS_C_NO_CREDENTIAL,\n\t\t\t\t\t   &cctx,\n\t\t\t\t\t   servername,\n\t\t\t\t\t   GSS_KRB5,\n\t\t\t\t\t   GSS_C_MUTUAL_FLAG |\n\t\t\t\t\t   GSS_C_REPLAY_FLAG |\n\t\t\t\t\t   GSS_C_SEQUENCE_FLAG,\n\t\t\t\t\t   0,\n\t\t\t\t\t   GSS_C_NO_CHANNEL_BINDINGS,\n\t\t\t\t\t   &bufdesc, NULL,\n\t\t\t\t\t   &bufdesc2, &ret_flags, &time_rec);\n\t  if (ret_flags != (GSS_C_MUTUAL_FLAG |\n\t\t\t    GSS_C_REPLAY_FLAG |\n\t\t\t    GSS_C_SEQUENCE_FLAG | GSS_C_PROT_READY_FLAG))\n\t    fail (\"loop 1 ret_flags failure (%d)\\n\", ret_flags);\n\t  break;\n\n\t  /* No case 2. */\n\n\tdefault:\n\t  break;\n\t}\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  fail (\"gss_init_sec_context failure (2)\\n\");\n\t  display_status (\"init_sec_context\", maj_stat, min_stat);\n\t}\n\n      {\n\tgss_buffer_desc pt, pt2, ct;\n\tint conf_state;\n\tgss_qop_t qop_state;\n\n\tpt.value = (char *) \"foo\";\n\tpt.length = strlen (pt.value) + 1;\n\tmaj_stat = gss_wrap (&min_stat, cctx, 0, 0, &pt, &conf_state, &ct);\n\tif (GSS_ERROR (maj_stat))\n\t  {\n\t    fail (\"client gss_wrap failure\\n\");\n\t    display_status (\"client wrap\", maj_stat, min_stat);\n\t  }\n\n\tmaj_stat = gss_unwrap (&min_stat, sctx,\n\t\t\t       &ct, &pt2, &conf_state, &qop_state);\n\tif (GSS_ERROR (maj_stat))\n\t  {\n\t    fail (\"server gss_unwrap failure\\n\");\n\t    display_status (\"client wrap\", maj_stat, min_stat);\n\t  }\n\n\tif (pt.length != pt2.length\n\t    || memcmp (pt2.value, pt.value, pt.length) != 0)\n\t  fail (\"wrap+unwrap failed (%d, %d, %.*s)\\n\",\n\t\t(int) pt.length, (int) pt2.length, (int) pt2.length,\n\t\t(char *) pt2.value);\n\n\tgss_release_buffer (&min_stat, &ct);\n\tgss_release_buffer (&min_stat, &pt2);\n      }\n\n      maj_stat = gss_delete_sec_context (&min_stat, &cctx, GSS_C_NO_BUFFER);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  fail (\"client gss_delete_sec_context failure\\n\");\n\t  display_status (\"client delete_sec_context\", maj_stat, min_stat);\n\t}\n\n      maj_stat = gss_delete_sec_context (&min_stat, &sctx, GSS_C_NO_BUFFER);\n      if (GSS_ERROR (maj_stat))\n\t{\n\t  fail (\"server gss_delete_sec_context failure\\n\");\n\t  display_status (\"server delete_sec_context\", maj_stat, min_stat);\n\t}\n\n      success (\"loop %d ok\\n\", (int) i);\n    }\n\n  /* Clean up. */\n\n  maj_stat = gss_release_cred (&min_stat, &server_creds);\n  if (GSS_ERROR (maj_stat))\n    {\n      fail (\"gss_release_cred\");\n      display_status (\"release credentials\", maj_stat, min_stat);\n    }\n\n  maj_stat = gss_release_name (&min_stat, &servername);\n  if (GSS_ERROR (maj_stat))\n    {\n      fail (\"gss_release_name failure\\n\");\n      display_status (\"gss_release_name\", maj_stat, min_stat);\n    }\n\n  shishi_done (handle);\n\n  /* We're done. */\n\n  if (debug)\n    printf (\"Kerberos 5 security context self tests done with %d errors\\n\",\n\t    error_count);\n\n  return error_count ? 1 : 0;\n}",
      "lines": 326,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/tests/saslname.c": {
    "main": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  gss_uint32 maj_stat, min_stat;\n  gss_buffer_desc bufdesc;\n  gss_OID oid;\n\n  do\n    if (strcmp (argv[argc - 1], \"-v\") == 0 ||\n\tstrcmp (argv[argc - 1], \"--verbose\") == 0)\n      debug = 1;\n    else if (strcmp (argv[argc - 1], \"-b\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--break-on-error\") == 0)\n      break_on_error = 1;\n    else if (strcmp (argv[argc - 1], \"-h\") == 0 ||\n\t     strcmp (argv[argc - 1], \"-?\") == 0 ||\n\t     strcmp (argv[argc - 1], \"--help\") == 0)\n      {\n\tprintf (\"Usage: %s [-vbh?] [--verbose] [--break-on-error] [--help]\\n\",\n\t\targv[0]);\n\treturn 1;\n      }\n  while (argc-- > 1);\n\n  maj_stat = gss_inquire_mech_for_saslname (&min_stat, NULL, NULL);\n  if (maj_stat == GSS_S_CALL_INACCESSIBLE_READ)\n    success (\"gss_inquire_mech_for_saslname (NULL, NULL) success\\n\");\n  else\n    fail (\"gss_inquire_mech_for_saslname (NULL, NULL) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  bufdesc.value = NULL;\n  bufdesc.length = 0;\n\n  maj_stat = gss_inquire_mech_for_saslname (&min_stat, &bufdesc, NULL);\n  if (maj_stat == GSS_S_BAD_MECH)\n    success (\"gss_inquire_mech_for_saslname (EMPTY, NULL) success\\n\");\n  else\n    fail (\"gss_inquire_mech_for_saslname (EMPTY, NULL) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n#ifdef USE_KERBEROS5\n  bufdesc.length = 8;\n  bufdesc.value = malloc (bufdesc.length);\n  memcpy (bufdesc.value, \"GS2-KRB5\", bufdesc.length);\n\n  maj_stat = gss_inquire_mech_for_saslname (&min_stat, &bufdesc, NULL);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_mech_for_saslname (GS2-KRB5, NULL) success\\n\");\n  else\n    fail (\"gss_inquire_mech_for_saslname (GS2-KRB5, NULL) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  maj_stat = gss_inquire_mech_for_saslname (&min_stat, &bufdesc, &oid);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_mech_for_saslname (GS2-KRB5, OID) success\\n\");\n  else\n    fail (\"gss_inquire_mech_for_saslname (GS2-KRB5, OID) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  if (oid != GSS_KRB5 || !gss_oid_equal (oid, GSS_KRB5))\n    fail (\"GS2-OID not Krb5?!\\n\");\n\n  free (bufdesc.value);\n#endif\n\n  maj_stat =\n    gss_inquire_saslname_for_mech (&min_stat, NULL, NULL, NULL, NULL);\n  if (maj_stat == GSS_S_CALL_INACCESSIBLE_READ)\n    success (\"gss_inquire_saslname_for_mech (NULL) success\\n\");\n  else\n    fail (\"gss_inquire_saslname_for_mech (NULL) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  maj_stat = gss_inquire_saslname_for_mech (&min_stat, GSS_C_NT_USER_NAME,\n\t\t\t\t\t    NULL, NULL, NULL);\n  if (maj_stat == GSS_S_BAD_MECH)\n    success (\"gss_inquire_saslname_for_mech (NT_USER_NAME) success\\n\");\n  else\n    fail (\"gss_inquire_saslname_for_mech (NT_USER_NAME) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n#ifdef USE_KERBEROS5\n  maj_stat = gss_inquire_saslname_for_mech (&min_stat, GSS_KRB5,\n\t\t\t\t\t    NULL, NULL, NULL);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_saslname_for_mech (GSS-KRB5) success\\n\");\n  else\n    fail (\"gss_inquire_saslname_for_mech (GSS-KRB5) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  bufdesc.value = NULL;\n  bufdesc.length = 0;\n\n  maj_stat = gss_inquire_saslname_for_mech (&min_stat, GSS_KRB5,\n\t\t\t\t\t    &bufdesc, NULL, NULL);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_saslname_for_mech (GSS-KRB5) success: %.*s\\n\",\n\t     (int) bufdesc.length, (char *) bufdesc.value);\n  else\n    fail (\"gss_inquire_saslname_for_mech (GSS-KRB5) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_inquire_saslname_for_mech (&min_stat, GSS_KRB5,\n\t\t\t\t\t    NULL, &bufdesc, NULL);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_saslname_for_mech (GSS-KRB5-2) success: %.*s\\n\",\n\t     (int) bufdesc.length, (char *) bufdesc.value);\n  else\n    fail (\"gss_inquire_saslname_for_mech (GSS-KRB5-2) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n\n  maj_stat = gss_inquire_saslname_for_mech (&min_stat, GSS_KRB5,\n\t\t\t\t\t    NULL, NULL, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_inquire_saslname_for_mech (GSS-KRB5-3) success: %.*s\\n\",\n\t     (int) bufdesc.length, (char *) bufdesc.value);\n  else\n    fail (\"gss_inquire_saslname_for_mech (GSS-KRB5-3) failed (%d,%d)\\n\",\n\t  maj_stat, min_stat);\n\n  maj_stat = gss_release_buffer (&min_stat, &bufdesc);\n  if (maj_stat == GSS_S_COMPLETE)\n    success (\"gss_release_buffer() OK\\n\");\n  else\n    fail (\"gss_release_buffer() failed (%d,%d)\\n\", maj_stat, min_stat);\n#endif\n\n  if (debug)\n    printf (\"Basic self tests done with %d errors\\n\", error_count);\n\n  return error_count ? 1 : 0;\n}",
      "lines": 145,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "gss/gss-1.0.3/tests/utils.c": {
    "fail": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "static void\nfail (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  vfprintf (stderr, format, arg_ptr);\n  va_end (arg_ptr);\n  error_count++;\n  if (break_on_error)\n    exit (EXIT_FAILURE);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "success": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\nsuccess (const char *format, ...)\n{\n  va_list arg_ptr;\n\n  va_start (arg_ptr, format);\n  if (debug)\n    vfprintf (stdout, format, arg_ptr);\n  va_end (arg_ptr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  }
}